[
    {
        "title": "Minimum Cost For Tickets",
        "question_content": "You have planned some train traveling one year in advance. The days of the year in which you will travel are given as an integer array days. Each day is an integer from 1 to 365.\nTrain tickets are sold in three different ways:\n\n\ta 1-day pass is sold for costs[0] dollars,\n\ta 7-day pass is sold for costs[1] dollars, and\n\ta 30-day pass is sold for costs[2] dollars.\n\nThe passes allow that many days of consecutive travel.\n\n\tFor example, if we get a 7-day pass on day 2, then we can travel for 7 days: 2, 3, 4, 5, 6, 7, and 8.\n\nReturn the minimum number of dollars you need to travel every day in the given list of days.\n&nbsp;\nExample 1:\n\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\nOutput: 11\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 1-day pass for costs[0] = $2, which covered day 1.\nOn day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9.\nOn day 20, you bought a 1-day pass for costs[0] = $2, which covered day 20.\nIn total, you spent $11 and covered all the days of your travel.\n\nExample 2:\n\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\nOutput: 17\nExplanation: For example, here is one way to buy passes that lets you travel your travel plan:\nOn day 1, you bought a 30-day pass for costs[2] = $15 which covered days 1, 2, ..., 30.\nOn day 31, you bought a 1-day pass for costs[0] = $2 which covered day 31.\nIn total, you spent $17 and covered all the days of your travel.\n\n&nbsp;\nConstraints:\n\n\t1 <= days.length <= 365\n\t1 <= days[i] <= 365\n\tdays is in strictly increasing order.\n\tcosts.length == 3\n\t1 <= costs[i] <= 1000",
        "solutions": [
            {
                "id": 226659,
                "title": "two-dp-solutions-with-pictures",
                "content": "The higher is the bar, the more you\\'re expected to use dynamic programming (DP) during an interview. This technique requires a lot of practice to grasp; if you\\'ve mastered the recursion, DP is the next level.\\n\\nThis problem appeared on LeetCode [weekly contest #121](https://leetcode.com/contest/weekly-contest-121), and it\\'s a good problem to practice the DP thinking.\\n<!--\\n# Problem Description\\nIn a country popular for train travel, you have planned some train travelling one year in advance. The days of the year that you will travel is given as an array days. Each day is an integer from 1 to 365.\\n\\nTrain tickets are sold in 3 different ways:\\n- 1-day pass is sold for costs[0] dollars;\\n- 7-day pass is sold for costs[1] dollars;\\n- 30-day pass is sold for costs[2] dollars.\\n\\nThe passes allow that many days of consecutive travel. For example, if we get a 7-day pass on day 2, then we can travel for 7 days: day 2, 3, 4, 5, 6, 7, and 8.\\n\\nReturn the minimum number of dollars you need to travel every day in the given list of days.\\n# Coding Practice\\nTry solving this problem before moving on to the solutions. It is available on LeetCode Online Judge ([983. Minimum Cost For Tickets](https://leetcode.com/problems/minimum-cost-for-tickets/)). Also, as you read through a solution, try implementing it yourself.\\n\\nLeetCode is my favorite destinations for algorithmic problems. It has 978 problems and counting, with test cases to validate the correctness, as well as computational and memory complexity. There is also a large community discussing different approaches, tips and tricks.\\n-->\\n# Intuition\\nFor each travel day, we can buy a one-day ticket, or use 7-day or 30-day pass as if we would have purchased it 7 or 30 days ago. We need to track rolling costs for at least 30 days back, and use them to pick the cheapest option for the next travel day.\\n\\nHere, we can use two approaches: track cost for all calendar days, or process only travel days. The first approach is simpler to implement, but it\\'s slower. Since the problem is limited to one calendar year, it does not make much of a difference; for a generalized problem I would recommend the second approach.\\n# 1. Track calendar days\\nWe track the minimum cost for all calendar days in ```dp```. For non-travel days, the cost stays the same as for the previous day. For travel days, it\\'s a minimum of yesterday\\'s cost plus single-day ticket, or cost for 8 days ago plus 7-day pass, or cost 31 days ago plus 30-day pass.\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1548621855.png)\\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n  unordered_set<int> travel(begin(days), end(days));\\n  int dp[366] = {};\\n  for (int i = 1; i < 366; ++i) {\\n    if (travel.find(i) == travel.end()) dp[i] = dp[i - 1];\\n    else dp[i] = min({ dp[i - 1] + costs[0], dp[max(0, i - 7)] + costs[1], dp[max(0, i - 30)] + costs[2]});\\n  }\\n  return dp[365];\\n}\\n```\\n# Optimizations\\nIn the previous solution, we store cost for all calendar days. However, since we only look 30 days back, we can just store the cost for last 30 days in a rolling array.\\n\\nIn addition, we can only look at calendar days within our first and last travel dates, as [@zengxinhai](https://leetcode.com/zengxinhai) suggested.\\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n  unordered_set<int> travel(begin(days), end(days));\\n  int dp[30] = {};\\n  for (int i = days.front(); i <= days.back(); ++i) {\\n    if (travel.find(i) == travel.end()) dp[i % 30] = dp[(i - 1) % 30];\\n    else dp[i % 30] = min({ dp[(i - 1) % 30] + costs[0],\\n        dp[max(0, i - 7) % 30] + costs[1], dp[max(0, i - 30) % 30] + costs[2] });\\n  }\\n  return dp[days.back() % 30];\\n}\\n```\\n# Complexity analysis\\n- Time Complexity: O(N), where N is the number of calendar days.\\n- Space Complexity: O(N) or O(31) for the optimized solution. Stricter, it\\'s a maximum duration among all pass types.\\n# 2. Track travel days\\nWe track the minimum ```cost``` for each travel day. We process only travel days and store {day, cost} for 7-and 30-day passes in the ```last7``` and ```last30``` queues. After a pass \\'expires\\', we remove it from the queue. This way, our queues only contains travel days for the last 7 and 30 days, and the cheapest pass prices are in the front of the queues.\\n\\n![image](https://assets.leetcode.com/users/votrubac/image_1548617861.png)\\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs, int cost = 0) {\\n  queue<pair<int, int>> last7, last30;\\n  for (auto d : days) {\\n    while (!last7.empty() && last7.front().first + 7 <= d) last7.pop();\\n    while (!last30.empty() && last30.front().first + 30 <= d) last30.pop();\\n    last7.push({ d, cost + costs[1] });\\n    last30.push({ d, cost + costs[2] });\\n    cost = min({ cost + costs[0], last7.front().second, last30.front().second });\\n  }\\n  return cost;\\n}\\n```\\n# Complexity analysis\\n- Time Complexity: O(n), where n is the number of travel days.\\n- Space Complexity: O(38). Stricter, it\\'s a sum of duration for all pass types (1 + 7 + 30 in our case).",
                "solutionTags": [],
                "code": "```dp```\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n  unordered_set<int> travel(begin(days), end(days));\\n  int dp[366] = {};\\n  for (int i = 1; i < 366; ++i) {\\n    if (travel.find(i) == travel.end()) dp[i] = dp[i - 1];\\n    else dp[i] = min({ dp[i - 1] + costs[0], dp[max(0, i - 7)] + costs[1], dp[max(0, i - 30)] + costs[2]});\\n  }\\n  return dp[365];\\n}\\n```\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n  unordered_set<int> travel(begin(days), end(days));\\n  int dp[30] = {};\\n  for (int i = days.front(); i <= days.back(); ++i) {\\n    if (travel.find(i) == travel.end()) dp[i % 30] = dp[(i - 1) % 30];\\n    else dp[i % 30] = min({ dp[(i - 1) % 30] + costs[0],\\n        dp[max(0, i - 7) % 30] + costs[1], dp[max(0, i - 30) % 30] + costs[2] });\\n  }\\n  return dp[days.back() % 30];\\n}\\n```\n```cost```\n```last7```\n```last30```\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs, int cost = 0) {\\n  queue<pair<int, int>> last7, last30;\\n  for (auto d : days) {\\n    while (!last7.empty() && last7.front().first + 7 <= d) last7.pop();\\n    while (!last30.empty() && last30.front().first + 30 <= d) last30.pop();\\n    last7.push({ d, cost + costs[1] });\\n    last30.push({ d, cost + costs[2] });\\n    cost = min({ cost + costs[0], last7.front().second, last30.front().second });\\n  }\\n  return cost;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 630868,
                "title": "explanation-from-someone-who-took-2-hours-to-solve",
                "content": "**before starting with DP one must master the art of recursion**\\nit took me 2 hours to solve this and 1 hours wo write this post , hopefully you will understand the question. and how we get the solution\\n\\n**step1 : understand the problem**\\nhere we are given days and cost of passes for 1 day pass, week pass, month pass, \"pass means , once you buy it is valid for that some period of time which means free travel during that period\"\\n\\n**step 2: logic building and deriving recurence relation**\\n\\n**1st sub step : asking questions**\\nwhen we buy pass what should we think ? \\nwe should think like, what pass should i buy today ? \\nshould i buy pass of one day , week or month pass ? \\n\\n**2nd sub step : Ariving at recurence relation**\\nif i buy one month pass , then i would be able to travel for next 30 days for free, then my cost will be 30 day pass cost + cost for remaining days after 30 day\\nif i buy one week pass , then i would be able to travel for next 7 days for free, then my cost will be 7 day pass cost + cost for remaining days after 30 day\\nif i buy 1 day pass ....... (\"you get it\");\\n\\nso we can skip to next day OR , next week OR next month ,\\nso cost for i would total pay today is going to be ? ... ? \\n```\\n# a = cost[one day pass] + cost of next day\\n# b = cost[ week pass ] + cost of next day after week\\n# c = cost[ month pass ] + cost of next day after month\\n```\\n\\nie we can skip 1, 7, or 30 days ;\\ncost = min( a , b , c )\\n\\nhere is 1st solution using recursion ( TLE )\\n**step 3: code recursive solution**\\n```\\n int sub(vector<int> &day, vector<int> &cost, int si)\\t\\t// si denotes starting index\\n    {\\n        int n = day.size();\\n        if(si>=n)   return 0;\\n        \\n        int cost_day = cost[0] + sub(day , cost , si+1);\\n        \\n        int i;\\n        for(i = si ; i<n and day[i]<day[si]+7 ; i++);   //skip till ith day is curr_day+7 as we are buying week pass\\n        int cost_week = cost[1] + sub(day, cost, i);\\n        \\n        for(i = si ; i<n and day[i]<day[si]+30 ; i++);   //skip till ith day is curr_day+30 as we are buying month pass\\n        int cost_month = cost[2] + sub(day, cost, i);      \\n        \\n        return min({cost_day, cost_week , cost_month  });\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {        \\n        return sub(days,costs,0);\\n    }\\n```\\nNow you know the sub problems so we can convert OUR recursion solution to top-down-memoization , ie we store our answers at each step before returning, then if we already knows the answer , we can return right back withour re calculating;\\n\\n**step4 : memoization-top-down**\\n```\\nvector<int> dp;\\n    int sub(vector<int> &day, vector<int> &cost, int si)    // subproblem\\n    {\\n        int n = day.size();\\n        if(si>=n)   return 0;\\n        \\n        if(dp[si])  return dp[si];      // ie we aready knows the answer so no need to re calculate , return answer.\\n        \\n        int cost_day = cost[0] + sub(day , cost , si+1);\\n        \\n        int i;\\n        for(i = si ; i<n and day[i]<day[si]+7 ; i++);\\n        int cost_week = cost[1] + sub(day, cost, i);\\n        \\n        for(i = si ; i<n and day[i]<day[si]+30 ; i++);\\n        int cost_month = cost[2] + sub(day, cost, i);     \\n        \\n        dp[si] = min({cost_day, cost_week , cost_month  });   // we store answer for future references \\n        \\n        return dp[si];\\n    } \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {        \\n        dp.resize(367);\\n        return sub(days,costs,0);    \\n    }\\n```\\n\\nso you see , once we get to the recursive solution we converted it into DP top-dow using 3-4 lines.\\n\\n**step 5 : now you know the base casses , you know the sub problems so try coming up with bottom up solution yourself** \\n\\n```\\nint mincostTickets(vector<int>& DAYS, vector<int>& cost) {\\n        \\n        unordered_set<int> days(DAYS.begin(),DAYS.end());\\n        vector<int> dp(367);\\n        \\n        for(int i=1 ; i<366 ; i++)\\n        {\\n            dp[i] = dp[i-1];\\n            if(days.find(i) != days.end())\\n            {\\n\\t\\t\\t// cost of ith day , decision of ith day will be\\n                dp[i] = min({ dp[i - 1] + cost[0],   // 1st case\\n                             dp[max(0, i - 7)] + cost[1],  // 2nd case\\n                             dp[max(0, i - 30)] + cost[2]});  // 3rd case\\n            }\\n        }\\n        return dp[365];\\n    }\\n```\\n\\n**thanks for reading**\\n**previous tutorial on DP** \\nhttps://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/discuss/642422/Lets-solve-it-together-%3A-step-by-step\\n\\nhttps://leetcode.com/problems/dungeon-game/discuss/745340/post-Dedicated-to-beginners-of-DP",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n# a = cost[one day pass] + cost of next day\\n# b = cost[ week pass ] + cost of next day after week\\n# c = cost[ month pass ] + cost of next day after month\\n```\n```\\n int sub(vector<int> &day, vector<int> &cost, int si)\\t\\t// si denotes starting index\\n    {\\n        int n = day.size();\\n        if(si>=n)   return 0;\\n        \\n        int cost_day = cost[0] + sub(day , cost , si+1);\\n        \\n        int i;\\n        for(i = si ; i<n and day[i]<day[si]+7 ; i++);   //skip till ith day is curr_day+7 as we are buying week pass\\n        int cost_week = cost[1] + sub(day, cost, i);\\n        \\n        for(i = si ; i<n and day[i]<day[si]+30 ; i++);   //skip till ith day is curr_day+30 as we are buying month pass\\n        int cost_month = cost[2] + sub(day, cost, i);      \\n        \\n        return min({cost_day, cost_week , cost_month  });\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {        \\n        return sub(days,costs,0);\\n    }\\n```\n```\\nvector<int> dp;\\n    int sub(vector<int> &day, vector<int> &cost, int si)    // subproblem\\n    {\\n        int n = day.size();\\n        if(si>=n)   return 0;\\n        \\n        if(dp[si])  return dp[si];      // ie we aready knows the answer so no need to re calculate , return answer.\\n        \\n        int cost_day = cost[0] + sub(day , cost , si+1);\\n        \\n        int i;\\n        for(i = si ; i<n and day[i]<day[si]+7 ; i++);\\n        int cost_week = cost[1] + sub(day, cost, i);\\n        \\n        for(i = si ; i<n and day[i]<day[si]+30 ; i++);\\n        int cost_month = cost[2] + sub(day, cost, i);     \\n        \\n        dp[si] = min({cost_day, cost_week , cost_month  });   // we store answer for future references \\n        \\n        return dp[si];\\n    } \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {        \\n        dp.resize(367);\\n        return sub(days,costs,0);    \\n    }\\n```\n```\\nint mincostTickets(vector<int>& DAYS, vector<int>& cost) {\\n        \\n        unordered_set<int> days(DAYS.begin(),DAYS.end());\\n        vector<int> dp(367);\\n        \\n        for(int i=1 ; i<366 ; i++)\\n        {\\n            dp[i] = dp[i-1];\\n            if(days.find(i) != days.end())\\n            {\\n\\t\\t\\t// cost of ith day , decision of ith day will be\\n                dp[i] = min({ dp[i - 1] + cost[0],   // 1st case\\n                             dp[max(0, i - 7)] + cost[1],  // 2nd case\\n                             dp[max(0, i - 30)] + cost[2]});  // 3rd case\\n            }\\n        }\\n        return dp[365];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227130,
                "title": "java-dp-solution-with-detailed-comment-and-explanation",
                "content": "dp[i] means up to i-th day the minimum cost of the tickets. The size of the dp array depends on the last travel day, so we don\\'t need an array length to be 365.\\n\\nWe do need a boolean array to mark the travel days, the reason is if it is not a travel day we don\\'t need a ticket. However, if it is a travel day, we consider three scenarios (with three types of tickects):\\n\\nIf a 1-day ticket on day i, dp[i] = dp[i - 1] + cost[0]\\nIf a 7-day ticket ending on day i, dp[i] = min(dp[i - 7], dp[i - 6] ... dp[i - 1]) + cost[1]\\nIf a 30-day ticket ending on day i, dp[i] = min(dp[i - 30], dp[i - 29] ... dp[i - 1]) + cost[2]\\n\\nBut since the value of dp array is increasing, therefore:\\nFor a 7-day ticket ending on day i, dp[i] = dp[i - 7] + cost[1] \\nFor a 30-day ticket ending on day i, dp[i] = dp[i - 30] + cost[2] \\n\\n\\n\\t public int mincostTickets(int[] days, int[] costs) {\\n\\t    // length up to the last travel + 1 day is good enough (no need for 365)\\n        int lastDay = days[days.length - 1]; \\n        // dp[i] means up to i-th day the minimum cost of the tickets\\n        int[] dp = new int[lastDay + 1]; \\n        boolean[] isTravelDays = new boolean[lastDay + 1];\\n        // mark the travel days\\n        for(int day : days) isTravelDays[day] = true;\\n        \\n        for(int i = 1; i <= lastDay; i++) {\\n            if(!isTravelDays[i]) { // no need to buy ticket if it is not a travel day\\n                dp[i] = dp[i - 1];\\n                continue;\\n            }\\n            // select which type of ticket to buy\\n            dp[i] = costs[0] + dp[i - 1]; // 1-day\\n            dp[i] = Math.min(costs[1] + dp[Math.max(i - 7, 0)], dp[i]); // 7-day\\n            dp[i] = Math.min(costs[2] + dp[Math.max(i - 30, 0)], dp[i]); // 30-day\\n        }\\n        return dp[lastDay];\\n    }",
                "solutionTags": [],
                "code": "dp[i] means up to i-th day the minimum cost of the tickets. The size of the dp array depends on the last travel day, so we don\\'t need an array length to be 365.\\n\\nWe do need a boolean array to mark the travel days, the reason is if it is not a travel day we don\\'t need a ticket. However, if it is a travel day, we consider three scenarios (with three types of tickects):\\n\\nIf a 1-day ticket on day i, dp[i] = dp[i - 1] + cost[0]\\nIf a 7-day ticket ending on day i, dp[i] = min(dp[i - 7], dp[i - 6] ... dp[i - 1]) + cost[1]\\nIf a 30-day ticket ending on day i, dp[i] = min(dp[i - 30], dp[i - 29] ... dp[i - 1]) + cost[2]\\n\\nBut since the value of dp array is increasing, therefore:\\nFor a 7-day ticket ending on day i, dp[i] = dp[i - 7] + cost[1] \\nFor a 30-day ticket ending on day i, dp[i] = dp[i - 30] + cost[2] \\n\\n\\n\\t public int mincostTickets(int[] days, int[] costs) {\\n\\t    // length up to the last travel + 1 day is good enough (no need for 365)\\n        int lastDay = days[days.length - 1]; \\n        // dp[i] means up to i-th day the minimum cost of the tickets\\n        int[] dp = new int[lastDay + 1]; \\n        boolean[] isTravelDays = new boolean[lastDay + 1];\\n        // mark the travel days\\n        for(int day : days) isTravelDays[day] = true;\\n        \\n        for(int i = 1; i <= lastDay; i++) {\\n            if(!isTravelDays[i]) { // no need to buy ticket if it is not a travel day\\n                dp[i] = dp[i - 1];\\n                continue;\\n            }\\n            // select which type of ticket to buy\\n            dp[i] = costs[0] + dp[i - 1]; // 1-day\\n            dp[i] = Math.min(costs[1] + dp[Math.max(i - 7, 0)], dp[i]); // 7-day\\n            dp[i] = Math.min(costs[2] + dp[Math.max(i - 30, 0)], dp[i]); // 30-day\\n        }\\n        return dp[lastDay];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 226670,
                "title": "java-dp-solution-with-explanation-o-n",
                "content": "Let minCost(i) denote the minimum cost that will be payed for all trips on days 1 to day 365.\\nThe desired answer is then minCost(365).\\n\\nCalculation minCost(i):\\n\\nIf no trip on day i, then minCost(i) = minCost(i-1).\\n minCost(i)=0 for all i \\u2264 0.\\nOtherwise:\\nIf a 1-day pass on day i. In this case,  minCost(i) =  minCost(i) + costs[0].\\nIf a 7-day pass ending on day i. then : In this case, minCost(i) = min(minCost(i \\u2212 7), minCost(i \\u2212 6), \\u2026, minCost(i \\u2212 1)) + costs[1].\\nBut since since minCost is increasing (adding a day never reduces the minCost) hence:\\n minCost(i) = minCost(i \\u2212 7) + costs[2]\\n\\nSame case for 30-day pass also.\\n\\n```\\npublic int mincostTickets(int[] days, int[] costs) {\\n        boolean[] dayIncluded = new boolean[366];\\n        for (int day : days) {\\n            dayIncluded[day] = true;\\n        }\\n        int[] minCost = new int[366];\\n        minCost[0] = 0;\\n        for (int day = 1; day <= 365; ++day) {\\n            if (!dayIncluded[day]) {\\n                minCost[day] = minCost[day-1];\\n                continue;\\n            }\\n            int min;\\n            min = minCost[day-1] + costs[0];\\n            min =Math.min(min, minCost[Math.max(0, day-7)] + costs[1]);\\n            min = Math.min(min, minCost[Math.max(0, day-30)] + costs[2]);\\n            minCost[day] = min;\\n        }\\n\\n        return minCost[365];\\n\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int mincostTickets(int[] days, int[] costs) {\\n        boolean[] dayIncluded = new boolean[366];\\n        for (int day : days) {\\n            dayIncluded[day] = true;\\n        }\\n        int[] minCost = new int[366];\\n        minCost[0] = 0;\\n        for (int day = 1; day <= 365; ++day) {\\n            if (!dayIncluded[day]) {\\n                minCost[day] = minCost[day-1];\\n                continue;\\n            }\\n            int min;\\n            min = minCost[day-1] + costs[0];\\n            min =Math.min(min, minCost[Math.max(0, day-7)] + costs[1]);\\n            min = Math.min(min, minCost[Math.max(0, day-30)] + costs[2]);\\n            minCost[day] = min;\\n        }\\n\\n        return minCost[365];\\n\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 228421,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def mincostTickets(self, days, costs):\\n        \"\"\"\\n        :type days: List[int]\\n        :type costs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp=[0 for i in range(days[-1]+1)]\\n        for i in range(days[-1]+1):\\n             if i not in days:\\n                dp[i]=dp[i-1]\\n             else:\\n                dp[i]=min(dp[max(0,i-7)]+costs[1],dp[max(0,i-1)]+costs[0],dp[max(0,i-30)]+costs[2])\\n        return dp[-1]\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def mincostTickets(self, days, costs):\\n        \"\"\"\\n        :type days: List[int]\\n        :type costs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp=[0 for i in range(days[-1]+1)]\\n        for i in range(days[-1]+1):\\n             if i not in days:\\n                dp[i]=dp[i-1]\\n             else:\\n                dp[i]=min(dp[max(0,i-7)]+costs[1],dp[max(0,i-1)]+costs[0],dp[max(0,i-30)]+costs[2])\\n        return dp[-1]\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810806,
                "title": "python-dp-solution-explanation",
                "content": "**Explanation:**\\n\\ndp[i] means overall costs untill i-th day (included)\\nwe have to check two conditions:\\n\\n**1. i in days list:**\\nwe have three option:\\na) 1-pass:` dp[i] = dp[i-1] + costs[0]`\\nb) 7-pass: `dp[i] = dp[i-7] + costs[1]`\\nc) 30-pass:` dp[i] = dp[i-30] + costs[2]`\\n*in order to avoid negative index:*\\na) 1-pass:` dp[i] =dp[max(0,i-1)] + costs[0]`\\nb) 7-pass: `dp[i] = dp[max(0,i-7)] + costs[1]`\\nc) 30-pass:` dp[i] = dp[max(0,i-30)] + costs[2]`\\n**2. i not in days:**\\ndp[i] = dp[i-1] \\nwhich simply means we don\\'t have to spend money, and total costs remains same\\n\\n```\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\tdp=[0 for i in range(days[-1]+1)]\\n\\tdy = set(days)\\n\\tfor i in range(days[-1]+1):\\n\\t\\tif i not in dy: dp[i]=dp[i-1]\\n\\t\\telse: dp[i]=min(dp[max(0,i-7)]+costs[1],dp[max(0,i-1)]+costs[0],dp[max(0,i-30)]+costs[2])\\n\\treturn dp[-1]\\n```\\n***\\n**Time complexity:** `O(n)`\\n**Space complexity:**` O(n)`\\nn = last day in days list + 1, time & space complexity max: `O(366)`",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\tdp=[0 for i in range(days[-1]+1)]\\n\\tdy = set(days)\\n\\tfor i in range(days[-1]+1):\\n\\t\\tif i not in dy: dp[i]=dp[i-1]\\n\\t\\telse: dp[i]=min(dp[max(0,i-7)]+costs[1],dp[max(0,i-1)]+costs[0],dp[max(0,i-30)]+costs[2])\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 227321,
                "title": "top-down-dp-logical-thinking",
                "content": "> Intuitively, we calculate total costs for each possible way of buying tickets and found the one with the minimum cost.\\n> That causes TLE.\\n> Why does it cause TLE? Because there are duplicate calculations.\\n> \\n\\n> Let\\'s decompose the problem: **minimum cost from day[i]** for i is the next day to buy tickets\\n> on day[i],  we can buy 1-day pass, 7-day pass or 30-day pass.\\n> - If we buy 1-day pass, cost from day[i] = costs[0] + **minimum cost from day[j]** for j is the next day to buy tickets\\n> - If we buy 7-day pass, cost from day[i] = costs[1] + **minimum cost from day[j]** for j is the next day to buy tickets\\n> - If we buy 30-day pass, cost from day[i] = costs[2] + **minimum cost from day[j]** for j is the next day to buy tickets\\n> \\n>**minimum cost from day[i]** is the minimum among 3 costs above\\n>Optimal substructure is found. We could apply dynamic programing.\\n\\n****\\n```\\n    private int[] memo;\\n    \\n    public int mincostTickets(int[] days, int[] costs) {\\n        memo = new int[days.length];\\n        return mincostTickets(0, days, costs);\\n    }\\n    \\n    private int mincostTickets(int dayIndex, int[] days, int[] costs) {\\n        if (dayIndex == days.length) {\\n            return 0;\\n        }\\n        \\n        if (memo[dayIndex] != 0) {\\n            return memo[dayIndex];\\n        }\\n        \\n        // Choose a pass, update dayIndex, and accumulate totalCost\\n        int totalCostDay = costs[0] + mincostTickets(getNextDayToBuy(dayIndex, days, 1), days, costs);   \\n        int totalCostWeek = costs[1] + mincostTickets(getNextDayToBuy(dayIndex, days, 7), days, costs);\\n        int totalCostMonth = costs[2] + mincostTickets(getNextDayToBuy(dayIndex, days, 30), days, costs);\\n        \\n        // Return the one with min totalCost\\n        memo[dayIndex] = Math.min(totalCostMonth, Math.min(totalCostDay, totalCostWeek));\\n        return memo[dayIndex];\\n    }\\n    \\n    private int getNextDayToBuy(int dayIndex, int[] days, int duration) {\\n        int endDay = days[dayIndex] + duration - 1;\\n        int newDayIndex = dayIndex;\\n\\t\\t\\n        while (newDayIndex < days.length && days[newDayIndex] <= endDay) {\\n            newDayIndex++;\\n        }\\n        \\n        return newDayIndex;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    private int[] memo;\\n    \\n    public int mincostTickets(int[] days, int[] costs) {\\n        memo = new int[days.length];\\n        return mincostTickets(0, days, costs);\\n    }\\n    \\n    private int mincostTickets(int dayIndex, int[] days, int[] costs) {\\n        if (dayIndex == days.length) {\\n            return 0;\\n        }\\n        \\n        if (memo[dayIndex] != 0) {\\n            return memo[dayIndex];\\n        }\\n        \\n        // Choose a pass, update dayIndex, and accumulate totalCost\\n        int totalCostDay = costs[0] + mincostTickets(getNextDayToBuy(dayIndex, days, 1), days, costs);   \\n        int totalCostWeek = costs[1] + mincostTickets(getNextDayToBuy(dayIndex, days, 7), days, costs);\\n        int totalCostMonth = costs[2] + mincostTickets(getNextDayToBuy(dayIndex, days, 30), days, costs);\\n        \\n        // Return the one with min totalCost\\n        memo[dayIndex] = Math.min(totalCostMonth, Math.min(totalCostDay, totalCostWeek));\\n        return memo[dayIndex];\\n    }\\n    \\n    private int getNextDayToBuy(int dayIndex, int[] days, int duration) {\\n        int endDay = days[dayIndex] + duration - 1;\\n        int newDayIndex = dayIndex;\\n\\t\\t\\n        while (newDayIndex < days.length && days[newDayIndex] <= endDay) {\\n            newDayIndex++;\\n        }\\n        \\n        return newDayIndex;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 762493,
                "title": "c-dp-solution-w-detailed-explanation",
                "content": "Working Example: days = [1,4,6,7,8,20], costs = [2,7,15]\\nEssentially the question breaks down to \"what is your total expenses on `day 20`\". Since we have three possible tickets with varying durations, the total cost of  `day 20` is either the cost of your total expenses on `day 19` + `2`,  `day 13` + `7`, or `day 0` + `15`, (`day 0` being the day before any possible trip, we can\\'t have negative days). As you can see the total cost of any day relies on the total cost of previous days. Furthermore, you should see that our original problem breaks itself down into the same issue just with earlier days. If you have an idea on how to approach the problem, I suggest you stop reading and try the problem out for yourself.\\n\\n1) This is a classic [Minimum (Maximum) Path to Reach a Target](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns#Minimum-(Maximum)-Path-to-Reach-a-Target) problem. First we have to initialize a vector/array `dp` representing all 365 days plus 1 (`day 0`). Since we are trying to minimize cost, I initalize the total cost of each day to `INT_MAX`. However, if `dp[0]` or `day 0` represents the day before any trip we shouldn\\'t have to minimize the cost of this day thus its value is set to zero.\\n\\n```\\nunordered_map<int,int> tickets;\\n        tickets[1] = costs[0];\\n        tickets[7] = costs[1];\\n        tickets[30] = costs[2];\\n\\t\\t\\nvector<int> dp(366, INT_MAX);\\ndp[0] = 0\\n```\\n*You could do some clever indexing with `dp[0]` and `dp[n]` representing your first and last trip respectively, but I found that to be overall too confusing. (It is also here I initialized the cost and duration of each ticket*\\n\\n2) We take a bottom-up approach to this problem as before answering `dp[20]` we answer `dp[19]`, `dp[13]`, etc. Also note that we start on `day 1` as we are not trying to minimize the cost of `day 0`\\n```\\nfor(int i=1; i<366; ++i){\\n//...\\n}\\n```\\n\\n3) Taking our idea from our intro and `2)` we have our solution. We should note that if `day i` is not included in our argument `days` that day\\'s total expensenses is equal `day i-1` since we didn\\'t have to consider buying a ticket.\\n```\\nif(find(days.begin(), days.end(), i) == days.end()){\\n\\tdp[i] = dp[i-1];\\n\\tcontinue;\\n}\\nfor(auto ticket : tickets){\\n\\tdp[i] = min(dp[i], dp[max(0, i-ticket.first)] + ticket.second);\\n}\\n```\\n\\n4) **To illustrate the process**\\n* dp[1] = 2 or `min(dp[0] + 2 dp[0] + 7, dp[0] + 15)`\\n* dp[2] = 2 (we don\\'t have to consider buying a ticket here so we just take the total cost of the previous day)\\n* dp[3] = 2 \\n* dp[4] = 4 or `min(dp[3] + 2, dp[0] + 7, dp[0] + 15)`\\n* dp[5] = 4\\n* dp[6] = 6\\n* dp[7] = 7 or `min(dp[6] + 2, dp[0] + 7, + dp[0]  + 15)`\\n* dp[8] = 9 or `min(dp[7] + 2, dp[1] + 7, + dp[0] + 15)` \\n* etc.\\n*Technically we could just break out of the loop on the last day, but I chose not too. After the last day, the total expenses will remain the same because of our if statement.*\\n\\n5) **Full Solution** (please don\\'t copy pasta the solution without reading the post!)\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        unordered_map<int,int> tickets;\\n        tickets[1] = costs[0];\\n        tickets[7] = costs[1];\\n        tickets[30] = costs[2];\\n        \\n        vector<int> dp(366, INT_MAX);\\n        dp[0] = 0;\\n        for(int i=1; i<366; ++i){\\n            if(find(days.begin(), days.end(), i) == days.end()){\\n                dp[i] = dp[i-1];\\n                continue;\\n            }\\n            for(auto ticket : tickets){\\n                dp[i] = min(dp[i], dp[max(0, i-ticket.first)] + ticket.second);\\n            }\\n        }\\n        \\n        return dp[365];\\n    }\\n};\\n```\\n6) Useful [post](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns) for those starting out with DP\\n7) Don\\'t forget to upvote if this post helped you :)\\n...if it didn\\'t please don\\'t downvote... I\\'m sorry I can change!\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nunordered_map<int,int> tickets;\\n        tickets[1] = costs[0];\\n        tickets[7] = costs[1];\\n        tickets[30] = costs[2];\\n\\t\\t\\nvector<int> dp(366, INT_MAX);\\ndp[0] = 0\\n```\n```\\nfor(int i=1; i<366; ++i){\\n//...\\n}\\n```\n```\\nif(find(days.begin(), days.end(), i) == days.end()){\\n\\tdp[i] = dp[i-1];\\n\\tcontinue;\\n}\\nfor(auto ticket : tickets){\\n\\tdp[i] = min(dp[i], dp[max(0, i-ticket.first)] + ticket.second);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        unordered_map<int,int> tickets;\\n        tickets[1] = costs[0];\\n        tickets[7] = costs[1];\\n        tickets[30] = costs[2];\\n        \\n        vector<int> dp(366, INT_MAX);\\n        dp[0] = 0;\\n        for(int i=1; i<366; ++i){\\n            if(find(days.begin(), days.end(), i) == days.end()){\\n                dp[i] = dp[i-1];\\n                continue;\\n            }\\n            for(auto ticket : tickets){\\n                dp[i] = min(dp[i], dp[max(0, i-ticket.first)] + ticket.second);\\n            }\\n        }\\n        \\n        return dp[365];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810749,
                "title": "python-js-go-c-by-dp-w-visualization",
                "content": "**Hint**:\\n\\nOptimal substructure for DP\\n\\n----\\n\\nBase case:\\n```\\n# no cost before first day (i.e., no travel)\\ndp[ 0 ] = 0\\n```\\n\\n---\\n\\nGeneral case:\\n\\nFor non-traveling day:\\n\\n```\\n# today is not traveling day, no extra cost\\n\\ndp[ d ] = dp[ d - 1 ] \\n```\\n\\n---\\n\\nFor traveling day:\\n\\n```\\n\\n# compute minimum cost from subproblem\\n\\ndp[ d ] = min( dp[     d - 1      ] + cost[0],\\n               dp[ max(d - 7, 0)  ] + cost[1],\\n\\t\\t\\t   dp[ max(d - 30, 0) ] + cost[2] )\\n\\n# cost[0]: the cost of 1-day-pass ticket\\n# cost[1]: the cost of 7-day-pass ticket\\n# cost[2]: the cost of 30-day-pass ticket\\n```\\n\\nNote:\\nHere we use **max**( d-7, **0**) and **max**( d-30, **0**) to **avoid invalid day index** which is out-of-boundary.\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/6d6e30e1-bffe-4911-868c-e3b347944696_1598355889.9800591.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/4c9f0064-9f1d-411e-9759-009f42b80128_1598355901.5866375.png)\\n\\n---\\n\\n![image](https://assets.leetcode.com/users/images/9dcadfdb-1428-4b94-a2e2-e2e97e464a4e_1598355916.5972583.png)\\n\\n---\\n\\n**Implementation** by Bottom-up DP with iteration (i.e., tabulation method)\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        \\n        # index of ticket\\n        _1day_pass, _7day_pass, _30day_pass = 0, 1, 2\\n        \\n        # set of travel days\\n        travel_days = set(days)\\n        \\n        # last travel day\\n        last_traverl_day = days[-1]\\n        \\n        # DP Table, record for minimum cost of ticket to travel\\n        dp_cost = [  0 for _ in range(last_traverl_day+1)]\\n    \\n        \\n        # Solve min cost by Dynamic Programming\\n        for day_i in range(1, last_traverl_day+1):\\n            \\n            \\n            if day_i not in travel_days:\\n                \\n                # today is not traveling day\\n                # no extra cost\\n                dp_cost[day_i] = dp_cost[day_i - 1]\\n            \\n            \\n            else:\\n                \\n                # today is traveling day\\n                # compute optimal cost by DP\\n                \\n                dp_cost[day_i] = min(   dp_cost[ day_i - 1 ]  + costs[ _1day_pass ],\\n                                        dp_cost[ max(day_i - 7, 0) ]  + costs[ _7day_pass ],\\n                                        dp_cost[ max(day_i - 30, 0) ] + costs[ _30day_pass ]     )\\n        \\n        \\n        # Cost on last travel day of this year is the answer\\n        return dp_cost[last_traverl_day]\\n        \\n```\\n\\n---\\n\\n**Implementaion** by Top-down DP with recursion + memoization\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        \\n        # to speed up element checking for days\\n        travel_days = set(days)\\n        \\n        # ---------------------------------------------------\\n        \\n        # use python built-in cache as memoization for DP\\n        @cache\\n        def dp(day_d):\\n            \\n            ## Base case\\n            if day_d == 0:\\n                \\n                # no cost on before traveling\\n                return 0\\n            \\n            ## General cases\\n            if day_d not in travel_days:\\n                \\n                # no extra cost on non-traverl day\\n                return dp(day_d-1)\\n            \\n            else:\\n                \\n                # compute minimal cost on travel day\\n                \\n                with_1_day_pass = dp( day_d-1 ) + costs[0]\\n                with_7_day_pass = dp( max( day_d - 7, 0) ) + costs[1]\\n                with_30_day_pass = dp( max( day_d - 30, 0) ) + costs[2]\\n                \\n                return min( with_1_day_pass, with_7_day_pass, with_30_day_pass)\\n            \\n        # ---------------------------------------------------\\n        last_travel_day = days[-1]\\n        \\n        return dp(last_travel_day)\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar mincostTickets = function(days, costs) {\\n    \\n    // index of ticket\\n    const [ _1day, _7day, _30day] = [0, 1, 2];\\n    \\n    // set of travel days\\n    let travelDays = new Set(days);\\n    \\n    let lastTravelDay = days[days.length-1];\\n    \\n    // DP table, record for minimum cost of ticket to travel\\n    dpCost = new Array( lastTravelDay+1 ).fill(0);\\n    \\n    // solve min cost by DP\\n    for( let day_i=1; day_i <= lastTravelDay ; day_i++ ){\\n        \\n        if( travelDays.has(day_i) == false ){\\n            \\n            // today is not traveling day\\n            // no extra cost\\n            dpCost[ day_i ] = dpCost[ day_i - 1 ];\\n            \\n        }else{\\n            \\n            // today is traveling day\\n            // compute optimal min cost\\n            dpCost[ day_i ] = Math.min( dpCost[ day_i - 1 ] + costs[ _1day ],\\n                                        dpCost[ Math.max(day_i - 7, 0) ] + costs[ _7day ], \\n                                        dpCost[ Math.max(day_i - 30, 0) ] + costs[_30day]  );\\n        }\\n    }\\n\\n    return dpCost[lastTravelDay];\\n    \\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\n// Golang doesn\\'t have natural built in min/max function for integers\\n// Programmer have to implement it manually\\nfunc MinOf(vars ...int) int {\\n    min := vars[0]\\n\\n    for _, i := range vars {\\n        if min > i {\\n            min = i\\n        }\\n    }\\n\\n    return min\\n}\\n\\n\\nfunc Max( x, y int) int {\\n    \\n    if x > y{\\n        return x\\n    }else{\\n        return y\\n    }\\n    \\n}\\n\\n\\ntype void struct{}\\nvar member void\\n\\nfunc mincostTickets(days []int, costs []int) int {\\n    \\n    // help reader to understand code, to avoid magic number\\n    const _1day, _7day, _30day = 0, 1, 2\\n    \\n    // set of travel days\\n    travelDays := make( map[int]void )\\n    \\n    for _, curTravelDay := range days{\\n        travelDays[ curTravelDay ] = member\\n    }\\n    \\n    // last travel day from input array\\n    lastTraverlDay := days[ len(days) - 1 ]\\n    \\n    // dp table\\n    dpCost := make([]int, lastTraverlDay+1)\\n    \\n    for day_i := 1 ; day_i <= lastTraverlDay ; day_i++ {\\n        \\n        if _, isTravelDay := travelDays[day_i] ; isTravelDay == false{\\n            \\n            // today is not traveling day\\n            // no extra cost\\n            dpCost[ day_i ] = dpCost[ day_i -1 ]\\n        \\n        }else{\\n            \\n                // today is traveling day\\n                // compute optimal cost by DP\\n                \\n                dpCost[day_i] = MinOf( dpCost[ day_i - 1 ]  + costs[ _1day ],\\n                                        dpCost[ Max(day_i - 7, 0) ]  + costs[ _7day ],\\n                                        dpCost[ Max(day_i - 30, 0) ] + costs[ _30day ]     )\\n        }\\n    }\\n    \\n    return dpCost[ lastTraverlDay ]\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        // index of ticket\\n        enum Ticket { _1day, _7day, _30day };\\n        \\n        \\n        // set of travel days\\n        set<int> travelDays = set<int>(days.begin(), days.end());\\n        \\n        int lastTravelDay = days.back();\\n        \\n        // dp table, record for minimum cost ofticket to travel\\n        vector<int> dpCost = vector<int>( lastTravelDay+1 );\\n        \\n        // Solve min cost by DP\\n        for( int day_i = 1; day_i <= lastTravelDay ; day_i++ ){\\n            \\n            if( travelDays.count(day_i) == 0 ){\\n                \\n                // today is not traveling day\\n                // no extra cost\\n                dpCost[ day_i ] = dpCost[ day_i - 1 ];\\n                \\n            }else{\\n                \\n                // today is traveling day\\n                // compute optimal cost by DP\\n                dpCost[ day_i ] = min( {dpCost[ day_i - 1 ]            + costs[ _1day ], \\n                                        dpCost[ max(day_i - 7, 0) ]    + costs[ _7day ], \\n                                        dpCost[ max(day_i - 30, 0) ]   + costs[ _30day]} );\\n            }\\n        }\\n\\n        return dpCost[lastTravelDay];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming"
                ],
                "code": "```\\n# no cost before first day (i.e., no travel)\\ndp[ 0 ] = 0\\n```\n```\\n# today is not traveling day, no extra cost\\n\\ndp[ d ] = dp[ d - 1 ] \\n```\n```\\n\\n# compute minimum cost from subproblem\\n\\ndp[ d ] = min( dp[     d - 1      ] + cost[0],\\n               dp[ max(d - 7, 0)  ] + cost[1],\\n\\t\\t\\t   dp[ max(d - 30, 0) ] + cost[2] )\\n\\n# cost[0]: the cost of 1-day-pass ticket\\n# cost[1]: the cost of 7-day-pass ticket\\n# cost[2]: the cost of 30-day-pass ticket\\n```\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        \\n        # index of ticket\\n        _1day_pass, _7day_pass, _30day_pass = 0, 1, 2\\n        \\n        # set of travel days\\n        travel_days = set(days)\\n        \\n        # last travel day\\n        last_traverl_day = days[-1]\\n        \\n        # DP Table, record for minimum cost of ticket to travel\\n        dp_cost = [  0 for _ in range(last_traverl_day+1)]\\n    \\n        \\n        # Solve min cost by Dynamic Programming\\n        for day_i in range(1, last_traverl_day+1):\\n            \\n            \\n            if day_i not in travel_days:\\n                \\n                # today is not traveling day\\n                # no extra cost\\n                dp_cost[day_i] = dp_cost[day_i - 1]\\n            \\n            \\n            else:\\n                \\n                # today is traveling day\\n                # compute optimal cost by DP\\n                \\n                dp_cost[day_i] = min(   dp_cost[ day_i - 1 ]  + costs[ _1day_pass ],\\n                                        dp_cost[ max(day_i - 7, 0) ]  + costs[ _7day_pass ],\\n                                        dp_cost[ max(day_i - 30, 0) ] + costs[ _30day_pass ]     )\\n        \\n        \\n        # Cost on last travel day of this year is the answer\\n        return dp_cost[last_traverl_day]\\n        \\n```\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        \\n        # to speed up element checking for days\\n        travel_days = set(days)\\n        \\n        # ---------------------------------------------------\\n        \\n        # use python built-in cache as memoization for DP\\n        @cache\\n        def dp(day_d):\\n            \\n            ## Base case\\n            if day_d == 0:\\n                \\n                # no cost on before traveling\\n                return 0\\n            \\n            ## General cases\\n            if day_d not in travel_days:\\n                \\n                # no extra cost on non-traverl day\\n                return dp(day_d-1)\\n            \\n            else:\\n                \\n                # compute minimal cost on travel day\\n                \\n                with_1_day_pass = dp( day_d-1 ) + costs[0]\\n                with_7_day_pass = dp( max( day_d - 7, 0) ) + costs[1]\\n                with_30_day_pass = dp( max( day_d - 30, 0) ) + costs[2]\\n                \\n                return min( with_1_day_pass, with_7_day_pass, with_30_day_pass)\\n            \\n        # ---------------------------------------------------\\n        last_travel_day = days[-1]\\n        \\n        return dp(last_travel_day)\\n```\n```\\nvar mincostTickets = function(days, costs) {\\n    \\n    // index of ticket\\n    const [ _1day, _7day, _30day] = [0, 1, 2];\\n    \\n    // set of travel days\\n    let travelDays = new Set(days);\\n    \\n    let lastTravelDay = days[days.length-1];\\n    \\n    // DP table, record for minimum cost of ticket to travel\\n    dpCost = new Array( lastTravelDay+1 ).fill(0);\\n    \\n    // solve min cost by DP\\n    for( let day_i=1; day_i <= lastTravelDay ; day_i++ ){\\n        \\n        if( travelDays.has(day_i) == false ){\\n            \\n            // today is not traveling day\\n            // no extra cost\\n            dpCost[ day_i ] = dpCost[ day_i - 1 ];\\n            \\n        }else{\\n            \\n            // today is traveling day\\n            // compute optimal min cost\\n            dpCost[ day_i ] = Math.min( dpCost[ day_i - 1 ] + costs[ _1day ],\\n                                        dpCost[ Math.max(day_i - 7, 0) ] + costs[ _7day ], \\n                                        dpCost[ Math.max(day_i - 30, 0) ] + costs[_30day]  );\\n        }\\n    }\\n\\n    return dpCost[lastTravelDay];\\n    \\n};\\n```\n```\\n// Golang doesn\\'t have natural built in min/max function for integers\\n// Programmer have to implement it manually\\nfunc MinOf(vars ...int) int {\\n    min := vars[0]\\n\\n    for _, i := range vars {\\n        if min > i {\\n            min = i\\n        }\\n    }\\n\\n    return min\\n}\\n\\n\\nfunc Max( x, y int) int {\\n    \\n    if x > y{\\n        return x\\n    }else{\\n        return y\\n    }\\n    \\n}\\n\\n\\ntype void struct{}\\nvar member void\\n\\nfunc mincostTickets(days []int, costs []int) int {\\n    \\n    // help reader to understand code, to avoid magic number\\n    const _1day, _7day, _30day = 0, 1, 2\\n    \\n    // set of travel days\\n    travelDays := make( map[int]void )\\n    \\n    for _, curTravelDay := range days{\\n        travelDays[ curTravelDay ] = member\\n    }\\n    \\n    // last travel day from input array\\n    lastTraverlDay := days[ len(days) - 1 ]\\n    \\n    // dp table\\n    dpCost := make([]int, lastTraverlDay+1)\\n    \\n    for day_i := 1 ; day_i <= lastTraverlDay ; day_i++ {\\n        \\n        if _, isTravelDay := travelDays[day_i] ; isTravelDay == false{\\n            \\n            // today is not traveling day\\n            // no extra cost\\n            dpCost[ day_i ] = dpCost[ day_i -1 ]\\n        \\n        }else{\\n            \\n                // today is traveling day\\n                // compute optimal cost by DP\\n                \\n                dpCost[day_i] = MinOf( dpCost[ day_i - 1 ]  + costs[ _1day ],\\n                                        dpCost[ Max(day_i - 7, 0) ]  + costs[ _7day ],\\n                                        dpCost[ Max(day_i - 30, 0) ] + costs[ _30day ]     )\\n        }\\n    }\\n    \\n    return dpCost[ lastTraverlDay ]\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        // index of ticket\\n        enum Ticket { _1day, _7day, _30day };\\n        \\n        \\n        // set of travel days\\n        set<int> travelDays = set<int>(days.begin(), days.end());\\n        \\n        int lastTravelDay = days.back();\\n        \\n        // dp table, record for minimum cost ofticket to travel\\n        vector<int> dpCost = vector<int>( lastTravelDay+1 );\\n        \\n        // Solve min cost by DP\\n        for( int day_i = 1; day_i <= lastTravelDay ; day_i++ ){\\n            \\n            if( travelDays.count(day_i) == 0 ){\\n                \\n                // today is not traveling day\\n                // no extra cost\\n                dpCost[ day_i ] = dpCost[ day_i - 1 ];\\n                \\n            }else{\\n                \\n                // today is traveling day\\n                // compute optimal cost by DP\\n                dpCost[ day_i ] = min( {dpCost[ day_i - 1 ]            + costs[ _1day ], \\n                                        dpCost[ max(day_i - 7, 0) ]    + costs[ _7day ], \\n                                        dpCost[ max(day_i - 30, 0) ]   + costs[ _30day]} );\\n            }\\n        }\\n\\n        return dpCost[lastTravelDay];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349729,
                "title": "java-python-and-c-easy-solutions-with-exaplanation-look-at-once",
                "content": "# Intuition\\nThe given code implements a dynamic programming approach to solve the minimum cost ticket problem. It initializes an array `dp` of size `n+1`, where `n` is the length of the `days` array. The `dp` array stores the minimum cost required to travel up to the i-th day in the `days` array. It is initialized to `Integer.MAX_VALUE`, except for `dp[0]` which is initialized to `0`\\n\\n# Approach\\nFor each day `i`, three possibilities are considered:\\n- If a 1-day pass is bought on that day, then the cost will be `dp[i-1] + costs[0]`.\\n- If a 7-day pass is bought on that day, then we look for the first day before the i-th day, such that the difference between the two days is less than 7. Let that day be j. Then, the cost will be `dp[j+1] + costs[1]`. We add `1` to `j` because we need to consider the cost of the 7-day pass for the current day, which is `costs[1]`.\\n- If a 30-day pass is bought on that day, then we look for the first day before the i-th day, such that the difference between the two days is less than 30. Let that day be j. Then, the\\ncost will be `dp[j+1] + costs[2]`\\n\\nWe take the minimum of these three possibilities and store it in `dp[i]`. Finally, we return\\n`dp[n]`, which stores the minimum cost required to travel up to the last day in the `days` array.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where `n` is the length of the `days` array.\\n\\n- Space complexity: $$O(n)$$ because we are using an additional array of size `n+1`.\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n``` Java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + costs[0]; // 1-day pass for current day\\n            \\n            int j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 7) j--;\\n            dp[i] = Math.min(dp[i], dp[j + 1] + costs[1]); // 7-day pass for current day\\n            \\n            j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 30) j--;\\n            dp[i] = Math.min(dp[i], dp[j + 1] + costs[2]); // 30-day pass for current day\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\\n``` C++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + costs[0]; // 1-day pass for current day\\n            \\n            int j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 7) {\\n                j--;\\n            }\\n            dp[i] = min(dp[i], dp[j + 1] + costs[1]); // 7-day pass for current day\\n            \\n            j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 30) {\\n                j--;\\n            }\\n            dp[i] = min(dp[i], dp[j + 1] + costs[2]); // 30-day pass for current day\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\\n``` Python []\\nclass Solution(object):\\n    def mincostTickets(self, days, costs):\\n        \"\"\"\\n        :type days: List[int]\\n        :type costs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(days)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[0] = 0\\n        \\n        for i in range(1, n + 1):\\n            dp[i] = dp[i - 1] + costs[0] # 1-day pass for current day\\n            \\n            j = i - 1\\n            while j >= 0 and days[i - 1] - days[j] < 7:\\n                j -= 1\\n            dp[i] = min(dp[i], dp[j + 1] + costs[1]) # 7-day pass for current day\\n            \\n            j = i - 1\\n            while j >= 0 and days[i - 1] - days[j] < 30:\\n                j -= 1\\n            dp[i] = min(dp[i], dp[j + 1] + costs[2]) # 30-day pass for current day\\n        \\n        return dp[n]\\n\\n```\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n``` Java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + costs[0]; // 1-day pass for current day\\n            \\n            int j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 7) j--;\\n            dp[i] = Math.min(dp[i], dp[j + 1] + costs[1]); // 7-day pass for current day\\n            \\n            j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 30) j--;\\n            dp[i] = Math.min(dp[i], dp[j + 1] + costs[2]); // 30-day pass for current day\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n + 1, INT_MAX);\\n        dp[0] = 0;\\n        \\n        for (int i = 1; i <= n; i++) {\\n            dp[i] = dp[i - 1] + costs[0]; // 1-day pass for current day\\n            \\n            int j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 7) {\\n                j--;\\n            }\\n            dp[i] = min(dp[i], dp[j + 1] + costs[1]); // 7-day pass for current day\\n            \\n            j = i - 1;\\n            while (j >= 0 && days[i - 1] - days[j] < 30) {\\n                j--;\\n            }\\n            dp[i] = min(dp[i], dp[j + 1] + costs[2]); // 30-day pass for current day\\n        }\\n        \\n        return dp[n];\\n    }\\n};\\n```\n``` Python []\\nclass Solution(object):\\n    def mincostTickets(self, days, costs):\\n        \"\"\"\\n        :type days: List[int]\\n        :type costs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        n = len(days)\\n        dp = [float(\\'inf\\')] * (n + 1)\\n        dp[0] = 0\\n        \\n        for i in range(1, n + 1):\\n            dp[i] = dp[i - 1] + costs[0] # 1-day pass for current day\\n            \\n            j = i - 1\\n            while j >= 0 and days[i - 1] - days[j] < 7:\\n                j -= 1\\n            dp[i] = min(dp[i], dp[j + 1] + costs[1]) # 7-day pass for current day\\n            \\n            j = i - 1\\n            while j >= 0 and days[i - 1] - days[j] < 30:\\n                j -= 1\\n            dp[i] = min(dp[i], dp[j + 1] + costs[2]) # 30-day pass for current day\\n        \\n        return dp[n]\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349786,
                "title": "image-explanation-recursion-dp-dp-optimized-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`)\\n`Minimum Cost For Tickets` by `Aryan Mittal`\\n![Google4.png](https://assets.leetcode.com/users/images/c638499b-2494-47fd-a4d3-fab6bc792f62_1679974209.109997.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/1eb522f1-e7c4-46ae-9e03-25187040052e_1679969963.3160527.png)\\n![image.png](https://assets.leetcode.com/users/images/2a9cee71-f6ed-4c1a-84f7-3e6d0abfb56a_1679969974.2573662.png)\\n![image.png](https://assets.leetcode.com/users/images/72d3bff9-8be5-42cd-b948-aacbb8c424da_1679969983.6983235.png)\\n![image.png](https://assets.leetcode.com/users/images/22f9f518-17e5-48f5-8f4b-c30ca70c0936_1679969996.8871362.png)\\n![image.png](https://assets.leetcode.com/users/images/4290a7b7-e3ba-4239-bf52-ff025b46d455_1679970007.2821136.png)\\n![image.png](https://assets.leetcode.com/users/images/6f08a03a-dbb2-4986-b7b9-ccdebe70f290_1679970013.9704604.png)\\nDP - Optimized Code\\n![image.png](https://assets.leetcode.com/users/images/1c48d256-b368-4c0c-8e76-182c08c0a975_1679970021.1624587.png)\\n\\n\\n# DP - Optimized Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs, int cost = 0) {\\n    queue<pair<int, int>> last7, last30;\\n\\n    for (auto d : days) {\\n        while (!last7.empty() && last7.front().first + 7 <= d) last7.pop();\\n        while (!last30.empty() && last30.front().first + 30 <= d) last30.pop();\\n        \\n        last7.push({ d, cost + costs[1] });\\n        last30.push({ d, cost + costs[2] });\\n        \\n        cost = min({ cost + costs[0], last7.front().second, last30.front().second });\\n    }\\n    return cost;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        Queue<int[]> last7 = new LinkedList<>();\\n        Queue<int[]> last30 = new LinkedList<>();\\n        int cost = 0;\\n\\n        for (int d : days) {\\n            while (!last7.isEmpty() && last7.peek()[0] + 7 <= d) {\\n                last7.poll();\\n            }\\n            while (!last30.isEmpty() && last30.peek()[0] + 30 <= d) {\\n                last30.poll();\\n            }\\n            last7.offer(new int[]{d, cost + costs[1]});\\n            last30.offer(new int[]{d, cost + costs[2]});\\n            cost = Math.min(cost + costs[0], Math.min(last7.peek()[1], last30.peek()[1]));\\n        }\\n\\n        return cost;\\n    }\\n}\\n```\\n```Python []\\nfrom queue import Queue\\n\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        last7 = Queue()\\n        last30 = Queue()\\n        cost = 0\\n\\n        for d in days:\\n            while not last7.empty() and last7.queue[0][0] + 7 <= d:\\n                last7.get()\\n            while not last30.empty() and last30.queue[0][0] + 30 <= d:\\n                last30.get()\\n            last7.put((d, cost + costs[1]))\\n            last30.put((d, cost + costs[2]))\\n            cost = min(cost + costs[0], last7.queue[0][1], last30.queue[0][1])\\n\\n        return cost\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs, int cost = 0) {\\n    queue<pair<int, int>> last7, last30;\\n\\n    for (auto d : days) {\\n        while (!last7.empty() && last7.front().first + 7 <= d) last7.pop();\\n        while (!last30.empty() && last30.front().first + 30 <= d) last30.pop();\\n        \\n        last7.push({ d, cost + costs[1] });\\n        last30.push({ d, cost + costs[2] });\\n        \\n        cost = min({ cost + costs[0], last7.front().second, last30.front().second });\\n    }\\n    return cost;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        Queue<int[]> last7 = new LinkedList<>();\\n        Queue<int[]> last30 = new LinkedList<>();\\n        int cost = 0;\\n\\n        for (int d : days) {\\n            while (!last7.isEmpty() && last7.peek()[0] + 7 <= d) {\\n                last7.poll();\\n            }\\n            while (!last30.isEmpty() && last30.peek()[0] + 30 <= d) {\\n                last30.poll();\\n            }\\n            last7.offer(new int[]{d, cost + costs[1]});\\n            last30.offer(new int[]{d, cost + costs[2]});\\n            cost = Math.min(cost + costs[0], Math.min(last7.peek()[1], last30.peek()[1]));\\n        }\\n\\n        return cost;\\n    }\\n}\\n```\n```Python []\\nfrom queue import Queue\\n\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        last7 = Queue()\\n        last30 = Queue()\\n        cost = 0\\n\\n        for d in days:\\n            while not last7.empty() and last7.queue[0][0] + 7 <= d:\\n                last7.get()\\n            while not last30.empty() and last30.queue[0][0] + 30 <= d:\\n                last30.get()\\n            last7.put((d, cost + costs[1]))\\n            last30.put((d, cost + costs[2]))\\n            cost = min(cost + costs[0], last7.queue[0][1], last30.queue[0][1])\\n\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 504403,
                "title": "dp-it-s-not-easy-as-you-thought",
                "content": "At the first glance, we think this problem can be solved by DP. It\\'s true, but the formular to come up with `bottom-up dp` is not intuitive. Once again, we have to come up with `dfs` first, then `dfs with memo`, and finally `bottom-up DP`.\\n\\n1) **dfs**\\n\\n\\tOk, at the `days[i]`, how many possibilities that we can do? \\n\\t+ pay nothing. We have bought a week-pass, or a month-pass in the past, and up-to-now, the pass is still valid.\\n\\t+ buy a day-pass to cover only this day\\n\\t+ buy a week-pass to cover next 6 consecutive days.\\n\\t+ buy a month-pass to cover next 29 consecutive days.\\n\\n```\\n\\tprivate int dfs(int[] days, int[] costs, int i, int finalValidDay) {\\n        if (i == days.length) return 0;\\n\\t\\t\\n\\t\\t// pay nothing, still a valid pass\\n        if (days[i] <= finalValidDay) return dfs(days, costs, i+1, finalValidDay);\\n\\t\\t\\n\\t\\t// buy a day-pass, or week-pass, or month-pass\\n        int buyDayPass = costs[0] + dfs(days, costs, i+1, days[i]);\\n        int buyWeekPass = costs[1] + dfs(days, costs, i+1, days[i]+6);\\n        int buyMonthPass = costs[2] + dfs(days, costs, i+1, days[i]+29);\\n\\t\\t\\n\\t\\t// choose the minimum cost\\n        return Math.min(buyDayPass, Math.min(buyWeekPass, buyMonthPass));\\n    }\\n```\\nThe interviewer is not satisfied, and will say this code is `TLE`, and you have to improve it. Now, since you see the `dfs function` depends on `i` and `finalValidDay`, so you are about to create a `int[][] memo` to represent these states? However, it doesn\\'t help. \\n\\n2) **simplify dfs**\\nWe should get rid of `finalValidDay` first. Note that we always encounter the first day we have to pay, the next days might be not necessary to calculate. For example `days=[1,2,4,6,7,8]`, if we buy a week-pass on the 1st day, then the next days `2,4,6,7` can be skipped. \\n\\n```\\n\\tprivate int dfs_simplify(int[] days, int[] costs, int i) {\\n        if (i == days.length) return 0;\\n\\n        // buy a day-pass, or week-pass, or month-pass\\n        int res = Integer.MAX_VALUE;\\n        for (int j = 0; j < costs.length; j++) {\\n            int nextIndex = nextDayIndex(days, i, j);\\n            res = Math.min(res, costs[j] + dfs_simplify(days, costs, nextIndex) );\\n        }\\n\\n        // choose the minimum cost\\n        return res;\\n    }\\n\\n    private int nextDayIndex(int[] days, int i, int j) {\\n        int next = nextDay(days, i, j);\\n        while (i < days.length && days[i] < next) i++;\\n        return i;\\n    }\\n\\n    private int nextDay(int[] days, int i, int j) {\\n        if (j == 0) return days[i]+1;\\n        if (j == 1) return days[i]+7;\\n        return days[i]+30;\\n    }\\n```\\n\\n3) **dfs with memo**\\n\\n```\\n\\tprivate int dfs_simplify_memo(int[] days, int[] costs, int i, int[] memo) {\\n        if (i == days.length) return 0;\\n        if (memo[i] != 0) return memo[i];\\n\\n        // buy a day-pass, or week-pass, or month-pass\\n        memo[i] = Integer.MAX_VALUE;\\n        for (int j = 0; j < costs.length; j++) {\\n            int nextIndex = nextDayIndex(days, i, j);\\n            memo[i] = Math.min(memo[i], costs[j] + dfs_simplify_memo(days, costs, nextIndex, memo) );\\n        }\\n\\n        // choose the minimum cost\\n        return memo[i];\\n    }\\n```\\n\\n4) **bottom-up dp**\\n\\n\\t`dp[n]` is the minimum cost to cover all days from day `1` until day `n`. \\n\\t- If day `n` is not one of our `days`, then we don\\'t have to worry. The cost is the same as the cost to cover all days to day `n-1` => `dp[n] = dp[n-1]`\\n\\t- If day `n` is one of our `days`, then we will check if buying a pass before can help us minimize the cost.\\n\\tFor example, buying a week-pass a week ago can cost: `dp[n-7] + costs[1]`\\n\\tbuying a month-pass a month ago can cost: `dp[n-30] + cost[2]`\\n\\t\\n\\tThere is a confusion here what if `n-7` or `n-30` is not one of our `days` ?? It doesn\\'t matter at all. What we care is we prefer not buy at day `n`, but rather buy at the moment before day `n`.\\n\\t\\n\\tdays: `1,2,3,x,x(n-7),x,x,x,x,9,x,11,12(n),13`\\n\\tIn this example, `n-7` is not our days, we would rather buy a week-pass from day `9`, than buy a week-pass on day `12`. Note that `dp[3] = dp[n-7] = dp[9]`\\n\\t\\n\\t```\\n\\tprivate int dp_bottom_up(int[] days, int[] costs) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int day : days) set.add(day);\\n\\n        int lastDay = days[days.length-1], dp[] = new int[lastDay+1];\\n        for (int i = 1; i <= lastDay; i++) {\\n            if (!set.contains(i)) {\\n                dp[i] = dp[i-1];\\n            }\\n            else {\\n                dp[i] = dp[i-1]+costs[0];\\n\\n                int j = (i >= 7) ? i-7 : 0;\\n                dp[i] = Math.min(dp[i], dp[j] + costs[1]);\\n\\n                j = (i >= 30) ? i-30 : 0;\\n                dp[i] = Math.min(dp[i], dp[j] + costs[2]);\\n            }\\n        }\\n\\n        return dp[lastDay];\\n    }\\n\\t```\\n\\t\\n\\t\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\tprivate int dfs(int[] days, int[] costs, int i, int finalValidDay) {\\n        if (i == days.length) return 0;\\n\\t\\t\\n\\t\\t// pay nothing, still a valid pass\\n        if (days[i] <= finalValidDay) return dfs(days, costs, i+1, finalValidDay);\\n\\t\\t\\n\\t\\t// buy a day-pass, or week-pass, or month-pass\\n        int buyDayPass = costs[0] + dfs(days, costs, i+1, days[i]);\\n        int buyWeekPass = costs[1] + dfs(days, costs, i+1, days[i]+6);\\n        int buyMonthPass = costs[2] + dfs(days, costs, i+1, days[i]+29);\\n\\t\\t\\n\\t\\t// choose the minimum cost\\n        return Math.min(buyDayPass, Math.min(buyWeekPass, buyMonthPass));\\n    }\\n```\n```\\n\\tprivate int dfs_simplify(int[] days, int[] costs, int i) {\\n        if (i == days.length) return 0;\\n\\n        // buy a day-pass, or week-pass, or month-pass\\n        int res = Integer.MAX_VALUE;\\n        for (int j = 0; j < costs.length; j++) {\\n            int nextIndex = nextDayIndex(days, i, j);\\n            res = Math.min(res, costs[j] + dfs_simplify(days, costs, nextIndex) );\\n        }\\n\\n        // choose the minimum cost\\n        return res;\\n    }\\n\\n    private int nextDayIndex(int[] days, int i, int j) {\\n        int next = nextDay(days, i, j);\\n        while (i < days.length && days[i] < next) i++;\\n        return i;\\n    }\\n\\n    private int nextDay(int[] days, int i, int j) {\\n        if (j == 0) return days[i]+1;\\n        if (j == 1) return days[i]+7;\\n        return days[i]+30;\\n    }\\n```\n```\\n\\tprivate int dfs_simplify_memo(int[] days, int[] costs, int i, int[] memo) {\\n        if (i == days.length) return 0;\\n        if (memo[i] != 0) return memo[i];\\n\\n        // buy a day-pass, or week-pass, or month-pass\\n        memo[i] = Integer.MAX_VALUE;\\n        for (int j = 0; j < costs.length; j++) {\\n            int nextIndex = nextDayIndex(days, i, j);\\n            memo[i] = Math.min(memo[i], costs[j] + dfs_simplify_memo(days, costs, nextIndex, memo) );\\n        }\\n\\n        // choose the minimum cost\\n        return memo[i];\\n    }\\n```\n```\\n\\tprivate int dp_bottom_up(int[] days, int[] costs) {\\n        Set<Integer> set = new HashSet<>();\\n        for (int day : days) set.add(day);\\n\\n        int lastDay = days[days.length-1], dp[] = new int[lastDay+1];\\n        for (int i = 1; i <= lastDay; i++) {\\n            if (!set.contains(i)) {\\n                dp[i] = dp[i-1];\\n            }\\n            else {\\n                dp[i] = dp[i-1]+costs[0];\\n\\n                int j = (i >= 7) ? i-7 : 0;\\n                dp[i] = Math.min(dp[i], dp[j] + costs[1]);\\n\\n                j = (i >= 30) ? i-30 : 0;\\n                dp[i] = Math.min(dp[i], dp[j] + costs[2]);\\n            }\\n        }\\n\\n        return dp[lastDay];\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 886443,
                "title": "evolution-recursion-memo-on-recursion-dp-6-line-dp-detailed-explanation",
                "content": "Recursion is the core of Dynamic Programming so coming up with recursive equation for any problem can be challenging. So here\\'s a flow of a how a Recursion ends up being a 6 line solution.\\n\\n**Recursion :**\\nTo come up with the recursive equation we need to think on how many ways are there to buy a ticket.\\n\\n*Scenario :*\\n*When our guy walks into the station to get ticket, he has to make choice between picking tickets.\\nHe has a note in his hand to see what all days he is travelling.\\nSo, **like a genius,** he looks at his notebook and thinks if he bought which ticket today, he might endup paying less in the year.\\nHe thinks of buying a ticket today by looking at tomorrow\\'s tickets at his disposal. **Oh wait!** now he thinks of the day after tomorrow and continues till last day of year!*\\n\\n*Turns out, if he bought ticket everyother day in consecutive days of travell, the ticket price is cheap for a week pass than buying it for everyday of the week*\\n\\n**He thinks about future and decides what to do today!**\\n`min cost of ticket` = `what ticket he might buy today` + `minimum price for the rest of the days`\\n\\nwhich translates to,\\n```\\nminCost = min({ \\n\\t\\t\\t\\toneDayPass + exceptToday,\\n\\t\\t\\t\\toneWeekPass + expectThisWeek,\\n\\t\\t\\t\\toneMonthPass, expectThisMonth \\n\\t\\t\\t})\\n```\\n\\nWhich in code translates to,\\n```\\n// Calculate for today ie i\\n// Recursive eqaution\\nminCost = min({\\n\\t\\t\\t\\tcost[0] + calculate(i + 1),\\n\\t\\t\\t\\tcost[1] + calculate(i + 7),\\n\\t\\t\\t\\tcost[2] + calculate(i + 30)\\n})\\n```\\n\\nRecursion code,\\n```\\nclass Solution {\\npublic:\\n    int calculate(vector<int> &days, vector<int> &costs, int i, vector <bool> map) {\\n        if( i > 365)    // Reached the end of year!!\\n            return 0;\\n        if(!map[i])\\n            return calculate(days, costs, i+1, map);    // If he ain\\'t travelling, goes to next day without buying any ticket\\n        return min({\\n            costs[0] + calculate(days, costs, i+1, map),\\n            costs[1] + calculate(days, costs, i+7, map),\\n            costs[2] + calculate(days, costs, i+30, map)\\n        });\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector <bool> map(366, false);    // To keep track the days he ain\\'t travelling\\n        for(auto x: days)\\n            map[x] = true;   // Only the travelling days are marked\\n        int x = calculate(days, costs, 0, map);\\n        return x;\\n    }\\n};\\n```\\n\\n*Now he figures out that, he is unneccesarily calculating for everyday repeatedly!\\nHe thinks even smart know! Every time he calucates for a day, **he jots it down on the notebook**!*\\n\\n**Recursion with memoization :**\\nAll we need to do is introduce memo variable to avoid repeated calculations\\n```\\nclass Solution {\\npublic:\\n    int rec(vector<int> &days, vector<int> &costs, int i, vector <bool> map, vector <int>& memo) {\\n        if( i > 365)\\n            return 0;\\n        if(memo[i] != -1)\\n            return memo[i]; // Already calculated\\n        if(!map[i])\\n            return memo[i] = rec(days, costs, i+1, map, memo);\\n        return memo[i] = min({\\n            costs[0] + rec(days, costs, i+1, map, memo),\\n            costs[1] + rec(days, costs, i+7, map, memo),\\n            costs[2] + rec(days, costs, i+30, map, memo)\\n        });\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector <bool> map(366, false);\\n        vector <int> memo(366, -1);\\n        for(auto x: days)\\n            map[x] = true;\\n        int x = rec(days, costs, 0, map, memo);\\n        return x;\\n    }\\n};\\n```\\n\\n*He figures out, because he already has the reapeated calculations jotted, he can just begin from the end and whatever price he ends up paying for today, will be the min cost for year!*\\n\\n**Iterative DP : top down**\\nCan be written as bottom up, but that would equation will change. To maintain regularity and the proof of recursion equation leading to DP I\\'m using top-down.\\n\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = 367;\\n        vector <bool> map(n , false);\\n        vector <int> dp(n , 0);\\n        for(auto x: days)\\n            map[x] = true;\\n        for(int i = n - 1; i >= 0; i--){\\n            dp[i] = dp[min(n - 1, i + 1)];\\n            if(map[i]){ \\n                dp[i] = min({\\n                    costs[0] + dp[min(n - 1, i + 1)],\\n                    costs[1] + dp[min(n - 1, i + 7)],\\n                    costs[2] + dp[min(n - 1, i + 30)]\\n                });\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\\n\\n\\n**6 lines DP Solution :**\\n*Let\\'s make it look like a PRO!!!*\\nBy the way, this is actually slower than the previous because set searching is expensive(computationally) over index array search\\n```\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = 367;\\n        unordered_set <int> map(days.begin(), days.end());\\n        vector <int> dp(n , 0);\\n        for(int i = n - 1; i >= 0; i--)\\n            dp[i] = map.find(i) == map.end() ? dp[min(n - 1, i + 1)] : min({ costs[0] + dp[min(n - 1, i + 1)], costs[1] + dp[min(n - 1, i + 7)], costs[2] + dp[min(n - 1, i + 30)] });\\n        return dp[0];\\n    }\\n```\\n\\n**Liked it? Simple enought to understand? Hit the damn upvote button.**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nminCost = min({ \\n\\t\\t\\t\\toneDayPass + exceptToday,\\n\\t\\t\\t\\toneWeekPass + expectThisWeek,\\n\\t\\t\\t\\toneMonthPass, expectThisMonth \\n\\t\\t\\t})\\n```\n```\\n// Calculate for today ie i\\n// Recursive eqaution\\nminCost = min({\\n\\t\\t\\t\\tcost[0] + calculate(i + 1),\\n\\t\\t\\t\\tcost[1] + calculate(i + 7),\\n\\t\\t\\t\\tcost[2] + calculate(i + 30)\\n})\\n```\n```\\nclass Solution {\\npublic:\\n    int calculate(vector<int> &days, vector<int> &costs, int i, vector <bool> map) {\\n        if( i > 365)    // Reached the end of year!!\\n            return 0;\\n        if(!map[i])\\n            return calculate(days, costs, i+1, map);    // If he ain\\'t travelling, goes to next day without buying any ticket\\n        return min({\\n            costs[0] + calculate(days, costs, i+1, map),\\n            costs[1] + calculate(days, costs, i+7, map),\\n            costs[2] + calculate(days, costs, i+30, map)\\n        });\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector <bool> map(366, false);    // To keep track the days he ain\\'t travelling\\n        for(auto x: days)\\n            map[x] = true;   // Only the travelling days are marked\\n        int x = calculate(days, costs, 0, map);\\n        return x;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int rec(vector<int> &days, vector<int> &costs, int i, vector <bool> map, vector <int>& memo) {\\n        if( i > 365)\\n            return 0;\\n        if(memo[i] != -1)\\n            return memo[i]; // Already calculated\\n        if(!map[i])\\n            return memo[i] = rec(days, costs, i+1, map, memo);\\n        return memo[i] = min({\\n            costs[0] + rec(days, costs, i+1, map, memo),\\n            costs[1] + rec(days, costs, i+7, map, memo),\\n            costs[2] + rec(days, costs, i+30, map, memo)\\n        });\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector <bool> map(366, false);\\n        vector <int> memo(366, -1);\\n        for(auto x: days)\\n            map[x] = true;\\n        int x = rec(days, costs, 0, map, memo);\\n        return x;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = 367;\\n        vector <bool> map(n , false);\\n        vector <int> dp(n , 0);\\n        for(auto x: days)\\n            map[x] = true;\\n        for(int i = n - 1; i >= 0; i--){\\n            dp[i] = dp[min(n - 1, i + 1)];\\n            if(map[i]){ \\n                dp[i] = min({\\n                    costs[0] + dp[min(n - 1, i + 1)],\\n                    costs[1] + dp[min(n - 1, i + 7)],\\n                    costs[2] + dp[min(n - 1, i + 30)]\\n                });\\n            }\\n        }\\n        return dp[0];\\n    }\\n};\\n```\n```\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = 367;\\n        unordered_set <int> map(days.begin(), days.end());\\n        vector <int> dp(n , 0);\\n        for(int i = n - 1; i >= 0; i--)\\n            dp[i] = map.find(i) == map.end() ? dp[min(n - 1, i + 1)] : min({ costs[0] + dp[min(n - 1, i + 1)], costs[1] + dp[min(n - 1, i + 7)], costs[2] + dp[min(n - 1, i + 30)] });\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349776,
                "title": "python3-39-ms-beats-91-51-dp",
                "content": "The mincostTickets function takes in two arguments: days, a list of integers representing the days on which you want to travel, and costs, a list of integers representing the costs for a 1-day, 7-day, and 30-day travel pass, respectively.\\n\\nThe function initializes the cost to zero and two deques last7 and last30, which will store tuples of the form (day, cost) representing the last 7-day and 30-day passes, respectively.\\n\\nThe function then iterates over each day in the days list. For each day, it first removes any tuples from last7 and last30 that are no longer valid (i.e., the day is more than 7 or 30 days after the day in the tuple).\\n\\nNext, it adds a new tuple to each deque with the current day and the cost of a 7-day or 30-day pass plus the cost so far. This is because if you buy a 7-day or 30-day pass on the current day, you will also have to pay for the cost of the pass for the preceding days.\\n\\nFinally, the function sets the cost to the minimum of the following three values: the cost so far plus the cost of a 1-day pass, the cost of the earliest tuple in last7, and the cost of the earliest tuple in last30. This is because you can either buy a 1-day pass on the current day or use one of the 7-day or 30-day passes in the deques.\\n\\nThe function returns the final cost at the end.\\n![image.png](https://assets.leetcode.com/users/images/ed5421cc-45ff-4a2d-afa7-b666655c06cb_1679969660.415069.png)\\n\\n# Please Upvote \\uD83D\\uDE07\\n\\n## Python3\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        cost = 0\\n        last7 = deque()\\n        last30 = deque()\\n        for day in days:\\n            while last7 and last7[0][0] + 7 <= day:\\n                last7.popleft()\\n            while last30 and last30[0][0] + 30 <= day:\\n                last30.popleft()\\n            last7.append((day, cost + costs[1]))\\n            last30.append((day, cost + costs[2]))\\n            cost = min(cost + costs[0],\\n                      last7[0][1],\\n                      last30[0][1])\\n        return cost\\n```\\n![image.png](https://assets.leetcode.com/users/images/a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png)",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        cost = 0\\n        last7 = deque()\\n        last30 = deque()\\n        for day in days:\\n            while last7 and last7[0][0] + 7 <= day:\\n                last7.popleft()\\n            while last30 and last30[0][0] + 30 <= day:\\n                last30.popleft()\\n            last7.append((day, cost + costs[1]))\\n            last30.append((day, cost + costs[2]))\\n            cost = min(cost + costs[0],\\n                      last7[0][1],\\n                      last30[0][1])\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 323912,
                "title": "c-dp-on-days",
                "content": "In this solution ```dp[i]``` means cost, for travelling i days. In order to minimize cost we can see whether it is better to buy 30 days ticket (which will be ```dp[i] = dp[i-30] + cost[2]```), 7 days (which will be ```dp[i] = dp[i-7] + cost[1]```) or 1 day (which is set initially in a first loop)\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        int dp[366];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for(auto day: days)\\n            dp[day] = costs[0];\\n        for(int i = 1; i <= days[n-1]; i++){\\n            if(!dp[i])\\n                dp[i] = dp[i-1];\\n            else{\\n                dp[i] = dp[i-1] + costs[0];\\n                int j = max(0, i-7);\\n                dp[i] = min(dp[i], dp[j] + costs[1]);\\n                j = max(0, i-30);\\n                dp[i] = min(dp[i], dp[j] + costs[2]);\\n            }\\n        }\\n        \\n        return dp[days[n-1]];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```dp[i]```\n```dp[i] = dp[i-30] + cost[2]```\n```dp[i] = dp[i-7] + cost[1]```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        int dp[366];\\n        memset(dp, 0, sizeof(dp));\\n        \\n        for(auto day: days)\\n            dp[day] = costs[0];\\n        for(int i = 1; i <= days[n-1]; i++){\\n            if(!dp[i])\\n                dp[i] = dp[i-1];\\n            else{\\n                dp[i] = dp[i-1] + costs[0];\\n                int j = max(0, i-7);\\n                dp[i] = min(dp[i], dp[j] + costs[1]);\\n                j = max(0, i-30);\\n                dp[i] = min(dp[i], dp[j] + costs[2]);\\n            }\\n        }\\n        \\n        return dp[days[n-1]];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810791,
                "title": "python-universal-true-o-days-solution-explained",
                "content": "There are a lot of different dp solution, which have `O(days)` complexity, which is in fact `O(30*days)`, so it depeneds a lot on our numbers `[1,7,30]`. My solution is universal: you can choose any passes you want, and time complexity will not depend on them. Let me introduce my notations:\\n\\n1. `k` is number of passes and `P` is durations of these passes, in our case it is `[1,7,30]`; cost is minimal cost so far, in the beginning it is equal to `0`.\\n2. `Q` is list of `k` queues. Why we need queues? When we want to find the best cost we can have at some day `d`, we need to look back `30` days before, so why not keep all these period in queue? What we keep in this queue? We keep pairs `[day, cost]`. Also we have queue for `7` day pass and for `1` day pass.\\n\\nLet us go through example for better understanding:\\n`days = [1,4,6,7,8,20], costs = [2,7,15]`.\\n\\n\\n1. `day = 1`, `Q[0] = [[1,2]], Q[1] = [[1,7]], Q[2] = [[1, 15]]`: for the first day we put it in all three queues.\\n2. `day = 4`, `Q[0] = [[4,4]], Q[1] = [[1,7], [4,9]], Q[2] = [[1,15], [4,17]]`: we update `Q[0]`, also `Q[1]` and `Q[2]` now have two elements.\\n3. `day = 6`, `Q[0] = [[6,6]], Q[1] = [[1,7], [4, 9], [6,11]], Q[2] = [[1,15], [4,17], [6,19]]`: update `Q[0]`, add element to `Q[1]` and `Q[2]`. \\n4. `day = 7`, `Q[0] = [[7,8]], Q[1] = [[1,7], [4,9], [6,11], [7,13]], Q[2] = [[1,15], [4,17], [6,19], [7,21]]`, similar logic.\\n5. `day = 8`, `Q[0] = [[8,9]], Q[1] = [[4,9], [6,11], [7,13], [8,14]], Q[2] = [[1,15], [4,17], [6,19], [7,21], [8,22]]`: update `Q[0]`, also add element to the end of `Q[1]` and remove element from the beginning of `Q[1]`, because it is outdated.\\n6. `day = 20`, `Q[0] = [[20,11]], Q[1] = [[20,16]], Q[2] = [[1,15], [4,17], [6,19], [7,21], [8,22], [20,24]]`.\\n\\nSo, we iterate through our days and update our queues on each step. Then we choose minimum possible result.\\n\\n**Complexity**: time complexity is `O(days)`, length of `days` list, because we process each element at most `3` times: we can put and remove it to each queue only once. For general case complexity is `O(days * k)`.  Space complexity is `O(30+7+1)` in our case and `O(sum(P))` in general case.\\n\\n\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days, costs):\\n        k, P, cost = 3, [1,7,30], 0\\n        Q = [deque() for _ in range(k)]\\n\\n        for d in days:\\n            for i in range(k):\\n                while Q[i] and Q[i][0][0] + P[i] <= d: Q[i].popleft()\\n                Q[i].append([d, cost + costs[i]])\\n         \\n            cost = min([Q[i][0][1] for i in range(k)])\\n\\n        return cost\\n```\\n\\n**Remark** I think this problem is similar to problem **264. Ugly Number II**, there we also need to keep several candidates for new number and update them.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days, costs):\\n        k, P, cost = 3, [1,7,30], 0\\n        Q = [deque() for _ in range(k)]\\n\\n        for d in days:\\n            for i in range(k):\\n                while Q[i] and Q[i][0][0] + P[i] <= d: Q[i].popleft()\\n                Q[i].append([d, cost + costs[i]])\\n         \\n            cost = min([Q[i][0][1] for i in range(k)])\\n\\n        return cost\\n```",
                "codeTag": "Java"
            },
            {
                "id": 533146,
                "title": "java-recursion-with-memoization-time-o-n-space-o-n",
                "content": "For each day that you need to buy a ticket you will try the three options\\n1. \\tBuying a one-day ticket and then continuing with the rest of the days\\n2. \\tBuying a seven-day ticket and skipping all the days included in this ticket\\n3. \\tBuying a thirty-day ticket and skipping all the days included in this ticket\\n\\n\\n```java\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[days.length];\\n        return minCostTickets(days, costs, 0, dp);\\n    }\\n    \\n    public static int minCostTickets(int[] days, int[] costs, int day, int[] dp){\\n        if(day >= days.length) return 0;\\n        //return previously calculated day\\n        if(dp[day] != 0) return dp[day];\\n         int i;\\n        \\n        //Attempt to buy a one-day ticket\\n        int buyOneDay =  minCostTickets(days, costs, day + 1, dp) + costs[0];\\n\\n        //Attempt to buy a seven-day ticket and skip all days that will be included in this ticket\\n        for(i = day; i < days.length; i++)\\n            if(days[i] >= days[day] + 7) break;\\n        int buySevenDays = minCostTickets(days, costs, i, dp) + costs[1];\\n        \\n        //Attempt to buy a thirty-day ticket and skip all days that will be included in this ticket\\n        for(i = day; i < days.length; i++)\\n            if(days[i] >= days[day] + 30) break;\\n        int buyThirtyDays = minCostTickets(days, costs, i, dp) + costs[2];\\n        \\n        //return minimum of three options\\n        int result = Math.min(Math.min(buyOneDay, buySevenDays), buyThirtyDays);\\n        dp[day] = result;\\n        return result;\\n        \\n    }\\n```\\n\\nThe time complexity in this case will be O(n) as each day is computed at most once and saved in dp array to be used for later calls\\nThe space complexity will be O(n) for the dp array.\\nThe recursion stack will also never surpass O(n) calls (in the case of trying to buy all one-day tickets)\\n",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```java\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[days.length];\\n        return minCostTickets(days, costs, 0, dp);\\n    }\\n    \\n    public static int minCostTickets(int[] days, int[] costs, int day, int[] dp){\\n        if(day >= days.length) return 0;\\n        //return previously calculated day\\n        if(dp[day] != 0) return dp[day];\\n         int i;\\n        \\n        //Attempt to buy a one-day ticket\\n        int buyOneDay =  minCostTickets(days, costs, day + 1, dp) + costs[0];\\n\\n        //Attempt to buy a seven-day ticket and skip all days that will be included in this ticket\\n        for(i = day; i < days.length; i++)\\n            if(days[i] >= days[day] + 7) break;\\n        int buySevenDays = minCostTickets(days, costs, i, dp) + costs[1];\\n        \\n        //Attempt to buy a thirty-day ticket and skip all days that will be included in this ticket\\n        for(i = day; i < days.length; i++)\\n            if(days[i] >= days[day] + 30) break;\\n        int buyThirtyDays = minCostTickets(days, costs, i, dp) + costs[2];\\n        \\n        //return minimum of three options\\n        int result = Math.min(Math.min(buyOneDay, buySevenDays), buyThirtyDays);\\n        dp[day] = result;\\n        return result;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 518772,
                "title": "javascript-solution-with-comments",
                "content": "Only doing days.length + 1 apporach. Beats 85% in speed 100% memory.\\n\\n```\\nvar mincostTickets = function(days, cost) {\\n// Initilize dp array to be the size of the last day plus 1\\n  let dp = new Array(days[days.length - 1] + 1);\\n  // Base case\\n  dp[0] = 0;\\n  // Loop through all the days\\n  for (let i = 1; i < dp.length; i++) {\\n  // If \\'i\\' isn\\'t in the days array we let it equal to the previous day because we don\\'t need to buy a ticket for that day\\n    if (!days.includes(i)) {\\n      dp[i] = dp[i - 1];\\n\\t  // if dp[i] is in the days array we find the min value between our 3 cost possibilities\\n    } else {\\n      dp[i] = Math.min(\\n        dp[Math.max(0, i - 1)] + cost[0],\\n        dp[Math.max(0, i - 7)] + cost[1],\\n        dp[Math.max(0, i - 30)] + cost[2]\\n      );\\n    }\\n  }\\n  // last element of dp will be our answer\\n  return dp[dp.length - 1];\\n};\\n\\n```\\nInput: days = [1,4,6,7,8,20]\\n\\t\\tcost = [2,7,15]\\nExample for a DP array : [ 0, 2, 2, 2, 4, 4, 6, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 11 ]\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar mincostTickets = function(days, cost) {\\n// Initilize dp array to be the size of the last day plus 1\\n  let dp = new Array(days[days.length - 1] + 1);\\n  // Base case\\n  dp[0] = 0;\\n  // Loop through all the days\\n  for (let i = 1; i < dp.length; i++) {\\n  // If \\'i\\' isn\\'t in the days array we let it equal to the previous day because we don\\'t need to buy a ticket for that day\\n    if (!days.includes(i)) {\\n      dp[i] = dp[i - 1];\\n\\t  // if dp[i] is in the days array we find the min value between our 3 cost possibilities\\n    } else {\\n      dp[i] = Math.min(\\n        dp[Math.max(0, i - 1)] + cost[0],\\n        dp[Math.max(0, i - 7)] + cost[1],\\n        dp[Math.max(0, i - 30)] + cost[2]\\n      );\\n    }\\n  }\\n  // last element of dp will be our answer\\n  return dp[dp.length - 1];\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 462201,
                "title": "diego-s-understandable-explanations-c",
                "content": "Hi, I\\'m trying to make easily understandable explanations for everyone. Hopefully I did a good job here.\\n*Please upvote if this post helped you, so that others can find it.*\\n\\n**The insight**\\nThe problem insight comes from recognizing that it is a good idea to remember the total cost of covering your journey up to a particular day. Let\\'s look at an example with some ticket costs.\\n\\n```\\n# cover travel up to        cost\\n# ------------------        ----\\n# day 7                     $10\\n# day 13                    $15\\n```\\n\\nLet\\'s say you can only buy two tickets: 1-day for $2, and 7-day for $5.\\n\\nIf you had to cover travel up to **day 14**, you must choose one of the two tickets to cover this new day. Given the above ticket prices, this means that you would compare two numbers: the price of a 1-day ticket plus the cost of covering travel for all days up to 1 day before **day 14**, or the price of a 7-day ticket plus the cost of covering travel for all days up to 7 days before **day 14**. *Here, we see that the 7-day ticket is the better choice since we would pay $15 ($10 prior + $5 ticket) instead of $17 ($15 prior + $2 ticket).*\\n\\nWe reference the cost of covering all travel days before the length of the ticket we\\'re thinking about purchasing because, if we were to buy the ticket, the ticket would cover that length of time.\\n\\n**Wrapping up**\\nNow that you know what numbers to compare when making the decision to purchase a ticket, you simply perform this comparison for each day that you need to travel!\\n\\nThis implies that for days where you don\\'t travel, you simply forward-propagate the total travel cost of the previous day. This way you will have a total travel cost when you reference that date.\\n\\nAs a final note, you might reference days that are outside of the one-year window. This is totally fine, since you need to compare all ticket prices available to you. To handle this, you simply allow the total cost to be zero for days before the one-year window.\\n\\n**A solution**\\nThis solution can be optimized in some ways for improved performance, but I leave that exercise to the reader.\\n\\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n    vector<int> dp(366, INT_MAX);\\n    dp[0] = 0; // You haven\\'t traveled yet, so you haven\\'t spent anything!\\n    size_t j = 0;\\n    for (size_t i = 1; i < dp.size(); i++) {\\n\\t\\t// Is this one of my travel days?\\n        if (j >= days.size() || i != days[j]) { dp[i] = dp[i - 1]; continue; }\\n\\t\\t// Yes! Perform comparisons.\\n        dp[i] = min(dp[i], (i >= 1 ? dp[i - 1] : 0) + costs[0]);\\n        dp[i] = min(dp[i], (i >= 7 ? dp[i - 7] : 0) + costs[1]);\\n        dp[i] = min(dp[i], (i >= 30 ? dp[i - 30] : 0) + costs[2]);\\n        j++; // Don\\'t forget to move on to the next travel day!\\n    }\\n\\n    return dp.back(); // This is the total cost of travel for the year, day 365!\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\n# cover travel up to        cost\\n# ------------------        ----\\n# day 7                     $10\\n# day 13                    $15\\n```\n```\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n    vector<int> dp(366, INT_MAX);\\n    dp[0] = 0; // You haven\\'t traveled yet, so you haven\\'t spent anything!\\n    size_t j = 0;\\n    for (size_t i = 1; i < dp.size(); i++) {\\n\\t\\t// Is this one of my travel days?\\n        if (j >= days.size() || i != days[j]) { dp[i] = dp[i - 1]; continue; }\\n\\t\\t// Yes! Perform comparisons.\\n        dp[i] = min(dp[i], (i >= 1 ? dp[i - 1] : 0) + costs[0]);\\n        dp[i] = min(dp[i], (i >= 7 ? dp[i - 7] : 0) + costs[1]);\\n        dp[i] = min(dp[i], (i >= 30 ? dp[i - 30] : 0) + costs[2]);\\n        j++; // Don\\'t forget to move on to the next travel day!\\n    }\\n\\n    return dp.back(); // This is the total cost of travel for the year, day 365!\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 227106,
                "title": "c-concise-4-line-0ms",
                "content": "```\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        map<int, int> dp = {{-30,0}};\\n        auto cost = [&](int day){return prev(dp.upper_bound(day))->second;};\\n        for(int d:days) dp[d] = min({costs[0] + cost(d-1), costs[1] + cost(d-7), costs[2] + cost(d-30)});\\n\\t\\t// if you want O(N) solution, simply add one line in loop:  if(dp.size() > 31) dp.erase(dp.begin());   \\n        return dp[days.back()];\\n    }",
                "solutionTags": [],
                "code": "```\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        map<int, int> dp = {{-30,0}};\\n        auto cost = [&](int day){return prev(dp.upper_bound(day))->second;};\\n        for(int d:days) dp[d] = min({costs[0] + cost(d-1), costs[1] + cost(d-7), costs[2] + cost(d-30)});\\n\\t\\t// if you want O(N) solution, simply add one line in loop:  if(dp.size() > 31) dp.erase(dp.begin());   \\n        return dp[days.back()];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3349857,
                "title": "c-easy-solution-dp-approach-100-faster",
                "content": "## **\\u2705\\u2705C++ || Easy Solution || \\uD83D\\uDCAF\\uD83D\\uDCAFDP Approach || 100% faster**\\n# **Please Upvote as it really motivates me**\\n\\n```\\nclass Solution {\\npublic:\\n    int  helper(int idx,vector<int>&days,vector<int>&costs,vector<int>&dp){\\n        if(idx>=days.size()){\\n            return 0;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        int pass1=upper_bound(days.begin(),days.end(),days[idx]+1-1)-days.begin();\\n        int c1=helper(pass1,days,costs,dp)+costs[0];\\n        int pass7=upper_bound(days.begin(),days.end(),days[idx]+7-1)-days.begin();\\n        int c7=helper(pass7,days,costs,dp)+costs[1];\\n        int pass3=upper_bound(days.begin(),days.end(),days[idx]+30-1)-days.begin();\\n        int c3=helper(pass3,days,costs,dp)+costs[2];\\n        \\n        return dp[idx]=min(min(c1,c7),c3);\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int>dp(days.size()+1,-1);\\n        return helper(0,days,costs,dp);\\n      \\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/9143cf97-b9ee-446f-a38f-cea43c0216b0_1679971399.3428004.png)\\n\\n![image](https://assets.leetcode.com/users/images/7f423b57-81a2-46ce-9ab2-72ad38f668f7_1675480558.466273.png)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int  helper(int idx,vector<int>&days,vector<int>&costs,vector<int>&dp){\\n        if(idx>=days.size()){\\n            return 0;\\n        }\\n        if(dp[idx]!=-1){\\n            return dp[idx];\\n        }\\n        int pass1=upper_bound(days.begin(),days.end(),days[idx]+1-1)-days.begin();\\n        int c1=helper(pass1,days,costs,dp)+costs[0];\\n        int pass7=upper_bound(days.begin(),days.end(),days[idx]+7-1)-days.begin();\\n        int c7=helper(pass7,days,costs,dp)+costs[1];\\n        int pass3=upper_bound(days.begin(),days.end(),days[idx]+30-1)-days.begin();\\n        int c3=helper(pass3,days,costs,dp)+costs[2];\\n        \\n        return dp[idx]=min(min(c1,c7),c3);\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int>dp(days.size()+1,-1);\\n        return helper(0,days,costs,dp);\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810728,
                "title": "c-3-approaches",
                "content": "We can solve this problem using dynamic programming. If we define:\\n\\n* `dp[i] = minimum cost for tickets on day i`\\n\\nThen, at each step, we have 3 options:\\n\\n* `dp[i] = dp[i -  1] + costs[0]\\t// for 1-day pass`\\n* `dp[i] = dp[i -  7] + costs[1]\\t// for 7-day pass`\\n* `dp[i] = dp[i - 30] + costs[2]\\t// for 30-day pass`\\n\\nApproaches 2 & 3 use this definition.\\n\\nWe can also define our `dp` table a bit differently:\\n\\n* `dp[i] = minimum cost for tickets on day days[i]`\\n\\nNote the subtle difference, it\\'s not on day `i` but rather on day `days[i]`. Now we have a problem, how do we find a value `x` in `days` where:\\n\\n* `x >= days[i] - 1`\\n* `x >= days[i] - 7`\\n* `x >= days[i] - 30`\\n\\nFor this we can use binary search shown in Approach 1.\\n\\n### **Approach 1: DP + Binary Search**\\n\\nWe find the previous day greater than or equal to `x` using binary search. Usually, we would use `std::lower_bound` for this but in this case our `dp` table is one-indexed instead of zero-indexed. So we use `std::upper_bound` instead.\\n\\n```cpp\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\tint n = days.size();\\n\\tvector<int> dp(n + 1);\\n\\tfor (int j, i = 1; i <= n; i++) {\\n\\t\\tdp[i] = dp[i - 1] + costs[0];\\n\\t\\tj = distance(days.begin(), upper_bound(days.begin(), days.begin() + i, days[i - 1] - 7));\\n\\t\\tdp[i] = min(dp[j] + costs[1], dp[i]);\\n\\t\\tj = distance(days.begin(), upper_bound(days.begin(), days.begin() + i, days[i - 1] - 30));\\n\\t\\tdp[i] = min(dp[j] + costs[2], dp[i]);\\n\\t}\\n\\treturn dp[n];\\n}\\n```\\n\\n### **Complexity**\\n* Time: `O(n \\u2022 log n)`\\n* Space: `O(n)`\\n\\nwhere `n` is the number of days.\\n\\n### **Approach 2: DP + HashSet**\\n\\nWe can only buy a ticket on a day we fly, _not_ on other days. So we need a quick way to check if given a day `x`, whether it exists in `days`. For this we can use a HashSet or `std::unordered_set`.\\n\\n```cpp\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\tint n = days.back();\\n\\tvector<int> dp(n + 1);\\n\\tunordered_set<int> seen(days.begin(), days.end());\\n\\t\\n\\t// dynamic programming\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tif (!seen.count(i))\\n\\t\\t\\tdp[i] = dp[i - 1];\\n\\t\\telse\\n\\t\\t\\tdp[i] = min({dp[i - 1         ] + costs[0],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i -  7)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i - 30)] + costs[2]});\\n\\t}\\n\\t\\n\\treturn dp[n];\\n}\\n```\\n\\n### **Complexity**\\n* Time: `O(n)`\\n* Space: `O(n)`\\n\\nwhere `n` is the last day.\\n\\n### **Approach 3: DP**\\n\\nInstead of using a HashSet to check if a given day `x` exists in `days`, we can initialize it to some cost which we know we can never have, this cost can be anything `<= 0`, I chose cost zero to keep things simple.\\n\\n```cpp\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\tint n = days.back();\\n\\tvector<int> dp(n + 1);\\n\\t\\n\\t// initialization\\n\\tfor (int& day: days)\\n\\t\\tdp[day] = numeric_limits<int>::max();\\n\\t\\n\\t// dynamic programming\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tif (dp[i] == 0)\\n\\t\\t\\tdp[i] = dp[i - 1];\\n\\t\\telse\\n\\t\\t\\tdp[i] = min({dp[i - 1         ] + costs[0],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i -  7)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i - 30)] + costs[2]});\\n\\t}\\n\\t\\n\\treturn dp[n];\\n}\\n```\\n\\n### **Complexity**\\n* Time: `O(n)`\\n* Space: `O(n)`\\n\\nwhere `n` is the last day.\\n\\n**Question:** What approach did you like the most?\\n\\nI\\'d say I like Approach 3 as it is very clean and fast too. However, if the number of days are much smaller, then Approach 1 would win.\\n\\nFind solutions to [this](https://github.com/Mohammed-Shoaib/Coding-Problems/blob/master/LeetCode/Solutions/LC0983.cpp?ts=4) and many other problems on my GitHub!\\n* [Coding-Problems](https://github.com/Mohammed-Shoaib/Coding-Problems/tree/master/LeetCode)\\n\\nI hope this helps :)",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\tint n = days.size();\\n\\tvector<int> dp(n + 1);\\n\\tfor (int j, i = 1; i <= n; i++) {\\n\\t\\tdp[i] = dp[i - 1] + costs[0];\\n\\t\\tj = distance(days.begin(), upper_bound(days.begin(), days.begin() + i, days[i - 1] - 7));\\n\\t\\tdp[i] = min(dp[j] + costs[1], dp[i]);\\n\\t\\tj = distance(days.begin(), upper_bound(days.begin(), days.begin() + i, days[i - 1] - 30));\\n\\t\\tdp[i] = min(dp[j] + costs[2], dp[i]);\\n\\t}\\n\\treturn dp[n];\\n}\\n```\n```cpp\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\tint n = days.back();\\n\\tvector<int> dp(n + 1);\\n\\tunordered_set<int> seen(days.begin(), days.end());\\n\\t\\n\\t// dynamic programming\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tif (!seen.count(i))\\n\\t\\t\\tdp[i] = dp[i - 1];\\n\\t\\telse\\n\\t\\t\\tdp[i] = min({dp[i - 1         ] + costs[0],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i -  7)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i - 30)] + costs[2]});\\n\\t}\\n\\t\\n\\treturn dp[n];\\n}\\n```\n```cpp\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\tint n = days.back();\\n\\tvector<int> dp(n + 1);\\n\\t\\n\\t// initialization\\n\\tfor (int& day: days)\\n\\t\\tdp[day] = numeric_limits<int>::max();\\n\\t\\n\\t// dynamic programming\\n\\tfor (int i = 1; i <= n; i++) {\\n\\t\\tif (dp[i] == 0)\\n\\t\\t\\tdp[i] = dp[i - 1];\\n\\t\\telse\\n\\t\\t\\tdp[i] = min({dp[i - 1         ] + costs[0],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i -  7)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[max(0, i - 30)] + costs[2]});\\n\\t}\\n\\t\\n\\treturn dp[n];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 583652,
                "title": "java-bottom-up-dp-solution",
                "content": "```\\nclass Solution \\n{\\n    public int mincostTickets(int[] days, int[] costs) \\n    {\\n        int[] dp = new int[366];\\n        dp[0] = 0; //no days to travel, no need to spend anything..!!!\\n            \\n        int j=0; //to iterate days array\\n        for(int i=1;i<=365;i++)\\n        {\\n            if(j==days.length)\\n                break; //when we are done with our travel days we break.\\n            \\n            if(days[j] != i) // if the day is not a travel day, just put the previous day cost.\\n                dp[i] = dp[i-1];\\n            \\n            else\\n            {\\n                int one = costs[0] + dp[i-1];\\n                int seven = costs[1] + dp[Math.max(0, i-7)];\\n                int thirty = costs[2] + dp[Math.max(0, i-30)];\\n                \\n                dp[i] = Math.min(one, Math.min(seven, thirty));\\n                \\n                j++;\\n            }\\n        }\\n        \\n        //System.out.println(Arrays.toString(dp));\\n        return dp[days[days.length-1]];\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution \\n{\\n    public int mincostTickets(int[] days, int[] costs) \\n    {\\n        int[] dp = new int[366];\\n        dp[0] = 0; //no days to travel, no need to spend anything..!!!\\n            \\n        int j=0; //to iterate days array\\n        for(int i=1;i<=365;i++)\\n        {\\n            if(j==days.length)\\n                break; //when we are done with our travel days we break.\\n            \\n            if(days[j] != i) // if the day is not a travel day, just put the previous day cost.\\n                dp[i] = dp[i-1];\\n            \\n            else\\n            {\\n                int one = costs[0] + dp[i-1];\\n                int seven = costs[1] + dp[Math.max(0, i-7)];\\n                int thirty = costs[2] + dp[Math.max(0, i-30)];\\n                \\n                dp[i] = Math.min(one, Math.min(seven, thirty));\\n                \\n                j++;\\n            }\\n        }\\n        \\n        //System.out.println(Arrays.toString(dp));\\n        return dp[days[days.length-1]];\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349667,
                "title": "recursion-memoization-tabulation-easiest-to-understand",
                "content": "### RECURSION\\n```\\nclass Solution {\\npublic:\\n    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)\\n    {\\n        int target = days[daysIdx] + ticketDuration - 1; //Max I can travel upto this \\'day Number\\'\\n        for (int i = daysIdx + 1; i < days.size(); i++)\\n        {\\n            if (days[i] > target) return i;\\n        }\\n        return days.size();\\n    }\\n    int solve(vector<int>& days, vector<int>& costs, vector<int>& ticketDurations, int daysIdx)\\n    {\\n        if (daysIdx == days.size()) return 0;\\n        \\n        int minTravelCost = INT_MAX;\\n        //==============================================================================\\n        for (int i = 0; i < 3; i++)\\n        {\\n            int ticketCost = costs[i], ticketDuration = ticketDurations[i];\\n            int nextDaysIdx = getNextDaysIdx(days, daysIdx, ticketDuration);\\n            \\n            int travelCost = ticketCost + solve(days, costs, ticketDurations, nextDaysIdx);\\n            minTravelCost = min(minTravelCost, travelCost);\\n        }\\n        //===================================================================================\\n        return minTravelCost;\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) \\n    {\\n        vector<int>ticketDurations = {1, 7, 30};\\n        int ans = solve(days, costs, ticketDurations, 0);\\n        return ans;\\n        \\n    }\\n};\\n```\\n//==========================================\\n### TOP - DOWN - MEMOIZATION\\n```\\nclass Solution {\\npublic:\\n    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)\\n    {\\n        int target = days[daysIdx] + ticketDuration - 1;\\n        for (int i = daysIdx + 1; i < days.size(); i++)\\n        {\\n            if (days[i] > target) return i;\\n        }\\n        return days.size();\\n    }\\n    int solve(vector<int>& days, vector<int>& costs, vector<int>& ticketDurations, vector<int>&dp, int daysIdx)\\n    {\\n        if (daysIdx == days.size()) return 0;\\n        \\n        if (dp[daysIdx] !=  -1) return dp[daysIdx];\\n        int minTravelCost = INT_MAX;\\n        //============================================================================\\n        for (int i = 0; i < 3; i++)\\n        {\\n            int ticketCost = costs[i], ticketDuration = ticketDurations[i];\\n            int nextDaysIdx = getNextDaysIdx(days, daysIdx, ticketDuration);\\n            \\n            int travelCost = ticketCost + solve(days, costs, ticketDurations, dp, nextDaysIdx);\\n            minTravelCost = min(minTravelCost, travelCost);\\n        }\\n        //==============================================================================\\n        return dp[daysIdx] = minTravelCost;\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) \\n    {\\n        vector<int>ticketDurations = {1, 7, 30};\\n        vector<int>dp(days.size(), -1);\\n        int ans = solve(days, costs, ticketDurations, dp, 0);\\n        return ans;\\n    }\\n};\\n```\\n//====================================================================================\\n### BOTTOM UP - TABULATION\\n```\\nclass Solution {\\npublic:\\n    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)\\n    {\\n        int target = days[daysIdx] + ticketDuration - 1;\\n        for (int i = daysIdx + 1; i < days.size(); i++)\\n        {\\n            if (days[i] > target) return i;\\n        }\\n        return days.size();\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) \\n    {\\n        int n = days.size();\\n        vector<int>ticketDurations = {1, 7, 30};\\n        vector<int>dp(n);\\n        //If I start at last day I can pick the min cost ticket instead of taking ticket for \\'1\\' day duration\\n        dp[n - 1] = *min_element(costs.begin(), costs.end()); \\n        for (int currDaysIdx = n - 2; currDaysIdx >= 0; currDaysIdx--)\\n        {\\n            int minTravelCost = INT_MAX;\\n            //=================================================================\\n            for (int i = 0; i < 3; i++)\\n            {\\n                int ticketCost = costs[i], ticketDuration = ticketDurations[i];\\n                int nextDaysIdx = getNextDaysIdx(days, currDaysIdx, ticketDuration);\\n                \\n                int nextTravelCost = (nextDaysIdx >= n)? 0 : dp[nextDaysIdx];\\n                int travelCost = ticketCost + nextTravelCost;\\n                minTravelCost = min(minTravelCost, travelCost);\\n            }\\n            //======================================================================\\n            dp[currDaysIdx] = minTravelCost;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)\\n    {\\n        int target = days[daysIdx] + ticketDuration - 1; //Max I can travel upto this \\'day Number\\'\\n        for (int i = daysIdx + 1; i < days.size(); i++)\\n        {\\n            if (days[i] > target) return i;\\n        }\\n        return days.size();\\n    }\\n    int solve(vector<int>& days, vector<int>& costs, vector<int>& ticketDurations, int daysIdx)\\n    {\\n        if (daysIdx == days.size()) return 0;\\n        \\n        int minTravelCost = INT_MAX;\\n        //==============================================================================\\n        for (int i = 0; i < 3; i++)\\n        {\\n            int ticketCost = costs[i], ticketDuration = ticketDurations[i];\\n            int nextDaysIdx = getNextDaysIdx(days, daysIdx, ticketDuration);\\n            \\n            int travelCost = ticketCost + solve(days, costs, ticketDurations, nextDaysIdx);\\n            minTravelCost = min(minTravelCost, travelCost);\\n        }\\n        //===================================================================================\\n        return minTravelCost;\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) \\n    {\\n        vector<int>ticketDurations = {1, 7, 30};\\n        int ans = solve(days, costs, ticketDurations, 0);\\n        return ans;\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)\\n    {\\n        int target = days[daysIdx] + ticketDuration - 1;\\n        for (int i = daysIdx + 1; i < days.size(); i++)\\n        {\\n            if (days[i] > target) return i;\\n        }\\n        return days.size();\\n    }\\n    int solve(vector<int>& days, vector<int>& costs, vector<int>& ticketDurations, vector<int>&dp, int daysIdx)\\n    {\\n        if (daysIdx == days.size()) return 0;\\n        \\n        if (dp[daysIdx] !=  -1) return dp[daysIdx];\\n        int minTravelCost = INT_MAX;\\n        //============================================================================\\n        for (int i = 0; i < 3; i++)\\n        {\\n            int ticketCost = costs[i], ticketDuration = ticketDurations[i];\\n            int nextDaysIdx = getNextDaysIdx(days, daysIdx, ticketDuration);\\n            \\n            int travelCost = ticketCost + solve(days, costs, ticketDurations, dp, nextDaysIdx);\\n            minTravelCost = min(minTravelCost, travelCost);\\n        }\\n        //==============================================================================\\n        return dp[daysIdx] = minTravelCost;\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) \\n    {\\n        vector<int>ticketDurations = {1, 7, 30};\\n        vector<int>dp(days.size(), -1);\\n        int ans = solve(days, costs, ticketDurations, dp, 0);\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getNextDaysIdx(vector<int>&days, int daysIdx, int ticketDuration)\\n    {\\n        int target = days[daysIdx] + ticketDuration - 1;\\n        for (int i = daysIdx + 1; i < days.size(); i++)\\n        {\\n            if (days[i] > target) return i;\\n        }\\n        return days.size();\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) \\n    {\\n        int n = days.size();\\n        vector<int>ticketDurations = {1, 7, 30};\\n        vector<int>dp(n);\\n        //If I start at last day I can pick the min cost ticket instead of taking ticket for \\'1\\' day duration\\n        dp[n - 1] = *min_element(costs.begin(), costs.end()); \\n        for (int currDaysIdx = n - 2; currDaysIdx >= 0; currDaysIdx--)\\n        {\\n            int minTravelCost = INT_MAX;\\n            //=================================================================\\n            for (int i = 0; i < 3; i++)\\n            {\\n                int ticketCost = costs[i], ticketDuration = ticketDurations[i];\\n                int nextDaysIdx = getNextDaysIdx(days, currDaysIdx, ticketDuration);\\n                \\n                int nextTravelCost = (nextDaysIdx >= n)? 0 : dp[nextDaysIdx];\\n                int travelCost = ticketCost + nextTravelCost;\\n                minTravelCost = min(minTravelCost, travelCost);\\n            }\\n            //======================================================================\\n            dp[currDaysIdx] = minTravelCost;\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842592,
                "title": "c-easy-to-understand-brute-to-efficient-clean-concise-faster",
                "content": "**Idea**\\n1.  We have three choices: Either we can choose first Pass, second Pass or Last Pass\\n2.  If any day is within validity of earlier choosen pass then we can travel without any cost.\\n3.  Base Condition: If we complete our travel, we don\\'t need to pay any cost \\n\\n**Brute Force [Recursion]**\\n```\\nclass Solution {\\n    int solve(vector<int>& days, vector<int>& costs, int i, int validity) {\\n        if(i >= days.size())\\n            return 0;\\n        \\n        if(days[i] <= validity)\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return solve(days, costs, i+1, validity);\\n        else {\\n            int ch1 = costs[0] + solve(days, costs, i+1, days[i]);\\n            int ch2 = costs[1] + solve(days, costs, i+1, days[i]+6);\\n            int ch3 = costs[2] + solve(days, costs, i+1, days[i]+29);\\n            return min(ch1, min(ch2, ch3));\\n        }\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        return solve(days, costs, 0, 0);\\n    }\\n};\\n```\\n\\n**Efficient Solution [Recursion + Memoization]**\\n```\\nclass Solution {\\n    int solve(vector<int>& days, vector<int>& costs, int i, int validity, vector<vector<int>> &dp) {\\n        if(i >= days.size())\\n            return 0;\\n        if(dp[i][validity] != -1)\\n            return dp[i][validity];\\n        if(days[i] <= validity)\\n            return dp[i][validity] = solve(days, costs, i+1, validity, dp);\\n        else {\\n            int ch1 = costs[0] + solve(days, costs, i+1, days[i], dp);\\n            int ch2 = costs[1] + solve(days, costs, i+1, days[i]+6, dp);\\n            int ch3 = costs[2] + solve(days, costs, i+1, days[i]+29, dp);\\n            return dp[i][validity] = min(ch1, min(ch2, ch3));\\n        }\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        int max_validity = days[n-1] + 30;\\n        vector<vector<int>> dp(n, vector<int>(max_validity, -1));\\n        return solve(days, costs, 0, 0, dp);\\n    }\\n};\\n```\\n\\n**If liked my approach and solution, do upvote!**\\n**If you have any doubt comment**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int solve(vector<int>& days, vector<int>& costs, int i, int validity) {\\n        if(i >= days.size())\\n            return 0;\\n        \\n        if(days[i] <= validity)\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0return solve(days, costs, i+1, validity);\\n        else {\\n            int ch1 = costs[0] + solve(days, costs, i+1, days[i]);\\n            int ch2 = costs[1] + solve(days, costs, i+1, days[i]+6);\\n            int ch3 = costs[2] + solve(days, costs, i+1, days[i]+29);\\n            return min(ch1, min(ch2, ch3));\\n        }\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        return solve(days, costs, 0, 0);\\n    }\\n};\\n```\n```\\nclass Solution {\\n    int solve(vector<int>& days, vector<int>& costs, int i, int validity, vector<vector<int>> &dp) {\\n        if(i >= days.size())\\n            return 0;\\n        if(dp[i][validity] != -1)\\n            return dp[i][validity];\\n        if(days[i] <= validity)\\n            return dp[i][validity] = solve(days, costs, i+1, validity, dp);\\n        else {\\n            int ch1 = costs[0] + solve(days, costs, i+1, days[i], dp);\\n            int ch2 = costs[1] + solve(days, costs, i+1, days[i]+6, dp);\\n            int ch3 = costs[2] + solve(days, costs, i+1, days[i]+29, dp);\\n            return dp[i][validity] = min(ch1, min(ch2, ch3));\\n        }\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        int max_validity = days[n-1] + 30;\\n        vector<vector<int>> dp(n, vector<int>(max_validity, -1));\\n        return solve(days, costs, 0, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349849,
                "title": "easy-solution-with-explanation-in-java-dp",
                "content": "# Intuition\\nSince we will have to use previous calculation to reach the end result we will be using Dyanmic programing to solve this. The thogugh for DP is to always think about what would happen for ith day.\\n\\ndp[i] will represent the min cost till that day.\\n\\nSo on ith day one of the following would occur\\n- We buy a one day ticket i.e one day before cost + 1 day ticket cost which looks like dp[i-1] + costs[0].\\n- We buy a seven day valid ticket which is dp[i-7] + costs[1]. ****But catch here is that we may still be at day 5(index 5) so 5-7 = -2 so that is a case we need to handle so dp[Math.max(0,i-7)] + costs[1]****\\n- We 30 days pass dp[Math.max(0,i-30)] + costs[2]\\n\\n*The underflow condition where we do Math.max(0, i-x) is imp and comes to mind only with practice*\\n\\n\\n---\\n\\n\\n# Approach\\n1) Define dp array to n+1 length where n is the max day we need to travel i.e days[length-1] element.\\n2) Since we don\\'t visit all the days we will maintain a boolean travel day array or Set anything would work\\n3) We traverse through all days and calculate\\n4) If the day is not in travel list cost remains same as what it costed us for last day i.e dp[i] = dp[i-1] where ith day is not travelled one\\n5) For travelled day i have explained above.\\n6) Return the value at last index of dp\\n\\nTo understand different type of DP see this [Leetcode award wining article](https://leetcode.com/discuss/general-discussion/458695/dynamic-programming-patterns) that helped me during my prepartion time\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n) Since we are travesing the days array once.\\n\\n- Space complexity:\\nO(n) for the DP array\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        \\n        int maxDay = days[days.length-1];\\n        boolean [] travelDay = new boolean[maxDay+1];\\n        for(int day: days){\\n            travelDay[day] =true;\\n        }\\n        int [] dp = new int[maxDay+1];\\n        dp[0]=0;\\n        \\n        for(int i=1;i<=maxDay;i++){\\n            if(!travelDay[i]){\\n                //dont have to buy a ticket if it is not a travel day\\n                dp[i]=dp[i-1]; \\n                continue;\\n            }\\n            dp[i] = costs[0]+dp[i-1];\\n            dp[i] = Math.min(dp[Math.max(0,i-7)]+costs[1],dp[i]);\\n            dp[i] = Math.min(dp[Math.max(0,i-30)]+costs[2],dp[i]);\\n        }\\n        return dp[maxDay];\\n    }\\n}\\n```\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging.\\n\\n![LCUpvote.png](https://assets.leetcode.com/users/images/f3061d04-264d-411d-927e-55aa85c647aa_1679972485.450106.png)\\n",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        \\n        int maxDay = days[days.length-1];\\n        boolean [] travelDay = new boolean[maxDay+1];\\n        for(int day: days){\\n            travelDay[day] =true;\\n        }\\n        int [] dp = new int[maxDay+1];\\n        dp[0]=0;\\n        \\n        for(int i=1;i<=maxDay;i++){\\n            if(!travelDay[i]){\\n                //dont have to buy a ticket if it is not a travel day\\n                dp[i]=dp[i-1]; \\n                continue;\\n            }\\n            dp[i] = costs[0]+dp[i-1];\\n            dp[i] = Math.min(dp[Math.max(0,i-7)]+costs[1],dp[i]);\\n            dp[i] = Math.min(dp[Math.max(0,i-30)]+costs[2],dp[i]);\\n        }\\n        return dp[maxDay];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227236,
                "title": "python-solution",
                "content": "We construct a `dp` array with `dp[i]` recording the minimum cost up to `days[i]` (inclusive). We initialize `dp[0] = costs[0]`, and iterate `i` in `range(1, len(days))`, for each `i`, we initialize a pointer `j`, and let it traverse backwards starting with `i` to find the first `idx` such that `days[idx]` is at least 1 day, 7 days, and 30 days ago respectively from `days[i]`. We find the minimum of the three values and let `dp[i]` be that value. Since for each `i`, `j` can go back by at most 30 indices, the total runtime is `O(30*n) = O(n)`, and the space complexity is `O(n)`.\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days: \\'List[int]\\', costs: \\'List[int]\\') -> \\'int\\':\\n        n = len(days)\\n        dp = [0]*n\\n        dp[0] = costs[0]\\n        for i in range(1, n):\\n            \\n            # buy one-day ticket\\n            dp[i] = dp[i-1]+costs[0]\\n            \\n            # what about buy seven-day ticket seven days ago\\n            j = i\\n            seven_ago = days[i]-7\\n            while j >= 0 and days[j] > seven_ago:\\n                j -= 1\\n            if j >= 0:\\n                dp[i] = min(dp[i], dp[j]+costs[1])\\n            else:\\n                dp[i] = min(dp[i], costs[1])\\n            \\n            # what about buy thirty-day ticket thirty days ago\\n            thirty_ago = days[i]-30\\n            while j >= 0 and days[j] > thirty_ago:\\n                j -= 1\\n            if j >= 0:\\n                dp[i] = min(dp[i], dp[j]+costs[2])\\n            else:\\n                dp[i] = min(dp[i], costs[2])\\n                \\n        return dp[-1]\\n```\\n\\nAnother solution: We can initialize a `dp` array and fill in every entry between `days[0]` and `days[-1]` with the minimum costs up to the respective day. This will eliminate the need to use another pointer to traverse back to find the minimum costs 1 day, 7 days, and 30 days ago. \\n\\nTime complexity: `O(m)`, space complexity: `O(m)`, where `m` is the range of days in `days`. We see that when `days` covers a wide range of days (`m` large `n` small), e.g., `days = [1, 365]`, the first algorithm performs better, and when `len(days)` is large but covers a relative small range of days (`n` large `m` small), e.g., `days = [4,6,8,9,10,12,15,20]`, the second algorithhm performs better.\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days: \\'List[int]\\', costs: \\'List[int]\\') -> \\'int\\':\\n        dp = [0]*366\\n        j = 0\\n        for i in range(days[0], 366):\\n            if i == days[j]:\\n                dp[i] = dp[i-1]+costs[0]\\n                if i >= 7:\\n                    dp[i] = min(dp[i-7]+costs[1], dp[i])\\n                else:\\n                    dp[i] = min(dp[i], costs[1])\\n                if i >= 30:\\n                    dp[i] = min(dp[i-30]+costs[2], dp[i])\\n                else:\\n                    dp[i] = min(dp[i], costs[2])\\n                j += 1\\n                if j == len(days):\\n                    return dp[i]\\n            else:\\n                if i > 0:\\n                    dp[i] = dp[i-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: \\'List[int]\\', costs: \\'List[int]\\') -> \\'int\\':\\n        n = len(days)\\n        dp = [0]*n\\n        dp[0] = costs[0]\\n        for i in range(1, n):\\n            \\n            # buy one-day ticket\\n            dp[i] = dp[i-1]+costs[0]\\n            \\n            # what about buy seven-day ticket seven days ago\\n            j = i\\n            seven_ago = days[i]-7\\n            while j >= 0 and days[j] > seven_ago:\\n                j -= 1\\n            if j >= 0:\\n                dp[i] = min(dp[i], dp[j]+costs[1])\\n            else:\\n                dp[i] = min(dp[i], costs[1])\\n            \\n            # what about buy thirty-day ticket thirty days ago\\n            thirty_ago = days[i]-30\\n            while j >= 0 and days[j] > thirty_ago:\\n                j -= 1\\n            if j >= 0:\\n                dp[i] = min(dp[i], dp[j]+costs[2])\\n            else:\\n                dp[i] = min(dp[i], costs[2])\\n                \\n        return dp[-1]\\n```\n```\\nclass Solution:\\n    def mincostTickets(self, days: \\'List[int]\\', costs: \\'List[int]\\') -> \\'int\\':\\n        dp = [0]*366\\n        j = 0\\n        for i in range(days[0], 366):\\n            if i == days[j]:\\n                dp[i] = dp[i-1]+costs[0]\\n                if i >= 7:\\n                    dp[i] = min(dp[i-7]+costs[1], dp[i])\\n                else:\\n                    dp[i] = min(dp[i], costs[1])\\n                if i >= 30:\\n                    dp[i] = min(dp[i-30]+costs[2], dp[i])\\n                else:\\n                    dp[i] = min(dp[i], costs[2])\\n                j += 1\\n                if j == len(days):\\n                    return dp[i]\\n            else:\\n                if i > 0:\\n                    dp[i] = dp[i-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350479,
                "title": "day-87-dp-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\nThe approach used in the code is dynamic programming, where the algorithm maintains a dynamic programming array dp that stores the minimum cost of travel for each day of the year. The algorithm initializes dp[0] to zero since the cost of traveling on day 0 is zero. For each day from day 1 to day 365, the algorithm checks whether that day is in the days list or not. If the day is in the days list, the algorithm calculates the minimum cost of travel for that day based on the minimum cost of travel for the previous day plus the cost of buying a 1-day pass, buying a 7-day pass, or buying a 30-day pass. The algorithm uses the minimum of these costs to update the dynamic programming array dp. If the day is not in the days list, the algorithm simply copies the value of dp[i-1] to dp[i].\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Create a function called mincostTickets that takes in two input parameters: days and costs.\\n2. Get the length of the days list and store it in a variable called n.\\n3. Create a dynamic programming array called dp of size 366 and fill it with INT_MAX.\\n4. Set dp[0] = 0 since the cost of travel on day 0 is zero.\\n5. Set a pointer j = 0.\\n6. Loop through all days from day 1 to day 365.\\n7. If the current day i equals the j-th day in the days list, then calculate the minimum cost of travel for that day using the following conditions:\\n    - a. dp[i] = min(dp[i], dp[i-1] + costs[0]) - If the cost of buying a 1-day pass and traveling on this day is cheaper than the previously calculated cost, then update dp[i].\\n    - b. if (i >= 7), dp[i] = min(dp[i], dp[i-7] + costs[1]) - If the cost of buying a 7-day pass and traveling on this day is cheaper than the previously calculated cost, then update dp[i].\\n    - c. if (i >= 30), dp[i] = min(dp[i], dp[i-30] + costs[2]) - If the cost of buying a 30-day pass and traveling on this day is cheaper than the previously calculated cost, then update dp[i].\\n    - d. Increment the pointer j.\\n1. Else, if the current day i is not in the days list, then dp[i] = dp[i-1].\\n2. Return dp[365], which gives the minimum cost of travel for the entire year.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(366, INT_MAX);\\n        dp[0] = 0;\\n        int j = 0;\\n        for (int i = 1; i <= 365; i++) {\\n            if (j < n && i == days[j]) {\\n                dp[i] = min(dp[i], dp[i-1] + costs[0]);\\n                if (i >= 7) \\n                    dp[i] = min(dp[i], dp[i-7] + costs[1]);\\n                else \\n                    dp[i] = min(dp[i], costs[1]);\\n                if (i >= 30) \\n                    dp[i] = min(dp[i], dp[i-30] + costs[2]);\\n                else \\n                    dp[i] = min(dp[i], costs[2]);\\n                j++;\\n            } \\n            else {\\n                dp[i] = dp[i-1];\\n            }\\n        }\\n        return dp[365];\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int[] dp = new int[366];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        int j = 0;\\n        for (int i = 1; i <= 365; i++) {\\n            if (j < n && i == days[j]) {\\n                dp[i] = Math.min(dp[i], dp[i-1] + costs[0]);\\n                if (i >= 7) \\n                    dp[i] = Math.min(dp[i], dp[i-7] + costs[1]);\\n                else \\n                    dp[i] = Math.min(dp[i], costs[1]);\\n                if (i >= 30) \\n                    dp[i] = Math.min(dp[i], dp[i-30] + costs[2]);\\n                else \\n                    dp[i] = Math.min(dp[i], costs[2]);\\n                j++;\\n            } \\n            else {\\n                dp[i] = dp[i-1];\\n            }\\n        }\\n        return dp[365];\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n = len(days)\\n        dp = [float(\\'inf\\')] * 366\\n        dp[0] = 0\\n        j = 0\\n        for i in range(1, 366):\\n            if j < n and i == days[j]:\\n                dp[i] = min(dp[i], dp[i-1] + costs[0])\\n                if i >= 7:\\n                    dp[i] = min(dp[i], dp[i-7] + costs[1])\\n                else:\\n                    dp[i] = min(dp[i], costs[1])\\n                if i >= 30:\\n                    dp[i] = min(dp[i], dp[i-30] + costs[2])\\n                else:\\n                    dp[i] = min(dp[i], costs[2])\\n                j += 1\\n            else:\\n                dp[i] = dp[i-1]\\n        return dp[365]\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity : **O(365*n) = O(n)**, where n is the length of the days list.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : **O(366) = O(1)**, since we only use a fixed size array of 366 elements.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(366, INT_MAX);\\n        dp[0] = 0;\\n        int j = 0;\\n        for (int i = 1; i <= 365; i++) {\\n            if (j < n && i == days[j]) {\\n                dp[i] = min(dp[i], dp[i-1] + costs[0]);\\n                if (i >= 7) \\n                    dp[i] = min(dp[i], dp[i-7] + costs[1]);\\n                else \\n                    dp[i] = min(dp[i], costs[1]);\\n                if (i >= 30) \\n                    dp[i] = min(dp[i], dp[i-30] + costs[2]);\\n                else \\n                    dp[i] = min(dp[i], costs[2]);\\n                j++;\\n            } \\n            else {\\n                dp[i] = dp[i-1];\\n            }\\n        }\\n        return dp[365];\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int[] dp = new int[366];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        int j = 0;\\n        for (int i = 1; i <= 365; i++) {\\n            if (j < n && i == days[j]) {\\n                dp[i] = Math.min(dp[i], dp[i-1] + costs[0]);\\n                if (i >= 7) \\n                    dp[i] = Math.min(dp[i], dp[i-7] + costs[1]);\\n                else \\n                    dp[i] = Math.min(dp[i], costs[1]);\\n                if (i >= 30) \\n                    dp[i] = Math.min(dp[i], dp[i-30] + costs[2]);\\n                else \\n                    dp[i] = Math.min(dp[i], costs[2]);\\n                j++;\\n            } \\n            else {\\n                dp[i] = dp[i-1];\\n            }\\n        }\\n        return dp[365];\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n = len(days)\\n        dp = [float(\\'inf\\')] * 366\\n        dp[0] = 0\\n        j = 0\\n        for i in range(1, 366):\\n            if j < n and i == days[j]:\\n                dp[i] = min(dp[i], dp[i-1] + costs[0])\\n                if i >= 7:\\n                    dp[i] = min(dp[i], dp[i-7] + costs[1])\\n                else:\\n                    dp[i] = min(dp[i], costs[1])\\n                if i >= 30:\\n                    dp[i] = min(dp[i], dp[i-30] + costs[2])\\n                else:\\n                    dp[i] = min(dp[i], costs[2])\\n                j += 1\\n            else:\\n                dp[i] = dp[i-1]\\n        return dp[365]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500472,
                "title": "2-c-solutions-with-recursion-and-memorization",
                "content": "***We will simplify this question:***\\nFor each day we have 3 choices i.e. 1 day ticket, 7 day ticket and 30 day ticket. So we use recursion choosing 3 types of ticket each day and find out the minimum of those 3 types. \\n\\nLets take an example:\\ndays = {1, 3, 4, 9}    \\ncosts = {2, 4, 12}\\n\\n```\\ntaking 1 day ticket for day 1 and cost till now is 2\\ncost till day 1 is 2\\ntaking 1 day ticket for day 3 and cost till now is 4\\ncost till day 3 is 4\\ntaking 1 day ticket for day 4 and cost till now is 6\\ncost till day 4 is 6\\ntaking 1 day ticket for day 9 and cost till now is 8\\ncost till day 9 is 8\\ntaking 7 day ticket for day 9 and cost till now is 10\\ncost till day 9 is 10\\ntaking 30 day ticket for day 9 and cost till now is 18\\ncost till day 9 is 18\\ntaking 7 day ticket for day 4 and cost till now is 8\\ncost till day 4 is 8\\ngoing further because of validity 10 is greater than present day 9\\ncost till day 9 is 8\\ntaking 30 day ticket for day 4 and cost till now is 16\\ncost till day 4 is 16\\ngoing further because of validity 33 is greater than present day 9\\ncost till day 9 is 16\\ntaking 7 day ticket for day 3 and cost till now is 6\\ncost till day 3 is 6\\ngoing further because of validity 9 is greater than present day 4\\ncost till day 4 is 6\\ngoing further because of validity 9 is greater than present day 9\\ncost till day 9 is 6\\ntaking 30 day ticket for day 3 and cost till now is 14\\ncost till day 3 is 14\\ngoing further because of validity 32 is greater than present day 4\\ncost till day 4 is 14\\ngoing further because of validity 32 is greater than present day 9\\ncost till day 9 is 14\\ntaking 7 day ticket for day 1 and cost till now is 4\\ncost till day 1 is 4\\ngoing further because of validity 7 is greater than present day 3\\ncost till day 3 is 4\\ngoing further because of validity 7 is greater than present day 4\\ncost till day 4 is 4\\ntaking 1 day ticket for day 9 and cost till now is 6\\ncost till day 9 is 6\\ntaking 7 day ticket for day 9 and cost till now is 8\\ncost till day 9 is 8\\ntaking 30 day ticket for day 9 and cost till now is 16\\ncost till day 9 is 16\\ntaking 30 day ticket for day 1 and cost till now is 12\\ncost till day 1 is 12\\ngoing further because of validity 30 is greater than present day 3\\ncost till day 3 is 12\\ngoing further because of validity 30 is greater than present day 4\\ncost till day 4 is 12\\ngoing further because of validity 30 is greater than present day 9\\ncost till day 9 is 12\\n```\\n\\n*Hence most optimal is:*\\ntaking 1 day ticket for day 1 and cost till now is 2\\ntaking 7 day ticket for day 3 and cost till now is 6\\nday 4 and 9 are covered with the above ticket\\nTotal cost is 6\\n\\n***Recursion code:***\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        return helper(0,0, days, costs);\\n    }\\n    \\n    int helper(int index,int validity, vector<int>& days, vector<int>& costs) {\\n        // if we reach nth index\\n        if(index>=days.size()) \\n            return 0;\\n        \\n        // if we buy a ticket with validity greater than current day\\n        if(validity >= days[index])\\n            return helper(index+1, validity, days, costs);\\n        \\n        int mini = INT_MAX;\\n        // Taking 1 day ticket and adding cost to present cost\\n        mini = min(mini, costs[0]+helper(index+1, days[index], days, costs));\\n        // Taking 7 day ticket and adding cost to present cost\\n        mini = min(mini, costs[1]+helper(index+1, days[index]+6, days, costs));\\n        // Taking 30 day ticket and adding cost to present cost\\n        mini = min(mini, costs[2]+helper(index+1, days[index]+29, days, costs));\\n        \\n        // storing the minimum in dp\\n        return mini;\\n    }\\n};\\n```\\n\\n***Optimised approach:*** 4ms Memorization (retrieving minimum amount for the days which we have already calculated min)\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // declaring dp with size of no of days\\n        dp.resize(days.size(),-1);\\n        return helper(0,0, days, costs);\\n    }\\n    \\n    int helper(int index,int validity, vector<int>& days, vector<int>& costs)\\n    {\\n        // if we reach nth index\\n        if(index>=days.size()) \\n            return 0;\\n        \\n        // if we buy a ticket with validity greater than current day\\n        if(validity >= days[index])\\n            return helper(index+1, validity, days, costs);\\n        \\n        // if we have already came across day[index], we can return dp[index] which has the minimum cost\\n        if(dp[index] != -1)\\n            return dp[index];\\n\\n        int mini = INT_MAX;\\n        // Taking 1 day ticket and adding cost to present cost\\n        mini = min(mini, costs[0]+helper(index+1, days[index], days, costs));\\n        // Taking 7 day ticket and adding cost to present cost\\n        mini = min(mini, costs[1]+helper(index+1, days[index]+6, days, costs));\\n        // Taking 30 day ticket and adding cost to present cost\\n        mini = min(mini, costs[2]+helper(index+1, days[index]+29, days, costs));\\n        \\n        // storing the minimum in dp\\n        return dp[index]=mini;\\n    }\\n};\\n```\\n\\nPlease Upvote If you liked it \\u263A\\uFE0F!! It keeps me motivated to post solutions like these.\\nIf there are any suggestions / questions / mistakes in my post, comment below.",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\ntaking 1 day ticket for day 1 and cost till now is 2\\ncost till day 1 is 2\\ntaking 1 day ticket for day 3 and cost till now is 4\\ncost till day 3 is 4\\ntaking 1 day ticket for day 4 and cost till now is 6\\ncost till day 4 is 6\\ntaking 1 day ticket for day 9 and cost till now is 8\\ncost till day 9 is 8\\ntaking 7 day ticket for day 9 and cost till now is 10\\ncost till day 9 is 10\\ntaking 30 day ticket for day 9 and cost till now is 18\\ncost till day 9 is 18\\ntaking 7 day ticket for day 4 and cost till now is 8\\ncost till day 4 is 8\\ngoing further because of validity 10 is greater than present day 9\\ncost till day 9 is 8\\ntaking 30 day ticket for day 4 and cost till now is 16\\ncost till day 4 is 16\\ngoing further because of validity 33 is greater than present day 9\\ncost till day 9 is 16\\ntaking 7 day ticket for day 3 and cost till now is 6\\ncost till day 3 is 6\\ngoing further because of validity 9 is greater than present day 4\\ncost till day 4 is 6\\ngoing further because of validity 9 is greater than present day 9\\ncost till day 9 is 6\\ntaking 30 day ticket for day 3 and cost till now is 14\\ncost till day 3 is 14\\ngoing further because of validity 32 is greater than present day 4\\ncost till day 4 is 14\\ngoing further because of validity 32 is greater than present day 9\\ncost till day 9 is 14\\ntaking 7 day ticket for day 1 and cost till now is 4\\ncost till day 1 is 4\\ngoing further because of validity 7 is greater than present day 3\\ncost till day 3 is 4\\ngoing further because of validity 7 is greater than present day 4\\ncost till day 4 is 4\\ntaking 1 day ticket for day 9 and cost till now is 6\\ncost till day 9 is 6\\ntaking 7 day ticket for day 9 and cost till now is 8\\ncost till day 9 is 8\\ntaking 30 day ticket for day 9 and cost till now is 16\\ncost till day 9 is 16\\ntaking 30 day ticket for day 1 and cost till now is 12\\ncost till day 1 is 12\\ngoing further because of validity 30 is greater than present day 3\\ncost till day 3 is 12\\ngoing further because of validity 30 is greater than present day 4\\ncost till day 4 is 12\\ngoing further because of validity 30 is greater than present day 9\\ncost till day 9 is 12\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        return helper(0,0, days, costs);\\n    }\\n    \\n    int helper(int index,int validity, vector<int>& days, vector<int>& costs) {\\n        // if we reach nth index\\n        if(index>=days.size()) \\n            return 0;\\n        \\n        // if we buy a ticket with validity greater than current day\\n        if(validity >= days[index])\\n            return helper(index+1, validity, days, costs);\\n        \\n        int mini = INT_MAX;\\n        // Taking 1 day ticket and adding cost to present cost\\n        mini = min(mini, costs[0]+helper(index+1, days[index], days, costs));\\n        // Taking 7 day ticket and adding cost to present cost\\n        mini = min(mini, costs[1]+helper(index+1, days[index]+6, days, costs));\\n        // Taking 30 day ticket and adding cost to present cost\\n        mini = min(mini, costs[2]+helper(index+1, days[index]+29, days, costs));\\n        \\n        // storing the minimum in dp\\n        return mini;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // declaring dp with size of no of days\\n        dp.resize(days.size(),-1);\\n        return helper(0,0, days, costs);\\n    }\\n    \\n    int helper(int index,int validity, vector<int>& days, vector<int>& costs)\\n    {\\n        // if we reach nth index\\n        if(index>=days.size()) \\n            return 0;\\n        \\n        // if we buy a ticket with validity greater than current day\\n        if(validity >= days[index])\\n            return helper(index+1, validity, days, costs);\\n        \\n        // if we have already came across day[index], we can return dp[index] which has the minimum cost\\n        if(dp[index] != -1)\\n            return dp[index];\\n\\n        int mini = INT_MAX;\\n        // Taking 1 day ticket and adding cost to present cost\\n        mini = min(mini, costs[0]+helper(index+1, days[index], days, costs));\\n        // Taking 7 day ticket and adding cost to present cost\\n        mini = min(mini, costs[1]+helper(index+1, days[index]+6, days, costs));\\n        // Taking 30 day ticket and adding cost to present cost\\n        mini = min(mini, costs[2]+helper(index+1, days[index]+29, days, costs));\\n        \\n        // storing the minimum in dp\\n        return dp[index]=mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811626,
                "title": "c-simple-clear-dp-solution-explained-100-time-85-space",
                "content": "Okay, this program screamed \"dynamic programming\" since the first paragraph, so who am I to deny its requests? And who are you to question the fact that I hear voices while coding?!\\n\\nAnyway, we need to proceed so that:\\n* we build a dp array of `last + 1` elements, where `last` is the last day in `days` and `+ 1` is due to the fact that we will allow the first element to be `0` (and save ourselves the pain to think of every day `- 1` when otherwise moving through its indexes);\\n* we will proceed until the last element so that `dp[i]` will be the cumulative value of what we have paid up to the `i`th day (included);\\n* when we find a scheduled day (and, for convenience, we will use `j` to know which is going to be the next day from `days`), we will try to get the minimum between:\\n   - cost of a daily ticket (`costs[0]`), plus cumulative cost until the previous day;\\n   - cost of a weekly ticket (`costs[1]`), plus cumulative cost until the 7 days before (or from day `0`, whichever is lower);\\n   - cost of a monthly ticket (`costs[2]`), plus cumulative cost until the 30 days before (or from day `0`, whichever is lower);\\n* when we find an unscsheduled day (one not in the calendar), then we just carry on the value from the previous one, since our expenses won\\'t change.\\n\\nNotice that for weekly and monthly ticket having to get either the previous 7/30 days or from `0` is what will allow you to have a passing solutions even when the costs of the tickets are not in increasing order (you would fail otherwise, if you were to skip those ranges for the first days).\\n\\nOnce we are done, we just return the value of the last cell of `dp` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // initialising values\\n        int last = days.back(), dp[last + 1];\\n        dp[0] = 0;\\n        for (int i = 1, j = 0; i <= last; i++) {\\n            if (i == days[j]) {\\n                // moving j to the next number\\n                j++;\\n                // dp[i] must be the min of\\n                dp[i] = min({\\n                    // a daily ticket plus previous costs\\n                    costs[0] + dp[i - 1],\\n                    // a weekly ticket plus previous costs\\n                    costs[1] + dp[i - min(i, 7)],\\n                    // a monthly ticket plus previous costs\\n                    costs[2] + dp[i - min(i, 30)],\\n                });\\n            }\\n            else {\\n                // alternatively we keep progressing with the last recorded value\\n                dp[i] = dp[i - 1];\\n            }\\n        }\\n        return dp[last];\\n    }\\n};\\n```\\n\\nI am not sure how one might use less memory, if not having only an array (or maybe a deque) of 30 elements, but that seems rather expensive - suggestions are welcome as always :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // initialising values\\n        int last = days.back(), dp[last + 1];\\n        dp[0] = 0;\\n        for (int i = 1, j = 0; i <= last; i++) {\\n            if (i == days[j]) {\\n                // moving j to the next number\\n                j++;\\n                // dp[i] must be the min of\\n                dp[i] = min({\\n                    // a daily ticket plus previous costs\\n                    costs[0] + dp[i - 1],\\n                    // a weekly ticket plus previous costs\\n                    costs[1] + dp[i - min(i, 7)],\\n                    // a monthly ticket plus previous costs\\n                    costs[2] + dp[i - min(i, 30)],\\n                });\\n            }\\n            else {\\n                // alternatively we keep progressing with the last recorded value\\n                dp[i] = dp[i - 1];\\n            }\\n        }\\n        return dp[last];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226754,
                "title": "python-easy-to-understand-solution-with-comments",
                "content": "```\\ndef mincostTickets(self, days, costs):\\n    dp=[0]*366\\n    for d in range(366):\\n        if d not in days:\\n            dp[d]=dp[d-1]\\n            continue\\n\\t\\t//1-day pass on day d\\n        mincost=dp[d-1]+costs[0]\\n\\t\\t//7-day pass ending on or after day d\\n        mincost=min(mincost,dp[max(0,d-7)]+costs[1])\\n\\t\\t//30-day pass ending on or after day d\\n        mincost=min(mincost,dp[max(0,d-30)]+costs[2])\\n        dp[d]=mincost\\n    return dp[-1]",
                "solutionTags": [],
                "code": "```\\ndef mincostTickets(self, days, costs):\\n    dp=[0]*366\\n    for d in range(366):\\n        if d not in days:\\n            dp[d]=dp[d-1]\\n            continue\\n\\t\\t//1-day pass on day d\\n        mincost=dp[d-1]+costs[0]\\n\\t\\t//7-day pass ending on or after day d\\n        mincost=min(mincost,dp[max(0,d-7)]+costs[1])\\n\\t\\t//30-day pass ending on or after day d\\n        mincost=min(mincost,dp[max(0,d-30)]+costs[2])\\n        dp[d]=mincost\\n    return dp[-1]",
                "codeTag": "Python3"
            },
            {
                "id": 3350801,
                "title": "easy-detailed-explanation-step-by-step",
                "content": "# Intuition\\n\\nOn each day, we need to look into future days and analyze if purchasing a 7 day or a 30 day pass will be benefitial.\\n- Weird scenario is when 30 day pass will be cheapest, the we can purchase that even for one day. But we ignore such cases in explaination since our answer also covers these cases\\n- So in other scenarios, getting a 7 day is benefitial if we need to travel multiple time in next seven days and cost of one 7 day pass would be less than purchasing one day pass multiple times for those days.\\n- If 7 day pass is cheaper and better then we can purchase that, but it might be possible that we are travelling a lot in not just 7 days but in next 30 days and getting a 30 day pass might be even cheaper\\n- So for each day, we look forward and find how many times we travel in next 7 days/ 30 days and calculate cost related to each option and choose the minimum.\\n- This is recursive problem since cost is Minimum of three available options\\n  - Get a one day pass and add rest of cost from next day onwards\\n  - Get a 7 day pass and add this cost and cost for remaining days after this 7 day pass expires \\n  - Get a 30 day pass and add this cost and cost for remaining days after this 30 day pass expires \\n\\n# Approach\\nIf we follow recursive approach we will get TLE, since multilple earlier days will require answer for later day and will make multiple calls but we can store the result i.e use DP to optimize.\\n\\n So we maintain a DP array and start from last day and calculate cost for last day, then second last day and then so on.\\n\\nOn any particular day, we check how many days we travel in next 7/ 30 days and then add the cost of pass + the cost from the day in future when pass would have expired\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ Since we calculate values for DP array n times: for each time we can look forward upto a max 30 elements. So Actual complexity is 30*O(n) but for large n, 30 is a constant hence final complexity is O(n) only. \\n\\n- Space complexity:\\n$$O(n)$$ Since we maintain a DP array of size n.\\n\\n# Please upvote if you liked the post, Spread some love!!\\n![image.png](https://assets.leetcode.com/users/images/01777ae4-777e-4984-9b93-e93c87985d2d_1679992953.4628372.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        int dp[n];\\n\\n        for(int i = n-1; i>=0; i--)\\n        {\\n            // Option 1 - get a one day pass\\n            int opOne = costs[0] + (i < n-1 ? dp[i+1] : 0);\\n            int j;\\n            \\n            // Option 2 - get 7 day pass\\n            for(j = i+1; j < n && days[j] < days[i] + 7; j++);  // single line for loop to get past elements that are in next 7 days and have cost already covered by this pass\\n            int opTwo = costs[1] + (j < n ? dp[j] : 0);\\n\\n            //Option 3 - get 30 day pass\\n            //    Notice that same var j is used since elements that had days upto next 7 days have been iterated, now we need to go till 30\\n            for(; j < n && days[j] < days[i] + 30; j++);\\n            int opThree = costs[2] + (j < n ? dp[j] : 0);\\n\\n            dp[i] = min(opOne, min(opTwo, opThree));\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        int dp[n];\\n\\n        for(int i = n-1; i>=0; i--)\\n        {\\n            // Option 1 - get a one day pass\\n            int opOne = costs[0] + (i < n-1 ? dp[i+1] : 0);\\n            int j;\\n            \\n            // Option 2 - get 7 day pass\\n            for(j = i+1; j < n && days[j] < days[i] + 7; j++);  // single line for loop to get past elements that are in next 7 days and have cost already covered by this pass\\n            int opTwo = costs[1] + (j < n ? dp[j] : 0);\\n\\n            //Option 3 - get 30 day pass\\n            //    Notice that same var j is used since elements that had days upto next 7 days have been iterated, now we need to go till 30\\n            for(; j < n && days[j] < days[i] + 30; j++);\\n            int opThree = costs[2] + (j < n ? dp[j] : 0);\\n\\n            dp[i] = min(opOne, min(opTwo, opThree));\\n        }\\n        \\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349875,
                "title": "c-simple-dp-solution-100-91-5",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTake the minimum cost of tickets for each day, bottom up approach.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe iterate backwards from the last day.\\n- Set days of no travel as -1, we can calculate the price of these days as the same as the next day.\\n- For days of travel, we take the minimum price of a 1 day ticket, 7 day ticket, and 30 day ticket.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int lastDay = *max_element(days.begin(), days.end());\\n        vector<int> dp(lastDay + 2, -1);\\n        // needed a + 1 so that the ticket can also cover the last day\\n        dp[lastDay + 1] = 0; // no trips after the last day so price is 0\\n\\n        for (auto day : days) dp[day] = 0;\\n\\n        for (int i = lastDay; i >= 0; i--) {\\n            // no trips that day, take the price of next day\\n            if (dp[i] == -1) dp[i] = dp[i + 1];\\n            else {\\n                dp[i] = dp[min(i + 1, lastDay + 1)] + costs[0]; // 1 day pass\\n                dp[i] = min(dp[i], dp[min(i + 7, lastDay + 1)] + costs[1]); // 7 day pass\\n                dp[i] = min(dp[i], dp[min(i + 30, lastDay + 1)] + costs[2]); // 30 day pass\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```\\n\\n![Screenshot 2023-03-27 231946.png](https://assets.leetcode.com/users/images/1408ec23-7284-4d56-90c9-ed048a9f2714_1679973630.1438503.png)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int lastDay = *max_element(days.begin(), days.end());\\n        vector<int> dp(lastDay + 2, -1);\\n        // needed a + 1 so that the ticket can also cover the last day\\n        dp[lastDay + 1] = 0; // no trips after the last day so price is 0\\n\\n        for (auto day : days) dp[day] = 0;\\n\\n        for (int i = lastDay; i >= 0; i--) {\\n            // no trips that day, take the price of next day\\n            if (dp[i] == -1) dp[i] = dp[i + 1];\\n            else {\\n                dp[i] = dp[min(i + 1, lastDay + 1)] + costs[0]; // 1 day pass\\n                dp[i] = min(dp[i], dp[min(i + 7, lastDay + 1)] + costs[1]); // 7 day pass\\n                dp[i] = min(dp[i], dp[min(i + 30, lastDay + 1)] + costs[2]); // 30 day pass\\n            }\\n        }\\n\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645560,
                "title": "c-using-dp-very-easy-to-understand-must-see-clear-idea-and-comments",
                "content": "***Pls upvote if you find this helpful  :)***\\n\\nBaic idea here is to break the problem into subproblems.Here we get three options on the days we are travelling ,we can get a one day pass,seven or a thirty days one.We take the minimum of all these possibilities and update each day beginning from day1 to day 365 and finally return day 365. We keep boolean array ifTravelled for the days when we Travel.\\nFor a 1-day pass for ith day, i.e dp[i] = dp[i - 1] + cost[0]\\nFor a 7-day pass ending on day i i.e dp[i] = min(dp[i - 7], dp[i - 6] ... dp[i - 1]) + cost[1]\\nFor a 30-day pass ending on day i, dp[i] = min(dp[i - 30], dp[i - 29] ... dp[i - 1]) + cost[2]\\n\\nBut here we can notice dp is increasing therefore the minimum will be dp[i-7] and dp[i-30] respectively.\\nTherefore, \\n             one day pass=dp[i-1]+costs[0]          \\n             seven day pass=dp[(i-7)]+costs[1]      \\n             thirty day pass=dp[(i-30)]+costs[2] \\n\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<bool> ifTravelled(366,false);// boolean vector to keep track of days we travelled\\n        for(int i:days)ifTravelled[i]=true;\\n        vector<int> dp(366,INT_MAX);       //this vector keeps track of costs till the respective days\\n        dp[0]=0;                           //initialisation\\n        for(int i=1;i<366;i++){\\n            if(!ifTravelled[i])            //for the days we didn\\'t travel update it with value of previous day\\n            {\\n                dp[i]=dp[i-1];\\n                continue;\\n             }\\n            int one=dp[i-1]+costs[0];               //one day pass cost \\n            int seven=dp[max(i-7,0)]+costs[1];      //seven day pass cost,handled when i-7<0\\n            int thirty=dp[max(i-30,0)]+costs[2];    //thirty day pass cost,we have handled the condition when i-30<0\\n            \\n                 dp[i]=std::min({one,seven,thirty}); //update the value with the minimum of all three passes\\n      }   \\n         return dp[365] ;                            //finally return last day value\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<bool> ifTravelled(366,false);// boolean vector to keep track of days we travelled\\n        for(int i:days)ifTravelled[i]=true;\\n        vector<int> dp(366,INT_MAX);       //this vector keeps track of costs till the respective days\\n        dp[0]=0;                           //initialisation\\n        for(int i=1;i<366;i++){\\n            if(!ifTravelled[i])            //for the days we didn\\'t travel update it with value of previous day\\n            {\\n                dp[i]=dp[i-1];\\n                continue;\\n             }\\n            int one=dp[i-1]+costs[0];               //one day pass cost \\n            int seven=dp[max(i-7,0)]+costs[1];      //seven day pass cost,handled when i-7<0\\n            int thirty=dp[max(i-30,0)]+costs[2];    //thirty day pass cost,we have handled the condition when i-30<0\\n            \\n                 dp[i]=std::min({one,seven,thirty}); //update the value with the minimum of all three passes\\n      }   \\n         return dp[365] ;                            //finally return last day value\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 472937,
                "title": "a-comparison-between-the-forward-and-backward-approach",
                "content": "```C++\\n// 1. forward\\n// dp[i] represents the cost you need if day i \\n// is the i-th day in your traverl plan. In other words,\\n// the cost if you traverl from day 1 to day i.\\n//\\n// If you do not travel on day i, dp[i] = dp[i-1];\\n// If you DO traverl on day i, dp[i] = min(dp[i-1] + costs[0], dp[i-7] + costs[1] + dp[i-30] + costs[2]).\\nint forward(vector<int>& days, vector<int>& costs) {\\n\\tunordered_set<int> dayset(days.begin(), days.end());\\n\\n\\tvector<int> dp(366, 0);\\n\\tfor(int i = 1; i < 366; ++i) {\\n\\t\\tif (dayset.find(i) == dayset.end()) {\\n\\t\\t\\tdp[i] = dp[i-1];\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = min({dp[i-1] + costs[0], \\n\\t\\t\\t\\t\\t\\t dp[max(i-7, 0)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[max(i-30, 0)] + costs[2]});\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[365];\\n}\\n\\n// 2. backward\\n// dp[i] represents the cost you need if day i is \\n// the first day in your travel plan. In other words,\\n// the cost if you travel from day i to day 365.\\n//\\n// If you do not travel on day i, dp[i] = dp[i+1];\\n// If you DO traverl on day i, dp[i] = min(dp[i+1] + costs[0], dp[i+7] + costs[1] + dp[i+30] + costs[2]).\\nint backward(vector<int>&days, vector<int>& costs) {\\n\\tunordered_set<int> dayset(days.begin(), days.end());\\n\\n\\tvector<int> dp(367, 0);\\n\\tfor(int i = 365; i >= 1; --i) {\\n\\t\\tif (dayset.find(i) == dayset.end()) {\\n\\t\\t\\tdp[i] = dp[i+1];\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = min({dp[i+1] + costs[0], \\n\\t\\t\\t\\t\\t\\t dp[min(i+7, 366)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[min(i+30, 366)] + costs[2]});\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[1];\\n}\\n```\\nThe important thing is to find the relationship and understand the meaning of `dp[i]`.",
                "solutionTags": [],
                "code": "```C++\\n// 1. forward\\n// dp[i] represents the cost you need if day i \\n// is the i-th day in your traverl plan. In other words,\\n// the cost if you traverl from day 1 to day i.\\n//\\n// If you do not travel on day i, dp[i] = dp[i-1];\\n// If you DO traverl on day i, dp[i] = min(dp[i-1] + costs[0], dp[i-7] + costs[1] + dp[i-30] + costs[2]).\\nint forward(vector<int>& days, vector<int>& costs) {\\n\\tunordered_set<int> dayset(days.begin(), days.end());\\n\\n\\tvector<int> dp(366, 0);\\n\\tfor(int i = 1; i < 366; ++i) {\\n\\t\\tif (dayset.find(i) == dayset.end()) {\\n\\t\\t\\tdp[i] = dp[i-1];\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = min({dp[i-1] + costs[0], \\n\\t\\t\\t\\t\\t\\t dp[max(i-7, 0)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[max(i-30, 0)] + costs[2]});\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[365];\\n}\\n\\n// 2. backward\\n// dp[i] represents the cost you need if day i is \\n// the first day in your travel plan. In other words,\\n// the cost if you travel from day i to day 365.\\n//\\n// If you do not travel on day i, dp[i] = dp[i+1];\\n// If you DO traverl on day i, dp[i] = min(dp[i+1] + costs[0], dp[i+7] + costs[1] + dp[i+30] + costs[2]).\\nint backward(vector<int>&days, vector<int>& costs) {\\n\\tunordered_set<int> dayset(days.begin(), days.end());\\n\\n\\tvector<int> dp(367, 0);\\n\\tfor(int i = 365; i >= 1; --i) {\\n\\t\\tif (dayset.find(i) == dayset.end()) {\\n\\t\\t\\tdp[i] = dp[i+1];\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = min({dp[i+1] + costs[0], \\n\\t\\t\\t\\t\\t\\t dp[min(i+7, 366)] + costs[1],\\n\\t\\t\\t\\t\\t\\t dp[min(i+30, 366)] + costs[2]});\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[1];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 226672,
                "title": "java-1-d-dp-time-space-o-1",
                "content": "For each day, it could be covered by the tickets bought on today or before. \\nFor each day, we check if it\\'s in the days array. If not, then the cost should remain the same; otherwise, check today\\'s cost could be coved by which day that will minimize total cost up to today.\\n\\n```\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] minCosts = new int[366];\\n        boolean[] isDays = new boolean[366];\\n        for(int day: days) isDays[day] = true;\\n        \\n        for(int i = 1; i <= 365; i++) {\\n            if(!isDays[i]) {\\n                minCosts[i] = minCosts[i - 1];\\n                continue;\\n            }\\n            int minCost;\\n            // case 1\\n            minCost = minCosts[i - 1] + costs[0];\\n            // case 2\\n            minCost = Math.min(minCost, minCosts[Math.max(0, i - 7)] + costs[1]);\\n            // case 3\\n            minCost = Math.min(minCost, minCosts[Math.max(0, i - 30)] + costs[2]);\\n            \\n            minCosts[i] = minCost;\\n        }\\n        \\n        return minCosts[365];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] minCosts = new int[366];\\n        boolean[] isDays = new boolean[366];\\n        for(int day: days) isDays[day] = true;\\n        \\n        for(int i = 1; i <= 365; i++) {\\n            if(!isDays[i]) {\\n                minCosts[i] = minCosts[i - 1];\\n                continue;\\n            }\\n            int minCost;\\n            // case 1\\n            minCost = minCosts[i - 1] + costs[0];\\n            // case 2\\n            minCost = Math.min(minCost, minCosts[Math.max(0, i - 7)] + costs[1]);\\n            // case 3\\n            minCost = Math.min(minCost, minCosts[Math.max(0, i - 30)] + costs[2]);\\n            \\n            minCosts[i] = minCost;\\n        }\\n        \\n        return minCosts[365];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 811521,
                "title": "python-3-lines-intuitive-dp-binary-search-beats-99",
                "content": "```\\nclass Solution:\\n    \\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        @lru_cache(maxsize = None)\\n        def helper(i):\\n            if i >= lend: return 0\\n            return min(costs[0] + helper(bisect.bisect_left(days, days[i] + 1)), \\n                      costs[1] + helper(bisect.bisect_left(days, days[i] + 7)),\\n                      costs[2] + helper(bisect.bisect_left(days, days[i] + 30)))\\n        \\n        lend = len(days)\\n        return helper(0)\\n```\\n\\n\\tWhen to think of DP?\\n    - Any question where the answer to smallest valid inputs are necessary, we should think of DP\\n\\n    Any recurssive solution will have 3 segments\\n    - base condition \\n    - a choice\\n    - a way to break down the question into smaller questions\\n\\n    Base condition here is?\\n    - if there are no travel days --> cost is 0\\n    - Awesome, that was simple\\n\\n    Choice here is?\\n    - I can take tickets for \\n        - 1 day\\n        - 7 days\\n        - 30 days\\n    - Awesome, we need the minimum\\n\\n    Breaking the question into smaller questions?\\n    - When we buy 1 day ticket, we travel for a day, so we can remove that day from the list...\\n    - Same goes when we buy 7 day ticket (we travel for 7 days, so remove 7 days from the list), 30 day ticket (we travel for 30 days, so remove 30 days from the list)... \\n    - Awesome, even that was simple\\n\\n    Now, the DP part... \\n    - Usually, blindly putting a cache would help...\\n\\n    But let me give it a shot to explain why it works:\\n    - Usually there will be cases where things overlap, like buying a 7 day ticket and then 2 day ticket, might overlap with buy 2 day ticket and then 7 day..\\n    - It is not sure, because it depends on the input days. \\n\\n    Why binarysearch?\\n    - As the days are in ascending (strictly increasing) order. We can leverage this info to find the 7th day index or 30th day index from today using binary search.\\n    - Instead of using linear search.\\n\\n    Why does helper function have an index for the days list?\\n    - Because, days list in itself cannot be hashed into cache. So, we have to use something that is hashable (or immutable). \\n    - Also, indexes are way lighter than the whole list. So, the index will be pointing to the current day in each recurssive call.\\n\\n    Please like if I was able to help you. Thank you for reading.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        @lru_cache(maxsize = None)\\n        def helper(i):\\n            if i >= lend: return 0\\n            return min(costs[0] + helper(bisect.bisect_left(days, days[i] + 1)), \\n                      costs[1] + helper(bisect.bisect_left(days, days[i] + 7)),\\n                      costs[2] + helper(bisect.bisect_left(days, days[i] + 30)))\\n        \\n        lend = len(days)\\n        return helper(0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647874,
                "title": "c-recursion-memoization-tabulation-binarysearch",
                "content": "# Method - 1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/390d04d4-2e6e-4ec4-8970-6ddb65a03861_1664654022.6634092.png)\\n\\n**T->O(Expo) && S->O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,vector<int>& d,vector<int>& c,int n){\\n\\t\\t\\tif(i>=n) return 0;\\n\\t\\t\\tint ind1=lower_bound(d.begin(),d.end(),d[i]+1)-d.begin();\\n\\t\\t\\tint op1=c[0]+f(ind1,d,c,n);\\n\\t\\t\\tint ind2=lower_bound(d.begin(),d.end(),d[i]+7)-d.begin();\\n\\t\\t\\tint op2=c[1]+f(ind2,d,c,n);\\n\\t\\t\\tint ind3=lower_bound(d.begin(),d.end(),d[i]+30)-d.begin();\\n\\t\\t\\tint op3=c[2]+f(ind3,d,c,n);\\n\\t\\t\\treturn min(op1,min(op2,op3));\\n\\t\\t}\\n\\n\\t\\tint mincostTickets(vector<int>& d, vector<int>& c) {\\n\\t\\t\\tint n=d.size();\\n\\t\\t\\treturn f(0,d,c,n);\\n\\t\\t}\\n\\t};\\n\\t\\n# Method -2 [Memoization]\\t\\n![image](https://assets.leetcode.com/users/images/0c9059a5-1285-47dc-9b2a-58343821717b_1664654170.3973186.png)\\'\\n\\n**T->O(n) && S->O(n) + O(n) [Recursion stack space]**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,vector<int>& d,vector<int>& c,int n,vector<int>& dp){\\n\\t\\t\\tif(i>=n) return 0;\\n\\t\\t\\tif(dp[i]!=-1) return dp[i];\\n\\t\\t\\tint ind1=lower_bound(d.begin(),d.end(),d[i]+1)-d.begin();\\n\\t\\t\\tint op1=c[0]+f(ind1,d,c,n,dp);\\n\\t\\t\\tint ind2=lower_bound(d.begin(),d.end(),d[i]+7)-d.begin();\\n\\t\\t\\tint op2=c[1]+f(ind2,d,c,n,dp);\\n\\t\\t\\tint ind3=lower_bound(d.begin(),d.end(),d[i]+30)-d.begin();\\n\\t\\t\\tint op3=c[2]+f(ind3,d,c,n,dp);\\n\\t\\t\\treturn dp[i]=min(op1,min(op2,op3));\\n\\t\\t}\\n\\n\\t\\tint mincostTickets(vector<int>& d, vector<int>& c) {\\n\\t\\t\\tint n=d.size();\\n\\t\\t\\tvector<int> dp(n,-1);\\n\\t\\t\\treturn f(0,d,c,n,dp);\\n\\t\\t}\\n\\t};\\n\\n# Method -2 [Tabulation]\\t\\n![image](https://assets.leetcode.com/users/images/bbe375e3-7833-4ef3-a93e-6409889b04c0_1664654431.5132751.png)\\n\\n**T->O(n) && S->O(n)**\\n\\n\\tclass Solution {\\n\\tpublic:    \\n\\t\\tint mincostTickets(vector<int>& d, vector<int>& c) {\\n\\t\\t\\tint n=d.size();\\n\\t\\t\\tvector<int> dp(n+1,0);\\n\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\tint ind1=lower_bound(d.begin(),d.end(),d[i]+1)-d.begin();\\n\\t\\t\\t\\tint op1=c[0]+dp[ind1];\\n\\t\\t\\t\\tint ind2=lower_bound(d.begin(),d.end(),d[i]+7)-d.begin();\\n\\t\\t\\t\\tint op2=c[1]+dp[ind2];\\n\\t\\t\\t\\tint ind3=lower_bound(d.begin(),d.end(),d[i]+30)-d.begin();\\n\\t\\t\\t\\tint op3=c[2]+dp[ind3];\\n\\t\\t\\t\\tdp[i]=min(op1,min(op2,op3));\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0];\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint f(int i,vector<int>& d,vector<int>& c,int n){\\n\\t\\t\\tif(i>=n) return 0;\\n\\t\\t\\tint ind1=lower_bound(d.begin(),d.end(),d[i]+1)-d.begin();\\n\\t\\t\\tint op1=c[0]+f(ind1,d,c,n);\\n\\t\\t\\tint ind2=lower_bound(d.begin(),d.end(),d[i]+7)-d.begin();\\n\\t\\t\\tint op2=c[1]+f(ind2,d,c,n);\\n\\t\\t\\tint ind3=lower_bound(d.begin(),d.end(),d[i]+30)-d.begin();\\n\\t\\t\\tint op3=c[2]+f(ind3,d,c,n);\\n\\t\\t\\treturn min(op1,min(op2,op3));\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1412598,
                "title": "c-memoized-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int dp[366];\\n    int helper(vector<int> &arr,vector<int>& cost,int l)\\n    {\\n        if(l>365){\\n            return 0;\\n        }\\n        \\n        if(dp[l] != -1){                      // if calculated earlier , then return \\n            return dp[l];\\n        }\\n        if(arr[l] == 0){                    // if we dont have to travel on lth day , then skip and increase l\\n            return dp[l] = helper(arr,cost,l+1);          // calculate and store\\n        }\\n        else{\\n            \\n            int op1 = cost[0] + helper(arr,cost,l+1);//buy one day ticket\\n            int op2 = cost[1] + helper(arr,cost,l+7);//buy seven day ticket\\n            int op3 = cost[2] + helper(arr,cost,l+30);//buy thirty day day ticket\\n\\n\\n            return dp[l] = min(op1,min(op2,op3));   // return minimum out of three options\\n        }\\n        \\n        \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        \\n        int n = days.size();\\n        vector<int> arr(366,0);\\n        \\n        for(int i=0;i<n;i++){\\n            arr[days[i]]++;\\n        }\\n        \\n        for(int i=0;i<366;i++) dp[i] = -1;\\n        \\n        return helper(arr,costs,1);\\n    }\\n};\\n```\\n\\n**If this post helped you in any way ,please consider upvoting .Thanks**",
                "solutionTags": [
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[366];\\n    int helper(vector<int> &arr,vector<int>& cost,int l)\\n    {\\n        if(l>365){\\n            return 0;\\n        }\\n        \\n        if(dp[l] != -1){                      // if calculated earlier , then return \\n            return dp[l];\\n        }\\n        if(arr[l] == 0){                    // if we dont have to travel on lth day , then skip and increase l\\n            return dp[l] = helper(arr,cost,l+1);          // calculate and store\\n        }\\n        else{\\n            \\n            int op1 = cost[0] + helper(arr,cost,l+1);//buy one day ticket\\n            int op2 = cost[1] + helper(arr,cost,l+7);//buy seven day ticket\\n            int op3 = cost[2] + helper(arr,cost,l+30);//buy thirty day day ticket\\n\\n\\n            return dp[l] = min(op1,min(op2,op3));   // return minimum out of three options\\n        }\\n        \\n        \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        \\n        int n = days.size();\\n        vector<int> arr(366,0);\\n        \\n        for(int i=0;i<n;i++){\\n            arr[days[i]]++;\\n        }\\n        \\n        for(int i=0;i<366;i++) dp[i] = -1;\\n        \\n        return helper(arr,costs,1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 741697,
                "title": "with-explanation-python-dp-short-and-fast-solution",
                "content": "Dynamic Programming \\n\\ndp[d] is the minimum price up to dth day\\n\\nOn each day in days, to make sure we have a pass, we either \\n1. buy a 1-day pass on that day\\n2. buy a 7-day pass 6 days ago\\n2. buy a 30-day pass 29 days ago\\n\\nIf we buy a 7-day pass, the price will be the cost at \"dp[day - 7] + costs[1]\", which is the minimum price 7 days ago + we buy a 7-day pass 6 days ago\\n\\nWe can buy a 7-day pass or a 30-day pass on day 1. That\\'s why we have \"dp[max(d - 7, 0)]\" and \"dp[max(d - 30, 0)]\" to handle first 30 days.\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        last_day = days[-1]\\n        dp = [0] * (last_day + 1) \\n        days = set(days) # convert day to set for fast look up later\\n        for d in range(1, last_day + 1):\\n            # to make sure we have pass, we either buy a 1-d pass today, a 7-d pass 6 days ago, or a 30-d pass 29 days ago\\n            if d in days:\\n                dp[d] = min(costs[2] + dp[max(d - 30, 0)], costs[1] + dp[max(d - 7, 0)], costs[0] + dp[d - 1])\\n            else: # we don\\'t buy pass on day not in days\\n                dp[d] = dp[d - 1]\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        last_day = days[-1]\\n        dp = [0] * (last_day + 1) \\n        days = set(days) # convert day to set for fast look up later\\n        for d in range(1, last_day + 1):\\n            # to make sure we have pass, we either buy a 1-d pass today, a 7-d pass 6 days ago, or a 30-d pass 29 days ago\\n            if d in days:\\n                dp[d] = min(costs[2] + dp[max(d - 30, 0)], costs[1] + dp[max(d - 7, 0)], costs[0] + dp[d - 1])\\n            else: # we don\\'t buy pass on day not in days\\n                dp[d] = dp[d - 1]\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349791,
                "title": "day-362-flow-chart-java-c-python-explained-intuition-algo-dry-run-proof",
                "content": "# upvote pls \\n![image.png](https://assets.leetcode.com/users/images/8a1a80a1-d47e-4224-8f8e-252cb5007971_1679970799.0759618.png)\\n\\n\\n##### \\u2022\\tThere are several ways to solve the \"Minimum Cost For Tickets\" problem. Here are some of the common approaches:\\n##### \\u2022\\tBrute Force: Try all possible combinations of passes for each day in the travel period. This approach has an exponential time complexity of O(3^n), where n is the number of days in the travel period, and is not practical for large values of n.\\n##### \\u2022\\tDynamic Programming: Use a DP array to store the minimum cost for each day in the travel period. The DP array is initialized with the cost of the previous day, and the cost for each travel day is computed by trying all three types of passes and choosing the minimum cost. This approach has a time complexity of O(maxDay), where maxDay is the maximum day in the travel period.\\n##### \\u2022\\tSliding Window: Use a sliding window to keep track of the previous 7 and 30 days and compute the cost for each travel day. This approach has a time complexity of O(n), where n is the number of days in the travel period.\\n##### \\u2022\\tStack: Use a stack to keep track of the travel days and their corresponding costs. This approach has a time complexity of O(n), where n is the number of days in the travel period.\\n##### \\u2022\\tQueue: Use a queue to keep track of the travel days and their corresponding costs. This approach has a time complexity of O(n), where n is the number of days in the travel period.\\n##### \\u2022\\tAll of these approaches have different time and space complexities and may be more or less suitable depending on the specific requirements of the problem.\\n\\n\\n# Intuition for space optimized dp\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nhere\\'s the intuition behind the given mincostTickets function:\\n![image.png](https://assets.leetcode.com/users/images/2b59ddd9-bc59-4075-8244-8db009361a40_1679975601.5487628.png)\\n\\n##### \\u2022\\tThe intuition behind this problem is to find the minimum cost of buying tickets for a travel period, given the costs of one-day, seven-day and thirty-day passes, and the days on which the person will be traveling.\\n##### \\u2022\\tThe code first computes the maximum day in the travel period and initializes an array called \"isTravelDay\" to mark the days on which the person will be traveling.\\n##### \\u2022\\tThen, the code initializes the costs of different types of passes and computes the minimum cost for each day from 1 to maxDay. If it\\'s not a travel day, the cost is the same as the previous day. If it\\'s a travel day, the code tries all three types of passes and chooses the minimum cost.\\n##### \\u2022\\tFinally, the code returns the minimum cost for the entire travel period. The intuition is to use dynamic programming to efficiently compute the minimum cost for each day, using the results from previous days. This reduces the time complexity of the algorithm from exponential to linear.\\n\\n\\n# ALGO \\n##### \\u2022\\tThe algorithm used in this code is Dynamic Programming. Here\\'s how it works:\\n##### \\u2022\\tInitialize the DP array and mark the travel days: The first step is to initialize the DP array with 0s and mark the days on which the person will be traveling.\\n##### \\u2022\\tCompute the minimum cost for each day from 1 to maxDay: For each day from 1 to maxDay, the algorithm checks if it\\'s a travel day or not. If it\\'s not a travel day, the cost is the same as the previous day. If it\\'s a travel day, the algorithm tries all three types of passes (one-day, seven-day, and thirty-day) and chooses the minimum cost. This is done using the formula dp[i] = Math.min(dp[i-1] + oneDayPassCost, dp[Math.max(0, i-7)] + sevenDayPassCost, dp[Math.max(0, i-30)] + thirtyDayPassCost).\\n##### \\u2022\\tReturn the minimum cost for the entire travel period: Once the minimum cost for each day has been computed, the algorithm returns the minimum cost for the entire travel period, which is stored in dp[maxDay].\\n##### \\u2022\\tThe time complexity of this algorithm is O(maxDay), where maxDay is the maximum day in the travel period. This is because the algorithm only needs to compute the minimum cost for each day once and then uses the results from previous days to compute the minimum cost for the current day. The space complexity is also O(maxDay), as the algorithm uses an array of size maxDay to store the DP values.\\n\\n\\n\\n```JAVA []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    // Get the maximum day in the travel period\\n    int maxDay = days[days.length - 1];\\n    \\n    // Initialize the DP array and mark the travel days\\n    int[] dp = new int[maxDay + 1];\\n    boolean[] isTravelDay = new boolean[maxDay + 1];\\n    for (int day : days) {\\n        isTravelDay[day] = true;\\n    }\\n    \\n    // Initialize the costs of different types of passes\\n    int oneDayPassCost = costs[0];\\n    int sevenDayPassCost = costs[1];\\n    int thirtyDayPassCost = costs[2];\\n    \\n    // Compute the minimum cost for each day from 1 to maxDay\\n    for (int i = 1; i <= maxDay; i++) {\\n        if (!isTravelDay[i]) {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        } else {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[i - 1] + oneDayPassCost;\\n            int cost2 = dp[Math.max(0, i - 7)] + sevenDayPassCost;\\n            int cost3 = dp[Math.max(0, i - 30)] + thirtyDayPassCost;\\n            dp[i] = Math.min(cost1, Math.min(cost2, cost3));\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period\\n    return dp[maxDay];\\n}\\n```\\n```C++ []\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n    // Get the maximum day in the travel period\\n    int maxDay = days[days.size() - 1];\\n    \\n    // Initialize the DP array and mark the travel days\\n    vector<int> dp(maxDay + 1);\\n    vector<bool> isTravelDay(maxDay + 1);\\n    for (int day : days) {\\n        isTravelDay[day] = true;\\n    }\\n    \\n    // Initialize the costs of different types of passes\\n    int oneDayPassCost = costs[0];\\n    int sevenDayPassCost = costs[1];\\n    int thirtyDayPassCost = costs[2];\\n    \\n    // Compute the minimum cost for each day from 1 to maxDay\\n    for (int i = 1; i <= maxDay; i++) {\\n        if (!isTravelDay[i]) {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        } else {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[i - 1] + oneDayPassCost;\\n            int cost2 = dp[max(0, i - 7)] + sevenDayPassCost;\\n            int cost3 = dp[max(0, i - 30)] + thirtyDayPassCost;\\n            dp[i] = min(cost1, min(cost2, cost3));\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period\\n    return dp[maxDay];\\n}\\n```\\n```PYTHON []\\ndef mincostTickets(days: List[int], costs: List[int]) -> int:\\n    # Get the maximum day in the travel period\\n    maxDay = days[-1]\\n    \\n    # Initialize the DP array and mark the travel days\\n    dp = [0] * (maxDay + 1)\\n    isTravelDay = [False] * (maxDay + 1)\\n    for day in days:\\n        isTravelDay[day] = True\\n    \\n    # Initialize the costs of different types of passes\\n    oneDayPassCost = costs[0]\\n    sevenDayPassCost = costs[1]\\n    thirtyDayPassCost = costs[2]\\n    \\n    # Compute the minimum cost for each day from 1 to maxDay\\n    for i in range(1, maxDay + 1):\\n        if not isTravelDay[i]:\\n            # If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1]\\n        else:\\n            # If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            cost1 = dp[i - 1] + oneDayPassCost\\n            cost2 = dp[max(0, i - 7)] + sevenDayPassCost\\n            cost3 = dp[max(0, i - 30)] + thirtyDayPassCost\\n            dp[i] = min(cost1, cost2, cost3)\\n    \\n    # Return the minimum cost for the entire travel period\\n    return dp[maxDay]\\n```\\n\\n# Complexity\\nHere\\'s an explanation of the time complexity (TC) and space complexity (SC) of the mincostTickets function:\\n##### \\u2022\\tTime complexity: O(maxDay), where maxDay is the maximum day in the travel period. We iterate over each day from 1 to maxDay and compute the minimum cost for each day.\\n##### \\u2022\\tSpace complexity: O(maxDay), where maxDay is the maximum day in the travel period. We initialize an array of size maxDay + 1 to store the DP values and another array of size maxDay + 1 to mark the travel days. Therefore, the overall space complexity is O(maxDay + maxDay) = O(maxDay).\\n\\n# 2ND WAY DP top down :\\n\\n```java []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    // Get the maximum day in the travel period\\n    int maxDay = days[days.length - 1];\\n\\n    // Initialize the DP array and mark the travel days\\n    int[] dp = new int[maxDay + 1];\\n    boolean[] isTravelDay = new boolean[maxDay + 1];\\n    for (int day : days) {\\n        isTravelDay[day] = true;\\n    }\\n\\n    // Initialize the costs of different types of passes\\n    int oneDayPassCost = costs[0];\\n    int sevenDayPassCost = costs[1];\\n    int thirtyDayPassCost = costs[2];\\n\\n    // Compute the minimum cost for each day from 1 to maxDay\\n    return minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, 1, maxDay);\\n}\\n\\nprivate int minCost(int[] days, int[] costs, int[] dp, boolean[] isTravelDay, int oneDayPassCost, int sevenDayPassCost, int thirtyDayPassCost, int day, int maxDay) {\\n    if (day > maxDay) {\\n        return 0;\\n    }\\n    if (dp[day] != 0) {\\n        return dp[day];\\n    }\\n    if (!isTravelDay[day]) {\\n        dp[day] = minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n    } else {\\n        int cost1 = oneDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n        int cost2 = sevenDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 7), maxDay);\\n        int cost3 = thirtyDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 30), maxDay);\\n        dp[day] = Math.min(cost1, Math.min(cost2, cost3));\\n    }\\n    return dp[day];\\n}\\n\\nprivate int findNextTravelDay(int[] days, int day, int duration) {\\n    int i = 0;\\n    while (i < days.length && days[i] < day + duration) {\\n        i++;\\n    }\\n    return i < days.length ? days[i] : days[days.length - 1] + 1;\\n}\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int maxDay = days[days.size() - 1];\\n        vector<int> dp(maxDay + 1);\\n        vector<bool> isTravelDay(maxDay + 1);\\n        for (int day : days) {\\n            isTravelDay[day] = true;\\n        }\\n        int oneDayPassCost = costs[0];\\n        int sevenDayPassCost = costs[1];\\n        int thirtyDayPassCost = costs[2];\\n        return minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, 1, maxDay);\\n    }\\n\\n    int minCost(vector<int>& days, vector<int>& costs, vector<int>& dp, vector<bool>& isTravelDay, int oneDayPassCost, int sevenDayPassCost, int thirtyDayPassCost, int day, int maxDay) {\\n        if (day > maxDay) {\\n            return 0;\\n        }\\n        if (dp[day] != 0) {\\n            return dp[day];\\n        }\\n        if (!isTravelDay[day]) {\\n            dp[day] = minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n        } else {\\n            int cost1 = oneDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n            int cost2 = sevenDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 7), maxDay);\\n            int cost3 = thirtyDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 30), maxDay);\\n            dp[day] = min(cost1, min(cost2, cost3));\\n        }\\n        return dp[day];\\n    }\\n\\n    int findNextTravelDay(vector<int>& days, int day, int duration) {\\n        int i = 0;\\n        while (i < days.size() && days[i] < day + duration) {\\n            i++;\\n        }\\n        return i < days.size() ? days[i] : days[days.size() - 1] + 1;\\n    }\\n};\\n```\\n```python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        maxDay = days[-1]\\n        dp = [0] * (maxDay + 1)\\n        isTravelDay = [False] * (maxDay + 1)\\n        for day in days:\\n            isTravelDay[day] = True\\n        oneDayPassCost = costs[0]\\n        sevenDayPassCost = costs[1]\\n        thirtyDayPassCost = costs[2]\\n        return self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, 1, maxDay)\\n\\n    def minCost(self, days: List[int], costs: List[int], dp: List[int], isTravelDay: List[bool], oneDayPassCost: int, sevenDayPassCost: int, thirtyDayPassCost: int, day: int, maxDay: int) -> int:\\n        if day > maxDay:\\n            return 0\\n        if dp[day] != 0:\\n            return dp[day]\\n        if not isTravelDay[day]:\\n            dp[day] = self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay)\\n        else:\\n            cost1 = oneDayPassCost + self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay)\\n            cost2 = sevenDayPassCost + self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, self.findNextTravelDay(days, day, 7), maxDay)\\n            cost3 = thirtyDayPassCost + self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, self.findNextTravelDay(days, day, 30), maxDay)\\n            dp[day] = min(cost1, min(cost2, cost3))\\n```\\n# 3rd way \\n\\n```PYTHON []\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n    # Initialize the DP array with all 0s\\n    dp = [0] * (days[-1] + 1)\\n    \\n    # Convert the list of travel days into a set for faster lookups\\n    travel_days = set(days)\\n    \\n    # Compute the minimum cost for each day from 1 to the maximum day\\n    for i in range(1, len(dp)):\\n        if i in travel_days:\\n            # If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            cost1 = dp[max(i - 1, 0)] + costs[0]\\n            cost2 = dp[max(i - 7, 0)] + costs[1]\\n            cost3 = dp[max(i - 30, 0)] + costs[2]\\n            dp[i] = min(cost1, cost2, cost3)\\n        else:\\n            # If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1]\\n    \\n    # Return the minimum cost for the entire travel period, which is the last element in the DP array\\n    return dp[-1]\\n```\\n```JAVA []\\npublic int mincostTickets(int[] days, int[] costs) { // Initialize the DP array with all 0s \\nint[] dp = new int[days[days.length - 1] + 1];\\n\\n    // Convert the list of travel days into a set for faster lookups\\n    Set<Integer> travelDays = new HashSet<>();\\n    for (int day : days) {\\n        travelDays.add(day);\\n    }\\n    \\n    // Compute the minimum cost for each day from 1 to the maximum day\\n    for (int i = 1; i < dp.length; i++) {\\n        if (travelDays.contains(i)) {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[Math.max(i - 1, 0)] + costs[0];\\n            int cost2 = dp[Math.max(i - 7, 0)] + costs[1];\\n            int cost3 = dp[Math.max(i - 30, 0)] + costs[2];\\n            dp[i] = Math.min(cost1, Math.min(cost2, cost3));\\n        } else {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period, which is the last element in the DP array\\n    return dp[dp.length - 1];\\n}\\n```\\n```C++ []\\nint mincostTickets(vector<int>& days, vector<int>& costs) { // Initialize the DP array with all 0s \\n    vector dp(days.back() + 1, 0);\\n\\n    // Convert the list of travel days into a set for faster lookups\\n    unordered_set<int> travel_days(days.begin(), days.end());\\n    \\n    // Compute the minimum cost for each day from 1 to the maximum day\\n    for (int i = 1; i < dp.size(); i++) {\\n        if (travel_days.count(i)) {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[max(i - 1, 0)] + costs[0];\\n            int cost2 = dp[max(i - 7, 0)] + costs[1];\\n            int cost3 = dp[max(i - 30, 0)] + costs[2];\\n            dp[i] = min(cost1, min(cost2, cost3));\\n        } else {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period, which is the last element in the DP array\\n    return dp.back();\\n}\\n```\\n# DP bottom up\\n\\n# INTUTION \\n\\n##### \\u2022\\tThe problem is to find the minimum cost to buy passes to travel on a given set of days. We can solve this problem using dynamic programming.\\n##### \\u2022\\tWe can define a recursive function minCost(days, costs, pass, index, dp) that returns the minimum cost to travel for the remaining days starting from the given index. We can use memoization to avoid recomputing the same subproblems.\\n##### \\u2022\\tAt each step, we can try all three types of passes (1-day, 7-day, and 30-day passes) and choose the one that gives the minimum cost. To find the cost of a pass, we need to add the cost of the pass to the cost of traveling for the remaining days after the pass expires.\\n##### \\u2022\\tTo find the index of the next day after a pass expires, we can use a loop to find the first day that is after the current day plus the duration of the pass.\\n##### \\u2022\\tThe base case of the recursion is when we have covered all the days. In this case, the cost is 0.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nHere\\'s an explanation of the algorithm used in the mincostTickets function:\\n##### \\u2022\\tDefine the passes: The given problem requires us to find the minimum cost to travel on a set of days. We are given three types of passes: a 1-day pass, a 7-day pass, and a 30-day pass. We can define these passes as an array pass of length 3, where pass[i] represents the duration of the i-th pass.\\n##### \\u2022\\tDefine the recursive function: We can define a recursive function minCost that takes as input the array of days, the array of costs, the array of pass durations, the current index, and a memoization array dp. The function returns the minimum cost to travel for the remaining days starting from the given index.\\n##### \\u2022\\tHandle the base case: If we have covered all the days, we return 0, since there is no cost to travel on no days.\\n##### \\u2022\\tCheck memoization: If we have already computed the result for the current index, we return the stored value from the memoization array.\\n##### \\u2022\\tTry all three types of passes: We loop through all three types of passes and compute the cost of each pass. For each pass, we add the cost of the pass to the cost of traveling for the remaining days after the pass expires.\\n##### \\u2022\\tFind the index of the next day after the pass expires: We use a loop to find the first day that is after the current day plus the duration of the pass.\\n##### \\u2022\\tCompute the cost for the remaining days: We call the minCost function recursively for the remaining days after the pass expires and add the cost of the pass to the result.\\n##### \\u2022\\tUpdate the minimum cost: We update the minimum cost by taking the minimum of the current minimum cost and the cost computed in step 7.\\n##### \\u2022\\tStore the result in the memoization array: We store the minimum cost computed for the current index in the memoization array.\\n##### \\u2022\\tReturn the minimum cost: We return the minimum cost computed in step 8.\\n##### \\u2022\\tCall the recursive function: In the mincostTickets function, we call the minCost function with the initial index set to 0 and return the result.\\n\\n# ALGO\\n\\n##### \\u2022\\tHere\\'s an explanation of the algorithm used in the mincostTickets function:\\n##### \\u2022\\tDefine the passes: The given problem requires us to find the minimum cost to travel on a set of days. We are given three types of passes: a 1-day pass, a 7-day pass, and a 30-day pass. We can define these passes as an array pass of length 3, where pass[i] represents the duration of the i-th pass.\\n##### \\u2022\\tDefine the recursive function: We can define a recursive function minCost that takes as input the array of days, the array of costs, the array of pass durations, the current index, and a memoization array dp. The function returns the minimum cost to travel for the remaining days starting from the given index.\\n##### \\u2022\\tHandle the base case: If we have covered all the days, we return 0, since there is no cost to travel on no days.\\n##### \\u2022\\tCheck memoization: If we have already computed the result for the current index, we return the stored value from the memoization array.\\n##### \\u2022\\tTry all three types of passes: We loop through all three types of passes and compute the cost of each pass. For each pass, we add the cost of the pass to the cost of traveling for the remaining days after the pass expires.\\n##### \\u2022\\tFind the index of the next day after the pass expires: We use a loop to find the first day that is after the current day plus the duration of the pass.\\n##### \\u2022\\tCompute the cost for the remaining days: We call the minCost function recursively for the remaining days after the pass expires and add the cost of the pass to the result.\\n##### \\u2022\\tUpdate the minimum cost: We update the minimum cost by taking the minimum of the current minimum cost and the cost computed in step 7.\\n##### \\u2022\\tStore the result in the memoization array: We store the minimum cost computed for the current index in the memoization array.\\n##### \\u2022\\tReturn the minimum cost: We return the minimum cost computed in step 8.\\n##### \\u2022\\tCall the recursive function: In the mincostTickets function, we call the minCost function with the initial index set to 0 and return the result.\\n\\n\\n# Code\\n```java []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    int n = days.length;\\n    int[] pass = {1, 7, 30};\\n    int[] dp = new int[n];\\n    Arrays.fill(dp, -1);\\n    return minCost(days, costs, pass, 0, dp);\\n}\\n\\npublic int minCost(int[] days, int[] costs, int[] pass, int index, int[] dp) {\\n    // Base case: all days have been covered\\n    if (index == days.length) {\\n        return 0;\\n    }\\n    \\n    // Check if the result is already computed\\n    if (dp[index] != -1) {\\n        return dp[index];\\n    }\\n    \\n    int minCost = Integer.MAX_VALUE;\\n    \\n    // Try all three types of passes\\n    for (int i = 0; i < costs.length; i++) {\\n        int cost = costs[i];\\n        int duration = pass[i];\\n        \\n        // Find the next day after the pass expires\\n        int j = index;\\n        while (j < days.length && days[j] < days[index] + duration) {\\n            j++;\\n        }\\n        \\n        // Compute the cost for the remaining days\\n        int remainingCost = cost + minCost(days, costs, pass, j, dp);\\n        \\n        // Update the minimum cost\\n        minCost = Math.min(minCost, remainingCost);\\n    }\\n    \\n    // Store the result in the memoization array and return it\\n    dp[index] = minCost;\\n    return minCost;\\n}\\n```\\n```c++ []\\nint minCost(vector<int>& days, vector<int>& costs, vector<int>& pass, int index, vector<int>& dp) {\\n    // Base case: all days have been covered\\n    if (index == days.size()) {\\n        return 0;\\n    }\\n    \\n    // Check if the result is already computed\\n    if (dp[index] != -1) {\\n        return dp[index];\\n    }\\n    \\n    int minCost = INT_MAX;\\n    \\n    // Try all three types of passes\\n    for (int i = 0; i < costs.size(); i++) {\\n        int cost = costs[i];\\n        int duration = pass[i];\\n        \\n        // Find the next day after the pass expires\\n        int j = index;\\n        while (j < days.size() && days[j] < days[index] + duration) {\\n            j++;\\n        }\\n        \\n        // Compute the cost for the remaining days\\n        int remainingCost = cost + minCost(days, costs, pass, j, dp);\\n        \\n        // Update the minimum cost\\n        minCost = min(minCost, remainingCost);\\n    }\\n    \\n    // Store the result in the memoization array and return it\\n    dp[index] = minCost;\\n    return minCost;\\n}\\n\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n    vector<int> pass = {1, 7, 30};\\n    vector<int> dp(days.size(), -1);\\n    return minCost(days, costs, pass, 0, dp);\\n}\\n```\\n```python []\\ndef minCost(days, costs, pass_, index, dp):\\n    # Base case: all days have been covered\\n    if index == len(days):\\n        return 0\\n    \\n    # Check if the result is already computed\\n    if dp[index] != -1:\\n        return dp[index]\\n    \\n    minCost = float(\\'inf\\')\\n    \\n    # Try all three types of passes\\n    for i in range(len(costs)):\\n        cost = costs[i]\\n        duration = pass_[i]\\n        \\n        # Find the next day after the pass expires\\n        j = index\\n        while j < len(days) and days[j] < days[index] + duration:\\n            j += 1\\n        \\n        # Compute the cost for the remaining days\\n        remainingCost = cost + minCost(days, costs, pass_, j, dp)\\n        \\n        # Update the minimum cost\\n        minCost = min(minCost, remainingCost)\\n    \\n    # Store the result in the memoization array and return it\\n    dp[index] = minCost\\n    return minCost\\n\\ndef mincostTickets(days, costs):\\n    pass_ = [1, 7, 30]\\n    dp = [-1] * len(days)\\n    return minCost(days, costs, pass_, 0, dp)\\n```\\n# SOLUTION LINK \\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3349791/day-362-flow-chart-java-c-python-explained-intuition-algo-dry-run-proof/\\n\\n\\n# DRY RUN 1\\nHere\\'s a dry run process for this case:\\nInput: days = [1,4,6,7,8,20], costs = [2,7,15]\\nOutput: 11\\n##### \\u2022\\tInitialize an array \"dp\" of size n+1 with all elements set to 0. Here, n is the maximum value of days, which is 20 in this case. So, dp will be an array of size 21 with all elements set to 0.\\n##### \\u2022\\tMark the days for which travel is done in the input array \"days\". In this case, the travel is done on days 1, 4, 6, 7, 8, and 20. So, mark the corresponding elements in the \"dp\" array as 1.\\n##### \\u2022\\tNow, for each day from 1 to n, calculate the cost of travel if that day is chosen. To do this, we check if the current day is marked in the \"dp\" array. If it is, we can choose to travel on this day by paying the cost of a one-day pass, which is costs[0] = 2 in this case. If not, we can either choose a 7-day pass or a 30-day pass, depending on which one would be cheaper. To calculate the cost of a 7-day pass, we need to check if we can travel on any of the previous 6 days. If we can, we add the cost of a 7-day pass, which is costs[1] = 7 in this case, to the cost on that day. If not, we can\\'t use a 7-day pass, so we just add the cost of a one-day pass. Similarly, to calculate the cost of a 30-day pass, we need to check if we can travel on any of the previous 29 days. If we can, we add the cost of a 30-day pass, which is costs[2] = 15 in this case, to the cost on that day. If not, we can\\'t use a 30-day pass, so we just add the cost of a one-day pass.\\n##### \\u2022\\tAfter calculating the cost of travel for each day, the final answer is the value of dp[n], which represents the minimum cost of travel for n days.\\n##### \\u2022\\tSo, in this case, the \"dp\" array would look like this after step 2:\\n##### \\u2022\\tdp = [1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]\\n##### \\u2022\\tAnd after step 3, the \"dp\" array would look like this:\\n##### \\u2022\\tdp = [0, 2, 2, 2, 4, 4, 6, 7, 9, 9, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11]\\n##### \\u2022\\tSo the final answer is dp[n] = dp[20] = 11.\\n\\n# DRY RUN 2\\n\\nHere\\'s a dry run process for this case: \\nInput: days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]\\n\\nOutput: 17\\n##### \\u2022\\tInitialize an array \"dp\" of size n+1 with all elements set to 0. Here, n is the maximum value of days, which is 31 in this case. So, dp will be an array of size 32 with all elements set to 0.\\n##### \\u2022\\tMark the days for which travel is done in the input array \"days\". In this case, the travel is done on days 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 30, and 31. So, mark the corresponding elements in the \"dp\" array as 1.\\n##### \\u2022\\tNow, for each day from 1 to n, calculate the cost of travel if that day is chosen. To do this, we check if the current day is marked in the \"dp\" array. If it is, we can choose to travel on this day by paying the cost of a one-day pass, which is costs[0] = 2 in this case. If not, we can either choose a 7-day pass or a 30-day pass, depending on which one would be cheaper. To calculate the cost of a 7-day pass, we need to check if we can travel on any of the previous 6 days. If we can, we add the cost of a 7-day pass, which is costs[1] = 7 in this case, to the cost on that day. If not, we can\\'t use a 7-day pass, so we just add the cost of a one-day pass. Similarly, to calculate the cost of a 30-day pass, we need to check if we can travel on any of the previous 29 days. If we can, we add the cost of a 30-day pass, which is costs[2] = 15 in this case, to the cost on that day. If not, we can\\'t use a 30-day pass, so we just add the cost of a one-day pass.\\n##### \\u2022\\tAfter calculating the cost of travel for each day, the final answer is the value of dp[n], which represents the minimum cost of travel for n days.\\n##### \\u2022\\tSo, in this case, the \"dp\" array would look like this after step 2:\\n##### \\u2022\\tdp = [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]\\n##### \\u2022\\tAnd after step 3, the \"dp\" array would look like this:\\n##### \\u2022\\tdp = [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 18, 18, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 17]\\n##### \\u2022\\tSo the final answer is dp[n] = dp[31] = 17.\\n\\nhere\\'s a brute force solution to the \"Minimum Cost For Tickets\" problem:\\n```java []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    return minCost(days, costs, 0);\\n}\\n\\nprivate int minCost(int[] days, int[] costs, int i) {\\n    if (i == days.length) {\\n        return 0;\\n    }\\n    int cost1 = costs[0] + minCost(days, costs, i + 1);\\n    int j = i;\\n    while (j < days.length && days[j] < days[i] + 7) {\\n        j++;\\n    }\\n    int cost2 = costs[1] + minCost(days, costs, j);\\n    j = i;\\n    while (j < days.length && days[j] < days[i] + 30) {\\n        j++;\\n    }\\n    int cost3 = costs[2] + minCost(days, costs, j);\\n    return Math.min(cost1, Math.min(cost2, cost3));\\n}\\n```\\n\\n# 5th way \\n\\n```c++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> daypasses({1, 7, 30});\\n        vector<int> dp(days.size());\\n\\n        for (int i = 0; i < days.size(); i++) {\\n            int date = days[i];\\n            int mincost = INT_MAX;\\n\\n            for (int j = 0; j < costs.size(); j++) {\\n                int daypass = daypasses[j];\\n                int cost = costs[j];\\n\\n                int preidx = getEqualOrSmaller(days, i - 1, date - daypass);\\n                int precost = 0;\\n\\n                if (preidx >= 0) {\\n                    precost = dp[preidx];\\n                }\\n\\n                mincost = min(mincost, precost + cost);\\n            }\\n\\n            dp[i] = mincost;\\n        }\\n\\n        return dp.back();\\n    }\\n\\n    int getEqualOrSmaller(vector<int>& days, int r, int target) {\\n        int l = 0;\\n        int idx = -1;\\n\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n\\n            if (days[m] == target) {\\n                return m;\\n            }\\n\\n            if (days[m] < target) {\\n                idx = m;\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n\\n        return idx;\\n    }\\n};\\n```\\n```java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[days.length];\\n        int[] durations = new int[]{1, 7, 30};\\n\\n        for (int i = 0; i < days.length; i++) {\\n            int minCost = Integer.MAX_VALUE;\\n            int curDay = days[i];\\n\\n            for (int j = 0; j < costs.length; j++) {\\n                int duration = durations[j];\\n                int cost = costs[j];\\n\\n                int prevIdx = getPrevDayIdx(days, i - 1, curDay - duration);\\n                int prevCost = prevIdx >= 0 ? dp[prevIdx] : 0;\\n\\n                minCost = Math.min(minCost, prevCost + cost);\\n            }\\n\\n            dp[i] = minCost;\\n        }\\n\\n        return dp[dp.length - 1];\\n    }\\n\\n    private int getPrevDayIdx(int[] days, int r, int target) {\\n        int l = 0;\\n        int idx = -1;\\n\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n\\n            if (days[m] == target) {\\n                return m;\\n            }\\n\\n            if (days[m] < target) {\\n                idx = m;\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n\\n        return idx;\\n    }\\n}\\n```\\n```python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [0] * len(days)\\n        durations = [1, 7, 30]\\n\\n        for i in range(len(days)):\\n            minCost = float(\\'inf\\')\\n            curDay = days[i]\\n\\n            for j in range(len(costs)):\\n                duration = durations[j]\\n                cost = costs[j]\\n\\n                prevIdx = self.getPrevDayIdx(days, i - 1, curDay - duration)\\n                prevCost = dp[prevIdx] if prevIdx >= 0 else 0\\n\\n                minCost = min(minCost, prevCost + cost)\\n\\n            dp[i] = minCost\\n\\n        return dp[-1]\\n\\n    def getPrevDayIdx(self, days: List[int], r: int, target: int) -> int:\\n        l = 0\\n        idx = -1\\n\\n        while l <= r:\\n            m = l + (r - l) // 2\\n\\n            if days[m] == target:\\n                return m\\n\\n            if days[m] < target:\\n                idx = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n\\n        return idx\\n```\\n##### \\u2022\\tThe mincostTickets function initializes the DP array and iterates through each travel day. For each travel day, it tries all three types of passes and computes the minimum cost for the current travel day using the minimum cost for the previous travel day covered by the pass. It then stores the minimum cost for the current travel day in the DP array.\\n\\n##### \\u2022\\tThe getEqualOrSmaller function takes the days array, the right index r, and the target date as input. It returns the index of the travel day that is equal to or smaller than the target date.\\n\\n##### \\u2022\\tThis solution has a time complexity of O(n log n), where n is the number of days in the travel period, due to the binary search in the getEqualOrSmaller function, and a space complexity of O(n) due to the DP array.\\n\\n\\n![BREUSELEE.webp](https://assets.leetcode.com/users/images/eedef461-f538-49dd-9482-120de09d46a0_1679981620.0901728.webp)\\n\\n\\n# DAY 362 proof \\n![image.png](https://assets.leetcode.com/users/images/feb1231c-bc05-4c02-b655-de8bf43fcc70_1680004379.571364.png)\\n\\n\\n![meme2.png](https://assets.leetcode.com/users/images/b8fdddf4-5dc7-4b8a-a812-e35d0990d580_1679970322.2557046.png)\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```JAVA []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    // Get the maximum day in the travel period\\n    int maxDay = days[days.length - 1];\\n    \\n    // Initialize the DP array and mark the travel days\\n    int[] dp = new int[maxDay + 1];\\n    boolean[] isTravelDay = new boolean[maxDay + 1];\\n    for (int day : days) {\\n        isTravelDay[day] = true;\\n    }\\n    \\n    // Initialize the costs of different types of passes\\n    int oneDayPassCost = costs[0];\\n    int sevenDayPassCost = costs[1];\\n    int thirtyDayPassCost = costs[2];\\n    \\n    // Compute the minimum cost for each day from 1 to maxDay\\n    for (int i = 1; i <= maxDay; i++) {\\n        if (!isTravelDay[i]) {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        } else {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[i - 1] + oneDayPassCost;\\n            int cost2 = dp[Math.max(0, i - 7)] + sevenDayPassCost;\\n            int cost3 = dp[Math.max(0, i - 30)] + thirtyDayPassCost;\\n            dp[i] = Math.min(cost1, Math.min(cost2, cost3));\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period\\n    return dp[maxDay];\\n}\\n```\n```C++ []\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n    // Get the maximum day in the travel period\\n    int maxDay = days[days.size() - 1];\\n    \\n    // Initialize the DP array and mark the travel days\\n    vector<int> dp(maxDay + 1);\\n    vector<bool> isTravelDay(maxDay + 1);\\n    for (int day : days) {\\n        isTravelDay[day] = true;\\n    }\\n    \\n    // Initialize the costs of different types of passes\\n    int oneDayPassCost = costs[0];\\n    int sevenDayPassCost = costs[1];\\n    int thirtyDayPassCost = costs[2];\\n    \\n    // Compute the minimum cost for each day from 1 to maxDay\\n    for (int i = 1; i <= maxDay; i++) {\\n        if (!isTravelDay[i]) {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        } else {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[i - 1] + oneDayPassCost;\\n            int cost2 = dp[max(0, i - 7)] + sevenDayPassCost;\\n            int cost3 = dp[max(0, i - 30)] + thirtyDayPassCost;\\n            dp[i] = min(cost1, min(cost2, cost3));\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period\\n    return dp[maxDay];\\n}\\n```\n```PYTHON []\\ndef mincostTickets(days: List[int], costs: List[int]) -> int:\\n    # Get the maximum day in the travel period\\n    maxDay = days[-1]\\n    \\n    # Initialize the DP array and mark the travel days\\n    dp = [0] * (maxDay + 1)\\n    isTravelDay = [False] * (maxDay + 1)\\n    for day in days:\\n        isTravelDay[day] = True\\n    \\n    # Initialize the costs of different types of passes\\n    oneDayPassCost = costs[0]\\n    sevenDayPassCost = costs[1]\\n    thirtyDayPassCost = costs[2]\\n    \\n    # Compute the minimum cost for each day from 1 to maxDay\\n    for i in range(1, maxDay + 1):\\n        if not isTravelDay[i]:\\n            # If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1]\\n        else:\\n            # If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            cost1 = dp[i - 1] + oneDayPassCost\\n            cost2 = dp[max(0, i - 7)] + sevenDayPassCost\\n            cost3 = dp[max(0, i - 30)] + thirtyDayPassCost\\n            dp[i] = min(cost1, cost2, cost3)\\n    \\n    # Return the minimum cost for the entire travel period\\n    return dp[maxDay]\\n```\n```java []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    // Get the maximum day in the travel period\\n    int maxDay = days[days.length - 1];\\n\\n    // Initialize the DP array and mark the travel days\\n    int[] dp = new int[maxDay + 1];\\n    boolean[] isTravelDay = new boolean[maxDay + 1];\\n    for (int day : days) {\\n        isTravelDay[day] = true;\\n    }\\n\\n    // Initialize the costs of different types of passes\\n    int oneDayPassCost = costs[0];\\n    int sevenDayPassCost = costs[1];\\n    int thirtyDayPassCost = costs[2];\\n\\n    // Compute the minimum cost for each day from 1 to maxDay\\n    return minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, 1, maxDay);\\n}\\n\\nprivate int minCost(int[] days, int[] costs, int[] dp, boolean[] isTravelDay, int oneDayPassCost, int sevenDayPassCost, int thirtyDayPassCost, int day, int maxDay) {\\n    if (day > maxDay) {\\n        return 0;\\n    }\\n    if (dp[day] != 0) {\\n        return dp[day];\\n    }\\n    if (!isTravelDay[day]) {\\n        dp[day] = minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n    } else {\\n        int cost1 = oneDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n        int cost2 = sevenDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 7), maxDay);\\n        int cost3 = thirtyDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 30), maxDay);\\n        dp[day] = Math.min(cost1, Math.min(cost2, cost3));\\n    }\\n    return dp[day];\\n}\\n\\nprivate int findNextTravelDay(int[] days, int day, int duration) {\\n    int i = 0;\\n    while (i < days.length && days[i] < day + duration) {\\n        i++;\\n    }\\n    return i < days.length ? days[i] : days[days.length - 1] + 1;\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int maxDay = days[days.size() - 1];\\n        vector<int> dp(maxDay + 1);\\n        vector<bool> isTravelDay(maxDay + 1);\\n        for (int day : days) {\\n            isTravelDay[day] = true;\\n        }\\n        int oneDayPassCost = costs[0];\\n        int sevenDayPassCost = costs[1];\\n        int thirtyDayPassCost = costs[2];\\n        return minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, 1, maxDay);\\n    }\\n\\n    int minCost(vector<int>& days, vector<int>& costs, vector<int>& dp, vector<bool>& isTravelDay, int oneDayPassCost, int sevenDayPassCost, int thirtyDayPassCost, int day, int maxDay) {\\n        if (day > maxDay) {\\n            return 0;\\n        }\\n        if (dp[day] != 0) {\\n            return dp[day];\\n        }\\n        if (!isTravelDay[day]) {\\n            dp[day] = minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n        } else {\\n            int cost1 = oneDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay);\\n            int cost2 = sevenDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 7), maxDay);\\n            int cost3 = thirtyDayPassCost + minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, findNextTravelDay(days, day, 30), maxDay);\\n            dp[day] = min(cost1, min(cost2, cost3));\\n        }\\n        return dp[day];\\n    }\\n\\n    int findNextTravelDay(vector<int>& days, int day, int duration) {\\n        int i = 0;\\n        while (i < days.size() && days[i] < day + duration) {\\n            i++;\\n        }\\n        return i < days.size() ? days[i] : days[days.size() - 1] + 1;\\n    }\\n};\\n```\n```python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        maxDay = days[-1]\\n        dp = [0] * (maxDay + 1)\\n        isTravelDay = [False] * (maxDay + 1)\\n        for day in days:\\n            isTravelDay[day] = True\\n        oneDayPassCost = costs[0]\\n        sevenDayPassCost = costs[1]\\n        thirtyDayPassCost = costs[2]\\n        return self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, 1, maxDay)\\n\\n    def minCost(self, days: List[int], costs: List[int], dp: List[int], isTravelDay: List[bool], oneDayPassCost: int, sevenDayPassCost: int, thirtyDayPassCost: int, day: int, maxDay: int) -> int:\\n        if day > maxDay:\\n            return 0\\n        if dp[day] != 0:\\n            return dp[day]\\n        if not isTravelDay[day]:\\n            dp[day] = self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay)\\n        else:\\n            cost1 = oneDayPassCost + self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, day + 1, maxDay)\\n            cost2 = sevenDayPassCost + self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, self.findNextTravelDay(days, day, 7), maxDay)\\n            cost3 = thirtyDayPassCost + self.minCost(days, costs, dp, isTravelDay, oneDayPassCost, sevenDayPassCost, thirtyDayPassCost, self.findNextTravelDay(days, day, 30), maxDay)\\n            dp[day] = min(cost1, min(cost2, cost3))\\n```\n```PYTHON []\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n    # Initialize the DP array with all 0s\\n    dp = [0] * (days[-1] + 1)\\n    \\n    # Convert the list of travel days into a set for faster lookups\\n    travel_days = set(days)\\n    \\n    # Compute the minimum cost for each day from 1 to the maximum day\\n    for i in range(1, len(dp)):\\n        if i in travel_days:\\n            # If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            cost1 = dp[max(i - 1, 0)] + costs[0]\\n            cost2 = dp[max(i - 7, 0)] + costs[1]\\n            cost3 = dp[max(i - 30, 0)] + costs[2]\\n            dp[i] = min(cost1, cost2, cost3)\\n        else:\\n            # If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1]\\n    \\n    # Return the minimum cost for the entire travel period, which is the last element in the DP array\\n    return dp[-1]\\n```\n```JAVA []\\npublic int mincostTickets(int[] days, int[] costs) { // Initialize the DP array with all 0s \\nint[] dp = new int[days[days.length - 1] + 1];\\n\\n    // Convert the list of travel days into a set for faster lookups\\n    Set<Integer> travelDays = new HashSet<>();\\n    for (int day : days) {\\n        travelDays.add(day);\\n    }\\n    \\n    // Compute the minimum cost for each day from 1 to the maximum day\\n    for (int i = 1; i < dp.length; i++) {\\n        if (travelDays.contains(i)) {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[Math.max(i - 1, 0)] + costs[0];\\n            int cost2 = dp[Math.max(i - 7, 0)] + costs[1];\\n            int cost3 = dp[Math.max(i - 30, 0)] + costs[2];\\n            dp[i] = Math.min(cost1, Math.min(cost2, cost3));\\n        } else {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period, which is the last element in the DP array\\n    return dp[dp.length - 1];\\n}\\n```\n```C++ []\\nint mincostTickets(vector<int>& days, vector<int>& costs) { // Initialize the DP array with all 0s \\n    vector dp(days.back() + 1, 0);\\n\\n    // Convert the list of travel days into a set for faster lookups\\n    unordered_set<int> travel_days(days.begin(), days.end());\\n    \\n    // Compute the minimum cost for each day from 1 to the maximum day\\n    for (int i = 1; i < dp.size(); i++) {\\n        if (travel_days.count(i)) {\\n            // If it\\'s a travel day, try all three types of passes and choose the minimum cost\\n            int cost1 = dp[max(i - 1, 0)] + costs[0];\\n            int cost2 = dp[max(i - 7, 0)] + costs[1];\\n            int cost3 = dp[max(i - 30, 0)] + costs[2];\\n            dp[i] = min(cost1, min(cost2, cost3));\\n        } else {\\n            // If it\\'s not a travel day, the cost is the same as the previous day\\n            dp[i] = dp[i - 1];\\n        }\\n    }\\n    \\n    // Return the minimum cost for the entire travel period, which is the last element in the DP array\\n    return dp.back();\\n}\\n```\n```java []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    int n = days.length;\\n    int[] pass = {1, 7, 30};\\n    int[] dp = new int[n];\\n    Arrays.fill(dp, -1);\\n    return minCost(days, costs, pass, 0, dp);\\n}\\n\\npublic int minCost(int[] days, int[] costs, int[] pass, int index, int[] dp) {\\n    // Base case: all days have been covered\\n    if (index == days.length) {\\n        return 0;\\n    }\\n    \\n    // Check if the result is already computed\\n    if (dp[index] != -1) {\\n        return dp[index];\\n    }\\n    \\n    int minCost = Integer.MAX_VALUE;\\n    \\n    // Try all three types of passes\\n    for (int i = 0; i < costs.length; i++) {\\n        int cost = costs[i];\\n        int duration = pass[i];\\n        \\n        // Find the next day after the pass expires\\n        int j = index;\\n        while (j < days.length && days[j] < days[index] + duration) {\\n            j++;\\n        }\\n        \\n        // Compute the cost for the remaining days\\n        int remainingCost = cost + minCost(days, costs, pass, j, dp);\\n        \\n        // Update the minimum cost\\n        minCost = Math.min(minCost, remainingCost);\\n    }\\n    \\n    // Store the result in the memoization array and return it\\n    dp[index] = minCost;\\n    return minCost;\\n}\\n```\n```c++ []\\nint minCost(vector<int>& days, vector<int>& costs, vector<int>& pass, int index, vector<int>& dp) {\\n    // Base case: all days have been covered\\n    if (index == days.size()) {\\n        return 0;\\n    }\\n    \\n    // Check if the result is already computed\\n    if (dp[index] != -1) {\\n        return dp[index];\\n    }\\n    \\n    int minCost = INT_MAX;\\n    \\n    // Try all three types of passes\\n    for (int i = 0; i < costs.size(); i++) {\\n        int cost = costs[i];\\n        int duration = pass[i];\\n        \\n        // Find the next day after the pass expires\\n        int j = index;\\n        while (j < days.size() && days[j] < days[index] + duration) {\\n            j++;\\n        }\\n        \\n        // Compute the cost for the remaining days\\n        int remainingCost = cost + minCost(days, costs, pass, j, dp);\\n        \\n        // Update the minimum cost\\n        minCost = min(minCost, remainingCost);\\n    }\\n    \\n    // Store the result in the memoization array and return it\\n    dp[index] = minCost;\\n    return minCost;\\n}\\n\\nint mincostTickets(vector<int>& days, vector<int>& costs) {\\n    vector<int> pass = {1, 7, 30};\\n    vector<int> dp(days.size(), -1);\\n    return minCost(days, costs, pass, 0, dp);\\n}\\n```\n```python []\\ndef minCost(days, costs, pass_, index, dp):\\n    # Base case: all days have been covered\\n    if index == len(days):\\n        return 0\\n    \\n    # Check if the result is already computed\\n    if dp[index] != -1:\\n        return dp[index]\\n    \\n    minCost = float(\\'inf\\')\\n    \\n    # Try all three types of passes\\n    for i in range(len(costs)):\\n        cost = costs[i]\\n        duration = pass_[i]\\n        \\n        # Find the next day after the pass expires\\n        j = index\\n        while j < len(days) and days[j] < days[index] + duration:\\n            j += 1\\n        \\n        # Compute the cost for the remaining days\\n        remainingCost = cost + minCost(days, costs, pass_, j, dp)\\n        \\n        # Update the minimum cost\\n        minCost = min(minCost, remainingCost)\\n    \\n    # Store the result in the memoization array and return it\\n    dp[index] = minCost\\n    return minCost\\n\\ndef mincostTickets(days, costs):\\n    pass_ = [1, 7, 30]\\n    dp = [-1] * len(days)\\n    return minCost(days, costs, pass_, 0, dp)\\n```\n```java []\\npublic int mincostTickets(int[] days, int[] costs) {\\n    return minCost(days, costs, 0);\\n}\\n\\nprivate int minCost(int[] days, int[] costs, int i) {\\n    if (i == days.length) {\\n        return 0;\\n    }\\n    int cost1 = costs[0] + minCost(days, costs, i + 1);\\n    int j = i;\\n    while (j < days.length && days[j] < days[i] + 7) {\\n        j++;\\n    }\\n    int cost2 = costs[1] + minCost(days, costs, j);\\n    j = i;\\n    while (j < days.length && days[j] < days[i] + 30) {\\n        j++;\\n    }\\n    int cost3 = costs[2] + minCost(days, costs, j);\\n    return Math.min(cost1, Math.min(cost2, cost3));\\n}\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> daypasses({1, 7, 30});\\n        vector<int> dp(days.size());\\n\\n        for (int i = 0; i < days.size(); i++) {\\n            int date = days[i];\\n            int mincost = INT_MAX;\\n\\n            for (int j = 0; j < costs.size(); j++) {\\n                int daypass = daypasses[j];\\n                int cost = costs[j];\\n\\n                int preidx = getEqualOrSmaller(days, i - 1, date - daypass);\\n                int precost = 0;\\n\\n                if (preidx >= 0) {\\n                    precost = dp[preidx];\\n                }\\n\\n                mincost = min(mincost, precost + cost);\\n            }\\n\\n            dp[i] = mincost;\\n        }\\n\\n        return dp.back();\\n    }\\n\\n    int getEqualOrSmaller(vector<int>& days, int r, int target) {\\n        int l = 0;\\n        int idx = -1;\\n\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n\\n            if (days[m] == target) {\\n                return m;\\n            }\\n\\n            if (days[m] < target) {\\n                idx = m;\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n\\n        return idx;\\n    }\\n};\\n```\n```java []\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[days.length];\\n        int[] durations = new int[]{1, 7, 30};\\n\\n        for (int i = 0; i < days.length; i++) {\\n            int minCost = Integer.MAX_VALUE;\\n            int curDay = days[i];\\n\\n            for (int j = 0; j < costs.length; j++) {\\n                int duration = durations[j];\\n                int cost = costs[j];\\n\\n                int prevIdx = getPrevDayIdx(days, i - 1, curDay - duration);\\n                int prevCost = prevIdx >= 0 ? dp[prevIdx] : 0;\\n\\n                minCost = Math.min(minCost, prevCost + cost);\\n            }\\n\\n            dp[i] = minCost;\\n        }\\n\\n        return dp[dp.length - 1];\\n    }\\n\\n    private int getPrevDayIdx(int[] days, int r, int target) {\\n        int l = 0;\\n        int idx = -1;\\n\\n        while (l <= r) {\\n            int m = l + (r - l) / 2;\\n\\n            if (days[m] == target) {\\n                return m;\\n            }\\n\\n            if (days[m] < target) {\\n                idx = m;\\n                l = m + 1;\\n            } else {\\n                r = m - 1;\\n            }\\n        }\\n\\n        return idx;\\n    }\\n}\\n```\n```python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [0] * len(days)\\n        durations = [1, 7, 30]\\n\\n        for i in range(len(days)):\\n            minCost = float(\\'inf\\')\\n            curDay = days[i]\\n\\n            for j in range(len(costs)):\\n                duration = durations[j]\\n                cost = costs[j]\\n\\n                prevIdx = self.getPrevDayIdx(days, i - 1, curDay - duration)\\n                prevCost = dp[prevIdx] if prevIdx >= 0 else 0\\n\\n                minCost = min(minCost, prevCost + cost)\\n\\n            dp[i] = minCost\\n\\n        return dp[-1]\\n\\n    def getPrevDayIdx(self, days: List[int], r: int, target: int) -> int:\\n        l = 0\\n        idx = -1\\n\\n        while l <= r:\\n            m = l + (r - l) // 2\\n\\n            if days[m] == target:\\n                return m\\n\\n            if days[m] < target:\\n                idx = m\\n                l = m + 1\\n            else:\\n                r = m - 1\\n\\n        return idx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2345641,
                "title": "dp-solution-as-striver-taught-beginner-friendly",
                "content": "# Beginner friendly solution\\n**ya you can optimise it more but it is just for understanding the core concept of picking and not_picking **\\n```\\nclass Solution {\\npublic:\\n   int helper(int ind  , vector<int>&costs , unordered_set<int>&days,vector<int>&dp )\\n {\\n    if(ind> 365)\\n    {\\n        return 0;\\n    }\\n    if(dp[ind]!=-1)\\n    {\\n        return dp[ind];\\n    }\\n       //Well if the day is not present we will not be tarvelling\\n\\t   //so this is not_pick condition\\n    if(days.find(ind) == days.end()) \\n    {\\n       return helper(ind+1  ,costs ,days,dp );\\n    }\\n  //if the day is present then we will pick and add the cost\\n    int day1 = costs[0] + helper(ind+1  , costs , days ,dp);\\n    int day7 = costs[1] + helper(ind+7  , costs , days ,dp);\\n    int day30 = costs[2] + helper(ind+30  , costs , days,dp );\\n\\n    return dp[ind] = min(day1 ,min (day7 , day30));\\n }\\n int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        unordered_set<int>temp;\\n        vector<int>dp(366,-1);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n           temp.insert(days[i]);\\n        }\\n\\n       return helper(days[0]  ,costs,temp,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int helper(int ind  , vector<int>&costs , unordered_set<int>&days,vector<int>&dp )\\n {\\n    if(ind> 365)\\n    {\\n        return 0;\\n    }\\n    if(dp[ind]!=-1)\\n    {\\n        return dp[ind];\\n    }\\n       //Well if the day is not present we will not be tarvelling\\n\\t   //so this is not_pick condition\\n    if(days.find(ind) == days.end()) \\n    {\\n       return helper(ind+1  ,costs ,days,dp );\\n    }\\n  //if the day is present then we will pick and add the cost\\n    int day1 = costs[0] + helper(ind+1  , costs , days ,dp);\\n    int day7 = costs[1] + helper(ind+7  , costs , days ,dp);\\n    int day30 = costs[2] + helper(ind+30  , costs , days,dp );\\n\\n    return dp[ind] = min(day1 ,min (day7 , day30));\\n }\\n int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        unordered_set<int>temp;\\n        vector<int>dp(366,-1);\\n        for(int i = 0 ; i < n ; i++)\\n        {\\n           temp.insert(days[i]);\\n        }\\n\\n       return helper(days[0]  ,costs,temp,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815165,
                "title": "video-explanation-minimum-cost-for-tickets-leetcode-recursive-to-memoization-c",
                "content": "*Please let me know if I need to improve anything.*\\n\\n[FaxMachine Codes](https://www.youtube.com/watch?v=374z8uiGAsM&t=139s)\\n\\n**Recursive Approach (gives TLE)**\\n\\n```\\npublic class Solution {\\n    int[] daysTravel;\\n    \\n    public Solution() {\\n        daysTravel = new int[]{1, 7, 30};\\n    }\\n    \\n    public int MincostTickets(int[] days, int[] costs) {\\n        return MincostTicketsUtil(days, costs, 0, 0);\\n    }\\n    \\n    private int MincostTicketsUtil(int[] days, int[] costs, int index, int day) {\\n        if(index >= days.Length)\\n            return 0;\\n        \\n        if(days[index] < day) {\\n            return MincostTicketsUtil(days, costs, index + 1, day);\\n        }\\n        \\n        int cost = int.MaxValue;\\n        \\n        for(int i = 0; i < 3; i++) {\\n            cost = Math.Min(cost, costs[i] + MincostTicketsUtil(days, costs, index + 1,\\n                                                                days[index] + daysTravel[i]));\\n        }\\n        \\n        return cost;\\n    }\\n}\\n```\\n\\n**Memoization**\\n\\n```\\npublic class Solution {\\n    int[] daysTravel;\\n    int[] dp;\\n    \\n    public int MincostTickets(int[] days, int[] costs) {\\n        daysTravel = new int[]{1, 7, 30};\\n        dp = new int[days.Length];\\n        Array.Fill(dp, -1);\\n        return MincostTicketsUtil(days, costs, 0, 0);\\n    }\\n    \\n    private int MincostTicketsUtil(int[] days, int[] costs, int index, int day) {\\n        if(index >= days.Length)\\n            return 0;\\n        \\n        if(index > 0 && days[index] < day) {\\n            return MincostTicketsUtil(days, costs, index + 1, day);\\n        }\\n        \\n        if(dp[index] != -1)\\n            return dp[index];\\n        \\n        int cost = int.MaxValue;\\n        \\n        for(int i = 0; i < 3; i++) {\\n            cost = Math.Min(cost, costs[i] + MincostTicketsUtil(days, costs, index + 1,\\n                                                                days[index] + daysTravel[i]));\\n        }\\n        \\n        dp[index] = cost;\\n        \\n        return dp[index];\\n    }\\n}\\n```\\n\\n*Please Like, Subscribe and Upvote this solution if you liked it.*",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization"
                ],
                "code": "```\\npublic class Solution {\\n    int[] daysTravel;\\n    \\n    public Solution() {\\n        daysTravel = new int[]{1, 7, 30};\\n    }\\n    \\n    public int MincostTickets(int[] days, int[] costs) {\\n        return MincostTicketsUtil(days, costs, 0, 0);\\n    }\\n    \\n    private int MincostTicketsUtil(int[] days, int[] costs, int index, int day) {\\n        if(index >= days.Length)\\n            return 0;\\n        \\n        if(days[index] < day) {\\n            return MincostTicketsUtil(days, costs, index + 1, day);\\n        }\\n        \\n        int cost = int.MaxValue;\\n        \\n        for(int i = 0; i < 3; i++) {\\n            cost = Math.Min(cost, costs[i] + MincostTicketsUtil(days, costs, index + 1,\\n                                                                days[index] + daysTravel[i]));\\n        }\\n        \\n        return cost;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    int[] daysTravel;\\n    int[] dp;\\n    \\n    public int MincostTickets(int[] days, int[] costs) {\\n        daysTravel = new int[]{1, 7, 30};\\n        dp = new int[days.Length];\\n        Array.Fill(dp, -1);\\n        return MincostTicketsUtil(days, costs, 0, 0);\\n    }\\n    \\n    private int MincostTicketsUtil(int[] days, int[] costs, int index, int day) {\\n        if(index >= days.Length)\\n            return 0;\\n        \\n        if(index > 0 && days[index] < day) {\\n            return MincostTicketsUtil(days, costs, index + 1, day);\\n        }\\n        \\n        if(dp[index] != -1)\\n            return dp[index];\\n        \\n        int cost = int.MaxValue;\\n        \\n        for(int i = 0; i < 3; i++) {\\n            cost = Math.Min(cost, costs[i] + MincostTicketsUtil(days, costs, index + 1,\\n                                                                days[index] + daysTravel[i]));\\n        }\\n        \\n        dp[index] = cost;\\n        \\n        return dp[index];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354591,
                "title": "c-solution",
                "content": "```\\npublic static int MincostTickets(int[] days, int[] costs)\\n        {\\n            var set = new HashSet<int>(days);\\n            int[] dp = new int[366];\\n            for (int i = 1; i < dp.Length; i++)\\n                if (!set.Contains(i))\\n                    dp[i] = dp[i - 1];\\n                else dp[i] = Math.Min(dp[i - 1] + costs[0], Math.Min(dp[Math.Max(0, i - 7)] + costs[1], dp[Math.Max(0, i - 30)] + costs[2]));\\n\\n            return dp[365];\\n        }\\n```",
                "solutionTags": [],
                "code": "```\\npublic static int MincostTickets(int[] days, int[] costs)\\n        {\\n            var set = new HashSet<int>(days);\\n            int[] dp = new int[366];\\n            for (int i = 1; i < dp.Length; i++)\\n                if (!set.Contains(i))\\n                    dp[i] = dp[i - 1];\\n                else dp[i] = Math.Min(dp[i - 1] + costs[0], Math.Min(dp[Math.Max(0, i - 7)] + costs[1], dp[Math.Max(0, i - 30)] + costs[2]));\\n\\n            return dp[365];\\n        }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 226704,
                "title": "java-o-nlogn-dp-solution-and-recursion-memorization-solution",
                "content": "```\\n//DP\\n//DP[i] is the minimum cost to complete the trip for the first i entris in days array...\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        if (days == null || days.length == 0) return 0;\\n        int n = days.length;\\n        int[] dp = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            int res = dp[i] + costs[0]; //previous cost + today\\'s cost...\\n            \\n            //find the left most index that is larger than days[i] - 7..\\n            //calculate the cost by using prev cost + one-week cost...\\n            int index7 = binarySearch(days, i, days[i] - 7);\\n            res = Math.min(res, dp[index7] + costs[1]);\\n            \\n            //find the left most index that is larger than days[i] - 30..\\n            //calculate the cost by using prev cost + one-month cost...\\n            int index30 = binarySearch(days, i, days[i] - 30);\\n            res = Math.min(res, dp[index30] + costs[2]);\\n            dp[i + 1] = res;\\n        }\\n        return dp[n];\\n    }\\n    \\n    private int binarySearch(int[] days, int i, int target) {\\n        int lo = 0, hi = i;\\n        while (lo  < hi) {\\n            int mid = lo + (hi - lo) / 2;\\n            if (days[mid] > target) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n\\n\\n\\n//recursion + memorization...\\nclass Solution {\\n    Integer[] memo;\\n    //memo[i] is the minimum cost from days[i] to days[days.length - 1];\\n    public int mincostTickets(int[] days, int[] costs) {\\n        if (days == null || days.length == 0) return 0;\\n        int n = days.length;\\n        memo = new Integer[n];      \\n        return minCost(days, costs, 0);\\n    }\\n    \\n    private int minCost(int[] days, int[] costs, int lo) {\\n        int n = days.length;\\n        if (lo >= n) return 0;\\n        if (memo[lo] != null) return memo[lo];\\n        int res = costs[0] + minCost(days, costs, lo + 1);\\n        \\n        //use binary search to find the right most index that has days[i] < days[lo] + 7...\\n        int index7 = binarySearch(days, lo, days[lo] + 7);\\n        res = Math.min(res, costs[1] + minCost(days, costs, index7 + 1));\\n        \\n        //use binary search to find the right most index that has days[i] <= days[lo] + 30...\\n        int index30 = binarySearch(days, lo, days[lo] + 30);\\n        res = Math.min(res, costs[2] + minCost(days, costs, index30 + 1));\\n        \\n        memo[lo] = res;\\n        return res;\\n    }\\n    \\n    private int binarySearch(int[] days, int lo, int target) {\\n        int hi = days.length - 1;\\n        while (lo < hi) {\\n            int mid = lo + (hi - lo + 1) / 2;\\n            if (days[mid] < target) {\\n                lo = mid;\\n            } else {\\n                hi = mid - 1;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        if (days == null || days.length == 0) return 0;\\n        int n = days.length;\\n        int[] dp = new int[n + 1];\\n        for (int i = 0; i < n; i++) {\\n            int res = dp[i] + costs[0]; //previous cost + today\\'s cost...\\n            \\n            //find the left most index that is larger than days[i] - 7..\\n            //calculate the cost by using prev cost + one-week cost...\\n            int index7 = binarySearch(days, i, days[i] - 7);\\n            res = Math.min(res, dp[index7] + costs[1]);\\n            \\n            //find the left most index that is larger than days[i] - 30..\\n            //calculate the cost by using prev cost + one-month cost...\\n            int index30 = binarySearch(days, i, days[i] - 30);\\n            res = Math.min(res, dp[index30] + costs[2]);\\n            dp[i + 1] = res;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 811064,
                "title": "simple-dp-solution-in-python3",
                "content": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mincostTickets(self, days: List[int], cost: List[int]) -> int:\\n        last = days[-1]\\n        dp = [0 for i in range(last + 1)]\\n        traveldays = Counter(days)\\n        \\n        for i in range(last + 1):\\n            if i not in traveldays:\\n                dp[i] = dp[i-1]\\n            else:\\n                one = dp[max(0, i - 1)] + cost[0]\\n                seven = dp[max(0, i - 7)] + cost[1]\\n                thirty = dp[max(0, i - 30)] + cost[2]\\n                dp[i] = min(one, seven, thirty)\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def mincostTickets(self, days: List[int], cost: List[int]) -> int:\\n        last = days[-1]\\n        dp = [0 for i in range(last + 1)]\\n        traveldays = Counter(days)\\n        \\n        for i in range(last + 1):\\n            if i not in traveldays:\\n                dp[i] = dp[i-1]\\n            else:\\n                one = dp[max(0, i - 1)] + cost[0]\\n                seven = dp[max(0, i - 7)] + cost[1]\\n                thirty = dp[max(0, i - 30)] + cost[2]\\n                dp[i] = min(one, seven, thirty)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 418307,
                "title": "c-recursive-solution",
                "content": "*we only buy ticket on travelling day*\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool s[366];\\n    int memo[366];\\n    \\n\\n    int dp(vector<int> &days, vector<int> &costs,int i=0)\\n    {\\n        if(i>365)  return 0;\\n        \\n        if (memo[i]!=-1)  return memo[i];\\n        int ans1,ans2,ans3;\\n        \\n        //if  not a travelling day we skip until the next travelling day\\n        if(s[i]==0)\\n        {\\n            return (memo[i]=dp(days,costs,i+1));\\n        }\\n        else\\n        {\\n            // on travelling day we can take 3  types of passes\\n           \\n            ans1=costs[0]+dp(days,costs,i+1);\\n            ans2=costs[1]+dp(days,costs,i+7);\\n            ans3=costs[2]+dp(days,costs,i+30);\\n        }\\n        \\n        return (memo[i]=min(ans1,min(ans2,ans3)));\\n        \\n\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        memset(s,0,sizeof(s));\\n        memset(memo,-1,sizeof(memo));\\n        for(auto x:days) s[x]=true;\\n        return dp(days,costs,0);\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool s[366];\\n    int memo[366];\\n    \\n\\n    int dp(vector<int> &days, vector<int> &costs,int i=0)\\n    {\\n        if(i>365)  return 0;\\n        \\n        if (memo[i]!=-1)  return memo[i];\\n        int ans1,ans2,ans3;\\n        \\n        //if  not a travelling day we skip until the next travelling day\\n        if(s[i]==0)\\n        {\\n            return (memo[i]=dp(days,costs,i+1));\\n        }\\n        else\\n        {\\n            // on travelling day we can take 3  types of passes\\n           \\n            ans1=costs[0]+dp(days,costs,i+1);\\n            ans2=costs[1]+dp(days,costs,i+7);\\n            ans3=costs[2]+dp(days,costs,i+30);\\n        }\\n        \\n        return (memo[i]=min(ans1,min(ans2,ans3)));\\n        \\n\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        memset(s,0,sizeof(s));\\n        memset(memo,-1,sizeof(memo));\\n        for(auto x:days) s[x]=true;\\n        return dp(days,costs,0);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226657,
                "title": "short-python-recursive-dp",
                "content": "The idea is to test all possible ways of taking the tickets to cover the current day, and recurse on the remaining.\\nWe use a cache, to make it DP, to store intermediate results.\\n\\nOne of the important things to understand is what cache[i] means.\\n\\nCache[i]: Means, the total min. Cost to cover days starting from i. and assuming i is not covered.\\n\\nSo, if i is already covered, then i simply move on to recursing next.\\n\\n\\n```\\ndef mincost(i, covered_until):\\n\\tif i >= len(days): return 0\\n\\tif days[i] <= covered_until: return mincost(i+1, covered_until)\\n\\tif i in cache: return cache[i]\\n\\tres = min(costs[0] + mincost(i + 1, days[i]), costs[1] + mincost(i + 1, days[i]+6), costs[2] + mincost(i + 1, days[i]+29))\\n\\tcache[i] = res\\n\\treturn cache[i]\\ncache = {}\\nreturn mincost(0, 0)\\n```",
                "solutionTags": [],
                "code": "```\\ndef mincost(i, covered_until):\\n\\tif i >= len(days): return 0\\n\\tif days[i] <= covered_until: return mincost(i+1, covered_until)\\n\\tif i in cache: return cache[i]\\n\\tres = min(costs[0] + mincost(i + 1, days[i]), costs[1] + mincost(i + 1, days[i]+6), costs[2] + mincost(i + 1, days[i]+29))\\n\\tcache[i] = res\\n\\treturn cache[i]\\ncache = {}\\nreturn mincost(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3411957,
                "title": "c-bottom-up-approach-beats-100-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOkay, we are first of all we are creating the dp array to store our previous calculation, and initializating ```dp[n]``` with 0 we will talk about that latter.\\n\\nAlso we have to supporting methods ```skipWeek``` and ```skipMonth``` this methods trying to find day after our 7-day pass and 30-day pass. \\nIn ```skipWeek``` we returning first day that are larger than ```days[index] + 6``` (this day and six next days) or ```days.size()```, that mean in ```days``` there are no \"travel\" days after end of 7-day pass from ```days[index]```  to ```days[index] + 6```.\\n```skipMonth``` works same as ```skipWeek``` but now we are trying to find next \"travel\" day after end of 30-day pass.\\n\\n\\nAfter initializating all, we run loop from ```n-1``` to ```0``` at each iteration we are trying to get how much money we spent earlier. \\n```costIfTakeDay``` - amount of money spent earlier plus ```cost[0]``` . That means how much we spent earlier and if for this day we will take 1-day ticket.\\n```costIfTakeWeek``` - amount of money spent earlier plus ```cost[1]```. That means how much we spent earlier and if for this day we will take 7-day ticket. If there are no days before function ```skipWeek``` will return ```days.size()```, but we already initialized ```dp[days.size()] = 0;``` and the cost of travel from ```days[index]``` will cost like a 7-day pass\\n```costIfTakeMonth``` - - amount of money spent earlier plus ```cost[2]```. Means same as ```costIfTakeWeek``` but calls  ```skipMonth``` function.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int> &days, vector<int> &costs) {\\n        int n = days.size();\\n        auto dp = std::vector<::uint16_t>(n+1, 1001);\\n        dp[n] = 0;\\n\\n        for (int i = n - 1; i >= 0; --i) {\\n            int costIfTakeDay = dp[i + 1] + costs[0];\\n            int costIfTakeWeek = dp[skipWeek(i, days)] + costs[1];\\n            int costIfTakeMonth = dp[skipMonth(i, days)] + costs[2];\\n\\n            dp[i] = std::min({costIfTakeDay, costIfTakeMonth, costIfTakeWeek});\\n        }\\n        return dp[0];\\n    }\\n\\n    int skipWeek(int index, std::vector<int> &days) {\\n        int lastDayOfWeekTicket = days[index] + 6;\\n        for (auto i = index; i < days.size(); ++i) {\\n            if (days[i] > lastDayOfWeekTicket)\\n                return i;\\n        }\\n        return days.size();\\n    }\\n\\n    int skipMonth(int index, std::vector<int> &days) {\\n        int lastDayOfMonthTicket = days[index] + 29;\\n        for (auto i = index; i < days.size(); ++i) {\\n            if (days[i] > lastDayOfMonthTicket)\\n                return i;\\n        }\\n        return days.size();\\n    }\\n};\\n```\\n\\n![_za_kompom_yapfiles.ru-min (online-video-cutter.com).gif](https://assets.leetcode.com/users/images/24de1e30-69bf-4d5e-9d36-cc6d305eadb8_1681373977.8447819.gif)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```dp[n]```\n```skipWeek```\n```skipMonth```\n```skipWeek```\n```days[index] + 6```\n```days.size()```\n```days```\n```days[index]```\n```days[index] + 6```\n```skipMonth```\n```skipWeek```\n```n-1```\n```0```\n```costIfTakeDay```\n```cost[0]```\n```costIfTakeWeek```\n```cost[1]```\n```skipWeek```\n```days.size()```\n```dp[days.size()] = 0;```\n```days[index]```\n```costIfTakeMonth```\n```cost[2]```\n```costIfTakeWeek```\n```skipMonth```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int> &days, vector<int> &costs) {\\n        int n = days.size();\\n        auto dp = std::vector<::uint16_t>(n+1, 1001);\\n        dp[n] = 0;\\n\\n        for (int i = n - 1; i >= 0; --i) {\\n            int costIfTakeDay = dp[i + 1] + costs[0];\\n            int costIfTakeWeek = dp[skipWeek(i, days)] + costs[1];\\n            int costIfTakeMonth = dp[skipMonth(i, days)] + costs[2];\\n\\n            dp[i] = std::min({costIfTakeDay, costIfTakeMonth, costIfTakeWeek});\\n        }\\n        return dp[0];\\n    }\\n\\n    int skipWeek(int index, std::vector<int> &days) {\\n        int lastDayOfWeekTicket = days[index] + 6;\\n        for (auto i = index; i < days.size(); ++i) {\\n            if (days[i] > lastDayOfWeekTicket)\\n                return i;\\n        }\\n        return days.size();\\n    }\\n\\n    int skipMonth(int index, std::vector<int> &days) {\\n        int lastDayOfMonthTicket = days[index] + 29;\\n        for (auto i = index; i < days.size(); ++i) {\\n            if (days[i] > lastDayOfMonthTicket)\\n                return i;\\n        }\\n        return days.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948406,
                "title": "dp-binary-search",
                "content": "**DP +Binary Search** . Time Complexity is O(Nlogn) and Space is O(N) . This code for Just a Knowledge .\\nPlease Hit the Like if u like My post.\\n\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n     int n=days.size();\\n     int dp[n];\\n     memset(dp, 0, sizeof(dp));\\n       \\n    for(int i=0; i<n;i++){\\n        \\n        if(i==0){\\n            //Base Case  Only One Day is there means size of days array is 1.\\n            dp[i]= *min_element(costs.begin(), costs.end());\\n            continue;\\n        }\\n        // val varible is used  to find minimum cost to reach days[i].\\n        // Choice one :- (1 day ticket).\\n        int val= dp[i-1]+costs[0];\\n        int index= lower_bound(days.begin() ,days.begin()+i, days[i]-6)-days.begin();\\n        // choice two :- 7 day ticket. As we know days array is sorted in Nature . \\n        // So Binary Search we can apply to find started day to Buy a ticket of 7 day pass.\\n        if(index!=0){\\n           val=min(dp[index-1]+ costs[1], val); \\n        }else{\\n            val=min(val, costs[1]);\\n        }\\n        index=lower_bound(days.begin() ,days.begin()+i, days[i]-29)-days.begin();\\n        // Similarly with 30 day pass as we do as 7 day pass.\\n        if(index!=0){\\n            val= min(dp[index-1]+costs[2], val);\\n        }else{\\n            val=min(val, costs[2]);\\n        }\\n        // Store val in dp for the Memoization.\\n        dp[i]=val;\\n        // cout<<dp[i]<<endl;\\n        \\n    }\\n        \\n    return dp[n-1];\\n        \\n    \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n     int n=days.size();\\n     int dp[n];\\n     memset(dp, 0, sizeof(dp));\\n       \\n    for(int i=0; i<n;i++){\\n        \\n        if(i==0){\\n            //Base Case  Only One Day is there means size of days array is 1.\\n            dp[i]= *min_element(costs.begin(), costs.end());\\n            continue;\\n        }\\n        // val varible is used  to find minimum cost to reach days[i].\\n        // Choice one :- (1 day ticket).\\n        int val= dp[i-1]+costs[0];\\n        int index= lower_bound(days.begin() ,days.begin()+i, days[i]-6)-days.begin();\\n        // choice two :- 7 day ticket. As we know days array is sorted in Nature . \\n        // So Binary Search we can apply to find started day to Buy a ticket of 7 day pass.\\n        if(index!=0){\\n           val=min(dp[index-1]+ costs[1], val); \\n        }else{\\n            val=min(val, costs[1]);\\n        }\\n        index=lower_bound(days.begin() ,days.begin()+i, days[i]-29)-days.begin();\\n        // Similarly with 30 day pass as we do as 7 day pass.\\n        if(index!=0){\\n            val= min(dp[index-1]+costs[2], val);\\n        }else{\\n            val=min(val, costs[2]);\\n        }\\n        // Store val in dp for the Memoization.\\n        dp[i]=val;\\n        // cout<<dp[i]<<endl;\\n        \\n    }\\n        \\n    return dp[n-1];\\n        \\n    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1778507,
                "title": "java-dp-solution-similar-to-coin-change",
                "content": "This question can be solved both recursively & tabulated way similarly to the Classic Coin change problem. Just like how we would be looping through all coin possiblities for a given amount, we would consider cost for all 3 passes at once (1,7,30) days.\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[366]; // we would consider all 365 days for our simplicity\\n        int k = 0;\\n        for(int i = 1; k < days.length; i++)\\n        {\\n            if(i != days[k])\\n                dp[i] = dp[i-1]; // just if we dont have to travel on the Current ith day in our 365 day Calendar, we consider the result from the previous day we have travelled\\n            else\\n            {\\n                int daypass = i-1 > 0 ?  dp[i-1] + costs[0] : costs[0]; // if we can go back 1 day & check the cost till a day before + 1 day pass for current day\\n                int weekpass = i-7 > 0 ? dp[i-7] + costs[1] : costs[1]; // if we can go back 7 days & check the cost till a week before + 7 day pass for current day\\n                int monthpass = i-30 > 0 ? dp[i-30] + costs[2] : costs[2]; // if we can go back 30 days & check the cost till a month before + 30 day pass for current day\\n                \\n                dp[i] = Math.min(monthpass, Math.min(weekpass,daypass)); // min of all above scenarios\\n                k++;\\n            }\\n        }\\n        k = days[days.length-1];\\n        return dp[k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[366]; // we would consider all 365 days for our simplicity\\n        int k = 0;\\n        for(int i = 1; k < days.length; i++)\\n        {\\n            if(i != days[k])\\n                dp[i] = dp[i-1]; // just if we dont have to travel on the Current ith day in our 365 day Calendar, we consider the result from the previous day we have travelled\\n            else\\n            {\\n                int daypass = i-1 > 0 ?  dp[i-1] + costs[0] : costs[0]; // if we can go back 1 day & check the cost till a day before + 1 day pass for current day\\n                int weekpass = i-7 > 0 ? dp[i-7] + costs[1] : costs[1]; // if we can go back 7 days & check the cost till a week before + 7 day pass for current day\\n                int monthpass = i-30 > 0 ? dp[i-30] + costs[2] : costs[2]; // if we can go back 30 days & check the cost till a month before + 30 day pass for current day\\n                \\n                dp[i] = Math.min(monthpass, Math.min(weekpass,daypass)); // min of all above scenarios\\n                k++;\\n            }\\n        }\\n        k = days[days.length-1];\\n        return dp[k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 658009,
                "title": "simple-cpp-solution-using-dp-with-detailed-explanation-o-n-tc",
                "content": "```\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\t//since days are sorted, take the last day that you should travel.\\n        int lastDay = days.back();\\n        vector<int> dp(lastDay + 1, -1);\\n\\n        //Mark those days needed to travel on as 0, just to remind us to do DP at this index.\\n        for(auto i : days)\\n            dp[i] = 0;\\n        //Make 0th day as 0, since it costs 0 to travel on 0th day\\n        dp[0] = 0;\\n        //Iterate from 1st day to last day\\n        for(int i = 1; i <= lastDay; i++)\\n        {\\n\\t\\t//If current index is -1, then we are not travelling on this day. Cost will be same as previous index\\n            if(dp[i] == -1)\\n                dp[i] = dp[i-1];\\n            else\\n            {\\n//Cost for one day travel is cost to travel till this date (dp[i-1]) + cost of one day travel\\n                dp[i] = dp[i-1] + costs[0];\\n//cost to travel if you had taken 7 day pass earlier and see if that can be cheaper than current cost.\\n                dp[i] = min(dp[i], dp[max(0, i-7)] + costs[1]);\\n//cost to travel if you had taken 7 day pass earlier and see if that can be cheaper than current cost.\\n                dp[i] = min(dp[i], dp[max(0, i-30)] + costs[2]);\\n            }\\n        }\\n        return dp[lastDay];\\n```",
                "solutionTags": [],
                "code": "```\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\t//since days are sorted, take the last day that you should travel.\\n        int lastDay = days.back();\\n        vector<int> dp(lastDay + 1, -1);\\n\\n        //Mark those days needed to travel on as 0, just to remind us to do DP at this index.\\n        for(auto i : days)\\n            dp[i] = 0;\\n        //Make 0th day as 0, since it costs 0 to travel on 0th day\\n        dp[0] = 0;\\n        //Iterate from 1st day to last day\\n        for(int i = 1; i <= lastDay; i++)\\n        {\\n\\t\\t//If current index is -1, then we are not travelling on this day. Cost will be same as previous index\\n            if(dp[i] == -1)\\n                dp[i] = dp[i-1];\\n            else\\n            {\\n//Cost for one day travel is cost to travel till this date (dp[i-1]) + cost of one day travel\\n                dp[i] = dp[i-1] + costs[0];\\n//cost to travel if you had taken 7 day pass earlier and see if that can be cheaper than current cost.\\n                dp[i] = min(dp[i], dp[max(0, i-7)] + costs[1]);\\n//cost to travel if you had taken 7 day pass earlier and see if that can be cheaper than current cost.\\n                dp[i] = min(dp[i], dp[max(0, i-30)] + costs[2]);\\n            }\\n        }\\n        return dp[lastDay];\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 238974,
                "title": "javascript-as-simple-as-it-gets",
                "content": "Keep a running total of your cost every day. \\nOn days where you need a ticket increment your cost by the daily cost.\\nEveryday do the following:\\n\\tLook back a week (or the first day) to see if it would have been cheaper to buy a weekly ticket. \\n\\tLook back a month (or the first day) to see if it would have been cheaper to buy a monthly ticket. \\n\\n```\\nvar mincostTickets = function(days, costs) {\\n    \\n    let total = Array(365);\\n    let dayPtr = 0;\\n    \\n    total[0] = 0;\\n    for(let i = 1; i < 365; i++){\\n        let curCost = total[i - 1];\\n        \\n        if(days[dayPtr] == i){\\n            curCost += costs[0];\\n            dayPtr++;\\n        }\\n        curCost = Math.min(curCost,total[Math.max(0,i - 7)] + costs[1]);\\n        curCost = Math.min(curCost,total[Math.max(0, i - 30)] + costs[2]); \\n\\n        \\n        total[i] = curCost;\\n    }\\n    \\n    return total[365 - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mincostTickets = function(days, costs) {\\n    \\n    let total = Array(365);\\n    let dayPtr = 0;\\n    \\n    total[0] = 0;\\n    for(let i = 1; i < 365; i++){\\n        let curCost = total[i - 1];\\n        \\n        if(days[dayPtr] == i){\\n            curCost += costs[0];\\n            dayPtr++;\\n        }\\n        curCost = Math.min(curCost,total[Math.max(0,i - 7)] + costs[1]);\\n        curCost = Math.min(curCost,total[Math.max(0, i - 30)] + costs[2]); \\n\\n        \\n        total[i] = curCost;\\n    }\\n    \\n    return total[365 - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3493310,
                "title": "recursion-memoization-very-easy-approach-with-easy-comments",
                "content": "class Solution {\\npublic:\\n \\n\\n    int solve(int n , vector<int>& days, vector<int>& costs , int ind , vector<int>& dp ){\\n        \\n        //BASE CASE agar index N ya usse bda hojae to hum sare days travel kr chuke h return krjao \\n        if(ind >= n){\\n            return 0 ;\\n        }\\n        \\n\\t\\t//step3 dp \\n        if(dp[ind] != -1)\\n            return dp[ind];\\n        \\n         // Mere pass 3 option honge har bar ya to ma ek day ka pass lu ya\\n        //3 din ka pass lu ya fir 7 din ka pass lu  \\n      \\n        //1 din ka pass \\n        \\n        int option1 = costs[0] + solve(n , days , costs , ind+1 , dp);\\n        \\n      // ek option ha ma 7 din ka pass lelu lekin agar mne 7 din ka pass lelia to mera\\n     //  index muje jb tk agge le jane hoga jb tk 7 din nhi ho jate \\n    // yani agar mne pass lia h day 1 pe to abb 1 se 7 tk jitne bhi din h unke lia call nhi krunga ma \\n        \\n        int i ;\\n        //iss for loop ko hmne bas i increase krne ke lia chlaya h \\n        \\n        for(i = ind ; i<n && days[i] <days[ind] + 7 ; i++);\\n        int option2 = costs[1] + solve(n , days , costs , i , dp);\\n        \\n        // abb ind na pass krke i pass krenge kyuki i hmara 7 days ke \\n      // lia traverse kr chuka h or same for 30 days \\n        \\n        int j ;\\n        for(j = ind ; j<n && days[j] <days[ind] + 30 ; j++);\\n        int option3 = costs[2] + solve(n , days , costs , j , dp); \\n        \\n\\t\\t//step 2 dp \\n        return dp[ind] =  min(option1 , min(option2 , option3));\\n        \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n\\t\\t//step 1 dp \\n        vector<int> dp(n+1, -1);\\n        int ans = solve(n , days , costs , 0 , dp);\\n        return ans; \\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n \\n\\n    int solve(int n , vector<int>& days, vector<int>& costs , int ind , vector<int>& dp ){\\n        \\n        //BASE CASE agar index N ya usse bda hojae to hum sare days travel kr chuke h return krjao \\n        if(ind >= n){\\n            return 0 ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3366816,
                "title": "minimum-cost-for-tickets-mem-dp-concept",
                "content": "class Solution {\\npublic:\\n    int solvemem(int n1,vector<int>& days, vector<int>& costs,int index,vector<int> &dp){\\n        if(index>=n1){\\n            return 0;\\n        }\\n        if(dp[index]!=-1){\\n            return dp[index];\\n        }\\n        int option1=costs[0]+solvemem(n1,days,costs,index+1,dp);\\n        int i;\\n        for( i=index;i<n1 && days[i]<days[index]+7;i++);\\n        int option2=costs[1]+solvemem(n1,days,costs,i,dp);\\n        \\n        \\n        for( i=index;i<n1 && days[i]<days[index]+30;i++);\\n        int option3=costs[2]+solvemem(n1,days,costs,i,dp);\\n        \\n        \\n        dp[index]=min(option1,min(option2,option3));\\n        return dp[index];\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // vector<int> dp(n+1,-1);\\n        int n=days.size();\\n         vector<int> dp(n+1,-1);\\n        return solvemem(n,days,costs,0,dp);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int solvemem(int n1,vector<int>& days, vector<int>& costs,int index,vector<int> &dp){\\n        if(index>=n1){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3350997,
                "title": "simple-solution-with-detailed-comments",
                "content": "# JavaScript Solution\\n```\\nvar mincostTickets = function (days, costs) {\\n  // Create an array to store the minimum cost for each day of the year\\n  const minCosts = new Array(days[days.length - 1] + 1).fill(0);\\n  \\n  // Create a set of the days you will be traveling on for faster lookup\\n  const travelDays = new Set(days);\\n  \\n  // Loop through each day of the year, starting from day 1\\n  for (let day = 1; day < minCosts.length; day++) {\\n    // If you\\'re not traveling on this day, the minimum cost is the same as the previous day\\n    if (!travelDays.has(day)) {\\n      minCosts[day] = minCosts[day - 1];\\n    } else {\\n      // If you\\'re traveling on this day, calculate the minimum cost by comparing the costs\\n      // of buying a 1-day pass, a 7-day pass, or a 30-day pass on this day, and adding the\\n      // cost of the minimum cost of traveling up to 1, 7, or 30 days ago respectively\\n      minCosts[day] = Math.min(\\n        minCosts[day - 1] + costs[0],\\n        minCosts[Math.max(0, day - 7)] + costs[1],\\n        minCosts[Math.max(0, day - 30)] + costs[2]\\n      );\\n    }\\n  }\\n  \\n  // Return the minimum cost for traveling on all the given days\\n  return minCosts[minCosts.length - 1];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar mincostTickets = function (days, costs) {\\n  // Create an array to store the minimum cost for each day of the year\\n  const minCosts = new Array(days[days.length - 1] + 1).fill(0);\\n  \\n  // Create a set of the days you will be traveling on for faster lookup\\n  const travelDays = new Set(days);\\n  \\n  // Loop through each day of the year, starting from day 1\\n  for (let day = 1; day < minCosts.length; day++) {\\n    // If you\\'re not traveling on this day, the minimum cost is the same as the previous day\\n    if (!travelDays.has(day)) {\\n      minCosts[day] = minCosts[day - 1];\\n    } else {\\n      // If you\\'re traveling on this day, calculate the minimum cost by comparing the costs\\n      // of buying a 1-day pass, a 7-day pass, or a 30-day pass on this day, and adding the\\n      // cost of the minimum cost of traveling up to 1, 7, or 30 days ago respectively\\n      minCosts[day] = Math.min(\\n        minCosts[day - 1] + costs[0],\\n        minCosts[Math.max(0, day - 7)] + costs[1],\\n        minCosts[Math.max(0, day - 30)] + costs[2]\\n      );\\n    }\\n  }\\n  \\n  // Return the minimum cost for traveling on all the given days\\n  return minCosts[minCosts.length - 1];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3350806,
                "title": "recursion-memoisation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfirst we will try with recursion then we will optimse time complexcity due to overlapping subproblems by 1 d dp\\nf(cd) is each state of recursive function \\nis defined as min travelling cost from day cd to the last valid travelling day\\nintuition is that we will buy tickets only when we encounter a valid travelling day \\non the rest of the day we assume to solve the question that we dont require a pass to travel on that day\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nif the last travelling day=d\\nthen time complexcity =O(d)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int dp[366];\\n\\n    int help(int cd,vector<int>&days,set<int>&st,vector<int>&costs,int & total,int till){\\n\\n\\n        //understand each state of this recursive function\\n        //f(cd) will tell the minimum cost to travel from day cd to the last valid travelling day\\n        if(cd>days[days.size()-1]){\\n            total=min(total,till);\\n            return  0;\\n        }\\n      \\n        if(dp[cd]!=-1){\\n            return dp[cd];\\n        }\\n        int ans=INT_MAX;\\n\\n        if(st.find(cd)==st.end()){\\n                ans=help(cd+1,days,st,costs,total,till);\\n\\n        }else{\\n            int c1=costs[0]+help(cd+1,days,st,costs,total,till+costs[0]);\\n            int c2=costs[1]+help(cd+7,days,st,costs,total,till+costs[1]);\\n            int c3=costs[2]+help(cd+30,days,st,costs,total,till+costs[2]);\\n            ans =min({c1,c2,c3,ans});\\n        }\\n        return dp[cd]=ans;\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\n        //first we will be writing the recursive approach for this question \\n\\n\\n        set<int>st;\\n        for(auto e:days){\\n            st.insert(e);\\n        }\\n\\n        memset(dp,-1,sizeof(dp));\\n\\n\\n        //st will contain the valid days on which we need to travel\\n        int total=INT_MAX;\\n        return help(1,days,st,costs,total,0);\\n        return total;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[366];\\n\\n    int help(int cd,vector<int>&days,set<int>&st,vector<int>&costs,int & total,int till){\\n\\n\\n        //understand each state of this recursive function\\n        //f(cd) will tell the minimum cost to travel from day cd to the last valid travelling day\\n        if(cd>days[days.size()-1]){\\n            total=min(total,till);\\n            return  0;\\n        }\\n      \\n        if(dp[cd]!=-1){\\n            return dp[cd];\\n        }\\n        int ans=INT_MAX;\\n\\n        if(st.find(cd)==st.end()){\\n                ans=help(cd+1,days,st,costs,total,till);\\n\\n        }else{\\n            int c1=costs[0]+help(cd+1,days,st,costs,total,till+costs[0]);\\n            int c2=costs[1]+help(cd+7,days,st,costs,total,till+costs[1]);\\n            int c3=costs[2]+help(cd+30,days,st,costs,total,till+costs[2]);\\n            ans =min({c1,c2,c3,ans});\\n        }\\n        return dp[cd]=ans;\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\n        //first we will be writing the recursive approach for this question \\n\\n\\n        set<int>st;\\n        for(auto e:days){\\n            st.insert(e);\\n        }\\n\\n        memset(dp,-1,sizeof(dp));\\n\\n\\n        //st will contain the valid days on which we need to travel\\n        int total=INT_MAX;\\n        return help(1,days,st,costs,total,0);\\n        return total;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349673,
                "title": "java-easy-solution-detailed-explanation-dp-100-faster-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[days.length+1];\\n        int monthStart = 1;\\n        int weekStart = 1;\\n        \\n        for(int i=0;i<days.length;i++){\\n            \\n            //calculate the total cost till the current day if day pass is bought\\n            int dayPass = costs[0] + dp[i];\\n            \\n            //Find the best possible window for week pass from current day(i)\\n            while(days[i]-days[weekStart-1]+1>7)\\n                weekStart++;\\n            \\n            //calculate the total cost till current day if week pass is bought for the last week pass window possible\\n            int weekPass = costs[1] + dp[weekStart-1];\\n            \\n            //Find the best possible window for month pass from current day(i)\\n            while(days[i]-days[monthStart-1]+1>30)\\n                monthStart++;\\n            \\n            //calculate the total cost till current day if month pass is bought for the last month pass window possible\\n            int monthPass = costs[2] + dp[monthStart-1];\\n            \\n            //Now calculate the lowest ticket cost till current day. This is done by choosing the lowest cost among day pass, week pass(for last 7 days) or month pass (for last 30 days)\\n            dp[i+1] = Math.min(dayPass,Math.min(weekPass,monthPass));\\n        }\\n        return dp[days.length];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[days.length+1];\\n        int monthStart = 1;\\n        int weekStart = 1;\\n        \\n        for(int i=0;i<days.length;i++){\\n            \\n            //calculate the total cost till the current day if day pass is bought\\n            int dayPass = costs[0] + dp[i];\\n            \\n            //Find the best possible window for week pass from current day(i)\\n            while(days[i]-days[weekStart-1]+1>7)\\n                weekStart++;\\n            \\n            //calculate the total cost till current day if week pass is bought for the last week pass window possible\\n            int weekPass = costs[1] + dp[weekStart-1];\\n            \\n            //Find the best possible window for month pass from current day(i)\\n            while(days[i]-days[monthStart-1]+1>30)\\n                monthStart++;\\n            \\n            //calculate the total cost till current day if month pass is bought for the last month pass window possible\\n            int monthPass = costs[2] + dp[monthStart-1];\\n            \\n            //Now calculate the lowest ticket cost till current day. This is done by choosing the lowest cost among day pass, week pass(for last 7 days) or month pass (for last 30 days)\\n            dp[i+1] = Math.min(dayPass,Math.min(weekPass,monthPass));\\n        }\\n        return dp[days.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2991115,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Recursive DP\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int max_day, cost[5], dys[500], dp[500];\\n\\n    int solve(int id) {\\n        if(id > 365) return 0;\\n        if(dp[id] != -1) return dp[id];\\n\\n        int ans;\\n        if(dys[id]) {\\n            ans = min({cost[0] + solve(id+1), cost[1] + solve(id+7), cost[2] + solve(id+30)});\\n        }\\n        else {\\n            ans = solve(id+1);\\n        }\\n        return dp[id] = ans;\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        for(int i=0; i<3; i++) cost[i] = costs[i];\\n        for(int i=0; i<500; i++) dp[i] = -1;\\n        for(int i=0; i<days.size(); i++) dys[days[i]] = 1;\\n        int ans = solve(0);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int max_day, cost[5], dys[500], dp[500];\\n\\n    int solve(int id) {\\n        if(id > 365) return 0;\\n        if(dp[id] != -1) return dp[id];\\n\\n        int ans;\\n        if(dys[id]) {\\n            ans = min({cost[0] + solve(id+1), cost[1] + solve(id+7), cost[2] + solve(id+30)});\\n        }\\n        else {\\n            ans = solve(id+1);\\n        }\\n        return dp[id] = ans;\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        for(int i=0; i<3; i++) cost[i] = costs[i];\\n        for(int i=0; i<500; i++) dp[i] = -1;\\n        for(int i=0; i<days.size(); i++) dys[days[i]] = 1;\\n        int ans = solve(0);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631059,
                "title": "c-iterative-dp-faster-than-100",
                "content": "Please upvote if you found this solution helpful.\\n\\n```\\n    int mincostTickets(vector<int> &days, vector<int> &costs) {\\n        vector<int> DP(days.back() + 1); // DP[i] is cost after ith day of travel\\n        DP[0] = 0; // initial cost before traveling is zero\\n        int i = 0; // iterator for days vector\\n        \\n        // **** Not neccessary\\n        int monthly = costs[2];\\n        int weekly = min(costs[1], monthly);\\n        int single = min(costs[0], weekly);\\n        // **** Not neccessary\\n        \\n        for (int day = 1; day < DP.size(); ++day) {\\n            if (day < days[i]) {\\n                /* Not traveling this day */\\n                DP[day] = DP[day - 1];\\n            } else if (day == days[i]) {\\n                // Recurrence relation\\n                DP[day] = DP[day - 1] + single;\\n                DP[day] = min(DP[day], DP[max(0, day - 7)] + weekly);\\n                DP[day] = min(DP[day], DP[max(0, day - 30)] + monthly);\\n                \\n                ++i; // Advance to next travel day\\n            } \\n        }\\n        \\n        return DP.back();\\n    }",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Iterator"
                ],
                "code": "Please upvote if you found this solution helpful.\\n\\n```\\n    int mincostTickets(vector<int> &days, vector<int> &costs) {\\n        vector<int> DP(days.back() + 1); // DP[i] is cost after ith day of travel\\n        DP[0] = 0; // initial cost before traveling is zero\\n        int i = 0; // iterator for days vector\\n        \\n        // **** Not neccessary\\n        int monthly = costs[2];\\n        int weekly = min(costs[1], monthly);\\n        int single = min(costs[0], weekly);\\n        // **** Not neccessary\\n        \\n        for (int day = 1; day < DP.size(); ++day) {\\n            if (day < days[i]) {\\n                /* Not traveling this day */\\n                DP[day] = DP[day - 1];\\n            } else if (day == days[i]) {\\n                // Recurrence relation\\n                DP[day] = DP[day - 1] + single;\\n                DP[day] = min(DP[day], DP[max(0, day - 7)] + weekly);\\n                DP[day] = min(DP[day], DP[max(0, day - 30)] + monthly);\\n                \\n                ++i; // Advance to next travel day\\n            } \\n        }\\n        \\n        return DP.back();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1563435,
                "title": "simple-python-solution-with-explanation",
                "content": "explanation : https://github.com/midnightbot/leetcode_solutions/blob/main/983.%20Minimum%20Cost%20For%20Tickets(DP).pdf\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n = max(days) + 1\\n        dp = [-1 for x in range(n)]\\n        #dp = [-1]*(max(days)+1)\\n        dp[0] = 0\\n        \\n        for x in range(1,len(dp)):\\n            if x in days:\\n                if x>=30:\\n                    #print(x,min(dp[x-1]+costs[0],dp[x-7]+costs[1],dp[x-30]+costs[2]))\\n                    dp[x] = min(dp[x-1]+costs[0],dp[x-7]+costs[1],dp[x-30]+costs[2])\\n                    \\n                elif x>=7 and x<30:\\n                    dp[x] = min(dp[x-1]+costs[0],dp[x-7]+costs[1],costs[2])\\n                    \\n                else:\\n                    dp[x] = min(dp[x-1]+costs[0],costs[1],costs[2])\\n                    \\n            else:\\n                dp[x] = dp[x-1]\\n                \\n        return dp[max(days)]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n = max(days) + 1\\n        dp = [-1 for x in range(n)]\\n        #dp = [-1]*(max(days)+1)\\n        dp[0] = 0\\n        \\n        for x in range(1,len(dp)):\\n            if x in days:\\n                if x>=30:\\n                    #print(x,min(dp[x-1]+costs[0],dp[x-7]+costs[1],dp[x-30]+costs[2]))\\n                    dp[x] = min(dp[x-1]+costs[0],dp[x-7]+costs[1],dp[x-30]+costs[2])\\n                    \\n                elif x>=7 and x<30:\\n                    dp[x] = min(dp[x-1]+costs[0],dp[x-7]+costs[1],costs[2])\\n                    \\n                else:\\n                    dp[x] = min(dp[x-1]+costs[0],costs[1],costs[2])\\n                    \\n            else:\\n                dp[x] = dp[x-1]\\n                \\n        return dp[max(days)]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339864,
                "title": "c-simple-and-easy-solution-faster-than-100-without-hash-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n  \\n        int dp[366] = {};\\n        \\n        for(int a : days)\\n            dp[a]++;\\n        \\n        for(int i = days[0]; i <= days.back(); i++){\\n            if(dp[i]){\\n                dp[i] = min({dp[i-1] + costs[0], dp[max(0, i-7)] + costs[1], dp[max(0, i-30)] + costs[2]});\\n            }\\n            else dp[i] = dp[i-1];\\n        }\\n        return dp[days.back()];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n  \\n        int dp[366] = {}",
                "codeTag": "Java"
            },
            {
                "id": 1320678,
                "title": "c-memoization-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[366];\\n    int solve(vector<int>&days,vector<int>&cost,int i){\\n        if(i>=days.size()) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int op1=cost[0]+solve(days,cost,i+1);\\n        \\n        int k=i;\\n        for(;k<days.size();k++){\\n            if(days[k]>=days[i]+7){\\n                break;\\n            }\\n        }\\n        int op2=cost[1]+solve(days,cost,k);\\n        \\n         for(;k<days.size();k++){\\n            if(days[k]>=days[i]+30){\\n                break;\\n            }\\n        }\\n        int op3=cost[2]+solve(days,cost,k);\\n        \\n        dp[i]=min(op1,min(op2,op3));\\n        \\n        return min(op1,min(op2,op3));\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(days,costs,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dp[366];\\n    int solve(vector<int>&days,vector<int>&cost,int i){\\n        if(i>=days.size()) return 0;\\n        if(dp[i]!=-1) return dp[i];\\n        int op1=cost[0]+solve(days,cost,i+1);\\n        \\n        int k=i;\\n        for(;k<days.size();k++){\\n            if(days[k]>=days[i]+7){\\n                break;\\n            }\\n        }\\n        int op2=cost[1]+solve(days,cost,k);\\n        \\n         for(;k<days.size();k++){\\n            if(days[k]>=days[i]+30){\\n                break;\\n            }\\n        }\\n        int op3=cost[2]+solve(days,cost,k);\\n        \\n        dp[i]=min(op1,min(op2,op3));\\n        \\n        return min(op1,min(op2,op3));\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp,-1,sizeof dp);\\n        return solve(days,costs,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811661,
                "title": "c-dynamic-programming-simple-solution",
                "content": "**Like it? please upvote...**\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> d(days.back()+1); // initialize a help array for dynamic programming\\n        for (int i=0; i<days.size(); i++) // days of traveling are initialized with max value\\n            d[days[i]] = INT_MAX;\\n        for (int i = 1; i<d.size();i++) // dynamic programming: fill the array depending on previous sub-problems\\n        {\\n            if (d[i] == 0)\\n                d[i] = d[i-1];\\n            else\\n                if (i < 7)\\n                    d[i] = min({d[i-1]+costs[0], d[0]+costs[1]});\\n                else if (i<30)\\n                    d[i] = min({d[i-1]+costs[0], d[i-7]+costs[1], d[0]+costs[2]});\\n                else\\n                    d[i] = min({d[i-1]+costs[0], d[i-7]+costs[1], d[i-30]+costs[2]});\\n        }\\n        return d.back();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> d(days.back()+1); // initialize a help array for dynamic programming\\n        for (int i=0; i<days.size(); i++) // days of traveling are initialized with max value\\n            d[days[i]] = INT_MAX;\\n        for (int i = 1; i<d.size();i++) // dynamic programming: fill the array depending on previous sub-problems\\n        {\\n            if (d[i] == 0)\\n                d[i] = d[i-1];\\n            else\\n                if (i < 7)\\n                    d[i] = min({d[i-1]+costs[0], d[0]+costs[1]});\\n                else if (i<30)\\n                    d[i] = min({d[i-1]+costs[0], d[i-7]+costs[1], d[0]+costs[2]});\\n                else\\n                    d[i] = min({d[i-1]+costs[0], d[i-7]+costs[1], d[i-30]+costs[2]});\\n        }\\n        return d.back();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 811378,
                "title": "java-100-0ms-dp-o-n-simple-explanation-no-recursion",
                "content": "**If useful, please up-vote.**\\n\\nUse a dynamic programming array ```dp[]``` indexed by the day number.  The ```dp[]``` array contains the minimum cost up to a specific day.  To decide between 1-day, 7-day, and 30-day tickets being cheapest, we will need look backward 1, 7, and 30 days in ```dp[]```, then add the ticket cost, and see which type of ticket would give the lowest cost to get to the current day.  We loop through days from the first travel day to the last travel day, updating the minimum cost to get to that day.  The ```dp[]``` array includes **all** days from day 0, until the last travel day, including all non-travel days in between travel days.\\n\\nBecause the 30-day ticket would use the longest look back in ```dp[]```, we add an **offset of 30 days** to all indexes into ```dp[]```.  With the 30 day offset, all day numbers used from ```days[]``` have 30 added to that day number.  This 30 day offset keeps the look backs from repeatedly requiring extra coding to make sure we don\\'t look back to a negative index in the ```dp[]``` array.  For example, **without** the extra 30 offset, at day 4, if looking back 30 days, we would need extra code to keep from indexing day 4-30 = day -26.  **With** an offset of 30 days into ```dp[]```, we can always safely index back to the current day minus 7 or the current day minus 30.\\n\\nSteps in the code below are:\\n1) Loop through all days from the first travel day to the last travel day.  The first travel day is ```days[0] + 30```, adding 30 for a 30 day offset of indexing the ```dp[]``` array.  The last travel day is ```days[days.length - 1] + 30```.\\n2) Get the day number of the next travel day, offset by 30 extra days.\\n3) If there are non-travel days since the last travel day, then copy the previous minimum cost from the previous day in ```dp[]``` to all non-travel days since the last travel day.\\n4) Find the minimum of the three costs of travelling with either a 1-day, 7-day, or 30-day ticket, for the last 1, 7, or 30 days.  \\n4a) To find the cost of travelling for the previous 1 day on a 1-day ticket, look back 1-day to get the minimum cost we had determined 1-day ago in ```dp[day-1]```, and add the ```costs[0]``` of a 1-day ticket since then.\\n4b) To find the cost travelling for the previous 7 days on a 7-day ticket, look back 7-days in ```dp[]``` to get the minimum cost we calculated in ```dp[day-7]```, and add the ```costs[1]``` of a 7-day ticket to travel since 7 days ago.  \\n4c) To find the cost of travelling for the previous 30 days on a 30-day ticket, look back 30-days in ```dp[]``` to get the minimum cost 30 days earlier in ```dp[day-30]```, and add the ```costs[2]``` of a 30-day ticket since then. \\n5) Loop back to step 2) until having processed the last travel day.\\n6) Return the minimum cost for the last travel day in ```dp[]```.\\n\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int firstDay = days[0] + 30;                            // First day to travel, offset by max look back.\\n        int lastDay = days[days.length - 1] + 30;               // Last day to travel, offset by max look back.\\n        int travelDayIndex = 0;                                 // Index of current travel day, in days[].\\n        int[] dp = new int[lastDay + 1 + 30];\\n        \\n        // Loop through the days to be travelling, including all the days between travel days.\\n        for (int day = firstDay; day <= lastDay; day++) {\\n            int nextTravelDay = days[travelDayIndex++] + 30;    // Next travel day, offset by max look back.\\n            while (day < nextTravelDay)                         // Loop through non-travel days until next travel day.\\n                dp[day] = dp[day++ - 1];                        // Between travel days, continue prev best price.\\n            dp[day] = Math.min(dp[day-1] + costs[0],            // Find min of 1-day ticket for last 1 day,\\n                               Math.min(dp[day-7] + costs[1],   //    or 7-day ticket for last 7 days, \\n                                       dp[day-30] + costs[2])); //    or 30-day ticket for last 30 days.\\n        }\\n        \\n        return dp[lastDay];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```dp[]```\n```dp[]```\n```dp[]```\n```dp[]```\n```dp[]```\n```dp[]```\n```days[]```\n```dp[]```\n```dp[]```\n```days[0] + 30```\n```dp[]```\n```days[days.length - 1] + 30```\n```dp[]```\n```dp[day-1]```\n```costs[0]```\n```dp[]```\n```dp[day-7]```\n```costs[1]```\n```dp[]```\n```dp[day-30]```\n```costs[2]```\n```dp[]```\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int firstDay = days[0] + 30;                            // First day to travel, offset by max look back.\\n        int lastDay = days[days.length - 1] + 30;               // Last day to travel, offset by max look back.\\n        int travelDayIndex = 0;                                 // Index of current travel day, in days[].\\n        int[] dp = new int[lastDay + 1 + 30];\\n        \\n        // Loop through the days to be travelling, including all the days between travel days.\\n        for (int day = firstDay; day <= lastDay; day++) {\\n            int nextTravelDay = days[travelDayIndex++] + 30;    // Next travel day, offset by max look back.\\n            while (day < nextTravelDay)                         // Loop through non-travel days until next travel day.\\n                dp[day] = dp[day++ - 1];                        // Between travel days, continue prev best price.\\n            dp[day] = Math.min(dp[day-1] + costs[0],            // Find min of 1-day ticket for last 1 day,\\n                               Math.min(dp[day-7] + costs[1],   //    or 7-day ticket for last 7 days, \\n                                       dp[day-30] + costs[2])); //    or 30-day ticket for last 30 days.\\n        }\\n        \\n        return dp[lastDay];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 701437,
                "title": "simple-to-understand-python-dp-bottom-up-approach",
                "content": "\\n```\\nday      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\\ncosts    0, 2, 2, 2, 4, 4, 6, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 11\\n```\\n\\n`costs` represent the cache in the code whereas `day` is the corresponding day. Notice how we do not update the cost on the days we do not travel e.g on day `2-3` and days `9 - 19 `\\n\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n = days[-1] + 1\\n        cache = [0] * n\\n\\n        # convert days to set for faster lookup\\n        travel_days = {day for day in days}\\n\\n        for i in range(1, n):\\n            if i in travel_days:\\n                # use max() to pick cache[0] incase `i-day` is out of bounds\\n                cache[i] = min(\\n                    [\\n                        cache[max(i - 1, 0)] + costs[0],  # one day pass\\n                        cache[max(i - 7, 0)] + costs[1],  # seven day pass\\n                        cache[max(i - 30, 0)] + costs[2],  # thirty day pass\\n                    ]\\n                )\\n            else:\\n                # not a travel day\\n                cache[i] = cache[i - 1]\\n\\n        return cache[-1]",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nday      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20\\ncosts    0, 2, 2, 2, 4, 4, 6, 7, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 9, 11\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 342599,
                "title": "python",
                "content": "```\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [0] * (days[-1] + 1)\\n        day = set(days)\\n        for i in range(1, days[-1] + 1):\\n            if i not in day:\\n                dp[i] = dp[i-1]\\n            else:\\n                dp[i] = min(dp[i-1]+costs[0], dp[max(0, i-7)]+costs[1], dp[max(0, i-30)] + costs[2])\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        dp = [0] * (days[-1] + 1)\\n        day = set(days)\\n        for i in range(1, days[-1] + 1):\\n            if i not in day:\\n                dp[i] = dp[i-1]\\n            else:\\n                dp[i] = min(dp[i-1]+costs[0], dp[max(0, i-7)]+costs[1], dp[max(0, i-30)] + costs[2])\\n        return dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3683203,
                "title": "memoized-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,int e,vector<int> &days,vector<int> &costs,vector<vector<int>> &dp){\\n        if(i>=n || e>365){\\n            return 0;\\n        }\\n        if(dp[i][e] != -1)return dp[i][e];\\n        int a = INT_MAX,b=INT_MAX,c=INT_MAX;\\n        if(days[i]>e){\\n            a = costs[0]+solve(i+1,n,days[i],days,costs,dp);\\n        }\\n        if(days[i]>e){\\n            b = costs[1]+solve(i+1,n,days[i]+6,days,costs,dp);\\n        }else{\\n            b = solve(i+1,n,e,days,costs,dp);\\n        }\\n        if(days[i]>e){\\n            c = costs[2]+solve(i+1,n,days[i]+29,days,costs,dp);\\n        }else{\\n            c = solve(i+1,n,e,days,costs,dp);\\n        }\\n        return dp[i][e] = min({a,b,c});\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<vector<int>> dp(n,vector<int>(366,-1));\\n        return solve(0,n,0,days,costs,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i,int &n,int e,vector<int> &days,vector<int> &costs,vector<vector<int>> &dp){\\n        if(i>=n || e>365){\\n            return 0;\\n        }\\n        if(dp[i][e] != -1)return dp[i][e];\\n        int a = INT_MAX,b=INT_MAX,c=INT_MAX;\\n        if(days[i]>e){\\n            a = costs[0]+solve(i+1,n,days[i],days,costs,dp);\\n        }\\n        if(days[i]>e){\\n            b = costs[1]+solve(i+1,n,days[i]+6,days,costs,dp);\\n        }else{\\n            b = solve(i+1,n,e,days,costs,dp);\\n        }\\n        if(days[i]>e){\\n            c = costs[2]+solve(i+1,n,days[i]+29,days,costs,dp);\\n        }else{\\n            c = solve(i+1,n,e,days,costs,dp);\\n        }\\n        return dp[i][e] = min({a,b,c});\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<vector<int>> dp(n,vector<int>(366,-1));\\n        return solve(0,n,0,days,costs,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352638,
                "title": "1-loop-solution-o-n",
                "content": "### Explained below inside the code for better Understanding.\\n\\n# \\uD83D\\uDE09Don\\'t just watch & move away, also give an Upvote.\\uD83D\\uDE09\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# \\uD83D\\uDE09Please upvote it motivates me\\uD83D\\uDE09\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        unordered_set<int> st(begin(days), end(days));\\n\\n        int last_day = days.back();\\n\\n        vector<int> t(last_day+1, 0);\\n        //t[i] will give us min cost to travel till day i.\\n\\n        t[0] = 0;\\n\\n        //Start from 1st day & travel till last day\\n        for(int i=1; i<=last_day; i++)\\n        {\\n            /* If i\\'th day is not found then\\n            set previous value in current index & continue. */\\n            if(st.find(i) == st.end())\\n            {\\n                t[i] = t[i-1];\\n                continue;\\n            }\\n\\n            //Calculate cost of day 1 pass\\n            int day_1_pass = costs[0] + t[max(i-1, 0)];\\n\\n            //Calculate cost of day 7 pass\\n            int day_7_pass = costs[1] + t[max(i-7, 0)];\\n\\n            //Calculate cost of day 30 pass\\n            int day_30_pass = costs[2] + t[max(i-30, 0)];\\n\\n\\n            //Find minimum of all & store in i\\'th index.\\n            t[i] = min({day_1_pass, day_7_pass, day_30_pass});\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return t[last_day];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        unordered_set<int> st(begin(days), end(days));\\n\\n        int last_day = days.back();\\n\\n        vector<int> t(last_day+1, 0);\\n        //t[i] will give us min cost to travel till day i.\\n\\n        t[0] = 0;\\n\\n        //Start from 1st day & travel till last day\\n        for(int i=1; i<=last_day; i++)\\n        {\\n            /* If i\\'th day is not found then\\n            set previous value in current index & continue. */\\n            if(st.find(i) == st.end())\\n            {\\n                t[i] = t[i-1];\\n                continue;\\n            }\\n\\n            //Calculate cost of day 1 pass\\n            int day_1_pass = costs[0] + t[max(i-1, 0)];\\n\\n            //Calculate cost of day 7 pass\\n            int day_7_pass = costs[1] + t[max(i-7, 0)];\\n\\n            //Calculate cost of day 30 pass\\n            int day_30_pass = costs[2] + t[max(i-30, 0)];\\n\\n\\n            //Find minimum of all & store in i\\'th index.\\n            t[i] = min({day_1_pass, day_7_pass, day_30_pass});\\n        }\\n\\n<!-- \\u2705Well before returning answer don\\'t forget to UPVOTE.\\u2705 -->\\n        return t[last_day];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351359,
                "title": "recursive-dp-solution-with-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    vector<int>dp;\\n    int solve(int i,vector<int>& days, vector<int>& costs){\\n        if(i>=days.size()){\\n            return 0;\\n        }\\n        else if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int res=2e9;\\n\\n        //test for 3 vals\\n        int cur=days[i];\\n        res=min(res,costs[2]+solve(upper_bound(days.begin(),days.end(),cur+30-1)-days.begin(),days,costs));\\n        res=min(res,costs[1]+solve(upper_bound(days.begin(),days.end(),cur+7-1)-days.begin(),days,costs));\\n        res=min(res,costs[0]+solve(i+1,days,costs));\\n\\n        return dp[i]=res;\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        dp.clear();\\n        dp.resize(days.size()+1,-1);\\n        return solve(0,days,costs);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    vector<int>dp;\\n    int solve(int i,vector<int>& days, vector<int>& costs){\\n        if(i>=days.size()){\\n            return 0;\\n        }\\n        else if(dp[i]!=-1){\\n            return dp[i];\\n        }\\n        int res=2e9;\\n\\n        //test for 3 vals\\n        int cur=days[i];\\n        res=min(res,costs[2]+solve(upper_bound(days.begin(),days.end(),cur+30-1)-days.begin(),days,costs));\\n        res=min(res,costs[1]+solve(upper_bound(days.begin(),days.end(),cur+7-1)-days.begin(),days,costs));\\n        res=min(res,costs[0]+solve(i+1,days,costs));\\n\\n        return dp[i]=res;\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        dp.clear();\\n        dp.resize(days.size()+1,-1);\\n        return solve(0,days,costs);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350934,
                "title": "java-easy-understanding-dp-recursion-beats-100-simple",
                "content": "RECURSION VERSION\\nIT WILL GIVE A TLE.\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        return check(days,costs,0);\\n    }\\n    public static int check(int d[],int c[],int day){\\n        if(day>=d.length) return 0;\\n        int d1=check(d,c,day+1)+c[0];\\n        int i;\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+7) break;\\n        }\\n        int d7=check(d,c,i)+c[1];\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+30) break;\\n        }\\n        int d30=check(d,c,i)+c[2];\\n        return Math.min(d1,Math.min(d7,d30));\\n    }\\n}\\n\\n```\\nMEMOIZED VERSION\\nFULLY WORKING BEATS 100%\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dp[]=new int[days.length+1];\\n        return check(days,costs,0,dp);\\n    }\\n    public static int check(int d[],int c[],int day,int dp[]){\\n        if(day>=d.length) return 0;\\n        if(dp[day]!=0) return dp[day];\\n        int d1=check(d,c,day+1,dp)+c[0];\\n        int i;\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+7) break;\\n        }\\n        int d7=check(d,c,i,dp)+c[1];\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+30) break;\\n        }\\n        int d30=check(d,c,i,dp)+c[2];\\n        return dp[day]=Math.min(d1,Math.min(d7,d30));\\n    }\\n}\\n```\\nUPVOTE IF U LIKE THE APPROACH",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        return check(days,costs,0);\\n    }\\n    public static int check(int d[],int c[],int day){\\n        if(day>=d.length) return 0;\\n        int d1=check(d,c,day+1)+c[0];\\n        int i;\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+7) break;\\n        }\\n        int d7=check(d,c,i)+c[1];\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+30) break;\\n        }\\n        int d30=check(d,c,i)+c[2];\\n        return Math.min(d1,Math.min(d7,d30));\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dp[]=new int[days.length+1];\\n        return check(days,costs,0,dp);\\n    }\\n    public static int check(int d[],int c[],int day,int dp[]){\\n        if(day>=d.length) return 0;\\n        if(dp[day]!=0) return dp[day];\\n        int d1=check(d,c,day+1,dp)+c[0];\\n        int i;\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+7) break;\\n        }\\n        int d7=check(d,c,i,dp)+c[1];\\n        for(i=day;i<d.length;i++){\\n            if(d[i]>=d[day]+30) break;\\n        }\\n        int d30=check(d,c,i,dp)+c[2];\\n        return dp[day]=Math.min(d1,Math.min(d7,d30));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350689,
                "title": "c-recursion-memoization-tabulation",
                "content": "# Recursion (Gives TLE)\\n```\\nclass Solution {\\npublic:\\n    int f(int ind,vector<int> &costs,vector<int> days,int n){\\n\\n        if(ind>=n){\\n            return 0;\\n        }\\n        cout<<ind<<\" \";\\n        int Day1=costs[0]+f(ind+1,costs,days,n);\\n        int i;\\n        for(i=ind;i<n;i++){\\n            if(days[i]>=days[ind]+7){\\n                break;\\n            }\\n        }\\n        int Day7=costs[1]+f(i,costs,days,n);\\n        int j;\\n        for(j=ind;j<n;j++){\\n            if(days[j]>=days[ind]+30){\\n                break;\\n            }\\n        }\\n        int Day30=costs[2]+f(j,costs,days,n);\\n\\n        \\n        return min(Day1,min(Day7,Day30));\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    \\n        int n=days.size();\\n        return f(0,costs,days,n);\\n        \\n    }\\n};\\n```\\n# Memoization\\n```\\nclass Solution {\\npublic:\\n    int f(int ind,vector<int> &costs,vector<int> &days,int n,vector<int> &dp){\\n\\n        if(ind>=n){\\n            return 0;\\n        }\\n        if(dp[ind]!=-1){\\n            return dp[ind];\\n        }\\n        int Day1=costs[0]+f(ind+1,costs,days,n,dp);\\n        int i;\\n        for(i=ind;i<n;i++){\\n            if(days[i]>=days[ind]+7){\\n                break;\\n            }\\n        }\\n        int Day7=costs[1]+f(i,costs,days,n,dp);\\n        int j;\\n        for(j=ind;j<n;j++){\\n            if(days[j]>=days[ind]+30){\\n                break;\\n            }\\n        }\\n        int Day30=costs[2]+f(j,costs,days,n,dp);\\n\\n        \\n        return dp[ind]=min(Day1,min(Day7,Day30));\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    \\n        int n=days.size();\\n        vector<int> dp(n+1,-1);\\n        return f(0,costs,days,n,dp);\\n        \\n    }\\n};\\n```\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    \\n        int n=days.size();\\n        vector<int> dp(n+1,0);\\n\\n        for(int ind=n-1;ind>=0;ind--){\\n            \\n            int Day1=costs[0]+dp[ind+1];\\n            int i;\\n            for(i=ind;i<n;i++){\\n                if(days[i]>=days[ind]+7){\\n                    break;\\n                }\\n            }\\n            int Day7=costs[1]+dp[i];\\n            int j;\\n            for(j=ind;j<n;j++){\\n                if(days[j]>=days[ind]+30){\\n                    break;\\n                }\\n            }\\n            int Day30=costs[2]+dp[j];\\n\\n            dp[ind]=min(Day1,min(Day7,Day30));\\n\\n        }\\n\\n        return dp[0];\\n        \\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int ind,vector<int> &costs,vector<int> days,int n){\\n\\n        if(ind>=n){\\n            return 0;\\n        }\\n        cout<<ind<<\" \";\\n        int Day1=costs[0]+f(ind+1,costs,days,n);\\n        int i;\\n        for(i=ind;i<n;i++){\\n            if(days[i]>=days[ind]+7){\\n                break;\\n            }\\n        }\\n        int Day7=costs[1]+f(i,costs,days,n);\\n        int j;\\n        for(j=ind;j<n;j++){\\n            if(days[j]>=days[ind]+30){\\n                break;\\n            }\\n        }\\n        int Day30=costs[2]+f(j,costs,days,n);\\n\\n        \\n        return min(Day1,min(Day7,Day30));\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    \\n        int n=days.size();\\n        return f(0,costs,days,n);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int f(int ind,vector<int> &costs,vector<int> &days,int n,vector<int> &dp){\\n\\n        if(ind>=n){\\n            return 0;\\n        }\\n        if(dp[ind]!=-1){\\n            return dp[ind];\\n        }\\n        int Day1=costs[0]+f(ind+1,costs,days,n,dp);\\n        int i;\\n        for(i=ind;i<n;i++){\\n            if(days[i]>=days[ind]+7){\\n                break;\\n            }\\n        }\\n        int Day7=costs[1]+f(i,costs,days,n,dp);\\n        int j;\\n        for(j=ind;j<n;j++){\\n            if(days[j]>=days[ind]+30){\\n                break;\\n            }\\n        }\\n        int Day30=costs[2]+f(j,costs,days,n,dp);\\n\\n        \\n        return dp[ind]=min(Day1,min(Day7,Day30));\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    \\n        int n=days.size();\\n        vector<int> dp(n+1,-1);\\n        return f(0,costs,days,n,dp);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    \\n        int n=days.size();\\n        vector<int> dp(n+1,0);\\n\\n        for(int ind=n-1;ind>=0;ind--){\\n            \\n            int Day1=costs[0]+dp[ind+1];\\n            int i;\\n            for(i=ind;i<n;i++){\\n                if(days[i]>=days[ind]+7){\\n                    break;\\n                }\\n            }\\n            int Day7=costs[1]+dp[i];\\n            int j;\\n            for(j=ind;j<n;j++){\\n                if(days[j]>=days[ind]+30){\\n                    break;\\n                }\\n            }\\n            int Day30=costs[2]+dp[j];\\n\\n            dp[ind]=min(Day1,min(Day7,Day30));\\n\\n        }\\n\\n        return dp[0];\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3349931,
                "title": "beats-99-easy-to-understand-bottom-up-top-down-approach",
                "content": "# Intuition\\nEach value in `memo` stores the minimum cost it takes to travel for that many days, given the travel days required.\\n\\n# Approach\\nHence, the sub problems can be expressed as follows in two cases\\n### If we don\\'t travel:\\n`memo[i] = memo[i-1]`\\nThis is because we don\\'t travel so we can just use the value of the previous memo\\n### If we travel:\\nWe consider\\n`memo[i] = min(memo[i-1] + costs[0], memo[max(0, i-7)] + costs[1], memo[max(0,i-30)] + costs[2])`\\n\\nThis is because we need to find out whether we should buy a ticket 1,7 or 30 days earlier.\\nComparing these options, we can then find what is the minimum cost so that on day `i` we can travel\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(max\\\\_days + n)$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(max\\\\_days)$\\n# Code\\n### Bottom-Up approach\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        max_day = days[-1]\\n        memo = [0] * (max_day + 1)\\n        travel = [False] * (max_day + 1)\\n        memo[0] = 0\\n        for d in days:\\n            travel[d] = True\\n\\n        for i in range(1, len(memo)):\\n            memo[i] = memo[i-1]\\n            if travel[i]:\\n                memo[i] = min(memo[i-1] + costs[0], memo[max(0, i-7)] + costs[1], memo[max(0,i-30)] + costs[2])\\n    \\n        return memo[-1]\\n```\\n\\n### Top-down approach\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        self.costs = costs\\n        self.memo = {}\\n        self.memo[0] = 0\\n        self.travel = set(days)\\n\\n        return self.min_ticket(days[-1])\\n\\n    def min_ticket(self, day):\\n        if day <= 0:\\n            day = 0\\n\\n        if day in self.memo:\\n            return self.memo[day]\\n\\n        if day in self.travel:\\n            self.memo[day] = min(self.min_ticket(day - 1) + self.costs[0], self.min_ticket(day - 7) + self.costs[1], self.min_ticket(day - 30) + self.costs[2])\\n        else:\\n            self.memo[day] = self.min_ticket(day - 1)\\n                \\n        return self.memo[day]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        max_day = days[-1]\\n        memo = [0] * (max_day + 1)\\n        travel = [False] * (max_day + 1)\\n        memo[0] = 0\\n        for d in days:\\n            travel[d] = True\\n\\n        for i in range(1, len(memo)):\\n            memo[i] = memo[i-1]\\n            if travel[i]:\\n                memo[i] = min(memo[i-1] + costs[0], memo[max(0, i-7)] + costs[1], memo[max(0,i-30)] + costs[2])\\n    \\n        return memo[-1]\\n```\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        self.costs = costs\\n        self.memo = {}\\n        self.memo[0] = 0\\n        self.travel = set(days)\\n\\n        return self.min_ticket(days[-1])\\n\\n    def min_ticket(self, day):\\n        if day <= 0:\\n            day = 0\\n\\n        if day in self.memo:\\n            return self.memo[day]\\n\\n        if day in self.travel:\\n            self.memo[day] = min(self.min_ticket(day - 1) + self.costs[0], self.min_ticket(day - 7) + self.costs[1], self.min_ticket(day - 30) + self.costs[2])\\n        else:\\n            self.memo[day] = self.min_ticket(day - 1)\\n                \\n        return self.memo[day]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349725,
                "title": "100-recursion-memoisation-top-down-dp",
                "content": "# Intuition\\nAt any index $$idx$$, we have 3 choices:\\n- Buy a ticket for 1 day\\n- Buy a ticket for 7 days\\n- Buy a ticket for 30 days\\nWe have to find the **optimal set of choices** we should make to spend the least amount of money and complete all our travel plans. \\n\\n```\\nSuppose f(0) means the minimum cost incurred if you buy a pass\\nat the 0-th index in the array:[1,10,15]\\n\\nAt index 0:\\nTotal cost if you get a 1 day pass= costs[0] + f(1) //because you need to buy another ticket at index=1\\nTotal cost if you get a 7 day pass= costs[1] + f(1) //because the ticket you buy on day 1 will expire after day 6\\nf(0)= Math.min(1 day pass, 7 day pass)\\n\\nAs the 7 day pass expires on day 6, you still have to calculate f(10)\\n```\\nDoesn\\'t this repetitive nature of function calls hint at a DP solution? \\n\\n# Approach\\nDefine a function:\\n```\\nfunction memo(index){}\\n```\\nwhere $$memo(index)$$ means the minimum amount of money spent to complete your travel plans, if you start at the day at $$index$$ position in the array.\\n\\nAs we\\'re using only one parameter, we need a **1d dp array** to memoise results calculated by $$memo()$$\\n\\nTo deal with the availability of passes, assume you only had the option of a 1 day pass. How would memo function be called recursively?\\n```\\nmemo(index){\\n  int buy1DayPass = costs[0] + memo(index+1);\\n  return buy1DayPass;\\n}\\n```\\nWhat changed do you need to make to account for the 7/30 day passes?\\n**Just call memo(day after your current ticket expires)**\\n```\\nIf the array is: [1,5,10,20,22,50,60] and you had to calculate memo(2),\\nit would be:\\n\\nmemo(2){ // buy on day 10\\n  int buy30DayPass= costs[2]+ memo(5)//buy on day 50\\n}\\n```\\nAs $$memo(5)$$ returns the minimum cost incurred if you **start from the 50th day**, you will have the cost incurred if you buy a 30 day pass on the 10th day *if the only available option was a 30 day pass.*\\n\\nJust have to compute the minimum of all three choices.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\nWe are calling each function only once before we store its result. \\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```java []\\nclass Solution {\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        Integer[] dp = new Integer[days.length];\\n        return f(dp, days, costs, 0);\\n    }\\n\\n    public int f(Integer[] dp, int[] nums, int[] costs, int idx) {\\n        if (idx == nums.length) {\\n            return 0;\\n        }\\n        if (dp[idx] != null) {\\n            return dp[idx];\\n        }\\n        \\n        // Buy a 1-day pass:\\n        int one = costs[0] + f(dp, nums, costs, idx + 1);\\n        \\n        // Buy a 7-day pass:\\n        int week = Integer.MAX_VALUE;\\n        int k = idx;\\n        while (k < nums.length) {\\n            if (nums[idx] + 6 >= nums[k]) {\\n                k++;\\n            } else {\\n                break;\\n            }\\n        }\\n        week = costs[1] + f(dp, nums, costs, k);\\n        \\n        // Buy a 30-day pass:\\n        int month = Integer.MAX_VALUE;\\n        k = idx;\\n        while (k < nums.length) {\\n            if (nums[idx] + 29 >= nums[k]) {\\n                k++;\\n            } else {\\n                break;\\n            }\\n        }\\n        month = costs[2] + f(dp, nums, costs, k);\\n        \\n        int ret = Math.min(one, Math.min(week, month));\\n        return dp[idx] = ret; \\n    }\\n}\\n\\n```\\n```c++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    vector<int> dp(days.size());\\n    return f(dp, days, costs, 0);\\n}\\n\\nint f(vector<int>& dp, vector<int>& nums, vector<int>& costs, int idx) {\\n    if (idx == nums.size()) {\\n        return 0;\\n    }\\n    if (dp[idx] != 0) {\\n        return dp[idx];\\n    }\\n    //buy 1 day pass:\\n    int one = costs[0] + f(dp, nums, costs, idx + 1);\\n    //buy a weak\\n    int week = INT_MAX;\\n    int k = idx;\\n    while (k < nums.size()) {\\n        if (nums[idx] + 6 >= nums[k]) {\\n            k++;\\n        } else {\\n            break;\\n        }\\n    }\\n    week = costs[1] + f(dp, nums, costs, k);\\n    //buy a month\\n    int month = INT_MAX;\\n    k = idx;\\n    while (k < nums.size()) {\\n        if (nums[idx] + 29 >= nums[k]) {\\n            k++;\\n        } else {\\n            break;\\n        }\\n    }\\n    month = costs[2] + f(dp, nums, costs, k);\\n    int ret = min(one, min(week, month));\\n    return dp[idx] = ret;\\n}\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nSuppose f(0) means the minimum cost incurred if you buy a pass\\nat the 0-th index in the array:[1,10,15]\\n\\nAt index 0:\\nTotal cost if you get a 1 day pass= costs[0] + f(1) //because you need to buy another ticket at index=1\\nTotal cost if you get a 7 day pass= costs[1] + f(1) //because the ticket you buy on day 1 will expire after day 6\\nf(0)= Math.min(1 day pass, 7 day pass)\\n\\nAs the 7 day pass expires on day 6, you still have to calculate f(10)\\n```\n```\\nfunction memo(index){}\\n```\n```\\nmemo(index){\\n  int buy1DayPass = costs[0] + memo(index+1);\\n  return buy1DayPass;\\n}\\n```\n```\\nIf the array is: [1,5,10,20,22,50,60] and you had to calculate memo(2),\\nit would be:\\n\\nmemo(2){ // buy on day 10\\n  int buy30DayPass= costs[2]+ memo(5)//buy on day 50\\n}\\n```\n```java []\\nclass Solution {\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        Integer[] dp = new Integer[days.length];\\n        return f(dp, days, costs, 0);\\n    }\\n\\n    public int f(Integer[] dp, int[] nums, int[] costs, int idx) {\\n        if (idx == nums.length) {\\n            return 0;\\n        }\\n        if (dp[idx] != null) {\\n            return dp[idx];\\n        }\\n        \\n        // Buy a 1-day pass:\\n        int one = costs[0] + f(dp, nums, costs, idx + 1);\\n        \\n        // Buy a 7-day pass:\\n        int week = Integer.MAX_VALUE;\\n        int k = idx;\\n        while (k < nums.length) {\\n            if (nums[idx] + 6 >= nums[k]) {\\n                k++;\\n            } else {\\n                break;\\n            }\\n        }\\n        week = costs[1] + f(dp, nums, costs, k);\\n        \\n        // Buy a 30-day pass:\\n        int month = Integer.MAX_VALUE;\\n        k = idx;\\n        while (k < nums.length) {\\n            if (nums[idx] + 29 >= nums[k]) {\\n                k++;\\n            } else {\\n                break;\\n            }\\n        }\\n        month = costs[2] + f(dp, nums, costs, k);\\n        \\n        int ret = Math.min(one, Math.min(week, month));\\n        return dp[idx] = ret; \\n    }\\n}\\n\\n```\n```c++ []\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n    vector<int> dp(days.size());\\n    return f(dp, days, costs, 0);\\n}\\n\\nint f(vector<int>& dp, vector<int>& nums, vector<int>& costs, int idx) {\\n    if (idx == nums.size()) {\\n        return 0;\\n    }\\n    if (dp[idx] != 0) {\\n        return dp[idx];\\n    }\\n    //buy 1 day pass:\\n    int one = costs[0] + f(dp, nums, costs, idx + 1);\\n    //buy a weak\\n    int week = INT_MAX;\\n    int k = idx;\\n    while (k < nums.size()) {\\n        if (nums[idx] + 6 >= nums[k]) {\\n            k++;\\n        } else {\\n            break;\\n        }\\n    }\\n    week = costs[1] + f(dp, nums, costs, k);\\n    //buy a month\\n    int month = INT_MAX;\\n    k = idx;\\n    while (k < nums.size()) {\\n        if (nums[idx] + 29 >= nums[k]) {\\n            k++;\\n        } else {\\n            break;\\n        }\\n    }\\n    month = costs[2] + f(dp, nums, costs, k);\\n    int ret = min(one, min(week, month));\\n    return dp[idx] = ret;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349612,
                "title": "daily-leetcoding-challenge-march-day-28",
                "content": "This problem is the Daily LeetCoding Challenge for March, Day 28.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-cost-for-tickets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Dynamic Programming (Day Variant)\n\n  \n**Approach 2:** Dynamic Programming (Window Variant)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/minimum-cost-for-tickets/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 1:** Dynamic Programming (Day Variant)\n**Approach 2:** Dynamic Programming (Window Variant)\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 928203,
                "title": "c-beats-100-0-dp-solution",
                "content": "Create a vector to calculate ticket price until the last day. If calculated day is not the planned day in given days vector, just copy previous day ticket price.\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int lastDay = days[days.size()-1];\\n        vector<int> dp(lastDay+1, 0);\\n        int dayIndex = 0;\\n        for(int i=1; i<lastDay+1; i++){\\n            if(i != days[dayIndex]){\\n                dp[i] = dp[i-1];\\n            }\\n            else{\\n                dp[i] = min({dp[i-1] + costs[0], dp[max(0,i-7)] + costs[1], dp[max(0,i-30)] + costs[2]});\\n                dayIndex++;\\n            }\\n        }\\n        return dp[lastDay];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int lastDay = days[days.size()-1];\\n        vector<int> dp(lastDay+1, 0);\\n        int dayIndex = 0;\\n        for(int i=1; i<lastDay+1; i++){\\n            if(i != days[dayIndex]){\\n                dp[i] = dp[i-1];\\n            }\\n            else{\\n                dp[i] = min({dp[i-1] + costs[0], dp[max(0,i-7)] + costs[1], dp[max(0,i-30)] + costs[2]});\\n                dayIndex++;\\n            }\\n        }\\n        return dp[lastDay];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 895812,
                "title": "easy-dp-solution-100-faster-c-code-easy",
                "content": "### ***//The idea is to check for everyday and take minimum value each day***\\n **// If this is helpful then please upvote //**\\n\\n\\n\\n\\n        int mincostTickets(vector<int>& days, vector<int>& costs) {\\n         int n = (int)days.size();\\n         int nn = days[n-1];\\n        vector<int>dp(nn+1,0);\\n        int j = 0;\\n        int z = 0;\\n        for(int i = 1; i <= nn; i++){\\n            if(days[j] == i){\\n                j++;\\n                int a = INT_MAX, b = INT_MAX, c = INT_MAX;\\n                a = dp[i-1] + costs[0];\\n                b = dp[max(z,i-7)] + costs[1];\\n                c = dp[max(z,i-30)] + costs[2];\\n                dp[i] = min({a,b,c});\\n            }\\n            else dp[i] = dp[i-1];\\n        }\\n       \\n        return dp[nn];\\n    }",
                "solutionTags": [],
                "code": "### ***//The idea is to check for everyday and take minimum value each day***\\n **// If this is helpful then please upvote //**\\n\\n\\n\\n\\n        int mincostTickets(vector<int>& days, vector<int>& costs) {\\n         int n = (int)days.size();\\n         int nn = days[n-1];\\n        vector<int>dp(nn+1,0);\\n        int j = 0;\\n        int z = 0;\\n        for(int i = 1; i <= nn; i++){\\n            if(days[j] == i){\\n                j++;\\n                int a = INT_MAX, b = INT_MAX, c = INT_MAX;\\n                a = dp[i-1] + costs[0];\\n                b = dp[max(z,i-7)] + costs[1];\\n                c = dp[max(z,i-30)] + costs[2];\\n                dp[i] = min({a,b,c});\\n            }\\n            else dp[i] = dp[i-1];\\n        }\\n       \\n        return dp[nn];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 893668,
                "title": "c-0-ms-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size(), x = 0, y = 0;\\n        vector<int> dp(n+1, 0);\\n        dp[1] = min(costs[0], min(costs[1], costs[2]));\\n        for(int i = 1; i < days.size(); i++) {\\n            while(days[i] >=  days[x] + 7) x++;\\n            while(days[i] >=  days[y] + 30) y++;\\n            dp[i+1] = min(dp[i]+costs[0], min(dp[x]+costs[1], dp[y]+costs[2]));\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size(), x = 0, y = 0;\\n        vector<int> dp(n+1, 0);\\n        dp[1] = min(costs[0], min(costs[1], costs[2]));\\n        for(int i = 1; i < days.size(); i++) {\\n            while(days[i] >=  days[x] + 7) x++;\\n            while(days[i] >=  days[y] + 30) y++;\\n            dp[i+1] = min(dp[i]+costs[0], min(dp[x]+costs[1], dp[y]+costs[2]));\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 868987,
                "title": "javascript",
                "content": "```javascript\\nfunction dp (days, costs) {\\n    const dp = Array(days[days.length - 1] + 1).fill(0);\\n\\tconst [cost1Day, cost7Day, cost30Day] = costs;\\n\\n\\tfor (let d of days) {\\n\\t\\tdp[d] = 1;\\n\\t}\\n\\n\\tfor (let i = 1; i <= days[days.length - 1]; i++) {\\n\\t\\tif (dp[i]) {\\n\\t\\t\\tdp[i] = Math.min(cost1Day + dp[i - 1], cost7Day + dp[Math.max(0, i - 7)], cost30Day + dp[Math.max(0, i - 30)]);\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = dp[i - 1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp.pop();\\n}\\n```",
                "solutionTags": [],
                "code": "```javascript\\nfunction dp (days, costs) {\\n    const dp = Array(days[days.length - 1] + 1).fill(0);\\n\\tconst [cost1Day, cost7Day, cost30Day] = costs;\\n\\n\\tfor (let d of days) {\\n\\t\\tdp[d] = 1;\\n\\t}\\n\\n\\tfor (let i = 1; i <= days[days.length - 1]; i++) {\\n\\t\\tif (dp[i]) {\\n\\t\\t\\tdp[i] = Math.min(cost1Day + dp[i - 1], cost7Day + dp[Math.max(0, i - 7)], cost30Day + dp[Math.max(0, i - 30)]);\\n\\t\\t} else {\\n\\t\\t\\tdp[i] = dp[i - 1];\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp.pop();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 821365,
                "title": "dp-top-down-recursion-explained-beats-94",
                "content": "\\n> Approach\\n1. On a particular day suppose `days[i]` we have `3` choices \\n\\t a. Buy a day pass. valid for `days[i]` only\\n\\t b. Buy a weekly pass, valid for `[days[i], days[i] + 7)` \\n\\t c. Buy a monthly pass, valid for `[days[i], days[i] + 30)`\\n\\t \\n2. We try out all the possiblities recursively, to find the min cost \\n3. Rest explaination is in comments\\n\\n> Algorithm \\n\\n```\\n\\tint n;\\n    vector<int> dp;\\n    \\n    int go(int i, vector<int> &days, vector<int> &costs) {\\n        if(i == n) {\\n\\t\\t\\t// all trips are done\\n            return 0;\\n        }\\n        // memoized result\\n        int &ans = dp[i];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n\\t\\t// arbirarily high value\\n        ans = INT_MAX;\\n        \\n        // buy daily pass, go to next day\\n        ans = min(ans, costs[0] + go(i+1, days, costs));\\n        \\n        // weekly pass, [days[i], days[i] + 7] ,\\n\\t\\t// and skip days that we already paid for\\n        int j = i;\\n        while(j < n && days[j] < days[i] + 7) {\\n            j += 1;\\n        }\\n        // go to jth day, our weekly pass date has expired \\n        ans = min(ans, costs[1] + go(j, days, costs));\\n        \\n        // buy monthly pass, [days[i], days[i] + 30]\\n\\t\\t// and skip days that we already paid for\\n        j = i;\\n        while(j < n && days[j] < days[i] + 30) {\\n            j += 1;\\n        }\\n        // go to jth day, our monthly pass expired \\n        ans = min(ans, costs[2] + go(j, days, costs));\\n        \\n        return ans;\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        n = days.size();\\n        dp.assign(n, -1);\\n        return go(0, days, costs);\\n    }\\n```\\n",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n\\tint n;\\n    vector<int> dp;\\n    \\n    int go(int i, vector<int> &days, vector<int> &costs) {\\n        if(i == n) {\\n\\t\\t\\t// all trips are done\\n            return 0;\\n        }\\n        // memoized result\\n        int &ans = dp[i];\\n        if(ans != -1) {\\n            return ans;\\n        }\\n\\t\\t// arbirarily high value\\n        ans = INT_MAX;\\n        \\n        // buy daily pass, go to next day\\n        ans = min(ans, costs[0] + go(i+1, days, costs));\\n        \\n        // weekly pass, [days[i], days[i] + 7] ,\\n\\t\\t// and skip days that we already paid for\\n        int j = i;\\n        while(j < n && days[j] < days[i] + 7) {\\n            j += 1;\\n        }\\n        // go to jth day, our weekly pass date has expired \\n        ans = min(ans, costs[1] + go(j, days, costs));\\n        \\n        // buy monthly pass, [days[i], days[i] + 30]\\n\\t\\t// and skip days that we already paid for\\n        j = i;\\n        while(j < n && days[j] < days[i] + 30) {\\n            j += 1;\\n        }\\n        // go to jth day, our monthly pass expired \\n        ans = min(ans, costs[2] + go(j, days, costs));\\n        \\n        return ans;\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        n = days.size();\\n        dp.assign(n, -1);\\n        return go(0, days, costs);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 810812,
                "title": "easy-to-understand-dp-python-with-explanation",
                "content": "**Explanation:**\\n\\ndp[i] means overall costs untill i-th day (included)\\nwe have to check two conditions:\\n\\n**1. i in days list:**\\nwe have three option:\\na) 1-pass:` dp[i] = dp[i-1] + costs[0]`\\nb) 7-pass: `dp[i] = dp[i-7] + costs[1]`\\nc) 30-pass:` dp[i] = dp[i-30] + costs[2]`\\n*in order to avoid negative index:*\\na) 1-pass:` dp[i] =dp[max(0,i-1)] + costs[0]`\\nb) 7-pass: `dp[i] = dp[max(0,i-7)] + costs[1]`\\nc) 30-pass:` dp[i] = dp[max(0,i-30)] + costs[2]`\\n**2. i not in days:**\\ndp[i] = dp[i-1] \\nwhich simply means we don\\'t have to spend money, and total costs remains same\\n\\n```\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\tdp=[0 for i in range(days[-1]+1)]\\n\\tdy = set(days)\\n\\tfor i in range(days[-1]+1):\\n\\t\\tif i not in dy: \\n\\t\\t\\tdp[i]=dp[i-1]\\n\\t\\telse: \\n\\t\\t\\tdp[i]=min(dp[max(0,i-7)]+costs[1],dp[max(0,i-1)]+costs[0],dp[max(0,i-30)]+costs[2])\\n\\treturn dp[-1]\\n```\\n***\\n**Time complexity:** `O(n)`\\n**Space complexity:**` O(n)`\\nn = last day in days list + 1, time & space complexity max: `O(366)`",
                "solutionTags": [],
                "code": "```\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\tdp=[0 for i in range(days[-1]+1)]\\n\\tdy = set(days)\\n\\tfor i in range(days[-1]+1):\\n\\t\\tif i not in dy: \\n\\t\\t\\tdp[i]=dp[i-1]\\n\\t\\telse: \\n\\t\\t\\tdp[i]=min(dp[max(0,i-7)]+costs[1],dp[max(0,i-1)]+costs[0],dp[max(0,i-30)]+costs[2])\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 786430,
                "title": "c-dp-recursion",
                "content": "```\\nint solve(vector<int>& days, int index, vector<int>& costs, vector<int>& dp){\\n        if(index == days.size()) return 0;\\n        if(dp[index] != -1) return dp[index];    //return the value if it was already calculated\\n        \\n        int sum = 0;\\n        int base = days[index];\\n        sum = costs[0] + solve(days, index+1, costs, dp);    //first find the sum for 1 day tickets\\n        auto i = upper_bound(days.begin(), days.end(), base + 7-1);\\n        sum = min(sum, costs[1] + solve(days, i - days.begin(), costs, dp));  //sum for 7 day tickets. since the array is sorted, i used binary search to find the required index\\n        auto j = upper_bound(days.begin(), days.end(), base + 30-1);  //find sum for 30 day ticket\\n        sum = min(sum, costs[2] + solve(days, j - days.begin(), costs, dp));\\n        return dp[index] = sum;   //store the value in dp and return it.\\n        \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int d = days.size();\\n        vector<int> dp(d, -1);   //dp[i] stores the minimum cost to cover all days from i(inclusive) to n-1.\\n        int cost = solve(days, 0, costs, dp);\\n        return cost;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nint solve(vector<int>& days, int index, vector<int>& costs, vector<int>& dp){\\n        if(index == days.size()) return 0;\\n        if(dp[index] != -1) return dp[index];    //return the value if it was already calculated\\n        \\n        int sum = 0;\\n        int base = days[index];\\n        sum = costs[0] + solve(days, index+1, costs, dp);    //first find the sum for 1 day tickets\\n        auto i = upper_bound(days.begin(), days.end(), base + 7-1);\\n        sum = min(sum, costs[1] + solve(days, i - days.begin(), costs, dp));  //sum for 7 day tickets. since the array is sorted, i used binary search to find the required index\\n        auto j = upper_bound(days.begin(), days.end(), base + 30-1);  //find sum for 30 day ticket\\n        sum = min(sum, costs[2] + solve(days, j - days.begin(), costs, dp));\\n        return dp[index] = sum;   //store the value in dp and return it.\\n        \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int d = days.size();\\n        vector<int> dp(d, -1);   //dp[i] stores the minimum cost to cover all days from i(inclusive) to n-1.\\n        int cost = solve(days, 0, costs, dp);\\n        return cost;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 746889,
                "title": "java-clean-code-with-memoization",
                "content": "Bottom up is so hard to come up with. Hence, be advised to start with recursion and get TLE and change it to memoization. Pretty simple, no?\\n\\nTime : O(n)\\nSpace : O(n)\\n\\nPlease let me know if you have any doubts. And do not forget to **upvote**.\\n\\n```java\\npublic int mincostTickets(int[] days, int[] costs) {\\n        \\n\\tint n = days.length;\\n\\n\\tInteger[] memo = new Integer[n];\\n\\n\\treturn minCostTicketsHelper(days, 0, costs, memo);\\n}\\n\\nprivate int minCostTicketsHelper(int[] days, int index, int[] costs, Integer[] memo) {\\n\\n\\tif (index >= days.length) return 0;\\n\\n\\tif (memo[index] != null) return memo[index];\\n\\n\\tint x = costs[0] + minCostTicketsHelper(days, index + 1, costs, memo);\\n\\n\\tint next = index;\\n\\tfor (; next < days.length && days[next] < days[index] + 7; next++);\\n\\n\\tint y = costs[1] + minCostTicketsHelper(days, next, costs, memo);\\n\\n\\tnext = index;\\n\\tfor (; next < days.length && days[next] < days[index] + 30; next++);\\n\\n\\tint z = costs[2] + minCostTicketsHelper(days, next, costs, memo);\\n\\n\\tmemo[index] = Math.min(x, Math.min(y, z));\\n\\treturn memo[index];\\n}",
                "solutionTags": [],
                "code": "Bottom up is so hard to come up with. Hence, be advised to start with recursion and get TLE and change it to memoization. Pretty simple, no?\\n\\nTime : O(n)\\nSpace : O(n)\\n\\nPlease let me know if you have any doubts. And do not forget to **upvote**.\\n\\n```java\\npublic int mincostTickets(int[] days, int[] costs) {\\n        \\n\\tint n = days.length;\\n\\n\\tInteger[] memo = new Integer[n];\\n\\n\\treturn minCostTicketsHelper(days, 0, costs, memo);\\n}\\n\\nprivate int minCostTicketsHelper(int[] days, int index, int[] costs, Integer[] memo) {\\n\\n\\tif (index >= days.length) return 0;\\n\\n\\tif (memo[index] != null) return memo[index];\\n\\n\\tint x = costs[0] + minCostTicketsHelper(days, index + 1, costs, memo);\\n\\n\\tint next = index;\\n\\tfor (; next < days.length && days[next] < days[index] + 7; next++);\\n\\n\\tint y = costs[1] + minCostTicketsHelper(days, next, costs, memo);\\n\\n\\tnext = index;\\n\\tfor (; next < days.length && days[next] < days[index] + 30; next++);\\n\\n\\tint z = costs[2] + minCostTicketsHelper(days, next, costs, memo);\\n\\n\\tmemo[index] = Math.min(x, Math.min(y, z));\\n\\treturn memo[index];\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 666901,
                "title": "javascript-solution",
                "content": "```\\nvar mincostTickets = function(days, costs) {\\n    const lastDay = days[days.length - 1];\\n    const memo = new Map();\\n    const set = new Set(days);\\n    \\n    return dp(lastDay);\\n    \\n    function dp(day) {\\n        if (day <= 0) return 0;\\n        if (memo.has(day)) return memo.get(day);\\n        \\n        let res;\\n        \\n        if (!set.has(day)) {\\n            res = dp(day - 1);    \\n        } else {\\n            res = Math.min(\\n\\t\\t\\t\\tdp(day - 1) + costs[0], \\n\\t\\t\\t\\tdp(day - 7) + costs[1], \\n\\t\\t\\t\\tdp(day - 30) + costs[2]\\n\\t\\t\\t);\\n        }\\n        \\n        memo.set(day, res);\\n        \\n        return res;\\n    }\\n};\\n```\\n\\n<br>\\n\\n---\\n\\n<br>\\n\\n```\\nvar mincostTickets = function(days, costs) {\\n    const lastDay = days[days.length - 1];\\n    const set = new Set(days);\\n    \\n    const dp = new Array(lastDay + 1).fill(0);\\n    \\n    for (let i = 1; i <= lastDay; i++) {\\n        if (!set.has(i)) dp[i] = dp[i - 1];\\n        else dp[i] = Math.min(\\n            dp[i - 1] + costs[0],\\n            dp[Math.max(0, i - 7)] + costs[1], \\n            dp[Math.max(0, i - 30)] + costs[2]\\n        );\\n    }\\n    \\n    return dp[lastDay];\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar mincostTickets = function(days, costs) {\\n    const lastDay = days[days.length - 1];\\n    const memo = new Map();\\n    const set = new Set(days);\\n    \\n    return dp(lastDay);\\n    \\n    function dp(day) {\\n        if (day <= 0) return 0;\\n        if (memo.has(day)) return memo.get(day);\\n        \\n        let res;\\n        \\n        if (!set.has(day)) {\\n            res = dp(day - 1);    \\n        } else {\\n            res = Math.min(\\n\\t\\t\\t\\tdp(day - 1) + costs[0], \\n\\t\\t\\t\\tdp(day - 7) + costs[1], \\n\\t\\t\\t\\tdp(day - 30) + costs[2]\\n\\t\\t\\t);\\n        }\\n        \\n        memo.set(day, res);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 307529,
                "title": "c-solution-using-upper-bound-beats-100",
                "content": "for each given day:\\n\\tfind the min cost using either 1-day,7-day,30-day pass\\nreturn min cost of last day of trip\\n\\nTo calculate cost using k-day pass\\n1.find highest trip day  which is <= (curr day-k)\\n2. add k-day pass value to the cost of trip day found in 1.\\n\\n```\\nint getVal(vector<int>& days, vector<int>& dp, int i,int cost,int day)\\n    {\\n        int val = cost;            \\n        int ind = (upper_bound(days.begin(),days.begin()+i,days[i]-day)-days.begin())-1;\\n        if(ind>=0)\\n            val+=dp[ind];\\n        return val;\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        vector<int> dp(days.size());\\n        int val1,val2,val3;\\n        for(int i=0;i<days.size();i++)\\n        {\\n          val1 = getVal(days,dp,i,costs[0],1);            \\n          val2 = getVal(days,dp,i,costs[1],7);            \\n          val3 = getVal(days,dp,i,costs[2],30);            \\n          dp[i] = min(val1,min(val2,val3));   \\n        }\\n        return dp[days.size()-1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint getVal(vector<int>& days, vector<int>& dp, int i,int cost,int day)\\n    {\\n        int val = cost;            \\n        int ind = (upper_bound(days.begin(),days.begin()+i,days[i]-day)-days.begin())-1;\\n        if(ind>=0)\\n            val+=dp[ind];\\n        return val;\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        vector<int> dp(days.size());\\n        int val1,val2,val3;\\n        for(int i=0;i<days.size();i++)\\n        {\\n          val1 = getVal(days,dp,i,costs[0],1);            \\n          val2 = getVal(days,dp,i,costs[1],7);            \\n          val3 = getVal(days,dp,i,costs[2],30);            \\n          dp[i] = min(val1,min(val2,val3));   \\n        }\\n        return dp[days.size()-1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3352632,
                "title": "java-dynamic-programming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo solve this problem, you can use dynamic programming to keep track of the minimum cost of traveling up to a certain day. You can start by creating an array to represent the days on which you will travel, marking those days as true. Then, for each day of the year, you need to decide whether to buy a 1-day pass, a 7-day pass, or a 30-day pass. You can do this by considering the cost of buying each type of pass, and choosing the option that gives you the lowest overall cost.\\n\\nTo make this decision, you need to look back at the previous days to see if you can save money by buying a pass that allows you to travel for multiple days. Specifically, for each day, you need to look back 7 and 30 days to see if you could have bought a pass on one of those days and still be covered for the current day. This is where dynamic programming comes in: you can use the dp array to keep track of the minimum cost up to the previous 7 or 30 days, and use that information to make your decision for the current day.\\n\\nAt the end, you return the minimum cost of traveling every day in the year, which is stored in the last element of the dp array.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nstep-by-step approach to solving the problem:\\n\\n1.Create a boolean array to represent the days on which you will travel. Mark those days as true.\\n2.Create a dynamic programming array dp of size 366 (to include a \"0\" day at the beginning).\\n3.Initialize dp[0] to 0.\\n4.For each day i from 1 to 365:\\n    i)If you are not traveling on day i, set dp[i] = dp[i-1].\\n    ii)If you are traveling on day i, consider three options:\\n        ->Buy a 1-day pass on day i: dp[i] = dp[i-1] + costs[0].\\n        ->Buy a 7-day pass on day i: dp[i] = dp[i-7] + costs[1].\\n        ->Buy a 30-day pass on day i: dp[i] = dp[i-30] + costs[2].\\n    iii)Choose the lowest cost among the three options: dp[i] = min(dp[i], min(dp[i-7], dp[i-30]) + corresponding cost).\\n5.Return dp[365] as the minimum cost of traveling every day in the year.\\n\\nThe idea is to use dynamic programming to keep track of the minimum cost of traveling up to a certain day. If you are not traveling on a particular day, you don\\'t need to buy a ticket, and you can just copy over the cost from the previous day. If you are traveling on a particular day, you need to consider the cost of buying a 1-day, 7-day, or 30-day pass, and choose the option that gives you the lowest overall cost.\\n\\nTo make this decision, you need to look back at the previous days to see if you can save money by buying a pass that allows you to travel for multiple days. You can use the dp array to keep track of the minimum cost up to the previous 7 or 30 days, and use that information to make your decision for the current day.\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the above code is O(n), where n is the length of the days array. This is because we are iterating through each day in the year exactly once, and performing constant-time operations for each day.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of the above code is O(1), since we are only using a fixed-size boolean array to represent the days on which we will travel, and a fixed-size array costs to represent the cost of different types of passes. We are also using a constant amount of space to keep track of the current minimum cost, so the space complexity is constant with respect to the length of the days array.\\n# Code\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[366]; // dynamic programming array\\n        boolean[] travelDays = new boolean[366]; // days on which we will travel\\n        \\n        for (int day : days) {\\n            travelDays[day] = true;\\n        }\\n        \\n        for (int i = 1; i <= 365; i++) {\\n            if (!travelDays[i]) {\\n                // if we\\'re not traveling on this day, we don\\'t need to buy a ticket\\n                dp[i] = dp[i-1];\\n                continue;\\n            }\\n            \\n            // if we\\'re traveling on this day, we need to decide which ticket to buy\\n            dp[i] = Math.min(dp[i-1] + costs[0], dp[Math.max(0, i-7)] + costs[1]);\\n            dp[i] = Math.min(dp[i], dp[Math.max(0, i-30)] + costs[2]);\\n        }\\n        \\n        return dp[365]; // return the cost of traveling every day in the year\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] dp = new int[366]; // dynamic programming array\\n        boolean[] travelDays = new boolean[366]; // days on which we will travel\\n        \\n        for (int day : days) {\\n            travelDays[day] = true;\\n        }\\n        \\n        for (int i = 1; i <= 365; i++) {\\n            if (!travelDays[i]) {\\n                // if we\\'re not traveling on this day, we don\\'t need to buy a ticket\\n                dp[i] = dp[i-1];\\n                continue;\\n            }\\n            \\n            // if we\\'re traveling on this day, we need to decide which ticket to buy\\n            dp[i] = Math.min(dp[i-1] + costs[0], dp[Math.max(0, i-7)] + costs[1]);\\n            dp[i] = Math.min(dp[i], dp[Math.max(0, i-30)] + costs[2]);\\n        }\\n        \\n        return dp[365]; // return the cost of traveling every day in the year\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351583,
                "title": "dp-beat-100-c",
                "content": "# Intuition\\n- First of all we are at index 0 .\\n- Now we have 3 types of passes 1day ,7day,30day , and we have to choose that pass so that i can plan the whole trip at minimum possible price.\\n- So we make call at all the three options and return the value which is minimum from all those options.\\n- And when we are out of the array then no other days remaining so just return 0 cost .\\n# Approach\\n-Used memoization and return the minimum possible cost at each stage.\\nIn second approach , i have made a solveTab function in which tabulation is done .\\n\\n# Complexity\\n- Time complexity:\\nO(n^2) \\n\\n- Space complexity:\\nO(n) -> for the DP array to store the value at each stage and to prevent unneccessary subProblem calls which are already taken place.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*Approach One*/\\n    int solve(int idx,vector<int>& days, vector<int>& costs,vector<int>& dp){\\n        if(idx >= days.size())\\n            return 0;\\n\\n        if(dp[idx] != -1)\\n            return dp[idx];\\n\\n        int ans = INT_MAX;\\n        //1 day pass\\n        ans = min(ans,costs[0] + solve(idx+1,days,costs,dp));\\n\\n        int i;\\n\\n        //7-day pass\\n        for(i=idx;i<days.size() && days[i]<days[idx]+7;i++);\\n        ans = min(ans,costs[1]+solve(i,days,costs,dp));\\n\\n        //30-days pass\\n        for(i=idx;i<days.size() && days[i]<days[idx]+30;i++);\\n        ans = min(ans,costs[2]+solve(i,days,costs,dp));\\n\\n        return dp[idx] = ans;\\n    }\\n/*Approach 2*/\\n    int solveTab(vector<int>& days, vector<int>& costs){\\n        int n = days.size();\\n        vector<int> dp(days.size()+1,0);\\n\\n        for(int idx=n-1;idx>=0;idx--){\\n\\n            int ans = INT_MAX;\\n\\n            //1 day pass\\n            ans = min(ans,costs[0] + dp[idx+1]);\\n\\n            int i;\\n\\n            //7-day pass\\n            for(i=idx;i<days.size() && days[i]<days[idx]+7;i++);\\n            ans = min(ans,costs[1]+dp[i]);\\n\\n            //30-days pass\\n            for(i=idx;i<days.size() && days[i]<days[idx]+30;i++);\\n            ans = min(ans,costs[2]+dp[i]);\\n\\n            dp[idx] = ans;\\n        }\\n        return dp[0];\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\n/*Approach 1*/\\n        // vector<int> dp(days.size(),-1);\\n        // return solve(0,days,costs,dp);\\n\\n/*Approach 2*/\\n        return solveTab(days,costs);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*Approach One*/\\n    int solve(int idx,vector<int>& days, vector<int>& costs,vector<int>& dp){\\n        if(idx >= days.size())\\n            return 0;\\n\\n        if(dp[idx] != -1)\\n            return dp[idx];\\n\\n        int ans = INT_MAX;\\n        //1 day pass\\n        ans = min(ans,costs[0] + solve(idx+1,days,costs,dp));\\n\\n        int i;\\n\\n        //7-day pass\\n        for(i=idx;i<days.size() && days[i]<days[idx]+7;i++);\\n        ans = min(ans,costs[1]+solve(i,days,costs,dp));\\n\\n        //30-days pass\\n        for(i=idx;i<days.size() && days[i]<days[idx]+30;i++);\\n        ans = min(ans,costs[2]+solve(i,days,costs,dp));\\n\\n        return dp[idx] = ans;\\n    }\\n/*Approach 2*/\\n    int solveTab(vector<int>& days, vector<int>& costs){\\n        int n = days.size();\\n        vector<int> dp(days.size()+1,0);\\n\\n        for(int idx=n-1;idx>=0;idx--){\\n\\n            int ans = INT_MAX;\\n\\n            //1 day pass\\n            ans = min(ans,costs[0] + dp[idx+1]);\\n\\n            int i;\\n\\n            //7-day pass\\n            for(i=idx;i<days.size() && days[i]<days[idx]+7;i++);\\n            ans = min(ans,costs[1]+dp[i]);\\n\\n            //30-days pass\\n            for(i=idx;i<days.size() && days[i]<days[idx]+30;i++);\\n            ans = min(ans,costs[2]+dp[i]);\\n\\n            dp[idx] = ans;\\n        }\\n        return dp[0];\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\n/*Approach 1*/\\n        // vector<int> dp(days.size(),-1);\\n        // return solve(0,days,costs,dp);\\n\\n/*Approach 2*/\\n        return solveTab(days,costs);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351379,
                "title": "c-easiest-way-solved-solution-well-explained-approach-inution-tc-sc-gauravthinks",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst we will attempt with recursion then we will optimse time complexcity because of covering subproblems by 1 d dp\\nInstinct is that we will purchase tickets/vouchers just when we experience a substantial travelling day\\nThen at the end we\\'ll return the minimum of all the possibilities\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNow you know the sub problems so we can convert OUR recursion solution to top-down-memoization , ie we store our answers at each step before returning, then if we already knows the answer , we can return right back without re calculating\\n\\n- For each day index of days array, three possibilities are considered:\\nFor each day that you need to buy a ticket you will try the three options\\n\\ni) Buying a one-day ticket and then continuing with the rest of the days\\nii) Buying a seven-day ticket and skipping all the days included in this ticket\\niii) Buying a thirty-day ticket and skipping all the days included in this ticket\\n as in top down DP approach, we store the results into the array(here in 1D array as needed) so that we can directly return the answer already stored if we traver again onto that index.\\nso before returning the answer at any index, we store it into the MEMO( DP ) array, for future use.\\nthis helps us reduce the time complexity(of recursive solution) from  3^n to much good(acchi acchi time complexity) time complexity;\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs we travel only once throught the days array, \\nTC comes out to be : O(N) \\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe use extra space (in memoised solution) of size N,\\ntherefore O(N) space complexity\\n\\n# Code\\n```\\nclass Solution {\\n    //          RECURSIVE SOLUTION(MIGHT GIVE TLE)\\n    int helper(vector<int>& days, vector<int>& costs, int n, int ind){\\n                                    // base condition\\n        // if the index while traversing  goes out of bound, then the fucntion can not bring anything from there, so return 0 \\n    if(ind>=n) return 0; \\n\\n                              //  else we have three routes to go with, take one day,   take                                      one week or take one month package\\n  \\n    // to take one day voucher, we just add the cost[0] and move to the next index\\n    int one= costs[0]+ helper(days, costs, n, ind+1);\\n\\n    // to take 7 or 30 day vouchers, we need to check the forward index if they are avaiable, if available, take 7 day or 30 day vouchers\\n    int pointer;\\n    for( pointer=ind; pointer<n and days[pointer] < days[ind]+7; pointer++ );\\n     int seven=  costs[1]+ helper(days, costs, n, pointer);\\n     for( pointer=ind; pointer<n and days[pointer] < days[ind]+30; pointer++ );\\n    int thirty= costs[2]+ helper(days, costs, n, pointer);\\n\\n\\n//  at the end, return minimum of all the three possibilities \\n    return min({one, seven, thirty});\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n= days.size();\\n        \\n        // helper(days, costs, n, starting index)\\n        return helper(days, costs,n, 0);\\n        \\n    }\\n};\\n```\\n```\\nclass Solution {\\n                          //          MEMOISED SOLUTION TO THE RECURSIVE ONE\\n    int helper(vector<int>& days, vector<int>& costs, int n, int ind, vector<int> &memo){\\n                                    // base condition\\n        // if the index while traversing  goes out of bound, then the fucntion can not bring anything from there, so return 0 \\n    if(ind>=n) return 0; \\n\\n                              //  else we have three routes to go with, take one day,   take                                      one week or take one month package\\n   if(memo[ind]!=-1) return memo[ind];\\n\\n    // to take one day voucher, we just add the cost[0] and move to the next index\\n    int one= costs[0]+ helper(days, costs, n, ind+1, memo);\\n\\n    // to take 7 or 30 day vouchers, we need to check the forward index if they are avaiable, if available, take 7 day or 30 day vouchers\\n    int pointer;\\n    for( pointer=ind; pointer<n and days[pointer] < days[ind]+7; pointer++ );\\n     int seven=  costs[1]+ helper(days, costs, n, pointer, memo);\\n     for( pointer=ind; pointer<n and days[pointer] < days[ind]+30; pointer++ );\\n    int thirty= costs[2]+ helper(days, costs, n, pointer, memo);\\n\\n\\n//  at the end, return minimum of all the three possibilities \\n    return memo[ind]= min({one, seven, thirty});\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n= days.size();\\n        \\n        vector<int> memo(n, -1);\\n        // helper(days, costs, n, starting index)\\n        return helper(days, costs,n, 0, memo);\\n        \\n    }\\n};\\n```\\nIf you liked the solution and explanation, then do Upvote the solution and subscribe to our YouTube Channel down below.\\n\\n# @GauravThinks <----- youtube channel",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    //          RECURSIVE SOLUTION(MIGHT GIVE TLE)\\n    int helper(vector<int>& days, vector<int>& costs, int n, int ind){\\n                                    // base condition\\n        // if the index while traversing  goes out of bound, then the fucntion can not bring anything from there, so return 0 \\n    if(ind>=n) return 0; \\n\\n                              //  else we have three routes to go with, take one day,   take                                      one week or take one month package\\n  \\n    // to take one day voucher, we just add the cost[0] and move to the next index\\n    int one= costs[0]+ helper(days, costs, n, ind+1);\\n\\n    // to take 7 or 30 day vouchers, we need to check the forward index if they are avaiable, if available, take 7 day or 30 day vouchers\\n    int pointer;\\n    for( pointer=ind; pointer<n and days[pointer] < days[ind]+7; pointer++ );\\n     int seven=  costs[1]+ helper(days, costs, n, pointer);\\n     for( pointer=ind; pointer<n and days[pointer] < days[ind]+30; pointer++ );\\n    int thirty= costs[2]+ helper(days, costs, n, pointer);\\n\\n\\n//  at the end, return minimum of all the three possibilities \\n    return min({one, seven, thirty});\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n= days.size();\\n        \\n        // helper(days, costs, n, starting index)\\n        return helper(days, costs,n, 0);\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n                          //          MEMOISED SOLUTION TO THE RECURSIVE ONE\\n    int helper(vector<int>& days, vector<int>& costs, int n, int ind, vector<int> &memo){\\n                                    // base condition\\n        // if the index while traversing  goes out of bound, then the fucntion can not bring anything from there, so return 0 \\n    if(ind>=n) return 0; \\n\\n                              //  else we have three routes to go with, take one day,   take                                      one week or take one month package\\n   if(memo[ind]!=-1) return memo[ind];\\n\\n    // to take one day voucher, we just add the cost[0] and move to the next index\\n    int one= costs[0]+ helper(days, costs, n, ind+1, memo);\\n\\n    // to take 7 or 30 day vouchers, we need to check the forward index if they are avaiable, if available, take 7 day or 30 day vouchers\\n    int pointer;\\n    for( pointer=ind; pointer<n and days[pointer] < days[ind]+7; pointer++ );\\n     int seven=  costs[1]+ helper(days, costs, n, pointer, memo);\\n     for( pointer=ind; pointer<n and days[pointer] < days[ind]+30; pointer++ );\\n    int thirty= costs[2]+ helper(days, costs, n, pointer, memo);\\n\\n\\n//  at the end, return minimum of all the three possibilities \\n    return memo[ind]= min({one, seven, thirty});\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n= days.size();\\n        \\n        vector<int> memo(n, -1);\\n        // helper(days, costs, n, starting index)\\n        return helper(days, costs,n, 0, memo);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351362,
                "title": "java-100-o-days-length",
                "content": "No need to iterate on all 365 days, we just need to iterate on each travelling day and find the earliest day for which a pass bought on that day would still be valid today\\n\\n```\\nclass Solution {\\n    \\n    // dp[i] = min cost to travel up to day i (inclusive)\\n    // = min  | dp[i-1] + day pass\\n    //        | dp[7_days_ago] + 7 days pass\\n    //        | dp[30_days_ago] + 30 days pass\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dayPass = costs[0];\\n        int weekPass = costs[1];\\n        int monthPass = costs[2];\\n        \\n        int n = days.length;\\n        \\n        int[] dp = new int[n+1];\\n        int w = 0; // index of earliest day within 7 days of today \\n        int m = 0; // index of earliest day within 30 days of today\\n        for(int i = 1; i<= n; i++){\\n            int today = days[i-1];\\n            while(days[w] <= today-7) w++;\\n            while(days[m] <= today-30) m++;\\n            \\n            int withDayPass = dp[i-1] + dayPass;\\n            int withWeekPass = dp[w] + weekPass;\\n            int withMonthPass = dp[m] + monthPass;\\n            dp[i] = Math.min(withDayPass, Math.min(withWeekPass, withMonthPass));\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    \\n    // dp[i] = min cost to travel up to day i (inclusive)\\n    // = min  | dp[i-1] + day pass\\n    //        | dp[7_days_ago] + 7 days pass\\n    //        | dp[30_days_ago] + 30 days pass\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dayPass = costs[0];\\n        int weekPass = costs[1];\\n        int monthPass = costs[2];\\n        \\n        int n = days.length;\\n        \\n        int[] dp = new int[n+1];\\n        int w = 0; // index of earliest day within 7 days of today \\n        int m = 0; // index of earliest day within 30 days of today\\n        for(int i = 1; i<= n; i++){\\n            int today = days[i-1];\\n            while(days[w] <= today-7) w++;\\n            while(days[m] <= today-30) m++;\\n            \\n            int withDayPass = dp[i-1] + dayPass;\\n            int withWeekPass = dp[w] + weekPass;\\n            int withMonthPass = dp[m] + monthPass;\\n            dp[i] = Math.min(withDayPass, Math.min(withWeekPass, withMonthPass));\\n        }\\n        \\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351257,
                "title": "easy-to-understand-short-upper-bound-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> apply dp on 365 days..similar to striver soln\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){\\n        if(ind<0){return 0;}\\n        if(dp[days[ind]]!=-1){return dp[days[ind]];}\\n        int daypoint=costs[0]+helper(costs,days,ind-1,dp);\\n        int indweek=upper_bound(days.begin(),days.end(),days[ind]-7)-days.begin();\\n        indweek--;\\n        int weekpoint=costs[1]+helper(costs,days,indweek,dp);\\n        int indmonth=upper_bound(days.begin(),days.end(),days[ind]-30)-days.begin();\\n        indmonth--;\\n        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);\\n        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n=days.size();\\n        vector<int>dp(366,-1);\\n        return helper(costs,days,n-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<int>&costs,vector<int>&days,int ind,vector<int>&dp){\\n        if(ind<0){return 0;}\\n        if(dp[days[ind]]!=-1){return dp[days[ind]];}\\n        int daypoint=costs[0]+helper(costs,days,ind-1,dp);\\n        int indweek=upper_bound(days.begin(),days.end(),days[ind]-7)-days.begin();\\n        indweek--;\\n        int weekpoint=costs[1]+helper(costs,days,indweek,dp);\\n        int indmonth=upper_bound(days.begin(),days.end(),days[ind]-30)-days.begin();\\n        indmonth--;\\n        int monthpoint=costs[2]+helper(costs,days,indmonth,dp);\\n        return dp[days[ind]]=min({daypoint,weekpoint,monthpoint});\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n=days.size();\\n        vector<int>dp(366,-1);\\n        return helper(costs,days,n-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350586,
                "title": "memoization",
                "content": "\\n# Approach\\nSimple memoization using three operations as increase by 1,7 or 30\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(vector<int>& days, vector<int>& costs, int idx, vector<int> &dp) {\\n        if(idx >= n) return 0;\\n        \\n        if(dp[idx] != -1) return dp[idx];\\n\\n        int i;\\n        int op1 = costs[0] + solve(days, costs, idx+1, dp);\\n        \\n        i=idx;\\n        while(i<n && days[i]<days[idx]+7){\\n            i++;\\n        }\\n        \\n        int op2 = costs[1] + solve(days, costs, i, dp);\\n        \\n    \\n        i=idx;\\n        while(i<n && days[i]<days[idx]+30){\\n            i++;\\n        }\\n            \\n        int op3 = costs[2] + solve(days, costs, i, dp);\\n        \\n        return dp[idx] = min({op1, op2,op3});\\n            \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        n = days.size();\\n        \\n        vector<int> dp(n+1, -1);\\n        \\n        return solve(days, costs, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int solve(vector<int>& days, vector<int>& costs, int idx, vector<int> &dp) {\\n        if(idx >= n) return 0;\\n        \\n        if(dp[idx] != -1) return dp[idx];\\n\\n        int i;\\n        int op1 = costs[0] + solve(days, costs, idx+1, dp);\\n        \\n        i=idx;\\n        while(i<n && days[i]<days[idx]+7){\\n            i++;\\n        }\\n        \\n        int op2 = costs[1] + solve(days, costs, i, dp);\\n        \\n    \\n        i=idx;\\n        while(i<n && days[i]<days[idx]+30){\\n            i++;\\n        }\\n            \\n        int op3 = costs[2] + solve(days, costs, i, dp);\\n        \\n        return dp[idx] = min({op1, op2,op3});\\n            \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        n = days.size();\\n        \\n        vector<int> dp(n+1, -1);\\n        \\n        return solve(days, costs, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350359,
                "title": "easy-code-with-intuition-and-approach-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem can be solved using Dynamic Programming where we need to find the minimum cost required to travel all the days mentioned in the given list. We can use a recursive approach to solve the problem where we consider all the possibilities of buying 1-day, 7-day, and 30-day passes, and choose the minimum cost among them.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe will create a recursive function where we pass the vector of days, costs, and the index of the current day. We will use memoization to store the already calculated results so that we do not have to recompute them. Inside the function, we will check if the result is already computed, if yes, we return the computed value. Otherwise, we will check if we have reached the end of the days, if yes, we return 0. Otherwise, we consider all the possibilities of buying passes for 1-day, 7-day, and 30-day and choose the minimum cost among them. We will calculate the index of the day when the pass expires using lower_bound function, and pass the updated index to the recursive function.\\n# Complexity\\n- Time complexity:\\nThe time complexity of the solution is O(n) where n is the number of days in the given list. This is because we are solving each subproblem only once and storing the results in the memoization table.\\n- Space complexity:\\nThe space complexity of the solution is O(n) where n is the number of days in the given list. This is because we are storing the results in the memoization table.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    // vector to store the available passes\\n    vector<int> passes = {1, 7, 30};\\n    vector<int> memo; // memoization table to store the already computed results\\n    \\n    int minCost(vector<int>& days, vector<int>& costs, int index) {\\n        // If result already computed, return it\\n        if (memo[index] != -1) {\\n            return memo[index];\\n        }\\n        // If we have reached the end of the days, return 0\\n        if (index >= days.size()) {\\n            return memo[index] = 0;\\n        }\\n        int ans = INT_MAX;\\n        // Consider all possibilities of buying passes for 1-day, 7-day, and 30-day\\n        for (int i = 0; i < costs.size(); i++) {\\n            int passIndex = lower_bound(days.begin(), days.end(), passes[i] + days[index]) - days.begin();\\n            ans = min(ans, minCost(days, costs, passIndex) + costs[i]);\\n        }\\n        return memo[index] = ans;\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memo.resize(days.size()+1, -1);\\n        return minCost(days, costs, 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // vector to store the available passes\\n    vector<int> passes = {1, 7, 30};\\n    vector<int> memo; // memoization table to store the already computed results\\n    \\n    int minCost(vector<int>& days, vector<int>& costs, int index) {\\n        // If result already computed, return it\\n        if (memo[index] != -1) {\\n            return memo[index];\\n        }\\n        // If we have reached the end of the days, return 0\\n        if (index >= days.size()) {\\n            return memo[index] = 0;\\n        }\\n        int ans = INT_MAX;\\n        // Consider all possibilities of buying passes for 1-day, 7-day, and 30-day\\n        for (int i = 0; i < costs.size(); i++) {\\n            int passIndex = lower_bound(days.begin(), days.end(), passes[i] + days[index]) - days.begin();\\n            ans = min(ans, minCost(days, costs, passIndex) + costs[i]);\\n        }\\n        return memo[index] = ans;\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memo.resize(days.size()+1, -1);\\n        return minCost(days, costs, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349689,
                "title": "go-dp",
                "content": "```\\nfunc mincostTickets(days []int, costs []int) int {\\n\\tvar dp [396]int\\n\\tfor _, d := range days {\\n\\t\\tdp[d] = 1\\n\\t}\\n\\tfor d := 365; d > 0; d-- {\\n\\t\\tif dp[d] == 0 {\\n\\t\\t\\tdp[d] = dp[d+1]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tdp[d] = min(\\n\\t\\t\\tdp[d+1]+costs[0],\\n\\t\\t\\tdp[d+7]+costs[1],\\n\\t\\t\\tdp[d+30]+costs[2])\\n\\t}\\n\\treturn dp[1]\\n}\\n\\nfunc min(nums ...int) int {\\n\\tfor _, n := range nums {\\n\\t\\tif n < nums[0] {\\n\\t\\t\\tnums[0] = n\\n\\t\\t}\\n\\t}\\n\\treturn nums[0]\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc mincostTickets(days []int, costs []int) int {\\n\\tvar dp [396]int\\n\\tfor _, d := range days {\\n\\t\\tdp[d] = 1\\n\\t}\\n\\tfor d := 365; d > 0; d-- {\\n\\t\\tif dp[d] == 0 {\\n\\t\\t\\tdp[d] = dp[d+1]\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tdp[d] = min(\\n\\t\\t\\tdp[d+1]+costs[0],\\n\\t\\t\\tdp[d+7]+costs[1],\\n\\t\\t\\tdp[d+30]+costs[2])\\n\\t}\\n\\treturn dp[1]\\n}\\n\\nfunc min(nums ...int) int {\\n\\tfor _, n := range nums {\\n\\t\\tif n < nums[0] {\\n\\t\\t\\tnums[0] = n\\n\\t\\t}\\n\\t}\\n\\treturn nums[0]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3084991,
                "title": "beats-100-in-both-time-and-space-easy-to-understand-o-n-c",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    int dp[366];\\n    int solve(vector<int>& days, vector<int>& costs, int i, int x){\\n        if(x<=0) return 0;\\n\\n        if(dp[x] != -1)\\n           return dp[x];\\n\\n        int cnt1=INT_MAX-1; int cnt2=INT_MAX-1; int cnt3=INT_MAX-1;\\n\\n        while(i>=0 && x<days[i]){\\n            i--;\\n        } if(i<0) return 0;\\n       \\n        cnt1=costs[0]+solve(days, costs, i, days[i]-1);\\n        cnt2=costs[1]+solve(days, costs, i, days[i]-7);\\n        cnt3=costs[2]+solve(days, costs, i, days[i]-30);\\n\\n       return dp[x]=min(cnt1, min(cnt2, cnt3));\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(days, costs, days.size()-1, days[days.size()-1]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int dp[366];\\n    int solve(vector<int>& days, vector<int>& costs, int i, int x){\\n        if(x<=0) return 0;\\n\\n        if(dp[x] != -1)\\n           return dp[x];\\n\\n        int cnt1=INT_MAX-1; int cnt2=INT_MAX-1; int cnt3=INT_MAX-1;\\n\\n        while(i>=0 && x<days[i]){\\n            i--;\\n        } if(i<0) return 0;\\n       \\n        cnt1=costs[0]+solve(days, costs, i, days[i]-1);\\n        cnt2=costs[1]+solve(days, costs, i, days[i]-7);\\n        cnt3=costs[2]+solve(days, costs, i, days[i]-30);\\n\\n       return dp[x]=min(cnt1, min(cnt2, cnt3));\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp, -1, sizeof(dp));\\n        return solve(days, costs, days.size()-1, days[days.size()-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494543,
                "title": "c-top-down-dp-memoized-explained",
                "content": "**---- DO UPVOTE IF YOU LIKE MY EXPLAINATION :D ----\\n**\\nclass Solution {\\npublic:\\n    \\n        int util(vector<int>& days, vector<int>& costs, vector<int>& dp,int ind)\\n        {\\n            //base case, if we reach end of days, we dont have to travel anymore\\n            if(ind>=days.size()) return 0;\\n\\n            \\n            // return memoized solution if it exists\\n            if(dp[ind]!=-1) return dp[ind];\\n\\n            //choice 1 we take 1-day pass for a given day at index ind\\n            //then we add 1-day cost and calculate cost for remaining days\\n            int choice1  = costs[0] + util(days,costs,dp,ind+1);\\n            \\n            //now for choice 2 we take a 7-day pass for a given day at index ind\\n            //now we can skip upto 7 days from days[ind]\\n            //so if any of values in days array i.e. any of upcoming travel days fall in the next 7 days we can skip them\\n            //formally \\n            //  while (days[i]<days[ind]+7) \\n            // { \\n                    // skip \\n                    // i++ \\n            // } \\n            \\n            int i= ind;\\n\\n            while(i < days.size() && days[i]<days[ind]+7) i++;\\n            \\n            //now we add cost of choice2 and calculate cost for remaining days\\n            int choice2 = costs[1]+util(days,costs,dp,i);\\n\\n            //now for choice 3 we take a 30-day pass for a given day at index ind\\n            //now we can skip upto 30 days from days[ind]\\n            //so if any of values in days array i.e. any of upcoming travel days fall in the next 30 days we can skip them\\n            //formally \\n            //  while (days[i]<days[ind]+30) \\n            // { \\n                    // skip \\n                    // i++ \\n            // }             \\n            while(i < days.size() && days[i]<days[ind]+30) i++;\\n            \\n            //now we add cost of choice3 and calculate cost for remaining days\\n            int choice3 = costs[2]+util(days,costs,dp,i);\\n\\n            \\n            //now that we have calculated for all 3 choices, we simply return the minimum cost of these 3 choices\\n            return dp[ind]=min({choice1,choice2,choice3});\\n        }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n\\n        vector<int> dp(days.size(),-1);\\n        int ans = util(days, costs,dp,0);\\n        return ans;\\n    }\\n        \\n        \\n};",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "class Solution {\\npublic:\\n    \\n        int util(vector<int>& days, vector<int>& costs, vector<int>& dp,int ind)\\n        {\\n            //base case, if we reach end of days, we dont have to travel anymore\\n            if(ind>=days.size()) return 0;\\n\\n            \\n            // return memoized solution if it exists\\n            if(dp[ind]!=-1) return dp[ind];\\n\\n            //choice 1 we take 1-day pass for a given day at index ind\\n            //then we add 1-day cost and calculate cost for remaining days\\n            int choice1  = costs[0] + util(days,costs,dp,ind+1);\\n            \\n            //now for choice 2 we take a 7-day pass for a given day at index ind\\n            //now we can skip upto 7 days from days[ind]\\n            //so if any of values in days array i.e. any of upcoming travel days fall in the next 7 days we can skip them\\n            //formally \\n            //  while (days[i]<days[ind]+7) \\n            // { \\n                    // skip \\n                    // i++ \\n            // }",
                "codeTag": "Java"
            },
            {
                "id": 2415004,
                "title": "dp-recursive-solution-with-lower-bound-c-solution-beasts-90-submissions",
                "content": "```\\nint dp[366];\\n    int helper(vector<int>&days, vector<int>&costs, int idx){\\n        if(idx>=days.size())\\n            return 0;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        \\n        int ans1 = 0, ans2 = 0, ans3 = 0;\\n        // 1-day pass\\n        int i = lower_bound(days.begin(), days.end(), days[idx]+1)-days.begin();\\n        ans1 += costs[0] + helper(days,costs,i);\\n        // // 7-days pass\\n        i = lower_bound(days.begin(), days.end(), days[idx]+7)-days.begin();\\n        ans2 += costs[1] + helper(days,costs,i);\\n        // // 30-days pass\\n        i = lower_bound(days.begin(), days.end(), days[idx]+30)-days.begin();\\n        ans3 += costs[2] + helper(days,costs,i);\\n        \\n        return dp[idx] = min({ans1,ans2,ans3});\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(days,costs,0);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nint dp[366];\\n    int helper(vector<int>&days, vector<int>&costs, int idx){\\n        if(idx>=days.size())\\n            return 0;\\n        if(dp[idx]!=-1)\\n            return dp[idx];\\n        \\n        int ans1 = 0, ans2 = 0, ans3 = 0;\\n        // 1-day pass\\n        int i = lower_bound(days.begin(), days.end(), days[idx]+1)-days.begin();\\n        ans1 += costs[0] + helper(days,costs,i);\\n        // // 7-days pass\\n        i = lower_bound(days.begin(), days.end(), days[idx]+7)-days.begin();\\n        ans2 += costs[1] + helper(days,costs,i);\\n        // // 30-days pass\\n        i = lower_bound(days.begin(), days.end(), days[idx]+30)-days.begin();\\n        ans3 += costs[2] + helper(days,costs,i);\\n        \\n        return dp[idx] = min({ans1,ans2,ans3});\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp,-1,sizeof(dp));\\n        return helper(days,costs,0);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2123226,
                "title": "python3-concise-bottom-up-dp",
                "content": "```\\n\"\"\"https://leetcode.com/problems/minimum-cost-for-tickets/\"\"\"\\n\\n\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        max_day = days[-1] + 1\\n        dp = [0] * max_day\\n        # dp[day] contains the minimum cost to cover the days up to the given day\\n        for day in range(1, max_day):\\n            if day in days:\\n                dp[day] = min(dp[day - 1] + costs[0], dp[max(day - 7, 0)] + costs[1], dp[max(day - 30, 0)] + costs[2])\\n            else:\\n                dp[day] = dp[day - 1]\\n\\n        return dp[-1]",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n\"\"\"https://leetcode.com/problems/minimum-cost-for-tickets/\"\"\"\\n\\n\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        max_day = days[-1] + 1\\n        dp = [0] * max_day\\n        # dp[day] contains the minimum cost to cover the days up to the given day\\n        for day in range(1, max_day):\\n            if day in days:\\n                dp[day] = min(dp[day - 1] + costs[0], dp[max(day - 7, 0)] + costs[1], dp[max(day - 30, 0)] + costs[2])\\n            else:\\n                dp[day] = dp[day - 1]\\n\\n        return dp[-1]",
                "codeTag": "Java"
            },
            {
                "id": 2021685,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int day: days) set.add(day);\\n        int n = days[days.length - 1];\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        for(int i = 1; i <= n; i++){\\n            if(!set.contains(i)){\\n                dp[i] = dp[i - 1];\\n                continue;\\n            }\\n            int a = dp[Math.max(0, i - 1)] + costs[0];\\n            int b = dp[Math.max(0, i - 7)] + costs[1];\\n            int c = dp[Math.max(0, i - 30)] + costs[2];\\n            dp[i] = Math.min(a, Math.min(b, c));\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        HashSet<Integer> set = new HashSet<>();\\n        for(int day: days) set.add(day);\\n        int n = days[days.length - 1];\\n        int[] dp = new int[n + 1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        for(int i = 1; i <= n; i++){\\n            if(!set.contains(i)){\\n                dp[i] = dp[i - 1];\\n                continue;\\n            }\\n            int a = dp[Math.max(0, i - 1)] + costs[0];\\n            int b = dp[Math.max(0, i - 7)] + costs[1];\\n            int c = dp[Math.max(0, i - 30)] + costs[2];\\n            dp[i] = Math.min(a, Math.min(b, c));\\n        }\\n        return dp[n];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1867012,
                "title": "top-down-memoization",
                "content": "For every day we have 3 choices to buy pass .\\nWe can buy 1 day pass, 7 day pass or 30 day pass .\\nThis helps in breaking down the problem .\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dn = days.length;\\n        //System.out.println(\"dn = \" + dn);\\n        Integer[] memo = new Integer[dn];\\n        int minCost = minCost(0, days, costs, memo);\\n        return minCost;\\n    }\\n    \\n    \\n    private int minCost(int start, int[] days, int[] costs, Integer[] memo){\\n        int dn = days.length;\\n        \\n        // it cost 0 to travel for 0 days\\n        if(start >= dn){\\n            return 0;\\n        }\\n        \\n        // already know minCost of travel from days[start, end]\\n        if(memo[start] != null){\\n            return memo[start];\\n        }\\n        \\n        int minCost = Integer.MAX_VALUE;\\n        \\n        int cost = 0;\\n        // case 1 : buy 1-day pass\\n        int Day1Cost = costs[0] + minCost(start + 1, days, costs, memo);\\n        minCost = Math.min(Day1Cost, minCost);\\n        \\n        // case 2 : buy 7-day pass\\n        \\n        // find first index of x = days[start] + 7 day\\n\\t\\t// then we need to find minCost of travel from xth day till end\\n        int Day7Idx = findIndex(start + 1, days[start] + 7, days);\\n        int Day7Cost = costs[1] + minCost(Day7Idx, days, costs, memo);\\n        minCost = Math.min(Day7Cost, minCost);\\n        \\n        // case 3 : buy 30-day pass\\n\\t\\t// again I bought 30-day pass means I can travel \\n\\t\\t// from S till T days , where S = days[start] and T = days[start] + 30 - 1\\n\\t\\t// on this pass and need to find minCost for remaining days .\\n        int Day30Idx = findIndex(start + 1, days[start] + 30, days);\\n        //System.out.println(\"Day30Idx \" + Day30Idx);\\n        // return 0;\\n        int Day30Cost = costs[2] + minCost(Day30Idx, days, costs, memo);\\n        minCost = Math.min(Day30Cost, minCost);\\n        \\n\\t\\t// memo[start] = minCost for travel from days[start, tillEnd]\\n\\t\\t// minCost = mnimum of three cases \\n        memo[start] = minCost;\\n        return minCost;\\n    }\\n    \\n\\t/*\\n\\tReturns the index of lower bound of \\'target\\' .\\n\\tPortion of array which is considered here is\\n\\tdays[startIdx...tillEnd] .\\n\\t*/\\n    private int findIndex(int startIdx, int target, int[] days){\\n        int dn = days.length;\\n        int lo = startIdx, hi = dn, m;\\n        while(lo < hi){\\n            m = lo + (hi - lo) / 2;\\n            // System.out.println(days[m] + \" \" + target);\\n            if(days[m] < target){\\n                lo = m + 1;\\n            }\\n            else{\\n                hi = m;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dn = days.length;\\n        //System.out.println(\"dn = \" + dn);\\n        Integer[] memo = new Integer[dn];\\n        int minCost = minCost(0, days, costs, memo);\\n        return minCost;\\n    }\\n    \\n    \\n    private int minCost(int start, int[] days, int[] costs, Integer[] memo){\\n        int dn = days.length;\\n        \\n        // it cost 0 to travel for 0 days\\n        if(start >= dn){\\n            return 0;\\n        }\\n        \\n        // already know minCost of travel from days[start, end]\\n        if(memo[start] != null){\\n            return memo[start];\\n        }\\n        \\n        int minCost = Integer.MAX_VALUE;\\n        \\n        int cost = 0;\\n        // case 1 : buy 1-day pass\\n        int Day1Cost = costs[0] + minCost(start + 1, days, costs, memo);\\n        minCost = Math.min(Day1Cost, minCost);\\n        \\n        // case 2 : buy 7-day pass\\n        \\n        // find first index of x = days[start] + 7 day\\n\\t\\t// then we need to find minCost of travel from xth day till end\\n        int Day7Idx = findIndex(start + 1, days[start] + 7, days);\\n        int Day7Cost = costs[1] + minCost(Day7Idx, days, costs, memo);\\n        minCost = Math.min(Day7Cost, minCost);\\n        \\n        // case 3 : buy 30-day pass\\n\\t\\t// again I bought 30-day pass means I can travel \\n\\t\\t// from S till T days , where S = days[start] and T = days[start] + 30 - 1\\n\\t\\t// on this pass and need to find minCost for remaining days .\\n        int Day30Idx = findIndex(start + 1, days[start] + 30, days);\\n        //System.out.println(\"Day30Idx \" + Day30Idx);\\n        // return 0;\\n        int Day30Cost = costs[2] + minCost(Day30Idx, days, costs, memo);\\n        minCost = Math.min(Day30Cost, minCost);\\n        \\n\\t\\t// memo[start] = minCost for travel from days[start, tillEnd]\\n\\t\\t// minCost = mnimum of three cases \\n        memo[start] = minCost;\\n        return minCost;\\n    }\\n    \\n\\t/*\\n\\tReturns the index of lower bound of \\'target\\' .\\n\\tPortion of array which is considered here is\\n\\tdays[startIdx...tillEnd] .\\n\\t*/\\n    private int findIndex(int startIdx, int target, int[] days){\\n        int dn = days.length;\\n        int lo = startIdx, hi = dn, m;\\n        while(lo < hi){\\n            m = lo + (hi - lo) / 2;\\n            // System.out.println(days[m] + \" \" + target);\\n            if(days[m] < target){\\n                lo = m + 1;\\n            }\\n            else{\\n                hi = m;\\n            }\\n        }\\n        return lo;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1577749,
                "title": "java-dfs-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        // using dfs as it is a decision tree\\n        // at each stage I can choose either 1/7/30 day pass\\n        // caching already visited indices\\n        return dfs(days, costs, 0, new int[days.length]);\\n    }\\n    \\n    private int dfs(int[] days, int[] costs, int index, int[] dp) {\\n        \\n        if(index >= days.length) {\\n            return 0;\\n        }\\n        \\n        // cached\\n        if(dp[index] > 0) {\\n            return dp[index];\\n        }\\n        \\n        \\n        // 1 Day Pass\\n        int cost1DayPass = costs[0] + dfs(days, costs, index+1, dp);\\n        \\n        // 7 Days Pass\\n        \\n        // Find next travel day when pass expires\\n        int i = index;\\n        \\n        while(i < days.length && days[i] < days[index] + 7) {\\n            i++;\\n        }\\n        \\n        int cost7DayPass = costs[1] + dfs(days, costs, i, dp);\\n        \\n        // 30 Days Pass\\n        \\n        // Find next travel day when pass expires\\n        i = index;\\n        \\n        while(i < days.length && days[i] < days[index] + 30) {\\n            i++;\\n        }\\n        \\n        int cost30DayPass = costs[2] + dfs(days, costs, i, dp);\\n        \\n        \\n        int result = Math.min(cost1DayPass, Math.min(cost7DayPass, cost30DayPass));\\n        \\n        dp[index] = result;\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        // using dfs as it is a decision tree\\n        // at each stage I can choose either 1/7/30 day pass\\n        // caching already visited indices\\n        return dfs(days, costs, 0, new int[days.length]);\\n    }\\n    \\n    private int dfs(int[] days, int[] costs, int index, int[] dp) {\\n        \\n        if(index >= days.length) {\\n            return 0;\\n        }\\n        \\n        // cached\\n        if(dp[index] > 0) {\\n            return dp[index];\\n        }\\n        \\n        \\n        // 1 Day Pass\\n        int cost1DayPass = costs[0] + dfs(days, costs, index+1, dp);\\n        \\n        // 7 Days Pass\\n        \\n        // Find next travel day when pass expires\\n        int i = index;\\n        \\n        while(i < days.length && days[i] < days[index] + 7) {\\n            i++;\\n        }\\n        \\n        int cost7DayPass = costs[1] + dfs(days, costs, i, dp);\\n        \\n        // 30 Days Pass\\n        \\n        // Find next travel day when pass expires\\n        i = index;\\n        \\n        while(i < days.length && days[i] < days[index] + 30) {\\n            i++;\\n        }\\n        \\n        int cost30DayPass = costs[2] + dfs(days, costs, i, dp);\\n        \\n        \\n        int result = Math.min(cost1DayPass, Math.min(cost7DayPass, cost30DayPass));\\n        \\n        dp[index] = result;\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1569613,
                "title": "easy-c-recursive-and-memorization",
                "content": "Recursive solution\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs, int ind=0, int d=0) {\\n        int cost=INT_MAX;\\n        static int arr[3]={1,7,30};\\n        if(ind>=days.size())\\n            return 0;\\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(d<days[ind])\\n                cost = min(costs[i]+mincostTickets(days, costs, ind+1, d+arr[i]), cost);\\n            else\\n                cost = min(cost, mincostTickets(days, costs, ind+1, d));\\n        }\\n        return cost;\\n    }\\n};\\n```\\nDynamic Programming\\n```\\nclass Solution {\\npublic:\\n    int dp[367];\\n     int count(vector<int> &days, vector<int> &costs, int d = 0, int ind = -1)\\n     {\\n         if (d > days[days.size() - 1])\\n             return 0;\\n         if (dp[d] != -1)\\n             return dp[d];\\n     \\n         for (int i = ind + 1; i < days.size(); i++)\\n         {\\n             if (days[i] > d)\\n             {\\n                 dp[d] = min(min(count(days, costs, days[i], i) + costs[0], count(days, costs, days[i] + 6, i) + costs[1]), count(days, costs, days[i] + 29, i) + costs[2]);\\n                 return dp[d];\\n             }\\n         }\\n         return 0;\\n     }\\n     int mincostTickets(vector<int> &days, vector<int> &costs)\\n     {\\n         memset(dp, -1, sizeof(dp));\\n         return count(days, costs);\\n     }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs, int ind=0, int d=0) {\\n        int cost=INT_MAX;\\n        static int arr[3]={1,7,30};\\n        if(ind>=days.size())\\n            return 0;\\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(d<days[ind])\\n                cost = min(costs[i]+mincostTickets(days, costs, ind+1, d+arr[i]), cost);\\n            else\\n                cost = min(cost, mincostTickets(days, costs, ind+1, d));\\n        }\\n        return cost;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int dp[367];\\n     int count(vector<int> &days, vector<int> &costs, int d = 0, int ind = -1)\\n     {\\n         if (d > days[days.size() - 1])\\n             return 0;\\n         if (dp[d] != -1)\\n             return dp[d];\\n     \\n         for (int i = ind + 1; i < days.size(); i++)\\n         {\\n             if (days[i] > d)\\n             {\\n                 dp[d] = min(min(count(days, costs, days[i], i) + costs[0], count(days, costs, days[i] + 6, i) + costs[1]), count(days, costs, days[i] + 29, i) + costs[2]);\\n                 return dp[d];\\n             }\\n         }\\n         return 0;\\n     }\\n     int mincostTickets(vector<int> &days, vector<int> &costs)\\n     {\\n         memset(dp, -1, sizeof(dp));\\n         return count(days, costs);\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428983,
                "title": "c-dp-6-lines",
                "content": "```\\n\\n```public:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        set<int>s(days.begin(),days.end());\\n        vector<int>dp(366,0);\\n        for(int i=1;i<366;i++)\\n        {\\n            if(s.find(i)==s.end())\\n            {\\n                dp[i]=dp[i-1];\\n            }\\n            else\\n            {\\n                dp[i]=min({costs[0]+dp[i-1],costs[1]+dp[max(0,i-7)],costs[2]+dp[max(0,i-30)]});\\n            }\\n        }\\n        return dp[365];\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1366312,
                "title": "c-commented-dp-solution-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int m = days.size(), n = costs.size(), mx = *max_element(days.begin(),days.end());        \\n        vector<int> dp(mx+1,INT_MAX); // dp[i] is the minimum cost required upto ith day\\n        dp[0] = 0;\\n        unordered_set<int> st(days.begin(),days.end()); // To efficently check whether the day is a travel day or not\\n        for(int i = 1 ; i <= mx ; ++i) // Iterating over the maximum day in days array\\n        {\\n            if(st.count(i) == 0) // If there is no travel on that day then the cost is equal to the cost upto the previous day\\n                dp[i] = dp[i-1];\\n            else\\n            {\\n                dp[i] = min(dp[i],dp[i-1] + costs[0]); // Taking the minimum of the cost upto ith day and the minimum upto (i-1)th day and cost of 1 day ticket\\n                if(i - 7 >= 0)\\n                    dp[i] = min(dp[i],dp[i-7] + costs[1]); // Taking the minimum of the cost upto ith day and the minimum upto (i-7)th day and cost of 7 days ticket\\n                else \\n                    dp[i] = min(dp[i],costs[1]); // Considering the case where cost of 7 days ticket is lower \\n                if(i - 30 >= 0)\\n                    dp[i] = min(dp[i],dp[i-30] + costs[2]); // Taking the minimum of the cost upto ith day and the minimum upto (i-30)th day and cost of 30 days ticket\\n                else \\n                    dp[i] = min(dp[i],costs[2]); // Considering the case where cost of 30 days ticket is lower\\n            }\\n        }\\n        return dp[mx]; // dp[last day] stores the minimum cost upto the last day in days array\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int m = days.size(), n = costs.size(), mx = *max_element(days.begin(),days.end());        \\n        vector<int> dp(mx+1,INT_MAX); // dp[i] is the minimum cost required upto ith day\\n        dp[0] = 0;\\n        unordered_set<int> st(days.begin(),days.end()); // To efficently check whether the day is a travel day or not\\n        for(int i = 1 ; i <= mx ; ++i) // Iterating over the maximum day in days array\\n        {\\n            if(st.count(i) == 0) // If there is no travel on that day then the cost is equal to the cost upto the previous day\\n                dp[i] = dp[i-1];\\n            else\\n            {\\n                dp[i] = min(dp[i],dp[i-1] + costs[0]); // Taking the minimum of the cost upto ith day and the minimum upto (i-1)th day and cost of 1 day ticket\\n                if(i - 7 >= 0)\\n                    dp[i] = min(dp[i],dp[i-7] + costs[1]); // Taking the minimum of the cost upto ith day and the minimum upto (i-7)th day and cost of 7 days ticket\\n                else \\n                    dp[i] = min(dp[i],costs[1]); // Considering the case where cost of 7 days ticket is lower \\n                if(i - 30 >= 0)\\n                    dp[i] = min(dp[i],dp[i-30] + costs[2]); // Taking the minimum of the cost upto ith day and the minimum upto (i-30)th day and cost of 30 days ticket\\n                else \\n                    dp[i] = min(dp[i],costs[2]); // Considering the case where cost of 30 days ticket is lower\\n            }\\n        }\\n        return dp[mx]; // dp[last day] stores the minimum cost upto the last day in days array\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1352703,
                "title": "a-very-easy-approach-dynamic-programming-fully-explained",
                "content": "# ****To Solve this problem we will take a dynamic array of size 366 and start travese it from one as dp[0] = 0 No cost for 0th day, Now for each day we will check the cost for 3 tickets and take minimum of it ----> Math.min(dp[i] =  dp[i-1] + costs[0] , dp[i] = dp[i-7] + costs[1], dp[i]  = dp[i-30] + costs[2]) this we will do when the ith day is in our days array otherwise we will simply store dp[i]= dp[i-1] and for optimisation we will break when our j pointer reaches days.length**\\n\\n\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dp[] = new int[366];\\n        dp[0]=0;\\n        int j=0;\\n        for(int i=1;i<366;i++){\\n            if(j==days.length){\\n                break;\\n            }\\n            \\n            if(days[j] != i){\\n                dp[i] = dp[i-1];\\n            }\\n            else{\\n                int one = dp[i-1] + costs[0];\\n                int seven = dp[Math.max(0,i-7)] + costs[1];\\n                int thirty = dp[Math.max(0,i-30)] + costs[2];\\n                dp[i] = Math.min(one, Math.min(seven, thirty));\\n                j++;\\n            }\\n        }\\n        return dp[days[days.length-1]];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int dp[] = new int[366];\\n        dp[0]=0;\\n        int j=0;\\n        for(int i=1;i<366;i++){\\n            if(j==days.length){\\n                break;\\n            }\\n            \\n            if(days[j] != i){\\n                dp[i] = dp[i-1];\\n            }\\n            else{\\n                int one = dp[i-1] + costs[0];\\n                int seven = dp[Math.max(0,i-7)] + costs[1];\\n                int thirty = dp[Math.max(0,i-30)] + costs[2];\\n                dp[i] = Math.min(one, Math.min(seven, thirty));\\n                j++;\\n            }\\n        }\\n        return dp[days[days.length-1]];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1219272,
                "title": "python-o-n-runtime-o-n-with-explanation",
                "content": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\t\\t#create the total costs for the days \\n        costForDays = [0 for _ in range(days[-1] + 1) ]\\n\\t\\t#since days are sorted in ascending order, we only need the index of the days we haven\\'t visited yet\\n        curIdx = 0\\n\\t\\t\\n        for d in range(1, len(costForDays)):\\n\\t\\t\\t#if we do not need to travel that day\\n\\t\\t\\t#we don\\'t need to add extra costs\\n            if d < days[curIdx]:\\n                costForDays[d] = costForDays[d - 1]\\n                continue\\n            \\n\\t\\t\\t#else this means we need to travel this day\\n\\t\\t\\t#find the cost if we were to buy a 1-day pass, 7-day pass and 30-day pass\\n            costs_extra_1 = costForDays[d - 1] + costs[0]\\n            costs_extra_7 = costForDays[max(0, d - 7)] + costs[1] \\n            costs_extra_30 = costForDays[max(0, d - 30)] + costs[2]\\n            \\n\\t\\t\\t#get the minimum value\\n            costForDays[d] = min(costs_extra_1, costs_extra_7, costs_extra_30)\\n\\t\\t\\t\\n\\t\\t\\t#update the index to the next day we need to travel\\n            curIdx += 1\\n\\t\\t\\t\\n        return costForDays[-1]\\n\\t\\t\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\t\\t#create the total costs for the days \\n        costForDays = [0 for _ in range(days[-1] + 1) ]\\n\\t\\t#since days are sorted in ascending order, we only need the index of the days we haven\\'t visited yet\\n        curIdx = 0\\n\\t\\t\\n        for d in range(1, len(costForDays)):\\n\\t\\t\\t#if we do not need to travel that day\\n\\t\\t\\t#we don\\'t need to add extra costs\\n            if d < days[curIdx]:\\n                costForDays[d] = costForDays[d - 1]\\n                continue\\n            \\n\\t\\t\\t#else this means we need to travel this day\\n\\t\\t\\t#find the cost if we were to buy a 1-day pass, 7-day pass and 30-day pass\\n            costs_extra_1 = costForDays[d - 1] + costs[0]\\n            costs_extra_7 = costForDays[max(0, d - 7)] + costs[1] \\n            costs_extra_30 = costForDays[max(0, d - 30)] + costs[2]\\n            \\n\\t\\t\\t#get the minimum value\\n            costForDays[d] = min(costs_extra_1, costs_extra_7, costs_extra_30)\\n\\t\\t\\t\\n\\t\\t\\t#update the index to the next day we need to travel\\n            curIdx += 1\\n\\t\\t\\t\\n        return costForDays[-1]\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1147589,
                "title": "c-recursive-solution-basic-thinking-2d-memoization",
                "content": "Our aim is here that we buy a ticket and keep a track of the day till which the last Bought is valid(This is stored in a valid variable). If the current day is less than that of valid then that means we do not need to buy a ticket at this day. \\n\\n```\\nclass Solution {\\npublic: int dp[366][366];\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        return Solve(days, costs, 0, -1); \\n    }\\n    \\n    int Solve(vector <int>& days, vector <int>& cost, int curr, int valid) \\n    {\\n        if(curr == days.size())\\n            return 0; \\n        \\n        if(valid != -1 && days[curr] <= valid)\\n            return Solve(days, cost, curr + 1, valid);\\n        \\n        if(valid != -1 && dp[curr][valid] != -1)\\n            return dp[curr][valid];\\n        \\n        int res = INT_MAX; \\n        \\n        for(int k = 0; k <= 2; k++)\\n        {\\n            int temp; \\n            \\n            if(k == 0)\\n                temp = days[curr]; \\n            else if(k == 1)\\n                temp = days[curr] + 6; \\n            else if(k == 2)\\n                temp = days[curr] +  29; \\n\\t\\t\\t\\t\\n            //the number of days this ticket is valid for is stored in temp. \\n\\t\\t\\t\\n            res = min(res, cost[k] + Solve(days, cost, curr + 1, temp)); \\n        }\\n        \\n        return valid == -1 ? res : dp[curr][valid] = res;  // doing memo at valid = -1 would lead to a invalid index. \\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: int dp[366][366];\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        memset(dp, -1, sizeof(dp));\\n        return Solve(days, costs, 0, -1); \\n    }\\n    \\n    int Solve(vector <int>& days, vector <int>& cost, int curr, int valid) \\n    {\\n        if(curr == days.size())\\n            return 0; \\n        \\n        if(valid != -1 && days[curr] <= valid)\\n            return Solve(days, cost, curr + 1, valid);\\n        \\n        if(valid != -1 && dp[curr][valid] != -1)\\n            return dp[curr][valid];\\n        \\n        int res = INT_MAX; \\n        \\n        for(int k = 0; k <= 2; k++)\\n        {\\n            int temp; \\n            \\n            if(k == 0)\\n                temp = days[curr]; \\n            else if(k == 1)\\n                temp = days[curr] + 6; \\n            else if(k == 2)\\n                temp = days[curr] +  29; \\n\\t\\t\\t\\t\\n            //the number of days this ticket is valid for is stored in temp. \\n\\t\\t\\t\\n            res = min(res, cost[k] + Solve(days, cost, curr + 1, temp)); \\n        }\\n        \\n        return valid == -1 ? res : dp[curr][valid] = res;  // doing memo at valid = -1 would lead to a invalid index. \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 813844,
                "title": "concise-java-dp-o-n-beats-100",
                "content": "Idea is quite simple and it is based on the fact that at ``i-th`` day we can be in 3 possible conditions to minimize expenses:\\n* we buy 1-day pass, then min cost is ``1-day pass + min cost the day before`` i.e. ``costs[0] + minCost[i]``\\n* it is last day of 7-day pass, then min cost is ``7-day pass + min cost the day before we bought it`` i.e. ``costs[1] + minCost[i7]``\\n* it is last day of 30-day pass, then min cost is ``30-day pass + min cost the day before we bought it`` i.e. ``costs[2] + minCost[i30]``\\n\\n``i7`` and ``i30`` are indices of the day when week or month window starts and are being advanced as we go and ``minCost`` is where we keep min cost for every day. Min cost for ``i-th`` day is kept in ``minCost[i+1]`` so that min cost at day before ``i-th`` day is ``minCost[i]``. If there is no day before day/week/month window min cost will be 0 i.e. ``minCost[0]=0``.\\n\\nWhen we done the answer will be the last element in ``minCost``.\\n\\n```\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] minCost = new int[days.length + 1]; // DP to keep min cost at i + 1 day\\n        for (int i = 0, i7 = 0, i30 = 0; i < days.length; i++) {\\n            while (days[i] - days[i7] >= 7) i7++;    // advance week start\\n            while (days[i] - days[i30] >= 30) i30++; // advance month start\\n            int daily = costs[0] + minCost[i];\\n            int weekly = costs[1] + minCost[i7];\\n            int monthly = costs[2] + minCost[i30];\\n            minCost[i + 1] = Math.min(daily, Math.min(weekly, monthly));\\n        }\\n        return minCost[minCost.length - 1];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int[] minCost = new int[days.length + 1]; // DP to keep min cost at i + 1 day\\n        for (int i = 0, i7 = 0, i30 = 0; i < days.length; i++) {\\n            while (days[i] - days[i7] >= 7) i7++;    // advance week start\\n            while (days[i] - days[i30] >= 30) i30++; // advance month start\\n            int daily = costs[0] + minCost[i];\\n            int weekly = costs[1] + minCost[i7];\\n            int monthly = costs[2] + minCost[i30];\\n            minCost[i + 1] = Math.min(daily, Math.min(weekly, monthly));\\n        }\\n        return minCost[minCost.length - 1];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 811825,
                "title": "javascript-clean-recursive-dp",
                "content": "```javascript\\nvar mincostTickets = function(days, costs) {\\n    const [one, seven, thirty] = costs;\\n    const memo = new Map()\\n    \\n    function recurse(curr, idx) {\\n        if(memo.has(curr)) return memo.get(curr);\\n        if(idx >= days.length) return 0;\\n        if(curr >= days[idx]) return recurse(curr, idx+1);\\n        \\n        const buy1 = recurse(days[idx], idx) + one;\\n        const buy7 = recurse(days[idx]+6, idx) + seven;\\n        const buy30 = recurse(days[idx]+29, idx) + thirty;\\n        const min = Math.min(buy1, buy7, buy30);\\n        memo.set(curr, min);\\n        return min;\\n    }\\n    return recurse(0, 0);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```javascript\\nvar mincostTickets = function(days, costs) {\\n    const [one, seven, thirty] = costs;\\n    const memo = new Map()\\n    \\n    function recurse(curr, idx) {\\n        if(memo.has(curr)) return memo.get(curr);\\n        if(idx >= days.length) return 0;\\n        if(curr >= days[idx]) return recurse(curr, idx+1);\\n        \\n        const buy1 = recurse(days[idx], idx) + one;\\n        const buy7 = recurse(days[idx]+6, idx) + seven;\\n        const buy30 = recurse(days[idx]+29, idx) + thirty;\\n        const min = Math.min(buy1, buy7, buy30);\\n        memo.set(curr, min);\\n        return min;\\n    }\\n    return recurse(0, 0);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 790708,
                "title": "python-bottom-up-dp-with-video-explanation",
                "content": "# Time Complexity: O(max(days))\\n# Space Complexity: O(max(days))\\n\\nvideo explanation: https://www.youtube.com/watch?v=DDcTw8QaJ0s\\n\\n# CODE PYTHON\\n\\n```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        daySet = set(days)\\n        size = max(days)+1\\n        dp = [0] * size\\n        dp[0] = 0\\n        for i in range(1, size):\\n            if i in daySet:\\n                pass1 = dp[0] if i - 1 <= 0 else dp[i-1] \\n                pass7 = dp[0] if i - 7 <= 0 else dp[i-7]\\n                pass30 = dp[0] if i - 30 <= 0 else dp[i-30]\\n                \\n                dp[i] = min(pass1+costs[0], pass7+costs[1], pass30+costs[2])\\n            else:\\n                dp[i] = dp[i-1]\\n        return dp[size-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        daySet = set(days)\\n        size = max(days)+1\\n        dp = [0] * size\\n        dp[0] = 0\\n        for i in range(1, size):\\n            if i in daySet:\\n                pass1 = dp[0] if i - 1 <= 0 else dp[i-1] \\n                pass7 = dp[0] if i - 7 <= 0 else dp[i-7]\\n                pass30 = dp[0] if i - 30 <= 0 else dp[i-30]\\n                \\n                dp[i] = min(pass1+costs[0], pass7+costs[1], pass30+costs[2])\\n            else:\\n                dp[i] = dp[i-1]\\n        return dp[size-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 746094,
                "title": "python-dp",
                "content": "Once we find the recurrence relation, it becomes a lot easier.\\n\\nCode:\\n```\\n        dp = [0]* (days[-1]+1)\\n        for i in range(1,len(dp)):\\n            if i not in days:   # keep the previous cost, do buy anything\\n                dp[i] = dp[i-1]\\n            else:\\n                dp[i] = min(dp[i-1]+costs[0], dp[max(0,i-7)]+costs[1], dp[max(0,i-30)]+costs[2])\\n            \\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\n        dp = [0]* (days[-1]+1)\\n        for i in range(1,len(dp)):\\n            if i not in days:   # keep the previous cost, do buy anything\\n                dp[i] = dp[i-1]\\n            else:\\n                dp[i] = min(dp[i-1]+costs[0], dp[max(0,i-7)]+costs[1], dp[max(0,i-30)]+costs[2])\\n            \\n        return dp[-1]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 673459,
                "title": "python-3-dp-easy-to-read-solution",
                "content": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n , max_days = len(days) , max(days)\\n        tickets_bought = [False for i in range(max_days + 1)]\\n        for day in days:\\n            tickets_bought[day] = True\\n        dp = [0 for i in range(max_days + 1)]\\n        for i in range(1 , max_days + 1):\\n            if not tickets_bought[i]:\\n                dp[i] = dp[i - 1]\\n            else:\\n                one_day_pass = dp[i - 1] + costs[0]\\n                seven_day_pass = dp[max(i - 7 , 0)] + costs[1]\\n                thirty_day_pass = dp[max(i - 30 , 0)] + costs[2]\\n                dp[i] = min(one_day_pass , seven_day_pass , thirty_day_pass)\\n        return dp[-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        n , max_days = len(days) , max(days)\\n        tickets_bought = [False for i in range(max_days + 1)]\\n        for day in days:\\n            tickets_bought[day] = True\\n        dp = [0 for i in range(max_days + 1)]\\n        for i in range(1 , max_days + 1):\\n            if not tickets_bought[i]:\\n                dp[i] = dp[i - 1]\\n            else:\\n                one_day_pass = dp[i - 1] + costs[0]\\n                seven_day_pass = dp[max(i - 7 , 0)] + costs[1]\\n                thirty_day_pass = dp[max(i - 30 , 0)] + costs[2]\\n                dp[i] = min(one_day_pass , seven_day_pass , thirty_day_pass)\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613964,
                "title": "dp-unbounded-knapsackconcept",
                "content": "\\n    \\n    int ks(vector<int> days, int n, vector<int> cost, int day){\\n                \\n        int dp[n+1][day+1];\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=day;j++){\\n                if(i==0) dp[i][j] = 0;\\n                else if(days[i-1]>j) dp[i][j] = dp[i-1][j];\\n                else{\\n                    int res = cost[0] + dp[i-1][days[i-1]-1];\\n                    if(days[i-1]-7>=0){\\n                        res = min(res,cost[1] + dp[i-1][days[i-1]-7]);         \\n                    }else res = min(res,cost[1]);\\n                    if(days[i-1]-30>=0){\\n                        res = min(res,cost[2] + dp[i-1][days[i-1]-30]);\\n                    } else res = min(res,cost[2]);\\n                    dp[i][j] = res;\\n\\n                } \\n                    \\n            }\\n        }\\n        return dp[n][day];\\n\\t\\t\\n\\t\\t}\\n        \\n//         if(n==0) return 0;\\n//         if(days[n-1] > day ){\\n//             return ks(days,n-1,cost,day);\\n//         }\\n//         return min( cost[0] + ks(days,n-1,cost,days[n-1]-1), min( cost[1] + ks(days,n-1,cost,days[n-1]-7),\\n//                                   cost[2] + ks(days,n-1,cost,days[n-1]-30) ) );\\n        \\n    \\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        return ks(days,days.size(),costs, days[days.size()-1]);     \\n    }",
                "solutionTags": [],
                "code": "\\n    \\n    int ks(vector<int> days, int n, vector<int> cost, int day){\\n                \\n        int dp[n+1][day+1];\\n        \\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<=day;j++){\\n                if(i==0) dp[i][j] = 0;\\n                else if(days[i-1]>j) dp[i][j] = dp[i-1][j];\\n                else{\\n                    int res = cost[0] + dp[i-1][days[i-1]-1];\\n                    if(days[i-1]-7>=0){\\n                        res = min(res,cost[1] + dp[i-1][days[i-1]-7]);         \\n                    }else res = min(res,cost[1]);\\n                    if(days[i-1]-30>=0){\\n                        res = min(res,cost[2] + dp[i-1][days[i-1]-30]);\\n                    } else res = min(res,cost[2]);\\n                    dp[i][j] = res;\\n\\n                } \\n                    \\n            }\\n        }\\n        return dp[n][day];\\n\\t\\t\\n\\t\\t}\\n        \\n//         if(n==0) return 0;\\n//         if(days[n-1] > day ){\\n//             return ks(days,n-1,cost,day);\\n//         }\\n//         return min( cost[0] + ks(days,n-1,cost,days[n-1]-1), min( cost[1] + ks(days,n-1,cost,days[n-1]-7),\\n//                                   cost[2] + ks(days,n-1,cost,days[n-1]-30) ) );\\n        \\n    \\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        return ks(days,days.size(),costs, days[days.size()-1]);     \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 293195,
                "title": "python-4-liner-dp-easy-to-understand-explanation",
                "content": "This solution runs in O(total number of days). The most optimal solution runs in O(30 days) because that is the most days a single ticket can cover, but since we\\'re told this problem only extends for 365 days, I just coded this solution up. If you want to understand the O(30) days one, https://leetcode.com/problems/minimum-cost-for-tickets/discuss/226659/Two-DP-solutions-with-pictures explains it quite well here. If the interviewer asks this question with an unlimited or very high number of days, you should implement the O(30) solution. If I have time, I will try to write it in Python. \\n\\nBeginner explanation for easy to code solution: If you do DP problems, you\\'ll notice most start with a 1D or 2D array. In this case, we can do this with a 1D array. We create a dparry with `number of days +1` elements so that we can have index 0 be 0. This is so we don\\'t run into out of bounds errors. \\n\\nFor day i, we look backward to see what kind of ticket we should buy. We look backward for i-1, i-7, i-30 days and see how much we already paid for tickets on those days and add the cost of one ticket for 1, 7, or 30 days. We\\'re looking to spend the least amount of money, so we look to take the value that is the smallest out of the three. \\n\\nThis is: \\n```\\nmin(dp[max(0, i-1)] + costs[0],  #min cost if we buy 1 day ticket for our current day\\n\\tdp[max(0, i-7)] + costs[1],  #min cost if we buy 7 day ticket for our current day, so we look 7 days previous to see what we paid\\n\\tdp[max(0, i-30)] + costs[2]) #min cost if we buy 30 day ticket for our current day, so we look 30 days previous to see what we paid\\n```\\n\\nIf during our for loop we loop through a day that isn\\'t one of our travel days, we just use the value in the prior index.  `else dp[max(0, i-1)]`\\n\\nSo, at every day we are on, we know that the minimum amount of money we need to spend on the days before us are all correct, so we just build on those results, one day at a time. We return the least amount of money, which is dp[-1]. \\n\\nCoding style tips: I use to do code that would look like: \"if i-1 >= 0, if i-7>= 0, if i-30 >=0\" clauses to make sure I wouldn\\'t go out of bounds for arrays, but if you use max(0, i-#) it makes the code look much better. \\n\\nRuntime + Space: O(number of days + 1)\\nI did try out totaldays = days[-1] and days = set(days) so that when we check if i is in days we\\'re not looping through the entire array and can just check O(1) for set, but the runtime is the same because we\\'re only checking 365 days max. \\n\\n```\\nclass Solution(object):\\n    def mincostTickets(self, days, costs):\\n        \"\"\"\\n        :type days: List[int]\\n        :type costs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [0 for i in range(days[-1] + 1)]\\n        for i in range(days[-1] + 1):\\n            dp[i] = min(dp[max(0, i-1)] + costs[0], dp[max(0, i-7)] + costs[1], dp[max(0, i-30)] + costs[2]) if i in days else dp[max(0, i-1)]\\n        return dp[-1]\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nmin(dp[max(0, i-1)] + costs[0],  #min cost if we buy 1 day ticket for our current day\\n\\tdp[max(0, i-7)] + costs[1],  #min cost if we buy 7 day ticket for our current day, so we look 7 days previous to see what we paid\\n\\tdp[max(0, i-30)] + costs[2]) #min cost if we buy 30 day ticket for our current day, so we look 30 days previous to see what we paid\\n```\n```\\nclass Solution(object):\\n    def mincostTickets(self, days, costs):\\n        \"\"\"\\n        :type days: List[int]\\n        :type costs: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [0 for i in range(days[-1] + 1)]\\n        for i in range(days[-1] + 1):\\n            dp[i] = min(dp[max(0, i-1)] + costs[0], dp[max(0, i-7)] + costs[1], dp[max(0, i-30)] + costs[2]) if i in days else dp[max(0, i-1)]\\n        return dp[-1]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 273012,
                "title": "python-dp",
                "content": "For each day that we need to travel, we can use either 1/7/30-day pass depend on the cost.\\n\\nSuppose ```dp[i]``` is the lowest cost till ```day i``` and ```one```, ```seven```, ```thirty``` are costs for 1-day, 7-day, 30-day pass accordingly. \\nIf ```day i``` is when we have to travel, we need to use a ticket, then ```dp[i] = min(dp[i-1]+one, dp[i-7]+seven, dp[i-30]+thirty)```. \\nOtherwise, we don\\'t need a ticket so there\\'s no extra cost, ```dp[i] = dp[i-1]```.\\n\\nAnd when i<7 or i<30, 7 and 30-day pass are still possible to lower down our cost, so I use ```dp[max(i-7), 0]+seven``` and ```dp[max(i-30),0]+thirty``` instead. In that case, we just buy a 7/30-day pass on day 0.\\n```\\ndef mincostTickets(days, costs):\\n\\tn, plans, days = max(days)+1, [1,7,30], set(days)\\n\\tdp = [0] * n\\n\\tfor i in range(n):\\n\\t\\tdp[i] = min((dp[max(0,i-p)]+c for p,c in zip(plans, costs))) if i in days else dp[i-1]\\n\\treturn dp[n-1]\\n```\\n\\nAnd actually we don\\'t have to iterate those days we don\\'t travel, especially for those large and sparse cases. \\nI use ```dp[prev:curr] = [dp[prev]] * (curr-prev)``` to reduce number of iteration as ```dp[i]=dp[i-1]``` when we don\\'t travel. Therefore, we only need to iterate the days we do travel.\\n```\\ndef mincostTickets(days, costs):\\n\\tdp, prev, plans = [0] * (max(days) + 1), 0, [1,7,30]\\n\\tfor curr in days:\\n\\t\\tdp[prev:curr] = [dp[prev]] * (curr-prev)\\n\\t\\tdp[curr], prev = min(dp[max(curr-p, 0)]+c for p,c in zip(plans, costs)), curr\\n\\treturn dp[-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```dp[i]```\n```day i```\n```one```\n```seven```\n```thirty```\n```day i```\n```dp[i] = min(dp[i-1]+one, dp[i-7]+seven, dp[i-30]+thirty)```\n```dp[i] = dp[i-1]```\n```dp[max(i-7), 0]+seven```\n```dp[max(i-30),0]+thirty```\n```\\ndef mincostTickets(days, costs):\\n\\tn, plans, days = max(days)+1, [1,7,30], set(days)\\n\\tdp = [0] * n\\n\\tfor i in range(n):\\n\\t\\tdp[i] = min((dp[max(0,i-p)]+c for p,c in zip(plans, costs))) if i in days else dp[i-1]\\n\\treturn dp[n-1]\\n```\n```dp[prev:curr] = [dp[prev]] * (curr-prev)```\n```dp[i]=dp[i-1]```\n```\\ndef mincostTickets(days, costs):\\n\\tdp, prev, plans = [0] * (max(days) + 1), 0, [1,7,30]\\n\\tfor curr in days:\\n\\t\\tdp[prev:curr] = [dp[prev]] * (curr-prev)\\n\\t\\tdp[curr], prev = min(dp[max(curr-p, 0)]+c for p,c in zip(plans, costs)), curr\\n\\treturn dp[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 245595,
                "title": "java-easy-to-understand-dp-solution-3ms-beats-100",
                "content": "```\\npublic int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int days_cost[] = new int[366];\\n        for(int i = 0; i < days.length; i++)\\n            days_cost[days[i]] = 1;\\n        \\n        for(int i = 1; i < 366; i++) {\\n            if(days_cost[i] == 0)\\n                days_cost[i] = days_cost[i - 1];\\n            else\\n                days_cost[i] = Math.min(costs[0] + days_cost[i - 1], Math.min(costs[1] + days_cost[Math.max(0, i - 7)], \\n                                                                             costs[2] + days_cost[Math.max(0, i - 30)]));\\n        }\\n        \\n        return days_cost[days[n - 1]];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int days_cost[] = new int[366];\\n        for(int i = 0; i < days.length; i++)\\n            days_cost[days[i]] = 1;\\n        \\n        for(int i = 1; i < 366; i++) {\\n            if(days_cost[i] == 0)\\n                days_cost[i] = days_cost[i - 1];\\n            else\\n                days_cost[i] = Math.min(costs[0] + days_cost[i - 1], Math.min(costs[1] + days_cost[Math.max(0, i - 7)], \\n                                                                             costs[2] + days_cost[Math.max(0, i - 30)]));\\n        }\\n        \\n        return days_cost[days[n - 1]];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237632,
                "title": "4ms-solution-in-c",
                "content": "Thanks to https://leetcode.com/problems/minimum-cost-for-tickets/discuss/226670/Java-DP-Solution-with-explanation-O(n).\\n```\\nint min(int x, int y, int z)\\n{\\n    if (x < y)\\n        return x < z ? x : z;\\n    return y < z ? y : z;\\n}\\n\\nint max(int x, int y) { return x > y ? x : y; }\\n\\nint mincostTickets(int *days, int daysSize, int *costs, int costsSize)\\n{\\n    bool day_list[366] = { false };\\n    int dp[366];\\n\\n    for (int i = 0; i < daysSize; ++i)\\n        day_list[days[i]] = true;\\n\\n    dp[0] = 0;\\n    for (int i = 1; i < 366; ++i) {\\n        if (!day_list[i]) {\\n            dp[i] = dp[i - 1];\\n            continue;\\n        }\\n\\n        dp[i] = min(dp[i - 1] + costs[0],\\n                    dp[max(0, i - 7)] + costs[1],\\n                    dp[max(0, i - 30)] + costs[2]);\\n    }\\n\\n    return dp[365];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint min(int x, int y, int z)\\n{\\n    if (x < y)\\n        return x < z ? x : z;\\n    return y < z ? y : z;\\n}\\n\\nint max(int x, int y) { return x > y ? x : y; }\\n\\nint mincostTickets(int *days, int daysSize, int *costs, int costsSize)\\n{\\n    bool day_list[366] = { false };\\n    int dp[366];\\n\\n    for (int i = 0; i < daysSize; ++i)\\n        day_list[days[i]] = true;\\n\\n    dp[0] = 0;\\n    for (int i = 1; i < 366; ++i) {\\n        if (!day_list[i]) {\\n            dp[i] = dp[i - 1];\\n            continue;\\n        }\\n\\n        dp[i] = min(dp[i - 1] + costs[0],\\n                    dp[max(0, i - 7)] + costs[1],\\n                    dp[max(0, i - 30)] + costs[2]);\\n    }\\n\\n    return dp[365];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 237530,
                "title": "python-straight-forward-dp-solution-100",
                "content": "```\\nclass Solution:\\n    def mincostTickets(self, days: \\'List[int]\\', costs: \\'List[int]\\') -> \\'int\\':\\n        # min cost for travelling till day i\\n        dp = [float(\\'inf\\')] * (days[-1] + 1)\\n        dp[0] = 0\\n        travel_days = set(days)\\n        for i in range(1, days[-1] + 1):\\n            if i not in travel_days:\\n                dp[i] = dp[i - 1]\\n            else:\\n                # 1-day pass\\n                dp[i] = min(dp[i], dp[i - 1] + costs[0])\\n                \\n                # 7-day pass\\n                if i <= 7:\\n                    dp[i] = min(dp[i], costs[1])\\n                else:\\n                    dp[i] = min(dp[i], dp[i - 7] + costs[1])\\n                    \\n                # 30-day pass\\n                if i <= 30:\\n                    dp[i] = min(dp[i], costs[2])\\n                else:\\n                    dp[i] = min(dp[i], dp[i - 30] + costs[2])\\n        return dp[-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mincostTickets(self, days: \\'List[int]\\', costs: \\'List[int]\\') -> \\'int\\':\\n        # min cost for travelling till day i\\n        dp = [float(\\'inf\\')] * (days[-1] + 1)\\n        dp[0] = 0\\n        travel_days = set(days)\\n        for i in range(1, days[-1] + 1):\\n            if i not in travel_days:\\n                dp[i] = dp[i - 1]\\n            else:\\n                # 1-day pass\\n                dp[i] = min(dp[i], dp[i - 1] + costs[0])\\n                \\n                # 7-day pass\\n                if i <= 7:\\n                    dp[i] = min(dp[i], costs[1])\\n                else:\\n                    dp[i] = min(dp[i], dp[i - 7] + costs[1])\\n                    \\n                # 30-day pass\\n                if i <= 30:\\n                    dp[i] = min(dp[i], costs[2])\\n                else:\\n                    dp[i] = min(dp[i], dp[i - 30] + costs[2])\\n        return dp[-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 227412,
                "title": "java-solution-dfs-with-memory-dp-solution",
                "content": "I was not able to come up with the DP solution at first. Therefore, I used a hashmap to record calculated data along the way. \\nThe solution still beat 50%, so I\\'d like to share it for reference.\\n```\\nclass Solution {\\n    Map<Integer, Integer> cache = new HashMap<>();\\n    \\n    public int mincostTickets(int[] days, int[] costs) {\\n        return dfs(days, 0, costs, -1);\\n    }\\n    \\n    private int dfs(int[] days, int index, int[] costs, int endDay) {\\n        if (index == days.length) {\\n            return 0;\\n        }\\n        if (endDay >= days[index]) {\\n            return dfs(days, index + 1, costs, endDay);\\n        } else if (cache.containsKey(days[index])) {\\n            return cache.get(days[index]);\\n        } else {\\n            int cost0 = costs[0] + dfs(days, index + 1, costs, days[index]);\\n            int cost1 = costs[1] + dfs(days, index + 1, costs, days[index] + 6);\\n            int cost2 = costs[2] + dfs(days, index + 1, costs, days[index] + 29);\\n            int minCost = Math.min(cost0, Math.min(cost1, cost2));\\n            cache.put(days[index], minCost);\\n            return minCost;\\n        }\\n    }\\n}\\n```\\n\\nDP solution attached. Considering the input length `n <= 365`, the space complexity can be treated as `O(1)`. Time complexity is tricky, it can be treated as O(1) becasue each day can be iterated at most `30 + 7` times, and there are at most 365 days. Or we can treat it as O(n).\\n```\\nclass Solution {\\n    \\n    public int mincostTickets(int[] days, int[] costs) {\\n        if (days == null || days.length == 0) {\\n            return 0;\\n        }\\n        int n = days.length;\\n        int[][] dp = new int[n][3];\\n        for (int i = 0; i < 3; i++) {\\n            dp[0][i] = costs[i];\\n        }\\n        for (int i = 1; i < n; i++) {\\n            int today = days[i];\\n            int cost0 = dp[i - 1][0] + costs[0];\\n            for (int j = i - 1; j >= 0 && days[j] + 30 > today; j--) {\\n                cost0 = Math.min(cost0, dp[j][2]);\\n            }\\n            for (int j = i - 1; j >= 0 && days[j] + 7 > today; j--) {\\n                cost0 = Math.min(cost0, dp[j][1]);\\n            }\\n            dp[i][0] = cost0;\\n            dp[i][1] = dp[i - 1][0] + costs[1];\\n            dp[i][2] = dp[i - 1][0] + costs[2];\\n        }\\n        return dp[n - 1][0];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> cache = new HashMap<>();\\n    \\n    public int mincostTickets(int[] days, int[] costs) {\\n        return dfs(days, 0, costs, -1);\\n    }\\n    \\n    private int dfs(int[] days, int index, int[] costs, int endDay) {\\n        if (index == days.length) {\\n            return 0;\\n        }\\n        if (endDay >= days[index]) {\\n            return dfs(days, index + 1, costs, endDay);\\n        } else if (cache.containsKey(days[index])) {\\n            return cache.get(days[index]);\\n        } else {\\n            int cost0 = costs[0] + dfs(days, index + 1, costs, days[index]);\\n            int cost1 = costs[1] + dfs(days, index + 1, costs, days[index] + 6);\\n            int cost2 = costs[2] + dfs(days, index + 1, costs, days[index] + 29);\\n            int minCost = Math.min(cost0, Math.min(cost1, cost2));\\n            cache.put(days[index], minCost);\\n            return minCost;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    \\n    public int mincostTickets(int[] days, int[] costs) {\\n        if (days == null || days.length == 0) {\\n            return 0;\\n        }\\n        int n = days.length;\\n        int[][] dp = new int[n][3];\\n        for (int i = 0; i < 3; i++) {\\n            dp[0][i] = costs[i];\\n        }\\n        for (int i = 1; i < n; i++) {\\n            int today = days[i];\\n            int cost0 = dp[i - 1][0] + costs[0];\\n            for (int j = i - 1; j >= 0 && days[j] + 30 > today; j--) {\\n                cost0 = Math.min(cost0, dp[j][2]);\\n            }\\n            for (int j = i - 1; j >= 0 && days[j] + 7 > today; j--) {\\n                cost0 = Math.min(cost0, dp[j][1]);\\n            }\\n            dp[i][0] = cost0;\\n            dp[i][1] = dp[i - 1][0] + costs[1];\\n            dp[i][2] = dp[i - 1][0] + costs[2];\\n        }\\n        return dp[n - 1][0];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226994,
                "title": "the-easiest-way-c-with-simple-array",
                "content": "everyday from Jan 1 to itself either cost   1-day ticket + yesterday\\'s cost      or         7-day ticket + the cost 7 day\\'s ago             or                30-day ticket + the cost 30 day\\'s before\\nso the solution below :\\n\\nfrom day 1 to day 6  can only buy a one day ticket\\n```\\nfor(int i = 1;i < 7;++i){\\n\\tanswer[i] = answer[i - 1] + need[i] * costs[0];// another array bool need[366] stores whether you\\'ll travel or not\\n}\\n```\\nfrom day 7 to day 29 you may have two choices : one-day ticket    or   7-day ticket\\n```\\nfor(int i = 7;i < 30;++i){\\n\\tanswer[i] = min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]);\\n}\\n```\\nand all the other days you have three choices \\ncode below : \\n```\\nfor(int i = 30;i < 366;++i){\\n\\tanswer[i] = min(min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]), answer[i - 30] + costs[2]);\\n}\\n```\\n\\nthe full code is here : \\n```\\nclass Solution {\\npublic:\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int answer[366] = {};\\n        bool need[366] = {};\\n        for(auto &i : days)need[i] = true;\\n        for(int i = 1;i < 7;++i){\\n        \\tanswer[i] = answer[i - 1] + need[i] * costs[0];\\n        }\\n        for(int i = 7;i < 30;++i){\\n        \\tanswer[i] = min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]);\\n        }\\n        for(int i = 30;i < 366;++i){\\n        \\tanswer[i] = min(min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]), answer[i - 30] + costs[2]);\\n        }\\n        return answer[365];\\n    }\\n};\\n```\\n\\n\\nor just simply add 30 space days infront of Jan 1st and use the third `if else`\\n\\n```\\nclass Solution {\\npublic:\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int answer[396] = {};\\n        bool need[396] = {};\\n        for(auto &i : days)need[i + 30] = true;\\n        for(int i = 30;i < 396;++i){\\n        \\tanswer[i] = min(min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]), answer[i - 30] + costs[2]);\\n        }\\n        return answer[395];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfor(int i = 1;i < 7;++i){\\n\\tanswer[i] = answer[i - 1] + need[i] * costs[0];// another array bool need[366] stores whether you\\'ll travel or not\\n}\\n```\n```\\nfor(int i = 7;i < 30;++i){\\n\\tanswer[i] = min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]);\\n}\\n```\n```\\nfor(int i = 30;i < 366;++i){\\n\\tanswer[i] = min(min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]), answer[i - 30] + costs[2]);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int answer[366] = {};\\n        bool need[366] = {};\\n        for(auto &i : days)need[i] = true;\\n        for(int i = 1;i < 7;++i){\\n        \\tanswer[i] = answer[i - 1] + need[i] * costs[0];\\n        }\\n        for(int i = 7;i < 30;++i){\\n        \\tanswer[i] = min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]);\\n        }\\n        for(int i = 30;i < 366;++i){\\n        \\tanswer[i] = min(min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]), answer[i - 30] + costs[2]);\\n        }\\n        return answer[365];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int answer[396] = {};\\n        bool need[396] = {};\\n        for(auto &i : days)need[i + 30] = true;\\n        for(int i = 30;i < 396;++i){\\n        \\tanswer[i] = min(min(answer[i - 1] + need[i] * costs[0], answer[i - 7] + costs[1]), answer[i - 30] + costs[2]);\\n        }\\n        return answer[395];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 226710,
                "title": "java-solution-using-dp",
                "content": "\\tpublic int mincostTickets(int[] days, int[] costs) {\\n        int dp[] = new int[366];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n\\n        for (int i = 0; i < days.length; i++) {\\n            dp[days[i]] = 1;\\n        }\\n        dp[0] = 0;\\n        for (int i = 1; i < 366; i++) {\\n            if(dp[i] == Integer.MAX_VALUE) {\\n                dp[i] = dp[i-1];\\n                \\n            } else {\\n                dp[i] = dp[i-1] + costs[0];\\n            }\\n            if(i>=7) {\\n                dp[i] = Math.min(dp[i], dp[i-7] + costs[1]);\\n            }\\n            if(i>=30) {\\n                dp[i] = Math.min(dp[i], dp[i - 30] + costs[2]);\\n            }\\n        }\\n        return dp[365];\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int mincostTickets(int[] days, int[] costs) {\\n        int dp[] = new int[366];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n\\n        for (int i = 0; i < days.length; i++) {\\n            dp[days[i]] = 1;\\n        }\\n        dp[0] = 0;\\n        for (int i = 1; i < 366; i++) {\\n            if(dp[i] == Integer.MAX_VALUE) {\\n                dp[i] = dp[i-1];\\n                \\n            } else {\\n                dp[i] = dp[i-1] + costs[0];\\n            }\\n            if(i>=7) {\\n                dp[i] = Math.min(dp[i], dp[i-7] + costs[1]);\\n            }\\n            if(i>=30) {\\n                dp[i] = Math.min(dp[i], dp[i - 30] + costs[2]);\\n            }\\n        }\\n        return dp[365];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3954095,
                "title": "recursive-solution-dp-explanation-cpp",
                "content": "Here we are exploring all possible combinations of passes and selecting the one that results in the minimum cost.\\n \\nIf the current day (days[index]) is before or on the last day for which a pass was purchased (lastValidDay), we don\\'t need to buy any pass for the current day. We move to the next day (index + 1) and make a recursive call with the same lastValidDay.\\n\\nIf the current day is after the lastValidDay, we have three options to consider for buying passes:\\n1. Buy a one-day pass for the current day and move to the next day (index + 1).\\n2. Buy a seven-day pass starting from the current day and move to the day seven days later (index + 1, and lastValidDay + 6).\\n3. Buy a thirty-day pass starting from the current day and move to the day thirty days later (index + 1, and lastValidDay + 29).\\n\\nRecursive Solution\\n```\\nclass Solution {\\n    int solve(vector<int> &days, vector<int> &costs, int index, int lastValidDay){\\n        if(index == days.size()){\\n            return 0;\\n        }\\n        \\n        if(days[index] <= lastValidDay){\\n            return solve(days, costs, index + 1, lastValidDay);\\n        }\\n        \\n        int oneDayPass = costs[0] + solve(days, costs, index + 1, days[index]);\\n        int weekPass = costs[1] + solve(days, costs, index + 1, days[index] + 6);\\n        int monthPass = costs[2] + solve(days, costs, index + 1, days[index] + 29);\\n        \\n        return min(oneDayPass, min(weekPass, monthPass));\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        return solve(days, costs, 0, -1e9);\\n    }\\n};\\n```\\nTC - O(3^n)\\n\\nBottom Up approach\\nshifting of indices in bottom up approach to handle the case of -1\\n-1 0 1 2 3 ... n-1\\n 0 1 2 3 4 ... n\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (1001, 0));\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            for(int lastValidDay = days[n-1]; lastValidDay >= -1; lastValidDay--){\\n                if(days[i] <= lastValidDay){\\n                    dp[i][lastValidDay + 1] = dp[i + 1][lastValidDay + 1]; \\n                }else{\\n                    int oneDayPass = costs[0] + dp[i + 1][days[i] + 1];\\n                    int weekPass = costs[1] + dp[i + 1][days[i] + 6 + 1];\\n                    int monthPass = costs[2] + dp[i + 1][days[i] + 29 + 1];\\n                    \\n                    dp[i][lastValidDay + 1] = min(oneDayPass, min(weekPass, monthPass));\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    int solve(vector<int> &days, vector<int> &costs, int index, int lastValidDay){\\n        if(index == days.size()){\\n            return 0;\\n        }\\n        \\n        if(days[index] <= lastValidDay){\\n            return solve(days, costs, index + 1, lastValidDay);\\n        }\\n        \\n        int oneDayPass = costs[0] + solve(days, costs, index + 1, days[index]);\\n        int weekPass = costs[1] + solve(days, costs, index + 1, days[index] + 6);\\n        int monthPass = costs[2] + solve(days, costs, index + 1, days[index] + 29);\\n        \\n        return min(oneDayPass, min(weekPass, monthPass));\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        return solve(days, costs, 0, -1e9);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<vector<int>> dp(n + 1, vector<int> (1001, 0));\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            for(int lastValidDay = days[n-1]; lastValidDay >= -1; lastValidDay--){\\n                if(days[i] <= lastValidDay){\\n                    dp[i][lastValidDay + 1] = dp[i + 1][lastValidDay + 1]; \\n                }else{\\n                    int oneDayPass = costs[0] + dp[i + 1][days[i] + 1];\\n                    int weekPass = costs[1] + dp[i + 1][days[i] + 6 + 1];\\n                    int monthPass = costs[2] + dp[i + 1][days[i] + 29 + 1];\\n                    \\n                    dp[i][lastValidDay + 1] = min(oneDayPass, min(weekPass, monthPass));\\n                }\\n            }\\n        }\\n        return dp[0][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807067,
                "title": "c-apni-bhasha-mein-easy-explanation-dp-interview-prep",
                "content": "# Intuition & Approach\\n- Explained in the code\\n\\n# Complexity\\n- Time complexity:$O(lastDay+1)$\\n\\n- Space complexity:$O(lastDay+1)$\\n\\n# Code\\n```\\nclass Solution\\n{\\n    public:\\n       LOGIC\\n\\n    KARNA KYA HAIN\\u2753\\n    1. We are given some integers in the list days.\\n    2. We can travel if we have a valid train ticket for that day.\\n    3. There are three ticket options.\\n    -  valid for 1 day at costs[0] dollars.\\n    -  valid for 7 day at costs[1] dollars.\\n    -  valid for 30 day at costs[2] dollars.\\n    4. We need to return the min cost that is required to travel on every day that\\n       is  given.\\n\\n    INTUITION & APPROACH\\n    1. 2 important things to notice in this problem\\n    - As we iterate we have to decide ki whether for that day we have a valid pass\\n    or we have to buy one.\\n    - Also we need to decide which ticket to buy which affects future decisions.\\n\\n    2. So this is a problem of DP and Recursion\\n    Why\\u2753\\n    - Each decision we make is affected by previous decision we made.\\n    - The problem is asking to find the minimum cost required.\\n\\n    3. Agar hamare paas ticket hain jis din ham travel kar rahe to koi dikkat nahin\\n    aage wale din check karenge is din koi extra cost nahin.\\n    4. Agar ticket nahin hain to hamare paas 3 choices hongi 1,7 and 30 day passed.\\n    5. Baari Baari se recursive call karenge aur teeno ka min nikalnege.\\n    \\uD83D\\uDCA5Recurrence relation mentioned in memoization code.\\n    6. The parameter which is changing is the currDay.\\n    7. BASE CASE :- currDay>days[days.length-1] return 0.\\n    8. We will create a hash set which will contain days on which we travel.\\n    9. In recursiveFunction we will check the currDay in this hash set and decide\\n    if we have the valid ticket or not.\\n    10. RECURSION -> MEMOIZATION -> TABULATION \\n    11. MEMOIZATION STEPS\\n    - Which parameter is changing\\n    - Declare dp array\\n    - Store the dp values\\n    - Check if the dp value is already stored.\\n    12. TABULATION\\n    - In this we will not keep a hash set but a variable i.\\n    - i will keep track of the days we have to visit.\\n    - While iterating the days from 1 to the largest day possible we will check it\\n    with index i if the day is smaller than days[i] if yes then this day is valid,\\n    cost is same as that of prev day and no extra cost is incurred otherwise \\n    we will check all three day passed and find min.\\n\\n//=========================================================================================================\\n\\n       \\t//MEMOIZATION SOLUTION\\n        unordered_set<int> isTicketValid;\\n    int Memoization(vector<int> &dp, vector<int> &days, vector< int > &costs, int currDay)\\n    {\\n        if (currDay > days[days.size() - 1])\\n        //BASE CASE\\n        //If the current day exceeds last Day\\n            return 0;\\n        if (dp[currDay] != -1)\\n        //If we have already calculated the val for currDay\\n            return dp[currDay];\\n        if (isTicketValid.find(currDay) == isTicketValid.end())\\n        //Checking if the currDay is a day on which we had to travel\\n            return Memoization(dp, days, costs, currDay + 1);\\n        int oneDay = costs[0] + Memoization(dp, days, costs, currDay + 1);\\n        //One day path\\n        int sevenDay = costs[1] + Memoization(dp, days, costs, currDay + 7);\\n        //seven day path\\n        int thirtyDay = costs[2] + Memoization(dp, days, costs, currDay + 30);\\n        //thirty day path\\n        return dp[currDay] = min(oneDay, min(sevenDay, thirtyDay));\\n        //min of all paths\\n    }\\n    int mincostTickets(vector<int> &days, vector<int> &costs)\\n    {\\n        int lastDay = days[days.size() - 1];\\n        vector<int> dp(lastDay + 1, -1);\\n        for (auto i: days)\\n        {\\n            isTicketValid.insert(i);\\n            //Creating valid days hash set\\n        }\\n        return Memoization(dp, days, costs, 1);\\n    }\\n//==============================================================================================================================\\n   \\t//TABULATION\\n    int mincostTickets(vector<int> &days, vector<int> &costs)\\n    {\\n        int lastDay = days[days.size() - 1];\\n        vector<int> dp(lastDay + 1, 0);\\n        int index = 0;\\n        //Index tracking valid days\\n        for (int day = 1; day <= lastDay; day++)\\n        {\\n            if (day < days[index])\\n            {\\n                dp[day] = dp[day - 1];\\n                //If the day is smaller than valid day so no extra cost\\n            }\\n            else\\n            {\\n                index++;\\n                //If day exceeds valid days\\n                //Checking cost of all paths\\n                int oneDay = costs[0] + dp[day - 1];\\n                int sevenDay = costs[1] + dp[max(0, day - 7)];\\n                int thirtyDay = costs[2] + dp[max(0, day - 30)];\\n                //Min of all paths\\n                dp[day] = min(oneDay, min(sevenDay, thirtyDay));\\n            }\\n        }\\n        return dp[lastDay];\\n    }\\n};\\n```\\nIf you *like* \\uD83D\\uDC4D this solution do *upvote* \\u2B06\\uFE0F and if there is any *improvement or suggestion* do mention it in the *comment* section \\uD83D\\uDE0A.\\n<p align=\"center\">\\n<img src=\"https://assets.leetcode.com/users/images/1b604300-df68-46aa-a267-71f38463bb89_1684820402.7869222.jpeg\" width=\\'350\\' alt=\"Upvote Image\">\\n</p>",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n       LOGIC\\n\\n    KARNA KYA HAIN\\u2753\\n    1. We are given some integers in the list days.\\n    2. We can travel if we have a valid train ticket for that day.\\n    3. There are three ticket options.\\n    -  valid for 1 day at costs[0] dollars.\\n    -  valid for 7 day at costs[1] dollars.\\n    -  valid for 30 day at costs[2] dollars.\\n    4. We need to return the min cost that is required to travel on every day that\\n       is  given.\\n\\n    INTUITION & APPROACH\\n    1. 2 important things to notice in this problem\\n    - As we iterate we have to decide ki whether for that day we have a valid pass\\n    or we have to buy one.\\n    - Also we need to decide which ticket to buy which affects future decisions.\\n\\n    2. So this is a problem of DP and Recursion\\n    Why\\u2753\\n    - Each decision we make is affected by previous decision we made.\\n    - The problem is asking to find the minimum cost required.\\n\\n    3. Agar hamare paas ticket hain jis din ham travel kar rahe to koi dikkat nahin\\n    aage wale din check karenge is din koi extra cost nahin.\\n    4. Agar ticket nahin hain to hamare paas 3 choices hongi 1,7 and 30 day passed.\\n    5. Baari Baari se recursive call karenge aur teeno ka min nikalnege.\\n    \\uD83D\\uDCA5Recurrence relation mentioned in memoization code.\\n    6. The parameter which is changing is the currDay.\\n    7. BASE CASE :- currDay>days[days.length-1] return 0.\\n    8. We will create a hash set which will contain days on which we travel.\\n    9. In recursiveFunction we will check the currDay in this hash set and decide\\n    if we have the valid ticket or not.\\n    10. RECURSION -> MEMOIZATION -> TABULATION \\n    11. MEMOIZATION STEPS\\n    - Which parameter is changing\\n    - Declare dp array\\n    - Store the dp values\\n    - Check if the dp value is already stored.\\n    12. TABULATION\\n    - In this we will not keep a hash set but a variable i.\\n    - i will keep track of the days we have to visit.\\n    - While iterating the days from 1 to the largest day possible we will check it\\n    with index i if the day is smaller than days[i] if yes then this day is valid,\\n    cost is same as that of prev day and no extra cost is incurred otherwise \\n    we will check all three day passed and find min.\\n\\n//=========================================================================================================\\n\\n       \\t//MEMOIZATION SOLUTION\\n        unordered_set<int> isTicketValid;\\n    int Memoization(vector<int> &dp, vector<int> &days, vector< int > &costs, int currDay)\\n    {\\n        if (currDay > days[days.size() - 1])\\n        //BASE CASE\\n        //If the current day exceeds last Day\\n            return 0;\\n        if (dp[currDay] != -1)\\n        //If we have already calculated the val for currDay\\n            return dp[currDay];\\n        if (isTicketValid.find(currDay) == isTicketValid.end())\\n        //Checking if the currDay is a day on which we had to travel\\n            return Memoization(dp, days, costs, currDay + 1);\\n        int oneDay = costs[0] + Memoization(dp, days, costs, currDay + 1);\\n        //One day path\\n        int sevenDay = costs[1] + Memoization(dp, days, costs, currDay + 7);\\n        //seven day path\\n        int thirtyDay = costs[2] + Memoization(dp, days, costs, currDay + 30);\\n        //thirty day path\\n        return dp[currDay] = min(oneDay, min(sevenDay, thirtyDay));\\n        //min of all paths\\n    }\\n    int mincostTickets(vector<int> &days, vector<int> &costs)\\n    {\\n        int lastDay = days[days.size() - 1];\\n        vector<int> dp(lastDay + 1, -1);\\n        for (auto i: days)\\n        {\\n            isTicketValid.insert(i);\\n            //Creating valid days hash set\\n        }\\n        return Memoization(dp, days, costs, 1);\\n    }\\n//==============================================================================================================================\\n   \\t//TABULATION\\n    int mincostTickets(vector<int> &days, vector<int> &costs)\\n    {\\n        int lastDay = days[days.size() - 1];\\n        vector<int> dp(lastDay + 1, 0);\\n        int index = 0;\\n        //Index tracking valid days\\n        for (int day = 1; day <= lastDay; day++)\\n        {\\n            if (day < days[index])\\n            {\\n                dp[day] = dp[day - 1];\\n                //If the day is smaller than valid day so no extra cost\\n            }\\n            else\\n            {\\n                index++;\\n                //If day exceeds valid days\\n                //Checking cost of all paths\\n                int oneDay = costs[0] + dp[day - 1];\\n                int sevenDay = costs[1] + dp[max(0, day - 7)];\\n                int thirtyDay = costs[2] + dp[max(0, day - 30)];\\n                //Min of all paths\\n                dp[day] = min(oneDay, min(sevenDay, thirtyDay));\\n            }\\n        }\\n        return dp[lastDay];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3755833,
                "title": "o-1-dp-and-queue-solutions-fully-explained-from-scratch",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Explanation 1: DP**\\n1. Try to decode the problem and think for a recursive solution.\\n2. There are **three options** in this problem:\\n- Option 1: Take 1 day pass for each day\\n- Option 2: Take a 7 days pass for 7 consecutive days in a year.\\n- Option 3: Take a 30 days pass for 30 consecutive days in a year.\\n3.Let us see an example for better understanding:\\n**days[] = {2,5}, costs[] = {1,4,25}**\\n\\nHere is the recursion tree for this example:\\n![image.png](https://assets.leetcode.com/users/images/e113f90d-6946-45b5-86fe-c7996a238f43_1689179197.6838899.png)\\n\\n# Complexity\\n- Time complexity: **O(1)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe size of our dp vector is days.size() + 1, we know that in a year, there are 365 days (as per this question, leap year is not considered), therefore size of our dp vector can be atmost 365 + 1 = 366, this can obviously be accessed in a constant time.\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int solveMem(vector<int>& days, vector<int>& costs, vector<int>& dp, int index)\\n    {\\n        if(index >= days.size()) return 0;\\n\\n        if(dp[index] != -1) return dp[index];\\n\\n        //1 day pass\\n        int option1 = costs[0] + solveMem(days, costs, dp, index + 1);\\n\\n        int i;\\n\\n        //7 days pass\\n        for(i = index; i < days.size() && days[i] < days[index] + 7; i++);\\n        int option2 = costs[1] + solveMem(days, costs, dp, i);\\n\\n        //30 days pass\\n        for(i = index; i < days.size() && days[i] < days[index] + 30; i++);\\n        int option3 = costs[2] + solveMem(days, costs, dp, i);\\n\\n        dp[index] = min(option1, min(option2, option3));\\n\\n        return dp[index];\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> dp(days.size() + 1, -1);\\n\\n        int index = 0;\\n\\n        return solveMem(days, costs, dp, index);\\n    }\\n};\\n```\\n\\n# **Queue Solution**\\n\\n# Approach\\nSliding window.\\nMaximum size of month queue can be 30.\\nMaximum size of week queue can be 7.\\n\\n**Time and Space Complexity**: both are O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int ans = 0;\\n        queue<pair<int, int>> week, month;\\n\\n        //first part of the pair will indicate the day, and the second part will indicate the cost on this day\\n\\n        for(auto day : days)\\n        {\\n            //step 1 : remove expired elements from the queue\\n            while(!week.empty() && week.front().first + 7 <= day)\\n            {\\n                week.pop();\\n            }\\n            while(!month.empty() && month.front().first + 30 <= day)\\n            {\\n                month.pop();\\n            }\\n            \\n            //step 2: push current day\\'s cost\\n            week.push(make_pair(day, ans + costs[1]));\\n            month.push(make_pair(day, ans + costs[2]));\\n\\n            //step 3: update the ans\\n            ans = min(ans + costs[0], min(week.front().second, month.front().second));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Dynamic Programming",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solveMem(vector<int>& days, vector<int>& costs, vector<int>& dp, int index)\\n    {\\n        if(index >= days.size()) return 0;\\n\\n        if(dp[index] != -1) return dp[index];\\n\\n        //1 day pass\\n        int option1 = costs[0] + solveMem(days, costs, dp, index + 1);\\n\\n        int i;\\n\\n        //7 days pass\\n        for(i = index; i < days.size() && days[i] < days[index] + 7; i++);\\n        int option2 = costs[1] + solveMem(days, costs, dp, i);\\n\\n        //30 days pass\\n        for(i = index; i < days.size() && days[i] < days[index] + 30; i++);\\n        int option3 = costs[2] + solveMem(days, costs, dp, i);\\n\\n        dp[index] = min(option1, min(option2, option3));\\n\\n        return dp[index];\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> dp(days.size() + 1, -1);\\n\\n        int index = 0;\\n\\n        return solveMem(days, costs, dp, index);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int ans = 0;\\n        queue<pair<int, int>> week, month;\\n\\n        //first part of the pair will indicate the day, and the second part will indicate the cost on this day\\n\\n        for(auto day : days)\\n        {\\n            //step 1 : remove expired elements from the queue\\n            while(!week.empty() && week.front().first + 7 <= day)\\n            {\\n                week.pop();\\n            }\\n            while(!month.empty() && month.front().first + 30 <= day)\\n            {\\n                month.pop();\\n            }\\n            \\n            //step 2: push current day\\'s cost\\n            week.push(make_pair(day, ans + costs[1]));\\n            month.push(make_pair(day, ans + costs[2]));\\n\\n            //step 3: update the ans\\n            ans = min(ans + costs[0], min(week.front().second, month.front().second));\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3449475,
                "title": "memoization-c-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst wrote the basic recurssive code for the problem then just memoized it. When solving this type of problem , the best thing is try to first decide the states of the recurrsion and 90% of the job is done.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**pass** is the number of days the traveller has purchased the ticket i.e 1,7 or 30 days\\n        it seems like pass also constitutes a state of the dp. But we purchase ticket(1,7,or 30) \\n        every day if we don\\'t have ticket for that day.And then initialise the minimun cost for \\n        that day.\\n\\n      day is the iterator from 0 to days.size()-1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) \\nwhere n= days.size()\\nwe are calling the function for each day only once then its result is being stored.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) \\nExtra space for the memo table.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int travel(vector<int>& days, vector<int>& costs,int pass, int day,vector<int> &memo)\\n    {\\n        if(day>=days.size())  // when we have reached end of the array\\n            return 0;\\n        \\n        if(days[day]<=pass)   // if we have ticket for that day then we don\\'t purchase any and simply increment day\\n            return travel(days,costs,pass,day+1,memo);\\n\\n        if(memo[day]!=-1)     // memo table look up\\n            return memo[day];\\n\\n        //if we don\\'t have ticket for that day\\n\\n        int cst=0; // purchasing all types of ticket for a given day and choosing the minimum from them\\n        \\n        cst=costs[0]+travel(days,costs,days[day],day+1,memo);\\n        cst= min(cst, costs[1]+travel(days,costs,days[day]+6,day+1,memo));\\n        cst= min(cst,costs[2]+travel(days,costs,days[day]+29,day+1,memo));\\n\\n        memo[day]=cst;\\n\\n        return cst;\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        vector<int> memo(days.size(),-1);\\n\\n        return travel(days,costs,0,0,memo);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int travel(vector<int>& days, vector<int>& costs,int pass, int day,vector<int> &memo)\\n    {\\n        if(day>=days.size())  // when we have reached end of the array\\n            return 0;\\n        \\n        if(days[day]<=pass)   // if we have ticket for that day then we don\\'t purchase any and simply increment day\\n            return travel(days,costs,pass,day+1,memo);\\n\\n        if(memo[day]!=-1)     // memo table look up\\n            return memo[day];\\n\\n        //if we don\\'t have ticket for that day\\n\\n        int cst=0; // purchasing all types of ticket for a given day and choosing the minimum from them\\n        \\n        cst=costs[0]+travel(days,costs,days[day],day+1,memo);\\n        cst= min(cst, costs[1]+travel(days,costs,days[day]+6,day+1,memo));\\n        cst= min(cst,costs[2]+travel(days,costs,days[day]+29,day+1,memo));\\n\\n        memo[day]=cst;\\n\\n        return cst;\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        \\n        vector<int> memo(days.size(),-1);\\n\\n        return travel(days,costs,0,0,memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3353097,
                "title": "kotlin-o-n-solution-brute-force-to-memoized-dfs-and-tabulation",
                "content": "# Approach\\nApproach is to do a brute force, which is quite hard, but intuition is like this:\\n\\nAt given position i, we can do three things:\\n- buy a 1 day ticket\\n- buy a 7 day ticket\\n- buy a 30 day ticket\\n\\nThe trick is to jump to first next index where our ticket is expired. We can compute that by a loop, or a binary search (since our day array is sorted).\\n\\n# Complexity\\n- Time complexity:\\nApproximately $$O(n)$$ (+ a little overhead caused by next function calls)\\n\\n- Space complexity:\\n$$O(n)$$ at most allocated in call stack\\n\\n# Code - brute force dfs\\n```java []\\nclass Solution {\\n    private int[] days;\\n    private int[] costs;\\n    private final int DAY_1 = 0;\\n    private final int DAY_7 = 1;\\n    private final int DAY_30 = 2;\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        this.days = days;\\n        this.costs = costs;\\n        return dfs(0);\\n    }\\n\\n    private int dfs(int i) {\\n        if (i == days.length) return 0;\\n        return Math.min(\\n            Math.min(\\n                costs[DAY_1] + dfs(next(i, 1)), // buy 1 day ticket\\n                costs[DAY_7] + dfs(next(i, 7)) // buy 7 day ticket\\n            ),\\n            costs[DAY_30] + dfs(next(i, 30)) // buy 30 day ticket\\n        );\\n    }\\n\\n    private int next(int i, int ticket) {\\n        int low = i+1;\\n        int high = days.length;\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid+1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```\\n```kotlin []\\nclass Solution {\\n    private lateinit var days: IntArray\\n    private lateinit var costs: IntArray\\n    private val DAY_1 = 0\\n    private val DAY_7 = 1\\n    private val DAY_30 = 2\\n\\n    fun mincostTickets(days: IntArray, costs: IntArray): Int {\\n        this.days = days\\n        this.costs = costs\\n        return dfs(0)\\n    }\\n\\n    private fun dfs(i: Int): Int {\\n        if (i == days.size) return 0\\n        return minOf(\\n            costs[DAY_1] + dfs(next(i, 1)), // buy 1 day ticket\\n            costs[DAY_7] + dfs(next(i, 7)), // buy 7 day ticket\\n            costs[DAY_30] + dfs(next(i, 30)) // buy 30 day ticket\\n        )\\n    }\\n\\n    private fun next(i: Int, ticket: Int): Int {\\n        var low = i+1\\n        var high = days.size\\n        while (low < high) {\\n            val mid = (low + high) / 2\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid + 1\\n            } else {\\n                high = mid\\n            }\\n        }\\n\\n        return low\\n    }\\n}\\n```\\n\\nThis gives us a brute force algorithm, where we get optimal solution at index i. This means solution to a subproblem we can memoize.\\n\\n# Code - memoized dfs\\n\\n```\\nclass Solution {\\n    private int[] days;\\n    private int[] costs;\\n    private int[] memo;\\n    private final int DAY_1 = 0;\\n    private final int DAY_7 = 1;\\n    private final int DAY_30 = 2;\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        this.days = days;\\n        this.costs = costs;\\n        memo = new int[days.length];\\n        Arrays.fill(memo, -1);\\n        return dfs(0);\\n    }\\n\\n    private int dfs(int i) {\\n        if (i == days.length) return 0;\\n        if (memo[i] != -1) return memo[i];\\n        memo[i] = Math.min(\\n            Math.min(\\n                costs[DAY_1] + dfs(next(i, 1)), // buy 1 day ticket\\n                costs[DAY_7] + dfs(next(i, 7)) // buy 7 day ticket\\n            ),\\n            costs[DAY_30] + dfs(next(i, 30)) // buy 30 day ticket\\n        );\\n        return memo[i];\\n    }\\n\\n    private int next(int i, int ticket) {\\n        int low = i+1;\\n        int high = days.length;\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid+1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```\\nFrom this approach we can come up with DP algo with single foreach where we iterate from end to beginning, just like in the dfs. Answer at i would be minimum of:\\n\\n1. day1Cost + memo[i+1]\\n2. day7Cost + memo at first expired index\\n3. day30Cost + memo at first expired index\\n \\nThe answer is then at first index of memo.\\n\\n# Code - DP tabulation\\n```\\nclass Solution {\\n    private val DAY_1 = 0\\n    private val DAY_7 = 1\\n    private val DAY_30 = 2\\n\\n    fun mincostTickets(days: IntArray, costs: IntArray): Int {\\n        val memo = IntArray(days.size+1) { -1 }\\n        memo[memo.lastIndex] = 0\\n        for (i in days.size-1 downTo 0) {\\n            memo[i] = minOf(\\n                costs[DAY_1] + memo[i+1],\\n                costs[DAY_7] + memo[next(days, i, 7)],\\n                costs[DAY_30] + memo[next(days, i, 30)]\\n            )\\n        }\\n\\n        return memo[0]\\n    }\\n\\n    private fun next(days: IntArray, i: Int, ticket: Int): Int {\\n        var low = i+1\\n        var high = days.size\\n        while (low < high) {\\n            val mid = (low + high) / 2\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid + 1\\n            } else {\\n                high = mid\\n            }\\n        }\\n        return low\\n    }\\n}\\n```\\n\\n---\\n\\n\\n\\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F If you like this solution or find it helpful, please upvote this post. \\uD83D\\uDC4D\\uFE0F\\uD83D\\uDC4D\\uFE0F",
                "solutionTags": [
                    "Java",
                    "Kotlin",
                    "Dynamic Programming",
                    "Depth-First Search"
                ],
                "code": "```java []\\nclass Solution {\\n    private int[] days;\\n    private int[] costs;\\n    private final int DAY_1 = 0;\\n    private final int DAY_7 = 1;\\n    private final int DAY_30 = 2;\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        this.days = days;\\n        this.costs = costs;\\n        return dfs(0);\\n    }\\n\\n    private int dfs(int i) {\\n        if (i == days.length) return 0;\\n        return Math.min(\\n            Math.min(\\n                costs[DAY_1] + dfs(next(i, 1)), // buy 1 day ticket\\n                costs[DAY_7] + dfs(next(i, 7)) // buy 7 day ticket\\n            ),\\n            costs[DAY_30] + dfs(next(i, 30)) // buy 30 day ticket\\n        );\\n    }\\n\\n    private int next(int i, int ticket) {\\n        int low = i+1;\\n        int high = days.length;\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid+1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```\n```kotlin []\\nclass Solution {\\n    private lateinit var days: IntArray\\n    private lateinit var costs: IntArray\\n    private val DAY_1 = 0\\n    private val DAY_7 = 1\\n    private val DAY_30 = 2\\n\\n    fun mincostTickets(days: IntArray, costs: IntArray): Int {\\n        this.days = days\\n        this.costs = costs\\n        return dfs(0)\\n    }\\n\\n    private fun dfs(i: Int): Int {\\n        if (i == days.size) return 0\\n        return minOf(\\n            costs[DAY_1] + dfs(next(i, 1)), // buy 1 day ticket\\n            costs[DAY_7] + dfs(next(i, 7)), // buy 7 day ticket\\n            costs[DAY_30] + dfs(next(i, 30)) // buy 30 day ticket\\n        )\\n    }\\n\\n    private fun next(i: Int, ticket: Int): Int {\\n        var low = i+1\\n        var high = days.size\\n        while (low < high) {\\n            val mid = (low + high) / 2\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid + 1\\n            } else {\\n                high = mid\\n            }\\n        }\\n\\n        return low\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private int[] days;\\n    private int[] costs;\\n    private int[] memo;\\n    private final int DAY_1 = 0;\\n    private final int DAY_7 = 1;\\n    private final int DAY_30 = 2;\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        this.days = days;\\n        this.costs = costs;\\n        memo = new int[days.length];\\n        Arrays.fill(memo, -1);\\n        return dfs(0);\\n    }\\n\\n    private int dfs(int i) {\\n        if (i == days.length) return 0;\\n        if (memo[i] != -1) return memo[i];\\n        memo[i] = Math.min(\\n            Math.min(\\n                costs[DAY_1] + dfs(next(i, 1)), // buy 1 day ticket\\n                costs[DAY_7] + dfs(next(i, 7)) // buy 7 day ticket\\n            ),\\n            costs[DAY_30] + dfs(next(i, 30)) // buy 30 day ticket\\n        );\\n        return memo[i];\\n    }\\n\\n    private int next(int i, int ticket) {\\n        int low = i+1;\\n        int high = days.length;\\n        while (low < high) {\\n            int mid = (low + high) / 2;\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid+1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n        return low;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    private val DAY_1 = 0\\n    private val DAY_7 = 1\\n    private val DAY_30 = 2\\n\\n    fun mincostTickets(days: IntArray, costs: IntArray): Int {\\n        val memo = IntArray(days.size+1) { -1 }\\n        memo[memo.lastIndex] = 0\\n        for (i in days.size-1 downTo 0) {\\n            memo[i] = minOf(\\n                costs[DAY_1] + memo[i+1],\\n                costs[DAY_7] + memo[next(days, i, 7)],\\n                costs[DAY_30] + memo[next(days, i, 30)]\\n            )\\n        }\\n\\n        return memo[0]\\n    }\\n\\n    private fun next(days: IntArray, i: Int, ticket: Int): Int {\\n        var low = i+1\\n        var high = days.size\\n        while (low < high) {\\n            val mid = (low + high) / 2\\n            if (days[mid] < days[i] + ticket) {\\n                low = mid + 1\\n            } else {\\n                high = mid\\n            }\\n        }\\n        return low\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352860,
                "title": "java-solution-beats-100-recursive-approach",
                "content": "# Intuition \\nRecursion, Dynamic Programming\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        \\n        int dp[] = new int[days.length + 1];\\n        Arrays.fill(dp, -1);\\n        return f(days, costs, 0, dp);\\n    }\\n    int f (int days[], int cost[], int i, int dp[]) {\\n        if(i >= days.length)\\n            return 0;\\n\\n        if(dp[i] != -1)\\n            return dp[i];\\n        //day 1\\n        int option1 = cost[0] + f(days, cost, i + 1, dp);\\n    \\n        int j;\\n        //day 7\\n        for(j = i; j < days.length && days[j] < days[i] + 7; j++);\\n        int option2 = cost[1] + f(days, cost, j, dp);\\n\\n        //day 30\\n        //day 7\\n       \\n        for(j = i; j < days.length && days[j] < days[i] + 30; j++);\\n        int option3 = cost[2] + f(days, cost, j, dp);\\n\\n        return dp[i] = Math.min(option1, Math.min(option2, option3));\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        \\n        int dp[] = new int[days.length + 1];\\n        Arrays.fill(dp, -1);\\n        return f(days, costs, 0, dp);\\n    }\\n    int f (int days[], int cost[], int i, int dp[]) {\\n        if(i >= days.length)\\n            return 0;\\n\\n        if(dp[i] != -1)\\n            return dp[i];\\n        //day 1\\n        int option1 = cost[0] + f(days, cost, i + 1, dp);\\n    \\n        int j;\\n        //day 7\\n        for(j = i; j < days.length && days[j] < days[i] + 7; j++);\\n        int option2 = cost[1] + f(days, cost, j, dp);\\n\\n        //day 30\\n        //day 7\\n       \\n        for(j = i; j < days.length && days[j] < days[i] + 30; j++);\\n        int option3 = cost[2] + f(days, cost, j, dp);\\n\\n        return dp[i] = Math.min(option1, Math.min(option2, option3));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352821,
                "title": "python-short-and-clean-dp",
                "content": "# Approach\\nTL;DR, Same as [Official solution](https://leetcode.com/problems/minimum-cost-for-tickets/editorial/).\\n\\n# Complexity\\n- Time complexity: $$O(n * k)$$\\n\\n- Space complexity: $$O(n)$$\\n\\nwhere,\\n`n is length of days array`,\\n`k is length of costs array`.\\n\\n# Code\\nRecursive:\\n```python\\nclass Solution:\\n    def mincostTickets(self, days: list[int], costs: list[int]) -> int:\\n        @cache\\n        def min_cost(i: int) -> int:\\n            return min(\\n                min_cost(bisect.bisect_left(days, days[i] + d, i)) + c\\n                for d, c in zip((1, 7, 30), costs)\\n            ) if i < len(days) else 0\\n        \\n        return min_cost(0)\\n\\n\\n```\\n\\nIterative:\\n```python\\nclass Solution:\\n    def mincostTickets(self, days: list[int], costs: list[int]) -> int:\\n        dp = [0] * (len(days) + 1)\\n        for i, x in enumerate(days):\\n            dp[i + 1] = min(\\n                dp[bisect.bisect(days, x - d, 0, i)] + c\\n                for d, c in zip((1, 7, 30), costs)\\n            )\\n        return dp[-1]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def mincostTickets(self, days: list[int], costs: list[int]) -> int:\\n        @cache\\n        def min_cost(i: int) -> int:\\n            return min(\\n                min_cost(bisect.bisect_left(days, days[i] + d, i)) + c\\n                for d, c in zip((1, 7, 30), costs)\\n            ) if i < len(days) else 0\\n        \\n        return min_cost(0)\\n\\n\\n```\n```python\\nclass Solution:\\n    def mincostTickets(self, days: list[int], costs: list[int]) -> int:\\n        dp = [0] * (len(days) + 1)\\n        for i, x in enumerate(days):\\n            dp[i + 1] = min(\\n                dp[bisect.bisect(days, x - d, 0, i)] + c\\n                for d, c in zip((1, 7, 30), costs)\\n            )\\n        return dp[-1]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3352059,
                "title": "c-tabulation-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. There are two cases whether a person buys a ticket on a particular day or not .\\n2. If he does not buy a ticket there must be a day prior to that day \\nsuch that the ticket bought on that day covers today . Choose minimum\\ncost from those .(Second Loop) .\\n3. If he buys a ticket we consider all three cases and add to minimum cost till now .\\n\\n# Complexity\\n- Time complexity:\\nO(n*n) \\n\\n- Space complexity:\\nO(4*n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        //dp[i][j] where j can be 0 , 1 , 2 , 3\\n\\n        vector<vector<int>> dp(366,vector<int>(4,INT_MAX)) ;\\n\\n        int n = days.size() ;\\n\\n        dp[days[0]][0] = INT_MAX ;\\n        dp[days[0]][1] = costs[0] , dp[days[0]][2] = costs[1] , dp[days[0]][3] = costs[2] ;\\n\\n        for(int i = 1 ; i < n ; i++){\\n\\n            int mini = min(dp[days[i-1]][1],min(dp[days[i-1]][2],dp[days[i-1]][3])) ;\\n\\n            if(dp[days[i-1]][0] != INT_MAX)\\n            {\\n                dp[days[i]][1] = min(dp[days[i-1]][0],mini) + costs[0] ;\\n                dp[days[i]][2] = min(dp[days[i-1]][0],mini) + costs[1] ;\\n                dp[days[i]][3] = min(dp[days[i-1]][0],mini) + costs[2] ;\\n            }\\n            else{\\n                dp[days[i]][1] = mini + costs[0] ;\\n                dp[days[i]][2] = mini + costs[1] ;\\n                dp[days[i]][3] = mini + costs[2] ;\\n            }\\n\\n            for(int j = 0 ; j < i ; j++){\\n                if(days[j] + 7 > days[i]){\\n                    dp[days[i]][0] = min(dp[days[i]][0],dp[days[j]][2]) ;\\n                }\\n                if(days[j] + 30 > days[i]){\\n                    dp[days[i]][0] = min(dp[days[i]][0],dp[days[j]][3]) ;\\n                }\\n            }\\n        }\\n\\n        return \\n        min(dp[days[n-1]][0],min(dp[days[n-1]][1],min(dp[days[n-1]][2],dp[days[n-1]][3]))) ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        //dp[i][j] where j can be 0 , 1 , 2 , 3\\n\\n        vector<vector<int>> dp(366,vector<int>(4,INT_MAX)) ;\\n\\n        int n = days.size() ;\\n\\n        dp[days[0]][0] = INT_MAX ;\\n        dp[days[0]][1] = costs[0] , dp[days[0]][2] = costs[1] , dp[days[0]][3] = costs[2] ;\\n\\n        for(int i = 1 ; i < n ; i++){\\n\\n            int mini = min(dp[days[i-1]][1],min(dp[days[i-1]][2],dp[days[i-1]][3])) ;\\n\\n            if(dp[days[i-1]][0] != INT_MAX)\\n            {\\n                dp[days[i]][1] = min(dp[days[i-1]][0],mini) + costs[0] ;\\n                dp[days[i]][2] = min(dp[days[i-1]][0],mini) + costs[1] ;\\n                dp[days[i]][3] = min(dp[days[i-1]][0],mini) + costs[2] ;\\n            }\\n            else{\\n                dp[days[i]][1] = mini + costs[0] ;\\n                dp[days[i]][2] = mini + costs[1] ;\\n                dp[days[i]][3] = mini + costs[2] ;\\n            }\\n\\n            for(int j = 0 ; j < i ; j++){\\n                if(days[j] + 7 > days[i]){\\n                    dp[days[i]][0] = min(dp[days[i]][0],dp[days[j]][2]) ;\\n                }\\n                if(days[j] + 30 > days[i]){\\n                    dp[days[i]][0] = min(dp[days[i]][0],dp[days[j]][3]) ;\\n                }\\n            }\\n        }\\n\\n        return \\n        min(dp[days[n-1]][0],min(dp[days[n-1]][1],min(dp[days[n-1]][2],dp[days[n-1]][3]))) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351970,
                "title": "all-three-approaches-discussed-in-an-understandable-manner",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDynamic Programming is to be implemented as the number of possibilities are infinte and we need to minimize the cost.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor recursive solution , you\\'ll get a TLE as cases are large.\\nCode gets successfully submitted for the top-down approach i.e. the memoized version of recursive solution and the bottom-up apprach.\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nExponential in case of recursive.\\nConstant i.e. O(1) in the memoized solution.\\nO(n) in case of bottom-up approach where n is the number of elememts in days array.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) in case of top-down and bottom-up solutions.\\n\\n# Code\\n```\\n//RECURSIVE SOLUTION\\nclass Solution {\\npublic:\\n\\n    int solve(int n, vector<int>& days, vector<int>& costs, int index)\\n    {\\n        //BASE CASE\\n        if(index >= n)\\n        return 0;\\n\\n        //1 day pass\\n        int option1 = costs[0] + solve(n,days, costs, index+1);\\n\\n        //7 days pass\\n        int i;\\n        for(i = index; i<n && days[i] < days[index]+7; i++){\\n            continue;\\n        }\\n\\n        int option2 = costs[1] + solve(n, days, costs, i);\\n\\n        //30 days pass\\n        for(i = index; i<n && days[i] < days[index]+30; i++){\\n            continue;\\n        }\\n\\n        int option3 = costs[2] + solve(n, days, costs, i);\\n\\n\\n        return min(option1, min(option2, option3));\\n\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n     return solve(n, days, costs, 0);\\n    }\\n};\\n\\n\\n\\n//MEMOIZED CODE\\nclass Solution {\\npublic:\\n\\n    int solveMem(int n, vector<int>& days, vector<int>& costs, int index, vector<int> & dp)\\n    {\\n        //BASE CASE\\n        if(index >= n)\\n        return 0;\\n\\n        if(dp[index] != -1)\\n        return dp[index];\\n\\n        //1 day pass\\n        int option1 = costs[0] + solveMem(n,days, costs, index+1, dp);\\n\\n        //7 days pass\\n        int i;\\n        for(i = index; i<n && days[i] < days[index]+7; i++){\\n            continue;\\n        }\\n\\n        int option2 = costs[1] + solveMem(n, days, costs, i, dp);\\n\\n        //30 days pass\\n        for(i = index; i<n && days[i] < days[index]+30; i++){\\n            continue;\\n        }\\n\\n        int option3 = costs[2] + solveMem(n, days, costs, i, dp);\\n\\n\\n        dp[index] = min(option1, min(option2, option3));\\n        return dp[index];\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n+1, -1);\\n     return solveMem(n, days, costs, 0, dp);\\n    }\\n};\\n\\n\\n\\n//BOTTOM-UP APPROACH\\nclass Solution {\\npublic:\\n\\n    int solveTab(int n, vector<int>& days, vector<int>& costs)\\n    {\\n       vector<int> dp(n+1, INT_MAX);\\n       dp[n] = 0;\\n\\n       for(int k = n-1; k>=0; k--)\\n       {\\n         //1 day pass\\n        int option1 = costs[0] + dp[k+1];\\n\\n        //7 days pass\\n        int i;\\n        for(i = k; i<n && days[i] < days[k]+7; i++){\\n            continue;\\n        }\\n\\n        int option2 = costs[1] + dp[i];\\n\\n        //30 days pass\\n        for(i = k; i<n && days[i] < days[k]+30; i++){\\n            continue;\\n        }\\n\\n        int option3 = costs[2] + dp[i];\\n\\n\\n        dp[k] = min(option1, min(option2, option3));\\n\\n       }\\n        return dp[0];\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n     return solveTab(n, days, costs);\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\n//RECURSIVE SOLUTION\\nclass Solution {\\npublic:\\n\\n    int solve(int n, vector<int>& days, vector<int>& costs, int index)\\n    {\\n        //BASE CASE\\n        if(index >= n)\\n        return 0;\\n\\n        //1 day pass\\n        int option1 = costs[0] + solve(n,days, costs, index+1);\\n\\n        //7 days pass\\n        int i;\\n        for(i = index; i<n && days[i] < days[index]+7; i++){\\n            continue;\\n        }\\n\\n        int option2 = costs[1] + solve(n, days, costs, i);\\n\\n        //30 days pass\\n        for(i = index; i<n && days[i] < days[index]+30; i++){\\n            continue;\\n        }\\n\\n        int option3 = costs[2] + solve(n, days, costs, i);\\n\\n\\n        return min(option1, min(option2, option3));\\n\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n     return solve(n, days, costs, 0);\\n    }\\n};\\n\\n\\n\\n//MEMOIZED CODE\\nclass Solution {\\npublic:\\n\\n    int solveMem(int n, vector<int>& days, vector<int>& costs, int index, vector<int> & dp)\\n    {\\n        //BASE CASE\\n        if(index >= n)\\n        return 0;\\n\\n        if(dp[index] != -1)\\n        return dp[index];\\n\\n        //1 day pass\\n        int option1 = costs[0] + solveMem(n,days, costs, index+1, dp);\\n\\n        //7 days pass\\n        int i;\\n        for(i = index; i<n && days[i] < days[index]+7; i++){\\n            continue;\\n        }\\n\\n        int option2 = costs[1] + solveMem(n, days, costs, i, dp);\\n\\n        //30 days pass\\n        for(i = index; i<n && days[i] < days[index]+30; i++){\\n            continue;\\n        }\\n\\n        int option3 = costs[2] + solveMem(n, days, costs, i, dp);\\n\\n\\n        dp[index] = min(option1, min(option2, option3));\\n        return dp[index];\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n+1, -1);\\n     return solveMem(n, days, costs, 0, dp);\\n    }\\n};\\n\\n\\n\\n//BOTTOM-UP APPROACH\\nclass Solution {\\npublic:\\n\\n    int solveTab(int n, vector<int>& days, vector<int>& costs)\\n    {\\n       vector<int> dp(n+1, INT_MAX);\\n       dp[n] = 0;\\n\\n       for(int k = n-1; k>=0; k--)\\n       {\\n         //1 day pass\\n        int option1 = costs[0] + dp[k+1];\\n\\n        //7 days pass\\n        int i;\\n        for(i = k; i<n && days[i] < days[k]+7; i++){\\n            continue;\\n        }\\n\\n        int option2 = costs[1] + dp[i];\\n\\n        //30 days pass\\n        for(i = k; i<n && days[i] < days[k]+30; i++){\\n            continue;\\n        }\\n\\n        int option3 = costs[2] + dp[i];\\n\\n\\n        dp[k] = min(option1, min(option2, option3));\\n\\n       }\\n        return dp[0];\\n\\n    }\\n\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n     return solveTab(n, days, costs);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351619,
                "title": "solution-swift-dynamic-programming-beats-90",
                "content": "**TC:** O(n)\\n**SC:** O(n)\\n```\\nclass Solution {\\n    func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int {\\n        let days = Set(days)\\n        var dp = Array(repeating: 0, count: 366)\\n        \\n        for i in 1...365 {\\n            if days.contains(i) {\\n                dp[i] = min(\\n                    dp[i - 1] + costs[0],\\n                    dp[max(0, i - 7)] + costs[1],\\n                    dp[max(0, i - 30)] + costs[2]\\n                )\\n            } else {\\n                dp[i] = dp[i - 1]\\n            }\\n        }\\n\\n        return dp[365]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    func mincostTickets(_ days: [Int], _ costs: [Int]) -> Int {\\n        let days = Set(days)\\n        var dp = Array(repeating: 0, count: 366)\\n        \\n        for i in 1...365 {\\n            if days.contains(i) {\\n                dp[i] = min(\\n                    dp[i - 1] + costs[0],\\n                    dp[max(0, i - 7)] + costs[1],\\n                    dp[max(0, i - 30)] + costs[2]\\n                )\\n            } else {\\n                dp[i] = dp[i - 1]\\n            }\\n        }\\n\\n        return dp[365]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351548,
                "title": "bottom-up-dp-three-pointers-0-ms-100-c-fast-and-simple",
                "content": "**Explaination :**\\n\\nIn this solution ```dp[i]``` means cost, for travelling ```days[i]``` days. In order to minimize cost we check whether it is better to buy 30 days ticket (which will be ```dp[i+1] = dp[k]+costs[2]```), 7 days (which will be ```dp[i+1] = dp[j]+costs[1]```) or 1 day ticket (which will be ```dp[i+1]=min(dp[i]+costs[0]```) using Two Pointers ```k``` and ```j``` to track the day atleast 30 and 7 days before ```i``` respectively. \\n\\n**Code :**\\n```\\nclass Solution {\\npublic:\\n    int dp[366];\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n=days.size(),j=0,k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(days[i]-days[j]>=7)j++;\\n            while(days[i]-days[k]>=30)k++;\\n            dp[i+1]=min(dp[i]+costs[0],min(dp[j]+costs[1],dp[k]+costs[2]));\\n        }\\n        return dp[n];\\n    }\\n};\\n```\\n\\n**Complexity analysis**\\n\\n* Time Complexity: O(N), where N is the number of calendar days.\\n* Space Complexity: O(N).",
                "solutionTags": [
                    "C",
                    "Array",
                    "Two Pointers",
                    "Dynamic Programming"
                ],
                "code": "```dp[i]```\n```days[i]```\n```dp[i+1] = dp[k]+costs[2]```\n```dp[i+1] = dp[j]+costs[1]```\n```dp[i+1]=min(dp[i]+costs[0]```\n```k```\n```j```\n```i```\n```\\nclass Solution {\\npublic:\\n    int dp[366];\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n=days.size(),j=0,k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            while(days[i]-days[j]>=7)j++;\\n            while(days[i]-days[k]>=30)k++;\\n            dp[i+1]=min(dp[i]+costs[0],min(dp[j]+costs[1],dp[k]+costs[2]));\\n        }\\n        return dp[n];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351472,
                "title": "3-approaches-easy-java-solution-using-backtracking-and-dp",
                "content": "# Approach 1 backtracking\\n\\n# Note\\n- This will give Time Limit Executed error but must do for beginners because it help in building dp solution\\n\\n# Complexity\\n- Time complexity: $$O(3^n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        return mincostTickets(days, costs, 0, 0);\\n    }\\n    private int mincostTickets(int[] days, int[] costs, int s, int cost){\\n        if(s >= days.length) return cost;\\n        int minCost = Integer.MAX_VALUE;\\n        for(int x = 0; x<3; x++){\\n            if(x == 0){\\n                minCost = Math.min(minCost, mincostTickets(days, costs, s+1, cost+costs[0]));\\n            } else if(x == 1){\\n                int nextDay = days[s]+7-1;\\n                for(int i = s+1; i<=days.length; i++){\\n                    if(i == days.length){\\n                        minCost = Math.min(minCost, cost+costs[1]);\\n                    } else if(days[i] > nextDay){\\n                        minCost = Math.min(minCost, mincostTickets(days, costs, i, cost+costs[1]));\\n                        break;\\n                    }\\n                }\\n            } else {\\n                int nextDay = days[s]+30-1;\\n                for(int i = s+1; i<=days.length; i++){\\n                    if(i == days.length){\\n                        minCost = Math.min(minCost, cost+costs[2]);\\n                    } else if(days[i] > nextDay){\\n                        minCost = Math.min(minCost, mincostTickets(days, costs, i, cost+costs[2]));\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return minCost;\\n    }\\n}\\n\\n```\\n\\n# Approach 2 DP\\n- I call it as forward dp approach because :- \\n    - In this approach we take our current day as starting day and check for the maximum days from current day we can travel.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int dp[] = new int[n+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        for(int day = 1; day <= n; day++){\\n            dp[day] = Math.min(dp[day], dp[day-1] + costs[0]);\\n            for(int i = day; i<=n; i++){\\n                if(i == n || days[i] > days[day-1]+7-1){\\n                    dp[i] = Math.min(dp[i], dp[day-1]+costs[1]);\\n                    break;\\n                }\\n            }\\n            for(int i = day; i<=n; i++){\\n                if(i == n || days[i] > days[day-1]+30-1){\\n                    dp[i] = Math.min(dp[i], dp[day-1]+costs[2]);\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n\\n```\\n\\n# Approach 3 DP easy\\n- I call it as backward dp approach because :- \\n    - In this approach we take our current day as ending day and check for the previous days from where we can reach to current day.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$ where n is the maximum day in days array\\n\\n# Code\\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int maxDay = days[days.length-1];\\n        int[] dp = new int[maxDay+1];\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int day : days){\\n            hs.add(day);\\n        }\\n        for(int i = 1; i<=maxDay; i++){\\n            if(!hs.contains(i)){\\n                dp[i] = dp[i-1];\\n            } else {\\n                dp[i] = Math.min(dp[i-1]+costs[0], Math.min(dp[Math.max(0, i-7)] + costs[1], dp[Math.max(0, i-30)] + costs[2]));\\n            }\\n        }\\n        return dp[maxDay];\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking"
                ],
                "code": "```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        return mincostTickets(days, costs, 0, 0);\\n    }\\n    private int mincostTickets(int[] days, int[] costs, int s, int cost){\\n        if(s >= days.length) return cost;\\n        int minCost = Integer.MAX_VALUE;\\n        for(int x = 0; x<3; x++){\\n            if(x == 0){\\n                minCost = Math.min(minCost, mincostTickets(days, costs, s+1, cost+costs[0]));\\n            } else if(x == 1){\\n                int nextDay = days[s]+7-1;\\n                for(int i = s+1; i<=days.length; i++){\\n                    if(i == days.length){\\n                        minCost = Math.min(minCost, cost+costs[1]);\\n                    } else if(days[i] > nextDay){\\n                        minCost = Math.min(minCost, mincostTickets(days, costs, i, cost+costs[1]));\\n                        break;\\n                    }\\n                }\\n            } else {\\n                int nextDay = days[s]+30-1;\\n                for(int i = s+1; i<=days.length; i++){\\n                    if(i == days.length){\\n                        minCost = Math.min(minCost, cost+costs[2]);\\n                    } else if(days[i] > nextDay){\\n                        minCost = Math.min(minCost, mincostTickets(days, costs, i, cost+costs[2]));\\n                        break;\\n                    }\\n                }\\n            }\\n        }\\n        return minCost;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int dp[] = new int[n+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[0] = 0;\\n        for(int day = 1; day <= n; day++){\\n            dp[day] = Math.min(dp[day], dp[day-1] + costs[0]);\\n            for(int i = day; i<=n; i++){\\n                if(i == n || days[i] > days[day-1]+7-1){\\n                    dp[i] = Math.min(dp[i], dp[day-1]+costs[1]);\\n                    break;\\n                }\\n            }\\n            for(int i = day; i<=n; i++){\\n                if(i == n || days[i] > days[day-1]+30-1){\\n                    dp[i] = Math.min(dp[i], dp[day-1]+costs[2]);\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[n];\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int maxDay = days[days.length-1];\\n        int[] dp = new int[maxDay+1];\\n        HashSet<Integer> hs = new HashSet<>();\\n        for(int day : days){\\n            hs.add(day);\\n        }\\n        for(int i = 1; i<=maxDay; i++){\\n            if(!hs.contains(i)){\\n                dp[i] = dp[i-1];\\n            } else {\\n                dp[i] = Math.min(dp[i-1]+costs[0], Math.min(dp[Math.max(0, i-7)] + costs[1], dp[Math.max(0, i-30)] + costs[2]));\\n            }\\n        }\\n        return dp[maxDay];\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351197,
                "title": "c-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int cost(vector<int>& days,  vector<int>& costs, int i, int n, vector<int>&dp){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int i7,i30;\\n        for(int j=i; j<n; j++){\\n            if(days[j]-days[i]+1 <= 7){\\n                i7 = j;\\n            }\\n            if(days[j]-days[i]+1 <= 30){\\n                i30 = j;\\n            }\\n            else break;\\n        }\\n        return dp[i] = min(costs[0] + cost(days,costs,i+1,n,dp),min(costs[1] + cost(days,costs,i7+1,n,dp), costs[2] + cost(days,costs,i30+1,n,dp) ) ); \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int>dp(n,-1);\\n        return cost(days,costs,0,n,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int cost(vector<int>& days,  vector<int>& costs, int i, int n, vector<int>&dp){\\n        if(i >= n) return 0;\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int i7,i30;\\n        for(int j=i; j<n; j++){\\n            if(days[j]-days[i]+1 <= 7){\\n                i7 = j;\\n            }\\n            if(days[j]-days[i]+1 <= 30){\\n                i30 = j;\\n            }\\n            else break;\\n        }\\n        return dp[i] = min(costs[0] + cost(days,costs,i+1,n,dp),min(costs[1] + cost(days,costs,i7+1,n,dp), costs[2] + cost(days,costs,i30+1,n,dp) ) ); \\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int>dp(n,-1);\\n        return cost(days,costs,0,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351028,
                "title": "dp-solution-implementation-with-cache-decorator",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n---\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSee the code snippet below.\\n---\\n---\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, $n$ is max day in `days`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n---\\n# Code\\n```python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        @cache\\n        def dp(day):\\n            if day <= 0: return 0\\n            if day not in days: return dp(day-1)\\n            return min(dp(day-1)+costs[0], dp(day-7)+costs[1], dp(day-30)+costs[2])\\n\\n        return dp(days[-1])\\n```\\n---\\n```\\nIf you like this solution, upvote, please !\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```python []\\nclass Solution:\\n    def mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n        @cache\\n        def dp(day):\\n            if day <= 0: return 0\\n            if day not in days: return dp(day-1)\\n            return min(dp(day-1)+costs[0], dp(day-7)+costs[1], dp(day-30)+costs[2])\\n\\n        return dp(days[-1])\\n```\n```\\nIf you like this solution, upvote, please !\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351002,
                "title": "java-easy-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int mincostTickets(int[] days, int[] costs) {\\n    int dp[] = new int[395];\\n    for(int d: days) dp[d+29] = 1;\\n\\n    for(int i = 30; i != dp.length; ++i)\\n      if(dp[i] == 0) dp[i] = dp[i-1];\\n      else dp[i] = Math.min(Math.min(dp[i-30] + costs[2], dp[i-7] + costs[1]), dp[i-1] + costs[0]);\\n\\n    return dp[394];      \\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int mincostTickets(int[] days, int[] costs) {\\n    int dp[] = new int[395];\\n    for(int d: days) dp[d+29] = 1;\\n\\n    for(int i = 30; i != dp.length; ++i)\\n      if(dp[i] == 0) dp[i] = dp[i-1];\\n      else dp[i] = Math.min(Math.min(dp[i-30] + costs[2], dp[i-7] + costs[1]), dp[i-1] + costs[0]);\\n\\n    return dp[394];      \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350897,
                "title": "typescript-solution-basic-intutition",
                "content": "# Intuition\\nEvery day you can either travel or not travel. \\n- In case you are not travelling, then you can check the next day\\n- In case you are travelling, you can either purchase:\\n  - A 1 day ticket - purchase and check next day\\n  - A 7 days ticket - purchase and check 7 days from now\\n  - A 30 days ticket - purchase and check 30 days from now\\n\\n\\n# Code\\n```\\nfunction mincostTickets(days: number[], costs: number[]): number {\\n    const daySet = new Set(days);\\n\\n    const dp = (d: number): number => {\\n        if (d > 365) {\\n            return 0;\\n        }\\n\\n        if (typeof cache[d] !== \\'undefined\\') {\\n            return cache[d];\\n        }\\n\\n        return cache[d] = !daySet.has(d) ? \\n            dp(d + 1) : // d is not among travelling days, skipping\\n            Math.min(\\n                costs[0] + dp(d + 1),\\n                costs[1] + dp(d + 7),\\n                costs[2] + dp(d + 30),\\n            ); \\n    }\\n    \\n    const cache: number[] = new Array(days.length);\\n\\n    // Starts from day 1\\n    return dp(1);\\n};\\n\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction mincostTickets(days: number[], costs: number[]): number {\\n    const daySet = new Set(days);\\n\\n    const dp = (d: number): number => {\\n        if (d > 365) {\\n            return 0;\\n        }\\n\\n        if (typeof cache[d] !== \\'undefined\\') {\\n            return cache[d];\\n        }\\n\\n        return cache[d] = !daySet.has(d) ? \\n            dp(d + 1) : // d is not among travelling days, skipping\\n            Math.min(\\n                costs[0] + dp(d + 1),\\n                costs[1] + dp(d + 7),\\n                costs[2] + dp(d + 30),\\n            ); \\n    }\\n    \\n    const cache: number[] = new Array(days.length);\\n\\n    // Starts from day 1\\n    return dp(1);\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3350836,
                "title": "dynamic-programming-100-faster-solution-and-greedy",
                "content": "# Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n***Why Greedy doesn\\'t work:***\\n- The simplest greedy approach would be similar to the fractional knapsack, taking the best cost per day plan.\\n- But, The solution doesn\\'t work because the plan must be taken in total we cannot take it per day, *Example: For 7 days plan we must take all 7 days cost even though we are using only 4 days in that plan. So, the total cost would not be reduced to per day*.\\nI don\\'t know if it was only me or if anyone would consider greedy as their first approach. This was for people who had trouble finding why greedy wouldn\\'t work.\\n\\n# Greedy Code\\n*Note: This is just an example for greedy.(However, I am not a good programmer. Any changes to the code are appreciated)*\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // we must pay the all days plan in total so, greedy fails here\\n        int start = 0;\\n        int ans = 0;\\n        while(start < days.size()){\\n        //     naive approach -> next 30 days if it has least cost per day for 30, 7 or 1 day cost take it --> greedy\\n        int cnt7=0,cnt30=0;\\n        for(int i=start; i<days.size(); i++){\\n            if(days[i]-days[start] < 7){\\n                     cnt7++;\\n                 }\\n                 if(days[i]-days[start] < 30){\\n                     cnt30++;\\n                 }else{\\n                     break;\\n                 }\\n             }\\n             // cost per day\\n             double c1 = (double)costs[0], c2 = (double)(costs[1]*7)/cnt7, c3 = (double)(costs[2]*30)/cnt30;\\n             // take day 1 and proceed\\n             if(c1 < c2 && c1 < c3){\\n                 ans += costs[0];\\n                 start++;\\n             }else if(c2 < c3){\\n                 ans += costs[1];\\n                 start += cnt7;\\n             }else{\\n                 ans += costs[2];\\n                 start += cnt30;\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```\\n\\n# Approach\\n**Working Solution (Dynamic Programming):**\\n- Each day of the \\'dp\\' array represents the optimal money spent till that day.\\n- For the 1-day plan, it is easy to get the optimal cost for a particular day i.e. 1-day plan cost + dp[i-1](optimal cost till previous day).\\n- For the 7-day plan and 30-day plan, the minimum cost affects the next upcoming 30 or 7 days. So, Take the minimum cost and update the \\'dp\\' array to have minimum costs for upcoming days. This ensures that we are not taking multiple plans at the same time. \\n- For the first day, we don\\'t have any minimum value to take for the previous day. So, make sure to set the previous cost to 0 before proceeding. \\n\\n# Complexity\\n- Time complexity: **O(number of days * 30)**\\nFor each day we can atmost look for next 30 days.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(number of days)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe solution described is not the best solution. May have better solutions than this.\\n\\n# Dynamic Programming Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // dynamic programming knapsack and LIS kind-of problem\\n        vector<int> dp(days.size(), INT_MAX);\\n        for(int i=0; i<days.size(); i++){\\n            // cost for a day\\n            if(i == 0)\\n                dp[i] = costs[0];\\n            else\\n                dp[i] = min(dp[i-1]+costs[0], dp[i]);\\n\\n            // cost for 7-day or 30-day plan\\n            int prevCost = 0;\\n            if(i != 0)\\n                prevCost = dp[i-1];\\n            for(int j=i; j<days.size(); j++){\\n                if(days[j]-days[i] < 7){\\n                    dp[j] = min(prevCost+costs[1], dp[j]);\\n                }\\n                if(days[j]-days[i] < 30){\\n                    dp[j] = min(prevCost+costs[2], dp[j]);\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[days.size()-1];\\n    }\\n};\\n```\\n\\n**If anyone found this helpful, give an upvote.\\nThank you for reading this post**\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // we must pay the all days plan in total so, greedy fails here\\n        int start = 0;\\n        int ans = 0;\\n        while(start < days.size()){\\n        //     naive approach -> next 30 days if it has least cost per day for 30, 7 or 1 day cost take it --> greedy\\n        int cnt7=0,cnt30=0;\\n        for(int i=start; i<days.size(); i++){\\n            if(days[i]-days[start] < 7){\\n                     cnt7++;\\n                 }\\n                 if(days[i]-days[start] < 30){\\n                     cnt30++;\\n                 }else{\\n                     break;\\n                 }\\n             }\\n             // cost per day\\n             double c1 = (double)costs[0], c2 = (double)(costs[1]*7)/cnt7, c3 = (double)(costs[2]*30)/cnt30;\\n             // take day 1 and proceed\\n             if(c1 < c2 && c1 < c3){\\n                 ans += costs[0];\\n                 start++;\\n             }else if(c2 < c3){\\n                 ans += costs[1];\\n                 start += cnt7;\\n             }else{\\n                 ans += costs[2];\\n                 start += cnt30;\\n             }\\n         }\\n         return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        // dynamic programming knapsack and LIS kind-of problem\\n        vector<int> dp(days.size(), INT_MAX);\\n        for(int i=0; i<days.size(); i++){\\n            // cost for a day\\n            if(i == 0)\\n                dp[i] = costs[0];\\n            else\\n                dp[i] = min(dp[i-1]+costs[0], dp[i]);\\n\\n            // cost for 7-day or 30-day plan\\n            int prevCost = 0;\\n            if(i != 0)\\n                prevCost = dp[i-1];\\n            for(int j=i; j<days.size(); j++){\\n                if(days[j]-days[i] < 7){\\n                    dp[j] = min(prevCost+costs[1], dp[j]);\\n                }\\n                if(days[j]-days[i] < 30){\\n                    dp[j] = min(prevCost+costs[2], dp[j]);\\n                }else{\\n                    break;\\n                }\\n            }\\n        }\\n        return dp[days.size()-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350804,
                "title": "java-solution-all-approaches-recursion-memoization-tabulation-space-optimization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can solve this by Dynamic Programming.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can apply Memoization and Tabulation for better complexity.\\n\\n# Complexity\\n- **Time complexity: O(n)** because we have days array with size n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space complexity: O(n)** cause we are using addtion dp array of size(n+1)\\n\\n**If we use space optimization then Space complexity would be O(1).**\\n\\n# Code Approaches\\n\\n`Recursion Solution will give you TLE so after that we should optimize our code to Memoization or Tabulation`.\\n\\n```Recursion []\\n    //Using Recursion\\n     int solve(int n, int[] days, int[] costs, int index)\\n     {\\n         if(index >= n)\\n         {\\n             return 0;\\n         }\\n\\n         //1 day pass\\n         int option1 = costs[0] + solve(n, days, costs, index+1);\\n\\n         //7 day pass\\n         int i;\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +7; i++);\\n\\n         int option2 = costs[1] + solve(n, days, costs, i);\\n\\n         //30 day pass\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +30; i++);\\n\\n         int option3 = costs[2] + solve(n, days, costs, i);\\n\\n        return Math.min(option1, Math.min(option2,option3));\\n     }\\n\\n```\\n```Memoization []\\n     //Using Memoization\\n     int solve(int n, int[] days, int[] costs, int index, int[] dp)\\n     {\\n         if(index >= n)\\n         {\\n             return 0;\\n         }\\n\\n         if(dp[index] != -1)\\n         {\\n             return dp[index];\\n         }\\n\\n         //1 day pass\\n         int option1 = costs[0] + solve(n, days, costs, index+1, dp);\\n\\n         //7 day pass\\n         int i;\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +7; i++);\\n\\n         int option2 = costs[1] + solve(n, days, costs, i, dp);\\n\\n         //30 day pass\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +30; i++);\\n\\n         int option3 = costs[2] + solve(n, days, costs, i, dp);\\n\\n         dp[index] = Math.min(option1, Math.min(option2,option3));\\n\\n         return dp[index];\\n     }\\n\\n```\\n```Tabulation []\\n    //Using Tabulation\\n    int solve(int n, int[] days, int[] costs, int index)\\n    {\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n] = 0;\\n\\n        for(int k=n-1;k>=0;k--)\\n        {\\n            //1 day pass\\n            int option1 = costs[0] + dp[k+1];\\n\\n            //7 day pass\\n            int i;\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +7; i++);\\n\\n            int option2 = costs[1] + dp[i];\\n\\n            //30 day pass\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +30; i++);\\n\\n            int option3 = costs[2] + dp[i];\\n\\n            dp[k] = Math.min(option1, Math.min(option2,option3));\\n        }\\n\\n        return dp[0];\\n\\n    }\\n```\\n```Space_Optimization []\\n\\n    int solve(int n, int[] days, int[] costs)\\n    {\\n        Queue<int[]> week = new LinkedList<>();\\n        Queue<int[]> month = new LinkedList<>();\\n   \\n        int ans= 0;\\n\\n        for (int t : days) {\\n            while (!week .isEmpty() && week.peek()[0] + 7 <= t) {\\n                week.poll();\\n            }\\n            while (!month.isEmpty() && month.peek()[0] + 30 <= t) {\\n                month.poll();\\n            }\\n            week.offer(new int[]{t, ans + costs[1]});\\n            month.offer(new int[]{t, ans + costs[2]});\\n            ans= Math.min(ans + costs[0], Math.min(week.peek()[1], month.peek()[1]));\\n        }\\n\\n        return ans;\\n    }\\n    \\n```\\n \\n# Code\\n\\n**I Solved by Tabulation you can use \"Space Optimization Solution\" as well.** \\n```\\nclass Solution {\\n\\n    //Using Tabulation\\n    int solve(int n, int[] days, int[] costs, int index)\\n    {\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n] = 0;\\n\\n        for(int k=n-1;k>=0;k--)\\n        {\\n            //1 day pass\\n            int option1 = costs[0] + dp[k+1];\\n\\n            //7 day pass\\n            int i;\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +7; i++);\\n\\n            int option2 = costs[1] + dp[i];\\n\\n            //30 day pass\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +30; i++);\\n\\n            int option3 = costs[2] + dp[i];\\n\\n            dp[k] = Math.min(option1, Math.min(option2,option3));\\n        }\\n\\n        return dp[0];\\n\\n    }\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        \\n        int n = days.length;\\n        // int[] dp = new int[n+1];\\n        // Arrays.fill(dp, -1);\\n        return solve(n, days, costs, 0);\\n    }\\n}\\n```\\n# Please Upvote \\uD83D\\uDC4D\\n\\n```\\nIf you like my all approaches. \\nPlease give my solution upvote !!!.\\nIt really motivates me.\\nKeep me motivated.\\nThank you! \\uD83D\\uDE0A\\n```\\n\\n![3dv7yo.jpg](https://assets.leetcode.com/users/images/6e634d87-fe4b-485a-a8a9-bca79eba9fa7_1679993240.6115506.jpeg)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```Recursion []\\n    //Using Recursion\\n     int solve(int n, int[] days, int[] costs, int index)\\n     {\\n         if(index >= n)\\n         {\\n             return 0;\\n         }\\n\\n         //1 day pass\\n         int option1 = costs[0] + solve(n, days, costs, index+1);\\n\\n         //7 day pass\\n         int i;\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +7; i++);\\n\\n         int option2 = costs[1] + solve(n, days, costs, i);\\n\\n         //30 day pass\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +30; i++);\\n\\n         int option3 = costs[2] + solve(n, days, costs, i);\\n\\n        return Math.min(option1, Math.min(option2,option3));\\n     }\\n\\n```\n```Memoization []\\n     //Using Memoization\\n     int solve(int n, int[] days, int[] costs, int index, int[] dp)\\n     {\\n         if(index >= n)\\n         {\\n             return 0;\\n         }\\n\\n         if(dp[index] != -1)\\n         {\\n             return dp[index];\\n         }\\n\\n         //1 day pass\\n         int option1 = costs[0] + solve(n, days, costs, index+1, dp);\\n\\n         //7 day pass\\n         int i;\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +7; i++);\\n\\n         int option2 = costs[1] + solve(n, days, costs, i, dp);\\n\\n         //30 day pass\\n         //We are using for loop without body here just to increment index.\\n         for(i=index;i<n && days[i] < days[index] +30; i++);\\n\\n         int option3 = costs[2] + solve(n, days, costs, i, dp);\\n\\n         dp[index] = Math.min(option1, Math.min(option2,option3));\\n\\n         return dp[index];\\n     }\\n\\n```\n```Tabulation []\\n    //Using Tabulation\\n    int solve(int n, int[] days, int[] costs, int index)\\n    {\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n] = 0;\\n\\n        for(int k=n-1;k>=0;k--)\\n        {\\n            //1 day pass\\n            int option1 = costs[0] + dp[k+1];\\n\\n            //7 day pass\\n            int i;\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +7; i++);\\n\\n            int option2 = costs[1] + dp[i];\\n\\n            //30 day pass\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +30; i++);\\n\\n            int option3 = costs[2] + dp[i];\\n\\n            dp[k] = Math.min(option1, Math.min(option2,option3));\\n        }\\n\\n        return dp[0];\\n\\n    }\\n```\n```Space_Optimization []\\n\\n    int solve(int n, int[] days, int[] costs)\\n    {\\n        Queue<int[]> week = new LinkedList<>();\\n        Queue<int[]> month = new LinkedList<>();\\n   \\n        int ans= 0;\\n\\n        for (int t : days) {\\n            while (!week .isEmpty() && week.peek()[0] + 7 <= t) {\\n                week.poll();\\n            }\\n            while (!month.isEmpty() && month.peek()[0] + 30 <= t) {\\n                month.poll();\\n            }\\n            week.offer(new int[]{t, ans + costs[1]});\\n            month.offer(new int[]{t, ans + costs[2]});\\n            ans= Math.min(ans + costs[0], Math.min(week.peek()[1], month.peek()[1]));\\n        }\\n\\n        return ans;\\n    }\\n    \\n```\n```\\nclass Solution {\\n\\n    //Using Tabulation\\n    int solve(int n, int[] days, int[] costs, int index)\\n    {\\n        int[] dp = new int[n+1];\\n        Arrays.fill(dp, Integer.MAX_VALUE);\\n        dp[n] = 0;\\n\\n        for(int k=n-1;k>=0;k--)\\n        {\\n            //1 day pass\\n            int option1 = costs[0] + dp[k+1];\\n\\n            //7 day pass\\n            int i;\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +7; i++);\\n\\n            int option2 = costs[1] + dp[i];\\n\\n            //30 day pass\\n            //We are using for loop without body here just to increment index.\\n            for(i=k;i<n && days[i] < days[k] +30; i++);\\n\\n            int option3 = costs[2] + dp[i];\\n\\n            dp[k] = Math.min(option1, Math.min(option2,option3));\\n        }\\n\\n        return dp[0];\\n\\n    }\\n\\n    public int mincostTickets(int[] days, int[] costs) {\\n        \\n        int n = days.length;\\n        // int[] dp = new int[n+1];\\n        // Arrays.fill(dp, -1);\\n        return solve(n, days, costs, 0);\\n    }\\n}\\n```\n```\\nIf you like my all approaches. \\nPlease give my solution upvote !!!.\\nIt really motivates me.\\nKeep me motivated.\\nThank you! \\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350121,
                "title": "time-o-n-space-o-365-with-comments-c-easy-to-understand-short-sweet",
                "content": "````\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> v(367,INT_MAX);//INITIALIZE ANS FOR EVERY DAY TO INFINITY\\n        v[366] = 0;\\n        int i = 0, j = 0,n = days.size();\\n        i = n-1;\\n        for(j = 365; j >=0; j--){\\n            if(i>=0&&days[i]==j){\\n                if(j+1<=366){//BUY 1-DAYS TICKET jth DAYS BY THIS WE TRAVELL j+1th DAY \\n                    v[j] = min(v[j],v[j+1]+costs[0]);//INTILILIZE ANS BY v[j] = min(v[j],v[j+1]if(j+1<=366)\\n                }else{\\n                    v[j] = min(v[j],costs[0]);//other wise v[j] = min(v[j],costs[0])\\n                }\\n                if(j+7<=366){//BUY 7-DAYS TICKET jth DAYS BY THIS WE TRAVELL j+7th DAY \\n                    v[j] = min(v[j],v[j+7]+costs[1]);//INTILILIZE ANS BY v[j] = min(v[j],v[j+7]if(j+7<=366)\\n                }else{\\n                    v[j] = min(v[j],costs[1]);;//other wise v[j] = min(v[j],costs[1])\\n                }\\n                if(j+30<=366){//BUY 30-DAYS TICKET jth DAYS BY THIS WE TRAVELL j+30th DAY \\n                    v[j] = min(v[j],v[j+30]+costs[2]);//INTILILIZE ANS BY v[j] = min(v[j],v[j+30]if(j+30<=366)\\n                }else{\\n                    v[j] = min(v[j],costs[2]);;//other wise v[j] = min(v[j],costs[2])\\n                }\\n                i--;\\n            }else{\\n                v[j] = v[j+1];\\n            }\\n        }\\n        // for(int i = 0; i <= days[n-1]; i++){\\n        //     cout<<v[i]<<\" \";\\n        // }\\n        return v[days[0]];\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "````\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> v(367,INT_MAX);//INITIALIZE ANS FOR EVERY DAY TO INFINITY\\n        v[366] = 0;\\n        int i = 0, j = 0,n = days.size();\\n        i = n-1;\\n        for(j = 365; j >=0; j--){\\n            if(i>=0&&days[i]==j){\\n                if(j+1<=366){//BUY 1-DAYS TICKET jth DAYS BY THIS WE TRAVELL j+1th DAY \\n                    v[j] = min(v[j],v[j+1]+costs[0]);//INTILILIZE ANS BY v[j] = min(v[j],v[j+1]if(j+1<=366)\\n                }else{\\n                    v[j] = min(v[j],costs[0]);//other wise v[j] = min(v[j],costs[0])\\n                }\\n                if(j+7<=366){//BUY 7-DAYS TICKET jth DAYS BY THIS WE TRAVELL j+7th DAY \\n                    v[j] = min(v[j],v[j+7]+costs[1]);//INTILILIZE ANS BY v[j] = min(v[j],v[j+7]if(j+7<=366)\\n                }else{\\n                    v[j] = min(v[j],costs[1]);;//other wise v[j] = min(v[j],costs[1])\\n                }\\n                if(j+30<=366){//BUY 30-DAYS TICKET jth DAYS BY THIS WE TRAVELL j+30th DAY \\n                    v[j] = min(v[j],v[j+30]+costs[2]);//INTILILIZE ANS BY v[j] = min(v[j],v[j+30]if(j+30<=366)\\n                }else{\\n                    v[j] = min(v[j],costs[2]);;//other wise v[j] = min(v[j],costs[2])\\n                }\\n                i--;\\n            }else{\\n                v[j] = v[j+1];\\n            }\\n        }\\n        // for(int i = 0; i <= days[n-1]; i++){\\n        //     cout<<v[i]<<\" \";\\n        // }\\n        return v[days[0]];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3331696,
                "title": "java-dp-memoization-0ms-runtime-beats-100",
                "content": "``` java []\\n// Memoization \\n// Beats 100%\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        boolean[] isPresent = new boolean[days[days.length-1]+1];\\n        for(int x:days){\\n            isPresent[x]=true;\\n        }\\n        Integer[] dp = new Integer[isPresent.length];\\n        return solve(isPresent,days[0],costs,dp);\\n    }\\n\\n    private int solve(boolean[] isPresent,int day,int[] costs,Integer[] dp){\\n        if(day>=isPresent.length){\\n            return 0;\\n        }\\n        if(dp[day]!=null){\\n            return dp[day];\\n        }\\n        if(isPresent[day]){\\n           int a = costs[0] + solve(isPresent,day+1,costs,dp);\\n           int b = costs[1] + solve(isPresent,day+7,costs,dp);\\n           int c = costs[2] + solve(isPresent,day+30,costs,dp);\\n           return dp[day] = Math.min(a,Math.min(b,c));\\n        }\\n        else{\\n            return dp[day] = solve(isPresent,day+1,costs,dp);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "``` java []\\n// Memoization \\n// Beats 100%\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        boolean[] isPresent = new boolean[days[days.length-1]+1];\\n        for(int x:days){\\n            isPresent[x]=true;\\n        }\\n        Integer[] dp = new Integer[isPresent.length];\\n        return solve(isPresent,days[0],costs,dp);\\n    }\\n\\n    private int solve(boolean[] isPresent,int day,int[] costs,Integer[] dp){\\n        if(day>=isPresent.length){\\n            return 0;\\n        }\\n        if(dp[day]!=null){\\n            return dp[day];\\n        }\\n        if(isPresent[day]){\\n           int a = costs[0] + solve(isPresent,day+1,costs,dp);\\n           int b = costs[1] + solve(isPresent,day+7,costs,dp);\\n           int c = costs[2] + solve(isPresent,day+30,costs,dp);\\n           return dp[day] = Math.min(a,Math.min(b,c));\\n        }\\n        else{\\n            return dp[day] = solve(isPresent,day+1,costs,dp);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3255576,
                "title": "dp-bs-memoization-tabulation-c",
                "content": "# Memoization\\n```\\nclass Solution {\\n    int dfs(int i, int n, vector<int> &days, vector<int> &costs, vector<int> &dp) {\\n        if(i == n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int one = costs[0] + dfs(i + 1, n, days, costs, dp);\\n        \\n        int pos1 = lower_bound(days.begin(), days.end(), days[i] + 7) - days.begin();\\n        int seven = costs[1] + dfs(pos1, n, days, costs, dp);\\n\\n        int pos2 = lower_bound(days.begin(), days.end(), days[i] + 30) - days.begin();\\n        int thirty = costs[2] + dfs(pos2, n, days, costs, dp);\\n\\n        return dp[i] = min({one, seven, thirty});\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n, -1);\\n        return dfs(0, n, days, costs, dp);\\n    }\\n};\\n```\\n\\n# Tabulation\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n + 1);\\n\\n        for(int i=n-1; i>=0; i--) {\\n            int one = costs[0] + dp[i + 1];\\n        \\n            int pos1 = lower_bound(days.begin(), days.end(), days[i] + 7) - days.begin();\\n            int seven = costs[1] + dp[pos1];\\n\\n            int pos2 = lower_bound(days.begin(), days.end(), days[i] + 30) - days.begin();\\n            int thirty = costs[2] + dp[pos2];\\n\\n            dp[i] = min({one, seven, thirty});\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int n, vector<int> &days, vector<int> &costs, vector<int> &dp) {\\n        if(i == n) return 0;\\n        if(dp[i] != -1) return dp[i];\\n\\n        int one = costs[0] + dfs(i + 1, n, days, costs, dp);\\n        \\n        int pos1 = lower_bound(days.begin(), days.end(), days[i] + 7) - days.begin();\\n        int seven = costs[1] + dfs(pos1, n, days, costs, dp);\\n\\n        int pos2 = lower_bound(days.begin(), days.end(), days[i] + 30) - days.begin();\\n        int thirty = costs[2] + dfs(pos2, n, days, costs, dp);\\n\\n        return dp[i] = min({one, seven, thirty});\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n, -1);\\n        return dfs(0, n, days, costs, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n = days.size();\\n        vector<int> dp(n + 1);\\n\\n        for(int i=n-1; i>=0; i--) {\\n            int one = costs[0] + dp[i + 1];\\n        \\n            int pos1 = lower_bound(days.begin(), days.end(), days[i] + 7) - days.begin();\\n            int seven = costs[1] + dp[pos1];\\n\\n            int pos2 = lower_bound(days.begin(), days.end(), days[i] + 30) - days.begin();\\n            int thirty = costs[2] + dp[pos2];\\n\\n            dp[i] = min({one, seven, thirty});\\n        }\\n        return dp[0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236585,
                "title": "dynamic-programming-c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int dp[366];\\n    int f(vector<int> &nums,int ind,vector<int> &cost,int n){\\n        \\n        if(ind>=n) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        \\n        int way1 = cost[0] + f(nums,ind+1,cost,n);\\n        int tempInd = ind;\\n        while(tempInd<n && nums[tempInd]-nums[ind]<7){\\n            tempInd++;\\n        }\\n        int way2 = cost[1] + f(nums,tempInd,cost,n);\\n        tempInd = ind;\\n        while(tempInd<n && nums[tempInd]-nums[ind]<30){\\n            tempInd++;\\n        }\\n        int way3 = cost[2] + f(nums,tempInd,cost,n);\\n        return dp[ind] = min(way1,min(way2,way3));\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(days,0,costs,days.size());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dp[366];\\n    int f(vector<int> &nums,int ind,vector<int> &cost,int n){\\n        \\n        if(ind>=n) return 0;\\n        if(dp[ind]!=-1) return dp[ind];\\n        \\n        int way1 = cost[0] + f(nums,ind+1,cost,n);\\n        int tempInd = ind;\\n        while(tempInd<n && nums[tempInd]-nums[ind]<7){\\n            tempInd++;\\n        }\\n        int way2 = cost[1] + f(nums,tempInd,cost,n);\\n        tempInd = ind;\\n        while(tempInd<n && nums[tempInd]-nums[ind]<30){\\n            tempInd++;\\n        }\\n        int way3 = cost[2] + f(nums,tempInd,cost,n);\\n        return dp[ind] = min(way1,min(way2,way3));\\n    }\\n    \\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        memset(dp,-1,sizeof(dp));\\n        return f(days,0,costs,days.size());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3210827,
                "title": "minimum-cost-for-tickets-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int ans = 0;\\n        queue<pair<int,int>> monthly;\\n        queue<pair<int,int>> weekly;\\n\\n        for(int day : days){\\n            //step 1 : remove expired days\\n            while(!monthly.empty() && monthly.front().first + 30 <= day){\\n                monthly.pop();\\n            }\\n\\n            while(!weekly.empty() && weekly.front().first + 7 <= day){\\n                weekly.pop();\\n            }\\n\\n            //step 2 : add cost for current day\\n            monthly.push(make_pair(day , ans + costs[2]));\\n            weekly.push(make_pair(day , ans + costs[1]));\\n\\n            ans = min(ans + costs[0] , min(monthly.front().second , weekly.front().second));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int ans = 0;\\n        queue<pair<int,int>> monthly;\\n        queue<pair<int,int>> weekly;\\n\\n        for(int day : days){\\n            //step 1 : remove expired days\\n            while(!monthly.empty() && monthly.front().first + 30 <= day){\\n                monthly.pop();\\n            }\\n\\n            while(!weekly.empty() && weekly.front().first + 7 <= day){\\n                weekly.pop();\\n            }\\n\\n            //step 2 : add cost for current day\\n            monthly.push(make_pair(day , ans + costs[2]));\\n            weekly.push(make_pair(day , ans + costs[1]));\\n\\n            ans = min(ans + costs[0] , min(monthly.front().second , weekly.front().second));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3182214,
                "title": "dp-recursive-memoization-c-3ms-easy-to-understand",
                "content": "```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int n, vector<int>& days, vector<int>& costs, vector<int> &dp)\\n    {\\n        if(idx>=n) return 0;\\n        \\n        if(dp[idx]!=-1) return dp[idx];\\n        int day_1=costs[0]+solve(idx+1,n,days,costs,dp);\\n        \\n        int new_idx=upper_bound(days.begin(),days.end(),days[idx]+6)-days.begin();\\n        int day_7=costs[1]+solve(new_idx,n,days,costs,dp);\\n        \\n        int new_idx1=upper_bound(days.begin(),days.end(),days[idx]+29)-days.begin();\\n        int mn=costs[2]+solve(new_idx1,n,days,costs,dp);\\n        \\n        return dp[idx]=min(day_1,min(day_7,mn));\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n=days.size();\\n        vector<int> dp(n,-1);\\n        return solve(0,n,days,costs,dp);\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/68e3bb93-975a-4e5d-88e1-4723bd06cfb9_1676315355.202165.png)\\n\\n# If it is helpful for you please upvote \\uD83D\\uDC46. Keep coding \\uD83D\\uDE0A\\uD83D\\uDC4D \\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int idx, int n, vector<int>& days, vector<int>& costs, vector<int> &dp)\\n    {\\n        if(idx>=n) return 0;\\n        \\n        if(dp[idx]!=-1) return dp[idx];\\n        int day_1=costs[0]+solve(idx+1,n,days,costs,dp);\\n        \\n        int new_idx=upper_bound(days.begin(),days.end(),days[idx]+6)-days.begin();\\n        int day_7=costs[1]+solve(new_idx,n,days,costs,dp);\\n        \\n        int new_idx1=upper_bound(days.begin(),days.end(),days[idx]+29)-days.begin();\\n        int mn=costs[2]+solve(new_idx1,n,days,costs,dp);\\n        \\n        return dp[idx]=min(day_1,min(day_7,mn));\\n    }\\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        int n=days.size();\\n        vector<int> dp(n,-1);\\n        return solve(0,n,days,costs,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3089689,
                "title": "4ms-soln-very-intuitive-easy-recursion-memoization-upper-bound",
                "content": "**Every day you have 3 different options to choose the pass, suppose if you choose the 7 day pass you can, then you just have to find the upper bound of currDay value + 6 and similarly for other options.**\\n\\n```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int>& days, vector<int>& cost, vector<int> &dp){\\n        if(i>=days.size())  return 0;\\n        if(dp[i]!=-1)   return dp[i];\\n        int a=0,b=0,c=0;\\n        int ind = upper_bound(days.begin(), days.end(), days[i]+0)-days.begin();\\n        a = cost[0] + solve(ind,days,cost,dp);\\n        ind = upper_bound(days.begin(), days.end(), days[i]+6)-days.begin();\\n        b = cost[1] + solve(ind,days,cost,dp);\\n        ind = upper_bound(days.begin(), days.end(), days[i]+29)-days.begin();\\n        c = cost[2] + solve(ind,days,cost,dp);\\n\\n        return dp[i] = min({a,b,c});\\n\\n\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> dp(366,-1);\\n        return solve(0,days, costs,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(int i, vector<int>& days, vector<int>& cost, vector<int> &dp){\\n        if(i>=days.size())  return 0;\\n        if(dp[i]!=-1)   return dp[i];\\n        int a=0,b=0,c=0;\\n        int ind = upper_bound(days.begin(), days.end(), days[i]+0)-days.begin();\\n        a = cost[0] + solve(ind,days,cost,dp);\\n        ind = upper_bound(days.begin(), days.end(), days[i]+6)-days.begin();\\n        b = cost[1] + solve(ind,days,cost,dp);\\n        ind = upper_bound(days.begin(), days.end(), days[i]+29)-days.begin();\\n        c = cost[2] + solve(ind,days,cost,dp);\\n\\n        return dp[i] = min({a,b,c});\\n\\n\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        vector<int> dp(366,-1);\\n        return solve(0,days, costs,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968702,
                "title": "easy-to-understand-binary-search-with-dp-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    \\n    int getNextDay(vector<int>& days, int dayIdx, int numDays) {\\n        int lastDay = days[dayIdx] + numDays;\\n        auto it = lower_bound(begin(days)+dayIdx, end(days), lastDay);\\n        if(it == days.end()) return days.size();\\n        int newDayIdx = it - days.begin();\\n        return newDayIdx;\\n    }\\n    \\n    int getMinCost(vector<int>& days, vector<int>& costs, int dayIdx) {\\n        if (dayIdx == days.size())\\n            return 0;\\n        if (dp[dayIdx] != -1)\\n            return dp[dayIdx];\\n        // Assume on a given day we bought a particular ticket\\n        // then recurse on remaining days function getNextDay tells till what time\\n        // current ticket is valid\\n        int totalDayCost = costs[0] + getMinCost(days,costs,getNextDay(days,dayIdx,1));\\n        int totalWeekCost = costs[1] + getMinCost(days,costs,getNextDay(days,dayIdx,7));\\n        int totalMonthCost = costs[2] + getMinCost(days,costs,getNextDay(days,dayIdx,30));\\n        dp[dayIdx]  = min({totalDayCost,totalWeekCost,totalMonthCost});\\n        return dp[dayIdx];\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        dp = vector<int>(days.size(),-1);\\n        return getMinCost(days,costs,0);\\n    }\\n};\\n\\nclass Solution1 {\\npublic:\\n    vector<int> dp;\\n    \\n    int getNextDay(vector<int>& days, int dayIdx, int numDays) {\\n        int lastDay = days[dayIdx] + numDays-1;\\n        int newDayIdx = dayIdx;\\n        while(newDayIdx < days.size() && days[newDayIdx] <= lastDay)\\n            newDayIdx++;\\n        return newDayIdx;\\n    }\\n    int getMinCost(vector<int>& days, vector<int>& costs, int dayIdx) {\\n        if (dayIdx == days.size())\\n            return 0;\\n        if (dp[dayIdx] != -1)\\n            return dp[dayIdx];\\n        // Assume on a given day we bought a particular ticket\\n        // then recurse on remaining days function getNextDay tells till what time\\n        // current ticket is valid\\n        int totalDayCost = costs[0] + getMinCost(days,costs,getNextDay(days,dayIdx,1));\\n        int totalWeekCost = costs[1] + getMinCost(days,costs,getNextDay(days,dayIdx,7));\\n        int totalMonthCost = costs[2] + getMinCost(days,costs,getNextDay(days,dayIdx,30));\\n        dp[dayIdx]  = min({totalDayCost,totalWeekCost,totalMonthCost});\\n        return dp[dayIdx];\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        dp = vector<int>(days.size(),-1);\\n        return getMinCost(days,costs,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    \\n    int getNextDay(vector<int>& days, int dayIdx, int numDays) {\\n        int lastDay = days[dayIdx] + numDays;\\n        auto it = lower_bound(begin(days)+dayIdx, end(days), lastDay);\\n        if(it == days.end()) return days.size();\\n        int newDayIdx = it - days.begin();\\n        return newDayIdx;\\n    }\\n    \\n    int getMinCost(vector<int>& days, vector<int>& costs, int dayIdx) {\\n        if (dayIdx == days.size())\\n            return 0;\\n        if (dp[dayIdx] != -1)\\n            return dp[dayIdx];\\n        // Assume on a given day we bought a particular ticket\\n        // then recurse on remaining days function getNextDay tells till what time\\n        // current ticket is valid\\n        int totalDayCost = costs[0] + getMinCost(days,costs,getNextDay(days,dayIdx,1));\\n        int totalWeekCost = costs[1] + getMinCost(days,costs,getNextDay(days,dayIdx,7));\\n        int totalMonthCost = costs[2] + getMinCost(days,costs,getNextDay(days,dayIdx,30));\\n        dp[dayIdx]  = min({totalDayCost,totalWeekCost,totalMonthCost});\\n        return dp[dayIdx];\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        dp = vector<int>(days.size(),-1);\\n        return getMinCost(days,costs,0);\\n    }\\n};\\n\\nclass Solution1 {\\npublic:\\n    vector<int> dp;\\n    \\n    int getNextDay(vector<int>& days, int dayIdx, int numDays) {\\n        int lastDay = days[dayIdx] + numDays-1;\\n        int newDayIdx = dayIdx;\\n        while(newDayIdx < days.size() && days[newDayIdx] <= lastDay)\\n            newDayIdx++;\\n        return newDayIdx;\\n    }\\n    int getMinCost(vector<int>& days, vector<int>& costs, int dayIdx) {\\n        if (dayIdx == days.size())\\n            return 0;\\n        if (dp[dayIdx] != -1)\\n            return dp[dayIdx];\\n        // Assume on a given day we bought a particular ticket\\n        // then recurse on remaining days function getNextDay tells till what time\\n        // current ticket is valid\\n        int totalDayCost = costs[0] + getMinCost(days,costs,getNextDay(days,dayIdx,1));\\n        int totalWeekCost = costs[1] + getMinCost(days,costs,getNextDay(days,dayIdx,7));\\n        int totalMonthCost = costs[2] + getMinCost(days,costs,getNextDay(days,dayIdx,30));\\n        dp[dayIdx]  = min({totalDayCost,totalWeekCost,totalMonthCost});\\n        return dp[dayIdx];\\n    }\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n        dp = vector<int>(days.size(),-1);\\n        return getMinCost(days,costs,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2741364,
                "title": "python-simple-code-dp-with-binary-search-memoization-98-faster",
                "content": "\\tclass Solution:\\n\\t\\tdef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef solve(ind):\\n\\t\\t\\t\\tif ind>=len(days):\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\toneDayCost = costs[0]+solve(ind+1)\\n\\t\\t\\t\\ttwoDayCost=costs[1]\\n\\t\\t\\t\\ti=ind\\n\\t\\t\\t\\twhile i<len(days) and days[i]<days[ind]+7:\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\ttwoDayCost +=solve(i)\\n\\t\\t\\t\\tthreeDayCost=costs[2]\\n\\t\\t\\t\\ti=ind\\n\\t\\t\\t\\twhile i<len(days) and days[i]<days[ind]+30:\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\tthreeDayCost +=solve(i)\\n\\t\\t\\t\\treturn min(oneDayCost,twoDayCost,threeDayCost)\\n\\t\\t\\treturn solve(0)\\n\\n\\n\\t#With Binary Search\\n\\t\\tclass Solution:\\n\\t\\t\\tdef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\t\\t\\t\\t@lru_cache(None)\\n\\t\\t\\t\\tdef solve(ind):\\n\\t\\t\\t\\t\\tif ind>=len(days):\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\t\\toneDayCost = costs[0]+solve(ind+1)\\n\\t\\t\\t\\t\\ttwoDayCost=costs[1]\\n\\t\\t\\t\\t\\ti=bisect_left(days,days[ind]+7)\\n\\t\\t\\t\\t\\t# while i<len(days) and days[i]<days[ind]+7:\\n\\t\\t\\t\\t\\t#     i+=1\\n\\t\\t\\t\\t\\ttwoDayCost +=solve(i)\\n\\t\\t\\t\\t\\tthreeDayCost=costs[2]\\n\\t\\t\\t\\t\\ti=bisect_left(days,days[ind]+30)\\n\\t\\t\\t\\t\\t# while i<len(days) and days[i]<days[ind]+30:\\n\\t\\t\\t\\t\\t#     i+=1\\n\\t\\t\\t\\t\\tthreeDayCost +=solve(i)\\n\\t\\t\\t\\t\\treturn min(oneDayCost,twoDayCost,threeDayCost)\\n\\t\\t\\t\\treturn solve(0)\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\t\\t\\t@lru_cache(None)\\n\\t\\t\\tdef solve(ind):\\n\\t\\t\\t\\tif ind>=len(days):\\n\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\toneDayCost = costs[0]+solve(ind+1)\\n\\t\\t\\t\\ttwoDayCost=costs[1]\\n\\t\\t\\t\\ti=ind\\n\\t\\t\\t\\twhile i<len(days) and days[i]<days[ind]+7:\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\ttwoDayCost +=solve(i)\\n\\t\\t\\t\\tthreeDayCost=costs[2]\\n\\t\\t\\t\\ti=ind\\n\\t\\t\\t\\twhile i<len(days) and days[i]<days[ind]+30:\\n\\t\\t\\t\\t\\ti+=1\\n\\t\\t\\t\\tthreeDayCost +=solve(i)\\n\\t\\t\\t\\treturn min(oneDayCost,twoDayCost,threeDayCost)\\n\\t\\t\\treturn solve(0)\\n\\n\\n\\t#With Binary Search\\n\\t\\tclass Solution:\\n\\t\\t\\tdef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\t\\t\\t\\t@lru_cache(None)\\n\\t\\t\\t\\tdef solve(ind):\\n\\t\\t\\t\\t\\tif ind>=len(days):\\n\\t\\t\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\t\\toneDayCost = costs[0]+solve(ind+1)\\n\\t\\t\\t\\t\\ttwoDayCost=costs[1]\\n\\t\\t\\t\\t\\ti=bisect_left(days,days[ind]+7)\\n\\t\\t\\t\\t\\t# while i<len(days) and days[i]<days[ind]+7:\\n\\t\\t\\t\\t\\t#     i+=1\\n\\t\\t\\t\\t\\ttwoDayCost +=solve(i)\\n\\t\\t\\t\\t\\tthreeDayCost=costs[2]\\n\\t\\t\\t\\t\\ti=bisect_left(days,days[ind]+30)\\n\\t\\t\\t\\t\\t# while i<len(days) and days[i]<days[ind]+30:\\n\\t\\t\\t\\t\\t#     i+=1\\n\\t\\t\\t\\t\\tthreeDayCost +=solve(i)\\n\\t\\t\\t\\t\\treturn min(oneDayCost,twoDayCost,threeDayCost)\\n\\t\\t\\t\\treturn solve(0)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2491491,
                "title": "80-tc-easy-python-solution",
                "content": "```\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\tn = len(days)\\n\\tdp = dict()\\n\\tdef solve(i, m):\\n\\t\\tif(i == n): return 0\\n\\t\\tif(m >= days[i]):\\n\\t\\t\\treturn solve(i+1, m)\\n\\t\\tif(i in dp): return dp[i]\\n\\t\\tdp[i] = min([costs[0] + solve(i+1, days[i]), costs[1] + solve(i+1, days[i]+6), costs[2] + solve(i+1, days[i]+29)])\\n\\t\\treturn dp[i]\\n\\n\\treturn solve(0, 0)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\ndef mincostTickets(self, days: List[int], costs: List[int]) -> int:\\n\\tn = len(days)\\n\\tdp = dict()\\n\\tdef solve(i, m):\\n\\t\\tif(i == n): return 0\\n\\t\\tif(m >= days[i]):\\n\\t\\t\\treturn solve(i+1, m)\\n\\t\\tif(i in dp): return dp[i]\\n\\t\\tdp[i] = min([costs[0] + solve(i+1, days[i]), costs[1] + solve(i+1, days[i]+6), costs[2] + solve(i+1, days[i]+29)])\\n\\t\\treturn dp[i]\\n\\n\\treturn solve(0, 0)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2484497,
                "title": "easy-java-solution",
                "content": "```\\npublic int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int[] dp = new int[n + 1];\\n        dp[n] = 0;\\n        for(int k=n-1; k>=0; k--){\\n            int op1 = costs[0] + dp[k+1];\\n            int i;\\n            for(i=k; i<n && days[i] < days[k] + 7; i++);\\n            int op2 = costs[1] + dp[i];\\n\\n            for(i=k; i<n && days[i] < days[k] + 30; i++);\\n            int op3 = costs[2] + dp[i];\\n\\n            dp[k] = Math.min(op1, Math.min(op2, op3));\\n        }\\n        return dp[0];\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\npublic int mincostTickets(int[] days, int[] costs) {\\n        int n = days.length;\\n        int[] dp = new int[n + 1];\\n        dp[n] = 0;\\n        for(int k=n-1; k>=0; k--){\\n            int op1 = costs[0] + dp[k+1];\\n            int i;\\n            for(i=k; i<n && days[i] < days[k] + 7; i++);\\n            int op2 = costs[1] + dp[i];\\n\\n            for(i=k; i<n && days[i] < days[k] + 30; i++);\\n            int op3 = costs[2] + dp[i];\\n\\n            dp[k] = Math.min(op1, Math.min(op2, op3));\\n        }\\n        return dp[0];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2410873,
                "title": "c-3-methods-recursion-memoization-tabulation-method-solving-by-queue",
                "content": "```\\nclass Solution {\\n    \\n    \\n        \\n      int SolveMemo(int index , vector<int>& days, vector<int>& costs,  vector<int> &dp)\\n    {\\n        if(index  == days.size())\\n            return 0;\\n        \\n        if(dp[index] != -1)\\n            return dp[index];\\n        \\n        //1 day Pass\\n        int op1 = costs[0] + SolveMemo(index+1 , days, costs, dp);\\n        \\n        //7 Day pass\\n        int i = index+1 ;\\n        while( i<days.size() && days[i]-days[index]<7 )\\n            i++;\\n        \\n        int op2 = costs[1] + SolveMemo(i , days, costs, dp);\\n        \\n        //7 Day pass\\n         while( i<days.size() && days[i]-days[index]<30 )\\n             i++;\\n        \\n        int op3 = costs[2] + SolveMemo(i , days, costs, dp);\\n        \\n        return dp[index] = min(op1 , min(op2, op3));\\n    }\\n    \\n    int SolveTabulation(vector<int>& days, vector<int>& costs)\\n    {\\n          vector<int> dp(days.size()+1 , 0);\\n        \\n        for(int k = days.size()-1 ; k>=0 ; k--)\\n        {\\n             //1 day Pass\\n        int op1 = costs[0] + dp[k+1];\\n        \\n        //7 Day pass\\n        int i = k+1 ;\\n        while( i<days.size() && days[i]-days[k]<7 )\\n            i++;\\n        \\n        int op2 = costs[1] + dp[i];\\n        \\n        //7 Day pass\\n         while( i<days.size() && days[i]-days[k]<30 )\\n             i++;\\n        \\n        int op3 = costs[2] + dp[i];\\n            \\n            dp[k] =  min(op1 , min(op2, op3));\\n        }\\n        \\n        return dp[0];\\n    }\\n    \\n    int SolveByQueue(vector<int>& days, vector<int>& costs)\\n    {\\n        int ans  = 0;\\n        \\n        queue<pair<int, int>> week;\\n        \\n        queue<pair<int, int>> month;\\n        \\n        for (auto day : days)\\n    {\\n        while (!week.empty() && week.front().first + 7 <= day)\\n            week.pop();\\n\\n        while (!month.empty() && month.front().first + 30 <= day)\\n            month.pop();\\n\\n        week.push(make_pair(day, ans + costs[1]));\\n        month.push(make_pair(day, ans + costs[2]));\\n\\n        \\n        ans = min(ans + costs[0], min(week.front().second, month.front().second));\\n    }\\n\\n        \\n        return ans;\\n        \\n    }\\n    \\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n      \\n        // Recursion + Memoization -> Uncomment This Part\\n        // vector<int> dp(days.size() , -1);\\n        // return SolveMemo(0 , days, costs, dp);\\n        \\n        \\n        //Tabulation Method -> Uncomment this part\\n        //return SolveTabulation(days, costs);\\n        \\n        //Queue Method -> Uncomment This part\\n        return SolveByQueue(days, costs);\\n    }\\n};\\n\\n// Pls Upvote If You Like It , Thanks !!\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    \\n    \\n        \\n      int SolveMemo(int index , vector<int>& days, vector<int>& costs,  vector<int> &dp)\\n    {\\n        if(index  == days.size())\\n            return 0;\\n        \\n        if(dp[index] != -1)\\n            return dp[index];\\n        \\n        //1 day Pass\\n        int op1 = costs[0] + SolveMemo(index+1 , days, costs, dp);\\n        \\n        //7 Day pass\\n        int i = index+1 ;\\n        while( i<days.size() && days[i]-days[index]<7 )\\n            i++;\\n        \\n        int op2 = costs[1] + SolveMemo(i , days, costs, dp);\\n        \\n        //7 Day pass\\n         while( i<days.size() && days[i]-days[index]<30 )\\n             i++;\\n        \\n        int op3 = costs[2] + SolveMemo(i , days, costs, dp);\\n        \\n        return dp[index] = min(op1 , min(op2, op3));\\n    }\\n    \\n    int SolveTabulation(vector<int>& days, vector<int>& costs)\\n    {\\n          vector<int> dp(days.size()+1 , 0);\\n        \\n        for(int k = days.size()-1 ; k>=0 ; k--)\\n        {\\n             //1 day Pass\\n        int op1 = costs[0] + dp[k+1];\\n        \\n        //7 Day pass\\n        int i = k+1 ;\\n        while( i<days.size() && days[i]-days[k]<7 )\\n            i++;\\n        \\n        int op2 = costs[1] + dp[i];\\n        \\n        //7 Day pass\\n         while( i<days.size() && days[i]-days[k]<30 )\\n             i++;\\n        \\n        int op3 = costs[2] + dp[i];\\n            \\n            dp[k] =  min(op1 , min(op2, op3));\\n        }\\n        \\n        return dp[0];\\n    }\\n    \\n    int SolveByQueue(vector<int>& days, vector<int>& costs)\\n    {\\n        int ans  = 0;\\n        \\n        queue<pair<int, int>> week;\\n        \\n        queue<pair<int, int>> month;\\n        \\n        for (auto day : days)\\n    {\\n        while (!week.empty() && week.front().first + 7 <= day)\\n            week.pop();\\n\\n        while (!month.empty() && month.front().first + 30 <= day)\\n            month.pop();\\n\\n        week.push(make_pair(day, ans + costs[1]));\\n        month.push(make_pair(day, ans + costs[2]));\\n\\n        \\n        ans = min(ans + costs[0], min(week.front().second, month.front().second));\\n    }\\n\\n        \\n        return ans;\\n        \\n    }\\n    \\npublic:\\n    int mincostTickets(vector<int>& days, vector<int>& costs) {\\n      \\n        // Recursion + Memoization -> Uncomment This Part\\n        // vector<int> dp(days.size() , -1);\\n        // return SolveMemo(0 , days, costs, dp);\\n        \\n        \\n        //Tabulation Method -> Uncomment this part\\n        //return SolveTabulation(days, costs);\\n        \\n        //Queue Method -> Uncomment This part\\n        return SolveByQueue(days, costs);\\n    }\\n};\\n\\n// Pls Upvote If You Like It , Thanks !!\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1845832,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845956,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845802,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845977,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846107,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845764,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846389,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845961,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846119,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846118,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845832,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845956,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845802,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845977,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846107,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845764,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846389,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845961,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846119,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1846118,
                "content": [
                    {
                        "username": "Shubham_Raj22",
                        "content": "Tips:-\n\nNotice that the constraints are very small, thus we can figure out all possibilities and take the minimum of them , i.e. it's a `dp problem.`\n\nFor any day `'i'`, we can buy either of the 3 ticket and we are paid until ` ith,  i+6th or i+29th `day . Also keep in mind that the days are sorted so we can easily find the next unpaid day for each possibility. At each step we need to take minimum of these 3 possibilities "
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "[@cthulhuden](/cthulhuden) By DP I meant thinking of trying out all possibilities, if you memoize your solution, the code runs perfectly. You can my code submission in my profile "
                    },
                    {
                        "username": "cthulhuden",
                        "content": "First of all, what you describe is not dp (unless you already solved the problem for ith, I+6th, i+29th days, or you do memoization). And I don't believe brute forcing through more than 2^(365/7) options will fit in time limit."
                    },
                    {
                        "username": "arghyadas",
                        "content": "In the first example why did they start with day 3, when in the array it is given day 4?"
                    },
                    {
                        "username": "akhilesh80025",
                        "content": "you can assume day 3 or day 4 \\n "
                    },
                    {
                        "username": "cenjian",
                        "content": "[@jooel_io](/jooel_io) the travals are planned in advance."
                    },
                    {
                        "username": "mdsalmankhader",
                        "content": "[@anay2103](/anay2103) The passes are valid through 1,7 and 30 days right?"
                    },
                    {
                        "username": "jooel_io",
                        "content": "[@cenjian](/cenjian) it is a little strange for the example to not start on the \"next\" day (4) since you know that you\\'re not traveling on day 3, but dont know what comes after day 4 (if moving from left to right, linearly)"
                    },
                    {
                        "username": "anay2103",
                        "content": "The passes are valid through 2, 7 or 30 days, after that they expire.  "
                    },
                    {
                        "username": "cenjian",
                        "content": "no difference, as 3-9 and 4-10 cover the same 4days"
                    },
                    {
                        "username": "sushi27",
                        "content": "Alert ! Alert! DP week incoming"
                    },
                    {
                        "username": "AMerrill",
                        "content": "Can I just buy a lifetime pass for `costs[3]`?"
                    },
                    {
                        "username": "daring-calf",
                        "content": "This problem wrecked my new gained confidence from last week\\'s dfs \\n\\nT_T"
                    },
                    {
                        "username": "UchihaKim",
                        "content": "Seems like it\\'s dp week, hope you solve it guys."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "**Here is the Approach :-)**\\n\\n1. Create a set of travel days using the given \"days\" array.\\n2. Find the maximum day in the \"days\" array and add 1 to it. This will be the maximum day we need to consider for travel.\\n3. Create a DP array of size n (maximum day) and initialize it with zeros.\\n4. Traverse the DP array from day 1 to maximum day and for each day:\\n    - If the day is not a travel day, set the DP value equal to the DP value of the previous day.\\n    - If the day is a travel day, set the DP value to the minimum cost of:\\n       - buying a 1-day pass and adding its cost to the DP value of the previous day.\\n       - buying a 7-day pass and adding its cost to the DP value of the day 7 days before.\\n       - buying a 30-day pass and adding its cost to the DP value of the day 30 days before.\\n5. Return the DP value of the maximum day (n-1).\\n\\n**Time Complexity: O(N), where N is the maximum travel day. We are filling the dp array for each day from 1 to N.**\\n\\n**Space Complexity: O(N), where N is the maximum travel day. We are using a dp array of size N. Additionally, we are using a set to store the travel days, which can also take up to O(N) space in the worst case if all days are travel days.**"
                    },
                    {
                        "username": "Yashwanth14",
                        "content": "Good Explanation"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "Great explanation, still trying to wrap my head around it, but works like a charm :) "
                    },
                    {
                        "username": "sasukesharma",
                        "content": "**through this question only, i gonna travel the world\\nmy dream \\uD83D\\uDE25\\uD83D\\uDE2B**"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Easy and detailed explanation \\u2764 : https://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "**Small hint** : at each day i.e element in array, check if getting a one pass and then paying for rest of days will be better or getting a 7 day pass will be better since we wont have to pay cost for some days in future because of that 7 days pass. For each day, we have three pass options - choose the best. \\nHere is detailed explanation\\nhttps://leetcode.com/problems/minimum-cost-for-tickets/solutions/3350801/easy-detailed-explanation-step-by-step/"
                    }
                ]
            },
            {
                "id": 1845904,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1804885,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1846306,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1846022,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1845887,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 2059945,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1984501,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1923507,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1846891,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1846509,
                "content": [
                    {
                        "username": "le-incroyable1-dev",
                        "content": "The same coin change thing is used in so many places you can\\'t even count"
                    },
                    {
                        "username": "sepac",
                        "content": "Is `costs[0]<costs[1]<costs[2]`?"
                    },
                    {
                        "username": "charonme",
                        "content": "no, some testcases don\\'t have increasing costs"
                    },
                    {
                        "username": "Shubham_Raj22",
                        "content": "Nope, also it's not relevant to get the correct solution, if that gives you some hint."
                    },
                    {
                        "username": "namnguyenarsenal",
                        "content": "same question "
                    },
                    {
                        "username": "woundweavr",
                        "content": "I don\\'t see anything that guarantees that"
                    },
                    {
                        "username": "phalvinayak",
                        "content": "Yes its less than or equal given in the contraints 1 <= costs[i] <= 1000"
                    },
                    {
                        "username": "Vinaygoswami321",
                        "content": "I spent an hour thinking how to do this problem, but I failed."
                    },
                    {
                        "username": "cenjian",
                        "content": "hint: if you come across rumtime exceed, try @cache (if you code in python)"
                    },
                    {
                        "username": "kartik_p",
                        "content": "DP week! Should be fun."
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Why using static keyword in static Set<Integer>map=new HashSet<>(); at line 2 is not allowing test cases to pass ? \n `class Solution {\n     static Set< Integer>map=new HashSet<>();\n    static int dp[]=new int[395];\n    public int mincostTickets(int[] days, int[] costs) {\n        for(Integer d:days)\n        map.add(d);\n        for(int i=0;i<395;i++)\n        dp[i]=-1;\n        return solve(1,days,costs);\n    }\n    \n    int solve(int currentDay,int [] days, int costs[]){\n        if(currentDay > days[days.length - 1])\n        return 0;\n        if(!map.contains(currentDay))\n          return solve(currentDay+1, days,costs);\n          if(dp[currentDay]!=-1)\n          return dp[currentDay];\n          \n        int oneDay = costs[0] + solve( currentDay+1,days, costs);\n        int sevenDay = costs[1] + solve( currentDay+7,days, costs);\n        int thirtyDay = costs[2] + solve( currentDay+30,days, costs);\n          return dp[currentDay]=Math.min(oneDay, Math.min(sevenDay, thirtyDay));\n    }\n}`"
                    },
                    {
                        "username": "Harshitbit",
                        "content": "Input is days = [1,3,7] costs=[1,4,20]. Correct answer is 3 but I am getting 4. Although the same code when executed on eclipse IDE, I am getting 3."
                    },
                    {
                        "username": "nagarajramachandran123",
                        "content": "Two Clarification needed\\n1. Whether days are sorted on ascending?\\n2. Cost[0] < cost[1] < cost[2] - whether this condition is for all?"
                    },
                    {
                        "username": "whoisroni_",
                        "content": "In the first example why did they start with day 3?"
                    },
                    {
                        "username": "vhtnguyen",
                        "content": "In the first example, the sentence `On day 3, you bought a 7-day pass for costs[1] = $7, which covered days 3, 4, ..., 9` makes readers really confused because it said `on day 3` instead  `on day 4` ???"
                    },
                    {
                        "username": "skpatil262020",
                        "content": " `public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    }
                ]
            },
            {
                "id": 1846507,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846375,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846216,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846198,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846189,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846185,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846055,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846043,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1846021,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            },
            {
                "id": 1845979,
                "content": [
                    {
                        "username": "skpatil262020",
                        "content": "public int mincostTickets(int[] days, int[] costs) {\\n    int[] dp = new int[days.length];\\n    Arrays.fill(dp, Integer.MAX_VALUE);\\n    \\n    for (int i = 0; i < days.length; i++) {\\n        if (i == 0) {\\n            dp[i] = Math.min(costs[0], Math.min(costs[1], costs[2]));\\n        } else {\\n            int oneDayPass = dp[i - 1] + costs[0];\\n            int sevenDayPass = dp[findDay(days, days[i] - 7)] + costs[1];\\n            int thirtyDayPass = dp[findDay(days, days[i] - 30)] + costs[2];\\n            dp[i] = Math.min(oneDayPass, Math.min(sevenDayPass, thirtyDayPass));\\n        }\\n    }\\n    return dp[days.length - 1];\\n}\\n\\nprivate int findDay(int[] days, int target) {\\n    int left = 0, right = days.length - 1;\\n    while (left <= right) {\\n        int mid = left + (right - left) / 2;\\n        if (days[mid] == target) {\\n            return mid;\\n        } else if (days[mid] < target) {\\n            left = mid + 1;\\n        } else {\\n            right = mid - 1;\\n        }\\n    }\\n    return -1;\\n}\\n"
                    },
                    {
                        "username": "prathmesh_24",
                        "content": "TLE Week.  (\\xB0\\u30FC\\xB0\\u3003)"
                    },
                    {
                        "username": "nirajthakare",
                        "content": "pathetic description \\uD83D\\uDE42"
                    },
                    {
                        "username": "0icy",
                        "content": "you need to learn english buddy"
                    },
                    {
                        "username": "tandalesamarth",
                        "content": "Given this is a problem of dp, I wonder what would be the tabulation solution for this ... ?"
                    },
                    {
                        "username": "yogesh713",
                        "content": "This week is More interesting . DP Week :)"
                    },
                    {
                        "username": "x-ider",
                        "content": "Just wanted to cry somewhere that I\\'m struggling with TLE on test #48. Thank you for attention \\uD83D\\uDE2D"
                    },
                    {
                        "username": "justsolveitlmao",
                        "content": "\\u200E\\uFE0F\\u200D\\uD83D\\uDD25+1"
                    },
                    {
                        "username": "Kirchen99",
                        "content": "Is a 1-day pass guaranteed to be cheaper than a 7-day pass and a 7-day pass guaranteed to be cheaper than a 30-day pass?"
                    },
                    {
                        "username": "naveenoffl2002",
                        "content": "No, the 30 day-pass can even be less than 1-day pass."
                    },
                    {
                        "username": "meow_power",
                        "content": "it\\'s such a beautiful question for a beginner like me:)"
                    },
                    {
                        "username": "daemon777",
                        "content": "**Help Needed!**\n`days = [1,4,6,9,10,11,12,13,14,15,16,17,18,20,21,22,23,27,28]\ncosts = [3,13,45]`\nCan anyone explain this test case?\nIt's correct output is 44, and my solution gives 45.\nThanks in advance."
                    },
                    {
                        "username": "tahakothawala",
                        "content": "Still stuck on this test case. Please help! Below is my code:\\n\\nclass Solution {\\n    public int mincostTickets(int[] days, int[] costs) {\\n        int ticketsBoughtUntil = 0;\\n        int sum = 0;\\n        for(int i=0;i<days.length;i++) {\\n            if(days[i] <= ticketsBoughtUntil) continue;\\n            float a = costs[0];\\n            int j = i;\\n            while(j < days.length && days[j] <= days[i] + 6) j++;\\n            float b = costs[1]/(float)(j-i);\\n            j = i;\\n            while(j < days.length && days[j] <= days[i] + 29) j++;\\n            float c = costs[2]/(float)(j-i);\\n            float min = a;\\n            ticketsBoughtUntil = days[i];\\n            int index = 0;\\n            if(b < min) {\\n                min = b;\\n                ticketsBoughtUntil = days[i] + 6;\\n                index = 1;\\n            }\\n            if(c < min) {\\n                min = c;\\n                ticketsBoughtUntil = days[i] + 29;\\n                index = 2;\\n            }\\n            sum += costs[index];\\n        }\\n        return sum;\\n    }\\n}"
                    },
                    {
                        "username": "akeempositive",
                        "content": "same here 45"
                    },
                    {
                        "username": "wyleungad",
                        "content": "I got 45 in this test case too. Did you solve this issue?"
                    },
                    {
                        "username": "daemon777",
                        "content": "[@c4tdog](/c4tdog)  thanks"
                    },
                    {
                        "username": "c4tdog",
                        "content": "first 3 (days 1,4,6) buy one-day ticket ($3 * 3 = $9), from 9th to 22th use 7-day ticket ($13 * 2 = $26). last 3 days - also one-day ticket ($3 * 3 = $9). Total = 9 + 26 + 9 = 44"
                    }
                ]
            }
        ]
    },
    {
        "title": "Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit",
        "question_content": "<p>Given an array of integers <code>nums</code> and an integer <code>limit</code>, return the size of the longest <strong>non-empty</strong> subarray such that the absolute difference between any two elements of this subarray is less than or equal to <code>limit</code><em>.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [8,2,4,7], limit = 4\n<strong>Output:</strong> 2 \n<strong>Explanation:</strong> All subarrays are: \n[8] with maximum absolute diff |8-8| = 0 &lt;= 4.\n[8,2] with maximum absolute diff |8-2| = 6 &gt; 4. \n[8,2,4] with maximum absolute diff |8-2| = 6 &gt; 4.\n[8,2,4,7] with maximum absolute diff |8-2| = 6 &gt; 4.\n[2] with maximum absolute diff |2-2| = 0 &lt;= 4.\n[2,4] with maximum absolute diff |2-4| = 2 &lt;= 4.\n[2,4,7] with maximum absolute diff |2-7| = 5 &gt; 4.\n[4] with maximum absolute diff |4-4| = 0 &lt;= 4.\n[4,7] with maximum absolute diff |4-7| = 3 &lt;= 4.\n[7] with maximum absolute diff |7-7| = 0 &lt;= 4. \nTherefore, the size of the longest subarray is 2.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [10,1,2,4,7,2], limit = 5\n<strong>Output:</strong> 4 \n<strong>Explanation:</strong> The subarray [2,4,7,2] is the longest since the maximum absolute diff is |2-7| = 5 &lt;= 5.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [4,2,2,2,4,4,2,2], limit = 0\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= limit &lt;= 10<sup>9</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 609771,
                "title": "java-c-python-deques-o-n",
                "content": "# **Intuition**\\nLast week we learned,\\nin [1425. Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\nhow to get minimum in a subarray when sliding.\\n\\nThis week, we need to get both the maximum and the minimum,\\nat the same time.\\n\\nSo I opened my post last week,\\nand copy some my own codes.\\n<br>\\n\\n\\n# **Solution 0**: Binary insert and remove\\nKeep an increasing list `L`.\\nBinary insert the current element.\\nIf the `L[L.size() - 1] - L[0] > limit`,\\nbinary search the position of `A[i]` and remove it from the list.\\n\\nTime `O(N^2)`\\nSpace `O(N)`\\n<br>\\n\\n```python\\n    def longestSubarray(self, A, limit):\\n        i, L = 0, []\\n        for j in xrange(len(A)):\\n            bisect.insort(L, A[j])\\n            if L[-1] - L[0] > limit:\\n                L.pop(bisect.bisect(L, A[i]) - 1)\\n                i += 1\\n        return j - i + 1\\n```\\n<br>\\n\\n# **Solution 1: Use two heaps**\\nTime `O(NogN)`\\nSpace `O(N)`\\n<br>\\n\\n**Python**\\n```py\\n    def longestSubarray(self, A, limit):\\n        maxq, minq = [], []\\n        res = i = 0\\n        for j, a in enumerate(A):\\n            heapq.heappush(maxq, [-a, j])\\n            heapq.heappush(minq, [a, j])\\n            while -maxq[0][0] - minq[0][0] > limit:\\n                i = min(maxq[0][1], minq[0][1]) + 1\\n                while maxq[0][1] < i: heapq.heappop(maxq)\\n                while minq[0][1] < i: heapq.heappop(minq)\\n            res = max(res, j - i + 1)\\n        return res\\n```\\n<br>\\n\\n# **Solution 2: Use TreeMap**\\nUse one tree map can easily get the maximum and the minimum at the same time.\\nIn java, we can use `TreeMap` to count elements.\\nIn cpp, it suports multi treeset, that\\'s even better.\\n\\nTime `O(NogN)`\\nSpace `O(N)`\\n\\n**Java**\\n@prdp89\\n```java\\npublic int longestSubarray(int[] A, int limit) {\\n    int i = 0, j;\\n    TreeMap<Integer, Integer> m = new TreeMap<>();\\n    for (j = 0; j < A.length; j++) {\\n        m.put(A[j], 1 + m.getOrDefault(A[j], 0));\\n        if (m.lastEntry().getKey() - m.firstEntry().getKey() > limit) {\\n            m.put(A[i], m.get(A[i]) - 1);\\n            if (m.get(A[i]) == 0)\\n                m.remove(A[i]);\\n            i++;\\n        }\\n    }\\n    return j - i;\\n}\\n```\\n**C++**\\n```cpp\\n    int longestSubarray(vector<int>& A, int limit) {\\n        int i = 0, j;\\n        multiset<int> m;\\n        for (j = 0; j < A.size(); ++j) {\\n            m.insert(A[j]);\\n            if (*m.rbegin() - *m.begin() > limit)\\n                m.erase(m.find(A[i++]));\\n        }\\n        return j - i;\\n    }\\n```\\n<br>\\n\\n\\n# **Solution 3: Use two deques**\\nTime `O(N)`\\nSpace `O(N)`\\n<br>\\n\\n**Java**\\n```java\\n    public int longestSubarray(int[] A, int limit) {\\n        Deque<Integer> maxd = new ArrayDeque<>();\\n        Deque<Integer> mind = new ArrayDeque<>();\\n        int i = 0, j;\\n        for (j = 0; j < A.length; ++j) {\\n            while (!maxd.isEmpty() && A[j] > maxd.peekLast()) maxd.pollLast();\\n            while (!mind.isEmpty() && A[j] < mind.peekLast()) mind.pollLast();\\n            maxd.add(A[j]);\\n            mind.add(A[j]);\\n            if (maxd.peek() - mind.peek() > limit) {\\n                if (maxd.peek() == A[i]) maxd.poll();\\n                if (mind.peek() == A[i]) mind.poll();\\n                ++i;\\n            }\\n        }\\n        return j - i;\\n    }\\n```\\n**C++**\\n```cpp\\n    int longestSubarray(vector<int>& A, int limit) {\\n        deque<int> maxd, mind;\\n        int i = 0, j;\\n        for (j = 0; j < A.size(); ++j) {\\n            while (!maxd.empty() && A[j] > maxd.back()) maxd.pop_back();\\n            while (!mind.empty() && A[j] < mind.back()) mind.pop_back();\\n            maxd.push_back(A[j]);\\n            mind.push_back(A[j]);\\n            if (maxd.front() - mind.front() > limit) {\\n                if (maxd.front() == A[i]) maxd.pop_front();\\n                if (mind.front() == A[i]) mind.pop_front();\\n                ++i;\\n            }\\n        }\\n        return j - i;\\n    }\\n```\\n**Python**\\n```py\\n    def longestSubarray(self, A, limit):\\n        maxd = collections.deque()\\n        mind = collections.deque()\\n        i = 0\\n        for a in A:\\n            while len(maxd) and a > maxd[-1]: maxd.pop()\\n            while len(mind) and a < mind[-1]: mind.pop()\\n            maxd.append(a)\\n            mind.append(a)\\n            if maxd[0] - mind[0] > limit:\\n                if maxd[0] == A[i]: maxd.popleft()\\n                if mind[0] == A[i]: mind.popleft()\\n                i += 1\\n        return len(A) - i\\n```\\n<br>\\n\\n# More Similar Sliding Window Problems\\nHere are some similar sliding window problems.\\nAlso find more explanations.\\nIf you have question about the complexity and `if/while` clause,\\npick an easier one first.\\n\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1358. [Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/discuss/516977/JavaC++Python-Easy-and-Concise)\\n- 1248. [Count Number of Nice Subarrays](https://leetcode.com/problems/count-number-of-nice-subarrays/discuss/419378/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n- 1234. [Replace the Substring for Balanced String](https://leetcode.com/problems/replace-the-substring-for-balanced-string/discuss/408978/javacpython-sliding-window/367697)\\n- 1004. [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/247564/javacpython-sliding-window/379427?page=3)\\n-  930. [Binary Subarrays With Sum](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/186683/)\\n-  992. [Subarrays with K Different Integers](https://leetcode.com/problems/subarrays-with-k-different-integers/discuss/234482/JavaC%2B%2BPython-Sliding-Window-atMost(K)-atMost(K-1))\\n-  904. [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/discuss/170740/Sliding-Window-for-K-Elements)\\n-  862. [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/discuss/143726/C%2B%2BJavaPython-O(N)-Using-Deque)\\n-  209. [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/433123/JavaC++Python-Sliding-Window)\\n<br>\\n\\n# More Good Stack Problems\\nHere are some stack problems that impressed me.\\n\\n- 1425. [Constrained Subsequence Sum](https://leetcode.com/problems/constrained-subsequence-sum/discuss/597751/JavaC++Python-O(N)-Decreasing-Deque)\\n- 1130. [Minimum Cost Tree From Leaf Values](https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/discuss/339959/One-Pass-O(N)-Time-and-Space)\\n- 907. [Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/discuss/170750/C++JavaPython-Stack-Solution)\\n- 901. [Online Stock Span](https://leetcode.com/problems/online-stock-span/discuss/168311/C++JavaPython-O(1))\\n- 856. [Score of Parentheses](https://leetcode.com/problems/score-of-parentheses/discuss/141777/C++JavaPython-O(1)-Space)\\n- 503. [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/discuss/98270/JavaC++Python-Loop-Twice)\\n- 496. Next Greater Element I\\n- 84. Largest Rectangle in Histogram\\n- 42. Trapping Rain Water\\n<br>\\n\\n# **FAQ**\\n**Q:** Why doest the return value work? Why use `if` instead of `while`\\n**A:** Please refer to the discussion of @hzfmer\\n(Maybe I should summary up an explanation)\\n\\n**Q:** Is your first thought compared with what @hzfmer suggests?\\n**A:**  If you follow my posts, you\\'ll know that I use them everywhere.\\n",
                "solutionTags": [],
                "code": "```python\\n    def longestSubarray(self, A, limit):\\n        i, L = 0, []\\n        for j in xrange(len(A)):\\n            bisect.insort(L, A[j])\\n            if L[-1] - L[0] > limit:\\n                L.pop(bisect.bisect(L, A[i]) - 1)\\n                i += 1\\n        return j - i + 1\\n```\n```py\\n    def longestSubarray(self, A, limit):\\n        maxq, minq = [], []\\n        res = i = 0\\n        for j, a in enumerate(A):\\n            heapq.heappush(maxq, [-a, j])\\n            heapq.heappush(minq, [a, j])\\n            while -maxq[0][0] - minq[0][0] > limit:\\n                i = min(maxq[0][1], minq[0][1]) + 1\\n                while maxq[0][1] < i: heapq.heappop(maxq)\\n                while minq[0][1] < i: heapq.heappop(minq)\\n            res = max(res, j - i + 1)\\n        return res\\n```\n```java\\npublic int longestSubarray(int[] A, int limit) {\\n    int i = 0, j;\\n    TreeMap<Integer, Integer> m = new TreeMap<>();\\n    for (j = 0; j < A.length; j++) {\\n        m.put(A[j], 1 + m.getOrDefault(A[j], 0));\\n        if (m.lastEntry().getKey() - m.firstEntry().getKey() > limit) {\\n            m.put(A[i], m.get(A[i]) - 1);\\n            if (m.get(A[i]) == 0)\\n                m.remove(A[i]);\\n            i++;\\n        }\\n    }\\n    return j - i;\\n}\\n```\n```cpp\\n    int longestSubarray(vector<int>& A, int limit) {\\n        int i = 0, j;\\n        multiset<int> m;\\n        for (j = 0; j < A.size(); ++j) {\\n            m.insert(A[j]);\\n            if (*m.rbegin() - *m.begin() > limit)\\n                m.erase(m.find(A[i++]));\\n        }\\n        return j - i;\\n    }\\n```\n```java\\n    public int longestSubarray(int[] A, int limit) {\\n        Deque<Integer> maxd = new ArrayDeque<>();\\n        Deque<Integer> mind = new ArrayDeque<>();\\n        int i = 0, j;\\n        for (j = 0; j < A.length; ++j) {\\n            while (!maxd.isEmpty() && A[j] > maxd.peekLast()) maxd.pollLast();\\n            while (!mind.isEmpty() && A[j] < mind.peekLast()) mind.pollLast();\\n            maxd.add(A[j]);\\n            mind.add(A[j]);\\n            if (maxd.peek() - mind.peek() > limit) {\\n                if (maxd.peek() == A[i]) maxd.poll();\\n                if (mind.peek() == A[i]) mind.poll();\\n                ++i;\\n            }\\n        }\\n        return j - i;\\n    }\\n```\n```cpp\\n    int longestSubarray(vector<int>& A, int limit) {\\n        deque<int> maxd, mind;\\n        int i = 0, j;\\n        for (j = 0; j < A.size(); ++j) {\\n            while (!maxd.empty() && A[j] > maxd.back()) maxd.pop_back();\\n            while (!mind.empty() && A[j] < mind.back()) mind.pop_back();\\n            maxd.push_back(A[j]);\\n            mind.push_back(A[j]);\\n            if (maxd.front() - mind.front() > limit) {\\n                if (maxd.front() == A[i]) maxd.pop_front();\\n                if (mind.front() == A[i]) mind.pop_front();\\n                ++i;\\n            }\\n        }\\n        return j - i;\\n    }\\n```\n```py\\n    def longestSubarray(self, A, limit):\\n        maxd = collections.deque()\\n        mind = collections.deque()\\n        i = 0\\n        for a in A:\\n            while len(maxd) and a > maxd[-1]: maxd.pop()\\n            while len(mind) and a < mind[-1]: mind.pop()\\n            maxd.append(a)\\n            mind.append(a)\\n            if maxd[0] - mind[0] > limit:\\n                if maxd[0] == A[i]: maxd.popleft()\\n                if mind[0] == A[i]: mind.popleft()\\n                i += 1\\n        return len(A) - i\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 609743,
                "title": "java-detailed-explanation-sliding-window-deque-o-n",
                "content": "**Key Notes:**\\n1. \"Absolute difference between **any two elements** is less than or equal to limit\" is basically => \"Absolute difference between **min and max elements** of subarray\"\\n2. Now the question becomes => find the longest subarray in which the absolute difference between min and max is less than or equal to limit. What we can do is to have two pointers: left and right, and then **find the longest subarray for every right pointer (iterate it) by shrinking left pointer.** And return the longest one among them.\\n3. Let\\'s work on sliding window max first. How to efficiently find [239. sliding window maximum](https://leetcode.com/problems/sliding-window-maximum/)? \\n\\tBy using max Deque. We maintain list of max element candidates in **monotonically decreasing order**. Everytime the right pointer reaches a new position, we need to dequeue the \"tail\" element who is smaller than the nums[right]. Since, **those \"old small tail\" elements will never be the range maximum from now on.** After \"clean up\" the \"old small tail\" elements, add nums[right] into the deque, and then, **the head of deque is the current maximum.**\\n\\t\\n\\tSame for the min Deque. Move right poniter by 1, and clean up \"old big tail\" elements, add nums[right], the head of deque is the current minimum.\\n\\t\\n\\tWhat we should do next is to **shrink left pointer** because of limit. If current.max - current.min > limit. We should move the left pointer. Accordingdly, we need to **update our min max deques**. If head of max deque is equal to the nums[left], that means, **it is the one, we need to dequeue it**, since we are gonna move the left pointer by 1. (Note: nums[left] will be never larger than head of max deque, and if nums[left] is smaller than the head, we good, keep moving left pointer until satisfying the limit).\\n\\t\\n```java\\nDeque<Integer> maxDeque = new LinkedList<>();\\nDeque<Integer> minDeque = new LinkedList<>();\\n\\nint res = 1;\\n\\nint l = 0;\\n\\n// find the longest subarray for every right pointer by shrinking left pointer\\nfor (int r = 0; r < nums.length; ++r) {\\n\\n\\t// update maxDeque with new right pointer\\n\\twhile (!maxDeque.isEmpty() && maxDeque.peekLast() < nums[r]) {\\n\\t\\tmaxDeque.removeLast();\\n\\t}\\n\\tmaxDeque.addLast(nums[r]);\\n\\n\\t// update minDeque with new right pointer\\n\\twhile (!minDeque.isEmpty() && minDeque.peekLast() > nums[r]) {\\n\\t\\tminDeque.removeLast();\\n\\t}\\n\\tminDeque.addLast(nums[r]);\\n\\n\\t// shrink left pointer if exceed limit\\n\\twhile (maxDeque.peekFirst() - minDeque.peekFirst() > limit) {\\n\\t\\tif (maxDeque.peekFirst() == nums[l]) maxDeque.pollFirst();\\n\\t\\tif (minDeque.peekFirst() == nums[l]) minDeque.pollFirst();\\n\\t\\t++l;  // shrink it!\\n\\t}\\n\\n\\t// update res\\n\\tres = Math.max(res, r - l + 1);\\n}\\n\\nreturn res;\\n```",
                "solutionTags": [],
                "code": "```java\\nDeque<Integer> maxDeque = new LinkedList<>();\\nDeque<Integer> minDeque = new LinkedList<>();\\n\\nint res = 1;\\n\\nint l = 0;\\n\\n// find the longest subarray for every right pointer by shrinking left pointer\\nfor (int r = 0; r < nums.length; ++r) {\\n\\n\\t// update maxDeque with new right pointer\\n\\twhile (!maxDeque.isEmpty() && maxDeque.peekLast() < nums[r]) {\\n\\t\\tmaxDeque.removeLast();\\n\\t}\\n\\tmaxDeque.addLast(nums[r]);\\n\\n\\t// update minDeque with new right pointer\\n\\twhile (!minDeque.isEmpty() && minDeque.peekLast() > nums[r]) {\\n\\t\\tminDeque.removeLast();\\n\\t}\\n\\tminDeque.addLast(nums[r]);\\n\\n\\t// shrink left pointer if exceed limit\\n\\twhile (maxDeque.peekFirst() - minDeque.peekFirst() > limit) {\\n\\t\\tif (maxDeque.peekFirst() == nums[l]) maxDeque.pollFirst();\\n\\t\\tif (minDeque.peekFirst() == nums[l]) minDeque.pollFirst();\\n\\t\\t++l;  // shrink it!\\n\\t}\\n\\n\\t// update res\\n\\tres = Math.max(res, r - l + 1);\\n}\\n\\nreturn res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 609708,
                "title": "python-clean-monotonic-queue-solution-with-detail-explanation-o-n",
                "content": "**Explanation**\\n\\nThe idea is to use sliding window and two monotonic queues to keep track of the window max and window min. \\n\\nIn the beginning,  we set both left pointer `l` and right pointer  `r` at index 0. We keep moving `r`  forward until the max absolute difference within the window exceeds the limit. Then, we move forward `l` until the max absolute difference falls back within the limit. \\n\\nWe know that:\\n\\n- max absolute difference = max value within the window - min value within the window\\n\\nThe tricky part  is to get the max and min value within a window. To do so, we can use two monotonic queues: `min_deque` and `max_deque`.\\n\\n`min_deque` is monotonically increasing and `max_deque` is monotonically decreasing. In this way, `min_deque[0]` will be the min value within a window and `max_deque[0]` will be the max value within the window.\\n\\nWe can store index in `min_deque` and `max_deque` to get rid of out-of-window numbers more easily. So we will use `nums[min_deque[0]]` instead of `min_deque[0]` to get numbers. The concept stays the same.\\n\\n<br />\\n\\n**Complexity**\\n\\nTime complexity: `O(N)`\\nSpace complexity: `O(N)`\\n\\n<br />\\n\\n**Python**\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        min_deque, max_deque = deque(), deque()\\n        l = r = 0\\n        ans = 0\\n        while r < len(nums):\\n            while min_deque and nums[r] <= nums[min_deque[-1]]:\\n                min_deque.pop()\\n            while max_deque and nums[r] >= nums[max_deque[-1]]:\\n                max_deque.pop()\\n            min_deque.append(r)\\n            max_deque.append(r)\\n            \\n            while nums[max_deque[0]] - nums[min_deque[0]] > limit:\\n                l += 1\\n                if l > min_deque[0]:\\n                    min_deque.popleft()\\n                if l > max_deque[0]:\\n                    max_deque.popleft()\\n            \\n            ans = max(ans, r - l + 1)\\n            r += 1\\n                \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        min_deque, max_deque = deque(), deque()\\n        l = r = 0\\n        ans = 0\\n        while r < len(nums):\\n            while min_deque and nums[r] <= nums[min_deque[-1]]:\\n                min_deque.pop()\\n            while max_deque and nums[r] >= nums[max_deque[-1]]:\\n                max_deque.pop()\\n            min_deque.append(r)\\n            max_deque.append(r)\\n            \\n            while nums[max_deque[0]] - nums[min_deque[0]] > limit:\\n                l += 1\\n                if l > min_deque[0]:\\n                    min_deque.popleft()\\n                if l > max_deque[0]:\\n                    max_deque.popleft()\\n            \\n            ans = max(ans, r - l + 1)\\n            r += 1\\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609705,
                "title": "java-simple-o-n-log-n-sliding-window-treeset",
                "content": "A TreeSet can be used to store the indices of all current values in the range, with O(logN) time for adding and O(logN) time for removing. It also provides O(1) access to current min and max. When an element is added to the right, the smallest index in the TreeSet is removed until max - min <= limit. Once the sequence is valid, the result is updated. I know this isn\\'t the fastest solution, but I found it quite simple, and I imagine that it would be easy to understand.\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int left = 0;\\n        TreeSet<Integer> set = new TreeSet<>((a, b) -> nums[a] == nums[b] ? a - b : nums[a] - nums[b]);\\n        set.add(0);\\n        int res = 1;\\n        for (int right = 1; right < nums.length; right++) {\\n            set.add(right);\\n            while (nums[set.last()] - nums[set.first()] > limit) {\\n                set.remove(left++);\\n            }\\n            res = Math.max(res, right - left + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int left = 0;\\n        TreeSet<Integer> set = new TreeSet<>((a, b) -> nums[a] == nums[b] ? a - b : nums[a] - nums[b]);\\n        set.add(0);\\n        int res = 1;\\n        for (int right = 1; right < nums.length; right++) {\\n            set.add(right);\\n            while (nums[set.last()] - nums[set.first()] > limit) {\\n                set.remove(left++);\\n            }\\n            res = Math.max(res, right - left + 1);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609969,
                "title": "c-solution-with-detailed-explanation",
                "content": "```\\nWe will have to store the elements in a multiset and check if the last element and first element difference is greater than limit.\\nWe will be having two pointers let i & j be the pointers.\\nWe keep incrementing i until the first element and the last element of the multiset is greater than limit.\\nIf so we find the element nums[i] and erase it fromt our multiset and increment i.\\nWe simutaneously cache in the maximum\\nnums = [8,2,4,7], limit = 4\\n        ^\\n        |\\n        i,j\\n\\nmultiset m = [8]\\ncheck if (*m.rbegin()-m.begin()>limit)\\n            |\\n            last element(NOTE:m.end() is not the last element it is the terminating character).\\n8-8<=4 so we continue whilst storing the maximum = 1\\n\\n[8,2,4,7]\\n ^ ^\\n | |\\n i j\\nm=[8,2]\\n\\nif (*m.rbegin()-m.begin()>limit) condition:true\\n\\tso we search for nums[i] and delete.\\nm=[2]\\n\\n\\n[8,2,4,7]\\n   ^ ^\\n   | |\\n   i j\\nm[2,4]\\nif (*m.rbegin()-m.begin()>limit) condition:false\\nmaximum=2\\n\\n[8,2,4,7]\\n   ^   ^\\n   |   |\\n   i   j\\nm=[2,4,7]\\nif (*m.rbegin()-m.begin()>limit) condition:true\\nso we search for nums[i] and delete.\\nm=[2,4,7]\\n\\n[8,2,4,7]\\n     ^   ^\\n     |   |\\n     i   j\\nas j has terminated our answer will become 2\\n\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        multiset<int> m;\\n        int j=0,ans=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m.insert(nums[i]);\\n            while(!m.empty() && *m.rbegin()-*m.begin()>limit)\\n                m.erase(m.find(nums[j++]));\\n            ans=max(ans,i-j+1);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nWe will have to store the elements in a multiset and check if the last element and first element difference is greater than limit.\\nWe will be having two pointers let i & j be the pointers.\\nWe keep incrementing i until the first element and the last element of the multiset is greater than limit.\\nIf so we find the element nums[i] and erase it fromt our multiset and increment i.\\nWe simutaneously cache in the maximum\\nnums = [8,2,4,7], limit = 4\\n        ^\\n        |\\n        i,j\\n\\nmultiset m = [8]\\ncheck if (*m.rbegin()-m.begin()>limit)\\n            |\\n            last element(NOTE:m.end() is not the last element it is the terminating character).\\n8-8<=4 so we continue whilst storing the maximum = 1\\n\\n[8,2,4,7]\\n ^ ^\\n | |\\n i j\\nm=[8,2]\\n\\nif (*m.rbegin()-m.begin()>limit) condition:true\\n\\tso we search for nums[i] and delete.\\nm=[2]\\n\\n\\n[8,2,4,7]\\n   ^ ^\\n   | |\\n   i j\\nm[2,4]\\nif (*m.rbegin()-m.begin()>limit) condition:false\\nmaximum=2\\n\\n[8,2,4,7]\\n   ^   ^\\n   |   |\\n   i   j\\nm=[2,4,7]\\nif (*m.rbegin()-m.begin()>limit) condition:true\\nso we search for nums[i] and delete.\\nm=[2,4,7]\\n\\n[8,2,4,7]\\n     ^   ^\\n     |   |\\n     i   j\\nas j has terminated our answer will become 2\\n\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        multiset<int> m;\\n        int j=0,ans=1;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            m.insert(nums[i]);\\n            while(!m.empty() && *m.rbegin()-*m.begin()>limit)\\n                m.erase(m.find(nums[j++]));\\n            ans=max(ans,i-j+1);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1178332,
                "title": "java-deque-solution-with-explanation",
                "content": "To solve this question you can use a sliding window. Before expanding the window, we have to check if every pair of numbers within the window has an absolute difference less than the limit. But how do we do that? \\n\\nWe could generate all pairs of numbers within the window, and check their differences, but that would lead to an N^2 solution. If only we could keep track of the max number in the window, and the min number in the window...\\n\\nUnfortunately, we cannot figure out the max and min numbers in our current window by doing something like `max = Math.max(max, arr[i]) ` and `min = Math.min(min, arr[i])` because when the time comes to contract the window (by incrementing the left pointer), we will have no idea if the number we are removing from the window was the max or the min.\\n\\nSo this is why we use Deques.\\nWe use 2 of them. One maintains the numbers we have seen so far in decreasing order (so that max element in the window will be at the front of the queue, or left side of the queue), and the other deque will maintain the numbers we have seen so far in increasing order (so the min number in the queue will be at the front, aka the left side of the queue). \\n\\nAs we iterate through the array, before we add the number to the queues, we check if this number is bigger than the number at the end of the max queue. While this is true, we remove numbers from the end of the max queue. Why do we remove them? Because we want the max queue to contain numbers in a decreasing order. If the number at the end of the max queue (the right side of the queue) is less than the current number we are on in the array, we shouldn\\'t add the number until we remove all numbers less than it. This ensures that the max queue always maintains the numbers we\\'ve seen already in decreasing order.\\n\\nThe same goes for the min queue. Before we add this number to the min queue, we check to see if its smaller than the number at the end of the minQueue. While this is true, we poll from the min queue. This ensures that the numbers being added to the minqueue are increasing order. We want the smallest number we\\'ve seen so far to be the first number in the minqueue.\\n\\nNow we just have to look at the front of both queues, and subtract those numbers. If the difference is under or equal to the limit, we record the size of the current window, and then try to expand the window again.\\n\\nIf the difference is greater than the window, we need to make the window smaller (contract). We do this by incrementing the left pointer. But before we increment the left pointer, we check to see if the number at the index of the left pointer in the array is equal to either head of the queues. If it is, we remove that head (aka poll from the left side of the queue). This is how we keep track of the max and min values in our window.\\n\\nSorry for the long explanation!\\n\\n\\n```\\npublic int longestSubarray(int[] nums, int limit) {\\n        Deque<Integer> maxQ = new LinkedList<>();\\n        Deque<Integer> minQ = new LinkedList<>();\\n        \\n        int start = 0;\\n        int size = 0;\\n        \\n        for (int end = 0; end < nums.length; end++) {\\n            \\n            while (!maxQ.isEmpty() && maxQ.peekLast() < nums[end]) {\\n                maxQ.pollLast();\\n            } \\n            \\n            while (!minQ.isEmpty() && minQ.peekLast() > nums[end]) {\\n                minQ.pollLast();\\n            }\\n            \\n            maxQ.addLast(nums[end]);\\n            minQ.addLast(nums[end]);\\n            \\n            if (maxQ.peekFirst() - minQ.peekFirst() > limit) {\\n                if (nums[start] == maxQ.peekFirst()) {\\n                    maxQ.pollFirst();\\n                }\\n                if (nums[start] == minQ.peekFirst()) {\\n                    minQ.pollFirst();\\n                }\\n                start++;\\n            }\\n            \\n            size = Math.max(size, end - start + 1);\\n        }\\n        \\n        return size;\\n    }",
                "solutionTags": [],
                "code": "To solve this question you can use a sliding window. Before expanding the window, we have to check if every pair of numbers within the window has an absolute difference less than the limit. But how do we do that? \\n\\nWe could generate all pairs of numbers within the window, and check their differences, but that would lead to an N^2 solution. If only we could keep track of the max number in the window, and the min number in the window...\\n\\nUnfortunately, we cannot figure out the max and min numbers in our current window by doing something like `max = Math.max(max, arr[i]) ` and `min = Math.min(min, arr[i])` because when the time comes to contract the window (by incrementing the left pointer), we will have no idea if the number we are removing from the window was the max or the min.\\n\\nSo this is why we use Deques.\\nWe use 2 of them. One maintains the numbers we have seen so far in decreasing order (so that max element in the window will be at the front of the queue, or left side of the queue), and the other deque will maintain the numbers we have seen so far in increasing order (so the min number in the queue will be at the front, aka the left side of the queue). \\n\\nAs we iterate through the array, before we add the number to the queues, we check if this number is bigger than the number at the end of the max queue. While this is true, we remove numbers from the end of the max queue. Why do we remove them? Because we want the max queue to contain numbers in a decreasing order. If the number at the end of the max queue (the right side of the queue) is less than the current number we are on in the array, we shouldn\\'t add the number until we remove all numbers less than it. This ensures that the max queue always maintains the numbers we\\'ve seen already in decreasing order.\\n\\nThe same goes for the min queue. Before we add this number to the min queue, we check to see if its smaller than the number at the end of the minQueue. While this is true, we poll from the min queue. This ensures that the numbers being added to the minqueue are increasing order. We want the smallest number we\\'ve seen so far to be the first number in the minqueue.\\n\\nNow we just have to look at the front of both queues, and subtract those numbers. If the difference is under or equal to the limit, we record the size of the current window, and then try to expand the window again.\\n\\nIf the difference is greater than the window, we need to make the window smaller (contract). We do this by incrementing the left pointer. But before we increment the left pointer, we check to see if the number at the index of the left pointer in the array is equal to either head of the queues. If it is, we remove that head (aka poll from the left side of the queue). This is how we keep track of the max and min values in our window.\\n\\nSorry for the long explanation!\\n\\n\\n```\\npublic int longestSubarray(int[] nums, int limit) {\\n        Deque<Integer> maxQ = new LinkedList<>();\\n        Deque<Integer> minQ = new LinkedList<>();\\n        \\n        int start = 0;\\n        int size = 0;\\n        \\n        for (int end = 0; end < nums.length; end++) {\\n            \\n            while (!maxQ.isEmpty() && maxQ.peekLast() < nums[end]) {\\n                maxQ.pollLast();\\n            } \\n            \\n            while (!minQ.isEmpty() && minQ.peekLast() > nums[end]) {\\n                minQ.pollLast();\\n            }\\n            \\n            maxQ.addLast(nums[end]);\\n            minQ.addLast(nums[end]);\\n            \\n            if (maxQ.peekFirst() - minQ.peekFirst() > limit) {\\n                if (nums[start] == maxQ.peekFirst()) {\\n                    maxQ.pollFirst();\\n                }\\n                if (nums[start] == minQ.peekFirst()) {\\n                    minQ.pollFirst();\\n                }\\n                start++;\\n            }\\n            \\n            size = Math.max(size, end - start + 1);\\n        }\\n        \\n        return size;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 609736,
                "title": "c-sliding-window-with-tree-map",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n\\t\\t// Time Complexity: O(n lg n)\\n\\t\\t// Space Complexity: O(n)\\n        multiset<int> cnts;\\n        int j(0), ans(0);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            cnts.insert(nums[i]);\\n            while (*cnts.rbegin() - *cnts.begin() > limit)\\n                cnts.erase(cnts.find(nums[j++]));\\n            ans = max(ans, i - j + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Sliding Window"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n\\t\\t// Time Complexity: O(n lg n)\\n\\t\\t// Space Complexity: O(n)\\n        multiset<int> cnts;\\n        int j(0), ans(0);\\n        for (int i = 0; i < nums.size(); ++i) {\\n            cnts.insert(nums[i]);\\n            while (*cnts.rbegin() - *cnts.begin() > limit)\\n                cnts.erase(cnts.find(nums[j++]));\\n            ans = max(ans, i - j + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1333408,
                "title": "python-sliding-window-using-2-deques-dqmin-and-dqmax-clean-concise-o-n",
                "content": "**\\u274C Solution 1: Brute force (Time Limit Exceeded)**\\n```python\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        n = len(nums)\\n        ans = 0\\n        \\n        for i in range(n):\\n            mi = ma = nums[i]\\n            for j in range(i, n):\\n                mi = min(mi, nums[j])\\n                ma = max(ma, nums[j])\\n                if ma - mi > limit:\\n                    break\\n                ans = max(ans, j - i + 1)\\n                \\n        return ans\\n```\\nComplexity:\\n- Time: `O(N^2)`, where `N` is length of `nums` array.\\n- Space: `O(1)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Sliding Window + Using 2 deques (dqMin and dqMax)**\\n- We do sliding window:\\n\\t- `l`, `r` keep window range\\n\\t- We also need a data structure to keep the maximum and minimum in the window range, which support to query maximum/minimum and add/pop element in window range in O(1), in this case `deque` is a good fit.\\n- Use 2 deques:\\n\\t- Let `dqMin` keep track of minimum elements in window range efficiently, if we meet a new element which is smaller then we pop all larger elements out of the `dqMin`; the front of the `dqMin` is the minimum of the current window range.\\n\\t- Let `dqMax` keep track of maximum elements in window range efficiently, if we meet a new element which is larger then we pop all smaller elements out of the `dqMax`; the front of the `qdMax` is the maximum of the current window range.\\n```python\\nclass Solution:  # 672 ms, faster than 79.33%\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # Example: [10,1,2,4,7,4,3,1], limit = 5\\n        dqMax, dqMin = deque(), deque()\\n        ans = 0\\n        l = 0\\n        n = len(nums)\\n        for r in range(n):\\n            while dqMax and nums[dqMax[-1]] <= nums[r]:  # If we found a larger element then no need to keep smaller elements\\n                dqMax.pop()\\n            while dqMin and nums[dqMin[-1]] >= nums[r]:  # If we found a smaller element then no need to keep larger elements\\n                dqMin.pop()\\n            dqMax.append(r)\\n            dqMin.append(r)\\n            \\n            while nums[dqMax[0]] - nums[dqMin[0]] > limit:\\n                l += 1  # Shrink size by moving the left pointer\\n                if dqMax[0] < l: dqMax.popleft()\\n                if dqMin[0] < l: dqMin.popleft()\\n                    \\n            ans = max(ans, r - l + 1)\\n            \\n        return ans\\n```\\nComplexity:\\n- Time: `O(N)`, where `N` is length of `nums` array.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        n = len(nums)\\n        ans = 0\\n        \\n        for i in range(n):\\n            mi = ma = nums[i]\\n            for j in range(i, n):\\n                mi = min(mi, nums[j])\\n                ma = max(ma, nums[j])\\n                if ma - mi > limit:\\n                    break\\n                ans = max(ans, j - i + 1)\\n                \\n        return ans\\n```\n```python\\nclass Solution:  # 672 ms, faster than 79.33%\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # Example: [10,1,2,4,7,4,3,1], limit = 5\\n        dqMax, dqMin = deque(), deque()\\n        ans = 0\\n        l = 0\\n        n = len(nums)\\n        for r in range(n):\\n            while dqMax and nums[dqMax[-1]] <= nums[r]:  # If we found a larger element then no need to keep smaller elements\\n                dqMax.pop()\\n            while dqMin and nums[dqMin[-1]] >= nums[r]:  # If we found a smaller element then no need to keep larger elements\\n                dqMin.pop()\\n            dqMax.append(r)\\n            dqMin.append(r)\\n            \\n            while nums[dqMax[0]] - nums[dqMin[0]] > limit:\\n                l += 1  # Shrink size by moving the left pointer\\n                if dqMax[0] < l: dqMax.popleft()\\n                if dqMin[0] < l: dqMin.popleft()\\n                    \\n            ans = max(ans, r - l + 1)\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 610027,
                "title": "c-all-solutions-from-worst-to-best-o-n-3-to-o-n",
                "content": "Solution 1: Simulating the problem - O(n^3) TC O(1) SC\\n\\n```\\nint longestSubarray(vector<int>& nums, int limit) {\\n        int maxlen=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                int maxe=nums[i];\\n                int mine = nums[i];\\n                \\n                for(int k=i+1;k<=j;k++)\\n                {\\n                    if(nums[k]>maxe)\\n                        maxe = nums[k];\\n                    if(nums[k]<mine)\\n                        mine = nums[k];\\n                }\\n                if(maxe-mine<=limit)\\n                    maxlen = max(maxlen,j-i+1);\\n            }\\n        }\\n        return maxlen;\\n    }\\n```\\n\\nSolution 2: Simulating the problem- Slightly better- O(n^2) TC O(1) SC\\n```\\nint longestSubarray(vector<int>& nums, int limit) {\\n        int maxlen=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int maxe=nums[i];\\n            int mine = nums[i];\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                if(nums[j]>maxe)\\n                    maxe = nums[j];\\n                if(nums[j]<mine)\\n                    mine = nums[j];\\n                \\n                if(maxe-mine<=limit)\\n                    maxlen = max(maxlen,j-i+1);\\n            }\\n        }\\n        return maxlen;\\n    }\\n```\\n\\nSolution 3: Using multiset. O(nlogn) TC O(n) SC. \\n[multiset stores all the element including repeated element in a sorted order. all operation in Multiset in Logn time]\\n```\\nint longestSubarray(vector<int>& A, int limit) {\\n        int i = 0, j;\\n        multiset<int> m;\\n        for (j = 0; j < A.size(); ++j) {\\n            m.insert(A[j]);\\n            if (*m.rbegin() - *m.begin() > limit) // last and first element diffrence > limit\\n                m.erase(m.find(A[i++]));\\n        }\\n        return j - i;\\n    }\\n```\\n\\nSolution 4:  O(n) TC O(n) SC using Deque\\n\\nvideo and code link: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609828/DETAILED-VIDEO-EXPLANATION-with-code-O(n)\\n\\n```\\nclass Solution {\\npublic:\\n\\tint longestSubarray(vector<int>& nums, int limit)\\n\\t{\\n\\t\\tint ans = 0;\\n\\t\\tdeque<int> minQueue;\\n\\t\\tdeque<int> maxQueue;\\n\\t\\tint s=0,e=0;\\n\\t\\twhile (e<nums.size()) \\n\\t\\t{\\n\\t\\t\\tint x = nums[e];\\n\\n\\t\\t\\t// add end to the minQueue keeping increasing order\\n\\t\\t\\twhile (!minQueue.empty()&&nums[minQueue.back()]>=x) minQueue.pop_back();\\n\\t\\t\\tminQueue.push_back(e);\\n\\n\\t\\t\\t// add end to the maxQueue keeping decreasing order\\n\\t\\t\\twhile (!maxQueue.empty()&&nums[maxQueue.back()]<=x) maxQueue.pop_back();\\n\\t\\t\\tmaxQueue.push_back(e);\\n\\n\\t\\t\\tint mini = nums[minQueue.front()];\\n\\t\\t\\tint maxi = nums[maxQueue.front()];\\n\\t\\t\\tif (maxi-mini>limit) \\n\\t\\t\\t{\\n\\t\\t\\t\\ts++;\\n\\t\\t\\t\\tif (s>minQueue.front()) minQueue.pop_front();\\n\\t\\t\\t\\tif (s>maxQueue.front()) maxQueue.pop_front();\\n\\t\\t\\t} \\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tans=max(ans,e-s+1);\\n\\t\\t\\t\\te++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\nExtra Solution without extra space: I like it. Looks like O(n^2). Any comment on complexity is appreciated.\\nLink of code:  https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609702/C%2B%2B-Two-pointers-solution-with-detailed-comments\\n\\n\\n```\\nclass Solution {\\npublic:\\n\\tint longestSubarray(vector<int>& nums, int limit) {\\n\\t\\tif(nums.empty()) return 0;\\n\\t\\tif(nums.size()==1) return 1; //corner cases\\n\\t\\tint n=nums.size();\\n\\t\\tint curMAX=nums[0];\\n\\t\\tint curMIN=nums[0];\\n\\t\\tint ans=0;\\n\\t\\tint left=0; // left pointer\\n\\t\\tfor(int i=1;i<nums.size();i++)\\n\\t\\t{\\n\\t\\t\\tcurMAX=max(curMAX,nums[i]); // current max value in the window\\n\\t\\t\\tcurMIN=min(curMIN,nums[i]); // current min value in the window\\n\\t\\t\\tif(abs(nums[i]-curMIN)>limit || abs(curMAX-nums[i])>limit) // when nums[i] breaks the window\\n\\t\\t\\t{\\n\\t\\t\\t\\tint temp=i;\\n\\t\\t\\t\\tleft=temp;\\n\\t\\t\\t\\tcurMAX=nums[i];       // reset max value\\n\\t\\t\\t\\tcurMIN=nums[i];       // reset min value\\n\\t\\t\\t\\twhile(abs(nums[i]-nums[temp])<=limit) // brute force to find left pointer\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tleft=temp;\\n\\t\\t\\t\\t\\ttemp--;\\n\\t\\t\\t\\t\\tcurMAX=max(curMAX,nums[left]); // update max value in the new window \\n\\t\\t\\t\\t\\tcurMIN=min(curMIN,nums[left]); // update min value in the new window\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans=max(ans,i-left+1);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nint longestSubarray(vector<int>& nums, int limit) {\\n        int maxlen=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                int maxe=nums[i];\\n                int mine = nums[i];\\n                \\n                for(int k=i+1;k<=j;k++)\\n                {\\n                    if(nums[k]>maxe)\\n                        maxe = nums[k];\\n                    if(nums[k]<mine)\\n                        mine = nums[k];\\n                }\\n                if(maxe-mine<=limit)\\n                    maxlen = max(maxlen,j-i+1);\\n            }\\n        }\\n        return maxlen;\\n    }\\n```\n```\\nint longestSubarray(vector<int>& nums, int limit) {\\n        int maxlen=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int maxe=nums[i];\\n            int mine = nums[i];\\n            for(int j=i;j<nums.size();j++)\\n            {\\n                if(nums[j]>maxe)\\n                    maxe = nums[j];\\n                if(nums[j]<mine)\\n                    mine = nums[j];\\n                \\n                if(maxe-mine<=limit)\\n                    maxlen = max(maxlen,j-i+1);\\n            }\\n        }\\n        return maxlen;\\n    }\\n```\n```\\nint longestSubarray(vector<int>& A, int limit) {\\n        int i = 0, j;\\n        multiset<int> m;\\n        for (j = 0; j < A.size(); ++j) {\\n            m.insert(A[j]);\\n            if (*m.rbegin() - *m.begin() > limit) // last and first element diffrence > limit\\n                m.erase(m.find(A[i++]));\\n        }\\n        return j - i;\\n    }\\n```\n```\\nclass Solution {\\npublic:\\n\\tint longestSubarray(vector<int>& nums, int limit)\\n\\t{\\n\\t\\tint ans = 0;\\n\\t\\tdeque<int> minQueue;\\n\\t\\tdeque<int> maxQueue;\\n\\t\\tint s=0,e=0;\\n\\t\\twhile (e<nums.size()) \\n\\t\\t{\\n\\t\\t\\tint x = nums[e];\\n\\n\\t\\t\\t// add end to the minQueue keeping increasing order\\n\\t\\t\\twhile (!minQueue.empty()&&nums[minQueue.back()]>=x) minQueue.pop_back();\\n\\t\\t\\tminQueue.push_back(e);\\n\\n\\t\\t\\t// add end to the maxQueue keeping decreasing order\\n\\t\\t\\twhile (!maxQueue.empty()&&nums[maxQueue.back()]<=x) maxQueue.pop_back();\\n\\t\\t\\tmaxQueue.push_back(e);\\n\\n\\t\\t\\tint mini = nums[minQueue.front()];\\n\\t\\t\\tint maxi = nums[maxQueue.front()];\\n\\t\\t\\tif (maxi-mini>limit) \\n\\t\\t\\t{\\n\\t\\t\\t\\ts++;\\n\\t\\t\\t\\tif (s>minQueue.front()) minQueue.pop_front();\\n\\t\\t\\t\\tif (s>maxQueue.front()) maxQueue.pop_front();\\n\\t\\t\\t} \\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tans=max(ans,e-s+1);\\n\\t\\t\\t\\te++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\tint longestSubarray(vector<int>& nums, int limit) {\\n\\t\\tif(nums.empty()) return 0;\\n\\t\\tif(nums.size()==1) return 1; //corner cases\\n\\t\\tint n=nums.size();\\n\\t\\tint curMAX=nums[0];\\n\\t\\tint curMIN=nums[0];\\n\\t\\tint ans=0;\\n\\t\\tint left=0; // left pointer\\n\\t\\tfor(int i=1;i<nums.size();i++)\\n\\t\\t{\\n\\t\\t\\tcurMAX=max(curMAX,nums[i]); // current max value in the window\\n\\t\\t\\tcurMIN=min(curMIN,nums[i]); // current min value in the window\\n\\t\\t\\tif(abs(nums[i]-curMIN)>limit || abs(curMAX-nums[i])>limit) // when nums[i] breaks the window\\n\\t\\t\\t{\\n\\t\\t\\t\\tint temp=i;\\n\\t\\t\\t\\tleft=temp;\\n\\t\\t\\t\\tcurMAX=nums[i];       // reset max value\\n\\t\\t\\t\\tcurMIN=nums[i];       // reset min value\\n\\t\\t\\t\\twhile(abs(nums[i]-nums[temp])<=limit) // brute force to find left pointer\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tleft=temp;\\n\\t\\t\\t\\t\\ttemp--;\\n\\t\\t\\t\\t\\tcurMAX=max(curMAX,nums[left]); // update max value in the new window \\n\\t\\t\\t\\t\\tcurMIN=min(curMIN,nums[left]); // update min value in the new window\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tans=max(ans,i-left+1);\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 610281,
                "title": "java-sliding-window-heaps",
                "content": "We can use the ***Sliding Window*** technique to handle this problem: when the **max absolute difference between 2 numbers** is less than or equal to the limit, we expand the window by increment end pointer index only; else, we increment both the start pointer *and end pointer* index. \\n\\nSince we only care about the **max absolute difference between 2 numbers** here, so we only need to know the maximum and minimum number for each window (that is a continuous subarray). To get those 2 numbers, we can maintain 2 heaps, one is max heap, the other one is min heap. \\n\\nMy code is as the following post:\\n```\\n    public int longestSubarray(int[] nums, int limit) {\\n        int start = 0;\\n        int end = 0;\\n        int res = 1;\\n        \\n        PriorityQueue<Integer> minQ = new PriorityQueue<Integer>();\\n        PriorityQueue<Integer> maxQ = new PriorityQueue<Integer>(Collections.reverseOrder());\\n            \\n        while (start <= end && end < nums.length) {\\n            minQ.offer(nums[end]);\\n            maxQ.offer(nums[end]);\\n            int minNum = minQ.peek();\\n            int maxNum = maxQ.peek();\\n            if (maxNum - minNum <= limit) {\\n                end++;\\n                res = Math.max(res, end - start);\\n            } else {\\n                boolean t = minQ.remove(nums[start]);\\n                boolean tt = maxQ.remove(nums[start]);\\n                start++;\\n                end++; // When \">limit\" you also need to change your end, if you do not do so, you will push the same number twice.\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\nUpdated: we can use the *Lambda Expression* to create a max-heap instead of overriding the ```compare(Object o1, Object o2)``` method of the *Comparator* Interface. For example, we can code like this:\\n```\\nPriorityQueue<Integer> maxQ = new PriorityQueue<>((a, b) -> b - a);\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestSubarray(int[] nums, int limit) {\\n        int start = 0;\\n        int end = 0;\\n        int res = 1;\\n        \\n        PriorityQueue<Integer> minQ = new PriorityQueue<Integer>();\\n        PriorityQueue<Integer> maxQ = new PriorityQueue<Integer>(Collections.reverseOrder());\\n            \\n        while (start <= end && end < nums.length) {\\n            minQ.offer(nums[end]);\\n            maxQ.offer(nums[end]);\\n            int minNum = minQ.peek();\\n            int maxNum = maxQ.peek();\\n            if (maxNum - minNum <= limit) {\\n                end++;\\n                res = Math.max(res, end - start);\\n            } else {\\n                boolean t = minQ.remove(nums[start]);\\n                boolean tt = maxQ.remove(nums[start]);\\n                start++;\\n                end++; // When \">limit\" you also need to change your end, if you do not do so, you will push the same number twice.\\n            }\\n        }\\n        return res;\\n    }\\n```\n```compare(Object o1, Object o2)```\n```\\nPriorityQueue<Integer> maxQ = new PriorityQueue<>((a, b) -> b - a);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 621160,
                "title": "python-how-to-actually-get-on-video-explained",
                "content": "First of all there are lots of solutions in O(N) already using ordered queue/stack, but I found them hard to understand, here is my code with the video explaination of how I get here:\\n```\\nclass Solution(object):\\n    def longestSubarray(self, nums, limit):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type limit: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        # On3 --> On2 --> On\\n        maxLen, i = 0, 0\\n        minQueue, maxQueue = collections.deque([]), collections.deque([])\\n        for j in range(len(nums)):\\n            while minQueue and minQueue[-1] > nums[j]:\\n                minQueue.pop()\\n            minQueue.append(nums[j])\\n            while maxQueue and maxQueue[-1] < nums[j]:\\n                maxQueue.pop()\\n            maxQueue.append(nums[j])\\n            \\n            if maxQueue[0] - minQueue[0] <= limit:\\n                maxLen = max(maxLen, j-i+1)\\n            else:\\n                if maxQueue[0] == nums[i]:\\n                    maxQueue.popleft()\\n                if minQueue[0] == nums[i]:\\n                    minQueue.popleft()\\n                i += 1\\n        return maxLen\\n```\\n\\nvideo: youtube.com/watch?v=h5cz7rA77ik",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestSubarray(self, nums, limit):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type limit: int\\n        :rtype: int\\n        \"\"\"\\n        \\n        # On3 --> On2 --> On\\n        maxLen, i = 0, 0\\n        minQueue, maxQueue = collections.deque([]), collections.deque([])\\n        for j in range(len(nums)):\\n            while minQueue and minQueue[-1] > nums[j]:\\n                minQueue.pop()\\n            minQueue.append(nums[j])\\n            while maxQueue and maxQueue[-1] < nums[j]:\\n                maxQueue.pop()\\n            maxQueue.append(nums[j])\\n            \\n            if maxQueue[0] - minQueue[0] <= limit:\\n                maxLen = max(maxLen, j-i+1)\\n            else:\\n                if maxQueue[0] == nums[i]:\\n                    maxQueue.popleft()\\n                if minQueue[0] == nums[i]:\\n                    minQueue.popleft()\\n                i += 1\\n        return maxLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 678355,
                "title": "easy-to-understand-c-solution-deque-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    // time: O(n), space: O(n)\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        deque<int> maxdq, mindq;\\n        int j = 0;\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            while (!maxdq.empty() && nums[i] > maxdq.back()) maxdq.pop_back();\\n            while (!mindq.empty() && nums[i] < mindq.back()) mindq.pop_back();\\n            maxdq.push_back(nums[i]);\\n            mindq.push_back(nums[i]);\\n            while (maxdq.front() - mindq.front() > limit) {\\n                if (maxdq.front() == nums[j]) maxdq.pop_front();\\n                if (mindq.front() == nums[j]) mindq.pop_front();\\n                j++;\\n            }\\n            ans = max(ans, i - j + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nclass Solution2 {\\npublic:\\n    // binary search tree\\n    // Time: O(nlogn), Space: O(n)\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        multiset<int> ms;\\n        int j = 0;\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            ms.insert(nums[i]);\\n            while (*ms.rbegin() - *ms.begin() > limit) {\\n                ms.erase(ms.find(nums[j]));\\n                j++;\\n            }\\n            ans = max(ans, i - j + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // time: O(n), space: O(n)\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        deque<int> maxdq, mindq;\\n        int j = 0;\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            while (!maxdq.empty() && nums[i] > maxdq.back()) maxdq.pop_back();\\n            while (!mindq.empty() && nums[i] < mindq.back()) mindq.pop_back();\\n            maxdq.push_back(nums[i]);\\n            mindq.push_back(nums[i]);\\n            while (maxdq.front() - mindq.front() > limit) {\\n                if (maxdq.front() == nums[j]) maxdq.pop_front();\\n                if (mindq.front() == nums[j]) mindq.pop_front();\\n                j++;\\n            }\\n            ans = max(ans, i - j + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution2 {\\npublic:\\n    // binary search tree\\n    // Time: O(nlogn), Space: O(n)\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        multiset<int> ms;\\n        int j = 0;\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            ms.insert(nums[i]);\\n            while (*ms.rbegin() - *ms.begin() > limit) {\\n                ms.erase(ms.find(nums[j]));\\n                j++;\\n            }\\n            ans = max(ans, i - j + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 762800,
                "title": "concise-java-solution-from-o-n-2-to-o-n",
                "content": "**Priority queue with O(n^2)**  \\nIntuitively, the question can be solved by sliding window, and we need two priority queues to maintain max and min values for each window. When the condition is satisfied we record the result and move right end, otherwise move the left end. But to remove an element in a queue takes O(n) time in Java, so the over all time complexity is O(n^2).\\n```java\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        PriorityQueue<Integer> max = new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Integer> min = new PriorityQueue<>();\\n        int l = 0, r = 0;\\n        int res = 0;\\n        while(r < nums.length) {\\n            max.offer(nums[r]);\\n            min.offer(nums[r]);\\n            while(max.peek() - min.peek() > limit) {\\n                max.remove(nums[l]);\\n                min.remove(nums[l]);\\n                l++;\\n            }\\n            res = Math.max(res, r - l + 1);\\n            r++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**Priority queue with O(nlong(n))**  \\nActually, the previous solution just needs to be modified a little bit to become O(nlong(n)). We store the index into the priority queues with the value together. When the condition is not satisfied, we simply move the left end one step after the position of min(min_index, max_index), and pop out values before left end. \\n```java\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        PriorityQueue<int[]> max = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        PriorityQueue<int[]> min = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        int l = 0, r = 0;\\n        int res = 0;\\n        while(r < nums.length) {\\n            max.offer(new int[]{nums[r], r});\\n            min.offer(new int[]{nums[r], r});\\n            while(max.peek()[0] - min.peek()[0] > limit) {\\n                l = Math.min(max.peek()[1], min.peek()[1]) + 1;\\n                while(max.peek()[1] < l) max.poll();\\n                while(min.peek()[1] < l) min.poll();\\n            }\\n            res = Math.max(res, r - l + 1);\\n            r++;\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n**Deque**  \\nThe good thing is that we can do better. If you are familiar with questions like [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum) or [480. Sliding Window Median](https://leetcode.com/problems/sliding-window-median), you will quickly come up with the idea of deque. This solution provide a way to maintain the max/min/median value within a window with O(1) time dynamically, which leads to an over all time complexity of O(n). \\n```java\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        Deque<Integer> max = new ArrayDeque();\\n        Deque<Integer> min = new ArrayDeque();\\n        int l = 0, r = 0;\\n        int res = 0;\\n        while(r < nums.length) {\\n            while(!max.isEmpty() && nums[max.peekLast()] <= nums[r]) max.pollLast();\\n            while(!min.isEmpty() && nums[min.peekLast()] >= nums[r]) min.pollLast();\\n            max.offerLast(r);\\n            min.offerLast(r);\\n            while(nums[max.peekFirst()] - nums[min.peekFirst()] > limit) {\\n                if(min.peekFirst() == l) min.pollFirst();\\n                if(max.peekFirst() == l) max.pollFirst();\\n                l++;\\n            }\\n            res = Math.max(res, r - l + 1);\\n            r++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        PriorityQueue<Integer> max = new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Integer> min = new PriorityQueue<>();\\n        int l = 0, r = 0;\\n        int res = 0;\\n        while(r < nums.length) {\\n            max.offer(nums[r]);\\n            min.offer(nums[r]);\\n            while(max.peek() - min.peek() > limit) {\\n                max.remove(nums[l]);\\n                min.remove(nums[l]);\\n                l++;\\n            }\\n            res = Math.max(res, r - l + 1);\\n            r++;\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        PriorityQueue<int[]> max = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n        PriorityQueue<int[]> min = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n        int l = 0, r = 0;\\n        int res = 0;\\n        while(r < nums.length) {\\n            max.offer(new int[]{nums[r], r});\\n            min.offer(new int[]{nums[r], r});\\n            while(max.peek()[0] - min.peek()[0] > limit) {\\n                l = Math.min(max.peek()[1], min.peek()[1]) + 1;\\n                while(max.peek()[1] < l) max.poll();\\n                while(min.peek()[1] < l) min.poll();\\n            }\\n            res = Math.max(res, r - l + 1);\\n            r++;\\n        }\\n        return res;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        Deque<Integer> max = new ArrayDeque();\\n        Deque<Integer> min = new ArrayDeque();\\n        int l = 0, r = 0;\\n        int res = 0;\\n        while(r < nums.length) {\\n            while(!max.isEmpty() && nums[max.peekLast()] <= nums[r]) max.pollLast();\\n            while(!min.isEmpty() && nums[min.peekLast()] >= nums[r]) min.pollLast();\\n            max.offerLast(r);\\n            min.offerLast(r);\\n            while(nums[max.peekFirst()] - nums[min.peekFirst()] > limit) {\\n                if(min.peekFirst() == l) min.pollFirst();\\n                if(max.peekFirst() == l) max.pollFirst();\\n                l++;\\n            }\\n            res = Math.max(res, r - l + 1);\\n            r++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777047,
                "title": "python-two-monotonic-queues-with-sliding-window-o-n",
                "content": "Inspired by the solution of [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/submissions/) which uses a single monotonic queue.\\nI am using two monotonic queues to maintain the maximum and minimum of current window.\\n\\nNote on monotonic queue: monotonic queue is a data structure maintaining a certain monotone order (ascending or descending). For example, if I have a max monotonic queue [5,3,2], when I insert 4, this queue will pop from the end with numbers that are smaller than 4 and then append 4 after 5, becoming [5,4]. The amortized runtime for insert operation is O(1), therefore making the whole algorithm O(N) with a for loop.\\n\\nI store the index of numbers to make sure they are in the window and popleft when the max or min is out of range, which might not be very readable.\\n\\n```\\nimport collections\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # sliding window\\n        mx, mn = collections.deque([0]), collections.deque([0])\\n        ans = 1\\n        left = 0\\n        for i in range(1, len(nums)):\\n            # update max and min monotonic q\\n            while mx and nums[mx[-1]] < nums[i]:\\n                mx.pop()\\n            mx.append(i)\\n            while mn and nums[mn[-1]] > nums[i]:\\n                mn.pop()\\n            mn.append(i)\\n            while mx and mn and nums[mx[0]] - nums[mn[0]] > limit:\\n                left += 1\\n                if mx[0] < left:\\n                    mx.popleft()\\n                if mn[0] < left:\\n                    mn.popleft()\\n            ans = max(ans, i-left+1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # sliding window\\n        mx, mn = collections.deque([0]), collections.deque([0])\\n        ans = 1\\n        left = 0\\n        for i in range(1, len(nums)):\\n            # update max and min monotonic q\\n            while mx and nums[mx[-1]] < nums[i]:\\n                mx.pop()\\n            mx.append(i)\\n            while mn and nums[mn[-1]] > nums[i]:\\n                mn.pop()\\n            mn.append(i)\\n            while mx and mn and nums[mx[0]] - nums[mn[0]] > limit:\\n                left += 1\\n                if mx[0] < left:\\n                    mx.popleft()\\n                if mn[0] < left:\\n                    mn.popleft()\\n            ans = max(ans, i-left+1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1670940,
                "title": "c-o-n-time-solution-max-heap-min-heap-sliding-window-with-condition",
                "content": "```\\nint longestSubarray(vector<int>& nums, int limit) {\\n        int i=0,j=0,n=nums.size();\\n        int max_size=0;\\n        priority_queue<pair<int,int>> maxh;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>, greater<pair<int,int>>> minh;\\n        while(j<n)\\n        {\\n            maxh.push({nums[j],j});\\n            minh.push({nums[j],j});\\n            while(maxh.top().second <i)\\n                    maxh.pop();\\n            \\n            while(minh.top().second < i)\\n                    minh.pop();\\n            if(maxh.top().first-minh.top().first<=limit)\\n            {\\n                max_size=max(max_size,j-i+1);\\n                j++;\\n            }\\n            else\\n            {\\n                i++;\\n\\n                \\n                j++;\\n            }\\n                \\n                \\n        }\\n        return max_size;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nint longestSubarray(vector<int>& nums, int limit) {\\n        int i=0,j=0,n=nums.size();\\n        int max_size=0;\\n        priority_queue<pair<int,int>> maxh;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>, greater<pair<int,int>>> minh;\\n        while(j<n)\\n        {\\n            maxh.push({nums[j],j});\\n            minh.push({nums[j],j});\\n            while(maxh.top().second <i)\\n                    maxh.pop();\\n            \\n            while(minh.top().second < i)\\n                    minh.pop();\\n            if(maxh.top().first-minh.top().first<=limit)\\n            {\\n                max_size=max(max_size,j-i+1);\\n                j++;\\n            }\\n            else\\n            {\\n                i++;\\n\\n                \\n                j++;\\n            }\\n                \\n                \\n        }\\n        return max_size;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 930316,
                "title": "simple-solution-using-2-priority-queue",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        PriorityQueue<Integer> min = new PriorityQueue<>();\\n        PriorityQueue<Integer> max = new PriorityQueue<>((a,b)->Integer.compare(b,a));\\n        int a=0,b=0;\\n        int res = 0;\\n        while(b<nums.length){\\n            min.add(nums[b]);\\n            max.add(nums[b]);\\n            while(Math.abs(max.peek()-min.peek()) >limit){\\n                min.remove(nums[a]);\\n                max.remove(nums[a]);\\n                a++;\\n            }\\n            res = Math.max(b-a+1,res);\\n            b++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        PriorityQueue<Integer> min = new PriorityQueue<>();\\n        PriorityQueue<Integer> max = new PriorityQueue<>((a,b)->Integer.compare(b,a));\\n        int a=0,b=0;\\n        int res = 0;\\n        while(b<nums.length){\\n            min.add(nums[b]);\\n            max.add(nums[b]);\\n            while(Math.abs(max.peek()-min.peek()) >limit){\\n                min.remove(nums[a]);\\n                max.remove(nums[a]);\\n                a++;\\n            }\\n            res = Math.max(b-a+1,res);\\n            b++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 628252,
                "title": "javascript-easy-to-understand-optimize-from-6564ms-to-64ms",
                "content": "## ORIGINAL SOLUTION\\n\\nAfter reading the description, the sliding window solution came out of my brain. So I quickly write this code to validate the feasibility.\\n\\nIn this code, there\\'s an inner loop to get the new min and max value when we move the left edge. So, it should be slow.\\n\\nAnd in fact, it costs 6564ms. T_T\\n\\n```js\\nconst longestSubarray = (nums, limit) => {\\n  let ret = 0;\\n  for (let left = 0, right = 0, cur = 0, min = nums[0], max = nums[0]; right < nums.length; ++right) {\\n    while (nums[right] - min > limit || max - nums[right] > limit) {\\n      if (nums[left] === min || nums[left] === max) {\\n        min = 10 ** 9;\\n        max = 0;\\n        for (let i = left + 1; i <= right; ++i) {\\n          nums[i] < min && (min = nums[i]);\\n          nums[i] > max && (max = nums[i]);\\n        }\\n      }\\n      --cur;\\n      ++left;\\n    }\\n    nums[right] < min && (min = nums[right]);\\n    nums[right] > max && (max = nums[right]);\\n    ++cur > ret && (ret = cur);\\n  }\\n  return ret;\\n};\\n```\\n\\n## OPTIMIZE\\n\\nTo optimize the original solution, the obvious way is to remove the inner loop.\\n\\nSo here, I use 2 queues to maintain the max and min value which makes the time complexity of getting max and min comes to O(1).\\n\\nAnd finally, this code costs 956ms. Nice try! Much better!\\n\\n```js\\nconst longestSubarray = (nums, limit) => {\\n  const maxQue = [];\\n  const minQue = [];\\n  let maxTop = -1, minTop = -1, max = 0;\\n  for (let left = -1, right = 0; right < nums.length; ++right) {\\n    const val = nums[right];\\n    while (maxTop >= 0 && val > maxQue[maxTop]) --maxTop;\\n    while (minTop >= 0 && val < minQue[minTop]) --minTop;\\n    maxQue[++maxTop] = val;\\n    minQue[++minTop] = val;\\n    if (maxQue[0] - minQue[0] <= limit) {\\n      right - left > max && (max = right - left);\\n    } else {\\n      while (maxQue[0] - minQue[0] > limit) {\\n        ++left;\\n        if (maxQue[0] === nums[left]) {\\n          maxQue.shift();\\n          --maxTop;\\n        }\\n        if (minQue[0] === nums[left]) {\\n          minQue.shift();\\n          --minTop;\\n        }\\n      }\\n    }\\n  }\\n  return max;\\n};\\n```\\n\\n## OPTIMIZE II\\n\\nBut the 956ms is still too slow.  Actually, we can easily find out that the array in JS is a linear list. We call the `shift` method to remove the first element, but it\\'s an O(n) operation since all elements after it needs to be moved forward.\\n\\nSo, we could maintain a pointer which is the index of the bottom of the queue to avoid the `shift` operation.\\n\\nAnd here\\'s the code which costs 64ms:\\n\\n```js\\nconst longestSubarray = (nums, limit) => {\\n  const maxQue = [];\\n  const minQue = [];\\n  let maxTop = -1, minTop = -1;\\n  let maxBottom = 0, minBottom = 0;\\n  let max = 0;\\n  for (let left = -1, right = 0; right < nums.length; ++right) {\\n    const val = nums[right];\\n    while (maxTop >= maxBottom && val > maxQue[maxTop]) --maxTop;\\n    while (minTop >= minBottom && val < minQue[minTop]) --minTop;\\n    maxQue[++maxTop] = val;\\n    minQue[++minTop] = val;\\n    if (maxQue[maxBottom] - minQue[minBottom] <= limit) {\\n      right - left > max && (max = right - left);\\n    } else {\\n      while (maxQue[maxBottom] - minQue[minBottom] > limit) {\\n        ++left;\\n        maxQue[maxBottom] === nums[left] && ++maxBottom;\\n        minQue[minBottom] === nums[left] && ++minBottom;\\n      }\\n    }\\n  }\\n  return max;\\n};\\n```\\n\\n## OPTIMIZE III\\n\\nLet\\'s go on. And it\\'s the last one.\\n\\nI\\'ve changed some logic in the traversal about how to move the left edge to improve it a little. But it may look a little tricky.\\n\\nI\\'ve written a detailed explanation of it as the last solution in the follow 2 posts already. So I\\'m not going to copy it here again. You may take a look at it. :)\\n\\n- [solution 2 in this post](https://leetcode.com/problems/get-equal-substrings-within-budget/discuss/393080/JavaScript-Easy-to-understand-2-solutions)\\n- [solution 3 in this post](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/628012/JavaScript-Easy-to-understand-3-solutions)\\n\\n```js\\nconst longestSubarray = (nums, limit) => {\\n  const maxQue = [];\\n  const minQue = [];\\n  let maxTop = -1, minTop = -1, left = -1;\\n  let maxBottom = 0, minBottom = 0;\\n  for (let right = 0; right < nums.length; ++right) {\\n    const val = nums[right];\\n    while (maxTop >= maxBottom && val > maxQue[maxTop]) --maxTop;\\n    while (minTop >= minBottom && val < minQue[minTop]) --minTop;\\n    maxQue[++maxTop] = val;\\n    minQue[++minTop] = val;\\n    if (maxQue[maxBottom] - minQue[minBottom] > limit) {\\n      ++left;\\n      maxQue[maxBottom] === nums[left] && ++maxBottom;\\n      minQue[minBottom] === nums[left] && ++minBottom;\\n    }\\n  }\\n  return nums.length - left - 1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst longestSubarray = (nums, limit) => {\\n  let ret = 0;\\n  for (let left = 0, right = 0, cur = 0, min = nums[0], max = nums[0]; right < nums.length; ++right) {\\n    while (nums[right] - min > limit || max - nums[right] > limit) {\\n      if (nums[left] === min || nums[left] === max) {\\n        min = 10 ** 9;\\n        max = 0;\\n        for (let i = left + 1; i <= right; ++i) {\\n          nums[i] < min && (min = nums[i]);\\n          nums[i] > max && (max = nums[i]);\\n        }\\n      }\\n      --cur;\\n      ++left;\\n    }\\n    nums[right] < min && (min = nums[right]);\\n    nums[right] > max && (max = nums[right]);\\n    ++cur > ret && (ret = cur);\\n  }\\n  return ret;\\n};\\n```\n```js\\nconst longestSubarray = (nums, limit) => {\\n  const maxQue = [];\\n  const minQue = [];\\n  let maxTop = -1, minTop = -1, max = 0;\\n  for (let left = -1, right = 0; right < nums.length; ++right) {\\n    const val = nums[right];\\n    while (maxTop >= 0 && val > maxQue[maxTop]) --maxTop;\\n    while (minTop >= 0 && val < minQue[minTop]) --minTop;\\n    maxQue[++maxTop] = val;\\n    minQue[++minTop] = val;\\n    if (maxQue[0] - minQue[0] <= limit) {\\n      right - left > max && (max = right - left);\\n    } else {\\n      while (maxQue[0] - minQue[0] > limit) {\\n        ++left;\\n        if (maxQue[0] === nums[left]) {\\n          maxQue.shift();\\n          --maxTop;\\n        }\\n        if (minQue[0] === nums[left]) {\\n          minQue.shift();\\n          --minTop;\\n        }\\n      }\\n    }\\n  }\\n  return max;\\n};\\n```\n```js\\nconst longestSubarray = (nums, limit) => {\\n  const maxQue = [];\\n  const minQue = [];\\n  let maxTop = -1, minTop = -1;\\n  let maxBottom = 0, minBottom = 0;\\n  let max = 0;\\n  for (let left = -1, right = 0; right < nums.length; ++right) {\\n    const val = nums[right];\\n    while (maxTop >= maxBottom && val > maxQue[maxTop]) --maxTop;\\n    while (minTop >= minBottom && val < minQue[minTop]) --minTop;\\n    maxQue[++maxTop] = val;\\n    minQue[++minTop] = val;\\n    if (maxQue[maxBottom] - minQue[minBottom] <= limit) {\\n      right - left > max && (max = right - left);\\n    } else {\\n      while (maxQue[maxBottom] - minQue[minBottom] > limit) {\\n        ++left;\\n        maxQue[maxBottom] === nums[left] && ++maxBottom;\\n        minQue[minBottom] === nums[left] && ++minBottom;\\n      }\\n    }\\n  }\\n  return max;\\n};\\n```\n```js\\nconst longestSubarray = (nums, limit) => {\\n  const maxQue = [];\\n  const minQue = [];\\n  let maxTop = -1, minTop = -1, left = -1;\\n  let maxBottom = 0, minBottom = 0;\\n  for (let right = 0; right < nums.length; ++right) {\\n    const val = nums[right];\\n    while (maxTop >= maxBottom && val > maxQue[maxTop]) --maxTop;\\n    while (minTop >= minBottom && val < minQue[minTop]) --minTop;\\n    maxQue[++maxTop] = val;\\n    minQue[++minTop] = val;\\n    if (maxQue[maxBottom] - minQue[minBottom] > limit) {\\n      ++left;\\n      maxQue[maxBottom] === nums[left] && ++maxBottom;\\n      minQue[minBottom] === nums[left] && ++minBottom;\\n    }\\n  }\\n  return nums.length - left - 1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 950108,
                "title": "explanation-of-deque-with-sliding-window-c",
                "content": "First, research about the Sliding Window Maximum (Maximum of all subarrays of size k) algorithm.\\nThen notice that once you found a subarray of length L, there\\'s no need to check other subarrays of length <= L.\\n\\nThis gives the following algorithm:\\n1. start with the first element of the array. it will always be possible to form this subarray\\n2. keep expanding the window to the right until you find a subarray that does not fit the solution\\n3. move the entire window one step to the right (maintaining its length)\\n4. repeat 2 and 3\\n\\nKeep track of min and max at all times with 2 deques.\\nComplexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    deque<int> mindeque;\\n    deque<int> maxdeque;\\n    \\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int left = 0;\\n        int right = 0;\\n        int best = 1;\\n        \\n        while (right < nums.size()) {\\n            push(nums[right]);\\n            int mini = mindeque.front();\\n            int maxi = maxdeque.front();\\n            \\n            if (maxi - mini <= limit) {\\n                best = max(best, right - left + 1);\\n            } else {\\n                pop(nums[left]);\\n                left++;\\n            }\\n            \\n            right++;\\n        }\\n       \\n        return best;\\n    }\\n    \\n    void pop(int x) {\\n        if (mindeque.front() == x) {\\n            mindeque.pop_front();\\n        }\\n        if (maxdeque.front() == x) {\\n            maxdeque.pop_front();\\n        }\\n    }\\n    \\n    void push(int x) {\\n        while (!mindeque.empty() && mindeque.back() > x) {\\n            mindeque.pop_back();\\n        }\\n        mindeque.push_back(x);\\n        while (!maxdeque.empty() && maxdeque.back() < x) {\\n            maxdeque.pop_back();\\n        }\\n        maxdeque.push_back(x);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    deque<int> mindeque;\\n    deque<int> maxdeque;\\n    \\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int left = 0;\\n        int right = 0;\\n        int best = 1;\\n        \\n        while (right < nums.size()) {\\n            push(nums[right]);\\n            int mini = mindeque.front();\\n            int maxi = maxdeque.front();\\n            \\n            if (maxi - mini <= limit) {\\n                best = max(best, right - left + 1);\\n            } else {\\n                pop(nums[left]);\\n                left++;\\n            }\\n            \\n            right++;\\n        }\\n       \\n        return best;\\n    }\\n    \\n    void pop(int x) {\\n        if (mindeque.front() == x) {\\n            mindeque.pop_front();\\n        }\\n        if (maxdeque.front() == x) {\\n            maxdeque.pop_front();\\n        }\\n    }\\n    \\n    void push(int x) {\\n        while (!mindeque.empty() && mindeque.back() > x) {\\n            mindeque.pop_back();\\n        }\\n        mindeque.push_back(x);\\n        while (!maxdeque.empty() && maxdeque.back() < x) {\\n            maxdeque.pop_back();\\n        }\\n        maxdeque.push_back(x);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609683,
                "title": "python-using-minmaxqueue-easy-to-understand",
                "content": "The idea is to create a class `MinMaxQueue` that keeps track of min and max value every time.\\nIn the main function, we just simple check whether the array satisfy the constraint and dequeue a value from the queue if it doesn\\'t.\\n\\nTime: `O(N)` where N is the length of the `nums` because for each number in `nums`, we perform constant operations (`enqueue`, `getMin`, `getMax`)\\nSpace: `O(N)` At max we store len(nums) number of values in the `MinMaxQueue`\\n\\n```\\nclass MinMaxQueue:\\n    \\n    def __init__(self):\\n        self.queue = collections.deque()\\n        self.min = collections.deque()\\n        self.max = collections.deque()\\n        self.id = 0\\n        self.length = 0\\n\\n    def enqueue(self, val):\\n        self.queue.append((val, self.id))\\n        # add to max\\n        while self.max and val > self.max[-1][0]:\\n            self.max.pop()\\n        self.max.append((val, self.id))\\n        # add to min\\n        while self.min and val < self.min[-1][0]:\\n            self.min.pop()\\n        self.min.append((val, self.id))\\n        \\n        self.length += 1\\n        self.id += 1\\n                        \\n    def dequeue(self):\\n        if self.queue:\\n            popped_val, popped_id = self.queue.popleft()\\n            if self.max[0][1] == popped_id:\\n                max_popped = self.max.popleft()\\n            if self.min[0][1] == popped_id:\\n                min_popped = self.min.popleft()\\n            self.length -= 1\\n            return popped_val\\n    \\n    def getMax(self):\\n        return self.max[0][0]\\n    \\n    def getMin(self):\\n        return self.min[0][0]\\n        \\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        max_len = 0\\n        queue = MinMaxQueue()\\n        for i in range(len(nums)):\\n            queue.enqueue(nums[i])\\n            curr_min = queue.getMin()\\n            curr_max = queue.getMax()\\n            abs_diff = abs(curr_max - curr_min)\\n            while abs_diff > limit:\\n                queue.dequeue()\\n                curr_min = queue.getMin()\\n                curr_max = queue.getMax()\\n                abs_diff = abs(curr_max - curr_min)\\n            max_len = max(max_len, queue.length)\\n        return max_len\\n```",
                "solutionTags": [],
                "code": "```\\nclass MinMaxQueue:\\n    \\n    def __init__(self):\\n        self.queue = collections.deque()\\n        self.min = collections.deque()\\n        self.max = collections.deque()\\n        self.id = 0\\n        self.length = 0\\n\\n    def enqueue(self, val):\\n        self.queue.append((val, self.id))\\n        # add to max\\n        while self.max and val > self.max[-1][0]:\\n            self.max.pop()\\n        self.max.append((val, self.id))\\n        # add to min\\n        while self.min and val < self.min[-1][0]:\\n            self.min.pop()\\n        self.min.append((val, self.id))\\n        \\n        self.length += 1\\n        self.id += 1\\n                        \\n    def dequeue(self):\\n        if self.queue:\\n            popped_val, popped_id = self.queue.popleft()\\n            if self.max[0][1] == popped_id:\\n                max_popped = self.max.popleft()\\n            if self.min[0][1] == popped_id:\\n                min_popped = self.min.popleft()\\n            self.length -= 1\\n            return popped_val\\n    \\n    def getMax(self):\\n        return self.max[0][0]\\n    \\n    def getMin(self):\\n        return self.min[0][0]\\n        \\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        max_len = 0\\n        queue = MinMaxQueue()\\n        for i in range(len(nums)):\\n            queue.enqueue(nums[i])\\n            curr_min = queue.getMin()\\n            curr_max = queue.getMax()\\n            abs_diff = abs(curr_max - curr_min)\\n            while abs_diff > limit:\\n                queue.dequeue()\\n                curr_min = queue.getMin()\\n                curr_max = queue.getMax()\\n                abs_diff = abs(curr_max - curr_min)\\n            max_len = max(max_len, queue.length)\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2136808,
                "title": "java-heaps-treemap-and-deques-solutions-o-n",
                "content": "The overall idea is using **sliding window** approach.\\n\\nevery time, move the right bound to find a longer result.\\nif the condition is not satisfied, move left bound to maintain the length.\\n\\n### Solution 1: 2 Heaps\\n1. use heaps to track the max, min values in the window\\n2. move the right bound, and add the number to max, min heaps\\n3. if max - min > limit, move left bound to the index + 1\\n\\n### Complexity\\ntime: `O(nlogn)`\\nspace: `O(n)`\\n### Java\\n```java\\npublic int longestSubarray(int[] A, int limit) {\\n\\tPriorityQueue<int[]> minQ = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n\\tPriorityQueue<int[]> maxQ = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n\\n\\tint j = 0, i;\\n\\tint res = 0;\\n\\tfor (i = 0; i < A.length; i++) {\\n\\t\\tminQ.add(new int[]{A[i], i});\\n\\t\\tmaxQ.add(new int[]{A[i], i});\\n\\n\\t\\twhile (maxQ.peek()[0] - minQ.peek()[0] > limit) {\\n\\t\\t\\tj = Math.min(maxQ.peek()[1], minQ.peek()[1]) + 1;\\n\\t\\t\\twhile (minQ.peek()[1] < j) minQ.poll();\\n\\t\\t\\twhile (maxQ.peek()[1] < j) maxQ.poll();\\n\\t\\t}\\n\\t\\tres = Math.max(res, i - j + 1);\\n\\t}\\n\\treturn res;\\n}\\n```\\n\\n----\\n### Solution 2: TreeMap\\n1. use tree map to track the max, min values in the window\\n2. move the right bound, and add the number to the tree\\n3. if max - min > limit, remove the left-most value, and move left bound\\n\\n\\n### Complexity\\ntime: `O(nlogn)`\\nspace: `O(n)`\\n### Java\\n```java\\npublic int longestSubarray(int[] A, int limit) {\\n\\tTreeMap<Integer, Integer> m = new TreeMap<>();\\n\\n\\tint j = 0, i;\\n\\tfor (i = 0; i < A.length; i++) {\\n\\t\\tm.put(A[i], m.getOrDefault(A[i], 0) + 1);\\n\\n\\t\\tif (m.lastKey() - m.firstKey() > limit) {\\n\\t\\t\\tm.put(A[j], m.get(A[j]) - 1);\\n\\t\\t\\tif (m.get(A[j]) == 0) m.remove(A[j]);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\treturn i - j;\\n}\\n```\\n----\\n### Solution 3: Deques\\nuse deques as increasing/decreasing monotonic stacks to track the max, min values\\n\\nto track a max value, if we have new value `k`, in the current window, any values less than `k` won\\'t be considered as a max value.\\nwhich means we can discard all less than or equals to `k`, then that is **increasing monotonic stack**\\n\\nsame idea, to tarck a min value, we need **decreasing monotonic stack**\\n\\n\\n### Steps\\n1. add element to both deques\\n2. for max deque, remove all <= new element\\n3. for min deque, remove all >= new element\\n4. if the max - min > limit, remove the element in left bound from deques, and move left bound\\n\\n### Complexity\\ntime: `O(n)`\\nspace: `O(n)`\\n### Java\\n```java\\npublic int longestSubarray(int[] A, int limit) {\\n    Deque<Integer> maxQ = new ArrayDeque<>();\\n    Deque<Integer> minQ = new ArrayDeque<>();\\n\\n    int j = 0, i;\\n    for (i = 0; i < A.length; i++) {\\n        while (!maxQ.isEmpty() && A[maxQ.peekLast()] <= A[i]) maxQ.removeLast();\\n        while (!minQ.isEmpty() && A[minQ.peekLast()] >= A[i]) minQ.removeLast();\\n\\n        maxQ.add(i);\\n        minQ.add(i);\\n\\n        if (A[maxQ.peek()] - A[minQ.peek()] > limit) {\\n            if (maxQ.peek() == j) maxQ.remove();\\n            if (minQ.peek() == j) minQ.remove();\\n            j++;\\n        }\\n    }\\n    return i - j;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int longestSubarray(int[] A, int limit) {\\n\\tPriorityQueue<int[]> minQ = new PriorityQueue<>((a, b) -> a[0] - b[0]);\\n\\tPriorityQueue<int[]> maxQ = new PriorityQueue<>((a, b) -> b[0] - a[0]);\\n\\n\\tint j = 0, i;\\n\\tint res = 0;\\n\\tfor (i = 0; i < A.length; i++) {\\n\\t\\tminQ.add(new int[]{A[i], i});\\n\\t\\tmaxQ.add(new int[]{A[i], i});\\n\\n\\t\\twhile (maxQ.peek()[0] - minQ.peek()[0] > limit) {\\n\\t\\t\\tj = Math.min(maxQ.peek()[1], minQ.peek()[1]) + 1;\\n\\t\\t\\twhile (minQ.peek()[1] < j) minQ.poll();\\n\\t\\t\\twhile (maxQ.peek()[1] < j) maxQ.poll();\\n\\t\\t}\\n\\t\\tres = Math.max(res, i - j + 1);\\n\\t}\\n\\treturn res;\\n}\\n```\n```java\\npublic int longestSubarray(int[] A, int limit) {\\n\\tTreeMap<Integer, Integer> m = new TreeMap<>();\\n\\n\\tint j = 0, i;\\n\\tfor (i = 0; i < A.length; i++) {\\n\\t\\tm.put(A[i], m.getOrDefault(A[i], 0) + 1);\\n\\n\\t\\tif (m.lastKey() - m.firstKey() > limit) {\\n\\t\\t\\tm.put(A[j], m.get(A[j]) - 1);\\n\\t\\t\\tif (m.get(A[j]) == 0) m.remove(A[j]);\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t}\\n\\treturn i - j;\\n}\\n```\n```java\\npublic int longestSubarray(int[] A, int limit) {\\n    Deque<Integer> maxQ = new ArrayDeque<>();\\n    Deque<Integer> minQ = new ArrayDeque<>();\\n\\n    int j = 0, i;\\n    for (i = 0; i < A.length; i++) {\\n        while (!maxQ.isEmpty() && A[maxQ.peekLast()] <= A[i]) maxQ.removeLast();\\n        while (!minQ.isEmpty() && A[minQ.peekLast()] >= A[i]) minQ.removeLast();\\n\\n        maxQ.add(i);\\n        minQ.add(i);\\n\\n        if (A[maxQ.peek()] - A[minQ.peek()] > limit) {\\n            if (maxQ.peek() == j) maxQ.remove();\\n            if (minQ.peek() == j) minQ.remove();\\n            j++;\\n        }\\n    }\\n    return i - j;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1712852,
                "title": "java-simple-solution-with-explanation-easy-to-understand",
                "content": "```java\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        Deque<Integer> min = new ArrayDeque<>(); // maintains increasing order of the value index. So that min front will always have smallest value.\\n        Deque<Integer> max = new ArrayDeque<>();// maintains decreasing order of the value index. So that max front will always have the greatest value.\\n        int size = 0;\\n        int left =0;\\n        int right =0;\\n        while(right < nums.length){\\n            int val  = nums[right];\\n            //from behind remove all the index that have values less than val.\\n            while(!min.isEmpty() && nums[min.peekLast()]>=val) min.pollLast();\\n            //add val index to the end. Hence the increasing order will be maintained\\n            min.addLast(right);\\n            while(!max.isEmpty() && nums[max.peekLast()]<=val) max.pollLast();\\n            //add val index to the end. Hence maintaining decreasing order.\\n            max.add(right);\\n            int minVal = nums[min.peekFirst()]; // min front will have min value index\\n            int maxVal = nums[max.peekFirst()]; // max front will have max value index\\n            if(maxVal - minVal<= limit) { \\n                size = Math.max(size,right-left+1); // right-left+1 will tell no of elements present in the current subarray\\n                right++;\\n            }\\n            else {\\n                /*\\n                As the if condition failed we will increment left index.\\n                And from the new left index new subarray will start.\\n                Hence all the indexes less than left should be removed from min and max deque as they are not part of the current subarray.*/\\n                left++;\\n                while(left> min.peekFirst()) min.pollFirst();\\n                while(left > max.peekFirst()) max.pollFirst();\\n            }\\n        }\\n        return size;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Queue"
                ],
                "code": "```java\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        Deque<Integer> min = new ArrayDeque<>(); // maintains increasing order of the value index. So that min front will always have smallest value.\\n        Deque<Integer> max = new ArrayDeque<>();// maintains decreasing order of the value index. So that max front will always have the greatest value.\\n        int size = 0;\\n        int left =0;\\n        int right =0;\\n        while(right < nums.length){\\n            int val  = nums[right];\\n            //from behind remove all the index that have values less than val.\\n            while(!min.isEmpty() && nums[min.peekLast()]>=val) min.pollLast();\\n            //add val index to the end. Hence the increasing order will be maintained\\n            min.addLast(right);\\n            while(!max.isEmpty() && nums[max.peekLast()]<=val) max.pollLast();\\n            //add val index to the end. Hence maintaining decreasing order.\\n            max.add(right);\\n            int minVal = nums[min.peekFirst()]; // min front will have min value index\\n            int maxVal = nums[max.peekFirst()]; // max front will have max value index\\n            if(maxVal - minVal<= limit) { \\n                size = Math.max(size,right-left+1); // right-left+1 will tell no of elements present in the current subarray\\n                right++;\\n            }\\n            else {\\n                /*\\n                As the if condition failed we will increment left index.\\n                And from the new left index new subarray will start.\\n                Hence all the indexes less than left should be removed from min and max deque as they are not part of the current subarray.*/\\n                left++;\\n                while(left> min.peekFirst()) min.pollFirst();\\n                while(left > max.peekFirst()) max.pollFirst();\\n            }\\n        }\\n        return size;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1327479,
                "title": "c-sliding-window-deque-heap-multiset-solution",
                "content": "**Sliding Window + Deque Solution : O(N)**\\n\\nRuntime: 136 ms, faster than 71.39% of C++ online submissions for Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit.\\nMemory Usage: 52.2 MB, less than 77.34% of C++ online submissions for Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit.\\n\\n```\\nLongest subarray can be found using Sliding Window approach where we expand and shrink window\\nbased on condition. Now, finding absolute difference between all element is same as finding difference\\nbetween Max and Min element inside the window. Finding the Max and Min element inside dynamic size\\nwindow is the challenge. This can be solved using 2 Deque or 2 Heap or Multiset. Maintaining 2 Deque\\nfor tracking Max and Min element gives us a O(N) solution.\\n\\nMax element tracking Deque => maxD => Non-increasing list\\nMin element tracking Deque => minD => Non-decreasing list\\nMismatch condition : maxD.front() - minD.front() > limit\\n```\\n\\n```\\nAs we loop through the elements we increase the last pointer in each step and insert nums[last] in maxD and minD. \\nNow before that we need to remove elements which are less than nums[last] from maxD so\\nthat we can maintain a  Non-increasing list, also the front of maxD will contain max element between first and last pointer \\nas we will remove the front element when we find a Mismatch condition and maxD.front()==nums[first].\\nIncase of Mismatch condition we shrink the window by increasing first pointer.\\n\\nSimilarly we remove the elements from minD which are greater than nums[last] to maintain a \\nNon-decreasing list and also remove the minD.front() when there is a Mismatch condition and minD.front()==nums[first].\\n```\\n\\n```\\nExample Input: nums = [10,1,2,4,7,2], limit = 5\\nOutput: 4 \\nFollowing is the simulation of the algorithm\\n```\\n![image](https://assets.leetcode.com/users/images/cdb78b5f-c364-4c4b-a7b8-eaae6f88851e_1625863474.4878218.png)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n                \\n        // array length\\n        int n = nums.size();\\n        \\n        // max and min deque\\n        deque<int>maxD;\\n        deque<int>minD;\\n        \\n        // first pointer of the window\\n        int first = 0;\\n        \\n        // longest sub-array length\\n        int maxL = 0;\\n        \\n        // lopp through the array\\n        for(int last = 0; last < n; last++)\\n        {\\n            // remove elements from maxD which are less than nums[last]\\n            // As maxD is Non-increasing list we compare and remove from the back of maxD\\n            // maxD will contain the max elements from first to last of the window in a non-increasing order\\n            while(!maxD.empty() && nums[last]>maxD.back())maxD.pop_back();\\n            \\n            // remove elements from minD which are greater than nums[last]\\n            // As minD is Non-decreasing list we compare and remove from the back of minD\\n            // minD will contain the min elements from first to last of the window in a non-decreasing order\\n            while(!minD.empty() && nums[last]<minD.back())minD.pop_back();\\n            \\n            // push back nums[last] in maxD and minD as all elements in maxD\\n            // are greater than nums[last] and all elements in minD are less than nums[last]\\n            maxD.push_back(nums[last]);\\n            minD.push_back(nums[last]);\\n            \\n            // mismatch condition as max and min element diff is greater than limit \\n            // thus window is not valid and so need to shrink window by increasing first pointer\\n            if((maxD.front()-minD.front())>limit)\\n            {\\n                // before increasing first pointer need to remove the first pointer element\\n                // from maxD or minD if it is the current max or min element in the window\\n                // which means nums[first] == maxD.front() or nums[first] == minD.front()\\n                // If nums[first] is not the current max or min element then it will get removed \\n                // at the begining of future loop when nums[future_last] > nums[current_first] from maxD\\n                // and when nums[future_last] < nums[current_first] from minD \\n                if(maxD.front()==nums[first])maxD.pop_front();\\n                if(minD.front()==nums[first])minD.pop_front();\\n                first++;\\n            }\\n            \\n            // calculate the max valid subarray length and get the max length\\n            maxL = max(maxL,last-first+1);            \\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```\\n\\n\\n**Sliding Window + Multiset Solution : O(NLogN)**\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n                \\n        int n = nums.size();\\n        multiset<int>track;\\n        \\n        int first = 0;\\n        int last = -1;\\n        int maxL = 0;\\n        \\n        while(last < n)\\n        {\\n            last++;\\n            if(last<n)\\n                track.insert(nums[last]);\\n\\n            while((*track.rbegin()-*track.begin())>limit)\\n                track.erase(track.find(nums[first++]));\\n            \\n            maxL = max(maxL,min(last,n-1)-first+1);            \\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```\\n\\n\\n**Sliding Window + Heap Solution : O(NLogN)**\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n                \\n        int n = nums.size();\\n        priority_queue<pair<int,int>> maxHeap;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>,greater<pair<int,int>>> minHeap;\\n        \\n        int first = 0;\\n        int last = -1;\\n        int maxL = 0;\\n        \\n        while(last < n)\\n        {\\n            last++;\\n            if(last<n)\\n            {\\n                maxHeap.push(make_pair(nums[last],last));\\n                minHeap.push(make_pair(nums[last],last));                                    \\n            }\\n\\n            while(abs(maxHeap.top().first-minHeap.top().first)>limit)\\n            {\\n                first =  min(maxHeap.top().second,minHeap.top().second) + 1;\\n                while(!minHeap.empty() && minHeap.top().second<first)minHeap.pop();\\n                while(!maxHeap.empty() && maxHeap.top().second<first)maxHeap.pop();\\n            }\\n            \\n            maxL = max(maxL,min(last,n-1)-first+1);            \\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nLongest subarray can be found using Sliding Window approach where we expand and shrink window\\nbased on condition. Now, finding absolute difference between all element is same as finding difference\\nbetween Max and Min element inside the window. Finding the Max and Min element inside dynamic size\\nwindow is the challenge. This can be solved using 2 Deque or 2 Heap or Multiset. Maintaining 2 Deque\\nfor tracking Max and Min element gives us a O(N) solution.\\n\\nMax element tracking Deque => maxD => Non-increasing list\\nMin element tracking Deque => minD => Non-decreasing list\\nMismatch condition : maxD.front() - minD.front() > limit\\n```\n```\\nAs we loop through the elements we increase the last pointer in each step and insert nums[last] in maxD and minD. \\nNow before that we need to remove elements which are less than nums[last] from maxD so\\nthat we can maintain a  Non-increasing list, also the front of maxD will contain max element between first and last pointer \\nas we will remove the front element when we find a Mismatch condition and maxD.front()==nums[first].\\nIncase of Mismatch condition we shrink the window by increasing first pointer.\\n\\nSimilarly we remove the elements from minD which are greater than nums[last] to maintain a \\nNon-decreasing list and also remove the minD.front() when there is a Mismatch condition and minD.front()==nums[first].\\n```\n```\\nExample Input: nums = [10,1,2,4,7,2], limit = 5\\nOutput: 4 \\nFollowing is the simulation of the algorithm\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n                \\n        // array length\\n        int n = nums.size();\\n        \\n        // max and min deque\\n        deque<int>maxD;\\n        deque<int>minD;\\n        \\n        // first pointer of the window\\n        int first = 0;\\n        \\n        // longest sub-array length\\n        int maxL = 0;\\n        \\n        // lopp through the array\\n        for(int last = 0; last < n; last++)\\n        {\\n            // remove elements from maxD which are less than nums[last]\\n            // As maxD is Non-increasing list we compare and remove from the back of maxD\\n            // maxD will contain the max elements from first to last of the window in a non-increasing order\\n            while(!maxD.empty() && nums[last]>maxD.back())maxD.pop_back();\\n            \\n            // remove elements from minD which are greater than nums[last]\\n            // As minD is Non-decreasing list we compare and remove from the back of minD\\n            // minD will contain the min elements from first to last of the window in a non-decreasing order\\n            while(!minD.empty() && nums[last]<minD.back())minD.pop_back();\\n            \\n            // push back nums[last] in maxD and minD as all elements in maxD\\n            // are greater than nums[last] and all elements in minD are less than nums[last]\\n            maxD.push_back(nums[last]);\\n            minD.push_back(nums[last]);\\n            \\n            // mismatch condition as max and min element diff is greater than limit \\n            // thus window is not valid and so need to shrink window by increasing first pointer\\n            if((maxD.front()-minD.front())>limit)\\n            {\\n                // before increasing first pointer need to remove the first pointer element\\n                // from maxD or minD if it is the current max or min element in the window\\n                // which means nums[first] == maxD.front() or nums[first] == minD.front()\\n                // If nums[first] is not the current max or min element then it will get removed \\n                // at the begining of future loop when nums[future_last] > nums[current_first] from maxD\\n                // and when nums[future_last] < nums[current_first] from minD \\n                if(maxD.front()==nums[first])maxD.pop_front();\\n                if(minD.front()==nums[first])minD.pop_front();\\n                first++;\\n            }\\n            \\n            // calculate the max valid subarray length and get the max length\\n            maxL = max(maxL,last-first+1);            \\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n                \\n        int n = nums.size();\\n        multiset<int>track;\\n        \\n        int first = 0;\\n        int last = -1;\\n        int maxL = 0;\\n        \\n        while(last < n)\\n        {\\n            last++;\\n            if(last<n)\\n                track.insert(nums[last]);\\n\\n            while((*track.rbegin()-*track.begin())>limit)\\n                track.erase(track.find(nums[first++]));\\n            \\n            maxL = max(maxL,min(last,n-1)-first+1);            \\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n                \\n        int n = nums.size();\\n        priority_queue<pair<int,int>> maxHeap;\\n        priority_queue<pair<int,int>, vector<pair<int,int>>,greater<pair<int,int>>> minHeap;\\n        \\n        int first = 0;\\n        int last = -1;\\n        int maxL = 0;\\n        \\n        while(last < n)\\n        {\\n            last++;\\n            if(last<n)\\n            {\\n                maxHeap.push(make_pair(nums[last],last));\\n                minHeap.push(make_pair(nums[last],last));                                    \\n            }\\n\\n            while(abs(maxHeap.top().first-minHeap.top().first)>limit)\\n            {\\n                first =  min(maxHeap.top().second,minHeap.top().second) + 1;\\n                while(!minHeap.empty() && minHeap.top().second<first)minHeap.pop();\\n                while(!maxHeap.empty() && maxHeap.top().second<first)maxHeap.pop();\\n            }\\n            \\n            maxL = max(maxL,min(last,n-1)-first+1);            \\n        }\\n        \\n        return maxL;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656139,
                "title": "java-traditional-sliding-window-o-n-k-no-deque-no-treemap",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        if (nums == null || nums.length == 0)\\n            return 0;\\n\\n        int len = nums.length, left = 0, min = nums[0], max = nums[0], res = 0;\\n\\n        for (int i = 0; i < len; i++) {\\n            int diff = Math.max(Math.abs(nums[i] - min), Math.abs(max - nums[i]));\\n            if (diff <= limit) {\\n                min = Math.min(nums[i], min);\\n                max = Math.max(nums[i], max);\\n                res = Math.max(res, i - left + 1);\\n            } else {\\n                int right = i - 1;\\n                min = max = nums[i];\\n                while (left < right && Math.abs(nums[i] - nums[right]) <= limit) {\\n                    min = Math.min(nums[right], min);\\n                    max = Math.max(nums[right], max);\\n                    right--;\\n                }\\n                left = right + 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        if (nums == null || nums.length == 0)\\n            return 0;\\n\\n        int len = nums.length, left = 0, min = nums[0], max = nums[0], res = 0;\\n\\n        for (int i = 0; i < len; i++) {\\n            int diff = Math.max(Math.abs(nums[i] - min), Math.abs(max - nums[i]));\\n            if (diff <= limit) {\\n                min = Math.min(nums[i], min);\\n                max = Math.max(nums[i], max);\\n                res = Math.max(res, i - left + 1);\\n            } else {\\n                int right = i - 1;\\n                min = max = nums[i];\\n                while (left < right && Math.abs(nums[i] - nums[right]) <= limit) {\\n                    min = Math.min(nums[right], min);\\n                    max = Math.max(nums[right], max);\\n                    right--;\\n                }\\n                left = right + 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 612321,
                "title": "c-sliding-window-min-and-max-heap",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n\\t    // max heap stores number and index\\n        priority_queue<pair<int, int>> maxpq;\\n\\t\\t// min heap stores number and index\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minpq;   \\n        int res = 0;\\n        for(int start = 0, end = 0, len = (int)nums.size(); end < len; ++end){\\n            minpq.emplace(nums[end], end);\\n            maxpq.emplace(nums[end], end);\\n            while(start <= end && maxpq.top().first - minpq.top().first > limit){\\n\\t\\t\\t\\t// if the difference between the top elements exceed the limit, \\n\\t\\t\\t\\t// we need to remove one of them until the invariant is satisfied.\\n                ++start;\\n\\t\\t\\t\\t// remove elements from the heap that have  index less than start index.\\n                while(!maxpq.empty() && maxpq.top().second < start) maxpq.pop();\\n                while(!minpq.empty() && minpq.top().second < start) minpq.pop();\\n            }\\n\\t\\t\\t// update  result.\\n            res = max(res, end - start + 1);\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n\\t    // max heap stores number and index\\n        priority_queue<pair<int, int>> maxpq;\\n\\t\\t// min heap stores number and index\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> minpq;   \\n        int res = 0;\\n        for(int start = 0, end = 0, len = (int)nums.size(); end < len; ++end){\\n            minpq.emplace(nums[end], end);\\n            maxpq.emplace(nums[end], end);\\n            while(start <= end && maxpq.top().first - minpq.top().first > limit){\\n\\t\\t\\t\\t// if the difference between the top elements exceed the limit, \\n\\t\\t\\t\\t// we need to remove one of them until the invariant is satisfied.\\n                ++start;\\n\\t\\t\\t\\t// remove elements from the heap that have  index less than start index.\\n                while(!maxpq.empty() && maxpq.top().second < start) maxpq.pop();\\n                while(!minpq.empty() && minpq.top().second < start) minpq.pop();\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 611888,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} limit\\n * @return {number}\\n */\\nvar longestSubarray = function(nums, limit) {\\n \\n    let count = 0;\\n    let result = 0;\\n    let current = [];\\n    let min = Number.MAX_SAFE_INTEGER;\\n    let max = Number.MIN_SAFE_INTEGER;\\n    \\n    for (let index = 0; index< nums.length; index++) {\\n        \\n        current.push(nums[index]);\\n        \\n        if (current.length < result) {\\n            continue;\\n        }\\n        \\n        min = Math.min(min, nums[index]);\\n        max = Math.max(max, nums[index]);\\n        \\n        let diff = Math.abs(max-min);\\n        \\n        if (diff <= limit) {\\n            count = current.length;\\n        } else {\\n            let ele = current.shift();\\n            \\n            if (ele === min) {\\n                min = Math.min(...current);\\n            } else if (ele === max) {\\n                max = Math.max(...current);\\n            }\\n            \\n        }\\n        \\n        \\n        result = Math.max(result, count);\\n    }\\n    \\n    \\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} limit\\n * @return {number}\\n */\\nvar longestSubarray = function(nums, limit) {\\n \\n    let count = 0;\\n    let result = 0;\\n    let current = [];\\n    let min = Number.MAX_SAFE_INTEGER;\\n    let max = Number.MIN_SAFE_INTEGER;\\n    \\n    for (let index = 0; index< nums.length; index++) {\\n        \\n        current.push(nums[index]);\\n        \\n        if (current.length < result) {\\n            continue;\\n        }\\n        \\n        min = Math.min(min, nums[index]);\\n        max = Math.max(max, nums[index]);\\n        \\n        let diff = Math.abs(max-min);\\n        \\n        if (diff <= limit) {\\n            count = current.length;\\n        } else {\\n            let ele = current.shift();\\n            \\n            if (ele === min) {\\n                min = Math.min(...current);\\n            } else if (ele === max) {\\n                max = Math.max(...current);\\n            }\\n            \\n        }\\n        \\n        \\n        result = Math.max(result, count);\\n    }\\n    \\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 893524,
                "title": "c-from-o-n-4-to-o-n-step-by-step-optimization",
                "content": "For this problem, even asked for a brute-force approach, there are multiple answers with different time complexities. The term \"brute-force\" here means a solution most intuitive, without any fancy data structure or algorithm.\\n\\nSpecifically, the most \"brutal\" approach would be a 4 level for-loop solution: 1) iterate over the start index of subarray, 2) iterate over the end index of the subarray 3) iterate over any element `a` within the subarray 4) iterate over another element `b` within the subarray. The code will look like\\n```\\nfor (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n\\t    bool isFeasible = true;\\n\\t    for (int s = i; s <= j; ++s) {\\n\\t\\t    for (int t = s; t <= j; ++t) {\\n\\t\\t\\t    isFeasible = isFeasible && (abs(nums[s] - nums[t]) <= limit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (isFeasible) {\\n\\t\\t    ans = max(ans, j - i + 1);\\n\\t\\t}\\n\\t}\\n}\\n```\\nOfcourse, this O(n^4) approach is far from an optimal solution. With some careful observation, it is not hard to find that a subarray is feasible if and only if its maximal and minimal elements are within distance `limit`. While given start and end indicies of a subarray, one can find the maximal and minimal elements in linear time, therefore we can have a better `O(n^3)` brute-force solution\\n```\\nfor (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n\\t    int minVal = INT_MAX, maxVal = INT_MIN;\\n\\t\\tfor (int k = i; k <= j; ++k) {\\n\\t\\t    minVal = min(minVal, nums[k]);\\n\\t\\t\\tmaxVal = max(maxVal, nums[k]);\\n\\t\\t}\\n\\t\\tif (maxVal - minVal <= limit) {\\n\\t\\t    ans = max(ans, j - i + 1);\\n\\t\\t}\\n\\t}\\n}\\n```\\nNotice that we have a lot of duplicate computation of maximal and minimal elements in an subarray. Take the maximal value for example, suppose we already calculate the maximal value for interval `[i, j-1]`, then maximal value for interval `[i, j]` is the larger value between the former one and `nums[j]`. In other words, we can update the maximal and minimal values based on their values in the previous iteration, therefore, we can immediately update the brute-force solution to O(n^2) time.\\n```\\nfor (int i = 0; i < n; ++i) {\\n    int minVal = nums[i], maxVal = nums[i];\\n    for (int j = i; j < n; ++j) {\\n\\t    minVal = min(minVal, nums[i]);\\n\\t\\tmaxVal = max(maxVal, nums[i]);\\n\\t\\tif (maxVal - minVal <= limit) {\\n\\t\\t    ans = max(ans, j - i + 1);\\n\\t\\t}\\n\\t}\\n}\\n```\\nNow that we achieve the \"best\" brute-force solution, it is time to apply some data structure or algorithm to futher improve it. For many problems, insight often come from some fact that is straightforward --- so straightforward that is easy to neglect. Looking back to this problem, the \"magic\" fact comes from the observation that if a subarray is valid, then any subarray of itself is also valid, and if the subarray is not valid, then any subarray that covers it is not valid either.\\nIn other words, if we find a valid subarray of length `L`, then we are certain that there also exists a valid subarray of any length `l <= L`; if we cannot find any valid subarray of length `L`, then there will not be any valid subarray of length `l >= L`. Therefore, we can apply a binary search on the top-level to find the optimal `L`.\\n```\\nint start = 1, end = n;\\nwhile (start + 1 < end) {\\n    int mid = start + (end - start)/2;\\n\\tif (isValid(nums, mid, limit)) {\\n\\t    start = mid; // we find a valid subarray with length `mid`, and can go more agressively\\n\\t} else {\\n\\t    end = mid; // we cannot find any valid subarray, so the answer must be smaller than `mid`\\n\\t}\\n}\\nreturn isValid(nums, end, limit) ? end : start;\\n```\\nThe binary search takes `O(logn)` iterations, so whether we can do better than `O(n^2)` depends on how we implments the boolean routine `isValid(.)`. Note that given the length of the sub-array, the problem for the routine becomes finding min/max values in a sliding window with fixed width. The optimal solution for solving such problem is using monotic deque that takes linear time. (Please see https://leetcode.com/problems/sliding-window-maximum/ for more details.) Here is the code implemenation.\\n```\\nbool isValid(vector<int>& nums, int w, int limit) {\\n    if (w == 1) {\\n         return true;\\n    }\\n    deque<int> dqMin, dqMax;\\n    int n = nums.size();\\n    for (int i = 0; i < n; ++i) {\\n        if (!dqMax.empty() && dqMax.front() <= i - w) {\\n            dqMax.pop_front();\\n        }\\n        if (!dqMin.empty() && dqMin.front() <= i - w) {\\n            dqMin.pop_front();\\n        }\\n        while (!dqMax.empty() && nums[dqMax.back()] < nums[i]) {\\n            dqMax.pop_back();\\n        }\\n        while (!dqMin.empty() && nums[dqMin.back()] > nums[i]) {\\n            dqMin.pop_back();\\n        }\\n        dqMax.push_back(i);\\n        dqMin.push_back(i);\\n            \\n        if (i >= w - 1) {\\n            int minVal = nums[dqMin.front()];\\n            int maxVal = nums[dqMax.front()];\\n            if ((long)maxVal <= (long)minVal + limit) {\\n                return true;\\n            }\\n        }\\n            \\n    }\\n    return false;\\n}\\n```\\nThe whole algorithm hence takes `O(nlogn)` time, which is a great progress. But we are not there yet!\\nHow do we improve the algorithm further? We do not have to come up with a brand-new algorithm, but can improve based on what we have. Note that in our `isValid` implementation, the high level ideas are: 1) Push the current element from into the deque from back and maintain non-ascending/non-descending sequences; 2) Pop elements from front whose indices are outside the sliding window, by doing this we preserve the invariant that the elements on the front of the deques are exactly the maximum and minimum values of the current sliding window.\\nIn order to gain more insight, we can abstract the operation 2) as one step that kicks out those elements that violates some constraint --- well, in the case of `isValid` routine, the constraint is that all the elements in the deque should be in the current sliding window. If we jump out of this scope, and look at the problem at the top level, then we realize the whole problem is another kind of sliding window, with the constraint become \"the front elements of the two deques cannot be deviated more than `limit`\". Therefore, by slightling modifying the constraint of the sliding window and applying it at the top level, we yield an algorithm of `O(n)` time!\\nSince the width of the sliding window is not constant anymore, we need to maintain a variable `w` to represent the width of the window. Everytime we push an element, we increment `w` by 1, and then check if the constraint still holds or not, and keep decrementing `w` and poping out elements from the two deques until the constraint is satisfied. The approach is very similar to a typical two-pointer approach, and the only difference is that we might need to maintain multiple candidate max/min values for future sliding windows, that is why we need deques.\\nFollowing is the detailed implementation.\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int n = nums.size();\\n        if (!n)\\n            return 0;\\n        int maxw = 1, w = 0;\\n        deque<int> dqMin, dqMax;\\n        for (int i = 0; i < n; ++i) {\\n            while (!dqMax.empty() && nums[dqMax.back()] < nums[i]) {\\n                dqMax.pop_back();\\n            }\\n            while (!dqMin.empty() && nums[dqMin.back()] > nums[i]) {\\n                dqMin.pop_back();\\n            }\\n            dqMax.push_back(i);\\n            dqMin.push_back(i);\\n            ++w;\\n            while (!dqMax.empty() && !dqMin.empty()) {\\n                int minVal = nums[dqMin.front()];\\n                int maxVal = nums[dqMax.front()];\\n                if ((long)maxVal <= (long)minVal + limit) {\\n                    break;\\n                }\\n                --w;\\n                if (dqMin.front() <= i - w) {\\n                    dqMin.pop_front();\\n                }\\n                if (dqMax.front() <= i - w) {\\n                    dqMax.pop_front();\\n                }\\n            }\\n            maxw = max(maxw, w);\\n        }\\n        return maxw;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfor (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n\\t    bool isFeasible = true;\\n\\t    for (int s = i; s <= j; ++s) {\\n\\t\\t    for (int t = s; t <= j; ++t) {\\n\\t\\t\\t    isFeasible = isFeasible && (abs(nums[s] - nums[t]) <= limit);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif (isFeasible) {\\n\\t\\t    ans = max(ans, j - i + 1);\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nfor (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n\\t    int minVal = INT_MAX, maxVal = INT_MIN;\\n\\t\\tfor (int k = i; k <= j; ++k) {\\n\\t\\t    minVal = min(minVal, nums[k]);\\n\\t\\t\\tmaxVal = max(maxVal, nums[k]);\\n\\t\\t}\\n\\t\\tif (maxVal - minVal <= limit) {\\n\\t\\t    ans = max(ans, j - i + 1);\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nfor (int i = 0; i < n; ++i) {\\n    int minVal = nums[i], maxVal = nums[i];\\n    for (int j = i; j < n; ++j) {\\n\\t    minVal = min(minVal, nums[i]);\\n\\t\\tmaxVal = max(maxVal, nums[i]);\\n\\t\\tif (maxVal - minVal <= limit) {\\n\\t\\t    ans = max(ans, j - i + 1);\\n\\t\\t}\\n\\t}\\n}\\n```\n```\\nint start = 1, end = n;\\nwhile (start + 1 < end) {\\n    int mid = start + (end - start)/2;\\n\\tif (isValid(nums, mid, limit)) {\\n\\t    start = mid; // we find a valid subarray with length `mid`, and can go more agressively\\n\\t} else {\\n\\t    end = mid; // we cannot find any valid subarray, so the answer must be smaller than `mid`\\n\\t}\\n}\\nreturn isValid(nums, end, limit) ? end : start;\\n```\n```\\nbool isValid(vector<int>& nums, int w, int limit) {\\n    if (w == 1) {\\n         return true;\\n    }\\n    deque<int> dqMin, dqMax;\\n    int n = nums.size();\\n    for (int i = 0; i < n; ++i) {\\n        if (!dqMax.empty() && dqMax.front() <= i - w) {\\n            dqMax.pop_front();\\n        }\\n        if (!dqMin.empty() && dqMin.front() <= i - w) {\\n            dqMin.pop_front();\\n        }\\n        while (!dqMax.empty() && nums[dqMax.back()] < nums[i]) {\\n            dqMax.pop_back();\\n        }\\n        while (!dqMin.empty() && nums[dqMin.back()] > nums[i]) {\\n            dqMin.pop_back();\\n        }\\n        dqMax.push_back(i);\\n        dqMin.push_back(i);\\n            \\n        if (i >= w - 1) {\\n            int minVal = nums[dqMin.front()];\\n            int maxVal = nums[dqMax.front()];\\n            if ((long)maxVal <= (long)minVal + limit) {\\n                return true;\\n            }\\n        }\\n            \\n    }\\n    return false;\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int n = nums.size();\\n        if (!n)\\n            return 0;\\n        int maxw = 1, w = 0;\\n        deque<int> dqMin, dqMax;\\n        for (int i = 0; i < n; ++i) {\\n            while (!dqMax.empty() && nums[dqMax.back()] < nums[i]) {\\n                dqMax.pop_back();\\n            }\\n            while (!dqMin.empty() && nums[dqMin.back()] > nums[i]) {\\n                dqMin.pop_back();\\n            }\\n            dqMax.push_back(i);\\n            dqMin.push_back(i);\\n            ++w;\\n            while (!dqMax.empty() && !dqMin.empty()) {\\n                int minVal = nums[dqMin.front()];\\n                int maxVal = nums[dqMax.front()];\\n                if ((long)maxVal <= (long)minVal + limit) {\\n                    break;\\n                }\\n                --w;\\n                if (dqMin.front() <= i - w) {\\n                    dqMin.pop_front();\\n                }\\n                if (dqMax.front() <= i - w) {\\n                    dqMax.pop_front();\\n                }\\n            }\\n            maxw = max(maxw, w);\\n        }\\n        return maxw;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 610144,
                "title": "py-detailed-easy-sol-explaination-thinking-approach-commented",
                "content": "#coding style- PEP8 (standard python)\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return 1\\n        # left and right index for tracing out current subarray\\n        l = 0\\n        r = 1\\n        # number out of this may only create problem\\n        cur_mx = nums[0]\\n        cur_mn = nums[0]\\n        # atleast max_l = 1, bcoz [8] = 8-8 = 0 <= limit\\n        max_l = 1\\n        # since, it is like sliding window ques,\\n        # use while loop with left, right index\\n\\t\\t# with for loop it will be complicated\\n        while l <= r and r < len(nums):\\n            cur_mx = max(cur_mx, nums[r])\\n            cur_mn = min(cur_mn, nums[r])\\n\\n            if cur_mx - cur_mn <= limit:\\n                max_l = max(max_l, r - l + 1)\\n            else:\\n                if nums[l] == cur_mx:\\n                    # need to update cur_mx\\n                    cur_mx = max(nums[l + 1:r + 1])  # inclusive r\\n                # using if & not elif bcoz- nums[l] == cur_mn == cur_mx\\n                if nums[l] == cur_mn:\\n                    # need to update cur_mn\\n                    cur_mn = min(nums[l + 1:r + 1])\\n                l += 1\\n            r += 1\\n        return max_l\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        if not nums:\\n            return 0\\n        if len(nums) == 1:\\n            return 1\\n        # left and right index for tracing out current subarray\\n        l = 0\\n        r = 1\\n        # number out of this may only create problem\\n        cur_mx = nums[0]\\n        cur_mn = nums[0]\\n        # atleast max_l = 1, bcoz [8] = 8-8 = 0 <= limit\\n        max_l = 1\\n        # since, it is like sliding window ques,\\n        # use while loop with left, right index\\n\\t\\t# with for loop it will be complicated\\n        while l <= r and r < len(nums):\\n            cur_mx = max(cur_mx, nums[r])\\n            cur_mn = min(cur_mn, nums[r])\\n\\n            if cur_mx - cur_mn <= limit:\\n                max_l = max(max_l, r - l + 1)\\n            else:\\n                if nums[l] == cur_mx:\\n                    # need to update cur_mx\\n                    cur_mx = max(nums[l + 1:r + 1])  # inclusive r\\n                # using if & not elif bcoz- nums[l] == cur_mn == cur_mx\\n                if nums[l] == cur_mn:\\n                    # need to update cur_mn\\n                    cur_mn = min(nums[l + 1:r + 1])\\n                l += 1\\n            r += 1\\n        return max_l\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 938171,
                "title": "python3-solution-sliding-window-deque-o-n",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        \\n        \"\"\"\\n        use flexible sliding window\\n        use deque to econimically keep track of the min and max of the window\\n        both deques MUST include the newest right element\\n\\t\\tNOTE: both deques contains the index, NOT the element values \\n        deque \"desc\": elements from high to low. If the right element is the max of the window, then desc only contains the right element\\n        deque \"asc\": elements from low to high. if the right is the min of the window, then asc only contains the right element\\n        \\n        every time we move the right index\\n        * we first update the two deques on the new right element\\n        * we then check max - min = desc[0] - asc[0]. if it is bigger than limit, move the left index until it is NOT bigger than the limit\\n        * every time we move the left index, if the left index of desc or asc is lower than left, remove them\\n        \"\"\"\\n        \\n        res = 1\\n        asc, desc = deque([0]), deque([0])\\n        left, right = 0, 0\\n        for right in range(1, len(nums)):\\n            \\n            while asc and nums[asc[-1]] > nums[right]:\\n                asc.pop()\\n            asc.append(right)\\n            \\n            while desc and nums[desc[-1]] < nums[right]:\\n                desc.pop()\\n            desc.append(right)\\n            \\n            print(asc, desc)\\n            \\n            while nums[desc[0]] - nums[asc[0]] > limit:\\n                left += 1\\n                if desc[0] < left:\\n                    desc.popleft()\\n                if asc[0] < left:\\n                    asc.popleft()\\n            \\n            res = max(res, right - left + 1)\\n        \\n        return res\\n\\t\\t```\\n\\t\\t",
                "solutionTags": [
                    "Python3",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        \\n        \"\"\"\\n        use flexible sliding window\\n        use deque to econimically keep track of the min and max of the window\\n        both deques MUST include the newest right element\\n\\t\\tNOTE: both deques contains the index, NOT the element values \\n        deque \"desc\": elements from high to low. If the right element is the max of the window, then desc only contains the right element\\n        deque \"asc\": elements from low to high. if the right is the min of the window, then asc only contains the right element\\n        \\n        every time we move the right index\\n        * we first update the two deques on the new right element\\n        * we then check max - min = desc[0] - asc[0]. if it is bigger than limit, move the left index until it is NOT bigger than the limit\\n        * every time we move the left index, if the left index of desc or asc is lower than left, remove them\\n        \"\"\"\\n        \\n        res = 1\\n        asc, desc = deque([0]), deque([0])\\n        left, right = 0, 0\\n        for right in range(1, len(nums)):\\n            \\n            while asc and nums[asc[-1]] > nums[right]:\\n                asc.pop()\\n            asc.append(right)\\n            \\n            while desc and nums[desc[-1]] < nums[right]:\\n                desc.pop()\\n            desc.append(right)\\n            \\n            print(asc, desc)\\n            \\n            while nums[desc[0]] - nums[asc[0]] > limit:\\n                left += 1\\n                if desc[0] < left:\\n                    desc.popleft()\\n                if asc[0] < left:\\n                    asc.popleft()\\n            \\n            res = max(res, right - left + 1)\\n        \\n        return res\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 623632,
                "title": "javascript-with-explanation-faster-then-75-less-memory-than-100",
                "content": "Ok, simply start at element 1, moving  and checking each new index.  If the new number is between the current min/max, simply increment the current count, else update the min and max and check previous numbers until one falls outside the new range.\\n\\n```\\nvar longestSubarray = function(nums, limit) {\\n    let longest = 1;\\n    let min = nums[0];\\n    let max = nums[0];\\n    let k=1;\\n    for (let i = 1; i < nums.length; i++) {\\n      if (nums[i]>max) {\\n          max = min=nums[i];\\n          min = max - limit;\\n          k=1;\\n          while ((i-k>-1) && nums[i-k]>=max-limit && nums[i-k]<= max) {k++;}\\n      } else if (nums[i]<min) {\\n          min = nums[i];\\n          max = min+limit;\\n          k=1;\\n          while ((i-k>-1) && nums[i-k]<=min+limit && nums[i-k]>=min) {k++;}\\n      } else {\\n          k++;\\n      }\\n    longest = Math.max(k, longest);\\n    }\\n   return longest; \\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestSubarray = function(nums, limit) {\\n    let longest = 1;\\n    let min = nums[0];\\n    let max = nums[0];\\n    let k=1;\\n    for (let i = 1; i < nums.length; i++) {\\n      if (nums[i]>max) {\\n          max = min=nums[i];\\n          min = max - limit;\\n          k=1;\\n          while ((i-k>-1) && nums[i-k]>=max-limit && nums[i-k]<= max) {k++;}\\n      } else if (nums[i]<min) {\\n          min = nums[i];\\n          max = min+limit;\\n          k=1;\\n          while ((i-k>-1) && nums[i-k]<=min+limit && nums[i-k]>=min) {k++;}\\n      } else {\\n          k++;\\n      }\\n    longest = Math.max(k, longest);\\n    }\\n   return longest; \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2042281,
                "title": "o-n-sliding-window-with-queue-javascript-solution-beats-90",
                "content": "![image](https://assets.leetcode.com/users/images/eaa5a984-dd4f-48e2-9c7f-0a446d28da0c_1652631126.674714.png)\\nThis problem is same with other typical sliding windows. But a bit different is it\\'s involved to monotic queue because we need to know what maximum and mininum value at each index position of the array.\\n\\nFor sliding windows we setup start pointer and end pointer, if windows is not valid we will shrink it, in this problem if `max - min of windows > limit` we will shrink our windows\\n```\\n\\tlet start = 0;\\n\\tlet res = 0;\\n\\tfor(let end = 0; end < nums.length; end ++) {\\n\\t\\tif(window is not valid will shrink the window) {\\n\\t\\t\\tstart +=1;\\n\\t\\t}\\n\\t\\tres = Math.max(res, end - start + 1);\\n\\t}\\n```\\n\\nHow we can find the max and min of window, so we need to use maxQueue and minQueue.\\nFor maxQueue it will contain decreasing consecutive number in which first index alwasy is largest one. similar to maxQueue, minQueue contain increasing concecutive number.\\n\\nFor maxQueue and minQueue we can setup like this\\n```\\n\\t\\tconst num = nums[end];\\n\\t\\twhile(maxQueue.length > 0 && maxQueue[maxQueue.length - 1] < num) {\\n\\t\\t\\tmaxQueue.pop();\\n\\t\\t}\\n\\n\\t\\twhile(minQueue.length > 0 && minQueue[minQueue.length - 1] > num) {\\n\\t\\t\\tminQueue.pop();\\n\\t\\t}\\n\\t\\tmaxQueue.push(num);\\n\\t\\tminQueue.push(num);\\n```\\n\\nAbout `maxQueue[0] - minQueue[0] > limit`, it\\'s condition to shrink the window.\\nSomeone might ask why we need to pop first item out of our queue.\\n```\\n\\t\\t\\tif(maxQueue[0] === nums[start]) {\\n                maxQueue.shift();\\n            }\\n            \\n            if(minQueue[0] === nums[start]) {\\n                minQueue.shift();\\n            }\\n```\\n\\nFor example nums = [8,2,4,7], limit = 3\\nand current windows start from 0 to 2 ([8,2,4]) so our maxQueue = [8,4], minQueue[2] it\\'s invalid window because 8 - 2 > 3, we need to shrink the window by moving start pointer to index 1\\nSo the number 8 no longer in our current window therefore we need to pop it out of our queue.\\n\\nAfter combine our slidingwindow and queue one, we can have entire implementation below:\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} limit\\n * @return {number}\\n */\\nvar longestSubarray = function(nums, limit) {\\n    const maxQueue = [];\\n    const minQueue = [];\\n    let start = 0;\\n    let res = 0;\\n    for(let end = 0; end < nums.length; end ++) {\\n        const num = nums[end];\\n        while(maxQueue.length > 0 && maxQueue[maxQueue.length - 1] < num) {\\n            maxQueue.pop();\\n        }\\n        \\n        while(minQueue.length > 0 && minQueue[minQueue.length - 1] > num) {\\n            minQueue.pop();\\n        }\\n        maxQueue.push(num);\\n        minQueue.push(num);\\n        if(maxQueue[0] - minQueue[0] > limit) {\\n            if(maxQueue[0] === nums[start]) {\\n                maxQueue.shift();\\n            }\\n            \\n            if(minQueue[0] === nums[start]) {\\n                minQueue.shift();\\n            }\\n            \\n            start +=1;\\n        }\\n        res = Math.max(res, end - start + 1);\\n    }\\n    \\n    return res;\\n};\\n```\\n\\nTime complexity: O(N)\\nSpace complexity:  since we introduced two queue. O(2 * N) = O(N) so space complexity will be O(N)",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\n\\tlet start = 0;\\n\\tlet res = 0;\\n\\tfor(let end = 0; end < nums.length; end ++) {\\n\\t\\tif(window is not valid will shrink the window) {\\n\\t\\t\\tstart +=1;\\n\\t\\t}\\n\\t\\tres = Math.max(res, end - start + 1);\\n\\t}\\n```\n```\\n\\t\\tconst num = nums[end];\\n\\t\\twhile(maxQueue.length > 0 && maxQueue[maxQueue.length - 1] < num) {\\n\\t\\t\\tmaxQueue.pop();\\n\\t\\t}\\n\\n\\t\\twhile(minQueue.length > 0 && minQueue[minQueue.length - 1] > num) {\\n\\t\\t\\tminQueue.pop();\\n\\t\\t}\\n\\t\\tmaxQueue.push(num);\\n\\t\\tminQueue.push(num);\\n```\n```\\n\\t\\t\\tif(maxQueue[0] === nums[start]) {\\n                maxQueue.shift();\\n            }\\n            \\n            if(minQueue[0] === nums[start]) {\\n                minQueue.shift();\\n            }\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} limit\\n * @return {number}\\n */\\nvar longestSubarray = function(nums, limit) {\\n    const maxQueue = [];\\n    const minQueue = [];\\n    let start = 0;\\n    let res = 0;\\n    for(let end = 0; end < nums.length; end ++) {\\n        const num = nums[end];\\n        while(maxQueue.length > 0 && maxQueue[maxQueue.length - 1] < num) {\\n            maxQueue.pop();\\n        }\\n        \\n        while(minQueue.length > 0 && minQueue[minQueue.length - 1] > num) {\\n            minQueue.pop();\\n        }\\n        maxQueue.push(num);\\n        minQueue.push(num);\\n        if(maxQueue[0] - minQueue[0] > limit) {\\n            if(maxQueue[0] === nums[start]) {\\n                maxQueue.shift();\\n            }\\n            \\n            if(minQueue[0] === nums[start]) {\\n                minQueue.shift();\\n            }\\n            \\n            start +=1;\\n        }\\n        res = Math.max(res, end - start + 1);\\n    }\\n    \\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1676610,
                "title": "python-o-n-sliding-window-with-2-monotonic-deques-solution-explanation-included",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # O(n) sliding window approach with two monotonic deques.\\n        # It is O(n) because we only ever push/pop an element once into the deques.\\n        # We use two monotonic deques because we want to keep track of the\\n        # min and max of our sliding window since that information is all\\n        # that is needed to calculate whether the limit is satisfied.\\n        # The monotonic property allows us to efficiently adjust the\\n        # left bound of the window.\\n\\n        # we will maintain a monotonic deque for both max and min values\\n        # containing the value and the index of the value\\n        min_dq = deque()\\n        max_dq = deque()\\n\\n        # start is the index of the start of the current sliding window\\n        start = 0\\n        max_len = 0\\n\\n        for i in range(len(nums)):\\n            # the only times we need to adjust start is if the difference between\\n            # our new element and the prev max/min in window exceeds limit.\\n            # when that happens, the start index of window must be adjusted\\n\\n            while min_dq and abs(nums[i] - min_dq[0][0]) > limit:\\n                start = min_dq.popleft()[1] + 1\\n\\n            while max_dq and abs(nums[i] - max_dq[0][0]) > limit:\\n                # take the max of the start value because\\n                # we want the narrowest valid range for new window\\n                # and the start when popping off min_dq above might have been later\\n                start = max(start, max_dq.popleft()[1] + 1)\\n\\n            # insert the element into the monotonic deques.\\n            # inclusive comparisons (>=, <=) because we only care about\\n            # the latest index of the given value when narrowing the bounds.\\n            while min_dq and min_dq[-1][0] >= nums[i]:\\n                min_dq.pop()\\n            min_dq.append([nums[i], i])\\n\\n            while max_dq and max_dq[-1][0] <= nums[i]:\\n                max_dq.pop()\\n            max_dq.append([nums[i], i])\\n\\n            # calculate and compare new length of window containing element i\\n            max_len = max(max_len, i - start + 1)\\n\\n        return max_len\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window",
                    "Monotonic Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # O(n) sliding window approach with two monotonic deques.\\n        # It is O(n) because we only ever push/pop an element once into the deques.\\n        # We use two monotonic deques because we want to keep track of the\\n        # min and max of our sliding window since that information is all\\n        # that is needed to calculate whether the limit is satisfied.\\n        # The monotonic property allows us to efficiently adjust the\\n        # left bound of the window.\\n\\n        # we will maintain a monotonic deque for both max and min values\\n        # containing the value and the index of the value\\n        min_dq = deque()\\n        max_dq = deque()\\n\\n        # start is the index of the start of the current sliding window\\n        start = 0\\n        max_len = 0\\n\\n        for i in range(len(nums)):\\n            # the only times we need to adjust start is if the difference between\\n            # our new element and the prev max/min in window exceeds limit.\\n            # when that happens, the start index of window must be adjusted\\n\\n            while min_dq and abs(nums[i] - min_dq[0][0]) > limit:\\n                start = min_dq.popleft()[1] + 1\\n\\n            while max_dq and abs(nums[i] - max_dq[0][0]) > limit:\\n                # take the max of the start value because\\n                # we want the narrowest valid range for new window\\n                # and the start when popping off min_dq above might have been later\\n                start = max(start, max_dq.popleft()[1] + 1)\\n\\n            # insert the element into the monotonic deques.\\n            # inclusive comparisons (>=, <=) because we only care about\\n            # the latest index of the given value when narrowing the bounds.\\n            while min_dq and min_dq[-1][0] >= nums[i]:\\n                min_dq.pop()\\n            min_dq.append([nums[i], i])\\n\\n            while max_dq and max_dq[-1][0] <= nums[i]:\\n                max_dq.pop()\\n            max_dq.append([nums[i], i])\\n\\n            # calculate and compare new length of window containing element i\\n            max_len = max(max_len, i - start + 1)\\n\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1003813,
                "title": "javascript-deque-solution-with-explanation",
                "content": "Note: this solution uses Javascript arrays which means insert/delete options will be O(n), resulting in an overall time complexity of O(n^2). However, by using a library such as Collections.js, you will have a similar API with O(1) insertion/deletion to the beginning and the end of the deques.\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} limit\\n * @return {number}\\n */\\nvar longestSubarray = function (nums, limit = 10) {\\n  let minDeque = []\\n  let maxDeque = []\\n  let max = 1;\\n  let l = 0;\\n\\n  for (let h = 0; h < nums.length; h++) {\\n    // add new h to min and max deques\\n    // remove all elements that are greater than nums[h]\\n    while (minDeque[minDeque.length - 1] > nums[h]) {\\n      minDeque.pop()\\n    }\\n    minDeque.push(nums[h])\\n    // remove all elements that are lower than nums[h]\\n    while (maxDeque[maxDeque.length - 1] < nums[h]) {\\n      maxDeque.pop()\\n    }\\n    maxDeque.push(nums[h])\\n\\n    if (maxDeque[0] - minDeque[0] > limit) {\\n      // increase l by 1\\n      while (maxDeque[0] - minDeque[0] > limit) {\\n        // update min and max queues\\n        minDeque[0] === nums[l] && minDeque.shift() \\n        maxDeque[0] === nums[l] && maxDeque.shift() \\n        l++\\n      }\\n    }\\n\\n    max = Math.max(h - l + 1, max);\\n  }\\n\\n  return max;\\n};\\n```\\n\\nExplanation:\\nThe structure of the problem is a classic sliding window question. We want to maintain a sliding window `[l,h]`, which moves through the `nums` array, and want to check that the `max - min` in the window satisfies the limit constraint. If so, then the longest subarray length can be updated to `h - l + 1` given that it\\'s the new longest subarray.\\n\\nThe tricky part of the question lies in how to store the max and min per window. If we were to derive the max and min in each subarray per iteration, that would be an O(n) operation, so we need to do this in a more clever way.\\n\\nWe can turn getting the max/min of the subarray into an O(1) operation by storing the potential candidates for the max and mins of the subarrays into two deques (double-ended queue).\\n\\n* `maxDeque` - stores candidates to be max of sliding window. This deque is in monotonically decreasing order. `maxDeque[0]` is the max of the current window\\n* `minDeque` - stores candidates to be min of sliding window. This deque is in monotonically increasing order. `minDeque[0]` is the min of the current window\\n\\nConsider the input array `[4, 10, 3, 20, 4]` with a limit of 10.\\n\\n1. The sliding window starts off with `[4]`. So we push 4 into the min and max deques.\\n    minDeque: [4]\\n    maxDeque: [4]\\n\\n2. Next, the sliding window becomes `[4, 10]`. Before we push 10 into the min and max deques, we pop out all elements that don\\'t satisfy the constraints. In the min deque, this would be any value that is greater than 10. In the max queue, this would be any value that is less than 10. What this is essentially doing is saying 10 is a potential min candidate now (if we slide `l` up and the window becomes `[10]`. We\\'re also removing the 4 from `maxDeque` as 4 can no longer be a max candidate, since we already have a 10 to its right.\\n    minDeque: [4, 10]\\n\\tmaxDeque: [10]\\n\\n3. Continue for sliding window = `[4, 10, 3]`. Notice how 4 is no longer in any of the deques and it doesn\\'t matter, since it will neither be a min nor a max with 10 and 3 to its right.\\n    minDeque: [3]\\n\\tmaxDeque: [10, 3]\\n\\t\\n4. Continue until the end...updating the maximum length on each iteration.",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} limit\\n * @return {number}\\n */\\nvar longestSubarray = function (nums, limit = 10) {\\n  let minDeque = []\\n  let maxDeque = []\\n  let max = 1;\\n  let l = 0;\\n\\n  for (let h = 0; h < nums.length; h++) {\\n    // add new h to min and max deques\\n    // remove all elements that are greater than nums[h]\\n    while (minDeque[minDeque.length - 1] > nums[h]) {\\n      minDeque.pop()\\n    }\\n    minDeque.push(nums[h])\\n    // remove all elements that are lower than nums[h]\\n    while (maxDeque[maxDeque.length - 1] < nums[h]) {\\n      maxDeque.pop()\\n    }\\n    maxDeque.push(nums[h])\\n\\n    if (maxDeque[0] - minDeque[0] > limit) {\\n      // increase l by 1\\n      while (maxDeque[0] - minDeque[0] > limit) {\\n        // update min and max queues\\n        minDeque[0] === nums[l] && minDeque.shift() \\n        maxDeque[0] === nums[l] && maxDeque.shift() \\n        l++\\n      }\\n    }\\n\\n    max = Math.max(h - l + 1, max);\\n  }\\n\\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 870105,
                "title": "c-using-linkedlist-as-dequeue",
                "content": "```\\npublic class Solution {\\n    public int LongestSubarray(int[] nums, int limit) {\\n        LinkedList<int> minq = new LinkedList<int>();\\n        LinkedList<int> maxq = new LinkedList<int>();\\n        \\n        int l =0, r=0;\\n        \\n        int max = 0;\\n        while(r<nums.Length)\\n        {\\n            while(maxq.Count>0 && maxq.Last.Value<nums[r]){\\n                maxq.RemoveLast();\\n            }\\n            \\n            maxq.AddLast(nums[r]);\\n            \\n            while(minq.Count>0 && minq.Last.Value > nums[r]){\\n                minq.RemoveLast();\\n            }\\n            \\n            minq.AddLast(nums[r]);\\n            \\n            while(maxq.First.Value-minq.First.Value>limit)\\n            {\\n                if(minq.First.Value == nums[l]) minq.RemoveFirst();\\n                if(maxq.First.Value == nums[l]) maxq.RemoveFirst();\\n                l++;\\n            }\\n            \\n            max = Math.Max(max,r-l+1);\\n            r++;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LongestSubarray(int[] nums, int limit) {\\n        LinkedList<int> minq = new LinkedList<int>();\\n        LinkedList<int> maxq = new LinkedList<int>();\\n        \\n        int l =0, r=0;\\n        \\n        int max = 0;\\n        while(r<nums.Length)\\n        {\\n            while(maxq.Count>0 && maxq.Last.Value<nums[r]){\\n                maxq.RemoveLast();\\n            }\\n            \\n            maxq.AddLast(nums[r]);\\n            \\n            while(minq.Count>0 && minq.Last.Value > nums[r]){\\n                minq.RemoveLast();\\n            }\\n            \\n            minq.AddLast(nums[r]);\\n            \\n            while(maxq.First.Value-minq.First.Value>limit)\\n            {\\n                if(minq.First.Value == nums[l]) minq.RemoveFirst();\\n                if(maxq.First.Value == nums[l]) maxq.RemoveFirst();\\n                l++;\\n            }\\n            \\n            max = Math.Max(max,r-l+1);\\n            r++;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 730176,
                "title": "c-o-n-solution",
                "content": "For current range [left, right], the idea is to maintain two deques such that front element in both queues represent maximum and minimum element in the range respectively.\\n\\n```\\nint longestSubarray(vector<int>& nums, int limit) {\\n        int n=nums.size(), left=0, right=0, ans=0;\\n        deque<int> mi, mx;\\n        while(right<n){\\n            while(!mx.empty() && nums[mx.back()]<=nums[right])\\n                mx.pop_back();\\n            mx.push_back(right);\\n            while(!mi.empty() && nums[mi.back()]>=nums[right])\\n                mi.pop_back();\\n            mi.push_back(right);\\n            while(!mx.empty() && !mi.empty() && nums[mx.front()]-nums[mi.front()]>limit){\\n                left++;\\n                while(!mx.empty() && mx.front()<left)\\n                    mx.pop_front();\\n                while(!mi.empty() && mi.front()<left)\\n                    mi.pop_front();\\n            }\\n            ans=max(ans, right-left+1);\\n            right++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nint longestSubarray(vector<int>& nums, int limit) {\\n        int n=nums.size(), left=0, right=0, ans=0;\\n        deque<int> mi, mx;\\n        while(right<n){\\n            while(!mx.empty() && nums[mx.back()]<=nums[right])\\n                mx.pop_back();\\n            mx.push_back(right);\\n            while(!mi.empty() && nums[mi.back()]>=nums[right])\\n                mi.pop_back();\\n            mi.push_back(right);\\n            while(!mx.empty() && !mi.empty() && nums[mx.front()]-nums[mi.front()]>limit){\\n                left++;\\n                while(!mx.empty() && mx.front()<left)\\n                    mx.pop_front();\\n                while(!mi.empty() && mi.front()<left)\\n                    mi.pop_front();\\n            }\\n            ans=max(ans, right-left+1);\\n            right++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 697531,
                "title": "java-with-no-queues-and-no-extra-space-and-with-2-queues",
                "content": "Adding 2 solutions with their running times. Complexity of both is linear.\\n\\n1. Using 2 queues. Running time 22 ms.\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        ArrayDeque<Integer> increasing = new ArrayDeque<>();\\n        ArrayDeque<Integer> decreasing = new ArrayDeque<>();\\n        int result = 0;\\n        int startPos = 0;\\n        \\n        for (int i=0 ; i<nums.length ; ++i) {\\n            while (!increasing.isEmpty() && nums[increasing.getLast()] > nums[i]) {\\n                increasing.removeLast();\\n            }\\n            increasing.addLast(i);\\n            while (!decreasing.isEmpty() && nums[decreasing.getLast()] < nums[i]) {\\n                decreasing.removeLast();\\n            }\\n            decreasing.addLast(i);\\n            \\n            while (nums[decreasing.getFirst()] - nums[increasing.getFirst()] > limit) {\\n                if (decreasing.getFirst() < increasing.getFirst()) {\\n                    startPos = decreasing.removeFirst() + 1;\\n                } else {\\n                    startPos = increasing.removeFirst() + 1;\\n                }\\n            }\\n            result = Math.max(result, i-startPos+1);\\n        }\\n        return result;\\n    }\\n}\\n```\\n\\n2. Without queues. Running time 26ms.\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int left = 0;\\n        int right = 0;\\n        int min = nums[0];\\n        int max = nums[0];\\n        int minPos = 0;\\n        int maxPos = 0;\\n        int len = 1; // len can never be zero if we have atleast one element in nums[] because limit >= 0\\n        \\n        while (++right < nums.length) {\\n            if (nums[right] >= max) {\\n                max = nums[right];\\n                maxPos = right;\\n                \\n                if (max - min > limit) {\\n                    // find new min\\n                    int i = right - 1;\\n                    min = Integer.MAX_VALUE;\\n                    while (i > left && max - nums[i] <= limit) {\\n                        if (nums[i] < min) {\\n                            minPos = i;\\n                            min = nums[i];\\n                        }\\n                        i--;\\n                    }\\n                    left = i+1;\\n                    if (min == Integer.MAX_VALUE) {\\n                        min = nums[left];\\n                        minPos = left;\\n                    }\\n                }\\n            }\\n            if (nums[right] <= min) {\\n                min = nums[right];\\n                minPos = right;\\n                \\n                if (max - min > limit) {\\n                    // find new max\\n                    int i = right - 1;\\n                    max = Integer.MIN_VALUE;\\n                    while (i > left && nums[i] - min <= limit) {\\n                        if (nums[i] > max) {\\n                            maxPos = i;\\n                            max = nums[i];\\n                        }\\n                        i--;\\n                    }\\n                    left = i+1;\\n                    if (max == Integer.MIN_VALUE) {\\n                        max = nums[left];\\n                        maxPos = left;\\n                    }\\n                }\\n            }\\n            len = Math.max(len, right-left+1);\\n        }\\n        return len;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        ArrayDeque<Integer> increasing = new ArrayDeque<>();\\n        ArrayDeque<Integer> decreasing = new ArrayDeque<>();\\n        int result = 0;\\n        int startPos = 0;\\n        \\n        for (int i=0 ; i<nums.length ; ++i) {\\n            while (!increasing.isEmpty() && nums[increasing.getLast()] > nums[i]) {\\n                increasing.removeLast();\\n            }\\n            increasing.addLast(i);\\n            while (!decreasing.isEmpty() && nums[decreasing.getLast()] < nums[i]) {\\n                decreasing.removeLast();\\n            }\\n            decreasing.addLast(i);\\n            \\n            while (nums[decreasing.getFirst()] - nums[increasing.getFirst()] > limit) {\\n                if (decreasing.getFirst() < increasing.getFirst()) {\\n                    startPos = decreasing.removeFirst() + 1;\\n                } else {\\n                    startPos = increasing.removeFirst() + 1;\\n                }\\n            }\\n            result = Math.max(result, i-startPos+1);\\n        }\\n        return result;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int left = 0;\\n        int right = 0;\\n        int min = nums[0];\\n        int max = nums[0];\\n        int minPos = 0;\\n        int maxPos = 0;\\n        int len = 1; // len can never be zero if we have atleast one element in nums[] because limit >= 0\\n        \\n        while (++right < nums.length) {\\n            if (nums[right] >= max) {\\n                max = nums[right];\\n                maxPos = right;\\n                \\n                if (max - min > limit) {\\n                    // find new min\\n                    int i = right - 1;\\n                    min = Integer.MAX_VALUE;\\n                    while (i > left && max - nums[i] <= limit) {\\n                        if (nums[i] < min) {\\n                            minPos = i;\\n                            min = nums[i];\\n                        }\\n                        i--;\\n                    }\\n                    left = i+1;\\n                    if (min == Integer.MAX_VALUE) {\\n                        min = nums[left];\\n                        minPos = left;\\n                    }\\n                }\\n            }\\n            if (nums[right] <= min) {\\n                min = nums[right];\\n                minPos = right;\\n                \\n                if (max - min > limit) {\\n                    // find new max\\n                    int i = right - 1;\\n                    max = Integer.MIN_VALUE;\\n                    while (i > left && nums[i] - min <= limit) {\\n                        if (nums[i] > max) {\\n                            maxPos = i;\\n                            max = nums[i];\\n                        }\\n                        i--;\\n                    }\\n                    left = i+1;\\n                    if (max == Integer.MIN_VALUE) {\\n                        max = nums[left];\\n                        maxPos = left;\\n                    }\\n                }\\n            }\\n            len = Math.max(len, right-left+1);\\n        }\\n        return len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 611863,
                "title": "c-monotonic-queue-to-maintain-min-and-max-then-sliding-window",
                "content": "```\\n#include <cassert>\\n#include <deque>\\n\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        assert(limit >= 0);\\n        std::size_t longest = 1;\\n        std::deque<std::size_t> maxDeque;\\n        std::deque<std::size_t> minDeque;\\n        for (std::size_t left = 0, right = 0; right < nums.size(); ++right) {\\n            while (!maxDeque.empty() and nums[maxDeque.back()] <= nums[right]) {\\n                maxDeque.pop_back();\\n            }\\n            maxDeque.push_back(right);\\n\\n            while (!minDeque.empty() and nums[minDeque.back()] >= nums[right]) {\\n                minDeque.pop_back();\\n            }\\n            minDeque.push_back(right);\\n\\n            while (nums[maxDeque.front()] - nums[minDeque.front()] > limit) {\\n                if (left == maxDeque.front()) {\\n                    maxDeque.pop_front();\\n                }\\n                if (left == minDeque.front()) {\\n                    minDeque.pop_front();\\n                }\\n                ++left;\\n            }\\n            longest = std::max(longest, right - left  + 1);\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#include <cassert>\\n#include <deque>\\n\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        assert(limit >= 0);\\n        std::size_t longest = 1;\\n        std::deque<std::size_t> maxDeque;\\n        std::deque<std::size_t> minDeque;\\n        for (std::size_t left = 0, right = 0; right < nums.size(); ++right) {\\n            while (!maxDeque.empty() and nums[maxDeque.back()] <= nums[right]) {\\n                maxDeque.pop_back();\\n            }\\n            maxDeque.push_back(right);\\n\\n            while (!minDeque.empty() and nums[minDeque.back()] >= nums[right]) {\\n                minDeque.pop_back();\\n            }\\n            minDeque.push_back(right);\\n\\n            while (nums[maxDeque.front()] - nums[minDeque.front()] > limit) {\\n                if (left == maxDeque.front()) {\\n                    maxDeque.pop_front();\\n                }\\n                if (left == minDeque.front()) {\\n                    minDeque.pop_front();\\n                }\\n                ++left;\\n            }\\n            longest = std::max(longest, right - left  + 1);\\n        }\\n        return longest;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 611269,
                "title": "extra-explanation-of-the-returned-value-in-the-sliding-window-approach",
                "content": "Note, to explain various options, parts of the code are redundant. If you have better way to explain it,  you are welcome to coment.\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& A, int limit) {\\n        int i = 0, j;\\n        multiset<int> m;\\n        int ans = 0;\\n        for (j = 0; j < A.size(); ++j) {\\n            m.insert(A[j]);\\n            if (*m.rbegin() - *m.begin() > limit) //If exceed limit, ONLY erase the earliest item, one only\\n                m.erase(m.find(A[i++]));\\n            ans = max(ans, j - i + 1); //Easy to explain, update the flood peak infomation, the high point of a flood\\n        }\\n        //for(auto i: m) cout<<i<< \" \"; cout<<endl; //debug: check what is really inside\\n        //return A.size() - i; // ok, but confusing and hard to explain\\n        //return j - i;        // ok, but confusing and hard to explain\\n        //return m.size();     // ok, but confusing and hard to explain\\n        return ans;  \\n    }\\n};\\n//Example: nums=[8,1,1,1,1,100,200,300], limit= 0\\n//After for-loop, m contain: {1, 100, 200, 300}! Surprise?! \"\\u9E20\\u5360\\u9E4A\\u5DE2\" (A cuckoo takes over the nest of a magpie)\\n//Why? The size of m is non-decreasing due to the following never-shrinking mechanism inside the for-loop:\\n//always insert one new item into m, but at most erase one item from m (the earliest item)\\n//So, you can safely return the size of m as Holy Grail.\\n```\\n\\nRerference:\\nhttps://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC%2B%2BPython-Deques-O(N)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& A, int limit) {\\n        int i = 0, j;\\n        multiset<int> m;\\n        int ans = 0;\\n        for (j = 0; j < A.size(); ++j) {\\n            m.insert(A[j]);\\n            if (*m.rbegin() - *m.begin() > limit) //If exceed limit, ONLY erase the earliest item, one only\\n                m.erase(m.find(A[i++]));\\n            ans = max(ans, j - i + 1); //Easy to explain, update the flood peak infomation, the high point of a flood\\n        }\\n        //for(auto i: m) cout<<i<< \" \"; cout<<endl; //debug: check what is really inside\\n        //return A.size() - i; // ok, but confusing and hard to explain\\n        //return j - i;        // ok, but confusing and hard to explain\\n        //return m.size();     // ok, but confusing and hard to explain\\n        return ans;  \\n    }\\n};\\n//Example: nums=[8,1,1,1,1,100,200,300], limit= 0\\n//After for-loop, m contain: {1, 100, 200, 300}! Surprise?! \"\\u9E20\\u5360\\u9E4A\\u5DE2\" (A cuckoo takes over the nest of a magpie)\\n//Why? The size of m is non-decreasing due to the following never-shrinking mechanism inside the for-loop:\\n//always insert one new item into m, but at most erase one item from m (the earliest item)\\n//So, you can safely return the size of m as Holy Grail.\\n```",
                "codeTag": "C++"
            },
            {
                "id": 610880,
                "title": "java-o-nlogn-treemap-solution-use-two-pointers",
                "content": "Use TreeMap to store numbers in order. The key is the number and the value is the count of number.\\n\\nif(lastKey - firstKey <= limit), we just simply move the right pointer to the next and calculate the right-left+1. Otherwise if lastKey - fitstKey is greater than limit. We move left pointer to the next. Before that we need to minus the count of current nums[left] in TreeMap, if the count equals 0 (means there is no same number between left and right) then we remove the nums[left] in TreeMap.\\n\\n```\\n    public int longestSubarray(int[] nums, int limit) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int res = 1, left = 0;\\n        for(int right = 0; right < nums.length; right++) {\\n            map.put(nums[right], map.getOrDefault(nums[right], 0) + 1);\\n            while(map.lastKey() - map.firstKey() > limit) {\\n                map.put(nums[left], map.get(nums[left]) - 1);\\n                if(map.get(nums[left]) == 0)\\n                    map.remove(nums[left]);\\n                left++;\\n            }\\n            res = Math.max(res, right-left+1);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestSubarray(int[] nums, int limit) {\\n        TreeMap<Integer, Integer> map = new TreeMap<>();\\n        int res = 1, left = 0;\\n        for(int right = 0; right < nums.length; right++) {\\n            map.put(nums[right], map.getOrDefault(nums[right], 0) + 1);\\n            while(map.lastKey() - map.firstKey() > limit) {\\n                map.put(nums[left], map.get(nums[left]) - 1);\\n                if(map.get(nums[left]) == 0)\\n                    map.remove(nums[left]);\\n                left++;\\n            }\\n            res = Math.max(res, right-left+1);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3598036,
                "title": "brute-force-two-heaps-treemap-monotonic-queue-should-be-well-explained",
                "content": "# Approach 1: Brute Force\\nIn this approach, what I do is just create a max heap and a min heap for every number in the list and use nested for loop to find the valid \"window \"for every number and return the max one. \\n\\n# Complexity\\n- Time complexity:\\n$n^2log(n)$ because when pushing element to each heap, I need $log(n)$ time.  \\n\\n- Space complexity:\\n$O(n)$ to store numbers in two heaps.  \\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # most instinct method\\n        max_length = 1\\n        for i in range(len(nums)):\\n            max_hq = [-nums[i]] # heapq in which the max is at the beginning\\n            min_hq = [nums[i]] # heapq in which the min is at the beginning\\n            \\n            for j in range(i + 1, len(nums)):\\n                # find max and min for every window and compare until the window is no longer valid\\n                if abs(-max_hq[0] - nums[j]) <= limit and abs(min_hq[0] - nums[j]) <= limit:\\n                    heapq.heappush(max_hq, -nums[j])\\n                    heapq.heappush(min_hq, nums[j])\\n                else:\\n                    break # break when the window is no longer valid\\n                max_length = max(len(max_hq), max_length)\\n        return max_length\\n```\\n\\n# Approach 2: Two Heaps\\nDifferent to the brute force approach, this one is better in that we only have one \"window\" in the whole process. We only manipulate the left and right index of the window.   \\n\\nWhat we did differently is that we try to slide the window forward while keeping numbers in the window is valid.  \\n\\n# Complexity\\n- Time complexity:\\n$nlog(n)$ because when pushing element to each heap, I need $log(n)$ time and every element can only be pushed to the heap once.  \\n\\n- Space complexity:\\n$O(n)$ to store numbers in two heaps.  \\n\\n# Code\\n```\\nimport heapq\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # most instinct method\\n        max_length = 1\\n        left = 0 # We want to have a sliding window so that we can know the length of the window (i.e. the possible solution, thus we named the start of the window \"left\")\\n        min_heap = [] # named min_heap because this heap\\'s purpose is to find the minimum\\n        max_heap = [] # named max_heap because this heap\\'s purpose is to find the maximum\\n        for right in range(len(nums)): # \"right\" is the right end of the window\\n            # first of all, we push the [right] element to both the min_heap and the max_heap\\n            # because we need to first \"slide\" the window \\n            # we also need the index information because we need to make sure our min and max is valid while we are sliding the window\\n            heapq.heappush(min_heap, (nums[right], right))\\n            heapq.heappush(max_heap, (-nums[right], right))\\n\\n            # in this step, we need to retrieve the minimum element and the maximum element in the window range, \\n            # therefore, we need to make sure the maximum and the minimum are within window range (i.e. left <= index <= right)\\n            # thus we need to pop the minheap until we find the smallest element which is in the window\\n            # we also need to pop the maxheap until we find the largest element which is in the window\\n            while min_heap[0][1] < left:\\n                heapq.heappop(min_heap)\\n            while max_heap[0][1] < left:\\n                heapq.heappop(max_heap)\\n\\n            # We find the minimum and the maximum in the window, we can check whether the window is valid or not\\n            if -max_heap[0][0] - min_heap[0][0] <= limit:\\n                # if it\\'s valid, we can update the answer\\n                max_length = max(max_length, right - left + 1)\\n            else:\\n                # else we just move the left end of the window\\n                left += 1\\n        return max_length\\n                \\n            \\n        \\n```\\n\\n# Approach 3: Treemap\\nIn this approach, we still need to use the sliding window method, the difference between this method and the two heaps is that in this method, we keep the frequency of num in a treemap in order to retrieve the maximum and the minimum in the window.  \\n\\nI think the most important part of solving a problem is to find the train of thought. As a matter of fact, this method is actually along the same direction with the two heaps method. In other words, you need to first set the left and right end of the window and then check if the maximum and the minimum in this window conform with the requirements. \\u201CSeek common points while reserving difference\\u201D. \\n\\n# Complexity\\n- Time complexity: $O(nlogn)$ because of the operations of treemap. \\n- Space complexity: $O(n)$ to create the treemap. \\n\\n# Code \\n```\\nimport sortedcontainers\\nfrom sortedcontainers import SortedDict\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int: \\n        left = 0 # Set up the left end of the window\\n        num_to_freq = SortedDict() # Python version of treemap\\n        max_length = 1\\n        for right in range(len(nums)):\\n            if nums[right] not in num_to_freq:\\n                num_to_freq[nums[right]] = 0\\n            num_to_freq[nums[right]] += 1 # if the right end of the window is not in the treemap, add it to the treemap\\n            while num_to_freq.peekitem(index=-1)[0] - num_to_freq.peekitem(index=0)[0] > limit: \\n                # Check if the maximum and the minimum conform the requirement\\n                # If it\\'s not, we pop the number at index left and update the left index. \\n                # Remember we cannot retrieve the frequency of start of the window and then minus the frequency \\n                # because we need to make sure our window is consecutive. It\\'s necessary to pop one item each time. \\n                # If you are still confused, think about this case: [2,2,2,4,4,2,5,5,5,5,5,2]\\n                num_to_freq[nums[left]] -= 1 \\n                if num_to_freq[nums[left]] == 0:\\n                    num_to_freq.pop(nums[left])\\n                left += 1\\n                \\n            max_length = max(max_length, right - left + 1) # if the maximum and the minimum conform the requirement, we update our result\\n        return max_length\\n```\\n\\n# Approach 4: Two Monotonic Queue\\nWe followed the same directions as the solutions before: we need to maintain a window and try to find the index of the valid maximum and the minimum within the window.  \\n\\nThe difference is that we used two monotonic array to find the maximum and the minimum, which is different from the previous two cases, in which the built-in data structures find the max and the min for us, we need to maintain the monotonic array ourselves.  \\n\\n# Complexity\\n- Time Complexity: O(N), for each elements in the array, we only need to add and pop one time per element.  \\n- Space Complexity: O(N), we need to create two deques to store the two monotonic arrays.  \\n\\n# Code\\n```\\nimport collections\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        left = 0\\n        max_length = 1\\n        n = len(nums)\\n        # We defined the two monotonic array here, we named the increasing array \"increasing_q\" and the decreasing array \"decreasing_q\"\\n        increasing_q = collections.deque()\\n        decreasing_q = collections.deque() \\n        # Start sliding -_- ...\\n        for right in range(n):\\n            # remember we should always try to insert the value into the last of the monotonic arrays\\n            # For increasing_q, we need to check whether the last value of the monotonic array is larger than the right end of the window. If it is, then we need to pop the value until we find the one which is smaller than the right end of the window and insert the right end of the window at the last of the increasing monotonic array. \\n            # You cannot put the increasing_q[-1] >= nums[right] here because the limit might be 0 and in this case, we need to count the number of equal value.\\n            while increasing_q and increasing_q[-1] > nums[right]:\\n                increasing_q.pop()\\n            increasing_q.append(nums[right])\\n\\n            # For decreasing_q, we need to check whether the last value of the monotonic array is smaller than the right end of the window. If it is, then we need to pop the value until we find the one which is larger than the right end of the window and insert the right end of the window at the last of the decreasing monotonic array. \\n            # You cannot put the decreasing_q[-1] <= nums[right] here because the limit might be 0 and in this case, we need to count the number of equal value.\\n            while decreasing_q and decreasing_q[-1] < nums[right]:\\n                decreasing_q.pop()\\n            decreasing_q.append(nums[right])\\n\\n            # we need to check if the difference of the max and min in the current window is bigger than the limit or not, if it is, we need to do something and update our window. \\n            while decreasing_q[0] - increasing_q[0] > limit:\\n                # For decreasing_q, there are 3(actually I think there are only 2) cases here: \\n                    # nums[left] is greater than decreasing_q[0], then it must have been popped before\\n                    # nums[left] == decreasing_q[0], then pop it here\\n                    # nums[left] is smaller than decreasing_q[0](which I think is impossible because we should always pop the bigger ones first to get the smaller ones so we haven\\'t reached those nums which are smaller than decreasing_q[0] yet.) \\n                if decreasing_q[0] == nums[left]:\\n                    decreasing_q.popleft()\\n                # For increasing_q, there are 3(actually I think there are only 2) cases here: \\n                    # nums[left] is smaller than increasing_q[0], then it must have been popped before\\n                    # nums[left] == increasing_q[0], then pop it here\\n                    # nums[left] is greater than increasing_q[0](which I think is impossible because we should always pop the smaller ones first to get the bigger ones so we haven\\'t reached those nums which are bigger than increasing_q[0] yet.) \\n                if increasing_q[0] == nums[left]:\\n                    increasing_q.popleft()\\n                \\n                # We need to update the left here to forward our window so that it is more likely to be valid\\n                left += 1\\n            # window is valid \\uD83D\\uDE0A, update the max_length here.  \\n            max_length = max(max_length, right - left + 1)\\n        return max_length\\n        \\n```\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Ordered Map",
                    "Heap (Priority Queue)",
                    "Ordered Set",
                    "Monotonic Queue"
                ],
                "code": "```\\nimport heapq\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # most instinct method\\n        max_length = 1\\n        for i in range(len(nums)):\\n            max_hq = [-nums[i]] # heapq in which the max is at the beginning\\n            min_hq = [nums[i]] # heapq in which the min is at the beginning\\n            \\n            for j in range(i + 1, len(nums)):\\n                # find max and min for every window and compare until the window is no longer valid\\n                if abs(-max_hq[0] - nums[j]) <= limit and abs(min_hq[0] - nums[j]) <= limit:\\n                    heapq.heappush(max_hq, -nums[j])\\n                    heapq.heappush(min_hq, nums[j])\\n                else:\\n                    break # break when the window is no longer valid\\n                max_length = max(len(max_hq), max_length)\\n        return max_length\\n```\n```\\nimport heapq\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # most instinct method\\n        max_length = 1\\n        left = 0 # We want to have a sliding window so that we can know the length of the window (i.e. the possible solution, thus we named the start of the window \"left\")\\n        min_heap = [] # named min_heap because this heap\\'s purpose is to find the minimum\\n        max_heap = [] # named max_heap because this heap\\'s purpose is to find the maximum\\n        for right in range(len(nums)): # \"right\" is the right end of the window\\n            # first of all, we push the [right] element to both the min_heap and the max_heap\\n            # because we need to first \"slide\" the window \\n            # we also need the index information because we need to make sure our min and max is valid while we are sliding the window\\n            heapq.heappush(min_heap, (nums[right], right))\\n            heapq.heappush(max_heap, (-nums[right], right))\\n\\n            # in this step, we need to retrieve the minimum element and the maximum element in the window range, \\n            # therefore, we need to make sure the maximum and the minimum are within window range (i.e. left <= index <= right)\\n            # thus we need to pop the minheap until we find the smallest element which is in the window\\n            # we also need to pop the maxheap until we find the largest element which is in the window\\n            while min_heap[0][1] < left:\\n                heapq.heappop(min_heap)\\n            while max_heap[0][1] < left:\\n                heapq.heappop(max_heap)\\n\\n            # We find the minimum and the maximum in the window, we can check whether the window is valid or not\\n            if -max_heap[0][0] - min_heap[0][0] <= limit:\\n                # if it\\'s valid, we can update the answer\\n                max_length = max(max_length, right - left + 1)\\n            else:\\n                # else we just move the left end of the window\\n                left += 1\\n        return max_length\\n                \\n            \\n        \\n```\n```\\nimport sortedcontainers\\nfrom sortedcontainers import SortedDict\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int: \\n        left = 0 # Set up the left end of the window\\n        num_to_freq = SortedDict() # Python version of treemap\\n        max_length = 1\\n        for right in range(len(nums)):\\n            if nums[right] not in num_to_freq:\\n                num_to_freq[nums[right]] = 0\\n            num_to_freq[nums[right]] += 1 # if the right end of the window is not in the treemap, add it to the treemap\\n            while num_to_freq.peekitem(index=-1)[0] - num_to_freq.peekitem(index=0)[0] > limit: \\n                # Check if the maximum and the minimum conform the requirement\\n                # If it\\'s not, we pop the number at index left and update the left index. \\n                # Remember we cannot retrieve the frequency of start of the window and then minus the frequency \\n                # because we need to make sure our window is consecutive. It\\'s necessary to pop one item each time. \\n                # If you are still confused, think about this case: [2,2,2,4,4,2,5,5,5,5,5,2]\\n                num_to_freq[nums[left]] -= 1 \\n                if num_to_freq[nums[left]] == 0:\\n                    num_to_freq.pop(nums[left])\\n                left += 1\\n                \\n            max_length = max(max_length, right - left + 1) # if the maximum and the minimum conform the requirement, we update our result\\n        return max_length\\n```\n```\\nimport collections\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        left = 0\\n        max_length = 1\\n        n = len(nums)\\n        # We defined the two monotonic array here, we named the increasing array \"increasing_q\" and the decreasing array \"decreasing_q\"\\n        increasing_q = collections.deque()\\n        decreasing_q = collections.deque() \\n        # Start sliding -_- ...\\n        for right in range(n):\\n            # remember we should always try to insert the value into the last of the monotonic arrays\\n            # For increasing_q, we need to check whether the last value of the monotonic array is larger than the right end of the window. If it is, then we need to pop the value until we find the one which is smaller than the right end of the window and insert the right end of the window at the last of the increasing monotonic array. \\n            # You cannot put the increasing_q[-1] >= nums[right] here because the limit might be 0 and in this case, we need to count the number of equal value.\\n            while increasing_q and increasing_q[-1] > nums[right]:\\n                increasing_q.pop()\\n            increasing_q.append(nums[right])\\n\\n            # For decreasing_q, we need to check whether the last value of the monotonic array is smaller than the right end of the window. If it is, then we need to pop the value until we find the one which is larger than the right end of the window and insert the right end of the window at the last of the decreasing monotonic array. \\n            # You cannot put the decreasing_q[-1] <= nums[right] here because the limit might be 0 and in this case, we need to count the number of equal value.\\n            while decreasing_q and decreasing_q[-1] < nums[right]:\\n                decreasing_q.pop()\\n            decreasing_q.append(nums[right])\\n\\n            # we need to check if the difference of the max and min in the current window is bigger than the limit or not, if it is, we need to do something and update our window. \\n            while decreasing_q[0] - increasing_q[0] > limit:\\n                # For decreasing_q, there are 3(actually I think there are only 2) cases here: \\n                    # nums[left] is greater than decreasing_q[0], then it must have been popped before\\n                    # nums[left] == decreasing_q[0], then pop it here\\n                    # nums[left] is smaller than decreasing_q[0](which I think is impossible because we should always pop the bigger ones first to get the smaller ones so we haven\\'t reached those nums which are smaller than decreasing_q[0] yet.) \\n                if decreasing_q[0] == nums[left]:\\n                    decreasing_q.popleft()\\n                # For increasing_q, there are 3(actually I think there are only 2) cases here: \\n                    # nums[left] is smaller than increasing_q[0], then it must have been popped before\\n                    # nums[left] == increasing_q[0], then pop it here\\n                    # nums[left] is greater than increasing_q[0](which I think is impossible because we should always pop the smaller ones first to get the bigger ones so we haven\\'t reached those nums which are bigger than increasing_q[0] yet.) \\n                if increasing_q[0] == nums[left]:\\n                    increasing_q.popleft()\\n                \\n                # We need to update the left here to forward our window so that it is more likely to be valid\\n                left += 1\\n            # window is valid \\uD83D\\uDE0A, update the max_length here.  \\n            max_length = max(max_length, right - left + 1)\\n        return max_length\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942910,
                "title": "c-100-faster-sliding-window",
                "content": "```\\n/*\\nJust keep track of the minimum and the maximum in the window,there difference should be below limit\\n*/\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        deque<int> mn, mx;\\n        int j = 0;\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            while(!mx.empty() and nums[i] > mx.back()){\\n                mx.pop_back();\\n            }\\n            mx.push_back(nums[i]);\\n            while(!mn.empty() and nums[i] < mn.back()){\\n                mn.pop_back();\\n            }\\n            mn.push_back(nums[i]);\\n            while(mx.front() - mn.front() > limit){\\n                if(nums[j] == mx.front()) mx.pop_front();\\n                if(nums[j] == mn.front()) mn.pop_front();\\n                j++;\\n            }\\n            ans = max(ans, i-j+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n/*\\nJust keep track of the minimum and the maximum in the window,there difference should be below limit\\n*/\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        deque<int> mn, mx;\\n        int j = 0;\\n        int ans = 0;\\n        for(int i = 0; i < nums.size(); i++){\\n            while(!mx.empty() and nums[i] > mx.back()){\\n                mx.pop_back();\\n            }\\n            mx.push_back(nums[i]);\\n            while(!mn.empty() and nums[i] < mn.back()){\\n                mn.pop_back();\\n            }\\n            mn.push_back(nums[i]);\\n            while(mx.front() - mn.front() > limit){\\n                if(nums[j] == mx.front()) mx.pop_front();\\n                if(nums[j] == mn.front()) mn.pop_front();\\n                j++;\\n            }\\n            ans = max(ans, i-j+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1486996,
                "title": "c-stack",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:** nearest greater on right and nearest smaller on right\\n\\n```\\nclass Solution {\\npublic:\\n    \\n\\t// to store index of nearest greater element on right side\\n    vector<int> greater(vector<int>& a){\\n        int n=a.size();\\n        vector<int> ngr;\\n        stack<pair<int,int>> st;\\n        for(int i=n-1;i>=0;i--){\\n            while(st.size()>0 && st.top().first<a[i]) st.pop();\\n            if(st.size()==0){\\n                ngr.push_back(n);\\n            }else{\\n                ngr.push_back(st.top().second);\\n            }\\n            st.push({a[i],i});\\n        }\\n        reverse(ngr.begin(),ngr.end());\\n        return ngr;\\n    }\\n    \\n\\t// to store index of nearest smaller element on right side\\n    vector<int> smaller(vector<int>& a){\\n        int n=a.size();\\n        vector<int> nsr;\\n        stack<pair<int,int>> st;\\n        for(int i=n-1;i>=0;i--){\\n            while(st.size()>0 && st.top().first>a[i]) st.pop();\\n            if(st.size()==0){\\n                nsr.push_back(n);\\n            }else{\\n                nsr.push_back(st.top().second);\\n            }\\n            st.push({a[i],i});\\n        }\\n        reverse(nsr.begin(),nsr.end());\\n        return nsr;\\n    }\\n    \\n    int longestSubarray(vector<int>& a, int k) {\\n        int n=a.size();\\n        \\n        vector<int> ngr=greater(a);\\n        vector<int> nsr=smaller(a);\\n        \\n        int i=0, j=0;\\n        int maxlen=0;\\n        int maxIdx=0, minIdx=0;\\n        while(j<n){\\n            if(a[j]>a[maxIdx]) maxIdx=j;\\n            if(a[j]<a[minIdx]) minIdx=j;\\n            \\n            if(i<=j && abs(a[maxIdx]-a[minIdx])>k){\\n                i++;\\n                int len=j-i+1;\\n                \\n                // max in window\\n                maxIdx=max(maxIdx,i);\\n                while(ngr[maxIdx]<i+len) maxIdx=ngr[maxIdx];\\n                \\n                // min in window\\n                minIdx=max(minIdx,i);\\n                while(nsr[minIdx]<i+len) minIdx=nsr[minIdx];\\n            }\\n            int len=j-i+1;\\n            maxlen=max(maxlen,len);\\n            j++;\\n        } \\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n\\t// to store index of nearest greater element on right side\\n    vector<int> greater(vector<int>& a){\\n        int n=a.size();\\n        vector<int> ngr;\\n        stack<pair<int,int>> st;\\n        for(int i=n-1;i>=0;i--){\\n            while(st.size()>0 && st.top().first<a[i]) st.pop();\\n            if(st.size()==0){\\n                ngr.push_back(n);\\n            }else{\\n                ngr.push_back(st.top().second);\\n            }\\n            st.push({a[i],i});\\n        }\\n        reverse(ngr.begin(),ngr.end());\\n        return ngr;\\n    }\\n    \\n\\t// to store index of nearest smaller element on right side\\n    vector<int> smaller(vector<int>& a){\\n        int n=a.size();\\n        vector<int> nsr;\\n        stack<pair<int,int>> st;\\n        for(int i=n-1;i>=0;i--){\\n            while(st.size()>0 && st.top().first>a[i]) st.pop();\\n            if(st.size()==0){\\n                nsr.push_back(n);\\n            }else{\\n                nsr.push_back(st.top().second);\\n            }\\n            st.push({a[i],i});\\n        }\\n        reverse(nsr.begin(),nsr.end());\\n        return nsr;\\n    }\\n    \\n    int longestSubarray(vector<int>& a, int k) {\\n        int n=a.size();\\n        \\n        vector<int> ngr=greater(a);\\n        vector<int> nsr=smaller(a);\\n        \\n        int i=0, j=0;\\n        int maxlen=0;\\n        int maxIdx=0, minIdx=0;\\n        while(j<n){\\n            if(a[j]>a[maxIdx]) maxIdx=j;\\n            if(a[j]<a[minIdx]) minIdx=j;\\n            \\n            if(i<=j && abs(a[maxIdx]-a[minIdx])>k){\\n                i++;\\n                int len=j-i+1;\\n                \\n                // max in window\\n                maxIdx=max(maxIdx,i);\\n                while(ngr[maxIdx]<i+len) maxIdx=ngr[maxIdx];\\n                \\n                // min in window\\n                minIdx=max(minIdx,i);\\n                while(nsr[minIdx]<i+len) minIdx=nsr[minIdx];\\n            }\\n            int len=j-i+1;\\n            maxlen=max(maxlen,len);\\n            j++;\\n        } \\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214793,
                "title": "c-two-pointer-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        priority_queue<pair<int, int>> maxh;\\n        priority_queue<pair<int, int>, vector<pair<int,int>>, greater<pair<int, int>>> minh;\\n        int i = 0; int j = 0;\\n        int ans = 0;\\n        while(j<nums.size()){\\n            maxh.push({nums[j], j});\\n            minh.push({nums[j], j});\\n            if(maxh.top().first-minh.top().first<=limit){\\n                ans= max(ans, j-i+1);\\n                j++;\\n            }\\n            else if(maxh.top().first-minh.top().first>limit){\\n                i++;\\n                while(maxh.top().second<i){\\n                    maxh.pop();\\n                }\\n                while(minh.top().second<i){\\n                    minh.pop();\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        priority_queue<pair<int, int>> maxh;\\n        priority_queue<pair<int, int>, vector<pair<int,int>>, greater<pair<int, int>>> minh;\\n        int i = 0; int j = 0;\\n        int ans = 0;\\n        while(j<nums.size()){\\n            maxh.push({nums[j], j});\\n            minh.push({nums[j], j});\\n            if(maxh.top().first-minh.top().first<=limit){\\n                ans= max(ans, j-i+1);\\n                j++;\\n            }\\n            else if(maxh.top().first-minh.top().first>limit){\\n                i++;\\n                while(maxh.top().second<i){\\n                    maxh.pop();\\n                }\\n                while(minh.top().second<i){\\n                    minh.pop();\\n                }\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135539,
                "title": "python-o-n-fast-step-wise-easy-to-understand-max-min-using-queue",
                "content": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        l = 0\\n        r = 0\\n        \\n        #Approach: Using deques as calculating max,min for each subarray is costly\\n        min_q = deque()\\n        max_q = deque()\\n        \\n        #STEP1: Iterate subarrays using window of l to r \\n        while r < len(nums):\\n            n = nums[r] #Get current element\\n            \\n            #STEP2: If current element < last element of min queue, pop it(REPEAT)\\n            while min_q and n < nums[min_q[-1]]:\\n                min_q.pop()\\n            \\n            #STEP3: If current element > last element of max queue, pop it(REPEAT)\\n            while max_q and n > nums[max_q[-1]]:\\n                max_q.pop()\\n                \\n            #---- Now queue satisfies insertion of current element ------\\n            \\n            #STEP4: Add index of current element to both queues at the last\\n            min_q.append(r)\\n            max_q.append(r)\\n            \\n            #STEP5: Get max and min values in current subarray\\n            max_e = nums[max_q[0]]\\n            min_e = nums[min_q[0]]\\n            \\n            #STEP6: If it violates limit, shrink the window from left\\n            if max_e - min_e > limit:\\n                l += 1\\n                #STEP7: We had previously considered the value we discarded, now we need to update our queues. So pop any index before current window\\n                while min_q and min_q[0] < l:\\n                    min_q.popleft()\\n                while max_q and max_q[0] < l:\\n                    max_q.popleft()\\n            r += 1\\n        \\n        #STEP8 Return the size of the current window.\\n        return (r-l)\\n    \\n    #r - l because r has increased by 1 already, no need to do r-l+1\\n                    \\n                \\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        l = 0\\n        r = 0\\n        \\n        #Approach: Using deques as calculating max,min for each subarray is costly\\n        min_q = deque()\\n        max_q = deque()\\n        \\n        #STEP1: Iterate subarrays using window of l to r \\n        while r < len(nums):\\n            n = nums[r] #Get current element\\n            \\n            #STEP2: If current element < last element of min queue, pop it(REPEAT)\\n            while min_q and n < nums[min_q[-1]]:\\n                min_q.pop()\\n            \\n            #STEP3: If current element > last element of max queue, pop it(REPEAT)\\n            while max_q and n > nums[max_q[-1]]:\\n                max_q.pop()\\n                \\n            #---- Now queue satisfies insertion of current element ------\\n            \\n            #STEP4: Add index of current element to both queues at the last\\n            min_q.append(r)\\n            max_q.append(r)\\n            \\n            #STEP5: Get max and min values in current subarray\\n            max_e = nums[max_q[0]]\\n            min_e = nums[min_q[0]]\\n            \\n            #STEP6: If it violates limit, shrink the window from left\\n            if max_e - min_e > limit:\\n                l += 1\\n                #STEP7: We had previously considered the value we discarded, now we need to update our queues. So pop any index before current window\\n                while min_q and min_q[0] < l:\\n                    min_q.popleft()\\n                while max_q and max_q[0] < l:\\n                    max_q.popleft()\\n            r += 1\\n        \\n        #STEP8 Return the size of the current window.\\n        return (r-l)\\n    \\n    #r - l because r has increased by 1 already, no need to do r-l+1\\n                    \\n                \\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1119368,
                "title": "c-multiset-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        multiset<int> ms;\\n        \\n        int ans = 1;\\n        int start = 0;\\n        for(int i=0; i < nums.size(); i++) {\\n            ms.insert(nums[i]);\\n            while(*ms.rbegin() - *ms.begin() > limit) {\\n                ms.erase(ms.find(nums[start]));\\n                start++;\\n            }\\n            ans = max(ans, i - start + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        multiset<int> ms;\\n        \\n        int ans = 1;\\n        int start = 0;\\n        for(int i=0; i < nums.size(); i++) {\\n            ms.insert(nums[i]);\\n            while(*ms.rbegin() - *ms.begin() > limit) {\\n                ms.erase(ms.find(nums[start]));\\n                start++;\\n            }\\n            ans = max(ans, i - start + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 976256,
                "title": "straightforward-java-solution-sliding-window-and-monotonic-queues-o-n-time",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        ArrayDeque<Integer> max = new ArrayDeque<>(); // monotonic decrease\\n        ArrayDeque<Integer> min = new ArrayDeque<>(); // monotonic increase\\n        int n = nums.length;\\n        max.offer(nums[0]);\\n        min.offer(nums[0]);\\n        int ans = 1;\\n        int i = 0;\\n        for (int j = 1; j < n; j++) {\\n            while (!max.isEmpty() && max.peekLast() < nums[j]) {\\n                max.pollLast();\\n            }\\n            max.offer(nums[j]);\\n            while (!min.isEmpty() && min.peekLast() > nums[j]) {\\n                min.pollLast();\\n            }\\n            min.offer(nums[j]);\\n            while (max.peekFirst() - min.peekFirst() > limit) {\\n                if (max.peekFirst() == nums[i]) {\\n                    max.pollFirst();\\n                }\\n                if (min.peekFirst() == nums[i]) {\\n                    min.pollFirst();\\n                }\\n                i++;\\n            }\\n            ans = Math.max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        ArrayDeque<Integer> max = new ArrayDeque<>(); // monotonic decrease\\n        ArrayDeque<Integer> min = new ArrayDeque<>(); // monotonic increase\\n        int n = nums.length;\\n        max.offer(nums[0]);\\n        min.offer(nums[0]);\\n        int ans = 1;\\n        int i = 0;\\n        for (int j = 1; j < n; j++) {\\n            while (!max.isEmpty() && max.peekLast() < nums[j]) {\\n                max.pollLast();\\n            }\\n            max.offer(nums[j]);\\n            while (!min.isEmpty() && min.peekLast() > nums[j]) {\\n                min.pollLast();\\n            }\\n            min.offer(nums[j]);\\n            while (max.peekFirst() - min.peekFirst() > limit) {\\n                if (max.peekFirst() == nums[i]) {\\n                    max.pollFirst();\\n                }\\n                if (min.peekFirst() == nums[i]) {\\n                    min.pollFirst();\\n                }\\n                i++;\\n            }\\n            ans = Math.max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 861252,
                "title": "c-10-lines-multiset-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& v, int lim) {\\n        multiset<int> w;\\n        int mn, mx, len = 0, n = v.size();\\n        for(int i=0, j=0; j<n; j++) {\\n            w.insert(v[j]);\\n            while(*w.rbegin()-*w.begin() > lim)\\n                w.erase(w.find(v[i])), i++;\\n            len=max(len,(int)w.size());\\n        }\\n        return len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& v, int lim) {\\n        multiset<int> w;\\n        int mn, mx, len = 0, n = v.size();\\n        for(int i=0, j=0; j<n; j++) {\\n            w.insert(v[j]);\\n            while(*w.rbegin()-*w.begin() > lim)\\n                w.erase(w.find(v[i])), i++;\\n            len=max(len,(int)w.size());\\n        }\\n        return len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 830041,
                "title": "o-1-space-simple-easy-java-solution-with-comments",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }\\n        int minIndex = 0;\\n        int minValue = nums[0];\\n        int maxValue = nums[0];\\n        int maxIndex = 0;\\n        int longestArray = 0;\\n        \\n        int left = 0;\\n        int right = 1;\\n        \\n        while(right<nums.length) {\\n            // if current value (right pointer) satisfies the limit, expand the window and continue)\\n            if (Math.abs(nums[right] - minValue) <= limit && Math.abs(nums[right] - maxValue) <= limit) {\\n                // check if max value and index needs to be updated.\\n                if (nums[right] > maxValue) {\\n                    maxValue = nums[right];\\n                    maxIndex = right;\\n                }\\n                // check if min value and index needs to be updated.\\n                if (nums[right] < minValue) {\\n                    minValue = nums[right];\\n                    minIndex = right;\\n                }\\n                right++;\\n                continue;\\n            }\\n            \\n            // window is broken. Identify if window needs to start from next index of MinIndex or MaxIndex.\\n            \\n            longestArray = Math.max(longestArray, right - left);\\n            \\n            int nextIndex = Math.max(minIndex, maxIndex); // try to skip to the maximum index \\n            if (Math.abs(nums[nextIndex] - nums[right]) > limit) {\\n                nextIndex = Math.max(minIndex, maxIndex);\\n            }\\n            else {\\n               nextIndex = Math.min(minIndex, maxIndex);\\n            }\\n            \\n            // skip values until the condition is satisfied.\\n            while(Math.abs(nums[nextIndex] - nums[right]) > limit && nextIndex < right) {\\n                nextIndex++;\\n            }\\n            minIndex = nextIndex;\\n            maxIndex = nextIndex;\\n            minValue = nums[nextIndex];\\n            maxValue = nums[nextIndex];\\n            left = nextIndex;\\n            right = nextIndex;\\n            right++;\\n        }\\n        longestArray = Math.max(longestArray, right - left);\\n        return longestArray;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        if (nums == null || nums.length == 0) {\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 812416,
                "title": "swift-o-n-3-o-n-2-o-n",
                "content": "```\\nimport Foundation\\n\\n// Brute force. Time O(n^3)\\nclass Solution {\\n    func longestSubarray(_ nums: [Int], _ limit: Int) -> Int {\\n        guard nums.count > 0 else {\\n            return 0\\n        }\\n        \\n        var maxLen = 1\\n        for i in 0..<nums.count {\\n            for j in i..<nums.count {\\n                let diff = abs(nums[i...j].max()! - nums[i...j].min()!)\\n                if diff <= limit {\\n                    maxLen = [maxLen, j - i + 1].max()!\\n                }\\n            }\\n        }\\n        return maxLen\\n    }\\n}\\n\\n\\n// Optimised Brute force. Time O(n^2)\\nclass Solution {\\n    func longestSubarray(_ nums: [Int], _ limit: Int) -> Int {\\n        guard nums.count > 0 else {\\n            return 0\\n        }\\n        \\n        var maxLen = 1\\n        for i in 0..<nums.count {\\n            var min = Int.max\\n            var max = Int.min\\n            for j in i..<nums.count {\\n                min = [min, nums[j]].min()!\\n                max = [max, nums[j]].max()!\\n                let diff = abs(max - min)\\n                if diff <= limit {\\n                    maxLen = [maxLen, j - i + 1].max()!\\n                }\\n            }\\n        }\\n        return maxLen\\n    }\\n}\\n\\n\\n// Sliding Window. Time O(n). Accepted\\n// Source: https://tinyurl.com/y3h2fj2m\\nclass Solution {\\n    func longestSubarray(_ nums: [Int], _ limit: Int) -> Int {\\n        guard nums.count > 0 else {\\n            return 0\\n        }\\n        \\n        var (left, right, maxLen) = (0, 0, 1)\\n        var (minDeque, maxDeque) = ([Int](), [Int]())\\n        while right < nums.count {\\n            while let last = minDeque.last, nums[last] >= nums[right] {\\n                minDeque.removeLast()\\n            }\\n            while let last = maxDeque.last, nums[last] <= nums[right] {\\n                maxDeque.removeLast()\\n            }\\n            minDeque.append(right)\\n            maxDeque.append(right)\\n            \\n            while nums[maxDeque.first!] - nums[minDeque.first!] > limit {\\n                left += 1\\n                if left > minDeque.first! {\\n                    minDeque.removeFirst()\\n                }\\n                if left > maxDeque.first! {\\n                    maxDeque.removeFirst()\\n                }\\n            }\\n            maxLen = [maxLen, right - left + 1].max()!\\n            right += 1\\n        }\\n        return maxLen\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Sliding Window"
                ],
                "code": "```\\nimport Foundation\\n\\n// Brute force. Time O(n^3)\\nclass Solution {\\n    func longestSubarray(_ nums: [Int], _ limit: Int) -> Int {\\n        guard nums.count > 0 else {\\n            return 0\\n        }\\n        \\n        var maxLen = 1\\n        for i in 0..<nums.count {\\n            for j in i..<nums.count {\\n                let diff = abs(nums[i...j].max()! - nums[i...j].min()!)\\n                if diff <= limit {\\n                    maxLen = [maxLen, j - i + 1].max()!\\n                }\\n            }\\n        }\\n        return maxLen\\n    }\\n}\\n\\n\\n// Optimised Brute force. Time O(n^2)\\nclass Solution {\\n    func longestSubarray(_ nums: [Int], _ limit: Int) -> Int {\\n        guard nums.count > 0 else {\\n            return 0\\n        }\\n        \\n        var maxLen = 1\\n        for i in 0..<nums.count {\\n            var min = Int.max\\n            var max = Int.min\\n            for j in i..<nums.count {\\n                min = [min, nums[j]].min()!\\n                max = [max, nums[j]].max()!\\n                let diff = abs(max - min)\\n                if diff <= limit {\\n                    maxLen = [maxLen, j - i + 1].max()!\\n                }\\n            }\\n        }\\n        return maxLen\\n    }\\n}\\n\\n\\n// Sliding Window. Time O(n). Accepted\\n// Source: https://tinyurl.com/y3h2fj2m\\nclass Solution {\\n    func longestSubarray(_ nums: [Int], _ limit: Int) -> Int {\\n        guard nums.count > 0 else {\\n            return 0\\n        }\\n        \\n        var (left, right, maxLen) = (0, 0, 1)\\n        var (minDeque, maxDeque) = ([Int](), [Int]())\\n        while right < nums.count {\\n            while let last = minDeque.last, nums[last] >= nums[right] {\\n                minDeque.removeLast()\\n            }\\n            while let last = maxDeque.last, nums[last] <= nums[right] {\\n                maxDeque.removeLast()\\n            }\\n            minDeque.append(right)\\n            maxDeque.append(right)\\n            \\n            while nums[maxDeque.first!] - nums[minDeque.first!] > limit {\\n                left += 1\\n                if left > minDeque.first! {\\n                    minDeque.removeFirst()\\n                }\\n                if left > maxDeque.first! {\\n                    maxDeque.removeFirst()\\n                }\\n            }\\n            maxLen = [maxLen, right - left + 1].max()!\\n            right += 1\\n        }\\n        return maxLen\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 751204,
                "title": "javascript-python3-c-map-for-min-max",
                "content": "**Synopsis:**\\n\\n\"grow\" and \"shrink\" a sliding window based on the min/max value tracked within the sliding window via an ordered map `m`.  I originally wrote this solution in C++ because C++ has an ordered map data structure which allows for O(logK) insertions for a window of size K.  Then I wrote similar solutions in Python3 and Javascript, surprisingly the JS solution is AC, while the Python3 solution results in TLE as expected, since sorting the window of size K costs O(K * logK).  Python3 has a built in heap data structure I could use to improve this bottleneck, and I suspect I would need to write a heap for JS.\\n\\n---\\n\\n*Javascript*\\n```\\nlet longestSubarray = (A, T, m = new Map(), best = 1) => {\\n    let N = A.length,\\n        i = 0,\\n        j = 1; // A[i..j) => i inclusive to j non-inclusive\\n    m.set(A[i], 1);\\n    for (;;) {\\n        let minmax = [...m.entries()].sort((a, b) => a[0] - b[0]).map(([x, _]) => x); // hack since JS lacks an ordered map\\n        let min = minmax[0],\\n            max = minmax[minmax.length - 1];\\n        if (max - min <= T) {\\n            best = Math.max(best, j - i); // \\uD83C\\uDFAF best, ie. max length from i inclusive to j non-inclusive\\n            if (j == N)\\n                break;\\n            m.set(A[j], 1 + (m.get(A[j]) || 0)); // \"grow\" window\\n            ++j;\\n        } else {\\n            m.set(A[i], -1 + m.get(A[i]));       // \"shrink\" window\\n            if (!m.get(A[i]))\\n                m.delete(A[i]);\\n            ++i;\\n        }\\n    }\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def longestSubarray(self, A: List[int], T: int, best = 0) -> int:\\n        m = collections.Counter()\\n        N, i, j = len(A), 0, 1 # A[i..j) => i inclusive to j non-inclusive\\n        m[A[i]] = 1\\n        while True:\\n            minmax = list(map(lambda pair: pair[0], sorted(m.items()))) # hack since Python3 lacks an ordered map\\n            minimum = minmax[0]\\n            maximum = minmax[-1]\\n            if maximum - minimum <= T:\\n                best = max(best, j - i) # \\uD83C\\uDFAF best, ie. max length from i inclusive to j non-inclusive\\n                if j == N:\\n                    break\\n                m[A[j]] += 1   # \"grow\" window\\n                j += 1\\n            else:\\n                m[A[i]] -= 1   # \"shrink\" window\\n                if not m[A[i]]:\\n                    del m[A[i]]\\n                i += 1\\n        return best\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = map<int, int>; // contents of sliding window [value, freq]\\n    int longestSubarray(VI& A, int T, Map m = {}, int best = 1) {\\n        int N = A.size(),\\n            i = 0,\\n            j = 1; // A[i..j) => i inclusive to j non-inclusive\\n        m[A[i]] = 1;\\n        for (;;) {\\n            auto min = m.begin()->first,\\n                 max = prev(m.end())->first;\\n            if (max - min <= T) {\\n                best = std::max(best, j - i); // \\uD83C\\uDFAF best, ie. max length from i inclusive to j non-inclusive\\n                if (j == N)\\n                    break;\\n                ++m[A[j++]];    // \"grow\" window\\n            } else {\\n                if (!--m[A[i]]) // \"shrink\" window\\n                    m.erase(A[i]);\\n                ++i;\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet longestSubarray = (A, T, m = new Map(), best = 1) => {\\n    let N = A.length,\\n        i = 0,\\n        j = 1; // A[i..j) => i inclusive to j non-inclusive\\n    m.set(A[i], 1);\\n    for (;;) {\\n        let minmax = [...m.entries()].sort((a, b) => a[0] - b[0]).map(([x, _]) => x); // hack since JS lacks an ordered map\\n        let min = minmax[0],\\n            max = minmax[minmax.length - 1];\\n        if (max - min <= T) {\\n            best = Math.max(best, j - i); // \\uD83C\\uDFAF best, ie. max length from i inclusive to j non-inclusive\\n            if (j == N)\\n                break;\\n            m.set(A[j], 1 + (m.get(A[j]) || 0)); // \"grow\" window\\n            ++j;\\n        } else {\\n            m.set(A[i], -1 + m.get(A[i]));       // \"shrink\" window\\n            if (!m.get(A[i]))\\n                m.delete(A[i]);\\n            ++i;\\n        }\\n    }\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def longestSubarray(self, A: List[int], T: int, best = 0) -> int:\\n        m = collections.Counter()\\n        N, i, j = len(A), 0, 1 # A[i..j) => i inclusive to j non-inclusive\\n        m[A[i]] = 1\\n        while True:\\n            minmax = list(map(lambda pair: pair[0], sorted(m.items()))) # hack since Python3 lacks an ordered map\\n            minimum = minmax[0]\\n            maximum = minmax[-1]\\n            if maximum - minimum <= T:\\n                best = max(best, j - i) # \\uD83C\\uDFAF best, ie. max length from i inclusive to j non-inclusive\\n                if j == N:\\n                    break\\n                m[A[j]] += 1   # \"grow\" window\\n                j += 1\\n            else:\\n                m[A[i]] -= 1   # \"shrink\" window\\n                if not m[A[i]]:\\n                    del m[A[i]]\\n                i += 1\\n        return best\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = map<int, int>; // contents of sliding window [value, freq]\\n    int longestSubarray(VI& A, int T, Map m = {}, int best = 1) {\\n        int N = A.size(),\\n            i = 0,\\n            j = 1; // A[i..j) => i inclusive to j non-inclusive\\n        m[A[i]] = 1;\\n        for (;;) {\\n            auto min = m.begin()->first,\\n                 max = prev(m.end())->first;\\n            if (max - min <= T) {\\n                best = std::max(best, j - i); // \\uD83C\\uDFAF best, ie. max length from i inclusive to j non-inclusive\\n                if (j == N)\\n                    break;\\n                ++m[A[j++]];    // \"grow\" window\\n            } else {\\n                if (!--m[A[i]]) // \"shrink\" window\\n                    m.erase(A[i]);\\n                ++i;\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 748197,
                "title": "python-3-easy-to-understand-commented-code",
                "content": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # sanity check\\n        if nums is None or len(nums) <= 1 or limit < 0:\\n            return 1\\n        \\n        # sliding window approach in O(n) time\\n        max_len, l, r = 0, 0, 0\\n        \\n        # notice that, the only absolute difference we need to check is the \\n        # maximum possible absolute difference since it ensures there are no\\n        # other absolute differences that can be bigger than @limit\\n        max_val, min_val = 0, 0\\n        \\n        # dequeu method of keeping a local min and max over a sliding window in \\n        # amortized O(1) time \\n        # reference: https://www.nayuki.io/page/sliding-window-minimum-maximum-algorithm\\n        min_dq, max_dq = [], []\\n        \\n        while r < len(nums):\\n            val = nums[r] \\n            \\n            # update min_dq\\n            while len(min_dq) > 0 and val < min_dq[-1]:\\n                min_dq.pop()\\n            min_dq.append(val)\\n            \\n            # update max_dq\\n            while len(max_dq) > 0 and val > max_dq[-1]:\\n                max_dq.pop()\\n            max_dq.append(val)\\n\\n            max_val = max_dq[0]\\n            min_val = min_dq[0]\\n            \\n            diff = abs(max_val - min_val)\\n            \\n            # note that we do not have to worry about the left pointer passing the right one\\n            if diff > limit:\\n                # recalculate min and max values of window by updating dequeues\\n                check = nums[l]\\n                if check == min_dq[0]:\\n                    min_dq.pop(0)\\n                if check == max_dq[0]:\\n                    max_dq.pop(0)\\n                \\n                # shrink window\\n                l += 1\\n            \\n            # expand window\\n            max_len = max(max_len, r - l + 1)\\n            r += 1\\n        \\n        return max_len       \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # sanity check\\n        if nums is None or len(nums) <= 1 or limit < 0:\\n            return 1\\n        \\n        # sliding window approach in O(n) time\\n        max_len, l, r = 0, 0, 0\\n        \\n        # notice that, the only absolute difference we need to check is the \\n        # maximum possible absolute difference since it ensures there are no\\n        # other absolute differences that can be bigger than @limit\\n        max_val, min_val = 0, 0\\n        \\n        # dequeu method of keeping a local min and max over a sliding window in \\n        # amortized O(1) time \\n        # reference: https://www.nayuki.io/page/sliding-window-minimum-maximum-algorithm\\n        min_dq, max_dq = [], []\\n        \\n        while r < len(nums):\\n            val = nums[r] \\n            \\n            # update min_dq\\n            while len(min_dq) > 0 and val < min_dq[-1]:\\n                min_dq.pop()\\n            min_dq.append(val)\\n            \\n            # update max_dq\\n            while len(max_dq) > 0 and val > max_dq[-1]:\\n                max_dq.pop()\\n            max_dq.append(val)\\n\\n            max_val = max_dq[0]\\n            min_val = min_dq[0]\\n            \\n            diff = abs(max_val - min_val)\\n            \\n            # note that we do not have to worry about the left pointer passing the right one\\n            if diff > limit:\\n                # recalculate min and max values of window by updating dequeues\\n                check = nums[l]\\n                if check == min_dq[0]:\\n                    min_dq.pop(0)\\n                if check == max_dq[0]:\\n                    max_dq.pop(0)\\n                \\n                # shrink window\\n                l += 1\\n            \\n            # expand window\\n            max_len = max(max_len, r - l + 1)\\n            r += 1\\n        \\n        return max_len       \\n```",
                "codeTag": "Java"
            },
            {
                "id": 746331,
                "title": "the-python3-version-of-the-2-heaps-solution",
                "content": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        if not len(nums): return 0\\n        \\n        ml, start, end = 1, 0, 0\\n        pqmin, pqmax = [], []\\n        \\n        for end in range(len(nums)):\\n            heapq.heappush(pqmin, (nums[end], end))\\n            heapq.heappush(pqmax, (-nums[end], end))\\n            \\n            while start < end and abs(pqmax[0][0] + pqmin[0][0]) > limit:\\n                start += 1\\n                while pqmax and pqmax[0][1] < start: heapq.heappop(pqmax)\\n                while pqmin and pqmin[0][1] < start: heapq.heappop(pqmin)\\n            \\n            ml = max(ml, end - start + 1)\\n            \\n        return ml\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        if not len(nums): return 0\\n        \\n        ml, start, end = 1, 0, 0\\n        pqmin, pqmax = [], []\\n        \\n        for end in range(len(nums)):\\n            heapq.heappush(pqmin, (nums[end], end))\\n            heapq.heappush(pqmax, (-nums[end], end))\\n            \\n            while start < end and abs(pqmax[0][0] + pqmin[0][0]) > limit:\\n                start += 1\\n                while pqmax and pqmax[0][1] < start: heapq.heappop(pqmax)\\n                while pqmin and pqmin[0][1] < start: heapq.heappop(pqmin)\\n            \\n            ml = max(ml, end - start + 1)\\n            \\n        return ml\\n",
                "codeTag": "Java"
            },
            {
                "id": 667986,
                "title": "python-neat-and-simple-solution-with-explanation",
                "content": "The problem description states that we need to find the window with the largest size  that has max-min<=limit\\nThis is clearly a sliding window problem. The brute force solution is to start from each index, keep on expanding, and once the max-min is larger than limit, we break. O(n^2)\\n\\nCan we do better? Well, we can actually use a classic technique in sliding window problems where we keep on expanding the window from the right until the window is no longer valid. \\nOnce the window is invalid we keep on contracting it from the left until it becomes valid again. (Just like in the famous \"Longest Substring Without Repeating Characters\" problem.\\n\\nEvery iteration we need to answer the question, what is our current min and max? this leads us to using two heaps where one of them is a min heap and the other is a max heap. \\n\\nEvery iteration we push the new number to both heaps and then keep on popping from the min and max heap until we\\'re sure that we\\'ve maintained the invariant maxHeap[0]-minHeap[0]<=limit.\\nWe do O(N) pushes and pops from the heaps and each push/pop is O(logN) so we end up with an O(NlogN) solution.\\n\\nHere is the code:\\n\\n```\\nfrom heapq import heappush,heappop\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        minHeap,maxHeap=[],[]\\n        left=maxLen=0\\n        for right in range(len(nums)):\\n            heappush(minHeap,(nums[right],right))\\n            heappush(maxHeap,(-nums[right],right))\\n            \\n            while nums[right]-minHeap[0][0]>limit:\\n                left=max(left,(heappop(minHeap)[1])+1)\\n            while -maxHeap[0][0]-nums[right]>limit:\\n                left=max(left,(heappop(maxHeap)[1])+1)\\n            maxLen=max(maxLen,right-left+1)\\n        return maxLen\\n```",
                "solutionTags": [],
                "code": "```\\nfrom heapq import heappush,heappop\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        minHeap,maxHeap=[],[]\\n        left=maxLen=0\\n        for right in range(len(nums)):\\n            heappush(minHeap,(nums[right],right))\\n            heappush(maxHeap,(-nums[right],right))\\n            \\n            while nums[right]-minHeap[0][0]>limit:\\n                left=max(left,(heappop(minHeap)[1])+1)\\n            while -maxHeap[0][0]-nums[right]>limit:\\n                left=max(left,(heappop(maxHeap)[1])+1)\\n            maxLen=max(maxLen,right-left+1)\\n        return maxLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 610804,
                "title": "monotonicqueue-sliding-window-o-n-this-should-be-a-hard-problem",
                "content": "This question should only accept monotonic queue as an answer and should be labeled as hard since it uses [this question as a stepping stone.](https://leetcode.com/problems/sliding-window-maximum/) Also looking at the contest statistics:\\n```\\nUser Accepted:2720\\nUser Tried:4807\\nTotal Accepted:2821\\nTotal Submissions:10830\\n```\\nWe can clearly see that this is on a hard level as hard level questions tend to have this kind of statistic.\\n\\nThe heap solution is mediocre for an acceptance, I think thats why it is currently marked as medium.\\n\\n```\\nimport collections\\n\\nclass Solution:\\n    def longestSubarray(self, nums, limit: int) -> int:\\n        minDeq = collections.deque()\\n        maxDeq = collections.deque()\\n\\n        res = 0\\n        start = 0\\n        for end in range(len(nums)):\\n            num = nums[end]\\n            while len(minDeq) > 0 and num < minDeq[-1]:\\n                minDeq.pop()\\n\\n            while len(maxDeq) > 0 and num > maxDeq[-1]:\\n                maxDeq.pop()\\n\\n            minDeq.append(num)\\n            maxDeq.append(num)\\n\\n            while not abs(minDeq[0] - maxDeq[0]) <= limit and start <= end:\\n                if minDeq[0] == nums[start]:\\n                    minDeq.popleft()\\n\\n                if maxDeq[0] == nums[start]:\\n                    maxDeq.popleft()\\n\\n                start += 1\\n\\n            res = max(res, end - start + 1)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nUser Accepted:2720\\nUser Tried:4807\\nTotal Accepted:2821\\nTotal Submissions:10830\\n```\n```\\nimport collections\\n\\nclass Solution:\\n    def longestSubarray(self, nums, limit: int) -> int:\\n        minDeq = collections.deque()\\n        maxDeq = collections.deque()\\n\\n        res = 0\\n        start = 0\\n        for end in range(len(nums)):\\n            num = nums[end]\\n            while len(minDeq) > 0 and num < minDeq[-1]:\\n                minDeq.pop()\\n\\n            while len(maxDeq) > 0 and num > maxDeq[-1]:\\n                maxDeq.pop()\\n\\n            minDeq.append(num)\\n            maxDeq.append(num)\\n\\n            while not abs(minDeq[0] - maxDeq[0]) <= limit and start <= end:\\n                if minDeq[0] == nums[start]:\\n                    minDeq.popleft()\\n\\n                if maxDeq[0] == nums[start]:\\n                    maxDeq.popleft()\\n\\n                start += 1\\n\\n            res = max(res, end - start + 1)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609849,
                "title": "java-sliding-window-priorityqueue",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        //Sliding window\\n        if (nums.length == 1) return 1;\\n        \\n        int size = 2;\\n        PriorityQueue<Integer> minQ = new PriorityQueue<Integer>();\\n        PriorityQueue<Integer> maxQ = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        minQ.add(nums[0]);\\n        maxQ.add(nums[0]);\\n        \\n        int min = 0;\\n        int max = 0;\\n        \\n        for (int i = 0, j = i + 1; j < nums.length;) {\\n            minQ.add(nums[j]);\\n            maxQ.add(nums[j]);\\n            min = minQ.peek();\\n            max = maxQ.peek();\\n            if (Math.abs(max - min) <= limit) {\\n                j++;\\n                size = Math.max(size, j - i);\\n                \\n            }\\n            else {\\n                minQ.remove(nums[i]);\\n                maxQ.remove(nums[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return size;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        //Sliding window\\n        if (nums.length == 1) return 1;\\n        \\n        int size = 2;\\n        PriorityQueue<Integer> minQ = new PriorityQueue<Integer>();\\n        PriorityQueue<Integer> maxQ = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        minQ.add(nums[0]);\\n        maxQ.add(nums[0]);\\n        \\n        int min = 0;\\n        int max = 0;\\n        \\n        for (int i = 0, j = i + 1; j < nums.length;) {\\n            minQ.add(nums[j]);\\n            maxQ.add(nums[j]);\\n            min = minQ.peek();\\n            max = maxQ.peek();\\n            if (Math.abs(max - min) <= limit) {\\n                j++;\\n                size = Math.max(size, j - i);\\n                \\n            }\\n            else {\\n                minQ.remove(nums[i]);\\n                maxQ.remove(nums[i]);\\n                i++;\\n                j++;\\n            }\\n        }\\n        return size;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609782,
                "title": "c-sliding-window-map",
                "content": "Use sliding window to track the boundaries.\\nUse map to track the smallest and the biggest number in the current range.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int res=0;\\n        map<int,int> m; // value ->count\\n        for(int l=0,r=0;r<nums.size();r++) {\\n            int v=nums[r];\\n            m[v]++;\\n            while(m.rbegin()->first - m.begin()->first > limit) {\\n                v=nums[l++];\\n                m[v]--; if(m[v]==0) m.erase(v);\\n            }\\n            res=max(res,r-l+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int res=0;\\n        map<int,int> m; // value ->count\\n        for(int l=0,r=0;r<nums.size();r++) {\\n            int v=nums[r];\\n            m[v]++;\\n            while(m.rbegin()->first - m.begin()->first > limit) {\\n                v=nums[l++];\\n                m[v]--; if(m[v]==0) m.erase(v);\\n            }\\n            res=max(res,r-l+1);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2593108,
                "title": "python-sliding-window-deque",
                "content": "This problem reminded me of the [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) problem\\n\\nThe reason being that in that one, we had to find the maximum element in each window of a given size.\\n\\nSo, in that problem, what I did was I used a deque to keep track of useful elements thay may become maximum in future windows. \\n\\nHere as well, I did the same but apart from maximum, I used a second deque for minimum elements. And then, all I did was make sure the current window follows the condition of maximum absolute difference <= limit.\\n\\nIn case you want to look at my solution for Sliding Window Maximum - https://leetcode.com/problems/sliding-window-maximum/discuss/2565755/Python-SLIDING-WINDOW-DEQUE-EXPLAINED\\n\\n\\n```\\ndef longestSubarray(self, nums: List[int], limit: int) -> int:\\n        maxLength = 0\\n\\n        minQueue = deque()\\n        maxQueue = deque()\\n        \\n        \\n        i,j = 0,0\\n        n = len(nums)\\n        \\n        while j < n:\\n            # We only want bigger elements in maxQueue\\n            while len(maxQueue) > 0 and maxQueue[-1] < nums[j]: maxQueue.pop()\\n            maxQueue.append(nums[j])\\n            \\n            # We only want smaller elements in minQueue\\n            while len(minQueue) > 0 and minQueue[-1] > nums[j]: minQueue.pop()\\n            minQueue.append(nums[j])\\n            \\n            # Make sure the maximum absolute difference is <= limit\\n            while len(maxQueue) > 0 and len(minQueue) > 0 and maxQueue[0] - minQueue[0] > limit:\\n                if maxQueue[0] == nums[i]: maxQueue.popleft()\\n                if minQueue[0] == nums[i]: minQueue.popleft()\\n                i += 1\\n                \\n            # Update the maxLength if current window length is bigger than previous maxLength\\n            maxLength = max(maxLength, j - i + 1)\\n            j += 1\\n        \\n        return maxLength\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\ndef longestSubarray(self, nums: List[int], limit: int) -> int:\\n        maxLength = 0\\n\\n        minQueue = deque()\\n        maxQueue = deque()\\n        \\n        \\n        i,j = 0,0\\n        n = len(nums)\\n        \\n        while j < n:\\n            # We only want bigger elements in maxQueue\\n            while len(maxQueue) > 0 and maxQueue[-1] < nums[j]: maxQueue.pop()\\n            maxQueue.append(nums[j])\\n            \\n            # We only want smaller elements in minQueue\\n            while len(minQueue) > 0 and minQueue[-1] > nums[j]: minQueue.pop()\\n            minQueue.append(nums[j])\\n            \\n            # Make sure the maximum absolute difference is <= limit\\n            while len(maxQueue) > 0 and len(minQueue) > 0 and maxQueue[0] - minQueue[0] > limit:\\n                if maxQueue[0] == nums[i]: maxQueue.popleft()\\n                if minQueue[0] == nums[i]: minQueue.popleft()\\n                i += 1\\n                \\n            # Update the maxLength if current window length is bigger than previous maxLength\\n            maxLength = max(maxLength, j - i + 1)\\n            j += 1\\n        \\n        return maxLength\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2581731,
                "title": "java-priority-queue-sliding-window",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int ans=0;\\n        PriorityQueue<Integer>minH=new PriorityQueue<>();\\n        PriorityQueue<Integer>maxH=new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        int i=0;\\n        for(int j=0;j<nums.length;j++){\\n            minH.add(nums[j]);\\n            maxH.add(nums[j]);\\n            while(i<=j && Math.abs(minH.peek()-maxH.peek())>limit){\\n                minH.remove(nums[i]);\\n                maxH.remove(nums[i]);\\n                i++;\\n            }\\n            ans=Math.max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int ans=0;\\n        PriorityQueue<Integer>minH=new PriorityQueue<>();\\n        PriorityQueue<Integer>maxH=new PriorityQueue<>(Collections.reverseOrder());\\n        \\n        int i=0;\\n        for(int j=0;j<nums.length;j++){\\n            minH.add(nums[j]);\\n            maxH.add(nums[j]);\\n            while(i<=j && Math.abs(minH.peek()-maxH.peek())>limit){\\n                minH.remove(nums[i]);\\n                maxH.remove(nums[i]);\\n                i++;\\n            }\\n            ans=Math.max(ans,j-i+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485214,
                "title": "python-two-pointers-with-sortedlist",
                "content": "Time Complexity: O(nlogn)\\n\\n```\\n# time complexity O(nlogn)\\n\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        sorted_list = SortedList()\\n        l, max_length = 0, 0\\n        for r in range(len(nums)):\\n            # move r\\n            sorted_list.add(nums[r])\\n\\n            while sorted_list[-1] - sorted_list[0] > limit:\\n                # move l\\n                sorted_list.remove(nums[l])\\n                l += 1\\n\\n            max_length = max(max_length, r - l + 1)\\n\\n        return max_length\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers"
                ],
                "code": "```\\n# time complexity O(nlogn)\\n\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        sorted_list = SortedList()\\n        l, max_length = 0, 0\\n        for r in range(len(nums)):\\n            # move r\\n            sorted_list.add(nums[r])\\n\\n            while sorted_list[-1] - sorted_list[0] > limit:\\n                # move l\\n                sorted_list.remove(nums[l])\\n                l += 1\\n\\n            max_length = max(max_length, r - l + 1)\\n\\n        return max_length\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418531,
                "title": "c-using-2-dequeues-o-n-time-complexity",
                "content": "```\\nclass Solution {\\n    deque<int> maxH;\\n    deque<int> minH;\\npublic:\\n    void push(int x) {\\n        while(!minH.empty() && minH.back() > x) minH.pop_back();\\n        minH.push_back(x);\\n        \\n        while(!maxH.empty() && maxH.back() < x) maxH.pop_back();\\n        maxH.push_back(x);\\n    }\\n    \\n    void pop(int x) {\\n        if(x == minH.front()) minH.pop_front();\\n        if(x == maxH.front()) maxH.pop_front();\\n    }\\n    \\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int n = nums.size();\\n        int i=0, j=0, len=INT_MIN;\\n        \\n        while(j < n) {\\n            push(nums[j]);\\n            \\n            int mini = minH.front();\\n            int maxi = maxH.front();\\n            \\n            if(maxi-mini <= limit) {\\n                len = max(len, j-i+1);\\n            } \\n            else {\\n                pop(nums[i]);\\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return len;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    deque<int> maxH;\\n    deque<int> minH;\\npublic:\\n    void push(int x) {\\n        while(!minH.empty() && minH.back() > x) minH.pop_back();\\n        minH.push_back(x);\\n        \\n        while(!maxH.empty() && maxH.back() < x) maxH.pop_back();\\n        maxH.push_back(x);\\n    }\\n    \\n    void pop(int x) {\\n        if(x == minH.front()) minH.pop_front();\\n        if(x == maxH.front()) maxH.pop_front();\\n    }\\n    \\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int n = nums.size();\\n        int i=0, j=0, len=INT_MIN;\\n        \\n        while(j < n) {\\n            push(nums[j]);\\n            \\n            int mini = minH.front();\\n            int maxi = maxH.front();\\n            \\n            if(maxi-mini <= limit) {\\n                len = max(len, j-i+1);\\n            } \\n            else {\\n                pop(nums[i]);\\n                i++;\\n            }\\n            \\n            j++;\\n        }\\n        \\n        return len;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982410,
                "title": "python-o-n-solution-with-two-deques-and-inline-explanations",
                "content": "We use two techniques to solve this problem efficiently:\\n1. We use the two-pointer techniques to iterate over the subarrays in O(n) time.\\n2. We use two monotonic queues to maintain minimum and maximum of the subarray in constant time.\\n\\nThe solution is based on https://leetcode.com/problems/sliding-window-maximum/discuss/1982405/Python-O(n)-Solution-using-deque-and-inline-explenation\\n```python\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        n = len(nums)\\n        i = j = maxlen = 0\\n        \\n        # minq is a monotonically increasing queue\\n        # maxq is a monotonically decreasing queue\\n        # both queue store indices of the values\\n        minq, maxq = deque(), deque()\\n        maxlen = 0\\n        while j < n:\\n            # preserve the monotonicity of the minq\\n            while minq and nums[minq[-1]] > nums[j]:\\n                minq.pop()\\n            # NOTE: check if the index we are pushing is not already pushed\\n            if not minq or minq[-1] != j:\\n                minq.append(j)\\n            \\n            # preserve the monotonicity of the maxq\\n            while maxq and nums[maxq[-1]] < nums[j]:\\n                maxq.pop()\\n            # NOTE: ensure we don\\'t push duplicate indices\\n            if not maxq or maxq[-1] != j:\\n                maxq.append(j)\\n            \\n            # ensure minq and maxq don\\'t have elements out of range of [i, j]\\n            if i > minq[0]:\\n                minq.popleft()\\n            if i > maxq[0]:\\n                maxq.popleft()\\n            \\n            # update maxlen and increment i and j\\n            minval = nums[minq[0]]\\n            maxval = nums[maxq[0]]\\n            if maxval - minval <= limit:\\n\\t\\t\\t    # if the window is valid we move j to right\\n                maxlen = max(maxlen, j - i + 1)\\n                j += 1\\n            else:\\n\\t\\t\\t    # otherwise we shrink the window by moving i to the right\\n                i += 1\\n        \\n        return maxlen\\n```",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```python\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        n = len(nums)\\n        i = j = maxlen = 0\\n        \\n        # minq is a monotonically increasing queue\\n        # maxq is a monotonically decreasing queue\\n        # both queue store indices of the values\\n        minq, maxq = deque(), deque()\\n        maxlen = 0\\n        while j < n:\\n            # preserve the monotonicity of the minq\\n            while minq and nums[minq[-1]] > nums[j]:\\n                minq.pop()\\n            # NOTE: check if the index we are pushing is not already pushed\\n            if not minq or minq[-1] != j:\\n                minq.append(j)\\n            \\n            # preserve the monotonicity of the maxq\\n            while maxq and nums[maxq[-1]] < nums[j]:\\n                maxq.pop()\\n            # NOTE: ensure we don\\'t push duplicate indices\\n            if not maxq or maxq[-1] != j:\\n                maxq.append(j)\\n            \\n            # ensure minq and maxq don\\'t have elements out of range of [i, j]\\n            if i > minq[0]:\\n                minq.popleft()\\n            if i > maxq[0]:\\n                maxq.popleft()\\n            \\n            # update maxlen and increment i and j\\n            minval = nums[minq[0]]\\n            maxval = nums[maxq[0]]\\n            if maxval - minval <= limit:\\n\\t\\t\\t    # if the window is valid we move j to right\\n                maxlen = max(maxlen, j - i + 1)\\n                j += 1\\n            else:\\n\\t\\t\\t    # otherwise we shrink the window by moving i to the right\\n                i += 1\\n        \\n        return maxlen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688568,
                "title": "java-time-o-n-and-space-o-1-solution",
                "content": "Keep track of the max and min, and the value would be valid if value >= max - limit && value <= min + limit\\n\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int left = 0;\\n        int right = 1;\\n        int max = nums[0];\\n        int min = nums[0];\\n        int res = 1;\\n        while(right < nums.length){\\n            if(nums[right] >= max - limit && nums[right] <= min + limit){\\n                max = Math.max(max, nums[right]);\\n                min = Math.min(min, nums[right]);\\n            }else{\\n                res = Math.max(right - left, res);\\n                int index = right - 1;\\n                max = nums[right];\\n                min = nums[right];\\n                while(index >= left && nums[index] >= max - limit && nums[index] <= min + limit){\\n                    max = Math.max(max, nums[index]);\\n                    min = Math.min(min, nums[index]);\\n                    index--;\\n                }\\n                left = index+1;\\n            }\\n            right++;\\n        }\\n        res = Math.max(right - left, res);\\n        return res;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int left = 0;\\n        int right = 1;\\n        int max = nums[0];\\n        int min = nums[0];\\n        int res = 1;\\n        while(right < nums.length){\\n            if(nums[right] >= max - limit && nums[right] <= min + limit){\\n                max = Math.max(max, nums[right]);\\n                min = Math.min(min, nums[right]);\\n            }else{\\n                res = Math.max(right - left, res);\\n                int index = right - 1;\\n                max = nums[right];\\n                min = nums[right];\\n                while(index >= left && nums[index] >= max - limit && nums[index] <= min + limit){\\n                    max = Math.max(max, nums[index]);\\n                    min = Math.min(min, nums[index]);\\n                    index--;\\n                }\\n                left = index+1;\\n            }\\n            right++;\\n        }\\n        res = Math.max(right - left, res);\\n        return res;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625788,
                "title": "why-239-is-a-hard-problem-but-this-with-two-monotonic-queue-is-a-medium-problem",
                "content": "```\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        maxq=deque()\\n        minq=deque()\\n        start=0\\n        maxlen=0\\n        for end in range(len(nums)):\\n            num=nums[end]\\n            #update maxq\\n            while len(maxq)!=0 and maxq[-1][0]<=num:\\n                maxq.pop()\\n            maxq.append((num,end))\\n            \\n            #update minq\\n            while len(minq)!=0 and minq[-1][0]>=num:\\n                minq.pop()\\n            minq.append((num,end))\\n            \\n            #optimize start pointer\\n            while start<end and (maxq[0][0]-minq[0][0])>limit:\\n                if maxq[0]==(nums[start],start):\\n                    maxq.popleft()\\n                if minq[0]==(nums[start],start):\\n                    minq.popleft()\\n                start+=1\\n            maxlen=max(maxlen,end-start+1)\\n        return maxlen",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        maxq=deque()\\n        minq=deque()\\n        start=0\\n        maxlen=0\\n        for end in range(len(nums)):\\n            num=nums[end]\\n            #update maxq\\n            while len(maxq)!=0 and maxq[-1][0]<=num:\\n                maxq.pop()\\n            maxq.append((num,end))\\n            \\n            #update minq\\n            while len(minq)!=0 and minq[-1][0]>=num:\\n                minq.pop()\\n            minq.append((num,end))\\n            \\n            #optimize start pointer\\n            while start<end and (maxq[0][0]-minq[0][0])>limit:\\n                if maxq[0]==(nums[start],start):\\n                    maxq.popleft()\\n                if minq[0]==(nums[start],start):\\n                    minq.popleft()\\n                start+=1\\n            maxlen=max(maxlen,end-start+1)\\n        return maxlen",
                "codeTag": "Python3"
            },
            {
                "id": 1566434,
                "title": "c-priority-queue-easy-to-understand",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) \\n    {\\n        int l = nums.size();\\n        \\n        //for storing minimum element.\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> minn;\\n        \\n        //for storing maximum element.\\n        priority_queue<pair<int,int>> maxx;\\n        \\n        int st = 0; //starting index of subarray.\\n        int res = 1;\\n        \\n        minn.push({nums[0],0});\\n        maxx.push({nums[0],0});\\n        for(int i=1;i<l;i++)\\n        {\\n            //excluding elements which are not part of current sub array.\\n            while(!minn.empty() && minn.top().second < st)\\n                minn.pop();\\n            \\n            while(!maxx.empty() && maxx.top().second < st)\\n                maxx.pop();\\n            \\n            //if current index is start index.\\n            if(minn.empty() || maxx.empty())\\n            {\\n                minn.push({nums[i],i});\\n                maxx.push({nums[i],i});\\n                continue;\\n            }\\n            \\n            int mx = maxx.top().first;\\n            int mn = minn.top().first;\\n            \\n            //if absolute difference of element with max and min element is in the range than differance with other elements are also in the given range.\\n            if(abs(mx-nums[i]) <= limit && abs(mn-nums[i]) <= limit)\\n            {\\n                res = max(res,i-st+1);\\n                minn.push({nums[i],i});\\n                maxx.push({nums[i],i});\\n            }else\\n            {\\n                if(abs(mx-nums[i])>limit)\\n                    st = maxx.top().second+1;\\n                if(abs(mn-nums[i])>limit)\\n                    st = max(st,minn.top().second+1);\\n                \\n                //for checking current number again.\\n                i--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) \\n    {\\n        int l = nums.size();\\n        \\n        //for storing minimum element.\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> minn;\\n        \\n        //for storing maximum element.\\n        priority_queue<pair<int,int>> maxx;\\n        \\n        int st = 0; //starting index of subarray.\\n        int res = 1;\\n        \\n        minn.push({nums[0],0});\\n        maxx.push({nums[0],0});\\n        for(int i=1;i<l;i++)\\n        {\\n            //excluding elements which are not part of current sub array.\\n            while(!minn.empty() && minn.top().second < st)\\n                minn.pop();\\n            \\n            while(!maxx.empty() && maxx.top().second < st)\\n                maxx.pop();\\n            \\n            //if current index is start index.\\n            if(minn.empty() || maxx.empty())\\n            {\\n                minn.push({nums[i],i});\\n                maxx.push({nums[i],i});\\n                continue;\\n            }\\n            \\n            int mx = maxx.top().first;\\n            int mn = minn.top().first;\\n            \\n            //if absolute difference of element with max and min element is in the range than differance with other elements are also in the given range.\\n            if(abs(mx-nums[i]) <= limit && abs(mn-nums[i]) <= limit)\\n            {\\n                res = max(res,i-st+1);\\n                minn.push({nums[i],i});\\n                maxx.push({nums[i],i});\\n            }else\\n            {\\n                if(abs(mx-nums[i])>limit)\\n                    st = maxx.top().second+1;\\n                if(abs(mn-nums[i])>limit)\\n                    st = max(st,minn.top().second+1);\\n                \\n                //for checking current number again.\\n                i--;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566320,
                "title": "python-easy-to-understand-sliding-window-solution-using-queues",
                "content": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        minQueue = deque()\\n        maxQueue = deque()\\n        \\n        ans = 0\\n        l = 0\\n        for r in range(len(nums)):\\n            # removing max elements on the left\\n            while maxQueue and nums[maxQueue[-1]] < nums[r]:\\n                maxQueue.pop()\\n                \\n            maxQueue.append(r)\\n            \\n            # removing min elements on the left\\n            while minQueue and nums[minQueue[-1]] > nums[r]:\\n                minQueue.pop()\\n                \\n            minQueue.append(r)\\n            \\n            maxEl = nums[maxQueue[0]]\\n            minEl = nums[minQueue[0]]\\n            \\n            if abs(maxEl - minEl) <= limit:\\n                ans = max(ans, r-l+1)\\n            else:\\n                # shrink window\\n                if l == maxQueue[0]:\\n                    maxQueue.popleft()\\n                if l == minQueue[0]:\\n                    minQueue.popleft()\\n                    \\n                l += 1\\n        return ans \\n```\\n\\nO(n) time and O(n) space",
                "solutionTags": [
                    "Python",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        minQueue = deque()\\n        maxQueue = deque()\\n        \\n        ans = 0\\n        l = 0\\n        for r in range(len(nums)):\\n            # removing max elements on the left\\n            while maxQueue and nums[maxQueue[-1]] < nums[r]:\\n                maxQueue.pop()\\n                \\n            maxQueue.append(r)\\n            \\n            # removing min elements on the left\\n            while minQueue and nums[minQueue[-1]] > nums[r]:\\n                minQueue.pop()\\n                \\n            minQueue.append(r)\\n            \\n            maxEl = nums[maxQueue[0]]\\n            minEl = nums[minQueue[0]]\\n            \\n            if abs(maxEl - minEl) <= limit:\\n                ans = max(ans, r-l+1)\\n            else:\\n                # shrink window\\n                if l == maxQueue[0]:\\n                    maxQueue.popleft()\\n                if l == minQueue[0]:\\n                    minQueue.popleft()\\n                    \\n                l += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348131,
                "title": "java-solution-sliding-window-deque-o-n",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int j = -1,res = 0,n = nums.length;\\n        ArrayDeque<Integer> min = new ArrayDeque<>();\\n        ArrayDeque<Integer> max = new ArrayDeque<>();\\n        for(int i = 0;i<n;i++){\\n            while(!min.isEmpty() && nums[i] <= nums[min.peekLast()]) min.removeLast();\\n            while(!max.isEmpty() && nums[i] >= nums[max.peekLast()]) max.removeLast();\\n            min.addLast(i);\\n            max.addLast(i);\\n            while((nums[max.peekFirst()]-nums[min.peekFirst()]) > limit){\\n                if(max.peekFirst() < min.peekFirst()) j=max.removeFirst();\\n                else j = min.removeFirst();\\n            }\\n            res = Math.max(res,i-j);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int j = -1,res = 0,n = nums.length;\\n        ArrayDeque<Integer> min = new ArrayDeque<>();\\n        ArrayDeque<Integer> max = new ArrayDeque<>();\\n        for(int i = 0;i<n;i++){\\n            while(!min.isEmpty() && nums[i] <= nums[min.peekLast()]) min.removeLast();\\n            while(!max.isEmpty() && nums[i] >= nums[max.peekLast()]) max.removeLast();\\n            min.addLast(i);\\n            max.addLast(i);\\n            while((nums[max.peekFirst()]-nums[min.peekFirst()]) > limit){\\n                if(max.peekFirst() < min.peekFirst()) j=max.removeFirst();\\n                else j = min.removeFirst();\\n            }\\n            res = Math.max(res,i-j);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1060705,
                "title": "java-two-deques-to-keep-max-value-and-min-value-in-range",
                "content": "```\\n    public int longestSubarray(int[] nums, int limit) {\\n        if(nums.length == 1) return 1;\\n        Deque<Integer> maxQ = new LinkedList<>();\\n        Deque<Integer> minQ = new LinkedList<>();\\n\\n        int ans = 1;\\n        maxQ.add(nums[0]);\\n        minQ.add(nums[0]);\\n        for(int i = 0, j = 1; j < nums.length; j++) {\\n            while(!maxQ.isEmpty() && maxQ.peekLast() < nums[j]) maxQ.pollLast();\\n            maxQ.addLast(nums[j]);\\n\\n            while(!minQ.isEmpty() && minQ.peekLast() > nums[j]) minQ.pollLast();\\n            minQ.addLast(nums[j]);\\n\\n            while(maxQ.peekFirst() - minQ.peekFirst() > limit) {\\n                int val = nums[i];\\n                if(val == maxQ.peekFirst()) maxQ.pollFirst();\\n                if(val == minQ.peekFirst()) minQ.pollFirst();\\n                i++;\\n            }\\n            ans = Math.max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestSubarray(int[] nums, int limit) {\\n        if(nums.length == 1) return 1;\\n        Deque<Integer> maxQ = new LinkedList<>();\\n        Deque<Integer> minQ = new LinkedList<>();\\n\\n        int ans = 1;\\n        maxQ.add(nums[0]);\\n        minQ.add(nums[0]);\\n        for(int i = 0, j = 1; j < nums.length; j++) {\\n            while(!maxQ.isEmpty() && maxQ.peekLast() < nums[j]) maxQ.pollLast();\\n            maxQ.addLast(nums[j]);\\n\\n            while(!minQ.isEmpty() && minQ.peekLast() > nums[j]) minQ.pollLast();\\n            minQ.addLast(nums[j]);\\n\\n            while(maxQ.peekFirst() - minQ.peekFirst() > limit) {\\n                int val = nums[i];\\n                if(val == maxQ.peekFirst()) maxQ.pollFirst();\\n                if(val == minQ.peekFirst()) minQ.pollFirst();\\n                i++;\\n            }\\n            ans = Math.max(ans, j - i + 1);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1004933,
                "title": "from-o-log-n-n-2-to-o-log-n-n-to-o-n",
                "content": "Forgive my java style C++ as I\\'m learning C++ for my current project. My first try to this question is brute force with some optimization using binary search. The time complexity is O(Log(N)*N^2) and as expected I got TLE.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int left = 1;\\n        int right = nums.size();\\n        while (left <= right) {\\n            int mid = left + (right-left)/2;\\n            if (valid(nums, limit, mid)) {\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n    \\n    bool valid(vector<int>& nums, int limit, int wSize) {\\n        for (int start = 0; start <= nums.size()-wSize; start++) {\\n            int sm = nums[start];\\n            int lg = nums[start];\\n            for (int i = 0; i < wSize; i++) {\\n                sm = min(sm, nums[start+i]);\\n                lg = max(lg, nums[start+i]);\\n            }\\n            if (lg-sm <= limit) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nSince what we care about is the max and min element in a window, we can leverage the deque to make valid check O(N), which improved the time complexity to O(Log(N)*N) and get me passed.\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int left = 1;\\n        int right = nums.size();\\n        while (left <= right) {\\n            int mid = left + (right-left)/2;\\n            if (valid(nums, limit, mid)) {\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n    \\n    bool valid(vector<int>& nums, int limit, int wSize) {\\n        deque<int> maxQ;\\n        deque<int> minQ;\\n        for (int i = 0; i < nums.size(); i++) {\\n            while (!maxQ.empty() && i-maxQ.front() >= wSize) {\\n                maxQ.pop_front();\\n            }\\n            while (!maxQ.empty() && nums[i] >= nums[maxQ.back()]) {\\n                maxQ.pop_back();\\n            }\\n            maxQ.push_back(i);\\n            while (!minQ.empty() && i-minQ.front() >= wSize) {\\n                minQ.pop_front();\\n            }  \\n            while (!minQ.empty() && nums[i] <= nums[minQ.back()]) {\\n                minQ.pop_back();\\n            }  \\n            minQ.push_back(i);\\n            if (i >= wSize-1 && nums[maxQ.front()]-nums[minQ.front()] <= limit) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\\n\\nTo improve it further, we can use max and min heap and do sliding window, which won\\'t improve the time complexity too much in the worst case. My next thought is that probably we can leverage the same deque data structure to maintain a window, which leads to the O(N) solution:\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int ret = 0;\\n        deque<int> maxQ;\\n        deque<int> minQ;\\n        int left = 0;\\n        for (int right = 0; right < nums.size(); right++) {\\n            while (!maxQ.empty() && nums[right] >= nums[maxQ.back()]) {\\n                maxQ.pop_back();\\n            }\\n            maxQ.push_back(right);  \\n            while (!minQ.empty() && nums[right] <= nums[minQ.back()]) {\\n                minQ.pop_back();\\n            }  \\n            minQ.push_back(right);\\n            while (nums[maxQ.front()]-nums[minQ.front()] > limit) {\\n                while (!maxQ.empty() && maxQ.front() <= left) {\\n                    maxQ.pop_front();\\n                }\\n                while (!minQ.empty() && minQ.front() <= left) {\\n                    minQ.pop_front();\\n                }\\n                left++;\\n            }\\n            ret = max(ret, right-left+1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int left = 1;\\n        int right = nums.size();\\n        while (left <= right) {\\n            int mid = left + (right-left)/2;\\n            if (valid(nums, limit, mid)) {\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n    \\n    bool valid(vector<int>& nums, int limit, int wSize) {\\n        for (int start = 0; start <= nums.size()-wSize; start++) {\\n            int sm = nums[start];\\n            int lg = nums[start];\\n            for (int i = 0; i < wSize; i++) {\\n                sm = min(sm, nums[start+i]);\\n                lg = max(lg, nums[start+i]);\\n            }\\n            if (lg-sm <= limit) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int left = 1;\\n        int right = nums.size();\\n        while (left <= right) {\\n            int mid = left + (right-left)/2;\\n            if (valid(nums, limit, mid)) {\\n                left = mid+1;\\n            } else {\\n                right = mid-1;\\n            }\\n        }\\n        return right;\\n    }\\n    \\n    bool valid(vector<int>& nums, int limit, int wSize) {\\n        deque<int> maxQ;\\n        deque<int> minQ;\\n        for (int i = 0; i < nums.size(); i++) {\\n            while (!maxQ.empty() && i-maxQ.front() >= wSize) {\\n                maxQ.pop_front();\\n            }\\n            while (!maxQ.empty() && nums[i] >= nums[maxQ.back()]) {\\n                maxQ.pop_back();\\n            }\\n            maxQ.push_back(i);\\n            while (!minQ.empty() && i-minQ.front() >= wSize) {\\n                minQ.pop_front();\\n            }  \\n            while (!minQ.empty() && nums[i] <= nums[minQ.back()]) {\\n                minQ.pop_back();\\n            }  \\n            minQ.push_back(i);\\n            if (i >= wSize-1 && nums[maxQ.front()]-nums[minQ.front()] <= limit) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int ret = 0;\\n        deque<int> maxQ;\\n        deque<int> minQ;\\n        int left = 0;\\n        for (int right = 0; right < nums.size(); right++) {\\n            while (!maxQ.empty() && nums[right] >= nums[maxQ.back()]) {\\n                maxQ.pop_back();\\n            }\\n            maxQ.push_back(right);  \\n            while (!minQ.empty() && nums[right] <= nums[minQ.back()]) {\\n                minQ.pop_back();\\n            }  \\n            minQ.push_back(right);\\n            while (nums[maxQ.front()]-nums[minQ.front()] > limit) {\\n                while (!maxQ.empty() && maxQ.front() <= left) {\\n                    maxQ.pop_front();\\n                }\\n                while (!minQ.empty() && minQ.front() <= left) {\\n                    minQ.pop_front();\\n                }\\n                left++;\\n            }\\n            ret = max(ret, right-left+1);\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 970514,
                "title": "python-deque",
                "content": "This method uses two deques\\n\\n1). Queue with indexes of max values stores the maximum value between left and right pointers:\\n\\neg. [10,1,2,1,9]\\n[10] => when the left pointer at index 0 and right pointer at index 0, what\\'s the max(max =10). \\n\\n[10, 1] => when the right pointer at index 1, what\\'s the max when left pointer at index 0 (max =10) and at index 1(max = 1)\\n\\n[10, 2, 2] => when the right pointer at index 2, what\\'s the max when left pointer at index 0 (max =10), at index 1(max = 2) and at index 2(=2)\\n\\n[10, 2, 2,1] => when the right pointer at index 3, what\\'s the max when left pointer at index 0 (max =10), at index 1(max = 2), at index 2(max =2) and at index 3(max = 1)\\n\\n[10, 9, 9, 9, 9] ...\\n\\nA simpler way to record the change is to store the index of maximum values. Each of the element j in the simplified queue means: the maximum value is nums[max_cur_queue[j]] for any subsequence starts from index max_cur_queue[j-1] + 1 to max_cur_queue[j],  and end with index max_cur_queue[j]\\n\\n[10, 1]   =>   [0, 1]\\n\\n[10, 2, 2]  =>[0, 2]\\n\\n[10, 2,2,1] => [0,2,3]\\n\\n[10, 9, 9, 9, 9]  =>[0,4]\\n\\nTo get this index list: while cur value is larger than the value queue[-1] point to, pop out the value in queue until the value queue[-1] point to is no longer smaller than cur, and then attach the current index. If cur value smaller than last value in the queue, attach the value to the queue directly.\\n\\n\\n\\n2). Do the same thing for min queue:\\n\\n[10] =>  [0]\\n\\n[1,1]  =>  [1]\\n\\n[1,1,2]  =>  [1,2]\\n\\n[1, 1, 2, 20]  =>  [1,2,3]\\n\\nwhile cur value is smaller than queue[-1] point to, pop out the last element in queue until no longer smaller, and append cur index to the queue\\n\\nIf cue value is larger than queue[-1] index to, append the cut index to the queue\\n\\n\\n3). if current max-min > limit, move left pointer forward until max-min <= limit. Meanwhile, if left pointer is larger than the first index in cur_max_queue or cur_min_queue, simply do a left pop of the queue.\\n\\n```\\nfrom collections import deque\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        left = 0\\n        right = 1\\n        cur_max = deque([0])\\n        cur_min = deque([0])\\n        max_count = 1\\n        while left <= right and right < len(nums):\\n            cur = nums[right]\\n            \\n            if cur < nums[cur_min[-1]]:\\n                while cur_min and nums[cur_min[-1]] > cur:\\n                    cur_min.pop()\\n                \\n            elif cur > nums[cur_max[-1]]:\\n                while cur_max and nums[cur_max[-1]] < cur:\\n                    cur_max.pop()\\n                    \\n            cur_max.append(right)\\n            cur_min.append(right)\\n            \\n            while nums[cur_max[0]] - nums[cur_min[0]] > limit:\\n                left += 1\\n                if left > cur_min[0]:\\n                    cur_min.popleft()\\n                if left > cur_max[0]:\\n                    cur_max.popleft()\\n            \\n            max_count = max(max_count, right - left + 1)\\n            right += 1\\n        return max_count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue"
                ],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        left = 0\\n        right = 1\\n        cur_max = deque([0])\\n        cur_min = deque([0])\\n        max_count = 1\\n        while left <= right and right < len(nums):\\n            cur = nums[right]\\n            \\n            if cur < nums[cur_min[-1]]:\\n                while cur_min and nums[cur_min[-1]] > cur:\\n                    cur_min.pop()\\n                \\n            elif cur > nums[cur_max[-1]]:\\n                while cur_max and nums[cur_max[-1]] < cur:\\n                    cur_max.pop()\\n                    \\n            cur_max.append(right)\\n            cur_min.append(right)\\n            \\n            while nums[cur_max[0]] - nums[cur_min[0]] > limit:\\n                left += 1\\n                if left > cur_min[0]:\\n                    cur_min.popleft()\\n                if left > cur_max[0]:\\n                    cur_max.popleft()\\n            \\n            max_count = max(max_count, right - left + 1)\\n            right += 1\\n        return max_count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 967160,
                "title": "concise-java-solution-using-treemap-and-two-pointers",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        \\n        int result = 1, n = nums.length, i = 0;\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>(); // <number, last index>\\n        \\n        for (int j = 0; j < n; j++)\\n        {\\n            treeMap.put(nums[j], j);\\n            \\n            // The newly added number is max or min number if > limit\\n            while (treeMap.lastKey() - treeMap.firstKey() > limit)\\n            {\\n                // Remove the min number if the newly added number is the max number\\n                if (nums[j] == treeMap.lastKey())\\n                {\\n                    int minIdx = treeMap.pollFirstEntry().getValue(); // Index of the min numbers\\n                    i = Math.max(i, minIdx + 1);\\n                }\\n                else // Remove the max number if the newly added number is the min number\\n                {\\n                    int maxIdx = treeMap.pollLastEntry().getValue(); // Index of the max numbers\\n                    i = Math.max(i, maxIdx + 1);\\n                }\\n            }\\n            \\n            result = Math.max(result, j-i+1);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        \\n        int result = 1, n = nums.length, i = 0;\\n        TreeMap<Integer, Integer> treeMap = new TreeMap<>(); // <number, last index>\\n        \\n        for (int j = 0; j < n; j++)\\n        {\\n            treeMap.put(nums[j], j);\\n            \\n            // The newly added number is max or min number if > limit\\n            while (treeMap.lastKey() - treeMap.firstKey() > limit)\\n            {\\n                // Remove the min number if the newly added number is the max number\\n                if (nums[j] == treeMap.lastKey())\\n                {\\n                    int minIdx = treeMap.pollFirstEntry().getValue(); // Index of the min numbers\\n                    i = Math.max(i, minIdx + 1);\\n                }\\n                else // Remove the max number if the newly added number is the min number\\n                {\\n                    int maxIdx = treeMap.pollLastEntry().getValue(); // Index of the max numbers\\n                    i = Math.max(i, maxIdx + 1);\\n                }\\n            }\\n            \\n            result = Math.max(result, j-i+1);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 949799,
                "title": "sliding-window-pq-deque-c-solution",
                "content": "(1) Priority Queue T-O(NLogN), S-O(N)\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int n=nums.size();\\n        priority_queue<pair<int, int>> max_heap;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> min_heap;\\n        \\n        int left=0, ans=0;\\n        for(int right=0; right<n; right++){\\n            max_heap.push({nums[right], right});\\n            min_heap.push({nums[right], right});\\n            \\n            while(max_heap.top().first-min_heap.top().first>limit){\\n                left++;\\n                while(!max_heap.empty() && max_heap.top().second<left)\\n                    max_heap.pop();\\n\\n                while(!min_heap.empty() && min_heap.top().second<left)\\n                    min_heap.pop();\\n            }\\n            \\n            ans = max(ans, right-left+1);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\n\\nAlgorithm Outline:\\n1. maxheap & minheap for end points with indexes. If out of range, remove them\\n2. sliding window, take max\\n\\n*/\\n```\\n(2) 2 Deques T-O(N), S-O(N)\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int n=nums.size();\\n        deque<pair<int, int>> max_dq, min_dq;\\n        \\n        int left=0, ans=0;\\n        for(int right=0; right<n; right++){\\n            while(!max_dq.empty() && max_dq.back().first<=nums[right])\\n                max_dq.pop_back();\\n\\n            while(!min_dq.empty() && min_dq.back().first>=nums[right])\\n                min_dq.pop_back();\\n            \\n            max_dq.push_back({nums[right], right});\\n            min_dq.push_back({nums[right], right});\\n            \\n            while(max_dq.front().first-min_dq.front().first>limit){\\n                left++;\\n                while(!max_dq.empty() && max_dq.front().second<left)\\n                    max_dq.pop_front();\\n\\n                while(!min_dq.empty() && min_dq.front().second<left)\\n                    min_dq.pop_front();\\n            }\\n            \\n            ans = max(ans, right-left+1);\\n        }\\n        return ans;\\n    }\\n};\\n```\\nI appreciate your upvote !!",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int n=nums.size();\\n        priority_queue<pair<int, int>> max_heap;\\n        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> min_heap;\\n        \\n        int left=0, ans=0;\\n        for(int right=0; right<n; right++){\\n            max_heap.push({nums[right], right});\\n            min_heap.push({nums[right], right});\\n            \\n            while(max_heap.top().first-min_heap.top().first>limit){\\n                left++;\\n                while(!max_heap.empty() && max_heap.top().second<left)\\n                    max_heap.pop();\\n\\n                while(!min_heap.empty() && min_heap.top().second<left)\\n                    min_heap.pop();\\n            }\\n            \\n            ans = max(ans, right-left+1);\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\n\\nAlgorithm Outline:\\n1. maxheap & minheap for end points with indexes. If out of range, remove them\\n2. sliding window, take max\\n\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int n=nums.size();\\n        deque<pair<int, int>> max_dq, min_dq;\\n        \\n        int left=0, ans=0;\\n        for(int right=0; right<n; right++){\\n            while(!max_dq.empty() && max_dq.back().first<=nums[right])\\n                max_dq.pop_back();\\n\\n            while(!min_dq.empty() && min_dq.back().first>=nums[right])\\n                min_dq.pop_back();\\n            \\n            max_dq.push_back({nums[right], right});\\n            min_dq.push_back({nums[right], right});\\n            \\n            while(max_dq.front().first-min_dq.front().first>limit){\\n                left++;\\n                while(!max_dq.empty() && max_dq.front().second<left)\\n                    max_dq.pop_front();\\n\\n                while(!min_dq.empty() && min_dq.front().second<left)\\n                    min_dq.pop_front();\\n            }\\n            \\n            ans = max(ans, right-left+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882001,
                "title": "java-two-pointers-o-n-solution-faster-than-100",
                "content": "Thanks to this video https://www.youtube.com/watch?v=LDFZm4iB7tA\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        int i = 0, j = 0;\\n        int res = 0;\\n        while (j < nums.length && i <= j) {\\n            min = Math.min(min, nums[j]);\\n            max = Math.max(max, nums[j]);\\n            if (max - min <= limit) {\\n                res = Math.max(res, j - i + 1);\\n                j++;\\n            }\\n            else {\\n                if (res - 1 > nums.length - j) break;\\n                int k = j;\\n                int preMax = max = nums[j];\\n                int preMin = min = nums[j];\\n                while (k >= i && max - min <= limit) {\\n                    preMax = max;\\n                    preMin = min;\\n                    max = Math.max(max, nums[k]);\\n                    min = Math.min(min, nums[k]);\\n                    k--;\\n                }\\n                i = k + 2;\\n                max = preMax;\\n                min = preMin;\\n            }\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int min = Integer.MAX_VALUE, max = Integer.MIN_VALUE;\\n        int i = 0, j = 0;\\n        int res = 0;\\n        while (j < nums.length && i <= j) {\\n            min = Math.min(min, nums[j]);\\n            max = Math.max(max, nums[j]);\\n            if (max - min <= limit) {\\n                res = Math.max(res, j - i + 1);\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 750219,
                "title": "c-sliding-windows",
                "content": "Have a sliding window that expands to the right and get shrinked from the left when it doesnt satisfy the condition\\nex:\\n[8] size: 1\\n[8,2] invalid\\n    [2] size: 1\\n\\t[2,4] size: 2\\n\\t[2,4,7] invalid\\n\\t    [4,7] size: 2\\n\\nreturn size 2\\n```\\npublic class Solution {\\n    public int LongestSubarray(int[] nums, int limit) {\\n        var left=0;\\n        var idx=0;\\n        var size = 0;\\n        var map = new MinMaxDictionary();\\n        \\n        while(idx < nums.Length) {\\n            // Add the element in the map\\n            map.Add(nums[idx]);\\n            \\n            // Get min and max values\\n            int minWin = map.Min();\\n            int maxWin = map.Max();\\n            \\n            // Check if the absolute diff is within the limit, \\n            // else move the windows one element to the right\\n            if(Math.Abs(minWin-maxWin) <= limit) {\\n                size = Math.Max(size, idx-left+1);\\n            } else {\\n                map.Remove(nums[left]);\\n                left++;\\n            }\\n            \\n            idx++;\\n        }\\n        \\n        return size;\\n    }\\n    \\n    // Helper class to get the min and max in the dictionary\\n    public class MinMaxDictionary {\\n        public Dictionary<int, int> map;\\n        \\n        public MinMaxDictionary() {\\n            map = new Dictionary<int, int>();\\n        }\\n        \\n        public int Min() {\\n            return map.Keys.Min();\\n        }\\n        \\n        public int Max() {\\n            return map.Keys.Max();\\n        }\\n        \\n        public void Add(int val) {\\n            if(!map.ContainsKey(val))\\n                map.Add(val, 0);\\n            map[val]++;\\n        }\\n        \\n        public void Remove(int val) {\\n            if(map.ContainsKey(val)) {\\n                map[val]--;\\n                if(map[val] == 0)\\n                    map.Remove(val);\\n            }\\n                \\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LongestSubarray(int[] nums, int limit) {\\n        var left=0;\\n        var idx=0;\\n        var size = 0;\\n        var map = new MinMaxDictionary();\\n        \\n        while(idx < nums.Length) {\\n            // Add the element in the map\\n            map.Add(nums[idx]);\\n            \\n            // Get min and max values\\n            int minWin = map.Min();\\n            int maxWin = map.Max();\\n            \\n            // Check if the absolute diff is within the limit, \\n            // else move the windows one element to the right\\n            if(Math.Abs(minWin-maxWin) <= limit) {\\n                size = Math.Max(size, idx-left+1);\\n            } else {\\n                map.Remove(nums[left]);\\n                left++;\\n            }\\n            \\n            idx++;\\n        }\\n        \\n        return size;\\n    }\\n    \\n    // Helper class to get the min and max in the dictionary\\n    public class MinMaxDictionary {\\n        public Dictionary<int, int> map;\\n        \\n        public MinMaxDictionary() {\\n            map = new Dictionary<int, int>();\\n        }\\n        \\n        public int Min() {\\n            return map.Keys.Min();\\n        }\\n        \\n        public int Max() {\\n            return map.Keys.Max();\\n        }\\n        \\n        public void Add(int val) {\\n            if(!map.ContainsKey(val))\\n                map.Add(val, 0);\\n            map[val]++;\\n        }\\n        \\n        public void Remove(int val) {\\n            if(map.ContainsKey(val)) {\\n                map[val]--;\\n                if(map[val] == 0)\\n                    map.Remove(val);\\n            }\\n                \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 739993,
                "title": "c-short",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        multiset <int, greater <int> > ms;       \\n        int res = 1;\\n        int left = 0;\\n        int right = 0;\\n            while(right < nums.size()){\\n                ms.insert(nums[right++]);\\n                 while(abs(*ms.begin() - *ms.rbegin()) > limit){\\n                        ms.erase(ms.find(nums[left++])); \\n                }\\n                res = max(res, right - left);\\n            }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        multiset <int, greater <int> > ms;       \\n        int res = 1;\\n        int left = 0;\\n        int right = 0;\\n            while(right < nums.size()){\\n                ms.insert(nums[right++]);\\n                 while(abs(*ms.begin() - *ms.rbegin()) > limit){\\n                        ms.erase(ms.find(nums[left++])); \\n                }\\n                res = max(res, right - left);\\n            }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 728178,
                "title": "python-deque-based-solution-o-n-tc",
                "content": "from collections import deque\\n\\nclass Solution(object):\\n    def longestSubarray(self, nums, limit):\\n  \\n        \\n        min_q = deque()\\n        max_q = deque()\\n        \\n        i = 0\\n        \\n        for item in nums:\\n        \\n        \\n            while(len(min_q)>0 and min_q[-1]>item):\\n                min_q.pop()\\n                \\n            while(len(max_q)>0 and max_q[-1]<item):\\n                max_q.pop()\\n                \\n            min_q.append(item)\\n            max_q.append(item)\\n            \\n            \\n            if max_q[0] - min_q[0] > limit:\\n                if min_q[0] == nums[i]:\\n                    min_q.popleft()\\n                    \\n                if max_q[0] == nums[i]:\\n                    max_q.popleft()\\n                    \\n                i+=1\\n                \\n                \\n        return len(nums)-i\\n",
                "solutionTags": [],
                "code": "from collections import deque\\n\\nclass Solution(object):\\n    def longestSubarray(self, nums, limit):\\n  \\n        \\n        min_q = deque()\\n        max_q = deque()\\n        \\n        i = 0\\n        \\n        for item in nums:\\n        \\n        \\n            while(len(min_q)>0 and min_q[-1]>item):\\n                min_q.pop()\\n                \\n            while(len(max_q)>0 and max_q[-1]<item):\\n                max_q.pop()\\n                \\n            min_q.append(item)\\n            max_q.append(item)\\n            \\n            \\n            if max_q[0] - min_q[0] > limit:\\n                if min_q[0] == nums[i]:\\n                    min_q.popleft()\\n                    \\n                if max_q[0] == nums[i]:\\n                    max_q.popleft()\\n                    \\n                i+=1\\n                \\n                \\n        return len(nums)-i\\n",
                "codeTag": "Java"
            },
            {
                "id": 703069,
                "title": "java-5ms-97-time-o-1-space-solution",
                "content": "### intuition:  \\nThe idea is to traverse forward through the array whilst keeping the maximum and minimum values (max and min), and make sure that the difference between them is always less than or equal to Limit. \\nWhen running into a number which contradicts this logic, counter is set back to value 1 (Which is the lowest possible answer), and we\\'ll have to traverse through the array backwards and take into account numbers that we might have missed on, that were present earlier in the iteration, or else we won\\'t get the actual result.\\n\\nThis is best demonstrated when running into an array like **[10,1,2,4,7,2]**, with **Limit=5** :  \\nin this case, we\\'ll start with \\'10\\' as our max and min, iterate to \\'1\\', and since the difference is 9 which is bigger than Limit, We\\'ll continue the iteration when now both our Max and Min values are \\'1\\'.\\nContinue iterating through \\'2\\' and \\'4\\', and now our counter value is at \\'3\\' - BUT when running into \\'7\\', min\\'s value is still \\'1\\', and max\\'s value is 7.\\nThe difference between them is 6 which is bigger than Limit\\'s 5, so we\\'ll set counter back to default value, and set 7 as both our Max and Min values and continue iterating forward.\\nHold on - but what about \\'2\\' and \\'4\\' who came before \\'7\\' but also needs to be taken into account?\\nTherefore, we\\'ll have to traverse BACKWARDS using integer \\'j\\' as long as the previous number doesn\\'t break our condition regarding Limit, and increment counter accordingly.\\nAfter we\\'re done with the backwards iteration, we\\'ll just continue iterating forward from the same place we left off as long as the condition applies, until we finish the loop.\\n\\nFINALLY, if we happen to run into a number which breaks our condition but the current \\'ans\\'  variable is bigger than the length of what\\'s left to iterate, we\\'ll just break from the loop, and return the correct result.\\n\\n```\\n\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int ans = 1;\\n        int counter = 0;\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int i=0; i<nums.length; i++){ \\n            max = Math.max(max,nums[i]);\\n            min = Math.min(min,nums[i]);\\n            if(max-min<=limit){ //Forward iteration as long as the condition applies\\n                counter++;\\n                ans = Math.max(counter, ans);   \\n            }\\n            else{ \\n                if(ans-1 > nums.length-i) break;\\n\\t\\t\\t\\tmax = nums[i];\\n                min = nums[i];\\n                int j = i;\\n                counter = 1;        \\n\\t\\t\\t\\t//Backwards iteration to take into account the numbers we might have missed on\\n                while(--j>=0 && Math.abs(max-nums[j])<=limit & Math.abs(min-nums[j])<=limit){\\n                    max = Math.max(max,nums[j]);\\n                    min = Math.min(min,nums[j]);\\n                    counter++;                                        \\n                }\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int ans = 1;\\n        int counter = 0;\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        \\n        for(int i=0; i<nums.length; i++){ \\n            max = Math.max(max,nums[i]);\\n            min = Math.min(min,nums[i]);\\n            if(max-min<=limit){ //Forward iteration as long as the condition applies\\n                counter++;\\n                ans = Math.max(counter, ans);   \\n            }\\n            else{ \\n                if(ans-1 > nums.length-i) break;\\n\\t\\t\\t\\tmax = nums[i];\\n                min = nums[i];\\n                int j = i;\\n                counter = 1;        \\n\\t\\t\\t\\t//Backwards iteration to take into account the numbers we might have missed on\\n                while(--j>=0 && Math.abs(max-nums[j])<=limit & Math.abs(min-nums[j])<=limit){\\n                    max = Math.max(max,nums[j]);\\n                    min = Math.min(min,nums[j]);\\n                    counter++;                                        \\n                }\\n            }\\n        }\\n       \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 622260,
                "title": "readable-sliding-windows-solution-on-c",
                "content": "```\\n  public int LongestSubarray(int[] nums, int limit)\\n      {\\n         var sortedItems = new List<int>() {nums[0]};\\n         int min = nums[0], max = nums[0], maxLen = 1, currLen = 1, firstIndex = 0;\\n\\n         for (int i = 1; i < nums.Length; i++)\\n         {\\n            min = Math.Min(min, nums[i]);\\n            max = Math.Max(max, nums[i]);\\n            Add(nums[i]);\\n            currLen++;\\n            while (max - min > limit)\\n            {\\n               //Removing nums[firstIndex] from sorted list\\n               int ind = sortedItems.BinarySearch(nums[firstIndex]);\\n               sortedItems.RemoveAt(ind);\\n               min = sortedItems[0];\\n               max = sortedItems[sortedItems.Count - 1];\\n               firstIndex++;\\n               currLen--;\\n            }\\n\\n            maxLen = Math.Max(currLen, maxLen);\\n         }\\n         \\n         return maxLen;\\n         \\n         //Add with Binary Search\\n         void Add(int num)\\n         {\\n            int st = 0, end = sortedItems.Count - 1;\\n            while (st < end)\\n            {\\n               int mid = (st + end) / 2;\\n               if (sortedItems[mid] > num)\\n                  end = mid - 1;\\n               else st = mid + 1;\\n            }\\n\\n            if (sortedItems[st] > num)\\n               sortedItems.Insert(st, num);\\n            else sortedItems.Insert(st + 1, num);\\n         }\\n      }\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\n  public int LongestSubarray(int[] nums, int limit)\\n      {\\n         var sortedItems = new List<int>() {nums[0]};\\n         int min = nums[0], max = nums[0], maxLen = 1, currLen = 1, firstIndex = 0;\\n\\n         for (int i = 1; i < nums.Length; i++)\\n         {\\n            min = Math.Min(min, nums[i]);\\n            max = Math.Max(max, nums[i]);\\n            Add(nums[i]);\\n            currLen++;\\n            while (max - min > limit)\\n            {\\n               //Removing nums[firstIndex] from sorted list\\n               int ind = sortedItems.BinarySearch(nums[firstIndex]);\\n               sortedItems.RemoveAt(ind);\\n               min = sortedItems[0];\\n               max = sortedItems[sortedItems.Count - 1];\\n               firstIndex++;\\n               currLen--;\\n            }\\n\\n            maxLen = Math.Max(currLen, maxLen);\\n         }\\n         \\n         return maxLen;\\n         \\n         //Add with Binary Search\\n         void Add(int num)\\n         {\\n            int st = 0, end = sortedItems.Count - 1;\\n            while (st < end)\\n            {\\n               int mid = (st + end) / 2;\\n               if (sortedItems[mid] > num)\\n                  end = mid - 1;\\n               else st = mid + 1;\\n            }\\n\\n            if (sortedItems[st] > num)\\n               sortedItems.Insert(st, num);\\n            else sortedItems.Insert(st + 1, num);\\n         }\\n      }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 622024,
                "title": "using-min-max-and-simple-array-navigation-o-nlogn",
                "content": "```\\n    public static int longestSubarray2(int[] nums, int limit) {\\n        int longestSeq = 0;\\n        int seq = 0;\\n        int min = nums[0], max = nums[0];\\n        int minIndex = 0, maxIndex = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (min >= nums[i]) {\\n                min = nums[i];\\n                minIndex = i;\\n            }\\n            if (max <= nums[i]) {\\n                max = nums[i];\\n                maxIndex = i;\\n            }\\n            if (Math.abs(min - max) <= limit) {\\n                seq++;\\n            }\\n            else {\\n                longestSeq = Math.max(longestSeq, seq);\\n                // The sequence is broken due to min or max value.\\n                // So starting from the next number from the minimum index of these two so that we don\\'t miss any sequence.\\n                i = Math.min(minIndex, maxIndex);\\n\\n                // Resetting variables.\\n                seq = 0;\\n                min = max = nums[i + 1];\\n                minIndex = maxIndex = i + 1;\\n            }\\n        }\\n        return Math.max(longestSeq, seq);\\n    }",
                "solutionTags": [],
                "code": "```\\n    public static int longestSubarray2(int[] nums, int limit) {\\n        int longestSeq = 0;\\n        int seq = 0;\\n        int min = nums[0], max = nums[0];\\n        int minIndex = 0, maxIndex = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            if (min >= nums[i]) {\\n                min = nums[i];\\n                minIndex = i;\\n            }\\n            if (max <= nums[i]) {\\n                max = nums[i];\\n                maxIndex = i;\\n            }\\n            if (Math.abs(min - max) <= limit) {\\n                seq++;\\n            }\\n            else {\\n                longestSeq = Math.max(longestSeq, seq);\\n                // The sequence is broken due to min or max value.\\n                // So starting from the next number from the minimum index of these two so that we don\\'t miss any sequence.\\n                i = Math.min(minIndex, maxIndex);\\n\\n                // Resetting variables.\\n                seq = 0;\\n                min = max = nums[i + 1];\\n                minIndex = maxIndex = i + 1;\\n            }\\n        }\\n        return Math.max(longestSeq, seq);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 611271,
                "title": "java-sliding-window-w-heaps",
                "content": "```\\npublic int longestSubarray(int[] nums, int limit) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>((a,b) -> (b-a));\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>((a,b) -> (a-b));\\n        int max = 0;\\n        int sub_length = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            while(sub_length > 0 && (Math.abs(nums[i] - maxHeap.peek()) > limit || Math.abs(nums[i] - minHeap.peek()) > limit)){\\n                int removed = nums[i - sub_length];\\n                sub_length--;\\n                maxHeap.remove(removed);\\n                minHeap.remove(removed);\\n            }\\n            sub_length++;\\n            maxHeap.add(nums[i]);\\n            minHeap.add(nums[i]);\\n            max = Math.max(max,sub_length);\\n        }\\n        return max;\\n}",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\npublic int longestSubarray(int[] nums, int limit) {\\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<Integer>((a,b) -> (b-a));\\n        PriorityQueue<Integer> minHeap = new PriorityQueue<Integer>((a,b) -> (a-b));\\n        int max = 0;\\n        int sub_length = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            while(sub_length > 0 && (Math.abs(nums[i] - maxHeap.peek()) > limit || Math.abs(nums[i] - minHeap.peek()) > limit)){\\n                int removed = nums[i - sub_length];\\n                sub_length--;\\n                maxHeap.remove(removed);\\n                minHeap.remove(removed);\\n            }\\n            sub_length++;\\n            maxHeap.add(nums[i]);\\n            minHeap.add(nums[i]);\\n            max = Math.max(max,sub_length);\\n        }\\n        return max;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 609839,
                "title": "java-use-mono-queue",
                "content": "Use 2 deques to store sliding window minimum and sliding window maximum,\\nThe subproblem is https://leetcode.com/problems/sliding-window-maximum/.\\nAlso, I do not think this should be marked as medium.\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int l = 0, ans = 1;\\n        Deque<Integer> subMax = new ArrayDeque<>(), subMin = new ArrayDeque<>();\\n        subMax.offerFirst(0);\\n        subMin.offerFirst(0);\\n        for (int i = 1; i < nums.length; ++i) {\\n            while (!subMax.isEmpty() && nums[i] > nums[subMax.peekLast()]) {\\n                subMax.pollLast();\\n            }\\n            subMax.offerLast(i);\\n            while (!subMin.isEmpty() && nums[i] < nums[subMin.peekLast()]) {\\n                subMin.pollLast();\\n            }\\n            subMin.offerLast(i);\\n            if (nums[subMax.peekFirst()] - nums[subMin.peekFirst()] <= limit) {\\n                ans = Math.max(i - l + 1, ans);\\n            } else {\\n                while (nums[subMax.peekFirst()] - nums[subMin.peekFirst()] > limit) {\\n                    if (subMax.peekFirst() < subMin.peekFirst()) {\\n                        l = 1 + subMax.pollFirst();\\n                    } else {\\n                        l = 1 + subMin.pollFirst();\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int l = 0, ans = 1;\\n        Deque<Integer> subMax = new ArrayDeque<>(), subMin = new ArrayDeque<>();\\n        subMax.offerFirst(0);\\n        subMin.offerFirst(0);\\n        for (int i = 1; i < nums.length; ++i) {\\n            while (!subMax.isEmpty() && nums[i] > nums[subMax.peekLast()]) {\\n                subMax.pollLast();\\n            }\\n            subMax.offerLast(i);\\n            while (!subMin.isEmpty() && nums[i] < nums[subMin.peekLast()]) {\\n                subMin.pollLast();\\n            }\\n            subMin.offerLast(i);\\n            if (nums[subMax.peekFirst()] - nums[subMin.peekFirst()] <= limit) {\\n                ans = Math.max(i - l + 1, ans);\\n            } else {\\n                while (nums[subMax.peekFirst()] - nums[subMin.peekFirst()] > limit) {\\n                    if (subMax.peekFirst() < subMin.peekFirst()) {\\n                        l = 1 + subMax.pollFirst();\\n                    } else {\\n                        l = 1 + subMin.pollFirst();\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609830,
                "title": "c-2-pointer-sol-13-lines",
                "content": "```\\nint longestSubarray(vector<int>& nums, int limit) {\\n        int i = 0, j = 0;\\n        multiset<int> h;   // multiset to keep the values in the [i,j].\\n        for(;j<nums.size(); j++) {\\n            h.insert(nums[j]);\\n            if(*(h.rbegin())- *(h.begin()) > limit) {\\n                h.erase(h.find(nums[i]));\\n                i++;\\n            }\\n        }\\n        return j-i;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint longestSubarray(vector<int>& nums, int limit) {\\n        int i = 0, j = 0;\\n        multiset<int> h;   // multiset to keep the values in the [i,j].\\n        for(;j<nums.size(); j++) {\\n            h.insert(nums[j]);\\n            if(*(h.rbegin())- *(h.begin()) > limit) {\\n                h.erase(h.find(nums[i]));\\n                i++;\\n            }\\n        }\\n        return j-i;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 609746,
                "title": "c-multiset",
                "content": "```\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int start = 0, longest = 0;\\n        multiset<int> st;\\n        for(int end = 0;end<nums.size();++end) {\\n            int cur = nums[end];\\n            st.insert(cur); \\n            if(*st.rbegin()-*st.begin()<=limit) longest = max(end-start+1, longest); \\n            else {\\n                while(*st.rbegin()-*st.begin()>limit) {\\n                    st.erase(st.find(nums[start])); \\n                    ++start;\\n                }\\n            }\\n        }\\n        return longest;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int start = 0, longest = 0;\\n        multiset<int> st;\\n        for(int end = 0;end<nums.size();++end) {\\n            int cur = nums[end];\\n            st.insert(cur); \\n            if(*st.rbegin()-*st.begin()<=limit) longest = max(end-start+1, longest); \\n            else {\\n                while(*st.rbegin()-*st.begin()>limit) {\\n                    st.erase(st.find(nums[start])); \\n                    ++start;\\n                }\\n            }\\n        }\\n        return longest;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3897565,
                "title": "c-solution-with-easiest-explanation-using-map-beats-83-runtime-50-memory",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1-> We can use window sliding and keep all the values in map that can tell us min and max value in that window.\\n2-> If the range (i.e., max-min) is greater than limit then we need to delete element from the left of window that we can do using map in O(1).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1 -> keep inserting the values in map and keep increasing the size of window, until we found max-min>limit and Keep updating the size of window as answer.\\n2-> If max-min>limit, then we can start deleting the values from map. This can be done by getting the left indexes of window and acces the value at that index and delete it from map.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nsince we are using map here, so complexity for map is O(Nlog(N));\\nand we are traversing the array from 0-N then it\\'ll take O(N);\\n\\nSo overall, **Time complexity: O(Nlog(N))**.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nsince we are using one extra map here, so **space complexity is O(N)**.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int ans=1,l=0,h=1,count=1;\\n        map<int,int> mp;\\n        mp[nums[l]]++;\\n        \\n        while(h<nums.size()){\\n            mp[nums[h]]++;\\n            count++; //counting the number of elements in map\\n            \\n            if(prev(mp.end())->first - mp.begin()->first <= limit){ // checking the diff \\n                ans=max(ans,count); // giving the size of subarray that may make our answer\\n            }else{\\n                // If diff is more than limit then we\\'ll start deleting the indexes from left side until we get the max and minimum value such that diff is in range\\n                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){\\n                    if(mp[nums[l]]>1)mp[nums[l]]--;\\n                    else mp.erase(nums[l]);\\n                    count--;\\n                    l++;\\n                }\\n            }\\n            h++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Array",
                    "Two Pointers",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int ans=1,l=0,h=1,count=1;\\n        map<int,int> mp;\\n        mp[nums[l]]++;\\n        \\n        while(h<nums.size()){\\n            mp[nums[h]]++;\\n            count++; //counting the number of elements in map\\n            \\n            if(prev(mp.end())->first - mp.begin()->first <= limit){ // checking the diff \\n                ans=max(ans,count); // giving the size of subarray that may make our answer\\n            }else{\\n                // If diff is more than limit then we\\'ll start deleting the indexes from left side until we get the max and minimum value such that diff is in range\\n                while(prev(mp.end())->first - mp.begin()->first > limit && l<h){\\n                    if(mp[nums[l]]>1)mp[nums[l]]--;\\n                    else mp.erase(nums[l]);\\n                    count--;\\n                    l++;\\n                }\\n            }\\n            h++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451870,
                "title": "very-veryimportant-question-on-multiset-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        \\n        int i = 0;\\n        int j = 0;\\n        int maxlen = 0;\\n        multiset<int> st;\\n        while(j<nums.size()){\\n            st.insert(nums[j]);\\n            int mini = *(st.begin());\\n            int maxi = *(st.rbegin());\\n            int l = maxi - mini;\\n            if(maxi - mini<=limit){\\n                maxlen = max(maxlen,(j-i+1));\\n            }\\n            else \\n            {\\n                while(st.size()>0 && l>limit){\\n                    auto it = st.find(nums[i]);\\n                    st.erase(it);\\n                    l = *(st.begin()) - *(st.rbegin());\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        \\n        int i = 0;\\n        int j = 0;\\n        int maxlen = 0;\\n        multiset<int> st;\\n        while(j<nums.size()){\\n            st.insert(nums[j]);\\n            int mini = *(st.begin());\\n            int maxi = *(st.rbegin());\\n            int l = maxi - mini;\\n            if(maxi - mini<=limit){\\n                maxlen = max(maxlen,(j-i+1));\\n            }\\n            else \\n            {\\n                while(st.size()>0 && l>limit){\\n                    auto it = st.find(nums[i]);\\n                    st.erase(it);\\n                    l = *(st.begin()) - *(st.rbegin());\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3052290,
                "title": "simple-python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # using binary search\\n        # arr, left  = [], 0\\n        # for i in range(len(nums)):\\n        #     bisect.insort(arr, nums[i])\\n        #     if arr[-1] - arr[0] > limit:\\n        #         arr.pop(bisect.bisect(arr, nums[left])-1)\\n        #         left += 1\\n        # return i - left + 1\\n\\n        #using deque\\n\\n        maxi = deque([])\\n        mini = deque([])\\n        left = 0\\n\\n        for num in nums:\\n            while maxi and num > maxi[-1]:\\n                maxi.pop()\\n            while mini and num < mini[-1]:\\n                mini.pop()\\n\\n            maxi.append(num)\\n            mini.append(num)\\n\\n            if maxi[0] - mini[0] > limit:\\n                if maxi[0] == nums[left]:\\n                    maxi.popleft()\\n                if mini[0] == nums[left]:\\n                    mini.popleft()\\n                left += 1\\n        return len(nums) - left                         \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # using binary search\\n        # arr, left  = [], 0\\n        # for i in range(len(nums)):\\n        #     bisect.insort(arr, nums[i])\\n        #     if arr[-1] - arr[0] > limit:\\n        #         arr.pop(bisect.bisect(arr, nums[left])-1)\\n        #         left += 1\\n        # return i - left + 1\\n\\n        #using deque\\n\\n        maxi = deque([])\\n        mini = deque([])\\n        left = 0\\n\\n        for num in nums:\\n            while maxi and num > maxi[-1]:\\n                maxi.pop()\\n            while mini and num < mini[-1]:\\n                mini.pop()\\n\\n            maxi.append(num)\\n            mini.append(num)\\n\\n            if maxi[0] - mini[0] > limit:\\n                if maxi[0] == nums[left]:\\n                    maxi.popleft()\\n                if mini[0] == nums[left]:\\n                    mini.popleft()\\n                left += 1\\n        return len(nums) - left                         \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732664,
                "title": "simple-modular-o-n-solution-faster-than-78-of-solutions",
                "content": "The idea is to use left and right pointers to move the subarray window. Within a window, you need to track the min and max values. If the difference between min and max is within limits, then the subarray is valid. \\n\\nAdvance the right pointer in each iteration. This adds new elements to the subarray and ensures we reach the end of the input. \\n\\nWhen a new element is included in the subarray, we need to perform 2 checks, is the new element lesser than min or is the new element greater than max. If the new element doesn\\'t affect min or max, then the subarray is still valid.\\n\\nBy not it\\'s clear you advance the right pointer in each iteration, but it\\'s not clear when to advance the left pointer.\\n\\nWhen the new element included in the subarray is lesser than min or greater than max, then we have to advance the left pointer to find the next valid window.\\n\\nIf the new element is either lesser than min or greater than max, move the left pointer toward right until, the difference between the elements between left and right pointers is wihin the limit.\\n\\nAfter you have found the new valid subarray, if the new element is lesser than min, then you need to\\n1. Find the new max in the subarray.\\n2. Update the min to the new min.\\n\\nOn the other hand, if the new elemet is greater than max, then you need to\\n1. Find the new min in the subarray.\\n2. Update the max to the new max.\\n\\nTime Complexity is O(N)\\nThe while loop consistently move the right pointer toward the end -> N.\\nIn the worst case, for each move of right pointer, the left pointer moves once so the subarray size is always 1. Example: [1,2,3] limit = 0. This means each element in the array is visited twice so time complexity becomes 2N.\\n\\nAsymptotically, the complexity is O(N).\\n\\n```\\npublic class Solution {\\n    public int LongestSubarray(int[] nums, int limit) {\\n        int max = nums[0], min = nums[0];\\n        int left = 0, right = 0;\\n        int maxSize = 0, size = 0;\\n        \\n        while (right < nums.Length) {\\n            if(nums[right] < min) {\\n                min = nums[right];\\n                if(Math.Abs(max - nums[right]) > limit) {\\n                    left = FindLeft(left, right, limit, nums);\\n                    max = FindMax(left, right, nums);\\n                }\\n            }\\n            else if(nums[right] > max) {\\n                max = nums[right];\\n                if(Math.Abs(min - nums[right]) > limit) {\\n                    left = FindLeft(left, right, limit, nums);\\n                    min = FindMin(left, right, nums);\\n                }\\n            }\\n            \\n            size = right - left + 1;\\n            maxSize = Math.Max(maxSize, size);\\n            right++;\\n        }\\n        \\n        return maxSize;\\n    }\\n    \\n    public static int FindMin(int left, int right, int[] nums) {\\n        int min = nums[left];\\n        for(int i=left; i<=right; i++) {\\n            min = Math.Min(nums[i], min);\\n        }\\n        \\n        return min;\\n    }\\n    \\n    public static int FindMax(int left, int right, int[] nums) {\\n        int max = nums[left];\\n        for(int i=left; i<=right; i++) {\\n            max = Math.Max(nums[i], max);\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public static int FindLeft(int left, int right, int limit, int[] nums) {\\n        int newLeft = left;\\n        \\n        for(int i=left; i<=right; i++) {\\n            if(Math.Abs(nums[right] - nums[i]) > limit) {\\n                newLeft = i;\\n            }\\n        }\\n        \\n        if(Math.Abs(nums[right] - nums[newLeft]) > limit) {\\n            newLeft++;\\n        }\\n        \\n        return newLeft;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LongestSubarray(int[] nums, int limit) {\\n        int max = nums[0], min = nums[0];\\n        int left = 0, right = 0;\\n        int maxSize = 0, size = 0;\\n        \\n        while (right < nums.Length) {\\n            if(nums[right] < min) {\\n                min = nums[right];\\n                if(Math.Abs(max - nums[right]) > limit) {\\n                    left = FindLeft(left, right, limit, nums);\\n                    max = FindMax(left, right, nums);\\n                }\\n            }\\n            else if(nums[right] > max) {\\n                max = nums[right];\\n                if(Math.Abs(min - nums[right]) > limit) {\\n                    left = FindLeft(left, right, limit, nums);\\n                    min = FindMin(left, right, nums);\\n                }\\n            }\\n            \\n            size = right - left + 1;\\n            maxSize = Math.Max(maxSize, size);\\n            right++;\\n        }\\n        \\n        return maxSize;\\n    }\\n    \\n    public static int FindMin(int left, int right, int[] nums) {\\n        int min = nums[left];\\n        for(int i=left; i<=right; i++) {\\n            min = Math.Min(nums[i], min);\\n        }\\n        \\n        return min;\\n    }\\n    \\n    public static int FindMax(int left, int right, int[] nums) {\\n        int max = nums[left];\\n        for(int i=left; i<=right; i++) {\\n            max = Math.Max(nums[i], max);\\n        }\\n        \\n        return max;\\n    }\\n    \\n    public static int FindLeft(int left, int right, int limit, int[] nums) {\\n        int newLeft = left;\\n        \\n        for(int i=left; i<=right; i++) {\\n            if(Math.Abs(nums[right] - nums[i]) > limit) {\\n                newLeft = i;\\n            }\\n        }\\n        \\n        if(Math.Abs(nums[right] - nums[newLeft]) > limit) {\\n            newLeft++;\\n        }\\n        \\n        return newLeft;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2689859,
                "title": "simple-deque-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        \\n        int ans = 0;\\n        deque <int> min;\\n        deque <int> max;\\n        int e = 0;\\n        int s = 0;\\n        \\n        while(e<nums.size()){\\n            \\n            while(!min.empty() && nums[min.back()]>=nums[e]){\\n                min.pop_back();\\n            }\\n            \\n            min.push_back(e);\\n            \\n            while(!max.empty() && nums[max.back()]<=nums[e]){\\n                max.pop_back();\\n            }\\n            \\n            max.push_back(e);\\n            \\n            if(nums[max.front()]-nums[min.front()]<=limit){\\n                if(ans<e-s+1){\\n                    ans = e-s+1;\\n                }\\n                e++;\\n            }\\n            \\n            else{\\n                s++;\\n                if(s>min.front()){\\n                    min.pop_front();\\n                }\\n                if(s>max.front()){\\n                    max.pop_front();\\n                }               \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        \\n        int ans = 0;\\n        deque <int> min;\\n        deque <int> max;\\n        int e = 0;\\n        int s = 0;\\n        \\n        while(e<nums.size()){\\n            \\n            while(!min.empty() && nums[min.back()]>=nums[e]){\\n                min.pop_back();\\n            }\\n            \\n            min.push_back(e);\\n            \\n            while(!max.empty() && nums[max.back()]<=nums[e]){\\n                max.pop_back();\\n            }\\n            \\n            max.push_back(e);\\n            \\n            if(nums[max.front()]-nums[min.front()]<=limit){\\n                if(ans<e-s+1){\\n                    ans = e-s+1;\\n                }\\n                e++;\\n            }\\n            \\n            else{\\n                s++;\\n                if(s>min.front()){\\n                    min.pop_front();\\n                }\\n                if(s>max.front()){\\n                    max.pop_front();\\n                }               \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2563482,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        if(nums.size()==1)return 1;\\n        int i=0;\\n        int j=0;\\n        int result=0;\\n        int count=0;\\n        deque<int>max_dq;\\n        deque<int>min_dq;\\n        // Variable size window problem\\n        while(j<nums.size())\\n        {\\n            // Do pre-calculation\\n            \\n               // Calculatoin for max element in window\\n                while(!max_dq.empty()&&nums[max_dq.back()]<nums[j])\\n                    max_dq.pop_back();\\n                max_dq.push_back(j);\\n            \\n            // Calculation for min elemetn in window\\n               while(!min_dq.empty()&&nums[min_dq.back()]>nums[j])\\n                   min_dq.pop_back();\\n             min_dq.push_back(j);\\n            \\n            // Play with Condition\\n            \\n            \\n                while(abs(nums[j]-nums[min_dq.front()])>limit||abs(nums[j]-nums[max_dq.front()])>limit)\\n                {\\n                    // Remove the calculation for i\\n                    if(min_dq.front()==i)\\n                        min_dq.pop_front();\\n                    if(max_dq.front()==i)\\n                        max_dq.pop_front();\\n                    i++;\\n                }\\n            \\n            // store result\\n            result=max(result,j-i+1);\\n            j++;\\n            \\n        }\\n        return result;\\n    }\\n};\\n\\nTime Complexity: O(2*n)\\nSpace Complexity: O(2*n)\\n```\\n\\n***PLEASE UPVOTE IF YOU FIND IT A LITTLE BIT HELPFUL, MEANS A LOT ;)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        if(nums.size()==1)return 1;\\n        int i=0;\\n        int j=0;\\n        int result=0;\\n        int count=0;\\n        deque<int>max_dq;\\n        deque<int>min_dq;\\n        // Variable size window problem\\n        while(j<nums.size())\\n        {\\n            // Do pre-calculation\\n            \\n               // Calculatoin for max element in window\\n                while(!max_dq.empty()&&nums[max_dq.back()]<nums[j])\\n                    max_dq.pop_back();\\n                max_dq.push_back(j);\\n            \\n            // Calculation for min elemetn in window\\n               while(!min_dq.empty()&&nums[min_dq.back()]>nums[j])\\n                   min_dq.pop_back();\\n             min_dq.push_back(j);\\n            \\n            // Play with Condition\\n            \\n            \\n                while(abs(nums[j]-nums[min_dq.front()])>limit||abs(nums[j]-nums[max_dq.front()])>limit)\\n                {\\n                    // Remove the calculation for i\\n                    if(min_dq.front()==i)\\n                        min_dq.pop_front();\\n                    if(max_dq.front()==i)\\n                        max_dq.pop_front();\\n                    i++;\\n                }\\n            \\n            // store result\\n            result=max(result,j-i+1);\\n            j++;\\n            \\n        }\\n        return result;\\n    }\\n};\\n\\nTime Complexity: O(2*n)\\nSpace Complexity: O(2*n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174714,
                "title": "monotonic-queue-implementation",
                "content": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        maxQueue = deque()\\n        minQueue = deque()\\n        \\n        length = len(nums)\\n        \\n        i = 0\\n        maxSize = 0\\n        \\n        for j, num in enumerate(nums):\\n            while maxQueue and maxQueue[-1] < num:\\n                maxQueue.pop()\\n            \\n            maxQueue.append(num)\\n            \\n            while minQueue and minQueue[-1] > num:\\n                minQueue.pop()\\n                \\n            minQueue.append(num)\\n            \\n            while maxQueue[0] - minQueue[0] > limit:\\n                if maxQueue[0] == nums[i]:\\n                    maxQueue.popleft()\\n                if minQueue[0] == nums[i]:\\n                    minQueue.popleft()\\n                \\n                i += 1\\n            maxSize = max(maxSize, j - i + 1)\\n        return maxSize\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        maxQueue = deque()\\n        minQueue = deque()\\n        \\n        length = len(nums)\\n        \\n        i = 0\\n        maxSize = 0\\n        \\n        for j, num in enumerate(nums):\\n            while maxQueue and maxQueue[-1] < num:\\n                maxQueue.pop()\\n            \\n            maxQueue.append(num)\\n            \\n            while minQueue and minQueue[-1] > num:\\n                minQueue.pop()\\n                \\n            minQueue.append(num)\\n            \\n            while maxQueue[0] - minQueue[0] > limit:\\n                if maxQueue[0] == nums[i]:\\n                    maxQueue.popleft()\\n                if minQueue[0] == nums[i]:\\n                    minQueue.popleft()\\n                \\n                i += 1\\n            maxSize = max(maxSize, j - i + 1)\\n        return maxSize\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2174352,
                "title": "c-multiset-sliding-window",
                "content": "int longestSubarray(vector<int>& nums, int limit) {\\n         \\n         multiset<int> m;\\n         int st = 0 , len = 0;\\n         for(int i=0;i<nums.size();i++){\\n             m.insert(nums[i]);\\n             auto it = (--m.end());\\n             auto it2 = m.begin();\\n             while(*it - *it2 > limit){\\n                 m.erase( m.find(nums[st++]));\\n                 it2 = m.begin();\\n                 it = (--m.end());\\n             }\\n             len = max(len , i - st + 1);\\n         }\\n        return len;\\n    }",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "int longestSubarray(vector<int>& nums, int limit) {\\n         \\n         multiset<int> m;\\n         int st = 0 , len = 0;\\n         for(int i=0;i<nums.size();i++){\\n             m.insert(nums[i]);\\n             auto it = (--m.end());\\n             auto it2 = m.begin();\\n             while(*it - *it2 > limit){\\n                 m.erase( m.find(nums[st++]));\\n                 it2 = m.begin();\\n                 it = (--m.end());\\n             }\\n             len = max(len , i - st + 1);\\n         }\\n        return len;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2165188,
                "title": "c-sliding-window-and-monotonic-deque",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        \\n        deque<int> maxdq;\\n        deque<int> mindq;\\n        \\n        int l = 0;\\n        int r = 0;\\n        \\n        maxdq.push_back(0);\\n        mindq.push_back(0);\\n\\n        int ans = 1;\\n        \\n        r = 1;\\n        \\n        while(r<nums.size()){\\n            \\n            while(!maxdq.empty() && nums[maxdq.back()] <= nums[r]){\\n                maxdq.pop_back();\\n            }\\n            maxdq.push_back(r);\\n            \\n            while(!mindq.empty() && nums[mindq.back()] >= nums[r]){\\n                mindq.pop_back();\\n            }\\n            mindq.push_back(r);\\n            \\n            \\n            while(nums[maxdq.front()] - nums[mindq.front()] > limit){\\n                \\n                if (maxdq.front() == l){\\n                    maxdq.pop_front();\\n                }\\n                if (mindq.front() == l){\\n                    mindq.pop_front();\\n                }\\n                \\n                l++;\\n            }\\n            \\n            ans = max(ans, r-l+1);\\n            \\n            r++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n// |a-b|\\n// a-b or b-a\\n\\n// max - min\\n\\n// maxdq\\n// mindq\\n\\n// 5 8 3 7 1 8\\n\\n\\n// 2 2\\n\\n// 2\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        \\n        deque<int> maxdq;\\n        deque<int> mindq;\\n        \\n        int l = 0;\\n        int r = 0;\\n        \\n        maxdq.push_back(0);\\n        mindq.push_back(0);\\n\\n        int ans = 1;\\n        \\n        r = 1;\\n        \\n        while(r<nums.size()){\\n            \\n            while(!maxdq.empty() && nums[maxdq.back()] <= nums[r]){\\n                maxdq.pop_back();\\n            }\\n            maxdq.push_back(r);\\n            \\n            while(!mindq.empty() && nums[mindq.back()] >= nums[r]){\\n                mindq.pop_back();\\n            }\\n            mindq.push_back(r);\\n            \\n            \\n            while(nums[maxdq.front()] - nums[mindq.front()] > limit){\\n                \\n                if (maxdq.front() == l){\\n                    maxdq.pop_front();\\n                }\\n                if (mindq.front() == l){\\n                    mindq.pop_front();\\n                }\\n                \\n                l++;\\n            }\\n            \\n            ans = max(ans, r-l+1);\\n            \\n            r++;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n// |a-b|\\n// a-b or b-a\\n\\n// max - min\\n\\n// maxdq\\n// mindq\\n\\n// 5 8 3 7 1 8\\n\\n\\n// 2 2\\n\\n// 2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162607,
                "title": "java-clean-code",
                "content": "```\\n   public int longestSubarray(int[] nums, int limit) {\\n        int n = nums.length;\\n        int start = 0, end = 0;\\n        int maxSubArrayLen = 0;        \\n        Deque<Integer> minDeque = new LinkedList<>();\\n        Deque<Integer> maxDeque = new LinkedList<>();\\n        for(end = 0; end<n; end++) {\\n            while(!minDeque.isEmpty() && nums[minDeque.peekLast()] > nums[end]) {\\n                minDeque.pollLast();\\n            }\\n            \\n            while(!maxDeque.isEmpty() && nums[maxDeque.peekLast()] < nums[end]) {\\n                maxDeque.pollLast();\\n            }\\n            \\n            minDeque.addLast(end);\\n            maxDeque.addLast(end);\\n                        \\n            while(start < end && nums[maxDeque.peekFirst()] - nums[minDeque.peekFirst()] > limit) {\\n                start++;\\n                while(!maxDeque.isEmpty() && maxDeque.peekFirst() < start) {\\n                    maxDeque.pollFirst();\\n                }\\n                \\n                while(!minDeque.isEmpty() && minDeque.peekFirst() < start) {\\n                    minDeque.pollFirst();\\n                }           \\n            }\\n\\n            maxSubArrayLen = Math.max(maxSubArrayLen, end-start+1);\\n        }\\n     \\n        return maxSubArrayLen;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   public int longestSubarray(int[] nums, int limit) {\\n        int n = nums.length;\\n        int start = 0, end = 0;\\n        int maxSubArrayLen = 0;        \\n        Deque<Integer> minDeque = new LinkedList<>();\\n        Deque<Integer> maxDeque = new LinkedList<>();\\n        for(end = 0; end<n; end++) {\\n            while(!minDeque.isEmpty() && nums[minDeque.peekLast()] > nums[end]) {\\n                minDeque.pollLast();\\n            }\\n            \\n            while(!maxDeque.isEmpty() && nums[maxDeque.peekLast()] < nums[end]) {\\n                maxDeque.pollLast();\\n            }\\n            \\n            minDeque.addLast(end);\\n            maxDeque.addLast(end);\\n                        \\n            while(start < end && nums[maxDeque.peekFirst()] - nums[minDeque.peekFirst()] > limit) {\\n                start++;\\n                while(!maxDeque.isEmpty() && maxDeque.peekFirst() < start) {\\n                    maxDeque.pollFirst();\\n                }\\n                \\n                while(!minDeque.isEmpty() && minDeque.peekFirst() < start) {\\n                    minDeque.pollFirst();\\n                }           \\n            }\\n\\n            maxSubArrayLen = Math.max(maxSubArrayLen, end-start+1);\\n        }\\n     \\n        return maxSubArrayLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2069217,
                "title": "sliding-window-o-n-using-map",
                "content": "use 2 pointer algo or we can say sliding window technique \\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit){\\n        \\n        int res=1;\\n        map<int,int> m;\\n        int i=0,j=1;\\n        m[nums[0]]++;\\n        int n=nums.size();\\n        while(j<n){\\n            m[nums[j]]++;\\n            int first=m.begin()->first;\\n            int last=m.rbegin()->first;\\n            if((last-first)<=limit){\\n                res=max(res,j-i+1);\\n                j++;\\n            }\\n            else{\\n                while(i<j&&(last-first)>limit){\\n                    m[nums[i]]--;\\n                    if(m[nums[i]]==0) m.erase(nums[i]);\\n                    first=m.begin()->first;\\n                    last=m.rbegin()->first;\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit){\\n        \\n        int res=1;\\n        map<int,int> m;\\n        int i=0,j=1;\\n        m[nums[0]]++;\\n        int n=nums.size();\\n        while(j<n){\\n            m[nums[j]]++;\\n            int first=m.begin()->first;\\n            int last=m.rbegin()->first;\\n            if((last-first)<=limit){\\n                res=max(res,j-i+1);\\n                j++;\\n            }\\n            else{\\n                while(i<j&&(last-first)>limit){\\n                    m[nums[i]]--;\\n                    if(m[nums[i]]==0) m.erase(nums[i]);\\n                    first=m.begin()->first;\\n                    last=m.rbegin()->first;\\n                    i++;\\n                }\\n                j++;\\n            }\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2055796,
                "title": "python-solution-with-two-pointers-and-queue",
                "content": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n\\n        window = l = r = 0\\n        i_q = deque()\\n        d_q = deque()\\n\\n        while r < len(nums):\\n            # get the max value from window\\n            while d_q and nums[d_q[-1]] <= nums[r]:\\n                d_q.pop()\\n            # get the min value from window\\n            while i_q and nums[i_q[-1]] >= nums[r]:\\n                i_q.pop()\\n                \\n            i_q.append(r)\\n            d_q.append(r)\\n\\n            # subtract the min val from the max val\\n            # and shrink window\\n            # while it satisfies diff <= limit\\n            while nums[d_q[0]] - nums[i_q[0]] > limit:\\n                l+=1\\n                # pop the index in a queue when \\n                # the left pointer becomes greater\\n                if l > i_q[0]: i_q.popleft()\\n                if l > d_q[0]: d_q.popleft()\\n            window = max(window, r-l+1)\\n            r+=1\\n\\n        return window\\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n\\n        window = l = r = 0\\n        i_q = deque()\\n        d_q = deque()\\n\\n        while r < len(nums):\\n            # get the max value from window\\n            while d_q and nums[d_q[-1]] <= nums[r]:\\n                d_q.pop()\\n            # get the min value from window\\n            while i_q and nums[i_q[-1]] >= nums[r]:\\n                i_q.pop()\\n                \\n            i_q.append(r)\\n            d_q.append(r)\\n\\n            # subtract the min val from the max val\\n            # and shrink window\\n            # while it satisfies diff <= limit\\n            while nums[d_q[0]] - nums[i_q[0]] > limit:\\n                l+=1\\n                # pop the index in a queue when \\n                # the left pointer becomes greater\\n                if l > i_q[0]: i_q.popleft()\\n                if l > d_q[0]: d_q.popleft()\\n            window = max(window, r-l+1)\\n            r+=1\\n\\n        return window\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2049904,
                "title": "two-heap-pointer",
                "content": "I am using two heaps + pointer to do this. Keeping the min and max in the heap top, check the diff, if exceeding the limit, then remove the left element until the heap size is <= to the limit.\\n\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        PriorityQueue<Integer> pqMin = new PriorityQueue();\\n        PriorityQueue<Integer> pqMax = new PriorityQueue(Collections.reverseOrder());\\n        int count = 0;\\n        int left = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            pqMin.offer(nums[i]);\\n            pqMax.offer(nums[i]);\\n            while (pqMax.peek() - pqMin.peek() > limit) {\\n                ++left;\\n                pqMin.remove(nums[left]);\\n                pqMax.remove(nums[left]);\\n            }\\n            count = Math.max(count, pqMin.size());\\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        PriorityQueue<Integer> pqMin = new PriorityQueue();\\n        PriorityQueue<Integer> pqMax = new PriorityQueue(Collections.reverseOrder());\\n        int count = 0;\\n        int left = -1;\\n        for (int i = 0; i < nums.length; i++) {\\n            pqMin.offer(nums[i]);\\n            pqMax.offer(nums[i]);\\n            while (pqMax.peek() - pqMin.peek() > limit) {\\n                ++left;\\n                pqMin.remove(nums[left]);\\n                pqMax.remove(nums[left]);\\n            }\\n            count = Math.max(count, pqMin.size());\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2012573,
                "title": "24ms-96-faster-simple-java-solution",
                "content": "java code is:\\n\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        ArrayDeque<Integer>min=new ArrayDeque<>();\\n        ArrayDeque<Integer>max=new ArrayDeque<>();\\n        int ans=0;\\n        for(int i=0,j=0;i<nums.length;i++){\\n            while(min.size()>0&&nums[min.peekLast()]>=nums[i])\\n                min.pollLast();\\n            min.add(i);\\n            while(max.size()>0&&nums[max.peekLast()]<=nums[i])\\n                max.pollLast();\\n            max.add(i);\\n            while(nums[max.peekFirst()]-nums[min.peekFirst()]>limit){\\n                if(max.peekFirst()==j)\\n                    max.pollFirst();\\n                if(min.peekFirst()==j)\\n                    min.pollFirst();\\n                j++;\\n            }\\n      //      System.out.println(\"i= \"+i+\" j= \"+j);\\n            ans=Math.max(ans,i-j+1);    \\n        }\\n        return ans;\\n    }\\n}\\n```\\nTime : O(n)\\nSpace : O(n)\\n\\nPlease upvote if this is helpful",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        ArrayDeque<Integer>min=new ArrayDeque<>();\\n        ArrayDeque<Integer>max=new ArrayDeque<>();\\n        int ans=0;\\n        for(int i=0,j=0;i<nums.length;i++){\\n            while(min.size()>0&&nums[min.peekLast()]>=nums[i])\\n                min.pollLast();\\n            min.add(i);\\n            while(max.size()>0&&nums[max.peekLast()]<=nums[i])\\n                max.pollLast();\\n            max.add(i);\\n            while(nums[max.peekFirst()]-nums[min.peekFirst()]>limit){\\n                if(max.peekFirst()==j)\\n                    max.pollFirst();\\n                if(min.peekFirst()==j)\\n                    min.pollFirst();\\n                j++;\\n            }\\n      //      System.out.println(\"i= \"+i+\" j= \"+j);\\n            ans=Math.max(ans,i-j+1);    \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1994018,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    /*\\n        Hint: \\n            1. Keep a multiset and run 2 pointer within limit\\n            2. Reduce logN factor by using monotonic deque instead of multiset\\n        Complexity:\\n            Time: \\n                1. O(N * logN) -> with multiset\\n                2. O(N) -> monotonic deque\\n            Space: O(N)\\n    */\\n    \\n    /*\\n        int longestSubarray(vector<int>& nums, int limit) {\\n            deque <int> min_deq, max_deq;\\n\\n            int lf = 0, rt;\\n            for (rt = 0; rt < nums.size(); rt++) {\\n                while(!max_deq.empty() && nums[max_deq.back()] <= nums[rt]) max_deq.pop_back();\\n                while(!min_deq.empty() && nums[min_deq.back()] >= nums[rt]) min_deq.pop_back();\\n                max_deq.push_back(rt);\\n                min_deq.push_back(rt);\\n\\n            if (nums[max_deq.front()] - nums[min_deq.front()] > limit) {\\n                    if (max_deq.front() == lf) max_deq.pop_front();\\n                    if (min_deq.front() == lf) min_deq.pop_front();\\n                    lf++;\\n                }\\n            }\\n\\n            return rt - lf;\\n        }\\n    */\\n    \\n    int longestSubarray(vector<int>& nums, int limit) {\\n        deque <int> min_deq, max_deq;\\n        \\n        int rt = 0;\\n        int max_substring = 0;\\n        for (int lf = 0; lf < nums.size(); lf++) {\\n            while(rt < nums.size() && (min_deq.empty() || nums[max_deq.front()] - nums[min_deq.front()] <= limit)) {\\n                while(!max_deq.empty() && nums[max_deq.back()] <= nums[rt]) max_deq.pop_back();\\n                while(!min_deq.empty() && nums[min_deq.back()] >= nums[rt]) min_deq.pop_back();\\n                max_deq.push_back(rt);\\n                min_deq.push_back(rt);\\n                rt++;\\n            }\\n            \\n            if (!min_deq.empty()) {\\n                if (nums[max_deq.front()] - nums[min_deq.front()] > limit) max_substring = max(max_substring, rt - lf - 1);\\n                else max_substring = max(max_substring, rt - lf);\\n                                \\n                if (max_deq.front() == lf) max_deq.pop_front();\\n                if (min_deq.front() == lf) min_deq.pop_front();\\n            }\\n            \\n            \\n        }\\n        \\n        return max_substring;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Monotonic Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /*\\n        Hint: \\n            1. Keep a multiset and run 2 pointer within limit\\n            2. Reduce logN factor by using monotonic deque instead of multiset\\n        Complexity:\\n            Time: \\n                1. O(N * logN) -> with multiset\\n                2. O(N) -> monotonic deque\\n            Space: O(N)\\n    */\\n    \\n    /*\\n        int longestSubarray(vector<int>& nums, int limit) {\\n            deque <int> min_deq, max_deq;\\n\\n            int lf = 0, rt;\\n            for (rt = 0; rt < nums.size(); rt++) {\\n                while(!max_deq.empty() && nums[max_deq.back()] <= nums[rt]) max_deq.pop_back();\\n                while(!min_deq.empty() && nums[min_deq.back()] >= nums[rt]) min_deq.pop_back();\\n                max_deq.push_back(rt);\\n                min_deq.push_back(rt);\\n\\n            if (nums[max_deq.front()] - nums[min_deq.front()] > limit) {\\n                    if (max_deq.front() == lf) max_deq.pop_front();\\n                    if (min_deq.front() == lf) min_deq.pop_front();\\n                    lf++;\\n                }\\n            }\\n\\n            return rt - lf;\\n        }\\n    */\\n    \\n    int longestSubarray(vector<int>& nums, int limit) {\\n        deque <int> min_deq, max_deq;\\n        \\n        int rt = 0;\\n        int max_substring = 0;\\n        for (int lf = 0; lf < nums.size(); lf++) {\\n            while(rt < nums.size() && (min_deq.empty() || nums[max_deq.front()] - nums[min_deq.front()] <= limit)) {\\n                while(!max_deq.empty() && nums[max_deq.back()] <= nums[rt]) max_deq.pop_back();\\n                while(!min_deq.empty() && nums[min_deq.back()] >= nums[rt]) min_deq.pop_back();\\n                max_deq.push_back(rt);\\n                min_deq.push_back(rt);\\n                rt++;\\n            }\\n            \\n            if (!min_deq.empty()) {\\n                if (nums[max_deq.front()] - nums[min_deq.front()] > limit) max_substring = max(max_substring, rt - lf - 1);\\n                else max_substring = max(max_substring, rt - lf);\\n                                \\n                if (max_deq.front() == lf) max_deq.pop_front();\\n                if (min_deq.front() == lf) min_deq.pop_front();\\n            }\\n            \\n            \\n        }\\n        \\n        return max_substring;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1668283,
                "title": "easy-c-solution-using-maps-and-sliding-window-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        // In map the keys are stored in sorted order\\n        // here key is the array element \\n        // value is the frequency of the key in current window\\n        map<int,int>dict;\\n        \\n        // \\'i\\' is the left pointer and \\'j\\' is the right pointer of the window\\n        // \\'ans\\' will hold the answer\\n        int i=0,j=0,ans=0;\\n        while(j<nums.size())\\n        {\\n            dict[nums[j]]++;\\n            \\n            // dict.rbegin() returns an iterator which points to the maximum element in the map\\n            // similarly dict.begin() returns an iterator which points to the minimum element in the map\\n            // so their difference would give us the range of elements in the window. Keep on shrinking the window as long as the range is greater than limit\\n            while(dict.rbegin()->first-dict.begin()->first>limit)\\n            {\\n                if(dict[nums[i]]==1)\\n                {\\n                    dict.erase(nums[i]);\\n                }\\n                else\\n                {\\n                    dict[nums[i]]--;\\n                }\\n                i++;\\n            }\\n            \\n            // Take the maximum of the current window size and previous sizes\\n            ans=max(ans,j-i+1);\\n            \\n            // Grow the window\\n            j++;\\n        }\\n        \\n        // Finally return the answer\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        // In map the keys are stored in sorted order\\n        // here key is the array element \\n        // value is the frequency of the key in current window\\n        map<int,int>dict;\\n        \\n        // \\'i\\' is the left pointer and \\'j\\' is the right pointer of the window\\n        // \\'ans\\' will hold the answer\\n        int i=0,j=0,ans=0;\\n        while(j<nums.size())\\n        {\\n            dict[nums[j]]++;\\n            \\n            // dict.rbegin() returns an iterator which points to the maximum element in the map\\n            // similarly dict.begin() returns an iterator which points to the minimum element in the map\\n            // so their difference would give us the range of elements in the window. Keep on shrinking the window as long as the range is greater than limit\\n            while(dict.rbegin()->first-dict.begin()->first>limit)\\n            {\\n                if(dict[nums[i]]==1)\\n                {\\n                    dict.erase(nums[i]);\\n                }\\n                else\\n                {\\n                    dict[nums[i]]--;\\n                }\\n                i++;\\n            }\\n            \\n            // Take the maximum of the current window size and previous sizes\\n            ans=max(ans,j-i+1);\\n            \\n            // Grow the window\\n            j++;\\n        }\\n        \\n        // Finally return the answer\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1604652,
                "title": "c-map-solution-sliding-window-two-pointer-commented-code",
                "content": "* Using **sliding window** \\n* if the window is valid [**maxOfWindow - minOfWindow <= limit**] then we will update the answer and move to next element\\n* if the window is not valid we will run the loop and remove elements from starting until we get a valid window\\n```\\n// time complexity = O(2n) = O(n)\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        // since map will be storing elements in sorted order\\n        map<int, int> mp{ {nums[0], 0} }; \\n        int start = 0, end = 0;\\n        int ans = 0;\\n        int size = nums.size();\\n        int maxOfWindow, minOfWindow;\\n        \\n        while(end < size)\\n        {\\n            \\n            mp[nums[end]]++;\\n            maxOfWindow = (--mp.end())->first; // because we want element just before end so --\\n            minOfWindow = mp.begin()->first;\\n            // cout<<maxOfWindow<<minOfWindow<<endl;\\n            \\n            if(maxOfWindow - minOfWindow <= limit) // valid window\\n            {\\n                ans = max(ans, end - start + 1);\\n            }\\n            else\\n            { // minimize the window until it becomes valid\\n                while(maxOfWindow - minOfWindow > limit)\\n                {\\n                    mp[nums[start]]--;\\n                    if(mp[nums[start]] == 0) // if disitnct element then remove it from mao\\n                    {\\n                        mp.erase(nums[start]);\\n                    }\\n                    start++;\\n                    maxOfWindow = mp.end()->first; // again updating min and max as removed element can be min or max\\n                    minOfWindow = mp.begin()->first;\\n                }\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// time complexity = O(2n) = O(n)\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        // since map will be storing elements in sorted order\\n        map<int, int> mp{ {nums[0], 0} }; \\n        int start = 0, end = 0;\\n        int ans = 0;\\n        int size = nums.size();\\n        int maxOfWindow, minOfWindow;\\n        \\n        while(end < size)\\n        {\\n            \\n            mp[nums[end]]++;\\n            maxOfWindow = (--mp.end())->first; // because we want element just before end so --\\n            minOfWindow = mp.begin()->first;\\n            // cout<<maxOfWindow<<minOfWindow<<endl;\\n            \\n            if(maxOfWindow - minOfWindow <= limit) // valid window\\n            {\\n                ans = max(ans, end - start + 1);\\n            }\\n            else\\n            { // minimize the window until it becomes valid\\n                while(maxOfWindow - minOfWindow > limit)\\n                {\\n                    mp[nums[start]]--;\\n                    if(mp[nums[start]] == 0) // if disitnct element then remove it from mao\\n                    {\\n                        mp.erase(nums[start]);\\n                    }\\n                    start++;\\n                    maxOfWindow = mp.end()->first; // again updating min and max as removed element can be min or max\\n                    minOfWindow = mp.begin()->first;\\n                }\\n            }\\n            end++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1548783,
                "title": "java-treemap",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        TreeMap<Integer, Integer> window = new TreeMap<>();\\n        int l = 0;\\n        int r = 0;\\n        int maxLength = 0;\\n        while (r < nums.length) {\\n            addToWindow(window, nums[r++]);\\n            while (window.lastKey() - window.firstKey() > limit) {\\n                removeFromWindow(window, nums[l++]);\\n            }\\n            maxLength = Math.max(r - l, maxLength);\\n        }\\n        \\n        return maxLength;\\n    }\\n    \\n    private void removeFromWindow(Map<Integer, Integer> window, int value) {\\n        if (window.containsKey(value)) {\\n            int occurencies = window.get(value);\\n            if (occurencies == 1) {\\n                window.remove(value);\\n            } else {\\n                window.put(value, occurencies - 1);\\n            }\\n        }\\n    }\\n    \\n    private void addToWindow(Map<Integer, Integer> window, int value) {\\n        window.put(value, window.getOrDefault(value, 0) + 1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        TreeMap<Integer, Integer> window = new TreeMap<>();\\n        int l = 0;\\n        int r = 0;\\n        int maxLength = 0;\\n        while (r < nums.length) {\\n            addToWindow(window, nums[r++]);\\n            while (window.lastKey() - window.firstKey() > limit) {\\n                removeFromWindow(window, nums[l++]);\\n            }\\n            maxLength = Math.max(r - l, maxLength);\\n        }\\n        \\n        return maxLength;\\n    }\\n    \\n    private void removeFromWindow(Map<Integer, Integer> window, int value) {\\n        if (window.containsKey(value)) {\\n            int occurencies = window.get(value);\\n            if (occurencies == 1) {\\n                window.remove(value);\\n            } else {\\n                window.put(value, occurencies - 1);\\n            }\\n        }\\n    }\\n    \\n    private void addToWindow(Map<Integer, Integer> window, int value) {\\n        window.put(value, window.getOrDefault(value, 0) + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289837,
                "title": "simple-16-line-js-solution-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/48c688d5-e81c-471d-b108-ea617a4f4ecb_1624360053.3406553.png)\\n\\n# Simple (16 Line) JS Solution ~ Faster than 100% of Submissions\\n* Monotonic Queue/Dequeue Approach \\n* Runtime: Faster than 100% of JavaScript Submissions\\n\\n```\\nvar longestSubarray = function(nums, limit) {\\n    let left = 0, right = 0, max = [], min = [], num = 0\\n    \\n    while (right < nums.length) {\\n        num = nums[right++]\\n        while (max.length && num > max[max.length - 1]) max.pop()\\n        while (min.length && num < min[min.length - 1]) min.pop()\\n        \\n        max.push(num)\\n        min.push(num)\\n        if (max[0] - min[0] <= limit) continue   \\n        \\n        num = nums[left++]\\n        if (max[0] == num) max.shift()\\n        if (min[0] == num) min.shift()\\n    }\\n    \\n    return right - left\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nvar longestSubarray = function(nums, limit) {\\n    let left = 0, right = 0, max = [], min = [], num = 0\\n    \\n    while (right < nums.length) {\\n        num = nums[right++]\\n        while (max.length && num > max[max.length - 1]) max.pop()\\n        while (min.length && num < min[min.length - 1]) min.pop()\\n        \\n        max.push(num)\\n        min.push(num)\\n        if (max[0] - min[0] <= limit) continue   \\n        \\n        num = nums[left++]\\n        if (max[0] == num) max.shift()\\n        if (min[0] == num) min.shift()\\n    }\\n    \\n    return right - left\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276698,
                "title": "python-using-deque-o-n",
                "content": "```\\nfrom collections import deque\\nfrom typing import Deque\\n\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        max_queue: Deque = deque()\\n        min_queue: Deque = deque()    \\n        left: int = 0    \\n        max_len: int = 0    \\n        \\n        for right in range(len(nums)):\\n            self.pushing_max(max_queue, nums[right])\\n            self.pushing_min(min_queue, nums[right])\\n            while left <= right and max_queue and min_queue and max_queue[0] - min_queue[0] > limit:\\n                if max_queue[0] == nums[left]:\\n                    max_queue.popleft()\\n                if min_queue[0] == nums[left]:\\n                    min_queue.popleft()\\n                left += 1    \\n            max_len = max(max_len, right - left + 1)    \\n        return max_len    \\n    \\n    def pushing_max(self, max_queue: Deque, value: int):\\n        while max_queue and max_queue[-1] < value:\\n            max_queue.pop()\\n        max_queue.append(value)    \\n        \\n    def pushing_min(self, min_queue: Deque, value: int):\\n        while min_queue and min_queue[-1] > value:\\n            min_queue.pop()\\n        min_queue.append(value)    \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nfrom typing import Deque\\n\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        max_queue: Deque = deque()\\n        min_queue: Deque = deque()    \\n        left: int = 0    \\n        max_len: int = 0    \\n        \\n        for right in range(len(nums)):\\n            self.pushing_max(max_queue, nums[right])\\n            self.pushing_min(min_queue, nums[right])\\n            while left <= right and max_queue and min_queue and max_queue[0] - min_queue[0] > limit:\\n                if max_queue[0] == nums[left]:\\n                    max_queue.popleft()\\n                if min_queue[0] == nums[left]:\\n                    min_queue.popleft()\\n                left += 1    \\n            max_len = max(max_len, right - left + 1)    \\n        return max_len    \\n    \\n    def pushing_max(self, max_queue: Deque, value: int):\\n        while max_queue and max_queue[-1] < value:\\n            max_queue.pop()\\n        max_queue.append(value)    \\n        \\n    def pushing_min(self, min_queue: Deque, value: int):\\n        while min_queue and min_queue[-1] > value:\\n            min_queue.pop()\\n        min_queue.append(value)    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 951177,
                "title": "why-tracking-only-two-variables-min-num-max-num-doesn-t-work",
                "content": "FYI, I am writing this to convience / explain to myself. lol\\n\\nIt seems the most popular answer is using two queues. ( minq, maxq )\\nand, I tried to understand how it works and stuck in the idea of using `minq` and `maxq`\\nI could be wrong, but this is why I think we need minq and maxq.\\n\\nlet\\'s say I have a list of number, [2,3,4,1,2,3]\\nand, let\\'s say I have two pointers, `left` and `right` that starts from idx=0.\\nwhen I move `right` pointer to right (extending window), I can get `max_val` and `min_val` value while I am moving `right` pointer.  ok this is clear and straightforward.\\n\\nnow, let\\'s move `left` pointer to reduce the window size to satisfy the `limit` requirement.\\nok. I can move `left`  to right, but the question can be where I can stop moving `left`\\nthe obvious answer is `max_val - min_val <= limit`\\nthen, how would I know the `max_val` and `min_val` in the current windown while moving `left` pointer?\\noh. by doing `min(nums[left:right])`, `max(nums[left:right])`, right?\\nyes, this works in terms of functionality, but this operation will increase time complexity ( time exceeeded ).\\n\\nso, I think those solutions using minq, max try to reduce the time complexity in checking `min_val`, `max_val` in the current window.\\n\\nso far, this is my understanding. :)\\n\\nThank you for reading.\\n\\njust FYI, the simple idea but time exceeded solution\\n\\n```\\n    # time exceeded\\n    class Solution:\\n        def longestSubarray(self, nums: List[int], limit: int) -> int:\\n\\n            max_len = 0\\n            for i in range(len(nums)):\\n                for j in range(i + 1, len(nums) + 1):\\n                    sub_arr = nums[i:j]\\n                    if max(sub_arr) - min(sub_arr) <= limit:\\n                        max_len = max(max_len, len(sub_arr))\\n\\n            return max_len\\n\\n    # time exceeded\\n    class Solution:\\n        def longestSubarray(self, nums: List[int], limit: int) -> int:\\n            max_len = 0\\n            for i in range(len(nums)):\\n                max_num = nums[i]\\n                min_num = nums[i]\\n                for j in range(i + 1, len(nums)+1):\\n                    max_num = max(max_num, nums[j-1])\\n                    min_num = min(min_num, nums[j-1])\\n                    if max_num - min_num <= limit:\\n                        max_len = max(max_len, j - i)\\n\\n            return max_len\\n```",
                "solutionTags": [],
                "code": "```\\n    # time exceeded\\n    class Solution:\\n        def longestSubarray(self, nums: List[int], limit: int) -> int:\\n\\n            max_len = 0\\n            for i in range(len(nums)):\\n                for j in range(i + 1, len(nums) + 1):\\n                    sub_arr = nums[i:j]\\n                    if max(sub_arr) - min(sub_arr) <= limit:\\n                        max_len = max(max_len, len(sub_arr))\\n\\n            return max_len\\n\\n    # time exceeded\\n    class Solution:\\n        def longestSubarray(self, nums: List[int], limit: int) -> int:\\n            max_len = 0\\n            for i in range(len(nums)):\\n                max_num = nums[i]\\n                min_num = nums[i]\\n                for j in range(i + 1, len(nums)+1):\\n                    max_num = max(max_num, nums[j-1])\\n                    min_num = min(min_num, nums[j-1])\\n                    if max_num - min_num <= limit:\\n                        max_len = max(max_len, j - i)\\n\\n            return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 942361,
                "title": "java-short-and-crisp-using-sliding-window-deque-with-explanation",
                "content": "**Aim:** Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit.\\nHere diff depends upon Largest and smallest number within the subarray.\\nWe use two pointers start,end to store start and end of subarray.\\n**Algo:**\\n1.Maintain largest and smallest number of subarray, check if it is <=limit.\\n2.If diff greter than limit , we should remove largest and smallest numbers from our subarray.\\n3.We can use Deque to maintain indices of largest and smallest numbers of subarray.\\n**Example:**\\narr=[8,2,4,7], limit=4\\nTwo Deques,\\nmin-to store indices of potential minimum,Topmost element stores smallest element\\nmax-to store indices of potential maximum numbers.Topmoset element stores largest element.\\nintially start=end=0n=.arr.length min=empty, max=empty.We run loop till end=n, \\n**[1]** start=0,end=0<n\\nmin=0(8) \\nmax=0(8) . \\nmax_value-min_value=8-8=0<=limit. so increase window size , end++ and res=1\\n**[2]** start=0,end=1<n\\nmin=1(2).We removed 8 because, it will never be least in any subarray from start>=0,end=i\\nmax=0,1(8,2)We add 2 beacuse,it may be maximum for subarray from start>=1,end=i\\nmax_value-min_value=8-2=6>limit. It means we need to reduce window size, remove elements from start of min,max deque [as we strored indices in ascending order] with index <=start . start++\\n**[3]** start=1,end=1<n\\nmin=1(2)\\nmax=1(2).\\nmax_value-min_value=2-2=0<=limit. so increase window size , end++ and res=1\\n**[4]** start=1,end=2<n\\nmin=1,2(2,4)Add 4 because it may be minimum in subarray where start>=2\\nmax=2(4).Remove 1(2) beacuse 2 will never be maximum for subarray where start>=1.\\nmax_value-min_value=4-2=2<=limit. so increase window size , end++ and res=2\\n**[5]** start=1,end=3<n\\nmin=1,2,3(2,4,7).\\nmax=3(7)\\nmax_value-min_value=7-2=5>limit. It means we need to reduce window size, remove elements from start of min,max deque [as we strored indices in ascending order]with index <=start . start++\\n**[6]** start=2,end=3<n\\nmin=2,3(4,7)\\nmax=3(7)\\nmax_value-min_value=7-4=3<=limit. so increase window size , end++ and res=2.\\n**[7]** start=2,end=4 . end of loop\\n\\n**Deque** Helps for inserting and deleting from either end.\\nSo we insert from last ,assuming current index may be min/max in future and we remove first when we want reduce window size and remove max/min that are less than or equal to start.\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int n=nums.length,res=0,start=0,end=0;\\n        Deque<Integer> min=new ArrayDeque<Integer>();\\n        Deque<Integer> max=new ArrayDeque<Integer>();\\n        while(end<n){          \\n            while(!min.isEmpty() && nums[min.peekLast()]>nums[end]) min.removeLast();\\n            min.addLast(end);\\n            while(!max.isEmpty() && nums[max.peekLast()]<nums[end]) max.removeLast();\\n            max.addLast(end);\\n            int min_val=nums[min.peekFirst()];\\n            int max_val=nums[max.peekFirst()];\\n            if(max_val-min_val<=limit){\\n                res=Math.max(res,end-start+1);\\n                end++;\\n            }\\n            else{\\n                int skip_index=Math.min(min.peekFirst(), max.peekFirst());\\n                while(min.peekFirst()<=skip_index) min.removeFirst();\\n                while(max.peekFirst()<=skip_index) max.removeFirst();\\n                start=skip_index+1;\\n            }         \\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int n=nums.length,res=0,start=0,end=0;\\n        Deque<Integer> min=new ArrayDeque<Integer>();\\n        Deque<Integer> max=new ArrayDeque<Integer>();\\n        while(end<n){          \\n            while(!min.isEmpty() && nums[min.peekLast()]>nums[end]) min.removeLast();\\n            min.addLast(end);\\n            while(!max.isEmpty() && nums[max.peekLast()]<nums[end]) max.removeLast();\\n            max.addLast(end);\\n            int min_val=nums[min.peekFirst()];\\n            int max_val=nums[max.peekFirst()];\\n            if(max_val-min_val<=limit){\\n                res=Math.max(res,end-start+1);\\n                end++;\\n            }\\n            else{\\n                int skip_index=Math.min(min.peekFirst(), max.peekFirst());\\n                while(min.peekFirst()<=skip_index) min.removeFirst();\\n                while(max.peekFirst()<=skip_index) max.removeFirst();\\n                start=skip_index+1;\\n            }         \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 858594,
                "title": "java-sliding-window-with-max-and-min-heaps-o-nlogn",
                "content": "```\\npublic int longestSubarray(int[] nums, int limit) {\\n\\tif (nums.length == 0)\\n\\t\\treturn 0;\\n\\tPriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n\\tPriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b-a);\\n\\tint i = 0;\\n\\tint j = 0;\\n\\tint result = 1;\\n\\tminHeap.offer(nums[i]);\\n\\tmaxHeap.offer(nums[j]);\\n\\twhile (j < nums.length){\\n\\t\\tint diff = maxHeap.peek() - minHeap.peek();\\n\\t\\tif (diff <= limit){\\n\\t\\t\\tif (j - i + 1 > result)\\n\\t\\t\\t\\tresult = j - i + 1;\\n\\t\\t\\tj++;\\n\\t\\t\\tif (j < nums.length){\\n\\t\\t\\t\\tminHeap.offer(nums[j]);\\n\\t\\t\\t\\tmaxHeap.offer(nums[j]);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tminHeap.remove(nums[i]);\\n\\t\\t\\tmaxHeap.remove(nums[i]);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t}\\n\\treturn result;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic int longestSubarray(int[] nums, int limit) {\\n\\tif (nums.length == 0)\\n\\t\\treturn 0;\\n\\tPriorityQueue<Integer> minHeap = new PriorityQueue<>();\\n\\tPriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b-a);\\n\\tint i = 0;\\n\\tint j = 0;\\n\\tint result = 1;\\n\\tminHeap.offer(nums[i]);\\n\\tmaxHeap.offer(nums[j]);\\n\\twhile (j < nums.length){\\n\\t\\tint diff = maxHeap.peek() - minHeap.peek();\\n\\t\\tif (diff <= limit){\\n\\t\\t\\tif (j - i + 1 > result)\\n\\t\\t\\t\\tresult = j - i + 1;\\n\\t\\t\\tj++;\\n\\t\\t\\tif (j < nums.length){\\n\\t\\t\\t\\tminHeap.offer(nums[j]);\\n\\t\\t\\t\\tmaxHeap.offer(nums[j]);\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tminHeap.remove(nums[i]);\\n\\t\\t\\tmaxHeap.remove(nums[i]);\\n\\t\\t\\ti++;\\n\\t\\t}\\n\\n\\t}\\n\\treturn result;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 830110,
                "title": "easy-cpp-solution-sliding-window-with-proper-comments-using-max-and-min-heap",
                "content": "```\\n\\nclass Solution {\\n   \\npublic:\\n    //here I have used pair to handle duplicate values and can be categoried by index\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int i=0,j=0,n=nums.size(),mx,mn,res=0;\\n        priority_queue<pair<int,int>> mxhp;   //to find max value in window\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> mnhp; \\n        //to find min value in window\\n        while(j<n) //until we reach to end\\n        {\\n            while(j<n) \\n            {\\n                mxhp.push({nums[j],j}); //push value and index in max heap\\n                mnhp.push({nums[j],j}); //push value and index in min heap\\n                mx=mxhp.top().first;    //store max value of window\\n                mn=mnhp.top().first;    //store min value of window\\n                if(mx-mn>limit)         //if we crosses limit difference , then now we have to change window     \\n                {   \\n                    while(!mxhp.empty()&&mxhp.top().second<=i) mxhp.pop();//remove ith or before element from heap\\n                    while(!mnhp.empty()&&mnhp.top().second<=i) mnhp.pop();//remove ith or before element from heap \\n                    j++;break;          \\n                    //increment window size and break window, because we have stored jth \\n                    //index value , next time we will store (j+1)th index value\\n                }\\n                res=max(j-i+1,res);     //update window length \\n                j++;                    //increase window size\\n            } \\n            i++;    //decrease windowsize  from starting\\n        } \\n        return res; //return final maximum window size\\n    }\\n};\\n```\\n***Time Complexity: O(nlogn)\\nSpace cmplexity: O(n)***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\nclass Solution {\\n   \\npublic:\\n    //here I have used pair to handle duplicate values and can be categoried by index\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int i=0,j=0,n=nums.size(),mx,mn,res=0;\\n        priority_queue<pair<int,int>> mxhp;   //to find max value in window\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> mnhp; \\n        //to find min value in window\\n        while(j<n) //until we reach to end\\n        {\\n            while(j<n) \\n            {\\n                mxhp.push({nums[j],j}); //push value and index in max heap\\n                mnhp.push({nums[j],j}); //push value and index in min heap\\n                mx=mxhp.top().first;    //store max value of window\\n                mn=mnhp.top().first;    //store min value of window\\n                if(mx-mn>limit)         //if we crosses limit difference , then now we have to change window     \\n                {   \\n                    while(!mxhp.empty()&&mxhp.top().second<=i) mxhp.pop();//remove ith or before element from heap\\n                    while(!mnhp.empty()&&mnhp.top().second<=i) mnhp.pop();//remove ith or before element from heap \\n                    j++;break;          \\n                    //increment window size and break window, because we have stored jth \\n                    //index value , next time we will store (j+1)th index value\\n                }\\n                res=max(j-i+1,res);     //update window length \\n                j++;                    //increase window size\\n            } \\n            i++;    //decrease windowsize  from starting\\n        } \\n        return res; //return final maximum window size\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 806278,
                "title": "with-constant-memory-with-o-n-solution",
                "content": "The idea behind this solution is to maintain higher and lower at each point. If the current value difference with higher and lower end less than or equal to limit then will keep counting.\\n\\nOtherwise, we will find the last index from left where condition doesn\\'t satisfy in the same loop will also update higher and lower end.\\n\\n\\tpublic int longestSubarray(int[] nums, int limit) {\\n        int maxLen=1;\\n        int idx=0;\\n        int minVal=nums[0];\\n        int maxVal=nums[0];\\n        int cnt=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(Math.abs(minVal-nums[i])<=limit && Math.abs(maxVal-nums[i])<=limit){\\n                cnt++;\\n                maxVal=Math.max(maxVal,nums[i]);\\n                minVal=Math.min(minVal,nums[i]);\\n            }else{\\n                cnt=1;\\n                minVal=nums[i];\\n                maxVal=nums[i];\\n                for(int j=i-1;j>=idx;j--){\\n                    if(Math.abs(nums[i]-nums[j])>limit){\\n                        idx=j+1;\\n                        break;\\n                    }\\n                    minVal=Math.min(minVal,nums[j]);\\n                    maxVal=Math.max(maxVal,nums[j]);\\n                    cnt++;\\n                }\\n            }\\n            maxLen=Math.max(maxLen,cnt);\\n        }\\n        return maxLen;\\n    }",
                "solutionTags": [],
                "code": "The idea behind this solution is to maintain higher and lower at each point. If the current value difference with higher and lower end less than or equal to limit then will keep counting.\\n\\nOtherwise, we will find the last index from left where condition doesn\\'t satisfy in the same loop will also update higher and lower end.\\n\\n\\tpublic int longestSubarray(int[] nums, int limit) {\\n        int maxLen=1;\\n        int idx=0;\\n        int minVal=nums[0];\\n        int maxVal=nums[0];\\n        int cnt=1;\\n        for(int i=1;i<nums.length;i++){\\n            if(Math.abs(minVal-nums[i])<=limit && Math.abs(maxVal-nums[i])<=limit){\\n                cnt++;\\n                maxVal=Math.max(maxVal,nums[i]);\\n                minVal=Math.min(minVal,nums[i]);\\n            }else{\\n                cnt=1;\\n                minVal=nums[i];\\n                maxVal=nums[i];\\n                for(int j=i-1;j>=idx;j--){\\n                    if(Math.abs(nums[i]-nums[j])>limit){\\n                        idx=j+1;\\n                        break;\\n                    }\\n                    minVal=Math.min(minVal,nums[j]);\\n                    maxVal=Math.max(maxVal,nums[j]);\\n                    cnt++;\\n                }\\n            }\\n            maxLen=Math.max(maxLen,cnt);\\n        }\\n        return maxLen;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 803679,
                "title": "priorityqueue-java-o-nlogn-easy-to-understand",
                "content": "```class Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int ans = 0;\\n        int n = nums.length;\\n        \\n        PriorityQueue<Integer> asc = new PriorityQueue<>((a,b)->a-b);\\n        PriorityQueue<Integer> dsc = new PriorityQueue<>((a,b)->b-a);\\n        \\n        Integer[] arr = new Integer[n];\\n        for(int i = 0; i < n; i++)\\n            arr[i] = nums[i];\\n        \\n        int head = 0;\\n        int tail = 0;\\n        \\n        while(tail < n){\\n            asc.add(arr[tail]);\\n            dsc.add(arr[tail]);\\n            \\n            while(dsc.peek() - asc.peek() > limit){\\n                asc.remove(arr[head]);\\n                dsc.remove(arr[head]);\\n                head++;\\n            }\\n            \\n            ans = Math.max(ans, tail-head+1);\\n            tail++;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int ans = 0;\\n        int n = nums.length;\\n        \\n        PriorityQueue<Integer> asc = new PriorityQueue<>((a,b)->a-b);\\n        PriorityQueue<Integer> dsc = new PriorityQueue<>((a,b)->b-a);\\n        \\n        Integer[] arr = new Integer[n];\\n        for(int i = 0; i < n; i++)\\n            arr[i] = nums[i];\\n        \\n        int head = 0;\\n        int tail = 0;\\n        \\n        while(tail < n){\\n            asc.add(arr[tail]);\\n            dsc.add(arr[tail]);\\n            \\n            while(dsc.peek() - asc.peek() > limit){\\n                asc.remove(arr[head]);\\n                dsc.remove(arr[head]);\\n                head++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 792938,
                "title": "heap-sliding-window-o-nlogn",
                "content": "```\\ndef longestSubarray(self, nums: List[int], limit: int) -> int:\\n        \\n    \\n        \\n        minheap=[]\\n        maxheap=[]\\n        heapq.heapify(minheap)\\n        heapq.heapify(maxheap)\\n        length=1\\n        i=0\\n        j=1\\n        heapq.heappush(minheap,[nums[0],0]) # add first element and its index\\n        heapq.heappush(maxheap,[-nums[0],0])\\n        maxindex=0\\n        while i<=j and j<=len(nums)-1:\\n            if abs(minheap[0][0]-nums[j])<=limit and abs(abs(maxheap[0][0])-nums[j])<= limit:\\n                length=max(length,j-i+1)\\n                heapq.heappush(minheap,[nums[j],j])\\n                heapq.heappush(maxheap,[-nums[j],j])\\n                j=j+1\\n            else:\\n                while len(minheap)>0 and abs(minheap[0][0]-nums[j])>limit:\\n                    ele,index=heapq.heappop(minheap)\\n                    maxindex=max(maxindex,index)\\n                while len(maxheap)>0 and abs(-maxheap[0][0]-nums[j])>limit:\\n                    ele,index=heapq.heappop(maxheap)\\n                    maxindex=max(maxindex,index)\\n                i=maxindex+1   # update i and now  we are not concerned with element before ith index\\n                heapq.heappush(minheap,[nums[j],j]) # add  element and its index\\n                heapq.heappush(maxheap,[-nums[j],j])\\n                j=j+1\\n            \\n        return length\\n```",
                "solutionTags": [],
                "code": "```\\ndef longestSubarray(self, nums: List[int], limit: int) -> int:\\n        \\n    \\n        \\n        minheap=[]\\n        maxheap=[]\\n        heapq.heapify(minheap)\\n        heapq.heapify(maxheap)\\n        length=1\\n        i=0\\n        j=1\\n        heapq.heappush(minheap,[nums[0],0]) # add first element and its index\\n        heapq.heappush(maxheap,[-nums[0],0])\\n        maxindex=0\\n        while i<=j and j<=len(nums)-1:\\n            if abs(minheap[0][0]-nums[j])<=limit and abs(abs(maxheap[0][0])-nums[j])<= limit:\\n                length=max(length,j-i+1)\\n                heapq.heappush(minheap,[nums[j],j])\\n                heapq.heappush(maxheap,[-nums[j],j])\\n                j=j+1\\n            else:\\n                while len(minheap)>0 and abs(minheap[0][0]-nums[j])>limit:\\n                    ele,index=heapq.heappop(minheap)\\n                    maxindex=max(maxindex,index)\\n                while len(maxheap)>0 and abs(-maxheap[0][0]-nums[j])>limit:\\n                    ele,index=heapq.heappop(maxheap)\\n                    maxindex=max(maxindex,index)\\n                i=maxindex+1   # update i and now  we are not concerned with element before ith index\\n                heapq.heappush(minheap,[nums[j],j]) # add  element and its index\\n                heapq.heappush(maxheap,[-nums[j],j])\\n                j=j+1\\n            \\n        return length\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 782042,
                "title": "golang-solution-using-sliding-window-and-min-max-queues",
                "content": "Sliding window approach using min and max queues\\nOnly thing to think about here is - how we maintain next smallest and largest values to use when we shrink our window from left\\nIdea is to maintain the min and max values of current window along with next min and max values which we may require when we shorten our sliding window.\\nSo we use 2 slices \\n- one to maintain smallest elem at 0th \\n- another to maintain largest at 0th\\n```\\nfunc longestSubarray(nums []int, limit int) int {\\n    res := 1\\n\\tn := len(nums)\\n\\tminList := make([]int, 0)\\n\\tmaxList := make([]int, 0)\\n\\n\\ts, e := 0, 0\\n\\n\\tfor e < n {\\n\\t\\tcurr := nums[e]\\n\\n\\t\\t// Here we always maintain the min and max elements in respective slices 0th position\\n\\t\\t// min elements slice\\n\\t\\tfor len(minList) > 0 && nums[minList[len(minList)-1]] >= curr {\\n\\t\\t\\tminList = minList[:len(minList)-1] // keep removing all elemnts greater than current, to ensure  we have min element at 0th\\n\\t\\t}\\n\\t\\t// max elements slice\\n\\t\\tfor len(maxList) > 0 && nums[maxList[len(maxList)-1]] <= curr {\\n\\t\\t\\tmaxList = maxList[:len(maxList)-1] // keep removing all elemnts lesser than current, to ensure we have max element at 0th\\n\\t\\t}\\n\\n\\t\\tminList = append(minList, e)\\n\\t\\tmaxList = append(maxList, e)\\n\\n\\n\\t\\tfor nums[maxList[0]]-nums[minList[0]] > limit {\\n\\t\\t\\t// if invalid state , pop from starting index till it becomes valid\\n\\t\\t\\ts++\\n\\t\\t\\tfor len(minList) > 0 && minList[0] < s {\\n\\t\\t\\t\\tminList = minList[1:]\\n\\t\\t\\t}\\n\\t\\t\\tfor len(maxList) > 0 && maxList[0] < s {\\n\\t\\t\\t\\tmaxList = maxList[1:]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres = max(res, e-s+1)\\n\\t\\te++\\n\\n\\t}\\n\\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc longestSubarray(nums []int, limit int) int {\\n    res := 1\\n\\tn := len(nums)\\n\\tminList := make([]int, 0)\\n\\tmaxList := make([]int, 0)\\n\\n\\ts, e := 0, 0\\n\\n\\tfor e < n {\\n\\t\\tcurr := nums[e]\\n\\n\\t\\t// Here we always maintain the min and max elements in respective slices 0th position\\n\\t\\t// min elements slice\\n\\t\\tfor len(minList) > 0 && nums[minList[len(minList)-1]] >= curr {\\n\\t\\t\\tminList = minList[:len(minList)-1] // keep removing all elemnts greater than current, to ensure  we have min element at 0th\\n\\t\\t}\\n\\t\\t// max elements slice\\n\\t\\tfor len(maxList) > 0 && nums[maxList[len(maxList)-1]] <= curr {\\n\\t\\t\\tmaxList = maxList[:len(maxList)-1] // keep removing all elemnts lesser than current, to ensure we have max element at 0th\\n\\t\\t}\\n\\n\\t\\tminList = append(minList, e)\\n\\t\\tmaxList = append(maxList, e)\\n\\n\\n\\t\\tfor nums[maxList[0]]-nums[minList[0]] > limit {\\n\\t\\t\\t// if invalid state , pop from starting index till it becomes valid\\n\\t\\t\\ts++\\n\\t\\t\\tfor len(minList) > 0 && minList[0] < s {\\n\\t\\t\\t\\tminList = minList[1:]\\n\\t\\t\\t}\\n\\t\\t\\tfor len(maxList) > 0 && maxList[0] < s {\\n\\t\\t\\t\\tmaxList = maxList[1:]\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres = max(res, e-s+1)\\n\\t\\te++\\n\\n\\t}\\n\\n    return res\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 741535,
                "title": "c-slide-window-and-lazy-update-of-max-and-min-value-technique",
                "content": "July 17, 2020\\n\\n**Introduction**\\nIt is my first algorithm in my Leetcode mock interview phone screen. The subarray should be continuous based on my analysis. So the array can not be sorted, the order has to be kept. \\n\\nOne of ideas is to apply slide window technique to find current width if the window meets the requirement of difference between max and min value. \\n\\n**TLE concern**\\nHow to keep minimum value and maximum value of sliding window? Do I need to consider maximum heap and minimum heap for values in sliding window? I skipped the consideration and ran into Time Limit Exceeded, so I add some pruning, only call Max and Min in sliding window when current value is Max or Min. \\n\\n```\\npublic class Solution {\\n    public int LongestSubarray(int[] nums, int limit) {\\n        \\n        // subarray should be continuous\\n        // brute force solution O(n*n)\\n        // optimal solution using slide window - keep max/ min window count for slide window\\n        // also keep count of value in slide window as well\\n        // using hashmap<Int, int>, key - integer value, value - count of number\\n        // max and min heap to get O(1) for maximum and minimum in sliding window\\n        // To simplify, use Max/ Min count instead\\n        if(nums == null || nums.Length == 0 || limit < 0)\\n            return 0; \\n        \\n        var length = nums.Length; \\n        \\n        var map = new Dictionary<int, int>(); \\n        \\n        var max = 0; \\n        var left = 0; \\n        var index = 0; \\n        \\n        // [8, 2, 4, 7], limit = 4\\n        while(index < length)\\n        {\\n            var current = nums[index]; // 7                        \\n            \\n            if(map.Count > 0)\\n            {\\n                var maxInWindow = map.Keys.Max();\\n                var minInWindow = map.Keys.Min(); \\n            \\n                while(map.Count > 0 && (Math.Abs(maxInWindow - current) > limit || Math.Abs(minInWindow - current) > limit))\\n                {\\n                    // slide left pointer\\n                    var leftValue = nums[left]; // 2\\n                    map[leftValue]--; // map[8] = 0\\n                    if(map[leftValue] == 0)\\n                    {\\n                        map.Remove(leftValue); //{}\\n                    }\\n                \\n                    // \\n                    if(leftValue == maxInWindow && !map.ContainsKey(leftValue))\\n                    {\\n                        if(map.Count == 0)\\n                        {\\n                            maxInWindow = current; \\n                        }\\n                        else\\n                        {\\n                            maxInWindow = map.Keys.Max();\\n                        }\\n                    }\\n                    \\n                    if(leftValue == minInWindow && !map.ContainsKey(leftValue))\\n                    {\\n                        if(map.Count == 0)\\n                        {\\n                           minInWindow = current;\\n                        }\\n                        else\\n                        {\\n                            minInWindow = map.Keys.Min(); \\n                        }\\n                    }\\n                    \\n                    left++; // 1\\n                }             \\n            }\\n            \\n            var width = index - left + 1;                 \\n            max = Math.Max(max, width); // 2\\n                \\n            //add current to map\\n            if(!map.ContainsKey(current))\\n            {\\n                map.Add(current, 0);\\n            }\\n                \\n            map[current]++; // map[2] = 1  map[4]=1                    \\n            \\n            index++;                \\n        }\\n        \\n        return max; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int LongestSubarray(int[] nums, int limit) {\\n        \\n        // subarray should be continuous\\n        // brute force solution O(n*n)\\n        // optimal solution using slide window - keep max/ min window count for slide window\\n        // also keep count of value in slide window as well\\n        // using hashmap<Int, int>, key - integer value, value - count of number\\n        // max and min heap to get O(1) for maximum and minimum in sliding window\\n        // To simplify, use Max/ Min count instead\\n        if(nums == null || nums.Length == 0 || limit < 0)\\n            return 0; \\n        \\n        var length = nums.Length; \\n        \\n        var map = new Dictionary<int, int>(); \\n        \\n        var max = 0; \\n        var left = 0; \\n        var index = 0; \\n        \\n        // [8, 2, 4, 7], limit = 4\\n        while(index < length)\\n        {\\n            var current = nums[index]; // 7                        \\n            \\n            if(map.Count > 0)\\n            {\\n                var maxInWindow = map.Keys.Max();\\n                var minInWindow = map.Keys.Min(); \\n            \\n                while(map.Count > 0 && (Math.Abs(maxInWindow - current) > limit || Math.Abs(minInWindow - current) > limit))\\n                {\\n                    // slide left pointer\\n                    var leftValue = nums[left]; // 2\\n                    map[leftValue]--; // map[8] = 0\\n                    if(map[leftValue] == 0)\\n                    {\\n                        map.Remove(leftValue); //{}\\n                    }\\n                \\n                    // \\n                    if(leftValue == maxInWindow && !map.ContainsKey(leftValue))\\n                    {\\n                        if(map.Count == 0)\\n                        {\\n                            maxInWindow = current; \\n                        }\\n                        else\\n                        {\\n                            maxInWindow = map.Keys.Max();\\n                        }\\n                    }\\n                    \\n                    if(leftValue == minInWindow && !map.ContainsKey(leftValue))\\n                    {\\n                        if(map.Count == 0)\\n                        {\\n                           minInWindow = current;\\n                        }\\n                        else\\n                        {\\n                            minInWindow = map.Keys.Min(); \\n                        }\\n                    }\\n                    \\n                    left++; // 1\\n                }             \\n            }\\n            \\n            var width = index - left + 1;                 \\n            max = Math.Max(max, width); // 2\\n                \\n            //add current to map\\n            if(!map.ContainsKey(current))\\n            {\\n                map.Add(current, 0);\\n            }\\n                \\n            map[current]++; // map[2] = 1  map[4]=1                    \\n            \\n            index++;                \\n        }\\n        \\n        return max; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 721619,
                "title": "python-rust-sliding-window-and-deque",
                "content": "- **Python**\\n\\n```python\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int):\\n        i, maxq, minq = 0, [], []\\n        \\n        for num in nums:\\n            while len(maxq) and num > maxq[-1]: maxq.pop()\\n            while len(minq) and num < minq[-1]: minq.pop()\\n                \\n            maxq.append(num)\\n            minq.append(num)\\n            \\n            if maxq[0] - minq[0] > limit:\\n                if maxq[0] == nums[i]: maxq.pop(0)\\n                if minq[0] == nums[i]: minq.pop(0)\\n                i += 1\\n                \\n        return len(nums) - i\\n```\\n\\n- **Rust**\\n\\n```rust\\nimpl Solution {\\n    pub fn longest_subarray(nums: Vec<i32>, limit: i32) -> i32 {\\n        let mut i = 0;\\n        let mut minq: Vec<i32> = vec![];\\n        let mut maxq: Vec<i32> = vec![];\\n        \\n        for num in nums.iter() {\\n            while minq.len() > 0 && num < minq.last().unwrap() {\\n                minq.pop();\\n            }\\n            \\n            while maxq.len() > 0 && num > maxq.last().unwrap() {\\n                maxq.pop();\\n            }\\n            \\n            minq.push(*num);\\n            maxq.push(*num);\\n            \\n            if maxq[0] - minq[0] > limit {\\n                if minq[0] == nums[i] { minq.remove(0); }\\n                if maxq[0] == nums[i] { maxq.remove(0); }\\n                i += 1;\\n            }\\n            \\n        }\\n        \\n        return (nums.len() as i32) - (i as i32);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Python",
                    "Rust",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int):\\n        i, maxq, minq = 0, [], []\\n        \\n        for num in nums:\\n            while len(maxq) and num > maxq[-1]: maxq.pop()\\n            while len(minq) and num < minq[-1]: minq.pop()\\n                \\n            maxq.append(num)\\n            minq.append(num)\\n            \\n            if maxq[0] - minq[0] > limit:\\n                if maxq[0] == nums[i]: maxq.pop(0)\\n                if minq[0] == nums[i]: minq.pop(0)\\n                i += 1\\n                \\n        return len(nums) - i\\n```\n```rust\\nimpl Solution {\\n    pub fn longest_subarray(nums: Vec<i32>, limit: i32) -> i32 {\\n        let mut i = 0;\\n        let mut minq: Vec<i32> = vec![];\\n        let mut maxq: Vec<i32> = vec![];\\n        \\n        for num in nums.iter() {\\n            while minq.len() > 0 && num < minq.last().unwrap() {\\n                minq.pop();\\n            }\\n            \\n            while maxq.len() > 0 && num > maxq.last().unwrap() {\\n                maxq.pop();\\n            }\\n            \\n            minq.push(*num);\\n            maxq.push(*num);\\n            \\n            if maxq[0] - minq[0] > limit {\\n                if minq[0] == nums[i] { minq.remove(0); }\\n                if maxq[0] == nums[i] { maxq.remove(0); }\\n                i += 1;\\n            }\\n            \\n        }\\n        \\n        return (nums.len() as i32) - (i as i32);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 719893,
                "title": "c-solution-using-deque",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        \\n        std::deque<pair<int, int>> max_deque;\\n        std::deque<pair<int, int>> min_deque;\\n        \\n        int start_window = 0;\\n        int end_window = -1;\\n        int maxLen = 0;\\n        int K = limit;\\n        \\n        for (int i = 0; i < nums.size(); i++) {        \\n            \\n            while (!max_deque.empty() &&\\n                   max_deque.back().second < nums[i]) {\\n                max_deque.pop_back();\\n            }\\n            \\n            max_deque.push_back({i, nums[i]});\\n             \\n            while (!min_deque.empty() &&\\n                   min_deque.back().second > nums[i]) {\\n                min_deque.pop_back();\\n            }\\n            \\n            min_deque.push_back({i, nums[i]});\\n            \\n            if (max_deque.front().first == i) {\\n                \\n                // Found a new max. Start popping from the\\n                // min deque till the difference between max\\n                // and min becomes <= K.\\n                \\n                while (!min_deque.empty() &&\\n                       (max_deque.front().second - min_deque.front().second) > K) {\\n                    \\n\\t\\t\\t\\t\\t// Start window index will now be the index after the element that\\n\\t\\t\\t\\t\\t// was causing the difference between max and min to be > K.\\n                    start_window = min_deque.front().first + 1;\\n                    min_deque.pop_front();\\n                }\\n                \\n            } else if (min_deque.front().first == i) {\\n                \\n                // Found a new min. Start popping from the\\n                // max deque till the difference between max\\n                // and min becomes <= K.\\n                \\n                while (!max_deque.empty() &&\\n                       (max_deque.front().second - min_deque.front().second) > K) {\\n                    \\n\\t\\t\\t\\t\\t// Start window index will now be the index after the element that\\n\\t\\t\\t\\t\\t// was causing the difference between max and min to be > K.\\n                    start_window = max_deque.front().first + 1;\\n                    max_deque.pop_front();\\n                }\\n            }\\n            \\n            end_window++;\\n            \\n            if ((end_window - start_window + 1) > maxLen) {\\n                maxLen = end_window - start_window + 1;\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        \\n        std::deque<pair<int, int>> max_deque;\\n        std::deque<pair<int, int>> min_deque;\\n        \\n        int start_window = 0;\\n        int end_window = -1;\\n        int maxLen = 0;\\n        int K = limit;\\n        \\n        for (int i = 0; i < nums.size(); i++) {        \\n            \\n            while (!max_deque.empty() &&\\n                   max_deque.back().second < nums[i]) {\\n                max_deque.pop_back();\\n            }\\n            \\n            max_deque.push_back({i, nums[i]});\\n             \\n            while (!min_deque.empty() &&\\n                   min_deque.back().second > nums[i]) {\\n                min_deque.pop_back();\\n            }\\n            \\n            min_deque.push_back({i, nums[i]});\\n            \\n            if (max_deque.front().first == i) {\\n                \\n                // Found a new max. Start popping from the\\n                // min deque till the difference between max\\n                // and min becomes <= K.\\n                \\n                while (!min_deque.empty() &&\\n                       (max_deque.front().second - min_deque.front().second) > K) {\\n                    \\n\\t\\t\\t\\t\\t// Start window index will now be the index after the element that\\n\\t\\t\\t\\t\\t// was causing the difference between max and min to be > K.\\n                    start_window = min_deque.front().first + 1;\\n                    min_deque.pop_front();\\n                }\\n                \\n            } else if (min_deque.front().first == i) {\\n                \\n                // Found a new min. Start popping from the\\n                // max deque till the difference between max\\n                // and min becomes <= K.\\n                \\n                while (!max_deque.empty() &&\\n                       (max_deque.front().second - min_deque.front().second) > K) {\\n                    \\n\\t\\t\\t\\t\\t// Start window index will now be the index after the element that\\n\\t\\t\\t\\t\\t// was causing the difference between max and min to be > K.\\n                    start_window = max_deque.front().first + 1;\\n                    max_deque.pop_front();\\n                }\\n            }\\n            \\n            end_window++;\\n            \\n            if ((end_window - start_window + 1) > maxLen) {\\n                maxLen = end_window - start_window + 1;\\n            }\\n        }\\n        \\n        return maxLen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 690374,
                "title": "java-sliding-window-treemap",
                "content": "```\\nclass Solution {\\n    \\n    private void decreaseInMap(Integer key, TreeMap<Integer, Integer> map) {\\n        if (!map.containsKey(key)) {\\n            return;\\n        }\\n        int value = map.get(key);\\n        if (value == 1) {\\n            map.remove(key);\\n        } else {\\n            map.put(key, value - 1);\\n        }\\n    }\\n    \\n    private void incrementInMap(Integer key, TreeMap<Integer, Integer> map) {\\n        map.put(key, map.getOrDefault(key, 0) + 1);\\n    }\\n    \\n    public int longestSubarray(int[] nums, int limit) {\\n        int left = 0;\\n        int right = 0;\\n        int diff = 0;\\n        int ans = 0;\\n        TreeMap<Integer, Integer> heap = new TreeMap<Integer, Integer>();\\n        while (right < nums.length) {\\n            incrementInMap(nums[right], heap);\\n            diff = Math.abs(heap.firstKey() - heap.lastKey());\\n            \\n            while (left <= right && diff > limit) {\\n                int toRemove = nums[left];\\n                decreaseInMap(toRemove, heap);\\n                diff = Math.abs(heap.firstKey() - heap.lastKey());\\n                ++left;\\n            }\\n            \\n            if (diff <= limit) {\\n                ans = Math.max(ans, right - left + 1);\\n            }\\n            ++right;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private void decreaseInMap(Integer key, TreeMap<Integer, Integer> map) {\\n        if (!map.containsKey(key)) {\\n            return;\\n        }\\n        int value = map.get(key);\\n        if (value == 1) {\\n            map.remove(key);\\n        } else {\\n            map.put(key, value - 1);\\n        }\\n    }\\n    \\n    private void incrementInMap(Integer key, TreeMap<Integer, Integer> map) {\\n        map.put(key, map.getOrDefault(key, 0) + 1);\\n    }\\n    \\n    public int longestSubarray(int[] nums, int limit) {\\n        int left = 0;\\n        int right = 0;\\n        int diff = 0;\\n        int ans = 0;\\n        TreeMap<Integer, Integer> heap = new TreeMap<Integer, Integer>();\\n        while (right < nums.length) {\\n            incrementInMap(nums[right], heap);\\n            diff = Math.abs(heap.firstKey() - heap.lastKey());\\n            \\n            while (left <= right && diff > limit) {\\n                int toRemove = nums[left];\\n                decreaseInMap(toRemove, heap);\\n                diff = Math.abs(heap.firstKey() - heap.lastKey());\\n                ++left;\\n            }\\n            \\n            if (diff <= limit) {\\n                ans = Math.max(ans, right - left + 1);\\n            }\\n            ++right;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 667320,
                "title": "java-2-deques",
                "content": "Idea:\\n1, Maintain min and max mono deques;\\n2, save index but compare with value;\\n3, in each loop,\\n...  \\ta, remove right high or lower to maintain the deque\\n...  \\tb, remove left when max - min > limit;\\n\\t\\n```\\n    public int longestSubarray(int[] nums, int lmt) {\\n        Deque<Integer> lq = new ArrayDeque<>(), rq = new ArrayDeque<>();\\n        int res = 0, lastValid = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (lq.size() > 0 && nums[lq.peekLast()] < nums[i]) lq.pollLast();\\n            while (rq.size() > 0 && nums[rq.peekLast()] > nums[i]) rq.pollLast();\\n            lq.offer(i);\\n            rq.offer(i);\\n            while (nums[lq.peek()] - nums[rq.peek()] > lmt) {\\n                if (lq.peek() > rq.peek()) lastValid = rq.poll() + 1;\\n                else lastValid = lq.poll() + 1;\\n            }\\n            res = Math.max(res, i - lastValid + 1);\\n            \\n        }  \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int longestSubarray(int[] nums, int lmt) {\\n        Deque<Integer> lq = new ArrayDeque<>(), rq = new ArrayDeque<>();\\n        int res = 0, lastValid = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            while (lq.size() > 0 && nums[lq.peekLast()] < nums[i]) lq.pollLast();\\n            while (rq.size() > 0 && nums[rq.peekLast()] > nums[i]) rq.pollLast();\\n            lq.offer(i);\\n            rq.offer(i);\\n            while (nums[lq.peek()] - nums[rq.peek()] > lmt) {\\n                if (lq.peek() > rq.peek()) lastValid = rq.poll() + 1;\\n                else lastValid = lq.poll() + 1;\\n            }\\n            res = Math.max(res, i - lastValid + 1);\\n            \\n        }  \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 663717,
                "title": "python-intuitive-solution-with-sliding-window-and-deques",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        maxd = deque()\\n        mind = deque()\\n        \\n        l, r, res = 0, 0, 0\\n        \\n        while r < len(nums):\\n            while maxd and nums[r] > nums[maxd[-1]]:\\n                maxd.pop()\\n            while mind and nums[r] < nums[mind[-1]]:\\n                mind.pop()\\n                \\n            maxd.append(r)\\n            mind.append(r)\\n            r += 1\\n\\n            while l < r and nums[maxd[0]] - nums[mind[0]] > limit:\\n                if maxd[0] == l: maxd.popleft()\\n                if mind[0] == l: mind.popleft()\\n                l += 1\\n            res = max(res, r - l)\\n\\t\\t\\t\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        maxd = deque()\\n        mind = deque()\\n        \\n        l, r, res = 0, 0, 0\\n        \\n        while r < len(nums):\\n            while maxd and nums[r] > nums[maxd[-1]]:\\n                maxd.pop()\\n            while mind and nums[r] < nums[mind[-1]]:\\n                mind.pop()\\n                \\n            maxd.append(r)\\n            mind.append(r)\\n            r += 1\\n\\n            while l < r and nums[maxd[0]] - nums[mind[0]] > limit:\\n                if maxd[0] == l: maxd.popleft()\\n                if mind[0] == l: mind.popleft()\\n                l += 1\\n            res = max(res, r - l)\\n\\t\\t\\t\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613269,
                "title": "straightforward-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& A, int limit) {\\n        int i = 0, j;\\n        multiset<int> m;\\n        for (j = 0; j < A.size(); ++j) {\\n            m.insert(A[j]);\\n            if (*m.rbegin() - *m.begin() > limit)\\n                m.erase(m.find(A[i++]));\\n        }\\n        return j - i;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& A, int limit) {\\n        int i = 0, j;\\n        multiset<int> m;\\n        for (j = 0; j < A.size(); ++j) {\\n            m.insert(A[j]);\\n            if (*m.rbegin() - *m.begin() > limit)\\n                m.erase(m.find(A[i++]));\\n        }\\n        return j - i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 610663,
                "title": "c-solution-explained-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& arr, int limit) {\\n        multiset<pair<int,int>>ms;        //to store the numbers and their index.\\n        int i=0,j=0,ans=0;\\n        for(int i=0 ; i<arr.size() ; i++)\\n        {\\n            ms.insert({arr[i],i});         //inset the values in the multiset until the difference between the 1st and last values of multiset > limit\\n            while(j<arr.size() and ((*ms.rbegin()).first-(*ms.begin()).first > limit))   //if the difference between the 1st and last values > limit then start deleting from the multiset to create a new subsequence.\\n            {\\n                auto it=ms.find({arr[j],j});\\n                ms.erase(it);\\n                j++;\\n            }\\n            ans=max(ans,i-j+1);      //store the max length of subarray.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& arr, int limit) {\\n        multiset<pair<int,int>>ms;        //to store the numbers and their index.\\n        int i=0,j=0,ans=0;\\n        for(int i=0 ; i<arr.size() ; i++)\\n        {\\n            ms.insert({arr[i],i});         //inset the values in the multiset until the difference between the 1st and last values of multiset > limit\\n            while(j<arr.size() and ((*ms.rbegin()).first-(*ms.begin()).first > limit))   //if the difference between the 1st and last values > limit then start deleting from the multiset to create a new subsequence.\\n            {\\n                auto it=ms.find({arr[j],j});\\n                ms.erase(it);\\n                j++;\\n            }\\n            ans=max(ans,i-j+1);      //store the max length of subarray.\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 610346,
                "title": "short-c-solution-using-priority-queue-with-explanation",
                "content": "We can use two-pointer approach with start as `lo` and end as `i` itself (loop variable). Now what we basically want is the min. and max. in the window of size (lo...i) which can be computed using two priority queues (Note: Priority_queues in C++ support duplicate values) - one for min. `min_pq` and the other for max. `max_pq`.\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) \\n    {\\n        priority_queue < pair < int, int > > max_pq;\\n        priority_queue < pair < int, int >, vector < pair < int, int > > , greater < pair < int, int > > > min_pq;\\n        \\n        int lo = 0, ans = 1;\\n        \\n        min_pq.push({nums[0], 0});\\n        max_pq.push({nums[0], 0});\\n        \\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            min_pq.push({nums[i], i});\\n            max_pq.push({nums[i], i});\\n            \\n            while(min_pq.top().second < lo)\\n                min_pq.pop();\\n            \\n            while(max_pq.top().second < lo)\\n                max_pq.pop();\\n            \\n            if(max_pq.top().first - min_pq.top().first <= limit)\\n                ans = max(ans, i - lo + 1);\\n            else\\n                lo++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) \\n    {\\n        priority_queue < pair < int, int > > max_pq;\\n        priority_queue < pair < int, int >, vector < pair < int, int > > , greater < pair < int, int > > > min_pq;\\n        \\n        int lo = 0, ans = 1;\\n        \\n        min_pq.push({nums[0], 0});\\n        max_pq.push({nums[0], 0});\\n        \\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            min_pq.push({nums[i], i});\\n            max_pq.push({nums[i], i});\\n            \\n            while(min_pq.top().second < lo)\\n                min_pq.pop();\\n            \\n            while(max_pq.top().second < lo)\\n                max_pq.pop();\\n            \\n            if(max_pq.top().first - min_pq.top().first <= limit)\\n                ans = max(ans, i - lo + 1);\\n            else\\n                lo++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 610053,
                "title": "java-sliding-window-no-extra-space-6ms",
                "content": "The idea is to record the max and min till current position. If the gap between min and max exceeds limit, left of window will move to min(position of min, position of max).\\n\\n```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int min = Integer.MAX_VALUE;\\n        int posmin = 0;\\n        int max = Integer.MIN_VALUE;\\n        int posmax = 0;\\n        int idx = 0;\\n        int left = 0;\\n        int res = 0;\\n        while (idx<nums.length){\\n            if (nums[idx]>max){\\n                max = nums[idx];\\n                posmax = idx;\\n            }\\n            if (nums[idx]<min){\\n                min = nums[idx];\\n                posmin = idx;\\n            }\\n            if (max-min<=limit){\\n                res = Math.max(res, idx-left+1);\\n                idx++;\\n            }else{\\n                left = Math.min(posmin, posmax)+1;\\n                idx = left;\\n                min = Integer.MAX_VALUE;\\n                max = Integer.MIN_VALUE;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int min = Integer.MAX_VALUE;\\n        int posmin = 0;\\n        int max = Integer.MIN_VALUE;\\n        int posmax = 0;\\n        int idx = 0;\\n        int left = 0;\\n        int res = 0;\\n        while (idx<nums.length){\\n            if (nums[idx]>max){\\n                max = nums[idx];\\n                posmax = idx;\\n            }\\n            if (nums[idx]<min){\\n                min = nums[idx];\\n                posmin = idx;\\n            }\\n            if (max-min<=limit){\\n                res = Math.max(res, idx-left+1);\\n                idx++;\\n            }else{\\n                left = Math.min(posmin, posmax)+1;\\n                idx = left;\\n                min = Integer.MAX_VALUE;\\n                max = Integer.MIN_VALUE;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 610028,
                "title": "java-two-pointer",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int l = 0;\\n        int res = 0;\\n        while(l<nums.length){\\n            if(nums.length - res < l) return res;\\n            int min = nums[l];\\n            int max = nums[l];\\n            int maxIdx = l;\\n            int r = l;\\n            while(r<nums.length){\\n               min = Math.min(min,nums[r]);\\n               max = Math.max(max,nums[r]);\\n               if(Math.abs(min-max)<=limit){\\n                  res = Math.max(res,r-l+1);\\n                  r++;\\n                  continue; \\n               }else break;\\n            }\\n            l++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        int l = 0;\\n        int res = 0;\\n        while(l<nums.length){\\n            if(nums.length - res < l) return res;\\n            int min = nums[l];\\n            int max = nums[l];\\n            int maxIdx = l;\\n            int r = l;\\n            while(r<nums.length){\\n               min = Math.min(min,nums[r]);\\n               max = Math.max(max,nums[r]);\\n               if(Math.abs(min-max)<=limit){\\n                  res = Math.max(res,r-l+1);\\n                  r++;\\n                  continue; \\n               }else break;\\n            }\\n            l++;\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609895,
                "title": "javascript-2-pointer-2-deques",
                "content": "```javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} limit\\n * @return {number}\\n */\\nvar longestSubarray = function(nums, limit) {\\n    let result = 0;\\n    const maxDeque = new Deque();\\n    const minDeque = new Deque();\\n    let left = -1;\\n    for (let right = 0; right < nums.length; right++) {\\n        const value = nums[right];\\n        while (!maxDeque.isEmpty() && nums[maxDeque.first()] - value > limit) {\\n            left = Math.max(left, maxDeque.dequeue());\\n        }\\n        while (!minDeque.isEmpty() && value - nums[minDeque.first()] > limit) {\\n            left = Math.max(left, minDeque.dequeue());\\n        }\\n        result = Math.max(result, right - left);\\n        while (!minDeque.isEmpty() && nums[minDeque.last()] > value) {\\n            minDeque.pop();\\n        }\\n        while (!maxDeque.isEmpty() && nums[maxDeque.last()] < value) {\\n            maxDeque.pop();\\n        }\\n        maxDeque.enqueue(right);\\n        minDeque.enqueue(right);\\n    }\\n    return result;\\n};\\n\\nclass Deque {\\n    constructor() {\\n        this.head = new Node();\\n        this.tail = new Node();\\n        this.head.next = this.tail;\\n        this.tail.prev = this.head;\\n    }\\n    \\n    isEmpty() {\\n        return this.head.next === this.tail;\\n    }\\n    \\n    first() {\\n        const { next } = this.head;\\n        if (next === this.tail) return null;\\n        return next.index;\\n    }\\n    \\n    last() {\\n        const { prev } = this.tail;\\n        if (prev === this.head) return null;\\n        return prev.index;\\n    }\\n    \\n    enqueue(index) {\\n        const node = new Node(index);\\n        const { prev } = this.tail;\\n        prev.next = node;\\n        node.prev = prev;\\n        node.next = this.tail;\\n        this.tail.prev = node;\\n    }\\n    \\n    dequeue() {\\n        const node = this.head.next;\\n        if (node === this.tail) return null;\\n        const { next } = node;\\n        this.head.next = next;\\n        next.prev = this.head;\\n        node.next = node.prev = null;\\n        return node.index;\\n    }\\n    \\n    pop() {\\n        const node = this.tail.prev;\\n        if (node === this.head) return null;\\n        const { prev } = node;\\n        prev.next = this.tail;\\n        this.tail.prev = prev;\\n        node.next = node.prev = null;\\n        return node.index;\\n    }\\n}\\n    \\nclass Node {\\n    constructor(index) {\\n        this.index = index;\\n        this.prev = this.next = null;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Two Pointers",
                    "Queue"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} limit\\n * @return {number}\\n */\\nvar longestSubarray = function(nums, limit) {\\n    let result = 0;\\n    const maxDeque = new Deque();\\n    const minDeque = new Deque();\\n    let left = -1;\\n    for (let right = 0; right < nums.length; right++) {\\n        const value = nums[right];\\n        while (!maxDeque.isEmpty() && nums[maxDeque.first()] - value > limit) {\\n            left = Math.max(left, maxDeque.dequeue());\\n        }\\n        while (!minDeque.isEmpty() && value - nums[minDeque.first()] > limit) {\\n            left = Math.max(left, minDeque.dequeue());\\n        }\\n        result = Math.max(result, right - left);\\n        while (!minDeque.isEmpty() && nums[minDeque.last()] > value) {\\n            minDeque.pop();\\n        }\\n        while (!maxDeque.isEmpty() && nums[maxDeque.last()] < value) {\\n            maxDeque.pop();\\n        }\\n        maxDeque.enqueue(right);\\n        minDeque.enqueue(right);\\n    }\\n    return result;\\n};\\n\\nclass Deque {\\n    constructor() {\\n        this.head = new Node();\\n        this.tail = new Node();\\n        this.head.next = this.tail;\\n        this.tail.prev = this.head;\\n    }\\n    \\n    isEmpty() {\\n        return this.head.next === this.tail;\\n    }\\n    \\n    first() {\\n        const { next } = this.head;\\n        if (next === this.tail) return null;\\n        return next.index;\\n    }\\n    \\n    last() {\\n        const { prev } = this.tail;\\n        if (prev === this.head) return null;\\n        return prev.index;\\n    }\\n    \\n    enqueue(index) {\\n        const node = new Node(index);\\n        const { prev } = this.tail;\\n        prev.next = node;\\n        node.prev = prev;\\n        node.next = this.tail;\\n        this.tail.prev = node;\\n    }\\n    \\n    dequeue() {\\n        const node = this.head.next;\\n        if (node === this.tail) return null;\\n        const { next } = node;\\n        this.head.next = next;\\n        next.prev = this.head;\\n        node.next = node.prev = null;\\n        return node.index;\\n    }\\n    \\n    pop() {\\n        const node = this.tail.prev;\\n        if (node === this.head) return null;\\n        const { prev } = node;\\n        prev.next = this.tail;\\n        this.tail.prev = prev;\\n        node.next = node.prev = null;\\n        return node.index;\\n    }\\n}\\n    \\nclass Node {\\n    constructor(index) {\\n        this.index = index;\\n        this.prev = this.next = null;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609875,
                "title": "c-using-dequeue-to-maintains-min-and-max-values-in-subarrays",
                "content": "```csharp\\npublic int LongestSubarray(int[] nums, int limit)\\n{\\n\\tLinkedList<int> minDequeue = new LinkedList<int>();\\n\\tLinkedList<int> maxDequeue = new LinkedList<int>();\\n\\n\\tint maxLength = 1;\\n\\tint start = 0;\\n\\tfor (int end = 0; end < nums.Length; end++)\\n\\t{\\n\\t\\twhile (minDequeue.Count > 0 && minDequeue.Last.Value > nums[end])\\n\\t\\t{\\n\\t\\t\\tminDequeue.RemoveLast();\\n\\t\\t}\\n\\n\\t\\twhile (maxDequeue.Count > 0 && maxDequeue.Last.Value < nums[end])\\n\\t\\t{\\n\\t\\t\\tmaxDequeue.RemoveLast();\\n\\t\\t}\\n\\n\\t\\tminDequeue.AddLast(nums[end]);\\n\\t\\tmaxDequeue.AddLast(nums[end]);\\n\\n\\t\\twhile (maxDequeue.Count > 0 && minDequeue.Count > 0 && maxDequeue.First.Value - minDequeue.First.Value > limit)\\n\\t\\t{\\n\\t\\t\\tif (minDequeue.First.Value == nums[start])\\n\\t\\t\\t{\\n\\t\\t\\t\\tminDequeue.RemoveFirst();\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tif (maxDequeue.First.Value == nums[start])\\n\\t\\t\\t{\\n\\t\\t\\t\\tmaxDequeue.RemoveFirst();\\n\\t\\t\\t}\\n\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\n\\t\\tmaxLength = Math.Max(maxLength, end - start + 1);\\n\\t}\\n\\n\\treturn maxLength;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic int LongestSubarray(int[] nums, int limit)\\n{\\n\\tLinkedList<int> minDequeue = new LinkedList<int>();\\n\\tLinkedList<int> maxDequeue = new LinkedList<int>();\\n\\n\\tint maxLength = 1;\\n\\tint start = 0;\\n\\tfor (int end = 0; end < nums.Length; end++)\\n\\t{\\n\\t\\twhile (minDequeue.Count > 0 && minDequeue.Last.Value > nums[end])\\n\\t\\t{\\n\\t\\t\\tminDequeue.RemoveLast();\\n\\t\\t}\\n\\n\\t\\twhile (maxDequeue.Count > 0 && maxDequeue.Last.Value < nums[end])\\n\\t\\t{\\n\\t\\t\\tmaxDequeue.RemoveLast();\\n\\t\\t}\\n\\n\\t\\tminDequeue.AddLast(nums[end]);\\n\\t\\tmaxDequeue.AddLast(nums[end]);\\n\\n\\t\\twhile (maxDequeue.Count > 0 && minDequeue.Count > 0 && maxDequeue.First.Value - minDequeue.First.Value > limit)\\n\\t\\t{\\n\\t\\t\\tif (minDequeue.First.Value == nums[start])\\n\\t\\t\\t{\\n\\t\\t\\t\\tminDequeue.RemoveFirst();\\n\\t\\t\\t}\\n\\n\\n\\t\\t\\tif (maxDequeue.First.Value == nums[start])\\n\\t\\t\\t{\\n\\t\\t\\t\\tmaxDequeue.RemoveFirst();\\n\\t\\t\\t}\\n\\n\\t\\t\\tstart++;\\n\\t\\t}\\n\\n\\t\\tmaxLength = Math.Max(maxLength, end - start + 1);\\n\\t}\\n\\n\\treturn maxLength;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 609829,
                "title": "python3-max-min-deques",
                "content": "Algorithm\\nKeep track of the max and min in two deques. \\n\\nImplementation\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        lo = i = ans = 0\\n        minq, maxq = deque(), deque() #(index, value)\\n        \\n        while i < len(nums): \\n            while minq and minq[-1][1] >= nums[i]: minq.pop()\\n            while maxq and maxq[-1][1] <= nums[i]: maxq.pop()\\n            minq.append((i, nums[i]))\\n            maxq.append((i, nums[i]))\\n            \\n            if maxq[0][1] - minq[0][1] > limit:\\n                lo += 1\\n                if lo > minq[0][0]: minq.popleft()\\n                if lo > maxq[0][0]: maxq.popleft()\\n            else:\\n                ans = max(ans, i - lo + 1)\\n                i += 1\\n        return ans \\n```\\n\\nA more efficient implementation is given by @lee215 in this [thread](https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC%2B%2BPython-Deques-O(N)). \\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        i = 0\\n        minq, maxq = deque(), deque()\\n        \\n        for num in nums: \\n            while minq and minq[-1] > num: minq.pop()\\n            while maxq and maxq[-1] < num: maxq.pop()\\n            minq.append(num)\\n            maxq.append(num)\\n            \\n            if maxq[0] - minq[0] > limit:\\n                if nums[i] == minq[0]: minq.popleft()\\n                if nums[i] == maxq[0]: maxq.popleft()\\n                i += 1\\n        return len(nums) - i  \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        lo = i = ans = 0\\n        minq, maxq = deque(), deque() #(index, value)\\n        \\n        while i < len(nums): \\n            while minq and minq[-1][1] >= nums[i]: minq.pop()\\n            while maxq and maxq[-1][1] <= nums[i]: maxq.pop()\\n            minq.append((i, nums[i]))\\n            maxq.append((i, nums[i]))\\n            \\n            if maxq[0][1] - minq[0][1] > limit:\\n                lo += 1\\n                if lo > minq[0][0]: minq.popleft()\\n                if lo > maxq[0][0]: maxq.popleft()\\n            else:\\n                ans = max(ans, i - lo + 1)\\n                i += 1\\n        return ans \\n```\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        i = 0\\n        minq, maxq = deque(), deque()\\n        \\n        for num in nums: \\n            while minq and minq[-1] > num: minq.pop()\\n            while maxq and maxq[-1] < num: maxq.pop()\\n            minq.append(num)\\n            maxq.append(num)\\n            \\n            if maxq[0] - minq[0] > limit:\\n                if nums[i] == minq[0]: minq.popleft()\\n                if nums[i] == maxq[0]: maxq.popleft()\\n                i += 1\\n        return len(nums) - i  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 609793,
                "title": "python-3-sliding-window-2-monotonic-queues-o-n-with-explanations",
                "content": "## Explanations\\n\\nWe use two indices `start_idx` and `end_idx` to represent a sliding window, `nums[start_idx:end_idx]`, in `nums`.\\n\\nTo keep track of the minimum and the maximum value in the window, we use 2 monotonic queues.\\nIt\\'s a common technique to use a monotonic queue to keep track of the minimum/maximum value in a sliding window.\\n[239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is one of such problems.\\n\\n`min_idxs` is a monotonically increasing queue which contains **the indices of numbers that could become the minimum in the window** when the range of the window is updated.\\n`min_idxs[0]` is always the rightmost index of the minimum number in the window.\\n`nums[min_idxs[i]] < nums[min_idxs[i+1]]` for all `i < len(min_idxs) - 1`\\n\\nSimilarly, \\n`max_idxs` is a monotonically decreasing queue which contains **the indices of numbers that could become the maximum in the window** when the range of the window is updated.\\n`max_idxs[0]` is always the rightmost index of the maximum number in the window.\\n`nums[max_idxs[i]] > nums[max_idxs[i+1]]` for all `i < len(max_idxs) - 1`\\n\\nAfter each loop, the sliding window will be the longest valid (with absolute diff <= limit) subarray ends at `end_idx`.\\nOur last job is to keep track of the max length of such subarrays.\\n\\n## Example\\n\\nFor example, after some loops, the states are\\n```\\nlimit = 4\\nindex =      0 1 2 3 4 5 6 7\\nnums =       5 3 7 3 6 4 8 7\\n             ^          ^\\nstart_idx, end_idx = 0, 6\\nwindow = nums[0:6] = [5, 3, 7, 3, 6, 4]\\nmin_idxs = [3, 5], min_in_window = nums[3] = 3\\nmax_idxs = [2, 4, 5], max_in_window = nums[2] = 7\\n```\\n\\nIn the beginning of the next loop, we move `end_idx` forward and update `min_idxs` and `max_idxs`.\\nNotice that [2, 4, 5] is popped from `max_idxs` because `nums[6]: 8` is greater than `nums[5]: 4`, `nums[4]: 6`, `nums[2]: 7`.\\n```\\nlimit = 4\\nindex =      0 1 2 3 4 5 6 7\\nnums =       5 3 7 3 6 4 8 7\\n             ^            ^\\nstart_idx, end_idx = 0, 7\\nwindow = nums[0:7] = [5, 3, 7, 3, 6, 4, 8]\\nmin_idxs = [3, 5, 6], min_in_window = nums[3] = 3\\nmax_idxs = [6], max_in_window = nums[6] = 8\\n```\\n\\nNow we find that `max_in_window - min_in_window == 5 > limit`,\\nso we move start_idx to `min_idxs[0] + 1` and pop min_idxs[0].\\n```\\nlimit = 4\\nindex =      0 1 2 3 4 5 6 7\\nnums =       5 3 7 3 6 4 8 7\\n                     ^    ^\\nstart_idx, end_idx = 4, 7\\nwindow = nums[4:7] [6, 4, 8]\\nmin_idxs = [5, 6], min_in_window = nums[5] = 4\\nmax_idxs = [6], max_in_window = nums[6] = 8\\n```\\n\\nThen we move `end_idx` forward again in the next loop.\\n\\n## Analysis\\n\\nTime: O(n) because `start_idx` and `end_idx` will both move n times at most\\nSpace: O(n)\\n\\n## Code\\n\\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # sliding window, nums[start_idx:end_idx]\\n        start_idx, end_idx = 0, 0\\n\\n        # monotonic queues\\n        min_idxs = deque() # nums[i] increasing\\n        max_idxs = deque() # nums[i] decreasing\\n\\n        ans = 0\\n        while end_idx < len(nums):\\n            end_idx += 1\\n            new_idx = end_idx - 1\\n            new_num = nums[new_idx]\\n\\n            # update mins\\n            while min_idxs and new_num <= nums[min_idxs[-1]]:\\n                min_idxs.pop()\\n            min_idxs.append(new_idx)\\n\\n            # update maxs\\n            while max_idxs and new_num >= nums[max_idxs[-1]]:\\n                max_idxs.pop()\\n            max_idxs.append(new_idx)\\n\\n            # min_in_window = nums[min_idxs[0]]\\n            # max_in_window = nums[max_idxs[0]]\\n\\t\\t\\t# diff = max_in_window - min_in_window\\n            # if `diff` > `limit`, move `start_idx` forward until `diff` <= `limit`\\n            while nums[max_idxs[0]] - nums[min_idxs[0]] > limit:\\n                if max_idxs[0] < min_idxs[0]:\\n                    start_idx = max_idxs.popleft() + 1\\n                else:\\n                    start_idx = min_idxs.popleft() + 1\\n            ans = max(ans, end_idx - start_idx)\\n\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nlimit = 4\\nindex =      0 1 2 3 4 5 6 7\\nnums =       5 3 7 3 6 4 8 7\\n             ^          ^\\nstart_idx, end_idx = 0, 6\\nwindow = nums[0:6] = [5, 3, 7, 3, 6, 4]\\nmin_idxs = [3, 5], min_in_window = nums[3] = 3\\nmax_idxs = [2, 4, 5], max_in_window = nums[2] = 7\\n```\n```\\nlimit = 4\\nindex =      0 1 2 3 4 5 6 7\\nnums =       5 3 7 3 6 4 8 7\\n             ^            ^\\nstart_idx, end_idx = 0, 7\\nwindow = nums[0:7] = [5, 3, 7, 3, 6, 4, 8]\\nmin_idxs = [3, 5, 6], min_in_window = nums[3] = 3\\nmax_idxs = [6], max_in_window = nums[6] = 8\\n```\n```\\nlimit = 4\\nindex =      0 1 2 3 4 5 6 7\\nnums =       5 3 7 3 6 4 8 7\\n                     ^    ^\\nstart_idx, end_idx = 4, 7\\nwindow = nums[4:7] [6, 4, 8]\\nmin_idxs = [5, 6], min_in_window = nums[5] = 4\\nmax_idxs = [6], max_in_window = nums[6] = 8\\n```\n```\\nfrom collections import deque\\n\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        # sliding window, nums[start_idx:end_idx]\\n        start_idx, end_idx = 0, 0\\n\\n        # monotonic queues\\n        min_idxs = deque() # nums[i] increasing\\n        max_idxs = deque() # nums[i] decreasing\\n\\n        ans = 0\\n        while end_idx < len(nums):\\n            end_idx += 1\\n            new_idx = end_idx - 1\\n            new_num = nums[new_idx]\\n\\n            # update mins\\n            while min_idxs and new_num <= nums[min_idxs[-1]]:\\n                min_idxs.pop()\\n            min_idxs.append(new_idx)\\n\\n            # update maxs\\n            while max_idxs and new_num >= nums[max_idxs[-1]]:\\n                max_idxs.pop()\\n            max_idxs.append(new_idx)\\n\\n            # min_in_window = nums[min_idxs[0]]\\n            # max_in_window = nums[max_idxs[0]]\\n\\t\\t\\t# diff = max_in_window - min_in_window\\n            # if `diff` > `limit`, move `start_idx` forward until `diff` <= `limit`\\n            while nums[max_idxs[0]] - nums[min_idxs[0]] > limit:\\n                if max_idxs[0] < min_idxs[0]:\\n                    start_idx = max_idxs.popleft() + 1\\n                else:\\n                    start_idx = min_idxs.popleft() + 1\\n            ans = max(ans, end_idx - start_idx)\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609702,
                "title": "c-two-pointers-solution-with-detailed-comments",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint longestSubarray(vector<int>& nums, int limit) {\\n\\t\\t\\tif(nums.empty()) return 0;\\n\\t\\t\\tif(nums.size()==1) return 1; //corner cases\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint curMAX=nums[0];\\n\\t\\t\\tint curMIN=nums[0];\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tint left=0; // left pointer\\n\\t\\t\\tfor(int i=1;i<nums.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurMAX=max(curMAX,nums[i]); // current max value in the window\\n\\t\\t\\t\\tcurMIN=min(curMIN,nums[i]); // current min value in the window\\n\\t\\t\\t\\tif(nums[i]-curMIN>limit || curMAX-nums[i]>limit) // when nums[i] breaks the window\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint temp=i;\\n\\t\\t\\t\\t\\tleft=temp;\\n\\t\\t\\t\\t\\tcurMAX=nums[i];       // reset max value\\n\\t\\t\\t\\t\\tcurMIN=nums[i];       // reset min value\\n\\n\\t\\t\\t\\t\\twhile(abs(nums[i]-nums[temp])<=limit) // brute force to find left pointer\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tleft=temp;\\n\\t\\t\\t\\t\\t\\ttemp--;\\n\\t\\t\\t\\t\\t\\tcurMAX=max(curMAX,nums[left]); // update max value in the new window \\n\\t\\t\\t\\t\\t\\tcurMIN=min(curMIN,nums[left]); // update min value in the new window\\n\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tans=max(ans,i-left+1);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint longestSubarray(vector<int>& nums, int limit) {\\n\\t\\t\\tif(nums.empty()) return 0;\\n\\t\\t\\tif(nums.size()==1) return 1; //corner cases\\n\\t\\t\\tint n=nums.size();\\n\\t\\t\\tint curMAX=nums[0];\\n\\t\\t\\tint curMIN=nums[0];\\n\\t\\t\\tint ans=0;\\n\\t\\t\\tint left=0; // left pointer\\n\\t\\t\\tfor(int i=1;i<nums.size();i++)\\n\\t\\t\\t{\\n\\t\\t\\t\\tcurMAX=max(curMAX,nums[i]); // current max value in the window\\n\\t\\t\\t\\tcurMIN=min(curMIN,nums[i]); // current min value in the window\\n\\t\\t\\t\\tif(nums[i]-curMIN>limit || curMAX-nums[i]>limit) // when nums[i] breaks the window\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint temp=i;\\n\\t\\t\\t\\t\\tleft=temp;\\n\\t\\t\\t\\t\\tcurMAX=nums[i];       // reset max value\\n\\t\\t\\t\\t\\tcurMIN=nums[i];       // reset min value\\n\\n\\t\\t\\t\\t\\twhile(abs(nums[i]-nums[temp])<=limit) // brute force to find left pointer\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tleft=temp;\\n\\t\\t\\t\\t\\t\\ttemp--;\\n\\t\\t\\t\\t\\t\\tcurMAX=max(curMAX,nums[left]); // update max value in the new window \\n\\t\\t\\t\\t\\t\\tcurMIN=min(curMIN,nums[left]); // update min value in the new window\\n\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 609701,
                "title": "python-two-heap-solution",
                "content": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        minheap = [[nums[0],0]]\\n        maxheap = [[-nums[0],0]]\\n        left = -1\\n        res = 1\\n        for i,val in enumerate(nums[1:]):\\n            j = i+1\\n            while len(maxheap) and len(minheap) and max(val,-maxheap[0][0]) - min(val,minheap[0][0]) > limit:\\n                if val == max(val,-maxheap[0][0]):\\n                    v,l = heapq.heappop(minheap)\\n                if minheap and val == min(val,minheap[0][0]):\\n                    v,l = heapq.heappop(maxheap)\\n                left = max(l,left)\\n            res = max(j-left,res)\\n            heapq.heappush(minheap,[val,j])\\n            heapq.heappush(maxheap,[-val,j])\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        minheap = [[nums[0],0]]\\n        maxheap = [[-nums[0],0]]\\n        left = -1\\n        res = 1\\n        for i,val in enumerate(nums[1:]):\\n            j = i+1\\n            while len(maxheap) and len(minheap) and max(val,-maxheap[0][0]) - min(val,minheap[0][0]) > limit:\\n                if val == max(val,-maxheap[0][0]):\\n                    v,l = heapq.heappop(minheap)\\n                if minheap and val == min(val,minheap[0][0]):\\n                    v,l = heapq.heappop(maxheap)\\n                left = max(l,left)\\n            res = max(j-left,res)\\n            heapq.heappush(minheap,[val,j])\\n            heapq.heappush(maxheap,[-val,j])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 609673,
                "title": "monotonic-queue-sliding-window-with-explanation-python",
                "content": "similar to 239. Sliding Window Maximum https://leetcode.com/problems/sliding-window-maximum/\\nuse a increasing queue and decreasing queue to store max and min within sliding window.\\n\\nAs for sliding window, each time, add a new num from right\\nThen compare whether the diff exceed limit, if so, pop the most left. and maintain new max and min using Monotonic Queue\\n```\\nfrom collections import deque\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        dec_que = deque()\\n        inc_que = deque()\\n        left = right = length = 0\\n        while right < len(nums):\\n            curr = nums[right]\\n            while dec_que and curr >= nums[dec_que[-1]]:\\n                dec_que.pop()\\n            while inc_que and curr <= nums[inc_que[-1]]:\\n                inc_que.pop()\\n            dec_que.append(right)\\n            inc_que.append(right)\\n            right += 1\\n            while nums[dec_que[0]] - nums[inc_que[0]] > limit:\\n                left += 1\\n                if dec_que[0] < left:\\n                    dec_que.popleft()\\n                if inc_que[0] < left:\\n                    inc_que.popleft()\\n            length = max(length, right - left)\\n        return length\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        dec_que = deque()\\n        inc_que = deque()\\n        left = right = length = 0\\n        while right < len(nums):\\n            curr = nums[right]\\n            while dec_que and curr >= nums[dec_que[-1]]:\\n                dec_que.pop()\\n            while inc_que and curr <= nums[inc_que[-1]]:\\n                inc_que.pop()\\n            dec_que.append(right)\\n            inc_que.append(right)\\n            right += 1\\n            while nums[dec_que[0]] - nums[inc_que[0]] > limit:\\n                left += 1\\n                if dec_que[0] < left:\\n                    dec_que.popleft()\\n                if inc_que[0] < left:\\n                    inc_que.popleft()\\n            length = max(length, right - left)\\n        return length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457714,
                "title": "c-easy-concise-sliding-window-multiset-approach",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSliding Window, Multiset\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        multiset<int>s;\\n        int left=0,ans=1;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n            while(!s.empty() && *s.rbegin()-*s.begin() > limit)\\n            s.erase(s.find(nums[left])) ,left++;\\n            ans=max(ans,i-left+1);\\n        }\\n        \\n        \\n     return ans;\\n        \\n    }\\n};\\n```\\nPLEASE UPVOTE !!",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        multiset<int>s;\\n        int left=0,ans=1;\\n        for(int i=0;i<nums.size();i++){\\n            s.insert(nums[i]);\\n            while(!s.empty() && *s.rbegin()-*s.begin() > limit)\\n            s.erase(s.find(nums[left])) ,left++;\\n            ans=max(ans,i-left+1);\\n        }\\n        \\n        \\n     return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450609,
                "title": "magic-of-python-using-sortedlist",
                "content": "- **Some Basics of SortedList** (Source: GFG)\\n\\n**SortedList \\u2013**\\nSorted list is a sorted mutable sequence in which the values are maintained in sorted order.\\n\\n- Functions to add and remove elements:\\n\\n1. add(value) : A function that takes one element as parameter and inserts it into the list by maintaining sorted order. Runtime Complexity: O(log(n))\\n\\n2. update(iterable): A function that takes an iterable as input and updates the SortedList adding all the values from the iterable Runtime complexity: O(k*log(n)).\\n\\n3. clear(): Remove all values from sorted list. Runtime complexity: O(n).\\n\\n4. discard(value): Remove value from sorted list if it is a member. If value is not a member, do nothing. Runtime complexity: O(log(n)).\\n\\n# Complexity\\n- `Time O(N * log(len(queue)))`\\n- `Space O(len(queue))`\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution(object):\\n    def longestSubarray(self, nums, limit):\\n        queue = SortedList()\\n        n, res, ptr = len(nums), 0, 0\\n        for i, num in enumerate(nums):\\n            queue.add([num, i])\\n            while queue and n > ptr and queue[-1][0] - queue[0][0] > limit:\\n                queue.discard([nums[ptr], ptr])\\n                ptr += 1\\n            res = max(res, len(queue))\\n        return res\\n```\\n****UpVote****, if it helps.\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution(object):\\n    def longestSubarray(self, nums, limit):\\n        queue = SortedList()\\n        n, res, ptr = len(nums), 0, 0\\n        for i, num in enumerate(nums):\\n            queue.add([num, i])\\n            while queue and n > ptr and queue[-1][0] - queue[0][0] > limit:\\n                queue.discard([nums[ptr], ptr])\\n                ptr += 1\\n            res = max(res, len(queue))\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106885,
                "title": "python-solution-beats-90",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve this problem, we can use two queues, one to keep track of the maximum numbers and one to keep track of the minimum numbers. Then, we can iterate through the array and add each number to its respective queue. Once we have both queues populated, we can compare the maximum number to the minimum number to see if the difference is less than or equal to the limit. If it is, then we can continue to iterate through the array and add to both queues. If it is not, then we can remove the number at the leftmost index from both queues and move the left pointer up one index. This way, we can maintain a sliding window of numbers, all of which have a difference of less than or equal to the limit.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        max_q = collections.deque()\\n        min_q = collections.deque()\\n        l = 0\\n        for r in range(len(nums)):\\n            while max_q and max_q[-1] < nums[r]:\\n                max_q.pop()\\n            while min_q and min_q[-1] > nums[r]:\\n                min_q.pop()\\n            max_q.append(nums[r])\\n            min_q.append(nums[r])\\n            if max_q[0] - min_q[0] > limit:\\n                if max_q[0] == nums[l]:\\n                    max_q.popleft()\\n                if min_q[0] == nums[l]:\\n                    min_q.popleft()\\n                l += 1\\n        return len(nums) - l\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        max_q = collections.deque()\\n        min_q = collections.deque()\\n        l = 0\\n        for r in range(len(nums)):\\n            while max_q and max_q[-1] < nums[r]:\\n                max_q.pop()\\n            while min_q and min_q[-1] > nums[r]:\\n                min_q.pop()\\n            max_q.append(nums[r])\\n            min_q.append(nums[r])\\n            if max_q[0] - min_q[0] > limit:\\n                if max_q[0] == nums[l]:\\n                    max_q.popleft()\\n                if min_q[0] == nums[l]:\\n                    min_q.popleft()\\n                l += 1\\n        return len(nums) - l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032143,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        multiset<int> s;\\n        int low = 0;\\n        int high = 0;\\n        int ans = 0;\\n\\n        while(high < nums.size()){\\n            s.insert(nums[high++]);\\n            while(*(s.rbegin()) - *(s.begin()) > limit)\\n            s.erase(s.find(nums[low++]));\\n            ans = max(ans,high - low);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        multiset<int> s;\\n        int low = 0;\\n        int high = 0;\\n        int ans = 0;\\n\\n        while(high < nums.size()){\\n            s.insert(nums[high++]);\\n            while(*(s.rbegin()) - *(s.begin()) > limit)\\n            s.erase(s.find(nums[low++]));\\n            ans = max(ans,high - low);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2820243,
                "title": "go-solution-with-two-queues",
                "content": "# Intuition & Approach\\n\\nMaintain queues of mins and maxs.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nfunc longestSubarray(nums []int, limit int) int {   \\n    var mins []int // indices\\n    var maxs []int\\n\\n    s, e := 0, 0 // The first interval\\n    var ans int\\n    for e < len(nums) {\\n        cur := nums[e]\\n\\n        // Clean mins queue till the element we are about to add is bigger then the last added\\n        for len(mins) > 0 && nums[mins[len(mins)-1]] > cur {\\n            mins = mins[:len(mins)-1]\\n        }\\n        // Clean maxs queue till the element we are about to add is smaller then the last added\\n        for len(maxs) > 0 && nums[maxs[len(maxs)-1]] < cur {\\n            maxs = maxs[:len(maxs)-1]\\n        }\\n        mins = append(mins, e)\\n        maxs = append(maxs, e)\\n\\n        // Restore correct limits\\n        for s < e && abs(nums[maxs[0]] - nums[mins[0]]) > limit {\\n            s++\\n            for len(mins) > 0 && mins[0] < s {\\n                mins = mins[1:]\\n            }\\n            for len(maxs) > 0 && maxs[0] < s {\\n                maxs = maxs[1:]\\n            }\\n        }\\n        ans = max(ans, e-s + 1)\\n        e++\\n    }\\n    return ans\\n}\\n\\nfunc max(a, b int) int { if a > b { return a } else { return b }}\\nfunc abs(a int) int { if a < 0 { return -a } else { return a }}\\n```",
                "solutionTags": [
                    "Go",
                    "Queue",
                    "Monotonic Queue"
                ],
                "code": "```\\nfunc longestSubarray(nums []int, limit int) int {   \\n    var mins []int // indices\\n    var maxs []int\\n\\n    s, e := 0, 0 // The first interval\\n    var ans int\\n    for e < len(nums) {\\n        cur := nums[e]\\n\\n        // Clean mins queue till the element we are about to add is bigger then the last added\\n        for len(mins) > 0 && nums[mins[len(mins)-1]] > cur {\\n            mins = mins[:len(mins)-1]\\n        }\\n        // Clean maxs queue till the element we are about to add is smaller then the last added\\n        for len(maxs) > 0 && nums[maxs[len(maxs)-1]] < cur {\\n            maxs = maxs[:len(maxs)-1]\\n        }\\n        mins = append(mins, e)\\n        maxs = append(maxs, e)\\n\\n        // Restore correct limits\\n        for s < e && abs(nums[maxs[0]] - nums[mins[0]]) > limit {\\n            s++\\n            for len(mins) > 0 && mins[0] < s {\\n                mins = mins[1:]\\n            }\\n            for len(maxs) > 0 && maxs[0] < s {\\n                maxs = maxs[1:]\\n            }\\n        }\\n        ans = max(ans, e-s + 1)\\n        e++\\n    }\\n    return ans\\n}\\n\\nfunc max(a, b int) int { if a > b { return a } else { return b }}\\nfunc abs(a int) int { if a < 0 { return -a } else { return a }}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2800001,
                "title": "c-solution-using-multiset",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        int longestSubarray(vector<int> &nums, int limit)\\n        {\\n            multiset<int> st;\\n            int j = 0;\\n            int ans = 0;\\n            for (int i = 0; i < nums.size(); i++)\\n            {\\n                st.insert(nums[i]);\\n                while (*st.rbegin() - *st.begin() > limit)\\n                {\\n                    st.erase(st.find(nums[j++]));\\n                }\\n                ans = max(ans, i - j + 1);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        int longestSubarray(vector<int> &nums, int limit)\\n        {\\n            multiset<int> st;\\n            int j = 0;\\n            int ans = 0;\\n            for (int i = 0; i < nums.size(); i++)\\n            {\\n                st.insert(nums[i]);\\n                while (*st.rbegin() - *st.begin() > limit)\\n                {\\n                    st.erase(st.find(nums[j++]));\\n                }\\n                ans = max(ans, i - j + 1);\\n            }\\n            return ans;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585673,
                "title": "java-sliding-window-o-n-log-m-using-treemap-for-frequencies-and-map-compute-to-remove-zeros",
                "content": "**Intuition**: At any given time, we can test the limit if we keep frequencies in a `TreeMap` and compare the lowest and highest keys.  But to do this, we need a way to remove zeros so they do not falsely indicate a min or max value.  Java 1.8 added some nice methods to the Map interface including `compute`, which takes a key, then a `BiFunction<Integer, Integer, Integer>` which computes the new value for that key, taking the key and existing value (or `null` if there is no existing mapping) as inputs.  But more importantly, if this `BiFunction<>` returns `null`, any existing entry is removed from the map.  This gives us the opportunity to write an increment and decrement function which return `null` instead of zero.  Technically, since we never have a value below zero in a frequency map, our increment `BiFunction` does not need to check for zeros (only our decrement `BiFunction` needs this logic).  And technically, since our decrement `BiFunction` will always find a mapping, it doesn\\'t have to handle a `null` value.  But since these can be useful ways to reclaim unused space in a map (and potentially reduce the time to put new values by having fewer comparisons due to fewer elements in the map), we\\'ll write both `BiFunction`s to handle `null` values and return `null` instead of `0`.  With these available to us, we can maintain a sliding window.  Each time in the loop, we move our right pointer right, and increase the frequency of the next element.  Then, while our max - min is too large, we\\'ll decrement frequencies from the left side, moving our left pointer right.  Since `limit` is always at least 0, and since a single value in the array always has a difference of 0, we\\'ll never have to worry about our left pointer moving past our right pointer.\\n\\n**Building a Solution:**  First, let\\'s work on the sliding window portion.  Imagine for a moment, that we already have two `BiFunction<Integer, Integer, Integer>` called `INCREMENT_VALUE` and `DECREMENT_VALUE`.  The first, `INCREMENT_VALUE`, takes a key and existing value in our map, and logically increments it, handling edge cases where there is no value in the map, etc.  The second, `DECREMENT_VALUE`, does the opposite - it decrements a value, and if that value ends up as zero, it tells the map to remove that mapping, instead.  We\\'ll worry about the implementation of these two in a minute, just take it for granted for a moment that they exist and have this behavior.  Then, we can write our sliding window as:\\n\\n```\\n    public int longestSubarray(int[] nums, int limit) {\\n        final TreeMap<Integer, Integer> freqs = new TreeMap<>();\\n        freqs.put(nums[0], 1);\\n        int i = 0;\\n        int j = 0;\\n        int max = 1;\\n        while ((++j) < nums.length) {\\n\\t\\t\\t// advance our right pointer to the right and increase the frequency of the next value\\n            freqs.compute(nums[j], INCREMENT_VALUE);\\n\\t\\t\\t// determine the difference: max - min\\n            int diff = (freqs.lastKey() - freqs.firstKey());\\n\\t\\t\\t// while this difference exceeds the maximum, decrease the frequency the leftmost value in the window\\n\\t\\t\\t// (removing any zeros) and advance the left pointer, until our difference is within the limit\\n            while (diff > limit) {\\n                freqs.compute(nums[i++], DECREMENT_VALUE);\\n                diff = (freqs.lastKey() - freqs.firstKey());\\n            }\\n\\t\\t\\t// determine the array length (window width):\\n            final int width = (1 + j - i);\\n\\t\\t\\t// check if this width is a new maximum\\n            if (width > max) {\\n                max = width;\\n            }\\n        }\\n        return max;\\n    }\\n```\\n\\nNow, we need to implement these two `BiFunction` constants.  Let\\'s crystallize our requirements so we can build them for reuse these in other contexts.\\n\\nOur `INCREMENT_VALUE` should:\\n* increment null (no entry) to 1\\n* increment an integer value by 1\\n* on incrementing to zero, remove the mapping instead of leaving a mapping to 0\\n\\nOur `DECREMENT_VALUE` should:\\n* decrement null (no entry) to -1\\n* decrement an integer value by 1\\n* on decrementing to zero, remove the mapping instead of leaving a mapping to 0\\n\\nWhen these are used as the second argument to `Map#compute(K, BiFunction<K, V, V>)`, we can achieve our third requirement by checking if the incremented or decremented value is zero, and return `null` instead.  So, we can implement them as follows:\\n\\n```\\n    static final BiFunction<Integer, Integer, Integer> INCREMENT_VALUE = (k, v) -> {\\n        if (v == null) {\\n            return 1;\\n        }\\n        int result = (v + 1);\\n        if (result == 0) {\\n            return null;\\n        }\\n        return result;\\n    };\\n\\n    static final BiFunction<Integer, Integer, Integer> DECREMENT_VALUE = (k, v) -> {\\n        if (v == null) {\\n            return -1;\\n        }\\n        int result = (v - 1);\\n        if (result == 0) {\\n            return null;\\n        }\\n        return result;\\n    };\\n```\\n\\nThese could be written a bit more succinctly, but this way, you can see how each of them addresses each of the three requirements in order.  And they are a bit more than we need - we will never decrement from `null` or increment to zero for example, but again, these are intended to be useful beyond this problem, e.g. for other problems where we wish not to store entries for zero values.\\n\\nPutting things together, we have a full solution.  I\\'ll remove comments, since they were already included above.\\n\\n**Java Code**:\\n\\n```\\nclass Solution {\\n\\n    static final BiFunction<Integer, Integer, Integer> INCREMENT_VALUE = (k, v) -> {\\n        if (v == null) {\\n            return 1;\\n        }\\n        int result = (v + 1);\\n        if (result == 0) {\\n            return null;\\n        }\\n        return result;\\n    };\\n\\n    static final BiFunction<Integer, Integer, Integer> DECREMENT_VALUE = (k, v) -> {\\n        if (v == null) {\\n            return -1;\\n        }\\n        int result = (v - 1);\\n        if (result == 0) {\\n            return null;\\n        }\\n        return result;\\n    };\\n\\n    public int longestSubarray(int[] nums, int limit) {\\n        final TreeMap<Integer, Integer> freqs = new TreeMap<>();\\n        freqs.put(nums[0], 1);\\n        int i = 0;\\n        int j = 0;\\n        int max = 1;\\n        while ((++j) < nums.length) {\\n            freqs.compute(nums[j], INCREMENT_VALUE);\\n            int diff = (freqs.lastKey() - freqs.firstKey());\\n            while (diff > limit) {\\n                freqs.compute(nums[i++], DECREMENT_VALUE);\\n                diff = (freqs.lastKey() - freqs.firstKey());\\n            }\\n            final int width = (1 + j - i);\\n            if (width > max) {\\n                max = width;\\n            }\\n        }\\n        return max;\\n    }\\n\\n}\\n```\\n\\n**Complexity**: In the worst case, we have O(n log n) time complexity for use of the tree map (the `compute` method is at worst equivalent to a `get` followed by a `put` or `remove`, each of which are O(log n)).  But notice that in many cases, the map is not full.  If the answer (max array length) is `m`, we will never have more than `m` values in the map at once, so our time complexity reduces to O(n log m).  Our space complexity is O(n) in the worst case, due to our map containing a mapping for all elements.  But again, this reduces to O(m) due storing at most `m` map entries.\\n\\n**Standard Plea**: If you found this useful, or think someone else might, I would **appreciate your upvote**.  If you didn\\'t like this solution, I would be grateful for your **constructive criticism in the comments**.  I\\'m doing this to have fun coding, and work on my writing, so any comments are appreciated.  Thanks for your time, happy coding, and good luck with interviewing if that\\'s what you\\'re here to practice for!\\n",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Sliding Window"
                ],
                "code": "```\\n    public int longestSubarray(int[] nums, int limit) {\\n        final TreeMap<Integer, Integer> freqs = new TreeMap<>();\\n        freqs.put(nums[0], 1);\\n        int i = 0;\\n        int j = 0;\\n        int max = 1;\\n        while ((++j) < nums.length) {\\n\\t\\t\\t// advance our right pointer to the right and increase the frequency of the next value\\n            freqs.compute(nums[j], INCREMENT_VALUE);\\n\\t\\t\\t// determine the difference: max - min\\n            int diff = (freqs.lastKey() - freqs.firstKey());\\n\\t\\t\\t// while this difference exceeds the maximum, decrease the frequency the leftmost value in the window\\n\\t\\t\\t// (removing any zeros) and advance the left pointer, until our difference is within the limit\\n            while (diff > limit) {\\n                freqs.compute(nums[i++], DECREMENT_VALUE);\\n                diff = (freqs.lastKey() - freqs.firstKey());\\n            }\\n\\t\\t\\t// determine the array length (window width):\\n            final int width = (1 + j - i);\\n\\t\\t\\t// check if this width is a new maximum\\n            if (width > max) {\\n                max = width;\\n            }\\n        }\\n        return max;\\n    }\\n```\n```\\n    static final BiFunction<Integer, Integer, Integer> INCREMENT_VALUE = (k, v) -> {\\n        if (v == null) {\\n            return 1;\\n        }\\n        int result = (v + 1);\\n        if (result == 0) {\\n            return null;\\n        }\\n        return result;\\n    };\\n\\n    static final BiFunction<Integer, Integer, Integer> DECREMENT_VALUE = (k, v) -> {\\n        if (v == null) {\\n            return -1;\\n        }\\n        int result = (v - 1);\\n        if (result == 0) {\\n            return null;\\n        }\\n        return result;\\n    };\\n```\n```\\nclass Solution {\\n\\n    static final BiFunction<Integer, Integer, Integer> INCREMENT_VALUE = (k, v) -> {\\n        if (v == null) {\\n            return 1;\\n        }\\n        int result = (v + 1);\\n        if (result == 0) {\\n            return null;\\n        }\\n        return result;\\n    };\\n\\n    static final BiFunction<Integer, Integer, Integer> DECREMENT_VALUE = (k, v) -> {\\n        if (v == null) {\\n            return -1;\\n        }\\n        int result = (v - 1);\\n        if (result == 0) {\\n            return null;\\n        }\\n        return result;\\n    };\\n\\n    public int longestSubarray(int[] nums, int limit) {\\n        final TreeMap<Integer, Integer> freqs = new TreeMap<>();\\n        freqs.put(nums[0], 1);\\n        int i = 0;\\n        int j = 0;\\n        int max = 1;\\n        while ((++j) < nums.length) {\\n            freqs.compute(nums[j], INCREMENT_VALUE);\\n            int diff = (freqs.lastKey() - freqs.firstKey());\\n            while (diff > limit) {\\n                freqs.compute(nums[i++], DECREMENT_VALUE);\\n                diff = (freqs.lastKey() - freqs.firstKey());\\n            }\\n            final int width = (1 + j - i);\\n            if (width > max) {\\n                max = width;\\n            }\\n        }\\n        return max;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2546353,
                "title": "c-multiset-sliding-window-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit)\\n    {\\n        multiset<int,greater<int>> s;\\n        int i=0,j=0,n=nums.size(),max_len=0;\\n        while(j<n)\\n        {\\n            s.insert(nums[j]);\\n            while((*s.begin()-*s.rbegin())>limit)\\n            {\\n                s.erase(s.find(nums[i++]));\\n            }\\n        \\n            max_len=max(max_len,j-i+1);\\n            j++;\\n        }\\n        return max_len;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit)\\n    {\\n        multiset<int,greater<int>> s;\\n        int i=0,j=0,n=nums.size(),max_len=0;\\n        while(j<n)\\n        {\\n            s.insert(nums[j]);\\n            while((*s.begin()-*s.rbegin())>limit)\\n            {\\n                s.erase(s.find(nums[i++]));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2523480,
                "title": "c-sliding-window-ordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        \\n        int n = nums.size(), i=0, j=0, ans = 0;\\n        map<int,int> m;\\n        auto it = m.begin();\\n        auto it1 = m.rbegin();\\n        \\n        while(j<n){\\n            m[nums[j]] +=1;\\n            it = m.begin();\\n            it1 = m.rbegin();\\n            \\n            if(abs(it->first-it1->first) <= limit){\\n                ans = max(ans, j-i+1);\\n            }else{\\n                while(abs(it->first-it1->first) > limit){\\n                    m[nums[i]] -=1;\\n                    if(m[nums[i]] == 0) m.erase(nums[i]);\\n                    i++;\\n                    it = m.begin();\\n                    it1 = m.rbegin();\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        \\n        int n = nums.size(), i=0, j=0, ans = 0;\\n        map<int,int> m;\\n        auto it = m.begin();\\n        auto it1 = m.rbegin();\\n        \\n        while(j<n){\\n            m[nums[j]] +=1;\\n            it = m.begin();\\n            it1 = m.rbegin();\\n            \\n            if(abs(it->first-it1->first) <= limit){\\n                ans = max(ans, j-i+1);\\n            }else{\\n                while(abs(it->first-it1->first) > limit){\\n                    m[nums[i]] -=1;\\n                    if(m[nums[i]] == 0) m.erase(nums[i]);\\n                    i++;\\n                    it = m.begin();\\n                    it1 = m.rbegin();\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461953,
                "title": "simple-c-solution-with-comments-using-monotonic-2-queues",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        /*\\n            here we will use 2 pointer approach and will check for min and max difference but for maintaining min and max element we will use deque i.e min deque and max deque \\n        */\\n        \\n        deque<int> mn,mx;\\n        int n = nums.size();\\n        int i = 0,j = 0;\\n        int ans = 0;\\n        while(j<n)\\n        {\\n            int x = nums[j];\\n            \\n            // min queue maintaining\\n            while(mn.size() and nums[mn.back()]>x)mn.pop_back();\\n            \\n            // max queue maintaining\\n            while(mx.size() and nums[mx.back()]<x)mx.pop_back();\\n            \\n            mn.push_back(j);\\n            mx.push_back(j);\\n            \\n            if(nums[mx.front()]-nums[mn.front()]>limit)\\n            {\\n                i++;\\n                if(mn.front()<i)mn.pop_front();\\n                if(mx.front()<i)mx.pop_front();\\n            }\\n            else\\n            {\\n                ans = max(ans,j-i+1);\\n            }\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        /*\\n            here we will use 2 pointer approach and will check for min and max difference but for maintaining min and max element we will use deque i.e min deque and max deque \\n        */\\n        \\n        deque<int> mn,mx;\\n        int n = nums.size();\\n        int i = 0,j = 0;\\n        int ans = 0;\\n        while(j<n)\\n        {\\n            int x = nums[j];\\n            \\n            // min queue maintaining\\n            while(mn.size() and nums[mn.back()]>x)mn.pop_back();\\n            \\n            // max queue maintaining\\n            while(mx.size() and nums[mx.back()]<x)mx.pop_back();\\n            \\n            mn.push_back(j);\\n            mx.push_back(j);\\n            \\n            if(nums[mx.front()]-nums[mn.front()]>limit)\\n            {\\n                i++;\\n                if(mn.front()<i)mn.pop_front();\\n                if(mx.front()<i)mx.pop_front();\\n            }\\n            else\\n            {\\n                ans = max(ans,j-i+1);\\n            }\\n            j++;\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2420793,
                "title": "double-deque-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int n=nums.size();\\n        deque<int>miny;\\n        deque<int>maxy;\\n        int s=0;\\n        int e=0;\\n        int ans=0;\\n        while(e<n){\\n            int x=nums[e];\\n         //   cout<<x<<endl;\\n            while(!miny.empty() && nums[miny.back()]>=x){\\n                miny.pop_back();\\n            }\\n            while(!maxy.empty() && nums[maxy.back()]<=x){\\n                maxy.pop_back();\\n            }\\n            \\n            miny.push_back(e);\\n            maxy.push_back(e);\\n            \\n            int dif=nums[maxy.front()]-nums[miny.front()];\\n            if(dif>limit){\\n                s++;\\n                while(!miny.empty() && miny.front()<s){\\n                    miny.pop_front();\\n                }\\n                while(!maxy.empty() && maxy.front()<s){\\n                    maxy.pop_front();\\n                }\\n                \\n                \\n            }\\n            else{\\n                ans=max(ans,e-s+1);\\n                e++;\\n            }\\n          \\n            \\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int n=nums.size();\\n        deque<int>miny;\\n        deque<int>maxy;\\n        int s=0;\\n        int e=0;\\n        int ans=0;\\n        while(e<n){\\n            int x=nums[e];\\n         //   cout<<x<<endl;\\n            while(!miny.empty() && nums[miny.back()]>=x){\\n                miny.pop_back();\\n            }\\n            while(!maxy.empty() && nums[maxy.back()]<=x){\\n                maxy.pop_back();\\n            }\\n            \\n            miny.push_back(e);\\n            maxy.push_back(e);\\n            \\n            int dif=nums[maxy.front()]-nums[miny.front()];\\n            if(dif>limit){\\n                s++;\\n                while(!miny.empty() && miny.front()<s){\\n                    miny.pop_front();\\n                }\\n                while(!maxy.empty() && maxy.front()<s){\\n                    maxy.pop_front();\\n                }\\n                \\n                \\n            }\\n            else{\\n                ans=max(ans,e-s+1);\\n                e++;\\n            }\\n          \\n            \\n            \\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2419650,
                "title": "c-using-two-heaps-two-pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int i = 0;\\n        int j = 0;\\n        priority_queue<pair<int,int>> pqMax;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pqMin;\\n        int ans = 1;\\n        while(i<nums.size() && j<nums.size()){\\n            pqMax.push({nums[j],j});\\n            pqMin.push({nums[j],j});\\n            if(pqMax.top().first-pqMin.top().first>limit){\\n                ans = max(ans,j-i);\\n                while(pqMax.size() && pqMax.top().second<=i)\\n                    pqMax.pop();\\n                 while(pqMin.size() && pqMin.top().second<=i)\\n                    pqMin.pop();\\n                i++;\\n            }\\n            j++;\\n        }\\n        ans = max(ans,j-i);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int i = 0;\\n        int j = 0;\\n        priority_queue<pair<int,int>> pqMax;\\n        priority_queue<pair<int,int>,vector<pair<int,int>>,greater<pair<int,int>>> pqMin;\\n        int ans = 1;\\n        while(i<nums.size() && j<nums.size()){\\n            pqMax.push({nums[j],j});\\n            pqMin.push({nums[j],j});\\n            if(pqMax.top().first-pqMin.top().first>limit){\\n                ans = max(ans,j-i);\\n                while(pqMax.size() && pqMax.top().second<=i)\\n                    pqMax.pop();\\n                 while(pqMin.size() && pqMin.top().second<=i)\\n                    pqMin.pop();\\n                i++;\\n            }\\n            j++;\\n        }\\n        ans = max(ans,j-i);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2349842,
                "title": "using-multiset-and-sliding-window",
                "content": "int longestSubarray(vector<int>& nums, int limit) {\\n\\n       multiset<int>m;\\n        int i=0,j=0,ans=0;\\n        while(j<nums.size())\\n        {\\n            m.insert(nums[j]);\\n            int k=*m.rbegin()-*m.begin();\\n            cout<<k<<endl;\\n            if(k<=limit)\\n                ans=max(ans,j-i+1);\\n            else\\n            {\\n                while(k>limit){\\n                    m.erase(m.find(nums[i]));\\n                    k=*m.end()-*m.begin();\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "int longestSubarray(vector<int>& nums, int limit) {\\n\\n       multiset<int>m;\\n        int i=0,j=0,ans=0;\\n        while(j<nums.size())\\n        {\\n            m.insert(nums[j]);\\n            int k=*m.rbegin()-*m.begin();\\n            cout<<k<<endl;\\n            if(k<=limit)\\n                ans=max(ans,j-i+1);\\n            else\\n            {\\n                while(k>limit){\\n                    m.erase(m.find(nums[i]));\\n                    k=*m.end()-*m.begin();\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2297861,
                "title": "java-2-deque-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        Deque<Integer> max = new ArrayDeque();\\n        Deque<Integer> min = new ArrayDeque();\\n        int j = 0, res = 1;\\n        for (int i = 0; i < nums.length; ++i) {\\n            while (!max.isEmpty() && max.peekLast() < nums[i])\\n                max.removeLast();\\n            \\n            max.addLast(nums[i]);\\n            while (!min.isEmpty() && min.peekLast() > nums[i])\\n                min.removeLast();\\n            \\n            min.addLast(nums[i]);\\n            while (j < nums.length && max.peekFirst() - min.peekFirst() > limit) {\\n                if (max.peekFirst() == nums[j])\\n                    max.pollFirst();\\n                if (min.peekFirst() == nums[j])\\n                    min.pollFirst();\\n                \\n                ++j;\\n            }\\n            \\n            res = Math.max(res, i - j + 1);\\n        }\\n        \\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        Deque<Integer> max = new ArrayDeque();\\n        Deque<Integer> min = new ArrayDeque();\\n        int j = 0, res = 1;\\n        for (int i = 0; i < nums.length; ++i) {\\n            while (!max.isEmpty() && max.peekLast() < nums[i])\\n                max.removeLast();\\n            \\n            max.addLast(nums[i]);\\n            while (!min.isEmpty() && min.peekLast() > nums[i])\\n                min.removeLast();\\n            \\n            min.addLast(nums[i]);\\n            while (j < nums.length && max.peekFirst() - min.peekFirst() > limit) {\\n                if (max.peekFirst() == nums[j])\\n                    max.pollFirst();\\n                if (min.peekFirst() == nums[j])\\n                    min.pollFirst();\\n                \\n                ++j;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2267112,
                "title": "easy-to-understand-clean-java-code",
                "content": "\\n\\n\\'\\'\\'\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n```\\n\\n```class Solution\\n{\\n    public int longestSubarray(int[] nums, int limit) \\n    {\\n        int st=0,end=0,n=nums.length;\\n        PriorityQueue<Integer> max=new PriorityQueue<>(Collections.reverseOrder());\\n        PriorityQueue<Integer> min=new PriorityQueue<>();\\n        int curr=0,max_len=0;\\n        while(end<n)\\n        {\\n            max.offer(nums[end]);\\n            min.offer(nums[end]);\\n            int diff=max.peek()-min.peek();\\n            if(diff<=limit)\\n            {\\n                curr++;\\n            }\\n            else\\n            {\\n                max_len=Math.max(end-st,max_len);\\n                while((max.peek()-min.peek())>limit)\\n                {\\n                    max.remove(nums[st]);\\n                    min.remove(nums[st]);\\n                    \\n                    ++st;\\n                }\\n                \\n            }\\n            ++end;\\n        }\\n        max_len=Math.max(end-st,max_len);\\n        return max_len;\\n    }\\n}\\n\\'\\'\\'",
                "solutionTags": [
                    "Sliding Window",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2250560,
                "title": "python-simple-sliding-window",
                "content": "\\n    def longestSubarray(self, nums, limit):\\n        max_arr, min_arr, left, max_len = [], [], 0, 0\\n        \\n        for right in range(len(nums)):\\n            while max_arr and max_arr[-1] < nums[right]: max_arr.pop()\\n            while min_arr and min_arr[-1] > nums[right]: min_arr.pop()\\n                \\n            max_arr.append(nums[right])\\n            min_arr.append(nums[right])\\n            \\n            while max_arr[0] - min_arr[0] > limit:\\n                if max_arr[0] == nums[left]: max_arr.pop(0)\\n                if min_arr[0] == nums[left]: min_arr.pop(0)\\n                left += 1\\n            \\n            max_len = max(max_len, right - left + 1)\\n                    \\n        return max_len\\n",
                "solutionTags": [],
                "code": "\\n    def longestSubarray(self, nums, limit):\\n        max_arr, min_arr, left, max_len = [], [], 0, 0\\n        \\n        for right in range(len(nums)):\\n            while max_arr and max_arr[-1] < nums[right]: max_arr.pop()\\n            while min_arr and min_arr[-1] > nums[right]: min_arr.pop()\\n                \\n            max_arr.append(nums[right])\\n            min_arr.append(nums[right])\\n            \\n            while max_arr[0] - min_arr[0] > limit:\\n                if max_arr[0] == nums[left]: max_arr.pop(0)\\n                if min_arr[0] == nums[left]: min_arr.pop(0)\\n                left += 1\\n            \\n            max_len = max(max_len, right - left + 1)\\n                    \\n        return max_len\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2245684,
                "title": "sliding-window-with-deque",
                "content": "```\\n# max absolte diff within a subarray is subarray max substracted by subarray min\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        q = collections.deque() # monotonic decreasing deque to compute subarray max, index of\\n        q2 = collections.deque() # monotonic increasing deque to compute subarray min, index of\\n        \\n        # sliding window\\n        res = left = 0\\n        for right in range(len(nums)):\\n            # pop monotocity-violating numbers from right end\\n            while q and nums[q[-1]] <= nums[right]:\\n                q.pop()\\n            q.append(right)\\n            \\n            # pop monotocity-violating numbers from right end\\n            while q2 and nums[q2[-1]] >= nums[right]:\\n                q2.pop()\\n            q2.append(right)\\n            \\n            # sliding window\\n            while left < right and q and q2 and nums[q[0]] - nums[q2[0]] > limit:\\n                # compress window from left pointer\\n                if q and q[0] == left:\\n                    q.popleft()\\n                \\n                # compress left pointer\\n                if q2 and q2[0] == left:\\n                    q2.popleft()\\n                    \\n                left += 1\\n            \\n            if nums[q[0]] - nums[q2[0]] <= limit:\\n                res = max(res, right - left + 1)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# max absolte diff within a subarray is subarray max substracted by subarray min\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        q = collections.deque() # monotonic decreasing deque to compute subarray max, index of\\n        q2 = collections.deque() # monotonic increasing deque to compute subarray min, index of\\n        \\n        # sliding window\\n        res = left = 0\\n        for right in range(len(nums)):\\n            # pop monotocity-violating numbers from right end\\n            while q and nums[q[-1]] <= nums[right]:\\n                q.pop()\\n            q.append(right)\\n            \\n            # pop monotocity-violating numbers from right end\\n            while q2 and nums[q2[-1]] >= nums[right]:\\n                q2.pop()\\n            q2.append(right)\\n            \\n            # sliding window\\n            while left < right and q and q2 and nums[q[0]] - nums[q2[0]] > limit:\\n                # compress window from left pointer\\n                if q and q[0] == left:\\n                    q.popleft()\\n                \\n                # compress left pointer\\n                if q2 and q2[0] == left:\\n                    q2.popleft()\\n                    \\n                left += 1\\n            \\n            if nums[q[0]] - nums[q2[0]] <= limit:\\n                res = max(res, right - left + 1)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240496,
                "title": "java-easy-understanding-sliding-window-without-deque",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        \\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return limit == 0 ? 0 : 1;\\n        int left =  0;\\n        int right = 0; \\n        int min = nums[0];\\n        int max = nums[0];\\n        // PriortyQueue<Integer> min_heap = new PriorityQueue<Integer>();\\n        // PriortyQueue<Integer> max_heap = new PriorityQueue<Integer>((a,b) -> b - a);\\n        \\n        int res = 0;\\n\\n        while(right < nums.length - 1) {\\n            right++; \\n            min = Math.min(min, nums[right]);\\n            max = Math.max(max, nums[right]);\\n            int diff = Math.abs(max - min);\\n            if (diff <= limit) {\\n                res = Math.max(res, right - left + 1);\\n             } else {\\n                int cur_left = left;\\n                     int cur_min = nums[right];\\n                     int cur_max = nums[right]; \\n                 for (int i = right; i >= cur_left; i--) {\\n                    if (Math.abs(nums[right] - nums[i]) <= limit) {\\n                        cur_min = Math.min(cur_min, nums[i]);\\n                        cur_max = Math.max(cur_max, nums[i]);\\n                    } else {\\n                        left = i + 1;\\n                        min = cur_min; \\n                        max = cur_max;\\n                        break;\\n                    }\\n                 }\\n            }      \\n        } \\n        return res; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        \\n        if(nums.length == 0) return 0;\\n        if(nums.length == 1) return limit == 0 ? 0 : 1;\\n        int left =  0;\\n        int right = 0; \\n        int min = nums[0];\\n        int max = nums[0];\\n        // PriortyQueue<Integer> min_heap = new PriorityQueue<Integer>();\\n        // PriortyQueue<Integer> max_heap = new PriorityQueue<Integer>((a,b) -> b - a);\\n        \\n        int res = 0;\\n\\n        while(right < nums.length - 1) {\\n            right++; \\n            min = Math.min(min, nums[right]);\\n            max = Math.max(max, nums[right]);\\n            int diff = Math.abs(max - min);\\n            if (diff <= limit) {\\n                res = Math.max(res, right - left + 1);\\n             } else {\\n                int cur_left = left;\\n                     int cur_min = nums[right];\\n                     int cur_max = nums[right]; \\n                 for (int i = right; i >= cur_left; i--) {\\n                    if (Math.abs(nums[right] - nums[i]) <= limit) {\\n                        cur_min = Math.min(cur_min, nums[i]);\\n                        cur_max = Math.max(cur_max, nums[i]);\\n                    } else {\\n                        left = i + 1;\\n                        min = cur_min; \\n                        max = cur_max;\\n                        break;\\n                    }\\n                 }\\n            }      \\n        } \\n        return res; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203699,
                "title": "java-monotonic-deque",
                "content": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        Deque<Integer> min = new LinkedList<>();\\n        Deque<Integer> max = new LinkedList<>();\\n        int res = 1;\\n        for (int i = 0, j = 0; j < nums.length; j++) {\\n            while (!min.isEmpty() && nums[min.peekLast()] > nums[j])\\n                min.pollLast();\\n            while (!max.isEmpty() && nums[max.peekLast()] < nums[j])\\n                max.pollLast();\\n            min.add(j);\\n            max.add(j);\\n            while (nums[max.peekFirst()] - nums[min.peekFirst()] > limit) {\\n                if (min.peekFirst() == i)\\n                    min.pollFirst();\\n                if (max.peekFirst() == i)\\n                    max.pollFirst();\\n                i++;\\n            }\\n            res = Math.max(res, j - i + 1);\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int longestSubarray(int[] nums, int limit) {\\n        Deque<Integer> min = new LinkedList<>();\\n        Deque<Integer> max = new LinkedList<>();\\n        int res = 1;\\n        for (int i = 0, j = 0; j < nums.length; j++) {\\n            while (!min.isEmpty() && nums[min.peekLast()] > nums[j])\\n                min.pollLast();\\n            while (!max.isEmpty() && nums[max.peekLast()] < nums[j])\\n                max.pollLast();\\n            min.add(j);\\n            max.add(j);\\n            while (nums[max.peekFirst()] - nums[min.peekFirst()] > limit) {\\n                if (min.peekFirst() == i)\\n                    min.pollFirst();\\n                if (max.peekFirst() == i)\\n                    max.pollFirst();\\n                i++;\\n            }\\n            res = Math.max(res, j - i + 1);\\n\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2195088,
                "title": "python-o-n-sliding-window-and-monotonic-queue-solution-with-explanation",
                "content": "sliding window method can solve the problem, but there is a improvement for normal sliding window\\n### brute force sliding window method \\nbrute force sliding window method is that adding value to window, and iterating the sliding window to find difference between max and min, if difference is not meet the requirement, then shrink sliding window, tc: O(N^2)\\n\\n\\n### sliding window with monotonic queue\\nthere is a improvement for brute force sliding window method, we can use a data structure to track min and max in sliding window, whose time of operations we use should be less than O(N), the candidates have min/max heap (insert value/pop max or min: log(N)), monotonic queue (insert value/pop max or min: O(1)), the latter is more time efficient.\\n\\nThe same as sliding window method, ```left``` and ```idx``` is to maintain left and right side of the window.\\n\\nAnd we can use two monotonic queues to track min and max for the window, so one keeps in the non-ascending order (min is on the tail), another keeps in the non-decreasing order (max is on the tail).\\n \\n \\n 1. put current number ```n``` to both queues,  when  ```n``` can not make queues keeps the order, remove the top value from the queues (pop from the top)\\n 2. put the current number ```n```  to the sliding window (put into the queues)\\n 3. check the differece between max and min in the window, if differece not meet the requirement, shrink window size (also pop value from the window (pop from the tail of the queues))\\n 4. find max len of the window\\n \\n both ```if decd[0] - ascd[0] > limit:``` and ```while decd[0] - ascd[0] > limit:``` work\\n \\n consider that nums = ```[1,2,1,10,1,1,1,1]``` and limit = ```4```\\n 0, ascd [1], decd [1], diff = 0, left = 0 -> max ans = 1\\n 1, ascd [1,2], decd [2], diff = 1, left = 0 -> max ans = 2\\n 2, ascd [1,1], decd [2,1], diff = 1, left = 0 -> max ans = 3\\n 3, ascd [1,1,10], decd [10], diff = 9,  left = 0 -> move left: ascd [1,10],  decd [10], diff = 9, left = 1 -> max ans = 3\\n 4, ascd [1,1], decd [10,1], diff = 9, left = 1 ->  move left: ascd [1,1], decd [10,1], diff = 9, left = 2 -> max ans = 3\\n 5, ascd [1,1,1], decd [10,1,1], diff = 9, left = 2 ->  move left: ascd [1,1], decd [10,1,1], diff = 9, left = 3 -> max ans = 3\\n 6, ascd [1,1,1], decd [10,1,1,1], diff = 9, left = 3 -> move left: ascd [1,1,1], decd [1,1,1], diff = 0, left = 4 -> max ans = 3\\n 7, ascd [1,1,1,1], decd [1,1,1,1], diff = 0, left = 4 ->  max ans = 4\\n \\nthere are two subarrarys meet the requirement ```[1,2,1]``` and ```[1,1,1,1]``` , before the right pointer ```idx``` arrive the last ```1``` (```nums[7]```), the  left pointer```left``` is already at correct place, which means if there are a valid sub array whose length is greater than previous valid sub array,  the left pointer will be at correct place sooner or later before the right pointer arrive at the end of valid sub array.\\n\\nBut I think  ```while decd[0] - ascd[0] > limit:``` is more intuitive.\\n \\ntc: O(N) because the value will pop from/ push into the queue once, sc: O(N)\\n```\\nfrom collections import deque\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        ascd, decd, ans, left = deque(), deque(), 0, 0\\n        for idx, n in enumerate(nums):\\n            while ascd and ascd[-1] > n: ascd.pop()\\n            while decd and decd[-1] < n: decd.pop()\\n            ascd.append(n)\\n            decd.append(n)\\n            if decd[0] - ascd[0] > limit:\\n                if decd[0] == nums[left]: decd.popleft()\\n                if ascd[0] == nums[left]: ascd.popleft()\\n                left += 1\\n            ans = max(ans, idx - left + 1)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```left```\n```idx```\n```n```\n```n```\n```n```\n```if decd[0] - ascd[0] > limit:```\n```while decd[0] - ascd[0] > limit:```\n```[1,2,1,10,1,1,1,1]```\n```4```\n```[1,2,1]```\n```[1,1,1,1]```\n```idx```\n```1```\n```nums[7]```\n```left```\n```while decd[0] - ascd[0] > limit:```\n```\\nfrom collections import deque\\nclass Solution:\\n    def longestSubarray(self, nums: List[int], limit: int) -> int:\\n        ascd, decd, ans, left = deque(), deque(), 0, 0\\n        for idx, n in enumerate(nums):\\n            while ascd and ascd[-1] > n: ascd.pop()\\n            while decd and decd[-1] < n: decd.pop()\\n            ascd.append(n)\\n            decd.append(n)\\n            if decd[0] - ascd[0] > limit:\\n                if decd[0] == nums[left]: decd.popleft()\\n                if ascd[0] == nums[left]: ascd.popleft()\\n                left += 1\\n            ans = max(ans, idx - left + 1)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2135883,
                "title": "using-dequeue-2-pointers-approach-well-commented-c",
                "content": "Implementation\\n\\n**Using Dequeue\\nTime Complexity : O(N)\\nSpace Complexity : O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        \\n        // maxElements will hold the elements in decreasing order, and\\n        // minElements will hold the elements in increasing order\\n        deque<int> maxElements, minElements;\\n        \\n        // taking two pointers\\n        // j will always move forward always, and\\n        // i will only move forward, when max & min element will cross the limit\\n        int i = 0, j;\\n        for(j = 0 ; j < nums.size(); j++){\\n            \\n            // if maxElements is not empty & if its back is having smaller element than jth current element in nums, then pop it, bcz maxElements is maintaining a decreasing order\\n            while(!maxElements.empty() && maxElements.back() < nums[j]){\\n                maxElements.pop_back();\\n            }\\n            \\n            // if minElements is not empty & if its back is having greater element than jth current element in nums, then pop it, bcz itminElements is maintaining a increasing order\\n            while(!minElements.empty() && minElements.back() > nums[j]){\\n                minElements.pop_back();\\n            }\\n            \\n            // push the current jth value of nums, into maxElements & minElements\\n            maxElements.push_back(nums[j]);\\n            minElements.push_back(nums[j]);\\n            \\n            // if the max & min element will cross the limit, then i will move forward,\\n            if(maxElements.front() - minElements.front() > limit){\\n                \\n                // if maxElements front is having same value as nums[i], it means needs to pop it, its a old value, and its out of the subarray\\n                if(maxElements.front() == nums[i]) maxElements.pop_front();\\n                \\n                // if minElements front is having same value as nums[i], it means needs to pop it, its a old value, and its out of the subarray\\n                if(minElements.front() == nums[i]) minElements.pop_front();\\n                i++;\\n            }\\n        }        \\n        \\n        // return result\\n        return j-i;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo **please do upvote and encourage me** to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Queue",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        \\n        // maxElements will hold the elements in decreasing order, and\\n        // minElements will hold the elements in increasing order\\n        deque<int> maxElements, minElements;\\n        \\n        // taking two pointers\\n        // j will always move forward always, and\\n        // i will only move forward, when max & min element will cross the limit\\n        int i = 0, j;\\n        for(j = 0 ; j < nums.size(); j++){\\n            \\n            // if maxElements is not empty & if its back is having smaller element than jth current element in nums, then pop it, bcz maxElements is maintaining a decreasing order\\n            while(!maxElements.empty() && maxElements.back() < nums[j]){\\n                maxElements.pop_back();\\n            }\\n            \\n            // if minElements is not empty & if its back is having greater element than jth current element in nums, then pop it, bcz itminElements is maintaining a increasing order\\n            while(!minElements.empty() && minElements.back() > nums[j]){\\n                minElements.pop_back();\\n            }\\n            \\n            // push the current jth value of nums, into maxElements & minElements\\n            maxElements.push_back(nums[j]);\\n            minElements.push_back(nums[j]);\\n            \\n            // if the max & min element will cross the limit, then i will move forward,\\n            if(maxElements.front() - minElements.front() > limit){\\n                \\n                // if maxElements front is having same value as nums[i], it means needs to pop it, its a old value, and its out of the subarray\\n                if(maxElements.front() == nums[i]) maxElements.pop_front();\\n                \\n                // if minElements front is having same value as nums[i], it means needs to pop it, its a old value, and its out of the subarray\\n                if(minElements.front() == nums[i]) minElements.pop_front();\\n                i++;\\n            }\\n        }        \\n        \\n        // return result\\n        return j-i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115814,
                "title": "no-deque-no-multiset-two-pointer-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int mini = INT_MAX-limit;\\n        int maxi = INT_MIN+limit;\\n        int best = INT_MIN;\\n        int start = -1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] <= mini+ limit && nums[i] >= maxi-limit){\\n                mini = min(mini, nums[i]);\\n                maxi = max(maxi, nums[i]);\\n                best = max(best, i - start);\\n            }else if(nums[i] < maxi - limit){\\n                mini = nums[i];\\n                maxi = INT_MIN+limit;\\n                start = i-1;\\n                while(nums[start] >= nums[i] && nums[start]<= nums[i] + limit){\\n                    mini = min(mini, nums[start]);\\n                    maxi = max(maxi, nums[start]);\\n                    start--;\\n                }\\n            }else{\\n                mini = INT_MAX-limit;\\n                maxi = nums[i];\\n                start = i-1;\\n                while(nums[start] <= nums[i] && nums[start]>= nums[i] - limit){\\n                    mini = min(mini, nums[start]);\\n                    maxi = max(maxi, nums[start]);\\n                    start--;\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int longestSubarray(vector<int>& nums, int limit) {\\n        int mini = INT_MAX-limit;\\n        int maxi = INT_MIN+limit;\\n        int best = INT_MIN;\\n        int start = -1;\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] <= mini+ limit && nums[i] >= maxi-limit){\\n                mini = min(mini, nums[i]);\\n                maxi = max(maxi, nums[i]);\\n                best = max(best, i - start);\\n            }else if(nums[i] < maxi - limit){\\n                mini = nums[i];\\n                maxi = INT_MIN+limit;\\n                start = i-1;\\n                while(nums[start] >= nums[i] && nums[start]<= nums[i] + limit){\\n                    mini = min(mini, nums[start]);\\n                    maxi = max(maxi, nums[start]);\\n                    start--;\\n                }\\n            }else{\\n                mini = INT_MAX-limit;\\n                maxi = nums[i];\\n                start = i-1;\\n                while(nums[start] <= nums[i] && nums[start]>= nums[i] - limit){\\n                    mini = min(mini, nums[start]);\\n                    maxi = max(maxi, nums[start]);\\n                    start--;\\n                }\\n            }\\n        }\\n        return best;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2096750,
                "title": "c-sliding-window-deque-simple-solution",
                "content": "**I have maintained two deque to keep track of maximum and minimum element in the subarray.**\\n```\\nint longestSubarray(vector<int>& nums, int limit) {\\n        deque<int> maxi;\\n        deque<int> mini;\\n        int i=0,j=0,n=nums.size(),ans=0;\\n        while(j<n)\\n        {\\n            while(!mini.empty() && mini.back()>nums[j])  // makes sure that the minimum element is in front\\n                mini.pop_back();\\n            mini.push_back(nums[j]);\\n            while(!maxi.empty() && maxi.back()<nums[j]) // makes sure that the maximum element is in front\\n                maxi.pop_back();\\n            maxi.push_back(nums[j]);\\n            if(abs(maxi.front()-mini.front())<=limit)\\n                ans=max(ans,j-i+1);\\n            else\\n            {\\n                while(abs(maxi.front()-mini.front())>limit)\\n                {\\n                    if(maxi.front()==nums[i])\\n                        maxi.pop_front();\\n                    if(mini.front()==nums[i])\\n                        mini.pop_front();\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Queue",
                    "Sliding Window"
                ],
                "code": "```\\nint longestSubarray(vector<int>& nums, int limit) {\\n        deque<int> maxi;\\n        deque<int> mini;\\n        int i=0,j=0,n=nums.size(),ans=0;\\n        while(j<n)\\n        {\\n            while(!mini.empty() && mini.back()>nums[j])  // makes sure that the minimum element is in front\\n                mini.pop_back();\\n            mini.push_back(nums[j]);\\n            while(!maxi.empty() && maxi.back()<nums[j]) // makes sure that the maximum element is in front\\n                maxi.pop_back();\\n            maxi.push_back(nums[j]);\\n            if(abs(maxi.front()-mini.front())<=limit)\\n                ans=max(ans,j-i+1);\\n            else\\n            {\\n                while(abs(maxi.front()-mini.front())>limit)\\n                {\\n                    if(maxi.front()==nums[i])\\n                        maxi.pop_front();\\n                    if(mini.front()==nums[i])\\n                        mini.pop_front();\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1783946,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1568328,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1566613,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1574496,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1842692,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1567562,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1568564,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1569984,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1953736,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1929261,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1783946,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1568328,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1566613,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1574496,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1842692,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1567562,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1568564,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1569984,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1953736,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            },
            {
                "id": 1929261,
                "content": [
                    {
                        "username": "calm27",
                        "content": "it should be hard. problem is nice. something to crack head on, but it is not medium in any dimension. hard-hard. "
                    },
                    {
                        "username": "newRuanXY",
                        "content": "I encountered this exact problem in my Google SWE internship 3rd phone interview 2 months ago. \\nI talked about I had a feeling to use monotonic stacks, but didn\\'t figure it out during the interview :("
                    },
                    {
                        "username": "fabanosim",
                        "content": "Internship? I bet that they weren\\'t expect a complete working answer for you, since this problem requires a sharp algorithmic mind and knowledge about this specific topic. It seems, at least for me, that interns are not suppose to have this level of knowledge yet."
                    },
                    {
                        "username": "rootkonda",
                        "content": "Few Observations On Min/Max solution, which might help understanding:\\n\\n1. First of all, why we use only Min/Max elements in a subarray to check the limit ? Its kind of obvious, because if we compare difference between minimum and maximum elements in a subarray and if thats within the limit, then all elements within that range will also be in that limit.\\n2. Say we have left and right pointers, where right pointer is constantly moving towards the end of array and left pointer only moved when the limit is exceeded.\\n3. Min queue/multiset - Always have elements in ascending order, so minimum element first.\\n    Max queue/multiset - Always have elements in descending order, so maximum element first.\\n4. Starting from zero, we keep going right towards end and for each element in the right we have to check whats the max and min elements so far after considering the current right element. Once we have that, check if that breaks the limit. If so then we have to move the left pointer and make sure to remove the element pointed by left pointer before moving. This is because this element is not valid anymore for comparison.   IMPORTANT: Difference between the right and left pointer will be our max subarray length. This difference is always in non-decreasing order, which means the difference will never go down, it either stays same or increase if there is a new window of size more than exisiting one.\\n5. How is this working? It has three parts here: \\n\\t 1) Say the longest subarray appears at the prefix part of the given array, then the right pointer keeps incrementing until it breaks the limit. The moment it breaks that limit, we are going to move the left pointer only once, which is inline with the right pointer. i.e. 1,2,3,4,8  with limit 5 then when right points to 8 then we have to move the left pointer from index 0 to index 1 and gives the actual window size of 4(right-left -- (1,2,3,4)). Hence moving the left pointer only once guarantees the window length to be non-decreasing.\\n\\t 2) Say the longest subarray appears at the suffix part of the given array, then the left pointer will keep getting incremented until it reaches the index where the difference between right and left doesn\\'t break the limit condition.\\n\\t 3) Say the longest subarray appears in between the start and end of given array, then the left pointer is NOT incremented until the window size of longest subarray is complete and for rest of the right elements, both the right and left pointers will be moved in order to maintain the longest window size.\\n6. If this is clear, then we can say that our answer is right-left, which is our longest subarray length satisfying our limit constraint.\\n\\nMost of the posts in the discuss tab revolves around the above logic I explained. I din\\'t post the code here because lot of people already posted the same logic in different styles. \\n\\nHope this helps!"
                    },
                    {
                        "username": "Chingfeng",
                        "content": "Why this is a medium?  I simply don\\'t understand the double Deque answer."
                    },
                    {
                        "username": "StDannyDan",
                        "content": "Description says \"absolute difference between any two elements of this subarray is less than or equal to limit\", so \"between any two elements\" - if any two elements in the array have absolute diff less than or equal to limit we just return array size but according to examples, description of the problem is not correct? In examples we get \"maximum absolute diff\" for some reason instead of \"any two elements\"."
                    },
                    {
                        "username": "vyshnavkr",
                        "content": "Concept and code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609743/Java-Detailed-Explanation-Sliding-Window-Deque-O(N)\\nSimilar Code: https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/discuss/609771/JavaC++Python-Deques-O(N)\\n\\nConcept coming from: https://leetcode.com/problems/sliding-window-maximum/\\n\\nLearnings:\\n* Using Deque with Sliding window\\n\\nIntution:\\n* **Absolute difference between every pairs** in a subarray must be less than a limit k means: you dont need to find the abs diff for every pair, just find the **min and max** of the subarray and find their abs difference.\\n* why cant we just use a min and max variable at each index rather than introducing a queue: growing a subarray to the right happens only until the limit validation fails. After that we will have to shrink the window by slidng left pointer to right for considering any possible candiddate subarray made from any of these new left pointer to the remaining numbers on the right of where validation failed. So the min and max for each index changes every time due to this **sliding window logic**. So we keep a **min and a max queue**."
                    },
                    {
                        "username": "vinejose",
                        "content": "how is this correct test case\\n\\n[1,5,6,7,8,10,6,5,6]\\n4\\nOutput\\n7\\nExpected\\n5\\n\\nFrom point 6 nums[2], u can get to all 7 points\\n6-7\\n6-8,\\n6-10\\n6-6\\n6-5\\n6-6 all are >= limit (4) .. Not sure what is wrong?\\n\\n\\n"
                    },
                    {
                        "username": "harshitaramani18",
                        "content": "It says absolute difference between any two elements in that sub-array should fall under the limit. Here in the sub-array [6, 7, 8, 10, 6, 5, 6], it contains both 10 and 5. Their difference is 5 and our limit is 4, therefore, the answer is 5(i.e. sub-array [6, 7, 8, 10, 6]) and not 7. "
                    },
                    {
                        "username": "bzez",
                        "content": "1) we move from left(0) to right expanding the possible interval where max-min<=limit, hence the condition is valid for all nums within this interval [left, right], we update our max and min on every step, no surprises here \\n\\n2) when we determine that the condition can\\'t be satisfied we know at this very moment \\n\\t1) the previous valid length\\n\\t2) and that somewhere in that interval [left,right-1] are our max and min elements \\n3) the next left position for a possibly valid interval  should be somewhere after (min or max position), whichever comes first and starting from that we can start shrinking our interval until the condition is satisfied and then continue moving to the right\\n4) it\\'s like a snake, head goes first, and then tail follows\\n"
                    },
                    {
                        "username": "spookyflame",
                        "content": "Can anyone explain how this is medium difficulty when [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/) is hard? Is there an easier way to solve this problem?\n"
                    },
                    {
                        "username": "johnnychang",
                        "content": "WTF this should be a hard problem. It\\'s an upgraded version of 239. Sliding Window Maximum."
                    },
                    {
                        "username": "spookyflame",
                        "content": "I think the same. maybe there\\'s easier way to solve it"
                    }
                ]
            }
        ]
    }
]