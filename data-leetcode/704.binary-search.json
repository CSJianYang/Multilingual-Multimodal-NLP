[
    {
        "title": "Contains Duplicate III",
        "question_content": "You are given an integer array nums and two integers indexDiff and valueDiff.\nFind a pair of indices (i, j) such that:\n\n\ti != j,\n\tabs(i - j) <= indexDiff.\n\tabs(nums[i] - nums[j]) <= valueDiff, and\n\nReturn true if such pair exists or false otherwise.\n&nbsp;\nExample 1:\n\nInput: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\nOutput: true\nExplanation: We can choose (i, j) = (0, 3).\nWe satisfy the three conditions:\ni != j --> 0 != 3\nabs(i - j) <= indexDiff --> abs(0 - 3) <= 3\nabs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0\n\nExample 2:\n\nInput: nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\nOutput: false\nExplanation: After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false.\n\n&nbsp;\nConstraints:\n\n\t2 <= nums.length <= 105\n\t-109 <= nums[i] <= 109\n\t1 <= indexDiff <= nums.length\n\t0 <= valueDiff <= 109",
        "solutions": [
            {
                "id": 61645,
                "title": "ac-o-n-solution-in-java-using-buckets-with-explanation",
                "content": "As a followup question, it naturally also requires maintaining a window of size k. When t == 0, it reduces to the previous question so we just reuse the solution.\\n\\nSince there is now a constraint on the range of the values of the elements to be considered duplicates, it reminds us of doing a range check which is implemented in tree data structure and would take O(LogN) if a balanced tree structure is used, or doing a bucket check which is constant time. We shall just discuss the idea using bucket here.\\n\\nBucketing means we map a range of values to the a bucket. For example, if the bucket size is 3, we consider 0, 1, 2 all map to the same bucket. However, if t == 3, (0, 3) is a considered duplicates but does not map to the same bucket. This is fine since we are checking the buckets immediately before and after as well. So, as a rule of thumb, just make sure the size of the bucket is reasonable such that elements having the same bucket is immediately considered duplicates or duplicates must lie within adjacent buckets. So this actually gives us a range of possible bucket size, i.e. t and t + 1. We just choose it to be t and a bucket mapping to be *num / t*.\\n\\nAnother complication is that negative ints are allowed. A simple *num / t* just shrinks everything towards 0. Therefore, we can just reposition every element to start from Integer.MIN_VALUE.\\n\\n     public class Solution {\\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n            if (k < 1 || t < 0) return false;\\n            Map<Long, Long> map = new HashMap<>();\\n            for (int i = 0; i < nums.length; i++) {\\n                long remappedNum = (long) nums[i] - Integer.MIN_VALUE;\\n                long bucket = remappedNum / ((long) t + 1);\\n                if (map.containsKey(bucket)\\n                        || (map.containsKey(bucket - 1) && remappedNum - map.get(bucket - 1) <= t)\\n                            || (map.containsKey(bucket + 1) && map.get(bucket + 1) - remappedNum <= t))\\n                                return true;\\n                if (map.entrySet().size() >= k) {\\n                    long lastBucket = ((long) nums[i - k] - Integer.MIN_VALUE) / ((long) t + 1);\\n                    map.remove(lastBucket);\\n                }\\n                map.put(bucket, remappedNum);\\n            }\\n            return false;\\n        }\\n    }\\n\\nEdits:\\n\\nActually, we can use t + 1 as the bucket size to get rid of the case when t == 0. It simplifies the code. The above code is therefore the updated version.",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n            if (k < 1 || t < 0) return false;\\n            Map<Long, Long> map = new HashMap<>();\\n            for (int i = 0; i < nums.length; i++) {\\n                long remappedNum = (long) nums[i] - Integer.MIN_VALUE;\\n                long bucket = remappedNum / ((long) t + 1);\\n                if (map.containsKey(bucket)\\n                        || (map.containsKey(bucket - 1) && remappedNum - map.get(bucket - 1) <= t)\\n                            || (map.containsKey(bucket + 1) && map.get(bucket + 1) - remappedNum <= t))\\n                                return true;\\n                if (map.entrySet().size() >= k) {\\n                    long lastBucket = ((long) nums[i - k] - Integer.MIN_VALUE) / ((long) t + 1);\\n                    map.remove(lastBucket);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 61639,
                "title": "java-python-one-pass-solution-o-n-time-o-n-space-using-buckets",
                "content": "The idea is like the bucket sort algorithm. Suppose we have consecutive buckets covering the range of nums with each bucket a width of (t+1). If there are two item with difference <= t, one of the two will happen:\\n\\n    (1) the two in the same bucket\\n    (2) the two in neighbor buckets\\n\\nFor detailed explanation see my blog [here](http://algobox.org/contains-duplicate-iii/)\\n\\n**Python**\\n\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        if t < 0: return False\\n        n = len(nums)\\n        d = {}\\n        w = t + 1\\n        for i in xrange(n):\\n            m = nums[i] / w\\n            if m in d:\\n                return True\\n            if m - 1 in d and abs(nums[i] - d[m - 1]) < w:\\n                return True\\n            if m + 1 in d and abs(nums[i] - d[m + 1]) < w:\\n                return True\\n            d[m] = nums[i]\\n            if i >= k: del d[nums[i - k] / w]\\n        return False\\n\\n\\n    # 30 / 30 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 56 ms\\n    # 93.81%\\n\\n\\n**Java**\\n\\n    private long getID(long i, long w) {\\n        return i < 0 ? (i + 1) / w - 1 : i / w;\\n    }\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (t < 0) return false;\\n        Map<Long, Long> d = new HashMap<>();\\n        long w = (long)t + 1;\\n        for (int i = 0; i < nums.length; ++i) {\\n            long m = getID(nums[i], w);\\n            if (d.containsKey(m))\\n                return true;\\n            if (d.containsKey(m - 1) && Math.abs(nums[i] - d.get(m - 1)) < w)\\n                return true;\\n            if (d.containsKey(m + 1) && Math.abs(nums[i] - d.get(m + 1)) < w)\\n                return true;\\n            d.put(m, (long)nums[i]);\\n            if (i >= k) d.remove(getID(nums[i - k], w));\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "The idea is like the bucket sort algorithm. Suppose we have consecutive buckets covering the range of nums with each bucket a width of (t+1). If there are two item with difference <= t, one of the two will happen:\\n\\n    (1) the two in the same bucket\\n    (2) the two in neighbor buckets\\n\\nFor detailed explanation see my blog [here](http://algobox.org/contains-duplicate-iii/)\\n\\n**Python**\\n\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        if t < 0: return False\\n        n = len(nums)\\n        d = {}\\n        w = t + 1\\n        for i in xrange(n):\\n            m = nums[i] / w\\n            if m in d:\\n                return True\\n            if m - 1 in d and abs(nums[i] - d[m - 1]) < w:\\n                return True\\n            if m + 1 in d and abs(nums[i] - d[m + 1]) < w:\\n                return True\\n            d[m] = nums[i]\\n            if i >= k: del d[nums[i - k] / w]\\n        return False\\n\\n\\n    # 30 / 30 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 56 ms\\n    # 93.81%\\n\\n\\n**Java**\\n\\n    private long getID(long i, long w) {\\n        return i < 0 ? (i + 1) / w - 1 : i / w;\\n    }\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (t < 0) return false;\\n        Map<Long, Long> d = new HashMap<>();\\n        long w = (long)t + 1;\\n        for (int i = 0; i < nums.length; ++i) {\\n            long m = getID(nums[i], w);\\n            if (d.containsKey(m))\\n                return true;\\n            if (d.containsKey(m - 1) && Math.abs(nums[i] - d.get(m - 1)) < w)\\n                return true;\\n            if (d.containsKey(m + 1) && Math.abs(nums[i] - d.get(m + 1)) < w)\\n                return true;\\n            d.put(m, (long)nums[i]);\\n            if (i >= k) d.remove(getID(nums[i - k], w));\\n        }\\n        return false;\\n    }",
                "codeTag": "Python3"
            },
            {
                "id": 824578,
                "title": "c-o-n-time-complexity-explained-buckets-o-k-space-complexity",
                "content": "**Explanation**\\n\\nWe use the concept of sliding window and buckets together to achieve an optimal solution with O(N) time complexity.\\n\\nSliding window ensures only those indices are considered whose the absolute difference is at most k. We only consider k indices at a time. This fulfills the second condition.\\n\\nBuckets are used to ensure that the absolute difference between two numbers is at most t. Let\\'s take a deeper look at them.\\nWe (floor) divide each number by t+1 and put it in a bucket with key as the quotient.\\nFor example,\\n\\n```\\n[1,5,2,4,3,9,1,5,9], k = 2, t = 3\\n\\n1 // (3+1) = 0\\n5 // (3+1) = 1\\n2 // (3+1) = 0\\n4 // (3+1) = 1\\n3 // (3+1) = 0\\n9 // (3+1) = 2\\n\\nHere, Bucket[0] will contain numbers 0,1,2,3.\\nBucket[1] will contain numbers 4,5,6,7.\\nBucket[2] will contain numbers 8,9,10,11.\\n\\nOn observing carefully, we can see that the absolute difference\\nbetween any two numbers in any bucket is at most t, which is what we want.\\n\\nAlso, there can be a case where the neighbouring bucket has some number\\nwhose absolute difference with a number in the current bucket is at most t.\\nFor instance, 2 lies in Bucket[0] and 4 lies in Bucket[1] and 4 - 2 = 2 < 3 (=t).\\nThis can only happen in neighbouring buckets. Therefore, we need to check for this too.\\n```\\n\\n**Code**\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n = nums.size();\\n        \\n        if(n == 0 || k < 0  || t < 0) return false;\\n        \\n        unordered_map<int,int> buckets;\\n        \\n        for(int i=0; i<n; ++i) {\\n            int bucket = nums[i] / ((long)t + 1);\\n            \\n\\t\\t\\t// For negative numbers, we need to decrement bucket by 1\\n\\t\\t\\t// to ensure floor division.\\n\\t\\t\\t// For example, -1/2 = 0 but -1 should be put in Bucket[-1].\\n\\t\\t\\t// Therefore, decrement by 1.\\n            if(nums[i] < 0) --bucket;\\n            \\n            if(buckets.find(bucket) != buckets.end()) return true;\\n            else {\\n                buckets[bucket] = nums[i];\\n                if(buckets.find(bucket-1) != buckets.end() && (long) nums[i] - buckets[bucket-1] <= t) return true;\\n                if(buckets.find(bucket+1) != buckets.end() && (long) buckets[bucket+1] - nums[i] <= t) return true;\\n                \\n                if(buckets.size() > k) {\\n                    int key_to_remove = nums[i-k] / ((long)t + 1);\\n                    \\n                    if(nums[i-k] < 0) --key_to_remove;\\n                    \\n                    buckets.erase(key_to_remove);\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```\\n\\nIf you have any questions, feel free to ask. If you like the solution and explanation, please **Upvote** to help others!\\nHave a great day!\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n[1,5,2,4,3,9,1,5,9], k = 2, t = 3\\n\\n1 // (3+1) = 0\\n5 // (3+1) = 1\\n2 // (3+1) = 0\\n4 // (3+1) = 1\\n3 // (3+1) = 0\\n9 // (3+1) = 2\\n\\nHere, Bucket[0] will contain numbers 0,1,2,3.\\nBucket[1] will contain numbers 4,5,6,7.\\nBucket[2] will contain numbers 8,9,10,11.\\n\\nOn observing carefully, we can see that the absolute difference\\nbetween any two numbers in any bucket is at most t, which is what we want.\\n\\nAlso, there can be a case where the neighbouring bucket has some number\\nwhose absolute difference with a number in the current bucket is at most t.\\nFor instance, 2 lies in Bucket[0] and 4 lies in Bucket[1] and 4 - 2 = 2 < 3 (=t).\\nThis can only happen in neighbouring buckets. Therefore, we need to check for this too.\\n```\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n = nums.size();\\n        \\n        if(n == 0 || k < 0  || t < 0) return false;\\n        \\n        unordered_map<int,int> buckets;\\n        \\n        for(int i=0; i<n; ++i) {\\n            int bucket = nums[i] / ((long)t + 1);\\n            \\n\\t\\t\\t// For negative numbers, we need to decrement bucket by 1\\n\\t\\t\\t// to ensure floor division.\\n\\t\\t\\t// For example, -1/2 = 0 but -1 should be put in Bucket[-1].\\n\\t\\t\\t// Therefore, decrement by 1.\\n            if(nums[i] < 0) --bucket;\\n            \\n            if(buckets.find(bucket) != buckets.end()) return true;\\n            else {\\n                buckets[bucket] = nums[i];\\n                if(buckets.find(bucket-1) != buckets.end() && (long) nums[i] - buckets[bucket-1] <= t) return true;\\n                if(buckets.find(bucket+1) != buckets.end() && (long) buckets[bucket+1] - nums[i] <= t) return true;\\n                \\n                if(buckets.size() > k) {\\n                    int key_to_remove = nums[i-k] / ((long)t + 1);\\n                    \\n                    if(nums[i-k] < 0) --key_to_remove;\\n                    \\n                    buckets.erase(key_to_remove);\\n                }\\n            }\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61655,
                "title": "java-o-n-lg-k-solution",
                "content": "This problem requires to maintain a window of size k of the previous values that can be queried for value ranges. The best data structure to do that is Binary Search Tree. As a result maintaining the tree of size k will result in time complexity O(N lg K). In order to check if there exists any value of range abs(nums[i] - nums[j]) to simple queries can be executed both of time complexity O(lg K)\\n\\nHere is the whole solution using TreeMap.\\n\\n----------\\n\\n    public class Solution {\\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n            if (nums == null || nums.length == 0 || k <= 0) {\\n                return false;\\n            }\\n    \\n            final TreeSet<Integer> values = new TreeSet<>();\\n            for (int ind = 0; ind < nums.length; ind++) {\\n    \\n                final Integer floor = values.floor(nums[ind] + t);\\n                final Integer ceil = values.ceiling(nums[ind] - t);\\n                if ((floor != null && floor >= nums[ind])\\n                        || (ceil != null && ceil <= nums[ind])) {\\n                    return true;\\n                }\\n    \\n                values.add(nums[ind]);\\n                if (ind >= k) {\\n                    values.remove(nums[ind - k]);\\n                }\\n            }\\n    \\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n            if (nums == null || nums.length == 0 || k <= 0) {\\n                return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 61641,
                "title": "c-using-set-less-10-lines-with-simple-explanation",
                "content": "     bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        set<int> window; // set is ordered automatically \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i > k) window.erase(nums[i-k-1]); // keep the set contains nums i j at most k\\n            // |x - nums[i]| <= t  ==> -t <= x - nums[i] <= t;\\n            auto pos = window.lower_bound(nums[i] - t); // x-nums[i] >= -t ==> x >= nums[i]-t \\n            // x - nums[i] <= t ==> |x - nums[i]| <= t    \\n            if (pos != window.end() && *pos - nums[i] <= t) return true;\\n            window.insert(nums[i]);\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "     bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        set<int> window; // set is ordered automatically \\n        for (int i = 0; i < nums.size(); i++) {\\n            if (i > k) window.erase(nums[i-k-1]); // keep the set contains nums i j at most k\\n            // |x - nums[i]| <= t  ==> -t <= x - nums[i] <= t;\\n            auto pos = window.lower_bound(nums[i] - t); // x-nums[i] >= -t ==> x >= nums[i]-t \\n            // x - nums[i] <= t ==> |x - nums[i]| <= t    \\n            if (pos != window.end() && *pos - nums[i] <= t) return true;\\n            window.insert(nums[i]);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 824603,
                "title": "python-sortedlist-o-n-log-k-solution-explained",
                "content": "In my opinion it is more like **hard** problem, because brute-force solution will get you TLE and all other solutions uses some not easy trick: either heaps or BST or bucket sort. If you know some other solution without these ideas, please let me know!\\n\\nIn this problem we need to iterate over window of size `k+1` and check if there is numbers with difference `<=t` in this window. What we need to do efficiently is to add and remove elements from our window, and my choice of data structure is BST, which is implemented in `SortedList` in python. So on each step we have sorted list of elements in this window. Imagine the case:\\n\\n`[1, 3, 7, 12]` and new number we need to insert is `10`, and `t = 2`. Then we need to consider range `[8,12]` and check if we have numbers in our `SList` in this range. We can do two binary searches here: `bisect_left` for left boundary and `bisect_right` for right boundary. Also we need to check if `pos1 != len(SList)`, if this is the case, it means that new number is bigger than bigges number in list + `t`, so in this case we just put it directly to our list. If `pos1 != pos2`, this means, that we found some number i our `[nums[i] - t, nums[i] + t]` range, so we immediatly return `True`.\\n\\n**Complexity**: time complexity is `O(n log k)`, because we do `n` steps, each one with `O(log k)` complexity to do binary search, remove and add elements. Space complexity is `O(k)` to keep our `SortedList` updated.\\n\\n```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        SList = SortedList()\\n        for i in range(len(nums)):\\n            if i > k: SList.remove(nums[i-k-1])   \\n            pos1 = SortedList.bisect_left(SList, nums[i] - t)\\n            pos2 = SortedList.bisect_right(SList, nums[i] + t)\\n            \\n            if pos1 != pos2 and pos1 != len(SList): return True\\n            \\n            SList.add(nums[i])\\n        \\n        return False\\n```\\n\\n**PS** because of time complexity `O(n log k)`, this solution will not be on top, there is `O(n)` bucket sort solution, but in my opinion it is for certain hard level.\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        SList = SortedList()\\n        for i in range(len(nums)):\\n            if i > k: SList.remove(nums[i-k-1])   \\n            pos1 = SortedList.bisect_left(SList, nums[i] - t)\\n            pos2 = SortedList.bisect_right(SList, nums[i] + t)\\n            \\n            if pos1 != pos2 and pos1 != len(SList): return True\\n            \\n            SList.add(nums[i])\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 174416,
                "title": "python-balanced-bst-solution",
                "content": "This solution is slow compared to other Python solutions because it uses balanced BST, and time complexity is O(n log k), while solutions using buckets are O(n). I am posting this because I don\\'t see anyone posting the BST solution.\\n\\n```\\nclass Node(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n        self.height = 1\\n\\n\\nclass AVLTree(object):\\n    def __init__(self):\\n        self.root = None\\n        self.size = 0\\n        \\n\\t\\t\\t\\t\\n    def height(self, node):\\n        if node:\\n            return node.height\\n        return 0\\n    \\n\\t\\t\\n    def setHeight(self, node):\\n        if node is None:\\n            return 0\\n        return 1 + max(self.height(node.left), self.height(node.right))\\n    \\n\\t\\t\\n    def rightRotate(self, node):\\n        new_root = node.left\\n        node.left = node.left.right\\n        new_root.right = node\\n        node.height = self.setHeight(node)\\n        new_root.height = self.setHeight(new_root)\\n        return new_root\\n    \\n    \\n    def leftRotate(self, node):\\n        new_root = node.right\\n        node.right = node.right.left\\n        new_root.left = node\\n        node.height = self.setHeight(node)\\n        new_root.height = self.setHeight(new_root)\\n        return new_root\\n        \\n    \\n    def insert(self, node, val):\\n        if node == self.root:\\n            self.size += 1\\n        # Returns a Node pointing to updated subtree\\n        if node is None:\\n            return Node(val)\\n        if node.val < val:\\n            node.right = self.insert(node.right, val)\\n        else:\\n            node.left = self.insert(node.left, val)\\n        balance = self.height(node.left) - self.height(node.right)\\n        if balance > 1:\\n            if self.height(node.left.left) > self.height(node.left.right):\\n                node = self.rightRotate(node)\\n            else:\\n                node.left = self.leftRotate(node.left)\\n                node = self.rightRotate(node)\\n        elif balance < -1:\\n            if self.height(node.right.right) > self.height(node.right.left):\\n                node = self.leftRotate(node)\\n            else:\\n                node.right = self.rightRotate(node.right)\\n                node = self.leftRotate(node)\\n        else:\\n            node.height = self.setHeight(node)\\n        return node\\n    \\n    \\n    def getMinValNode(self, node):\\n        if node is None or node.left is None:\\n            return node\\n        return self.getMinValNode(node.left)\\n    \\n\\t\\t\\n    def remove(self, node, val):\\n        if node is None:\\n            return None\\n        if node.val < val:\\n            node.right = self.remove(node.right, val)\\n        elif node.val > val:\\n            node.left = self.remove(node.left, val)\\n        else:\\n            if node.left is None:\\n                return node.right\\n            elif node.right is None:\\n                return node.left\\n            else:\\n                right_min_val_node = self.getMinValNode(node.right)\\n                node.val = right_min_val_node.val\\n                node.right = self.remove(node.right, right_min_val_node.val)\\n        \\n        node.height = self.setHeight(node)\\n        balance = self.height(node.left) - self.height(node.right)\\n        if balance > 1:\\n            if self.height(node.left.left) > self.height(node.left.right):\\n                node = self.rightRotate(node)\\n            else:\\n                node.left = self.leftRotate(node.left)\\n                node = self.rightRotate(node)\\n        elif balance < -1:\\n            if self.height(node.right.right) > self.height(node.right.left):\\n                node = self.leftRotate(node)\\n            else:\\n                node.right = self.rightRotate(node.right)\\n                node = self.leftRotate(node)\\n        else:\\n            node.height = self.setHeight(node)\\n        return node\\n    \\n    \\n    def predecessor(self, node, val):\\n        if node is None:\\n            return None\\n        if node.val == val:\\n            return val\\n        elif node.val > val:\\n            return self.predecessor(node.left, val)\\n        else:\\n            right_res = self.predecessor(node.right, val)\\n            return right_res if right_res else node.val    \\n            \\n\\t\\t\\t\\t\\t\\t\\n    def successor(self, node, val):\\n        if node is None:\\n            return None\\n        if node.val == val:\\n            return val\\n        elif node.val < val:\\n            return self.successor(node.right, val)\\n        else:\\n            left_res = self.successor(node.left, val)\\n            return left_res if left_res else node.val\\n    \\n\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        avltree = AVLTree()\\n        root = avltree.root\\n        for i, num in enumerate(nums):            \\n            predecessor = avltree.predecessor(root, num)\\n            if predecessor is not None and abs(predecessor - num) <= t:\\n                return True\\n            successor = avltree.successor(root, num)\\n            if successor is not None and abs(successor - num) <= t:\\n                return True\\n                        \\n            root = avltree.insert(root, num)\\n            \\n            if avltree.size > k:\\n                root = avltree.remove(root, nums[i-k])\\n                \\n        return False\\n ```",
                "solutionTags": [],
                "code": "```\\nclass Node(object):\\n    def __init__(self, val):\\n        self.val = val\\n        self.left = None\\n        self.right = None\\n        self.height = 1\\n\\n\\nclass AVLTree(object):\\n    def __init__(self):\\n        self.root = None\\n        self.size = 0\\n        \\n\\t\\t\\t\\t\\n    def height(self, node):\\n        if node:\\n            return node.height\\n        return 0\\n    \\n\\t\\t\\n    def setHeight(self, node):\\n        if node is None:\\n            return 0\\n        return 1 + max(self.height(node.left), self.height(node.right))\\n    \\n\\t\\t\\n    def rightRotate(self, node):\\n        new_root = node.left\\n        node.left = node.left.right\\n        new_root.right = node\\n        node.height = self.setHeight(node)\\n        new_root.height = self.setHeight(new_root)\\n        return new_root\\n    \\n    \\n    def leftRotate(self, node):\\n        new_root = node.right\\n        node.right = node.right.left\\n        new_root.left = node\\n        node.height = self.setHeight(node)\\n        new_root.height = self.setHeight(new_root)\\n        return new_root\\n        \\n    \\n    def insert(self, node, val):\\n        if node == self.root:\\n            self.size += 1\\n        # Returns a Node pointing to updated subtree\\n        if node is None:\\n            return Node(val)\\n        if node.val < val:\\n            node.right = self.insert(node.right, val)\\n        else:\\n            node.left = self.insert(node.left, val)\\n        balance = self.height(node.left) - self.height(node.right)\\n        if balance > 1:\\n            if self.height(node.left.left) > self.height(node.left.right):\\n                node = self.rightRotate(node)\\n            else:\\n                node.left = self.leftRotate(node.left)\\n                node = self.rightRotate(node)\\n        elif balance < -1:\\n            if self.height(node.right.right) > self.height(node.right.left):\\n                node = self.leftRotate(node)\\n            else:\\n                node.right = self.rightRotate(node.right)\\n                node = self.leftRotate(node)\\n        else:\\n            node.height = self.setHeight(node)\\n        return node\\n    \\n    \\n    def getMinValNode(self, node):\\n        if node is None or node.left is None:\\n            return node\\n        return self.getMinValNode(node.left)\\n    \\n\\t\\t\\n    def remove(self, node, val):\\n        if node is None:\\n            return None\\n        if node.val < val:\\n            node.right = self.remove(node.right, val)\\n        elif node.val > val:\\n            node.left = self.remove(node.left, val)\\n        else:\\n            if node.left is None:\\n                return node.right\\n            elif node.right is None:\\n                return node.left\\n            else:\\n                right_min_val_node = self.getMinValNode(node.right)\\n                node.val = right_min_val_node.val\\n                node.right = self.remove(node.right, right_min_val_node.val)\\n        \\n        node.height = self.setHeight(node)\\n        balance = self.height(node.left) - self.height(node.right)\\n        if balance > 1:\\n            if self.height(node.left.left) > self.height(node.left.right):\\n                node = self.rightRotate(node)\\n            else:\\n                node.left = self.leftRotate(node.left)\\n                node = self.rightRotate(node)\\n        elif balance < -1:\\n            if self.height(node.right.right) > self.height(node.right.left):\\n                node = self.leftRotate(node)\\n            else:\\n                node.right = self.rightRotate(node.right)\\n                node = self.leftRotate(node)\\n        else:\\n            node.height = self.setHeight(node)\\n        return node\\n    \\n    \\n    def predecessor(self, node, val):\\n        if node is None:\\n            return None\\n        if node.val == val:\\n            return val\\n        elif node.val > val:\\n            return self.predecessor(node.left, val)\\n        else:\\n            right_res = self.predecessor(node.right, val)\\n            return right_res if right_res else node.val    \\n            \\n\\t\\t\\t\\t\\t\\t\\n    def successor(self, node, val):\\n        if node is None:\\n            return None\\n        if node.val == val:\\n            return val\\n        elif node.val < val:\\n            return self.successor(node.right, val)\\n        else:\\n            left_res = self.successor(node.left, val)\\n            return left_res if left_res else node.val\\n    \\n\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        avltree = AVLTree()\\n        root = avltree.root\\n        for i, num in enumerate(nums):            \\n            predecessor = avltree.predecessor(root, num)\\n            if predecessor is not None and abs(predecessor - num) <= t:\\n                return True\\n            successor = avltree.successor(root, num)\\n            if successor is not None and abs(successor - num) <= t:\\n                return True\\n                        \\n            root = avltree.insert(root, num)\\n            \\n            if avltree.size > k:\\n                root = avltree.remove(root, nums[i-k])\\n                \\n        return False\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 61731,
                "title": "o-n-python-using-buckets-with-explanation-10-lines",
                "content": "    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        # Bucket sort. Each bucket has size of t. For each number, the possible\\n        # candidate can only be in the same bucket or the two buckets besides.\\n        # Keep as many as k buckets to ensure that the difference is at most k.\\n        buckets = {}\\n        for i, v in enumerate(nums):\\n            # t == 0 is a special case where we only have to check the bucket\\n            # that v is in.\\n            bucketNum, offset = (v / t, 1) if t else (v, 0)\\n            for idx in xrange(bucketNum - offset, bucketNum + offset + 1):\\n                if idx in buckets and abs(buckets[idx] - nums[i]) <= t:\\n                    return True\\n\\n            buckets[bucketNum] = nums[i]\\n            if len(buckets) > k:\\n                # Remove the bucket which is too far away. Beware of zero t.\\n                del buckets[nums[i - k] / t if t else nums[i - k]]\\n\\n        return False",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        # Bucket sort. Each bucket has size of t. For each number, the possible\\n        # candidate can only be in the same bucket or the two buckets besides.\\n        # Keep as many as k buckets to ensure that the difference is at most k.\\n        buckets = {}\\n        for i, v in enumerate(nums):\\n            # t == 0 is a special case where we only have to check the bucket\\n            # that v is in.\\n            bucketNum, offset = (v / t, 1) if t else (v, 0)\\n            for idx in xrange(bucketNum - offset, bucketNum + offset + 1):\\n                if idx in buckets and abs(buckets[idx] - nums[i]) <= t:\\n                    return True\\n\\n            buckets[bucketNum] = nums[i]\\n            if len(buckets) > k:\\n                # Remove the bucket which is too far away. Beware of zero t.\\n                del buckets[nums[i - k] / t if t else nums[i - k]]\\n\\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 61756,
                "title": "python-ordereddict",
                "content": "    class Solution:\\n\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        if k < 1 or t < 0:\\n            return False\\n        dic = collections.OrderedDict()\\n        for n in nums:\\n            key = n if not t else n // t\\n            for m in (dic.get(key - 1), dic.get(key), dic.get(key + 1)):\\n                if m is not None and abs(n - m) <= t:\\n                    return True\\n            if len(dic) == k:\\n                dic.popitem(False)\\n            dic[key] = n\\n        return False",
                "solutionTags": [],
                "code": "    class Solution:\\n\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        if k < 1 or t < 0:\\n            return False\\n        dic = collections.OrderedDict()\\n        for n in nums:\\n            key = n if not t else n // t\\n            for m in (dic.get(key - 1), dic.get(key), dic.get(key + 1)):\\n                if m is not None and abs(n - m) <= t:\\n                    return True\\n            if len(dic) == k:\\n                dic.popitem(False)\\n            dic[key] = n\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 61676,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Contains Duplicate III** https://leetcode.com/problems/contains-duplicate-iii/\\n\\n**Brute Force Solution**\\n* Brute force solution is use two loops and test both the conditions. The inner loop starts from i+1 to i+k. Because of that, we no longer need to test one of the conditions since that is taken care of automatically.\\n* Time complexity : O(n * k). \\n\\n```\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(0, len(nums)):\\n            for j in range(i+1, i+k+1):\\n                if j < len(nums):\\n                    if abs(nums[i]-nums[j]) <= t:\\n                        return True\\n        return False\\n```\\n\\n**Binary Search Tree Solution**\\n* Maintain a BST of previous k elements. This is the invariant for this problem!\\n* When you get element x, we want to find an element y in the BST such that (y-x)<=t or (x-y)<=t\\n* How do we find (y-x)<=t ? Solution: Find the smallest value in the BST greater than or equal to x i.e. ceiling of x. Then test that value for the above condition.If the smallest value greater than x doesnt meet the criterion, then no other value y greater than x will meet the condition. One may consider the smallest element y that is greater or equal to x as the successor of x in the BST, as in: \"What is the next greater value of x?\"\\n* How do we find (x-y)<=t? Find the greatest element y in the BST which is smaller than or equal to x. Again if this y doesnt meet the condition, no other y in the BST will meet the condition. We consider the greatest element y that is smaller or equal to x as the predecessor of x in the BST, as in: \"What is the previous smaller value of x?\\n* Visualize or imagine this as x and its two closest neighbors.\\n* After trying the above tests, if they fail, then put x in set\\n* If the size of the set is larger than k, remove the oldest item - this maintains the invariant.\\n* Time complexity : O(n * log (min(n,k))). Space complexity: O(min(n,k))\\n\\n**Buckets Method**\\n* Maintain buckets each of size t+1 holding the last k elements. This is the invariant.\\n* Buckets are [0, t], [t+1,2t+1], [2t+2, 3t+2],....\\n* What are the conditions of a match? Either x lies in a bucket which already has a member (this directly means that x and this element are within t of each other). Or the two neighbors of around this bucket may have a potential match. Check the code for an explanation.\\n* Lastly we notice how we purge elements from the cache/buckets which are stale i.e. outside the window of k elements.\\n* Notice one more thing: -3//5 = -1 - Python does this automatically and hence we dont need any special magic for handling negative numbers.\\n\\n```\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        if t < 0:\\n            return False\\n        cache = {}\\n        for i in range(len(nums)):\\n            if i-k > 0:\\n                bucket_id_to_delete = nums[i-k-1]//(t+1)\\n                del cache[bucket_id_to_delete]\\n            bucket_id = nums[i]//(t+1)\\n            condition1 = (bucket_id in cache)\\n            condition2 = ((bucket_id-1 in cache and abs(cache[bucket_id-1]-nums[i])<= t))\\n            condition3 = ((bucket_id+1 in cache and abs(cache[bucket_id+1]-nums[i])<= t))\\n            if condition1 or condition2 or condition3:\\n                return True\\n            cache[bucket_id] = nums[i]\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        for i in range(0, len(nums)):\\n            for j in range(i+1, i+k+1):\\n                if j < len(nums):\\n                    if abs(nums[i]-nums[j]) <= t:\\n                        return True\\n        return False\\n```\n```\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        if t < 0:\\n            return False\\n        cache = {}\\n        for i in range(len(nums)):\\n            if i-k > 0:\\n                bucket_id_to_delete = nums[i-k-1]//(t+1)\\n                del cache[bucket_id_to_delete]\\n            bucket_id = nums[i]//(t+1)\\n            condition1 = (bucket_id in cache)\\n            condition2 = ((bucket_id-1 in cache and abs(cache[bucket_id-1]-nums[i])<= t))\\n            condition3 = ((bucket_id+1 in cache and abs(cache[bucket_id+1]-nums[i])<= t))\\n            if condition1 or condition2 or condition3:\\n                return True\\n            cache[bucket_id] = nums[i]\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825267,
                "title": "python3-summarizing-contain-duplicates-i-ii-iii",
                "content": "This is a very self-consistent series. Although ad-hoc implementations exist (please check the corresponding posts in Dicuss), their solutions bear great resemblance to each other. \\n\\nStarting with [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/), the key is to memoize what has been seen in a set\\n```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = set()\\n        for x in nums:\\n            if x in seen: return True \\n            seen.add(x)\\n        return False\\n```\\n\\nProgressing to [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/), extra info needs to be memoized, i.e. position via a dictionary. \\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        seen = {}\\n        for i, x in enumerate(nums): \\n            if x in seen and i - seen[x] <= k: return True \\n            seen[x] = i\\n        return False \\n```\\n\\nComing back to this problem, we can summarize numbers in a given range into bucket. By bucketing numbers properly, this becomes almost identical to 219. Contains Duplicate except that numbers in adjacent buckets need to be check as well. \\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if t < 0: return False # edge case \\n        \\n        seen = {}\\n        for i, x in enumerate(nums): \\n            bkt = x//(t+1)\\n            if bkt in seen and i - seen[bkt][0] <= k: return True \\n            if bkt-1 in seen and i - seen[bkt-1][0] <= k and abs(x - seen[bkt-1][1]) <= t: return True \\n            if bkt+1 in seen and i - seen[bkt+1][0] <= k and abs(x - seen[bkt+1][1]) <= t: return True \\n            seen[bkt] = (i, x) \\n        return False \\n```\\n\\nAs mentioned in the beginning, ad-hoc implementations do exist. But these three questions can all be solved by properly memoizing certain info, which makes them quite consistent for practice.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsDuplicate(self, nums: List[int]) -> bool:\\n        seen = set()\\n        for x in nums:\\n            if x in seen: return True \\n            seen.add(x)\\n        return False\\n```\n```\\nclass Solution:\\n    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:\\n        seen = {}\\n        for i, x in enumerate(nums): \\n            if x in seen and i - seen[x] <= k: return True \\n            seen[x] = i\\n        return False \\n```\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if t < 0: return False # edge case \\n        \\n        seen = {}\\n        for i, x in enumerate(nums): \\n            bkt = x//(t+1)\\n            if bkt in seen and i - seen[bkt][0] <= k: return True \\n            if bkt-1 in seen and i - seen[bkt-1][0] <= k and abs(x - seen[bkt-1][1]) <= t: return True \\n            if bkt+1 in seen and i - seen[bkt+1][0] <= k and abs(x - seen[bkt+1][1]) <= t: return True \\n            seen[bkt] = (i, x) \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 61764,
                "title": "i-finally-got-ac-in-c",
                "content": "Using a set container to keep the k+1-length array,which all elements are distinct.Before the container's size reached k+1, we just find the first element that is not less than [nums[i]-t] and judge the element's value whether it is less than [nums[i]+t]. Starting to move forward by erasing the head and adding element at the backend after the container's size reached k+1. The existence of the first element ,which is not less than [nums[i]-t]  and less than [nums[i]+t], is the prerequisite of existing other eligible elements.\\n\\n     bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t)\\n        {\\n        \\t\\tif (!k || t<0 || nums.size()<2)\\n            \\t\\treturn false;\\n            \\tset<int>record;                   \\n            \\tauto nLen = nums.size();\\n            \\tfor (int i = 0; i < nLen;++i)\\n            \\t{\\n            \\t\\tif (i>k)\\n            \\t\\t\\trecord.erase(nums[i - k - 1]);         \\n            \\t\\tset<int>::iterator lower = record.lower_bound(nums[i] - t);\\n            \\t\\tif (lower != record.end() && abs(nums[i] - *lower) <= t)\\n            \\t\\t\\treturn true;\\n            \\n            \\t\\trecord.insert(nums[i]);\\n            \\t}\\n            \\treturn false;\\n        }",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "Using a set container to keep the k+1-length array,which all elements are distinct.Before the container's size reached k+1, we just find the first element that is not less than [nums[i]-t] and judge the element's value whether it is less than [nums[i]+t]. Starting to move forward by erasing the head and adding element at the backend after the container's size reached k+1. The existence of the first element ,which is not less than [nums[i]-t]  and less than [nums[i]+t], is the prerequisite of existing other eligible elements.\\n\\n     bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t)\\n        {\\n        \\t\\tif (!k || t<0 || nums.size()<2)\\n            \\t\\treturn false;\\n            \\tset<int>record;                   \\n            \\tauto nLen = nums.size();\\n            \\tfor (int i = 0; i < nLen;++i)\\n            \\t{\\n            \\t\\tif (i>k)\\n            \\t\\t\\trecord.erase(nums[i - k - 1]);         \\n            \\t\\tset<int>::iterator lower = record.lower_bound(nums[i] - t);\\n            \\t\\tif (lower != record.end() && abs(nums[i] - *lower) <= t)\\n            \\t\\t\\treturn true;\\n            \\n            \\t\\trecord.insert(nums[i]);\\n            \\t}\\n            \\treturn false;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 61774,
                "title": "accept-c-solution",
                "content": "My idea is to preserve a sliding window containing nearest k numbers, and check if next number collides to the numbers in the window.\\n\\n    class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            if (nums.size() < 2 || k == 0)\\n                return false;\\n            deque<int> windows_deq;\\n            multiset<long> windows;\\n            for (int i = 0; i < nums.size(); i++) {\\n                if (windows.size() > k) {\\n                    int num = windows_deq.front();\\n                    windows_deq.pop_front();\\n                    windows.erase(windows.find(num));\\n                }\\n                auto it = windows.lower_bound((long)nums[i] - (long)t);\\n                if (it == windows.end() || *it > (long)nums[i] + (long)t) {\\n                    // not found\\n                    windows_deq.push_back(nums[i]);\\n                    windows.insert(nums[i]);\\n                }\\n                else return true;\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            if (nums.size() < 2 || k == 0)\\n                return false;\\n            deque<int> windows_deq;\\n            multiset<long> windows;\\n            for (int i = 0; i < nums.size(); i++) {\\n                if (windows.size() > k) {\\n                    int num = windows_deq.front();\\n                    windows_deq.pop_front();\\n                    windows.erase(windows.find(num));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1500895,
                "title": "java-tc-o-n-sc-o-min-n-k-sliding-window-using-buckets",
                "content": "```java\\n/**\\n * Sliding Window solution using Buckets\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(min(N, K+1))\\n *\\n * N = Length of input array. K = Input difference between indexes.\\n */\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length < 2 || k < 1 || t < 0) {\\n            return false;\\n        }\\n\\n        HashMap<Long, Long> buckets = new HashMap<>();\\n        // The bucket size is t+1 as the ranges are from 0..t, t+1..2t+1, ..\\n        long bucketSize = (long) t + 1;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            // Making sure only K buckets exists in map.\\n            if (i > k) {\\n                long lastBucket = ((long) nums[i - k - 1] - Integer.MIN_VALUE) / bucketSize;\\n                buckets.remove(lastBucket);\\n            }\\n\\n            long remappedNum = (long) nums[i] - Integer.MIN_VALUE;\\n            long bucket = remappedNum / bucketSize;\\n\\n            // If 2 numbers belong to same bucket\\n            if (buckets.containsKey(bucket)) {\\n                return true;\\n            }\\n\\n            // If numbers are in adjacent buckets and the difference between them is at most\\n            // t.\\n            if (buckets.containsKey(bucket - 1) && remappedNum - buckets.get(bucket - 1) <= t) {\\n                return true;\\n            }\\n            if (buckets.containsKey(bucket + 1) && buckets.get(bucket + 1) - remappedNum <= t) {\\n                return true;\\n            }\\n\\n            buckets.put(bucket, remappedNum);\\n        }\\n\\n        return false;\\n    }\\n}\\n```\\n\\n---\\n\\nSolutions to other parts of Contains Duplicate question on LeetCode:\\n- [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/discuss/1500880/Java-or-TC:-O(N)-or-SC:-O(N)-or-Clean-and-concise-solution-using-HashSet)\\n- [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/discuss/1500887/Java-or-TC:-O(N)-or-SC:-O(min(N-K))-or-Sliding-Window-using-HashSet)\\n\\n---\\n\\nSolutions to other Sliding Window questions on LeetCode:\\n- [76. Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/discuss/1496754/Java-or-TC:-O(S+T)-or-SC:-O(T)-or-Space-optimized-Sliding-Window-using-Two-Pointers)\\n- [340. Longest Substring with At Most K Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-k-distinct-characters/discuss/1496838/Java-or-TC:-O(N)-or-SC:-O(K)-or-One-Pass-Sliding-Window-using-LinkedHashMap)\\n- [159. Longest Substring with At Most Two Distinct Characters](https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/discuss/1496840/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Sliding-Window-using-LinkedHashMap)\\n- [438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/1500039/Java-or-TC:-O(S+P)-or-SC:-O(1)-or-Sliding-window-solution)\\n- [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1500874/Java-or-TC:-O(N)-or-SC:-O(1)-or-Sliding-Window-using-HashMap-and-Two-Pointers)\\n- [209. Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/discuss/1500877/Java-or-Both-O(N)-and-O(N-logN)-solutions-with-O(1)-space-or-Sliding-Window-and-Binary-Search-solutions)\\n- [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/discuss/1500887/Java-or-TC:-O(N)-or-SC:-O(min(N-K))-or-Sliding-Window-using-HashSet)\\n- [567. Permutation in String](https://leetcode.com/problems/permutation-in-string/discuss/1500902/Java-or-TC:-O(S2)-or-SC:-O(1)-or-Constant-space-Sliding-Window-solution)\\n- [239. Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/discuss/1506048/Java-or-TC:-O(N)-or-SC:-O(K)-or-Using-Deque-as-Sliding-Window)\\n- [480. Sliding Window Median](https://leetcode.com/problems/sliding-window-median/discuss/1507981/Java-or-TC:-O(N*logK)-or-SC:-(K)-or-Optimized-sliding-window-using-TreeSet)\\n- [487. Max Consecutive Ones II](https://leetcode.com/problems/max-consecutive-ones-ii/discuss/1508045/Java-or-TC:-O(N)-or-SC:-O(1)-or-Four-solutions-with-Follow-up-handled)\\n- [1004. Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/discuss/1508044/Java-or-TC:-O(N)-or-SC:-O(1)-or-One-Pass-Optimized-Sliding-Window)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```java\\n/**\\n * Sliding Window solution using Buckets\\n *\\n * Time Complexity: O(N)\\n *\\n * Space Complexity: O(min(N, K+1))\\n *\\n * N = Length of input array. K = Input difference between indexes.\\n */\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length < 2 || k < 1 || t < 0) {\\n            return false;\\n        }\\n\\n        HashMap<Long, Long> buckets = new HashMap<>();\\n        // The bucket size is t+1 as the ranges are from 0..t, t+1..2t+1, ..\\n        long bucketSize = (long) t + 1;\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            // Making sure only K buckets exists in map.\\n            if (i > k) {\\n                long lastBucket = ((long) nums[i - k - 1] - Integer.MIN_VALUE) / bucketSize;\\n                buckets.remove(lastBucket);\\n            }\\n\\n            long remappedNum = (long) nums[i] - Integer.MIN_VALUE;\\n            long bucket = remappedNum / bucketSize;\\n\\n            // If 2 numbers belong to same bucket\\n            if (buckets.containsKey(bucket)) {\\n                return true;\\n            }\\n\\n            // If numbers are in adjacent buckets and the difference between them is at most\\n            // t.\\n            if (buckets.containsKey(bucket - 1) && remappedNum - buckets.get(bucket - 1) <= t) {\\n                return true;\\n            }\\n            if (buckets.containsKey(bucket + 1) && buckets.get(bucket + 1) - remappedNum <= t) {\\n                return true;\\n            }\\n\\n            buckets.put(bucket, remappedNum);\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61734,
                "title": "ac-java-solution-without-set-or-dictionary-sort-the-nums-and-record-the-positions",
                "content": "public class Solution {\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    \\tif(nums.length<2||k<1||t<0) return false;\\n    \\tValuePosPair[] valPosArr = new ValuePosPair[nums.length];\\n    \\tfor(int i =0;i<nums.length;i++) valPosArr[i] = new ValuePosPair(nums[i],i); \\n    \\tArrays.sort(valPosArr);\\t\\n    \\tfor(int i=0;i<valPosArr.length;i++){\\n    \\t\\tfor(int j=i+1;j<valPosArr.length&&((long)valPosArr[j].val-(long)valPosArr[i].val<=(long)t);j++){\\n    \\t\\t\\tif(Math.abs(valPosArr[j].pos-valPosArr[i].pos)<=k) return true;\\t\\n    \\t\\t}\\n    \\t}\\n    \\treturn false;\\n    }  \\n}\\n\\n    class ValuePosPair implements Comparable<ValuePosPair>{\\n    \\n    \\tint val;\\n    \\tint pos;\\n\\n    \\tValuePosPair(int v, int p) { val = v; pos = p;}\\n\\n    \\tpublic int compareTo(ValuePosPair x){\\n    \\t\\treturn this.val - x.val;\\n    \\t}\\t\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    \\tif(nums.length<2||k<1||t<0) return false;\\n    \\tValuePosPair[] valPosArr = new ValuePosPair[nums.length];\\n    \\tfor(int i =0;i<nums.length;i++) valPosArr[i] = new ValuePosPair(nums[i],i); \\n    \\tArrays.sort(valPosArr);\\t\\n    \\tfor(int i=0;i<valPosArr.length;i++){\\n    \\t\\tfor(int j=i+1;j<valPosArr.length&&((long)valPosArr[j].val-(long)valPosArr[i].val<=(long)t);j++){\\n    \\t\\t\\tif(Math.abs(valPosArr[j].pos-valPosArr[i].pos)<=k) return true;\\t\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 61662,
                "title": "java-treeset-implementation-nlogk",
                "content": "this is a very good demonstration of the use of TreeSet ---- which we rarely use normally. \\n\\n\\n\\n        public class Solution {\\n    \\n        public boolean containsNearbyAlmostDuplicate(final int[] nums, int kk, long t) {\\n            if (nums.length < 2) return false;\\n            if (kk == 0) return false;\\n            TreeSet<Long> window = new TreeSet<Long>();\\n            \\n            for(int i=0;i<nums.length;i++) {\\n    \\n                // check dup, window size <= kk right now\\n            \\tif ( window.floor(nums[i] + t) !=null && window.floor(nums[i]+t) >= nums[i]-t ) return true;\\n            \\t\\n                window.add(new Long(nums[i]));\\n                \\n                \\n                if (i >= kk) {\\n                    //remove one, the size has to be kk on the next fresh step\\n                \\twindow.remove(new Long(nums[i-kk]));\\n                }\\n            }\\n            \\n            return false;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n        public boolean containsNearbyAlmostDuplicate(final int[] nums, int kk, long t) {\\n            if (nums.length < 2) return false;\\n            if (kk == 0) return false;\\n            TreeSet<Long> window = new TreeSet<Long>();\\n            \\n            for(int i=0;i<nums.length;i++) {\\n    \\n                // check dup, window size <= kk right now\\n            \\tif ( window.floor(nums[i] + t) !=null && window.floor(nums[i]+t) >= nums[i]-t ) return true;\\n            \\t\\n                window.add(new Long(nums[i]));\\n                \\n                \\n                if (i >= kk) {\\n                    //remove one, the size has to be kk on the next fresh step\\n                \\twindow.remove(new Long(nums[i-kk]));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 61666,
                "title": "short-c-solution",
                "content": "    class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            map<long long,int> M;\\n            int l=0;\\n            for (int r=0;r<nums.size();r++) {\\n                if (r-l>k && M[nums[l]]==l)\\n                    M.erase(nums[l++]);\\n                auto it=M.lower_bound(nums[r]-t);\\n                if (it!=M.end() && abs(it->first-nums[r])<=t)\\n                    return true;\\n                M[nums[r]]=r;\\n            }\\n            return false;\\n         }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            map<long long,int> M;\\n            int l=0;\\n            for (int r=0;r<nums.size();r++) {\\n                if (r-l>k && M[nums[l]]==l)\\n                    M.erase(nums[l++]);\\n                auto it=M.lower_bound(nums[r]-t);\\n                if (it!=M.end() && abs(it->first-nums[r])<=t)\\n                    return true;\\n                M[nums[r]]=r;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 825726,
                "title": "contains-duplicate-iii-best-theoretical-time-complexity-java",
                "content": "Note a few ideas that will help you understand this problem and make the optimal time complexity approach easier for you:\\n\\n* Consider the edge cases. What are the edge cases? What happens when the array is empty, singleton etc. And what about when ```k``` is 0? Consider edge cases that you know are unlikely to be included in a general solution, and take care of those cases right away.\\n* Then, you understand that for any element ```x```  in ```nums```, you\\'re actually looking for its partner. This partner element is at most ```k``` hops away from ```x```, and doesn\\'t differ from ```x``` by more than ```t```.\\n* So, if you happen to have ```k``` elements in your hand, and look at a ```(k + 1)th``` element, you ask \"does this ```(k + 1)th``` guy find a partner in the ```k``` I\\'m already holding on to?\" \\nIf not, well guess what? The oldest element in the ```k``` ones you have can no more find its partner so you can get rid of it and let ```(k + 1)th``` guy get in.\\n* For an example, let\\'s consider the first one given i.e. ```nums = [1,2,3,1] | k = 3 | t = 0```. \\n* Now, you\\'re holding on to the first ```k``` elements i.e. ```[1,2,3]```. Your supposed loop considers the next element i.e. ```[..., 1]```. Now if this ```1``` has a partner in ```[1,2,3]```, great, we\\'re done. But if not, then there\\'s no problem in throwing the first ```[1...]```, because well, all the elements you see now are going to be more than ```k``` hops away from him. So you end up with ```[2,3,1]```.\\n* That was the basic processing idea. \\n* Finally, you understand that upon processing each element ```x```, if the largest number smaller than ```x``` or the smallest number greater than ```x```, in the ```k``` elements you already have, produce something bounded by ```t```, you have an answer.\\n* Now it\\'s your turn to research what data structure can hold onto elements such that it can yeild a ceiling/floor relative to some number efficiently (clearly it will have to keep its elements in a sorted manner...) \\n* (P.S. think a bit about why ceiling/floor and not just max/min)\\n\\n```java\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        int len = nums.length;\\n        \\n        // return false when given parameters makes two distinct indices impossible \\n        if (len <= 1 || k <= 0) {\\n            return false;\\n        }\\n        \\n        /**\\n        * Important, question definition:\\n        *   Absolute diff between nums[i] and nums[j] <= t\\n        *   Absolute diff between indices i and j <= k\\n        **/\\n        \\n        TreeSet<Long> set = new TreeSet();\\n        for (int i = 0; i < nums.length; i++) {\\n            Long number = new Long(nums[i]);\\n            Long ceil = set.ceiling(number);\\n            Long floor = set.floor(number);\\n            \\n            if (ceil != null && ceil - number <= t) {\\n                return true;\\n            }\\n            \\n            if (floor != null && number - floor <= t) {\\n                return true;\\n            }\\n            \\n            set.add(number);\\n            if (set.size() > k) {\\n                Long oldest = new Long(nums[i - k]);\\n                set.remove(oldest);\\n            }\\n        }\\n        \\n        return false;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "```k```\n```x```\n```nums```\n```k```\n```x```\n```x```\n```t```\n```k```\n```(k + 1)th```\n```(k + 1)th```\n```k```\n```k```\n```(k + 1)th```\n```nums = [1,2,3,1] | k = 3 | t = 0```\n```k```\n```[1,2,3]```\n```[..., 1]```\n```1```\n```[1,2,3]```\n```[1...]```\n```k```\n```[2,3,1]```\n```x```\n```x```\n```x```\n```k```\n```t```",
                "codeTag": "Unknown"
            },
            {
                "id": 825606,
                "title": "python-3-official-solution-in-python-3-2-methods-explanation",
                "content": "Below is Python 3 version of official solution: https://leetcode.com/problems/contains-duplicate-iii/solution/\\n### Approach \\\\#1\\n- Omitted since it will TLE\\n\\n### Approach \\\\#2 \\n- The official Java solution used `TreeSet` as help, which provide the ability to maintain the order. At the same time it search and remove is relatively efficient. \\n- Python standard library doesn\\'t come with a data struction like `TreeSet`, but from library `sortedcontainers`, we can simulate the same process using `SortedSet` (`SortedList` should also work in this scenario).\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        from sortedcontainers import SortedSet\\n        if not nums or t < 0: return False     # Handle special cases\\n        ss, n = SortedSet(), 0                 # Create SortedSet. `n` is the size of sortedset, max value of `n` is `k` from input\\n        for i, num in enumerate(nums):\\n            ceiling_idx = ss.bisect_left(num)  # index whose value is greater than or equal to `num`\\n            floor_idx = ceiling_idx - 1        # index whose value is smaller than `num`\\n            if ceiling_idx < n and abs(ss[ceiling_idx]-num) <= t: return True  # check right neighbour \\n            if 0 <= floor_idx and abs(ss[floor_idx]-num) <= t: return True     # check left neighbour\\n            ss.add(num)\\n            n += 1\\n            if i - k >= 0:  # maintain the size of sortedset by finding & removing the earliest number in sortedset\\n                ss.remove(nums[i-k])\\n                n -= 1\\n        return False\\n```\\n### Approach \\\\#3 \\n- This is pretty much a re-write of the official Java version. \\n- But by using `defaultdict`, the code is cleaner (since we don\\'t have to check the existance of a key in dictionary).\\n- Use `OrderedDict` is also a feasible way, since it is more efficient to maintain the size\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if not nums or t < 0: return False\\n        min_val = min(nums)\\n        bucket_key = lambda x: (x-min_val) // (t+1)       # A lambda function generate buckey key given a value\\n        d = collections.defaultdict(lambda: sys.maxsize)  # A bucket simulated with defaultdict\\n        for i, num in enumerate(nums):\\n            key = bucket_key(num)                         # key for current number `num`\\n            for nei in [d[key-1], d[key], d[key+1]]:      # check left bucket, current bucket and right bucket\\n                if abs(nei - num) <= t: return True\\n            d[key] = num    \\n            if i >= k: d.pop(bucket_key(nums[i-k]))       # maintain a size of `k` \\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        from sortedcontainers import SortedSet\\n        if not nums or t < 0: return False     # Handle special cases\\n        ss, n = SortedSet(), 0                 # Create SortedSet. `n` is the size of sortedset, max value of `n` is `k` from input\\n        for i, num in enumerate(nums):\\n            ceiling_idx = ss.bisect_left(num)  # index whose value is greater than or equal to `num`\\n            floor_idx = ceiling_idx - 1        # index whose value is smaller than `num`\\n            if ceiling_idx < n and abs(ss[ceiling_idx]-num) <= t: return True  # check right neighbour \\n            if 0 <= floor_idx and abs(ss[floor_idx]-num) <= t: return True     # check left neighbour\\n            ss.add(num)\\n            n += 1\\n            if i - k >= 0:  # maintain the size of sortedset by finding & removing the earliest number in sortedset\\n                ss.remove(nums[i-k])\\n                n -= 1\\n        return False\\n```\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if not nums or t < 0: return False\\n        min_val = min(nums)\\n        bucket_key = lambda x: (x-min_val) // (t+1)       # A lambda function generate buckey key given a value\\n        d = collections.defaultdict(lambda: sys.maxsize)  # A bucket simulated with defaultdict\\n        for i, num in enumerate(nums):\\n            key = bucket_key(num)                         # key for current number `num`\\n            for nei in [d[key-1], d[key], d[key+1]]:      # check left bucket, current bucket and right bucket\\n                if abs(nei - num) <= t: return True\\n            d[key] = num    \\n            if i >= k: d.pop(bucket_key(nums[i-k]))       # maintain a size of `k` \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61742,
                "title": "cpp-solution-by-using-multiset-n-log-k",
                "content": "    class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            multiset<int> mySet;\\n            for(int i = 0; i<nums.size(); i++){\\n            \\tauto lb = mySet.lower_bound(nums[i]-t);\\n            \\t//lower_bound returns the iterator (the most near to value equals to nums[i] - t) , this is tricky\\n            \\tif(lb!=mySet.end() && *lb - nums[i]<=t) return true;\\n            \\tmySet.insert(nums[i]);\\n            \\tif(mySet.size()>k) mySet.erase(nums[i-k]);\\n    \\n            }\\n        return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            multiset<int> mySet;\\n            for(int i = 0; i<nums.size(); i++){\\n            \\tauto lb = mySet.lower_bound(nums[i]-t);\\n            \\t//lower_bound returns the iterator (the most near to value equals to nums[i] - t) , this is tricky\\n            \\tif(lb!=mySet.end() && *lb - nums[i]<=t) return true;\\n            \\tmySet.insert(nums[i]);\\n            \\tif(mySet.size()>k) mySet.erase(nums[i-k]);\\n    \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 61706,
                "title": "python-without-dictionary",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @param {integer} k\\n        # @param {integer} t\\n        # @return {boolean}\\n        def containsNearbyAlmostDuplicate(self, nums, k, t):\\n            ind = sorted(range(len(nums)), key = lambda x: nums[x])\\n            for i in range(len(nums)-1):\\n                j = i + 1\\n                while j < len(nums) and nums[ind[j]] - nums[ind[i]] <= t:\\n                    if abs(ind[i]-ind[j]) <= k:\\n                        return True\\n                    j += 1\\n            return False\\n\\nind is an array of the indexes of sorted num. Iterate through ind to check if nums are within t and ind are within k.",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 2570864,
                "title": "c-sliding-window-w-easy-explanation",
                "content": "**Sliding Window:**\\n1. Create a winodw (multiset) of size k+1(as index to index+k will come in set) and it will be sorted.           i = left of window, j=right of window\\n2. If diff of adjacent elements <= t \\n\\t\\t\\tthen return true;\\n    b/c adjacent elements will be the one with min diff in a sorted set\\n3. For any element its adjacent left & right will be just less & just greater to it respectively.\\n4. Before inserting the current element(curr) in window(multiset) we look for the upper bound of curr in pre-exisiting window (also to avoid the number itself to become its upper bound if inserted first and then checked for upper bound) \\n5. If upper bound is not the end of multiset means just greater element is present in set and if absolute difference of upper bound(just greater) and curr <= valueDifference then return true\\n6. If upper bound is not the beginning of multiset means there is also a lower bound exisiting for curr which will be at index upper_bound - 1. If absolute difference of lower bound(just smaller) and curr <= valueDifference then return true\\n7. Keep a check if window size = k+1 then remove the ith element and increment i (slide the window)\\n8. If after traversing whole vector no such two elements are found return false at last.\\n\\n**If it helped, please UPVOTE : )**\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) \\n    {\\n        int n = nums.size();\\n        multiset<int> ms;     //to store window elements in sorted order\\n        \\n\\t\\tint i=0, j=0;\\n        while(j<n)\\n        {\\n            auto up = ms.upper_bound(nums[j]);\\n            if((up != ms.end() and *up-nums[j] <= t) || (up != ms.begin() and nums[j] - *(--up) <= t))\\n                return true;\\n            ms.insert(nums[j]);\\n            \\n            if(ms.size() == k+1)\\n            {\\n                ms.erase(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) \\n    {\\n        int n = nums.size();\\n        multiset<int> ms;     //to store window elements in sorted order\\n        \\n\\t\\tint i=0, j=0;\\n        while(j<n)\\n        {\\n            auto up = ms.upper_bound(nums[j]);\\n            if((up != ms.end() and *up-nums[j] <= t) || (up != ms.begin() and nums[j] - *(--up) <= t))\\n                return true;\\n            ms.insert(nums[j]);\\n            \\n            if(ms.size() == k+1)\\n            {\\n                ms.erase(nums[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 255877,
                "title": "who-gives-this-shit",
                "content": "what is this testcase really mean for?\\n\\n```\\n[-1,-1]\\n1\\n-1\\n```",
                "solutionTags": [],
                "code": "```\\n[-1,-1]\\n1\\n-1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61740,
                "title": "easy-ac-solution-using-treeset-long-in-java",
                "content": "\\n    public class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length == 0) return false;\\n        TreeSet<Long> set = new TreeSet<>();\\n        set.add((long) nums[0]);\\n        for (int i = 1; i < nums.length; i++) {\\n            if (i > k) set.remove((long) nums[i - k - 1]);\\n            long left = (long) nums[i] - t;\\n            long right = (long) nums[i] + t;\\n            if (left <= right && !set.subSet(left, right + 1).isEmpty()) return true;\\n            set.add((long) nums[i]);\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length == 0) return false;\\n        TreeSet<Long> set = new TreeSet<>();\\n        set.add((long) nums[0]);\\n        for (int i = 1; i < nums.length; i++) {\\n            if (i > k) set.remove((long) nums[i - k - 1]);\\n            long left = (long) nums[i] - t;\\n            long right = (long) nums[i] + t;\\n            if (left <= right && !set.subSet(left, right + 1).isEmpty()) return true;\\n            set.add((long) nums[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 599885,
                "title": "python-bucket-sort-ordered-map-solution-beats-95-53-with-handwriting-explanation",
                "content": "**Time Complexity: O(n)**\\n\\nMedium blog [Here](https://medium.com/@yilingliu1994/the-application-of-bucket-sort-ordered-dict-leetcode-220-6f99d0eb375?postPublishedType=initial)\\n\\nCode:\\n```\\nimport collections\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        if k < 0 or t < 0:\\n            return False\\n        # example: set([1,1,2,3]) = {1,2,3}, length = 3 != 4, so there are duplicated numbers\\n        if t == 0:\\n            return len(set(nums)) != len(nums)\\n        bucket = collections.OrderedDict()\\n        b_size = t + 1\\n        for num in nums:\\n\\t\\t\\t# explanation in picture 1 and 2\\n            key = num//b_size\\n            if key in bucket:\\n                return True\\n            bucket[key] = num\\n\\t\\t\\t# end of picture 1 and 2\\n\\t\\t\\t# explanation in picture 3\\n            if key - 1 in bucket and num - bucket[key - 1] <= t:\\n                return True\\n            if key + 1 in bucket and bucket[key + 1] - num <= t:\\n                return True\\n\\t\\t\\t# end of picture 3\\n            # remove the first added key\\n            if len(bucket) > k:\\n                bucket.popitem(last = False)\\n        return False\\n```\\n\\nPicture 1:\\n![image](https://assets.leetcode.com/users/yilingliu/image_1587981434.png)\\n\\nPicture 2:\\n![image](https://assets.leetcode.com/users/yilingliu/image_1587981438.png)\\n\\nPicture 3:\\n![image](https://assets.leetcode.com/users/yilingliu/image_1587981976.png)\\n\\n\\nWhy use OrderedDict:\\n\\n```\\n\\'\\'\\'\\nOrderedDict.popitem(last: bool) -> Tuple[Unknown]\\nRemove and return a (key, value) pair from the dictionary.\\n\\nPairs are returned in LIFO order if last is true or FIFO order if false.\\n\\'\\'\\'\\n```\\n\\nSo if the dictionary is full and we need to move to the next element, the first element added to dict could be removed",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```\\nimport collections\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        if k < 0 or t < 0:\\n            return False\\n        # example: set([1,1,2,3]) = {1,2,3}, length = 3 != 4, so there are duplicated numbers\\n        if t == 0:\\n            return len(set(nums)) != len(nums)\\n        bucket = collections.OrderedDict()\\n        b_size = t + 1\\n        for num in nums:\\n\\t\\t\\t# explanation in picture 1 and 2\\n            key = num//b_size\\n            if key in bucket:\\n                return True\\n            bucket[key] = num\\n\\t\\t\\t# end of picture 1 and 2\\n\\t\\t\\t# explanation in picture 3\\n            if key - 1 in bucket and num - bucket[key - 1] <= t:\\n                return True\\n            if key + 1 in bucket and bucket[key + 1] - num <= t:\\n                return True\\n\\t\\t\\t# end of picture 3\\n            # remove the first added key\\n            if len(bucket) > k:\\n                bucket.popitem(last = False)\\n        return False\\n```\n```\\n\\'\\'\\'\\nOrderedDict.popitem(last: bool) -> Tuple[Unknown]\\nRemove and return a (key, value) pair from the dictionary.\\n\\nPairs are returned in LIFO order if last is true or FIFO order if false.\\n\\'\\'\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1163715,
                "title": "accepted-solution-for-swift",
                "content": "```swift\\nclass Solution {\\n    func containsNearbyAlmostDuplicate(_ nums: [Int], _ k: Int, _ t: Int) -> Bool {\\n        guard !nums.isEmpty else { return false }\\n        let ids = [Int](0..<nums.count).sorted{ nums[$0] < nums[$1] }\\n        \\n        for a in 0...ids.count - 1 {\\n            for b in (a + 1)..<nums.count {\\n                let lhs = ids[a], rhs = ids[b]\\n                if nums[rhs] - nums[lhs] > t { break }\\n                if abs(rhs - lhs) <= k { return true }\\n            }\\n        }\\n        return false\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n<pre>\\nResult: Executed 1 test, with 0 failures (0 unexpected) in 0.004 (0.005) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test() {\\n        XCTAssertEqual(solution.containsNearbyAlmostDuplicate([1,2,3,1], 3, 0), true)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func containsNearbyAlmostDuplicate(_ nums: [Int], _ k: Int, _ t: Int) -> Bool {\\n        guard !nums.isEmpty else { return false }\\n        let ids = [Int](0..<nums.count).sorted{ nums[$0] < nums[$1] }\\n        \\n        for a in 0...ids.count - 1 {\\n            for b in (a + 1)..<nums.count {\\n                let lhs = ids[a], rhs = ids[b]\\n                if nums[rhs] - nums[lhs] > t { break }\\n                if abs(rhs - lhs) <= k { return true }\\n            }\\n        }\\n        return false\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test() {\\n        XCTAssertEqual(solution.containsNearbyAlmostDuplicate([1,2,3,1], 3, 0), true)\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 658158,
                "title": "python-well-explained-sliding-window-bucket-sort",
                "content": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if t>=0:\\n            bs,w = {}, t+1\\n            for i, v in enumerate(nums):\\n                b = v // w\\n                if b in bs:\\n                    return True\\n                else:\\n                    bs[b] = v\\n                    if (b-1 in bs and v-bs[b-1] <= t) or (b+1 in bs and bs[b+1]-v <= t):\\n                        return True\\n                    if i >= k:\\n                        del bs[nums[i-k] // w]\\n        return False \\n```\\n\\nSo the general idea is simple. We need to check two things:\\n\\n1. The indexes of the elements are `>=k` apart. That can be done by using a sliding window.\\n2. The values of the elements are `>=t` apart. This is a bit more interesting. Let\\'s say we have buckets of size `t+1`. If our element value is `v`, it will go into bucket `v//(t+1)`.  So if we get 2 values in the same bucket - they are withing `t+1` - so we found a solution. It\\'s also possible that we might have an element close enough in the previous or next bucket.\\n3. Finally, as we move sliding window, we need to remove left element from the buckets.\\n\\nOk, now we put everything together:\\n\\n1. The absolute difference can\\'t be a negative number, but apparently they have an edge test case where `t=-1` and it causes division by 0, so we take care of this explicitely:\\n\\n```\\n        if t>=0:\\n```\\n\\n2. Now we define our buckets and the bucket width w:\\n```\\n            bs,w = {}, t+1\\n```\\n3. Our main loop:\\n```\\n            for i, v in enumerate(nums):\\n```\\n\\t4. `b` is the bucket number for the current value `v`:\\n```\\n               b = v // w\\n```\\n5. If that bucket already has another value - we found a pair!\\n```\\n                if b in bs:\\n                    return True\\n```\\n6. Otherwise we add the current value into the new bucket and check the buckets just above and below. Make sure that you check that the element is in bs first before you try to use it\\'s value, not the other way around!\\n```\\n                    bs[b] = v\\n                    if (b-1 in bs and v-bs[b-1] <= t) or (b+1 in bs and bs[b+1]-v <= t):\\n                        return True\\n```\\n7. Finally, if we exceeded sliding window - we remove the leftmost value from its bucket:\\n```\\n                    if i >= k:\\n                        del bs[nums[i-k] // w]\\n```\\n8. If we haven\\'t found any good pairs, we return False:\\n\\n```\\n        return False \\n```\\n\\nThat\\'s it!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if t>=0:\\n            bs,w = {}, t+1\\n            for i, v in enumerate(nums):\\n                b = v // w\\n                if b in bs:\\n                    return True\\n                else:\\n                    bs[b] = v\\n                    if (b-1 in bs and v-bs[b-1] <= t) or (b+1 in bs and bs[b+1]-v <= t):\\n                        return True\\n                    if i >= k:\\n                        del bs[nums[i-k] // w]\\n        return False \\n```\n```\\n        if t>=0:\\n```\n```\\n            bs,w = {}, t+1\\n```\n```\\n            for i, v in enumerate(nums):\\n```\n```\\n               b = v // w\\n```\n```\\n                if b in bs:\\n                    return True\\n```\n```\\n                    bs[b] = v\\n                    if (b-1 in bs and v-bs[b-1] <= t) or (b+1 in bs and bs[b+1]-v <= t):\\n                        return True\\n```\n```\\n                    if i >= k:\\n                        del bs[nums[i-k] // w]\\n```\n```\\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1809732,
                "title": "c-sliding-window-multiset-solution-with-comments-easy-understanding",
                "content": "\\n\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n=nums.size();\\n        t=(long)t;          // taking t as long because difference between numbers can be greater than INT_MAX\\n        multiset<long> s;   //window\\n        \\n        for(int i=0;i<n;i++){\\n            if(i>k){\\n                s.erase((long)nums[i-k-1]);         // if size of window > k, we are removing elements from window\\n            }\\n            \\n            auto it=s.lower_bound((long)nums[i]-t); // searching for numbers with difference at most t\\n\\t\\t\\tlong dif=*it-(long)nums[i];             // difference is calculated for further comparisons\\n\\t\\t\\t\\n            if(it!=s.end() and dif<=t){             // if number in window with at most t difference is present \\n                return true;\\n            }\\n            s.insert(nums[i]); // inserting element in window \\n        }\\n        return false;\\n    }\\n\\t// Thanks\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "\\n\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n=nums.size();\\n        t=(long)t;          // taking t as long because difference between numbers can be greater than INT_MAX\\n        multiset<long> s;   //window\\n        \\n        for(int i=0;i<n;i++){\\n            if(i>k){\\n                s.erase((long)nums[i-k-1]);         // if size of window > k, we are removing elements from window\\n            }\\n            \\n            auto it=s.lower_bound((long)nums[i]-t); // searching for numbers with difference at most t\\n\\t\\t\\tlong dif=*it-(long)nums[i];             // difference is calculated for further comparisons\\n\\t\\t\\t\\n            if(it!=s.end() and dif<=t){             // if number in window with at most t difference is present \\n                return true;\\n            }\\n            s.insert(nums[i]); // inserting element in window \\n        }\\n        return false;\\n    }\\n\\t// Thanks\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 829231,
                "title": "python3-easy-to-understand-o-n-solution-contains-duplicate-iii",
                "content": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        d = OrderedDict()\\n        window = t + 1\\n        for i, n in enumerate(nums):\\n            while len(d) > k:\\n                d.popitem(last=False)\\n            if (b := n//window) in d:\\n                return True \\n            if b - 1 in d and abs(d[b-1] - n) <= t:\\n                return True\\n            if b + 1 in d and abs(d[b+1] - n) <= t:\\n                return True\\n            d[b] = nums[i]  \\n        return False \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        d = OrderedDict()\\n        window = t + 1\\n        for i, n in enumerate(nums):\\n            while len(d) > k:\\n                d.popitem(last=False)\\n            if (b := n//window) in d:\\n                return True \\n            if b - 1 in d and abs(d[b-1] - n) <= t:\\n                return True\\n            if b + 1 in d and abs(d[b+1] - n) <= t:\\n                return True\\n            d[b] = nums[i]  \\n        return False \\n```",
                "codeTag": "Java"
            },
            {
                "id": 339421,
                "title": "python-bucket-method-in-detail",
                "content": "Thanks to @dietpepsi, here I am explaining his solution as simple as I can.\\n\\nWe take bucketSize = t+1\\nSo when we encounter a number N we can get its bucket index = N / bucketSize\\nThere are 2 cases our code will return True:\\n```\\n(1) When two numbers lie in the same bucket, they already have difference <= t because of bucket size\\n(2) When two numbers lie in the adjacent bucket and they have difference<=t\\n```\\n\\nCreate a dictionary allBuckets = {}\\nOur allBuckets store only buckets corresponding to at max k numbers inside our k sized window.\\n\\n**In the below code when i>=k we delete the bucket of (i-k)th index from our allBuckets,\\nin this way we only maintain buckets for indexes (i-k+1) to i --> k numbers**\\n\\n```\\ndef containsNearbyAlmostDuplicate(self, nums, k, t):\\n\\tif t<0 or k<0:\\n\\t\\treturn False\\n\\tallBuckets = {}\\n\\tbucketSize = t+1\\n\\tfor i in xrange(len(nums)):\\n\\t\\t# m is bucket Index for nums[i]\\n\\t\\tm = nums[i]/bucketSize\\n\\t\\t\\n\\t\\t#if there is a bucket already present corresponding to current number\\n\\t\\tif m in allBuckets:\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n\\t\\t#checking two adjacent buckets  m, m-1\\n\\t\\tif (m-1) in allBuckets and abs(nums[i]-allBuckets[m-1])<bucketSize:\\n\\t\\t\\treturn True\\n\\t\\t\\n\\t\\t#checking two adjacent buckets m, m+1\\n\\t\\tif (m+1) in allBuckets and abs(nums[i]-allBuckets[m+1])<bucketSize:\\n\\t\\t\\treturn True\\n\\t\\tallBuckets[m]= nums[i]\\n\\t\\t\\n\\t\\t#removing the bucket corresponding to number out of our k sized window\\n\\t\\tif i>=k:\\n\\t\\t\\tdel allBuckets[ nums[i-k]/bucketSize ]\\n\\treturn False\\n```",
                "solutionTags": [],
                "code": "```\\n(1) When two numbers lie in the same bucket, they already have difference <= t because of bucket size\\n(2) When two numbers lie in the adjacent bucket and they have difference<=t\\n```\n```\\ndef containsNearbyAlmostDuplicate(self, nums, k, t):\\n\\tif t<0 or k<0:\\n\\t\\treturn False\\n\\tallBuckets = {}\\n\\tbucketSize = t+1\\n\\tfor i in xrange(len(nums)):\\n\\t\\t# m is bucket Index for nums[i]\\n\\t\\tm = nums[i]/bucketSize\\n\\t\\t\\n\\t\\t#if there is a bucket already present corresponding to current number\\n\\t\\tif m in allBuckets:\\n\\t\\t\\treturn True\\n\\t\\t\\t\\n\\t\\t#checking two adjacent buckets  m, m-1\\n\\t\\tif (m-1) in allBuckets and abs(nums[i]-allBuckets[m-1])<bucketSize:\\n\\t\\t\\treturn True\\n\\t\\t\\n\\t\\t#checking two adjacent buckets m, m+1\\n\\t\\tif (m+1) in allBuckets and abs(nums[i]-allBuckets[m+1])<bucketSize:\\n\\t\\t\\treturn True\\n\\t\\tallBuckets[m]= nums[i]\\n\\t\\t\\n\\t\\t#removing the bucket corresponding to number out of our k sized window\\n\\t\\tif i>=k:\\n\\t\\t\\tdel allBuckets[ nums[i-k]/bucketSize ]\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1423174,
                "title": "c-sliding-window-easiest-sol-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) \\n    {\\n        if(t<0 || k<=0)\\n            return false;\\n        \\n        t = (long)t;\\n        k = (long)k;\\n        multiset<long> window;//window of size k\\n\\n        for(int right=0; right<nums.size(); right++)\\n        {\\n            if(right > k)//abs(i - j) <= k.\\n                window.erase((long)nums[right-k-1]);//slide the window\\n\\n           //search within the window for the number which can satisfy the condition\\n            auto number_satisfy  = window.lower_bound((long)nums[right]-t);\\n            long diff = *number_satisfy - (long)nums[right];\\n            //abs(nums[i] - nums[j]) <= t\\n            if(number_satisfy != window.end() and diff <= t)\\n                return true;\\n\\n            window.insert(nums[right]);\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) \\n    {\\n        if(t<0 || k<=0)\\n            return false;\\n        \\n        t = (long)t;\\n        k = (long)k;\\n        multiset<long> window;//window of size k\\n\\n        for(int right=0; right<nums.size(); right++)\\n        {\\n            if(right > k)//abs(i - j) <= k.\\n                window.erase((long)nums[right-k-1]);//slide the window\\n\\n           //search within the window for the number which can satisfy the condition\\n            auto number_satisfy  = window.lower_bound((long)nums[right]-t);\\n            long diff = *number_satisfy - (long)nums[right];\\n            //abs(nums[i] - nums[j]) <= t\\n            if(number_satisfy != window.end() and diff <= t)\\n                return true;\\n\\n            window.insert(nums[right]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 824724,
                "title": "c-16-ms-96-solution-with-map-and-2-pointers-explanation",
                "content": "1. create map < nums[i]  ,  [i]> where  0 < i < nums.size()\\n2. Now we have orderd numbers from vector nums in our map\\n3. We sequentially scan the numbers in the map (in the range from i, until the number in the map exceeds the original number + t)\\n\\nRuntime: 16 ms, faster than 96.45% of C++ online submissions for Contains Duplicate III.\\nMemory Usage: 15.2 MB, less than 46.57% of C++ online submissions for Contains Duplicate III.\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        multimap <int,int> mp;\\n        for(int i=0;i<nums.size();i++) mp.insert(pair< int, int >(nums[i], i));\\n        \\n        multimap <int,int>::iterator it, itnext;\\n        \\n        for(it=mp.begin();it!=mp.end();it++){\\n            itnext = it;\\n            while(true){\\n                itnext++;\\n                if(itnext == mp.end()) break;\\n                long long a = (*it).first;\\n                long long b = (*itnext).first;\\n                if( b - a <= t)  {if(abs((*it).second - (*itnext).second) <= k) return true;}\\n                else break;\\n            }\\n        }            \\n        return false;\\n    }\\n};\\n```\\n\\n**original it was writed as it:**\\n```\\nclass Solution {\\npublic:\\n  bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n    multimap <int,int> mp;\\n    for(int i = 0; i != nums.size(); i++) mp.insert({nums[i], i});\\n        \\n    for(multimap <int,int>::iterator it = mp.begin(), itnext = mp.begin(); it != mp.end(); itnext = ++it)\\n      while(++itnext != mp.end())\\n        if(long((*itnext).first) - long((*it).first) <= t)  {if(abs((*it).second - (*itnext).second) <= k) return true;}\\n        else break;\\n        \\n    return false;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        multimap <int,int> mp;\\n        for(int i=0;i<nums.size();i++) mp.insert(pair< int, int >(nums[i], i));\\n        \\n        multimap <int,int>::iterator it, itnext;\\n        \\n        for(it=mp.begin();it!=mp.end();it++){\\n            itnext = it;\\n            while(true){\\n                itnext++;\\n                if(itnext == mp.end()) break;\\n                long long a = (*it).first;\\n                long long b = (*itnext).first;\\n                if( b - a <= t)  {if(abs((*it).second - (*itnext).second) <= k) return true;}\\n                else break;\\n            }\\n        }            \\n        return false;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n    multimap <int,int> mp;\\n    for(int i = 0; i != nums.size(); i++) mp.insert({nums[i], i});\\n        \\n    for(multimap <int,int>::iterator it = mp.begin(), itnext = mp.begin(); it != mp.end(); itnext = ++it)\\n      while(++itnext != mp.end())\\n        if(long((*itnext).first) - long((*it).first) <= t)  {if(abs((*it).second - (*itnext).second) <= k) return true;}\\n        else break;\\n        \\n    return false;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 805542,
                "title": "python-bst-approach-with-sortedcontainers",
                "content": "```\\nimport sortedcontainers\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        def floor(n, bst):\\n            le = bst.bisect_right(n) - 1\\n            return bst[le] if le >= 0 else None\\n        \\n        def ceiling(n, bst):\\n            ge = bst.bisect_right(n)\\n            return bst[ge] if ge < len(bst) else None\\n        \\n        bst = sortedcontainers.SortedList()\\n        for i, n in enumerate(nums):\\n            le = floor(n, bst)\\n            if le is not None and n <= le + t:\\n                return True\\n            ge = ceiling(n, bst)\\n            if ge is not None and ge <= n + t:\\n                return True\\n            bst.add(n)\\n            if len(bst) > k:\\n                bst.remove(nums[i-k])\\n        return False\\n    # time:  O(nlogk)\\n    # space: O(k)\\n```\\n*Edit: tags*",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree"
                ],
                "code": "```\\nimport sortedcontainers\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        def floor(n, bst):\\n            le = bst.bisect_right(n) - 1\\n            return bst[le] if le >= 0 else None\\n        \\n        def ceiling(n, bst):\\n            ge = bst.bisect_right(n)\\n            return bst[ge] if ge < len(bst) else None\\n        \\n        bst = sortedcontainers.SortedList()\\n        for i, n in enumerate(nums):\\n            le = floor(n, bst)\\n            if le is not None and n <= le + t:\\n                return True\\n            ge = ceiling(n, bst)\\n            if ge is not None and ge <= n + t:\\n                return True\\n            bst.add(n)\\n            if len(bst) > k:\\n                bst.remove(nums[i-k])\\n        return False\\n    # time:  O(nlogk)\\n    # space: O(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 295563,
                "title": "c-sortedset-getviewbetween",
                "content": "```\\npublic class Solution {\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (t < 0) return false;\\n        var n = nums.Length;\\n        var sortedSet = new SortedSet<long>();\\n        for (int i = 0; i < n; i++) {\\n            if (sortedSet.GetViewBetween((long)nums[i] - t, (long)nums[i] + t).Count > 0) return true;\\n            sortedSet.Add(nums[i]);\\n            if (i >= k) sortedSet.Remove(nums[i - k]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (t < 0) return false;\\n        var n = nums.Length;\\n        var sortedSet = new SortedSet<long>();\\n        for (int i = 0; i < n; i++) {\\n            if (sortedSet.GetViewBetween((long)nums[i] - t, (long)nums[i] + t).Count > 0) return true;\\n            sortedSet.Add(nums[i]);\\n            if (i >= k) sortedSet.Remove(nums[i - k]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61668,
                "title": "10ms-non-cheating-solution-beats-98-84-submissions",
                "content": "Unlike some solutions in the forum that convert int to long which is kinda of cheating, this solution doesn't convert.. Converting defeats the purpose of having max value test case (if the input contains max long itself, how to handle?)\\n\\n```\\nimport java.util.Hashtable;\\n\\npublic class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n\\tif(k<=0||t<0||nums.length < 2) return false;\\n\\t\\t\\n        Hashtable<Integer,Integer> hs = new Hashtable<Integer,Integer>();\\n\\n        if (t==0) {\\n            for (int i = 0; i<nums.length; i++){\\n            \\tif (i>k) {\\n                \\ths.remove(nums[i-k-1]);\\n                }\\n                if (hs.containsKey(nums[i])){\\n                    return true;\\n                }\\n                hs.put(nums[i],i);\\n            }\\n            return false;\\n        } else{\\n\\n            for (int i = 0; i<nums.length; i++){\\n            \\tif (i>k) {\\n                \\t// windowing, only preserve k#\\n                \\ths.remove(nums[i-k-1]/t);\\n                }\\n                if (hs.get(nums[i]/t) != null ){\\n                \\tint delta = Math.abs(nums[i] - nums[hs.get(nums[i]/t)]);\\n                \\t// The delta value could be larger than t, if one number is in (-t,0) and the other is in (0,t)\\n                \\tif ( delta<=t) return true;\\n                }\\n                if (hs.get(nums[i]/t-1) != null ){\\n                \\tint delta = nums[i] - nums[hs.get(nums[i]/t-1)];\\n                \\t// If delta < 0, the distance between to numbers is larger than Integer.MAX_VALUE, which is larger than t.\\n                \\tif ( delta<=t && delta >0) return true;\\n                }\\n                if (hs.get(nums[i]/t+1) != null ){\\n                \\tint delta = nums[hs.get(nums[i]/t+1)] - nums[i];\\n                \\t// If delta < 0, the distance between to numbers is larger than Integer.MAX_VALUE, which is larger than t.\\n                \\tif ( delta<=t && delta >0) return true;\\n\\n                }\\n    \\n                hs.put(nums[i]/t,i);\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Hashtable;\\n\\npublic class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n\\tif(k<=0||t<0||nums.length < 2) return false;\\n\\t\\t\\n        Hashtable<Integer,Integer> hs = new Hashtable<Integer,Integer>();\\n\\n        if (t==0) {\\n            for (int i = 0; i<nums.length; i++){\\n            \\tif (i>k) {\\n                \\ths.remove(nums[i-k-1]);\\n                }\\n                if (hs.containsKey(nums[i])){\\n                    return true;\\n                }\\n                hs.put(nums[i],i);\\n            }\\n            return false;\\n        } else{\\n\\n            for (int i = 0; i<nums.length; i++){\\n            \\tif (i>k) {\\n                \\t// windowing, only preserve k#\\n                \\ths.remove(nums[i-k-1]/t);\\n                }\\n                if (hs.get(nums[i]/t) != null ){\\n                \\tint delta = Math.abs(nums[i] - nums[hs.get(nums[i]/t)]);\\n                \\t// The delta value could be larger than t, if one number is in (-t,0) and the other is in (0,t)\\n                \\tif ( delta<=t) return true;\\n                }\\n                if (hs.get(nums[i]/t-1) != null ){\\n                \\tint delta = nums[i] - nums[hs.get(nums[i]/t-1)];\\n                \\t// If delta < 0, the distance between to numbers is larger than Integer.MAX_VALUE, which is larger than t.\\n                \\tif ( delta<=t && delta >0) return true;\\n                }\\n                if (hs.get(nums[i]/t+1) != null ){\\n                \\tint delta = nums[hs.get(nums[i]/t+1)] - nums[i];\\n                \\t// If delta < 0, the distance between to numbers is larger than Integer.MAX_VALUE, which is larger than t.\\n                \\tif ( delta<=t && delta >0) return true;\\n\\n                }\\n    \\n                hs.put(nums[i]/t,i);\\n            }\\n            return false;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61736,
                "title": "o-n-solution-in-c-using-bucket-sort",
                "content": "    // time: O(n); space: O(n)\\n    class Solution {\\n        long long getBucketId(long long i, long long w) {\\n            return i < 0 ? (i + 1) / w - 1 : i / w;\\n        }\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            int n = nums.size();\\n            if (n < 2 || k < 1 || t < 0)\\n            {\\n                return false;\\n            }\\n    \\n            unordered_map<long long, long long> buckets;\\n            long long width = (long long)t + 1;\\n            for (int i = 0; i < n; i++)\\n            {\\n                long long id = getBucketId(nums[i], width);\\n    \\n                // found the value in the same bucket\\n                if (buckets.find(id) != buckets.end())\\n                {\\n                    return true;\\n                }\\n    \\n                // found the value in the adjacent bucket\\n                if ((buckets.find(id - 1) != buckets.end() && nums[i] - buckets[id - 1] < width) ||\\n                    (buckets.find(id + 1) != buckets.end() && buckets[id + 1] - nums[i] < width))\\n                {\\n                    return true;\\n                }\\n    \\n                // insert current value to buckets\\n                buckets[id] = nums[i];\\n    \\n                if (i >= k)    // remove out of range element\\n                {\\n                    buckets.erase(getBucketId(nums[i - k], width));\\n                }\\n            }\\n    \\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        long long getBucketId(long long i, long long w) {\\n            return i < 0 ? (i + 1) / w - 1 : i / w;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3546546,
                "title": "python-bucketsort-o-n-beat-98-with-comments",
                "content": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n        buckets = {} #store values for diapason (i-indexDiff:i]\\n        valueDiff +=1 #if valueDiff = zero it\\'s simplify proces edge-cases\\n        \\n        for idx, curVal in enumerate(nums):\\n            bucketId = curVal // valueDiff #bucket for new element\\n            if bucketId in buckets: return True # have \\'duplicate value\\' in current bucket\\n            #check neighboring buckets if they are exists\\n            for i in (bucketId - 1, bucketId + 1):\\n                if i in buckets: # bucket exist\\n                    if abs(buckets[i] - curVal) < valueDiff: # because valueDiff+1 then check only strict <\\n                        return True\\n            \\n            #add current value to bucket\\n            buckets[bucketId] = curVal\\n            \\n            # remove value out of available window\\n            if idx >= indexDiff:\\n                removeVal = nums[idx - indexDiff]\\n                del buckets[removeVal//valueDiff]\\n\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n        buckets = {} #store values for diapason (i-indexDiff:i]\\n        valueDiff +=1 #if valueDiff = zero it\\'s simplify proces edge-cases\\n        \\n        for idx, curVal in enumerate(nums):\\n            bucketId = curVal // valueDiff #bucket for new element\\n            if bucketId in buckets: return True # have \\'duplicate value\\' in current bucket\\n            #check neighboring buckets if they are exists\\n            for i in (bucketId - 1, bucketId + 1):\\n                if i in buckets: # bucket exist\\n                    if abs(buckets[i] - curVal) < valueDiff: # because valueDiff+1 then check only strict <\\n                        return True\\n            \\n            #add current value to bucket\\n            buckets[bucketId] = curVal\\n            \\n            # remove value out of available window\\n            if idx >= indexDiff:\\n                removeVal = nums[idx - indexDiff]\\n                del buckets[removeVal//valueDiff]\\n\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407967,
                "title": "clean-python-solution-self-explained-with-other-similar-problems",
                "content": "```python\\n\"\"\"\\nTime: O(N)\\nSpace: O(K)\\n\\nImagine there are several different buckets. Each bucket can only contain one number.\\nBucket1 contains a number within [0, t]\\nBucket2 contains a number within [t+1, 2t+1]\\nBucket3 contains a number within [2t+2, 3t+2]\\n...\\n\\nFor each num, put it in the bucket.\\nBefore that.\\nIf the bucket is already occupied, there must be another num that \"abs(anotherNum - num) <= t\", return True.\\nCheck the neighbor buckets, the number within those might also \"abs(anotherNum - num) <= t\". If so, return True.\\n\\nWe only consider k numbers before num.\\nSo remove nums[i-k-1] from the bucket if we already have k elements in the buckets.\\n\"\"\"\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        bucket = {}\\n        \\n        for i, num in enumerate(nums):\\n            if len(bucket)>k:\\n                bidToRemove = nums[i-k-1]//(t+1)\\n                del bucket[bidToRemove]\\n            \\n            bid = num//(t+1)\\n            if bid in bucket: return True\\n            if bid+1 in bucket and abs(bucket[bid+1]-num)<=t: return True\\n            if bid-1 in bucket and abs(bucket[bid-1]-num)<=t: return True\\n            bucket[bid] = num\\n        \\n        return False\\n\\t\\t\\n\"\"\"\\nRelated Heap Problems:\\nContains Duplicate: I, II, III\\nMax Sum of Rectangle No Larger Than K\\nMaximum Sum Of Subarray Close To K\\nK Empty Slots\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(N)\\nSpace: O(K)\\n\\nImagine there are several different buckets. Each bucket can only contain one number.\\nBucket1 contains a number within [0, t]\\nBucket2 contains a number within [t+1, 2t+1]\\nBucket3 contains a number within [2t+2, 3t+2]\\n...\\n\\nFor each num, put it in the bucket.\\nBefore that.\\nIf the bucket is already occupied, there must be another num that \"abs(anotherNum - num) <= t\", return True.\\nCheck the neighbor buckets, the number within those might also \"abs(anotherNum - num) <= t\". If so, return True.\\n\\nWe only consider k numbers before num.\\nSo remove nums[i-k-1] from the bucket if we already have k elements in the buckets.\\n\"\"\"\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        bucket = {}\\n        \\n        for i, num in enumerate(nums):\\n            if len(bucket)>k:\\n                bidToRemove = nums[i-k-1]//(t+1)\\n                del bucket[bidToRemove]\\n            \\n            bid = num//(t+1)\\n            if bid in bucket: return True\\n            if bid+1 in bucket and abs(bucket[bid+1]-num)<=t: return True\\n            if bid-1 in bucket and abs(bucket[bid-1]-num)<=t: return True\\n            bucket[bid] = num\\n        \\n        return False\\n\\t\\t\\n\"\"\"\\nRelated Heap Problems:\\nContains Duplicate: I, II, III\\nMax Sum of Rectangle No Larger Than K\\nMaximum Sum Of Subarray Close To K\\nK Empty Slots\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825264,
                "title": "a-sortedset-based-solution",
                "content": "```\\npublic class Solution\\n{\\n    private SortedSet<long> neighbors = new SortedSet<long>();\\n    \\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t)\\n    {\\n        if(k < 0 || t < 0) return false;\\n\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(IsThereNeighbor(nums[i], t)) return true;\\n            neighbors.Add(nums[i]);\\n            if(i >= k) neighbors.Remove(nums[i-k]);\\n        }\\n        return false;\\n    }\\n    \\n    private bool IsThereNeighbor(long num, int distance)\\n    {\\n        return neighbors.GetViewBetween(num - distance, num + distance).Any();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    private SortedSet<long> neighbors = new SortedSet<long>();\\n    \\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t)\\n    {\\n        if(k < 0 || t < 0) return false;\\n\\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            if(IsThereNeighbor(nums[i], t)) return true;\\n            neighbors.Add(nums[i]);\\n            if(i >= k) neighbors.Remove(nums[i-k]);\\n        }\\n        return false;\\n    }\\n    \\n    private bool IsThereNeighbor(long num, int distance)\\n    {\\n        return neighbors.GetViewBetween(num - distance, num + distance).Any();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548969,
                "title": "easy-js-solution",
                "content": "```\\n/*\\nk = max size of window \\nt = max diff between nums[startOfWindow] and nums[endOfWindow]\\n\\nWe need to find if there are i and j such that (1) their size of window is <= k and (2) their diff is <= t.\\n*/\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i+1; j <= i+k; j++) { // satisfies (1)\\n            let diff = Math.abs(nums[i] - nums[j]);\\n            if (diff <= t) { // satisfies (2)\\n                return true; \\n            }\\n        }\\n    }\\n    return false;\\n    // T.C: O(N*K)\\n    // S.C: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nk = max size of window \\nt = max diff between nums[startOfWindow] and nums[endOfWindow]\\n\\nWe need to find if there are i and j such that (1) their size of window is <= k and (2) their diff is <= t.\\n*/\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    for (let i = 0; i < nums.length; i++) {\\n        for (let j = i+1; j <= i+k; j++) { // satisfies (1)\\n            let diff = Math.abs(nums[i] - nums[j]);\\n            if (diff <= t) { // satisfies (2)\\n                return true; \\n            }\\n        }\\n    }\\n    return false;\\n    // T.C: O(N*K)\\n    // S.C: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 541412,
                "title": "javascript-binary-search-tree",
                "content": "- Time Complexity: O(NH)\\n- Space Compexity: O(K)\\n\\n```JavaScript\\n/**\\n * @param {number} x\\n */\\nconst BST  = function(x) {\\n    this.val = x;\\n    this.left = null;\\n    this.right = null;\\n}\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nBST.prototype.add = function(x, t) {\\n    if (x < this.val) {\\n        this.left ? this.left.add(x) : this.left = new BST(x);\\n        return this.val - x <= t \\n    } else {\\n        this.right ? this.right.add(x) : this.right = new BST(x);\\n    }\\n}\\n\\n/**\\n * @param {BST} node\\n * @return {BST}\\n */\\nconst predecessor = function(node) {\\n    node = node.left;\\n    while (node.right) {\\n        node = node.right;\\n    }\\n    return node;\\n}\\n\\n/**\\n * @param {BST} node\\n * @return {BST}\\n */\\nconst successor = function(node) {\\n    node = node.right;\\n    while (node.left) {\\n        node = node.left;\\n    }\\n    return node;\\n}\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nBST.prototype.delete = function(x) {\\n    if (this.val === x) {\\n        if (this.right) {\\n            const next = successor(this);\\n            this.val = next.val;\\n            this.right = this.right.delete(next.val);\\n        } else if (this.left) {\\n            const prev = predecessor(this);\\n            this.val = prev.val;\\n            this.left = this.left.delete(prev.val);\\n        } else {\\n            return null;\\n        }\\n    } else {\\n        this.val < x\\n            ? this.right = this.right.delete(x)\\n            : this.left = this.left.delete(x);\\n    }\\n    return this;\\n}\\n\\n/**\\n * @param {number} a\\n * @param {number} b\\n * @return {boolean}\\n */\\nBST.prototype.between = function(a,b) {\\n    if (a <= this.val && this.val <= b) {\\n        return true;\\n    }\\n    if (this.left && a < this.val && b < this.val) {\\n        return this.left.between(a,b);\\n    }\\n    if (this.right && a > this.val && b > this.val) {\\n        return this.right.between(a,b);\\n    }\\n    return false;\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    let root = null;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (root && root.between(nums[i] - t, nums[i] + t)) {\\n            return true;\\n        }\\n        root ? root.add(nums[i]) : root = new BST(nums[i]);\\n        if (k <= i) {\\n            root = root.delete(nums[i-k]);\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search Tree"
                ],
                "code": "```JavaScript\\n/**\\n * @param {number} x\\n */\\nconst BST  = function(x) {\\n    this.val = x;\\n    this.left = null;\\n    this.right = null;\\n}\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nBST.prototype.add = function(x, t) {\\n    if (x < this.val) {\\n        this.left ? this.left.add(x) : this.left = new BST(x);\\n        return this.val - x <= t \\n    } else {\\n        this.right ? this.right.add(x) : this.right = new BST(x);\\n    }\\n}\\n\\n/**\\n * @param {BST} node\\n * @return {BST}\\n */\\nconst predecessor = function(node) {\\n    node = node.left;\\n    while (node.right) {\\n        node = node.right;\\n    }\\n    return node;\\n}\\n\\n/**\\n * @param {BST} node\\n * @return {BST}\\n */\\nconst successor = function(node) {\\n    node = node.right;\\n    while (node.left) {\\n        node = node.left;\\n    }\\n    return node;\\n}\\n\\n/**\\n * @param {number} x\\n * @return {void}\\n */\\nBST.prototype.delete = function(x) {\\n    if (this.val === x) {\\n        if (this.right) {\\n            const next = successor(this);\\n            this.val = next.val;\\n            this.right = this.right.delete(next.val);\\n        } else if (this.left) {\\n            const prev = predecessor(this);\\n            this.val = prev.val;\\n            this.left = this.left.delete(prev.val);\\n        } else {\\n            return null;\\n        }\\n    } else {\\n        this.val < x\\n            ? this.right = this.right.delete(x)\\n            : this.left = this.left.delete(x);\\n    }\\n    return this;\\n}\\n\\n/**\\n * @param {number} a\\n * @param {number} b\\n * @return {boolean}\\n */\\nBST.prototype.between = function(a,b) {\\n    if (a <= this.val && this.val <= b) {\\n        return true;\\n    }\\n    if (this.left && a < this.val && b < this.val) {\\n        return this.left.between(a,b);\\n    }\\n    if (this.right && a > this.val && b > this.val) {\\n        return this.right.between(a,b);\\n    }\\n    return false;\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    let root = null;\\n    for (let i = 0; i < nums.length; i++) {\\n        if (root && root.between(nums[i] - t, nums[i] + t)) {\\n            return true;\\n        }\\n        root ? root.add(nums[i]) : root = new BST(nums[i]);\\n        if (k <= i) {\\n            root = root.delete(nums[i-k]);\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 508393,
                "title": "java-easy-solution-with-explanation",
                "content": "In this question, we can use a TreeSet which offers functinos like floor and ceiling. \\n**floor()** returns the greatest element in this set less than or equal to the given element, or null if there is no such element. \\n**ceiling()** returns the least element in this set greater than or equal to the given element, or null if there is no such element. \\n\\nAt all times, the TreeSet will represent **a  window of k numbers**. When the index goes beyond k, we keep on removing index-k th number form the TreeSet.\\n\\n```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\tif(nums.length == 0) return false;\\n\\tTreeSet<Long> window = new TreeSet<>();\\n\\tfor(int i=0; i<nums.length; i++) {\\n\\t\\tlong num = nums[i];\\n\\t\\tLong floor = window.floor(num+t);\\n\\t\\tLong ceiling = window.ceiling(num-t);\\n\\t\\tif(floor != null && floor >= num) return true;\\n\\t\\tif(ceiling !=null && ceiling <= num) return true;\\n\\t\\twindow.add(num);\\n\\t\\tif(i >= k) window.remove((long)nums[i-k]);\\n\\t}\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\tif(nums.length == 0) return false;\\n\\tTreeSet<Long> window = new TreeSet<>();\\n\\tfor(int i=0; i<nums.length; i++) {\\n\\t\\tlong num = nums[i];\\n\\t\\tLong floor = window.floor(num+t);\\n\\t\\tLong ceiling = window.ceiling(num-t);\\n\\t\\tif(floor != null && floor >= num) return true;\\n\\t\\tif(ceiling !=null && ceiling <= num) return true;\\n\\t\\twindow.add(num);\\n\\t\\tif(i >= k) window.remove((long)nums[i-k]);\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61768,
                "title": "16-ms-accepted-a-unusual-c-solution-even-faster-than-c",
                "content": "I save the nums to a pointer array, then sort the pointer array ascending. At last, I use the most plain algorithm.\\n\\n    bool cmpptr(int *a, int *b){\\n        return *a < *b; \\n    }\\n    class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n          const int N = nums.size();\\n          vector<int*> numptrs(N);\\n          for(int i = 0; i < N; ++i){\\n             numptrs[i] = &nums[i];\\n          }\\n          sort(numptrs.begin(), numptrs.end(), cmpptr);\\n          if(0 == k) return false;\\n          for(int i = 0; i < N; ++i){\\n              for(int j = i + 1; j < N; ++j){\\n                   //nums[i] and nums[j] is at most t\\n                  if((*numptrs[j]) > (*numptrs[i]) + t) \\n                         break;\\n                  //the difference between i and j is at most k\\n                  if(abs(numptrs[j] - numptrs[i]) <= k) return true;\\n              }\\n          }\\n           return false;\\n        }\\n\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n          const int N = nums.size();\\n          vector<int*> numptrs(N);\\n          for(int i = 0; i < N; ++i){\\n             numptrs[i] = &nums[i];\\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2717465,
                "title": "java-3-approaches-brute-to-optimal",
                "content": "### **Please Upvote** :D\\n##### 1. Brute force (47/48 passed - TLE):\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                if (Math.abs((long) (nums[i] - nums[j])) <= valueDiff\\n                        && j - i <= indexDiff) {\\n                    return true;\\n                }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\\n##### 2. A little optimization to brute force (Accepted / Very Slow):\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int i = 0, j = 1;\\n\\n        while(j < nums.length){\\n            int currValueDiff = Math.abs(nums[i] - nums[j]);\\n            int currIndexDiff = Math.abs(i - j);\\n\\n            if (currValueDiff <= valueDiff && currIndexDiff <= indexDiff){\\n                return true;\\n            }\\n\\n            else if(currIndexDiff == indexDiff || j == nums.length - 1){\\n                j = ++i;\\n            }\\n\\n            j++;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\\n##### 3. Optimal Solution:\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        TreeSet<Long> set = new TreeSet<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            Long num = new Long(nums[i]);\\n            Long floor = set.floor(num);\\n            Long ceil = set.ceiling(num);\\n\\n            if (floor != null && Math.abs(floor - num) <= valueDiff) {\\n                return true;\\n            }\\n\\n            if (ceil != null && Math.abs(ceil - num) <= valueDiff) {\\n                return true;\\n            }\\n\\n            set.add(num);\\n\\n            if (set.size() > indexDiff) {\\n                set.remove(1L * nums[i - indexDiff]);\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n * logk), SC: O(k)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int n = nums.length;\\n\\n        for (int i = 0; i < n; i++)\\n            for (int j = i + 1; j < n; j++)\\n                if (Math.abs((long) (nums[i] - nums[j])) <= valueDiff\\n                        && j - i <= indexDiff) {\\n                    return true;\\n                }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int i = 0, j = 1;\\n\\n        while(j < nums.length){\\n            int currValueDiff = Math.abs(nums[i] - nums[j]);\\n            int currIndexDiff = Math.abs(i - j);\\n\\n            if (currValueDiff <= valueDiff && currIndexDiff <= indexDiff){\\n                return true;\\n            }\\n\\n            else if(currIndexDiff == indexDiff || j == nums.length - 1){\\n                j = ++i;\\n            }\\n\\n            j++;\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        TreeSet<Long> set = new TreeSet<>();\\n\\n        for (int i = 0; i < nums.length; i++) {\\n\\n            Long num = new Long(nums[i]);\\n            Long floor = set.floor(num);\\n            Long ceil = set.ceiling(num);\\n\\n            if (floor != null && Math.abs(floor - num) <= valueDiff) {\\n                return true;\\n            }\\n\\n            if (ceil != null && Math.abs(ceil - num) <= valueDiff) {\\n                return true;\\n            }\\n\\n            set.add(num);\\n\\n            if (set.size() > indexDiff) {\\n                set.remove(1L * nums[i - indexDiff]);\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n\\n// TC: O(n * logk), SC: O(k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 212714,
                "title": "neat-python-code-implementing-bucket-using-dict-o-n-time",
                "content": "```\\n\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if k <= 0 or t < 0 or len(nums) < 2:\\n            return False\\n\\n        min_val = min(nums)\\n        if min_val < 0:\\n            nums = [n - min_val for n in nums]\\n            min_val = 0\\n        max_val = max(nums)\\n        bucket_dict = {}\\n        for i, num in enumerate(nums):\\n            idx = int(num/(t+1))\\n            if len(bucket_dict) == k+1:\\n                bucket_dict.pop(int(nums[i-k-1]/(t+1)))\\n            if idx in bucket_dict:\\n                return True\\n            elif idx-1 in bucket_dict and num - bucket_dict[idx-1] <= t:\\n                return True\\n            elif idx+1 in bucket_dict and bucket_dict[idx+1] - num <= t:\\n                return True\\n            else:\\n                bucket_dict[idx] = num\\n        \\n        return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        if k <= 0 or t < 0 or len(nums) < 2:\\n            return False\\n\\n        min_val = min(nums)\\n        if min_val < 0:\\n            nums = [n - min_val for n in nums]\\n            min_val = 0\\n        max_val = max(nums)\\n        bucket_dict = {}\\n        for i, num in enumerate(nums):\\n            idx = int(num/(t+1))\\n            if len(bucket_dict) == k+1:\\n                bucket_dict.pop(int(nums[i-k-1]/(t+1)))\\n            if idx in bucket_dict:\\n                return True\\n            elif idx-1 in bucket_dict and num - bucket_dict[idx-1] <= t:\\n                return True\\n            elif idx+1 in bucket_dict and bucket_dict[idx+1] - num <= t:\\n                return True\\n            else:\\n                bucket_dict[idx] = num\\n        \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1571794,
                "title": "simple-python-solution-77-faster-with-detailed-explanation",
                "content": "class Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        if t < 0:\\n            return False\\n\\n        n = len(nums)\\n        num_arr = []\\n        # create a array of tuple where first index hold the element\\n        # and 2nd Index hold its index\\n        for i in range(n):\\n            temp = (nums[i],i)\\n            num_arr.append(temp)\\n\\n        # sort the array\\n        num_arr = sorted(num_arr)\\n\\n        # loop through array from 0th position\\n        for i in range(n):\\n            # loop array from i+1 postion\\n            for j in range(i+1,n):\\n                # check if difference of two elements is less than t or not\\n                # if not, no need to check further as array is already sorted\\n                # so further element\\'s different will also not meet this criteria\\n                if abs(num_arr[i][0] - num_arr[j][0]) <= t :\\n                    # if above condition met, check if both index\\'s position defference is less than k\\n                    if abs(num_arr[i][1] - num_arr[j][1]) <= k:\\n                        # if yes, return True\\n                        return True\\n                else:\\n                    break\\n        return False",
                "solutionTags": [],
                "code": "class Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        if t < 0:\\n            return False\\n\\n        n = len(nums)\\n        num_arr = []\\n        # create a array of tuple where first index hold the element\\n        # and 2nd Index hold its index\\n        for i in range(n):\\n            temp = (nums[i],i)\\n            num_arr.append(temp)\\n\\n        # sort the array\\n        num_arr = sorted(num_arr)\\n\\n        # loop through array from 0th position\\n        for i in range(n):\\n            # loop array from i+1 postion\\n            for j in range(i+1,n):\\n                # check if difference of two elements is less than t or not\\n                # if not, no need to check further as array is already sorted\\n                # so further element\\'s different will also not meet this criteria\\n                if abs(num_arr[i][0] - num_arr[j][0]) <= t :\\n                    # if above condition met, check if both index\\'s position defference is less than k\\n                    if abs(num_arr[i][1] - num_arr[j][1]) <= k:\\n                        # if yes, return True\\n                        return True\\n                else:\\n                    break\\n        return False",
                "codeTag": "Java"
            },
            {
                "id": 138067,
                "title": "clean-javascript-solution",
                "content": "```js\\nconst containsNearbyAlmostDuplicate = (nums, k, t) => {\\n  const map = nums\\n    .map((val, idx) => ({ val, idx }))\\n    .sort((a, b) => a.val - b.val);\\n\\n  let l = 0;\\n  let r = 1;\\n\\n  while (r < map.length) {\\n    const diff = Math.abs(map[r].val - map[l].val);\\n    const range = Math.abs(map[r].idx - map[l].idx);\\n\\n    if (diff <= t && range <= k) return true;\\n    else if (diff > t) l++;\\n    else if (range > k) r++;\\n\\n    if (l === r) r++;\\n  }\\n\\n  return false;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst containsNearbyAlmostDuplicate = (nums, k, t) => {\\n  const map = nums\\n    .map((val, idx) => ({ val, idx }))\\n    .sort((a, b) => a.val - b.val);\\n\\n  let l = 0;\\n  let r = 1;\\n\\n  while (r < map.length) {\\n    const diff = Math.abs(map[r].val - map[l].val);\\n    const range = Math.abs(map[r].idx - map[l].idx);\\n\\n    if (diff <= t && range <= k) return true;\\n    else if (diff > t) l++;\\n    else if (range > k) r++;\\n\\n    if (l === r) r++;\\n  }\\n\\n  return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61737,
                "title": "20ms-simple-c-code",
                "content": "   \\n\\n    class Solution {\\n        public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            vector< pair<long, int> > vec;\\n            for (int i = 0; i < nums.size(); ++i) {\\n                vec.push_back(make_pair(nums[i], i));\\n            }\\n            sort(vec.begin(), vec.end());\\n            for (int i = 0; i < nums.size(); ++i) {\\n                int j = i + 1;\\n                while(j < nums.size() && vec[j].first-vec[i].first <= t) {\\n                    if (abs(vec[j].second-vec[i].second) <= k) return true;\\n                    j++;\\n                }\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n        public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            vector< pair<long, int> > vec;\\n            for (int i = 0; i < nums.size(); ++i) {\\n                vec.push_back(make_pair(nums[i], i));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 61692,
                "title": "my-o-n-accepted-java-solution-using-hashmap",
                "content": "I didn't use bs.\\n\\nThx lx223 for his corner case. His answer is https://leetcode.com/discuss/38206/ac-solution-in-java-using-o-n-bucket-with-explanation\\n\\nAlready updated for his corner case {-3,3},2,4\\n \\n\\n    public static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        Map<Long, Long> map = new java.util.LinkedHashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            long j = t == 0 ? (long) nums[i] - Integer.MIN_VALUE : (((long) nums[i] - Integer.MIN_VALUE) / t);\\n            if (map.containsKey(j) || (map.containsKey(j - 1) && Math.abs(map.get(j - 1) - nums[i]) <= t)\\n                    || (map.containsKey(j + 1) && Math.abs(map.get(j + 1) - nums[i]) <= t)) return true;\\n            if (map.keySet().size() == k) map.remove(map.keySet().iterator().next());\\n            map.put(j, (long) nums[i]);\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "I didn't use bs.\\n\\nThx lx223 for his corner case. His answer is https://leetcode.com/discuss/38206/ac-solution-in-java-using-o-n-bucket-with-explanation\\n\\nAlready updated for his corner case {-3,3},2,4\\n \\n\\n    public static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        Map<Long, Long> map = new java.util.LinkedHashMap<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            long j = t == 0 ? (long) nums[i] - Integer.MIN_VALUE : (((long) nums[i] - Integer.MIN_VALUE) / t);\\n            if (map.containsKey(j) || (map.containsKey(j - 1) && Math.abs(map.get(j - 1) - nums[i]) <= t)\\n                    || (map.containsKey(j + 1) && Math.abs(map.get(j + 1) - nums[i]) <= t)) return true;\\n            if (map.keySet().size() == k) map.remove(map.keySet().iterator().next());\\n            map.put(j, (long) nums[i]);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61654,
                "title": "java-solution-with-treeset",
                "content": "A TreeSet with size less than k is used here. So the time should be O(n * log(k)). \\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || k < 0 || t < 0)\\n            return false;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i - k - 1 >= 0)\\n                set.remove(nums[i - k - 1]);\\n            int n = nums[i];\\n            if (set.floor(n) != null && n <= t + set.floor(n) || \\n                    set.ceiling(n) != null && set.ceiling(n) <= t + n)\\n                return true;\\n            set.add(n);\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "A TreeSet with size less than k is used here. So the time should be O(n * log(k)). \\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || k < 0 || t < 0)\\n            return false;\\n        TreeSet<Integer> set = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i - k - 1 >= 0)\\n                set.remove(nums[i - k - 1]);\\n            int n = nums[i];\\n            if (set.floor(n) != null && n <= t + set.floor(n) || \\n                    set.ceiling(n) != null && set.ceiling(n) <= t + n)\\n                return true;\\n            set.add(n);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2514560,
                "title": "pair-c-easy",
                "content": "class Solution {\\npublic:\\n\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<long,long>> vec(nums.size());\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            vec[i].first = nums[i];\\n            vec[i].second = i;\\n        }\\n        sort(vec.begin(),vec.end());\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            for(int j = i+1 ; j < nums.size() ; j++)\\n            {\\n                if(abs(vec[i].first + t >= vec[j].first))\\n                {  \\n                    if(abs(vec[i].second - vec[j].second) <= k)\\n                        return true;\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<long,long>> vec(nums.size());\\n        for(int i = 0 ; i < nums.size() ; i++)\\n        {\\n            vec[i].first = nums[i];\\n            vec[i].second = i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 828127,
                "title": "python-js-go-o-n-by-sliding-window-and-bucket-w-comment",
                "content": "Python/Go O(n) by sliding-window and bucket\\n\\n---\\n\\n**Implementation**:\\n\\nPython:\\n\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        if t == 0 and len(set(nums)) == len(nums):\\n            \\n            # Quick response for t = 0\\n            # t = 0 requires at least one pair of repeated element\\n            \\n            return False\\n            \\n        \\n        size = len(nums)\\n        \\n        bucket = {}\\n        \\n        width = t + 1\\n        \\n        for idx, number in enumerate(nums):\\n            \\n            bucket_idx = number // width\\n            \\n            if bucket_idx in bucket:\\n                \\n                # two numbers in the same bucket, gap must be smaller than width\\n                return True\\n            \\n            elif bucket_idx + 1 in bucket and abs(number - bucket[bucket_idx + 1]) < width:\\n                \\n                # two number in two consecutive buckets, and gap is smaller than width\\n                return True\\n            \\n            elif bucket_idx - 1 in bucket and abs(number - bucket[bucket_idx - 1]) < width:\\n                \\n                # two number in two consecutive buckets, and gap is smaller than width\\n                return True\\n            \\n            # put current number into corresponding bucket\\n            bucket[bucket_idx] = number\\n            \\n            \\n            if idx >= k:\\n                \\n                # delete old number whose index distance larger than k\\n                del bucket[ nums[idx-k] //width ]\\n                \\n        return False\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {\\n    \\n    if(  (valueDiff == 0) && ( new Set(nums).size == nums.length ) ) {\\n        \\n        // Quick response for valueDiff = 0\\n        // valueDiff = 9 requires at least one pair ofrepeated element\\n        return false;\\n    }\\n    \\n    // key: element value / width\\n    // value: corresponding element \\n    let bucket = new Map();\\n    \\n    const width = valueDiff + 1;\\n    \\n    for( let idx = 0 ; idx < nums.length ; idx++ ){\\n        \\n        let curNumber = nums[idx];\\n        \\n        let bucketIdx = Math.floor( curNumber / width );\\n        \\n        if( bucket.has(bucketIdx) ){\\n            \\n            // two numbers in the same bucket, gap must be smaller than width\\n            return true;\\n            \\n        }else if( bucket.has(bucketIdx+1) && Math.abs( curNumber - bucket.get(bucketIdx+1) ) < width ){\\n        \\n            // two number in two consecutive buckets, and gap is smaller than width\\n            return true;\\n            \\n        }else if( bucket.has(bucketIdx-1) && Math.abs( curNumber - bucket.get(bucketIdx-1) ) < width ){\\n            \\n            // two number in two consecutive buckets, and gap is smaller than width\\n            return true;\\n        }\\n        \\n        \\n        // put current number into corresponding bucket\\n        bucket.set( bucketIdx,  curNumber );\\n        \\n        if( idx >= indexDiff ){\\n            \\n            let oldNumber = nums[ idx - indexDiff ];\\n            let oldNumberBucketIdx = Math.floor( oldNumber / width);\\n            bucket.delete( oldNumberBucketIdx );\\n        } \\n        \\n    }\\n    \\n   \\n    \\n    return false;\\n};\\n```\\n\\n---\\n\\n```\\n\\nGo:\\n\\nfunc Abs(x int) int {\\n    if x < 0{\\n        return -x\\n    }else{\\n        return x\\n    }\\n}\\n\\nfunc containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {\\n \\n    \\n    //size := len(nums)\\n    \\n    bucket := make( map[int]int)\\n    \\n    width := t+1\\n    \\n    for idx, number := range nums{\\n        \\n        var bucketIdx int\\n        \\n        if number >= 0 {\\n            \\n            bucketIdx = number / width\\n            \\n        }else{\\n            \\n            // offset patch for negative number\\n            bucketIdx = (number / width) - 1\\n        }\\n        \\n        if _, exist := bucket[bucketIdx]; exist{\\n            \\n            // two numbers in the smae bucket, gap must be smaller than width\\n            return true\\n            \\n        }else if _, exist := bucket[bucketIdx+1]; exist && ( Abs( number - bucket[bucketIdx+1] ) < width ) {\\n            \\n            // two number in two consecotive buckets, and gap is smaller than width\\n            return true\\n            \\n        }else if _, exist := bucket[bucketIdx-1]; exist && ( Abs(number - bucket[bucketIdx-1] ) < width ) {\\n        \\n            // two number in two consecotive buckets, and gap is smaller than width\\n            return true\\n        }\\n        \\n        \\n        // put current number into corresponding bucket\\n        bucket[bucketIdx] = number\\n        \\n        if idx >= k{\\n            delete(bucket, (nums[idx - k] / width) )\\n        }\\n        \\n    }\\n    \\n    return false\\n}\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #217 Contains Duplicate](https://leetcode.com/problems/contains-duplicate/)\\n\\n[Leetcode #219 Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii)\\n\\n[Leetcode #220 Contains Duplicate III](https://leetcode.com/problems/contains-duplicate-iii)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "JavaScript",
                    "Go",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        if t == 0 and len(set(nums)) == len(nums):\\n            \\n            # Quick response for t = 0\\n            # t = 0 requires at least one pair of repeated element\\n            \\n            return False\\n            \\n        \\n        size = len(nums)\\n        \\n        bucket = {}\\n        \\n        width = t + 1\\n        \\n        for idx, number in enumerate(nums):\\n            \\n            bucket_idx = number // width\\n            \\n            if bucket_idx in bucket:\\n                \\n                # two numbers in the same bucket, gap must be smaller than width\\n                return True\\n            \\n            elif bucket_idx + 1 in bucket and abs(number - bucket[bucket_idx + 1]) < width:\\n                \\n                # two number in two consecutive buckets, and gap is smaller than width\\n                return True\\n            \\n            elif bucket_idx - 1 in bucket and abs(number - bucket[bucket_idx - 1]) < width:\\n                \\n                # two number in two consecutive buckets, and gap is smaller than width\\n                return True\\n            \\n            # put current number into corresponding bucket\\n            bucket[bucket_idx] = number\\n            \\n            \\n            if idx >= k:\\n                \\n                # delete old number whose index distance larger than k\\n                del bucket[ nums[idx-k] //width ]\\n                \\n        return False\\n```\n```\\nvar containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {\\n    \\n    if(  (valueDiff == 0) && ( new Set(nums).size == nums.length ) ) {\\n        \\n        // Quick response for valueDiff = 0\\n        // valueDiff = 9 requires at least one pair ofrepeated element\\n        return false;\\n    }\\n    \\n    // key: element value / width\\n    // value: corresponding element \\n    let bucket = new Map();\\n    \\n    const width = valueDiff + 1;\\n    \\n    for( let idx = 0 ; idx < nums.length ; idx++ ){\\n        \\n        let curNumber = nums[idx];\\n        \\n        let bucketIdx = Math.floor( curNumber / width );\\n        \\n        if( bucket.has(bucketIdx) ){\\n            \\n            // two numbers in the same bucket, gap must be smaller than width\\n            return true;\\n            \\n        }else if( bucket.has(bucketIdx+1) && Math.abs( curNumber - bucket.get(bucketIdx+1) ) < width ){\\n        \\n            // two number in two consecutive buckets, and gap is smaller than width\\n            return true;\\n            \\n        }else if( bucket.has(bucketIdx-1) && Math.abs( curNumber - bucket.get(bucketIdx-1) ) < width ){\\n            \\n            // two number in two consecutive buckets, and gap is smaller than width\\n            return true;\\n        }\\n        \\n        \\n        // put current number into corresponding bucket\\n        bucket.set( bucketIdx,  curNumber );\\n        \\n        if( idx >= indexDiff ){\\n            \\n            let oldNumber = nums[ idx - indexDiff ];\\n            let oldNumberBucketIdx = Math.floor( oldNumber / width);\\n            bucket.delete( oldNumberBucketIdx );\\n        } \\n        \\n    }\\n    \\n   \\n    \\n    return false;\\n};\\n```\n```\\n\\nGo:\\n\\nfunc Abs(x int) int {\\n    if x < 0{\\n        return -x\\n    }else{\\n        return x\\n    }\\n}\\n\\nfunc containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {\\n \\n    \\n    //size := len(nums)\\n    \\n    bucket := make( map[int]int)\\n    \\n    width := t+1\\n    \\n    for idx, number := range nums{\\n        \\n        var bucketIdx int\\n        \\n        if number >= 0 {\\n            \\n            bucketIdx = number / width\\n            \\n        }else{\\n            \\n            // offset patch for negative number\\n            bucketIdx = (number / width) - 1\\n        }\\n        \\n        if _, exist := bucket[bucketIdx]; exist{\\n            \\n            // two numbers in the smae bucket, gap must be smaller than width\\n            return true\\n            \\n        }else if _, exist := bucket[bucketIdx+1]; exist && ( Abs( number - bucket[bucketIdx+1] ) < width ) {\\n            \\n            // two number in two consecotive buckets, and gap is smaller than width\\n            return true\\n            \\n        }else if _, exist := bucket[bucketIdx-1]; exist && ( Abs(number - bucket[bucketIdx-1] ) < width ) {\\n        \\n            // two number in two consecotive buckets, and gap is smaller than width\\n            return true\\n        }\\n        \\n        \\n        // put current number into corresponding bucket\\n        bucket[bucketIdx] = number\\n        \\n        if idx >= k{\\n            delete(bucket, (nums[idx - k] / width) )\\n        }\\n        \\n    }\\n    \\n    return false\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825273,
                "title": "c-multiset-solution-with-detailed-explanation",
                "content": "```\\n// we can maintain a sliding window of K elements after ith element to satisfy the index condition(k)\\n// the idea is to maintain a BST of K elements, so that search, insert and delete can be done in O(log(k))\\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n    if (k == 0) return false;\\n\\n    multiset<long> kelements;\\n    int kend = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        long currentNum = nums[i];\\n        // remove ith element from the window\\n        auto curItr = kelements.find(currentNum);\\n        if (curItr != kelements.end()) kelements.erase(curItr);\\n\\n        // this inserts K elements when i = 0 and only 1 element for each subsequent iteration\\n        while (kelements.size() < k && kend < nums.size()) {\\n            kelements.insert(nums[kend]);\\n            kend++;\\n        }\\n\\n        // we need to find a number that is between currentNum - t and currentNum + t\\n        // so the smallest numer greater than or equal to currentNum - t should be our candidate\\n        // an alternate way is to find the largest number less than or equal to currentNum + t\\n        auto closest = kelements.lower_bound(currentNum - t);\\n\\n        // it is possible that no such number exists\\n        if (closest == kelements.end()) continue;\\n\\n        // check for the condition on the potential candidate\\n        if (abs(currentNum - *closest) <= t) return true;\\n    }\\n\\n    return false;\\n}\\n```\\n\\nTime Complexity: ``` O(nlog(k))```\\nSpace Complexity: ```O(k)```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Sliding Window"
                ],
                "code": "```\\n// we can maintain a sliding window of K elements after ith element to satisfy the index condition(k)\\n// the idea is to maintain a BST of K elements, so that search, insert and delete can be done in O(log(k))\\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n    if (k == 0) return false;\\n\\n    multiset<long> kelements;\\n    int kend = 1;\\n    for (int i = 0; i < nums.size(); i++) {\\n        long currentNum = nums[i];\\n        // remove ith element from the window\\n        auto curItr = kelements.find(currentNum);\\n        if (curItr != kelements.end()) kelements.erase(curItr);\\n\\n        // this inserts K elements when i = 0 and only 1 element for each subsequent iteration\\n        while (kelements.size() < k && kend < nums.size()) {\\n            kelements.insert(nums[kend]);\\n            kend++;\\n        }\\n\\n        // we need to find a number that is between currentNum - t and currentNum + t\\n        // so the smallest numer greater than or equal to currentNum - t should be our candidate\\n        // an alternate way is to find the largest number less than or equal to currentNum + t\\n        auto closest = kelements.lower_bound(currentNum - t);\\n\\n        // it is possible that no such number exists\\n        if (closest == kelements.end()) continue;\\n\\n        // check for the condition on the potential candidate\\n        if (abs(currentNum - *closest) <= t) return true;\\n    }\\n\\n    return false;\\n}\\n```\n``` O(nlog(k))```\n```O(k)```",
                "codeTag": "Unknown"
            },
            {
                "id": 824538,
                "title": "java-treeset-easy-to-understand-o-n-log-k",
                "content": "Coming up with this solution, think of it like a number line.\\nIf you want the difference of x and y to be 0 then you want x = y (on top of each other).\\nAs you raise the allowed difference, think of the allowed range increasing in both positive and negative direction equally.\\nE.g. allowed distance is \\'k\\' then x can be in range [y - k, y +k] and y can be in range [x - k, x +k].\\n\\nAnd TreeSet is perfect for testing range.contains.\\n\\nYou could read about https://en.wikipedia.org/wiki/Interval_(mathematics).\\n\\n```\\n  public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    if (t < 0) {\\n      return false;\\n    }\\n\\n    // sliding window\\n\\t// Need ugly Long to handle int overflows.\\n    TreeSet<Long> set = new TreeSet<>();\\n\\n    for (int i = 0; i < nums.length; i++) {\\n      // abs difference\\n      // |nums[i] - nums[j]| <= t\\n\\n      // if nums[j] <= nums[i] then:\\n      // nums[i] - t <= nums[j]\\n\\n      // if nums[j] >= nums[i] then:\\n      // nums[j] <= t + nums[i]\\n\\n      // which is:\\n      // nums[i] - t <= nums[j] <= t + nums[i]\\n\\n      // basically, is there anything in the range [num - t, num + t]?\\n\\n      if (!set.subSet((long) nums[i] - t, true, (long) nums[i] + t, true).isEmpty()) {\\n        return true;\\n      }\\n\\n      set.add((long) nums[i]);\\n      if (set.size() > k) {\\n        set.remove((long) nums[i - k]);\\n      }\\n    }\\n    return false;\\n  }\\n  ```",
                "solutionTags": [],
                "code": "```\\n  public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    if (t < 0) {\\n      return false;\\n    }\\n\\n    // sliding window\\n\\t// Need ugly Long to handle int overflows.\\n    TreeSet<Long> set = new TreeSet<>();\\n\\n    for (int i = 0; i < nums.length; i++) {\\n      // abs difference\\n      // |nums[i] - nums[j]| <= t\\n\\n      // if nums[j] <= nums[i] then:\\n      // nums[i] - t <= nums[j]\\n\\n      // if nums[j] >= nums[i] then:\\n      // nums[j] <= t + nums[i]\\n\\n      // which is:\\n      // nums[i] - t <= nums[j] <= t + nums[i]\\n\\n      // basically, is there anything in the range [num - t, num + t]?\\n\\n      if (!set.subSet((long) nums[i] - t, true, (long) nums[i] + t, true).isEmpty()) {\\n        return true;\\n      }\\n\\n      set.add((long) nums[i]);\\n      if (set.size() > k) {\\n        set.remove((long) nums[i - k]);\\n      }\\n    }\\n    return false;\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 715483,
                "title": "java-brute-force-optimal-explained",
                "content": "```\\nclass Solution {\\n    \\n    /*\\n    BRUTE FORCE APPROACH-----------------------------------------------------------------------------\\n\\n    The brute force approach is to account for the requirement: |i - j| <= k\\n    We can do this by iterating over every index as i, then calculate the MAX value\\n    of j such that the requirement is met.\\n    j <= k + i hence maxJ <= k + i.\\n    \\n    Now we know that for index i, we can use elements from i+1 up to maxJ to represent index j\\n    Given indices for j, we can now evalutate the second requirement for |nums[i] - nums[j]| <= t\\n    If that requirement is also true, we can return true.\\n    \\n    In the worst case, k == nums.length. So every index i can be paired with any other index j.\\n    So we would evalute each pair of i & j for both requirements.\\n    \\n    Time: O(N^2) | Space: O(1)\\n    \\n    OPTIMAL APPROACH-----------------------------------------------------------------------------\\n    \\n    Can we improve the time and space? Well yes we can. What if we evaluate the requirements\\n    differently? Let\\'s handle the |nums[i] - nums[j]| <= t first. To handle this requirement\\n    we can take some nums[i] and ask, \\n        \"Which values in the array are closest to nums[i]?\"\\n    \\n    This is a good question because the difference between 2 close elements will have the\\n    smallest difference! If the min possible difference does not satisfy the requirement then\\n    then no other values will satisfy it for the current nums[i], and we should move on\\n    to the next nums[i]. But finding the closest element can take N time for each nums[i] evaluated\\n    and this does not improve our time ;( so lets use some space!\\n    \\n    Which data structure can store values, and lookup the nearest values to any nums[i] we give?\\n    Well we would have to sort these values, so one data structure that sorts elements and has\\n    a good lookup time is a TreeSet! The TreeSet can get the successor of a value with .ceiling(nums[i])\\n    and the predecessor of a value with .floor(nums[i]) and a single lookup is log(N) time.\\n    \\n    But how do we handle the first requirement where |i-j| <= k ???\\n    This requirement sets a window of elements we can examine for our floor annd ceiling, so\\n    we can make sure that our TreeSet holds at most K elements! Simply remove nums[i-k]\\n\\tfrom the set when the size exceeds k.\\n\\n\\tTime: O(N*log(K)) | Space: O(K) but K can be equal to N so...\\n    Time: O(N*log(N)) | Space: O(N)\\n\\n    */\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Integer> sortedWindow = new TreeSet<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            Integer numJ = sortedWindow.ceiling(nums[i]); //get successor\\n            if (numJ != null && Math.abs((long)nums[i] - (long)numJ) <= t)\\n                return true;\\n            \\n            numJ = sortedWindow.floor(nums[i]); //get predecessor\\n            if (numJ != null && Math.abs((long)nums[i] - (long)numJ) <= t)\\n                return true;\\n            \\n            sortedWindow.add(nums[i]); //add value to set\\n            \\n            if (sortedWindow.size() > k) //keep window at most length k from index i\\n                sortedWindow.remove(nums[i-k]);\\n        }\\n        \\n        return false;\\n    }\\n    \\n    public static boolean bruteForce(int[] nums, int k, int t) {\\n        for (int i = 0; i < nums.length; i++) {\\n            int maxJ = Math.min(k + i, nums.length - 1);\\n            for (int j = i + 1; j <= maxJ; j++) {\\n                long diff = Math.abs((long) nums[i] - (long) nums[j]);\\n                if (diff <= t) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    /*\\n    BRUTE FORCE APPROACH-----------------------------------------------------------------------------\\n\\n    The brute force approach is to account for the requirement: |i - j| <= k\\n    We can do this by iterating over every index as i, then calculate the MAX value\\n    of j such that the requirement is met.\\n    j <= k + i hence maxJ <= k + i.\\n    \\n    Now we know that for index i, we can use elements from i+1 up to maxJ to represent index j\\n    Given indices for j, we can now evalutate the second requirement for |nums[i] - nums[j]| <= t\\n    If that requirement is also true, we can return true.\\n    \\n    In the worst case, k == nums.length. So every index i can be paired with any other index j.\\n    So we would evalute each pair of i & j for both requirements.\\n    \\n    Time: O(N^2) | Space: O(1)\\n    \\n    OPTIMAL APPROACH-----------------------------------------------------------------------------\\n    \\n    Can we improve the time and space? Well yes we can. What if we evaluate the requirements\\n    differently? Let\\'s handle the |nums[i] - nums[j]| <= t first. To handle this requirement\\n    we can take some nums[i] and ask, \\n        \"Which values in the array are closest to nums[i]?\"\\n    \\n    This is a good question because the difference between 2 close elements will have the\\n    smallest difference! If the min possible difference does not satisfy the requirement then\\n    then no other values will satisfy it for the current nums[i], and we should move on\\n    to the next nums[i]. But finding the closest element can take N time for each nums[i] evaluated\\n    and this does not improve our time ;( so lets use some space!\\n    \\n    Which data structure can store values, and lookup the nearest values to any nums[i] we give?\\n    Well we would have to sort these values, so one data structure that sorts elements and has\\n    a good lookup time is a TreeSet! The TreeSet can get the successor of a value with .ceiling(nums[i])\\n    and the predecessor of a value with .floor(nums[i]) and a single lookup is log(N) time.\\n    \\n    But how do we handle the first requirement where |i-j| <= k ???\\n    This requirement sets a window of elements we can examine for our floor annd ceiling, so\\n    we can make sure that our TreeSet holds at most K elements! Simply remove nums[i-k]\\n\\tfrom the set when the size exceeds k.\\n\\n\\tTime: O(N*log(K)) | Space: O(K) but K can be equal to N so...\\n    Time: O(N*log(N)) | Space: O(N)\\n\\n    */\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Integer> sortedWindow = new TreeSet<>();\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            \\n            Integer numJ = sortedWindow.ceiling(nums[i]); //get successor\\n            if (numJ != null && Math.abs((long)nums[i] - (long)numJ) <= t)\\n                return true;\\n            \\n            numJ = sortedWindow.floor(nums[i]); //get predecessor\\n            if (numJ != null && Math.abs((long)nums[i] - (long)numJ) <= t)\\n                return true;\\n            \\n            sortedWindow.add(nums[i]); //add value to set\\n            \\n            if (sortedWindow.size() > k) //keep window at most length k from index i\\n                sortedWindow.remove(nums[i-k]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 367234,
                "title": "python-o-n-solution-using-sliding-window-and-dict",
                "content": "We need to find `i`, `j` such that `|i-j|<=k` and `|nums[i]-nums[j]|<=t`, we use sliding window to mainteniance the nums before nums[i] when we use for iteration.\\n\\nWe can see that `|nums[i]-nums[j]|<=t` is equalivalent `|nums[i]/t-nums[j]/t|<=1`, which we can obtain `|floor(nums[i]/t)-floor(nums[j]/t)|<=1` and we call it (1). We can easily see if (1) doesn\\'t hold, then `|nums[i]-nums[j]>t|`, thus we only need to consider j satisfies (1).\\n\\nWe use dict to solve this, the key is `floor(nums[i]/t)` and the value is `nums[i]`.\\n\\n\\n```python\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if not nums or k < 1 or t < 0:\\n            return False\\n        \\n        n = len(nums)\\n        l = 0\\n        d = {nums[0] // max(1, t): nums[0]}\\n        for r in range(1, n):\\n            if r - l == k + 1:\\n                d.pop(nums[l] // max(1, t))\\n                l += 1\\n            tmp = nums[r] // max(1, t)\\n            for key in {tmp-1, tmp, tmp+1}:\\n                if key in d and abs(d.get(key) - nums[r]) <= t:\\n                    return True\\n            d[tmp] = nums[r]\\n            \\n        return False\\n```\\n\\nThere are some other solutions in my Notion HomePage:\\nhttps://www.notion.so/quicy/Contains-Duplicate-III-db8e5402b20d481cb29daaf1cd7f6e59\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if not nums or k < 1 or t < 0:\\n            return False\\n        \\n        n = len(nums)\\n        l = 0\\n        d = {nums[0] // max(1, t): nums[0]}\\n        for r in range(1, n):\\n            if r - l == k + 1:\\n                d.pop(nums[l] // max(1, t))\\n                l += 1\\n            tmp = nums[r] // max(1, t)\\n            for key in {tmp-1, tmp, tmp+1}:\\n                if key in d and abs(d.get(key) - nums[r]) <= t:\\n                    return True\\n            d[tmp] = nums[r]\\n            \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61650,
                "title": "c-bst-o-nlogk-84-64",
                "content": "Or just use `std::set`, implementing BST in C++ is a pain in ass.\\n\\n```\\n/**\\n * class TreeNode {\\n * public:\\n *     int val;\\n *     TreeNode* left;\\n *     TreeNode* right;\\n * \\n *     TreeNode(int val) {\\n *         this->val = val;\\n *         this->left = nullptr;\\n *         this->right = nullptr;\\n *     }\\n * };\\n */\\nclass BST {\\npublic:\\n    TreeNode* root;\\n    \\n    BST() {\\n        root = nullptr;\\n    }\\n    \\n    TreeNode* insert(int val) {\\n        root = insert(root, val);\\n        return root;\\n    }\\n    \\n    TreeNode* insert(TreeNode* now, int val) {\\n        if (!now) now = new TreeNode(val);\\n        else if (val > now->val) now->right = insert(now->right, val);\\n        else if (val < now->val) now->left = insert(now->left, val);\\n        return now;\\n    }\\n    \\n    TreeNode* remove(int val) {\\n        root = remove(root, val);\\n        return root;\\n    }\\n    \\n    TreeNode* remove(TreeNode* now, int val) {\\n        if (!now) {\\n            return nullptr;\\n        } else if (val < now->val) {\\n            now->left = remove(now->left, val);\\n        } else if (val > now->val) {\\n            now->right = remove(now->right, val);\\n        } else {\\n            if (!now->left) {\\n                TreeNode *tmp = now->right;\\n                delete now;\\n                return tmp;\\n            } else if (!now->right) {\\n                TreeNode *tmp = now->left;\\n                delete now;\\n                return tmp;\\n            } else {\\n                TreeNode *tmp = now->right;\\n                while (tmp->left) tmp = tmp->left;\\n                now->val = tmp->val;\\n                now->right = remove(now->right, now->val);\\n            }\\n        }\\n        return now;\\n    }\\n    \\n    bool search(int val, int t) {\\n        return search(root, val, t);\\n    }\\n    \\n    bool search(TreeNode* now, long val, int t) {\\n        if (!now) return false;\\n        else if (abs(val - now->val) <= t) return true;\\n        else if (now->val - t > val) return search(now->left, val, t);\\n        else return search(now->right, val, t);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        if (nums.empty() || k == 0) return false;\\n        BST bst;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            bst.insert(nums[i - 1]);\\n            if (i > k) bst.remove(nums[i - k - 1]);\\n            if (bst.search(long(nums[i]), t)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * class TreeNode {\\n * public:\\n *     int val;\\n *     TreeNode* left;\\n *     TreeNode* right;\\n * \\n *     TreeNode(int val) {\\n *         this->val = val;\\n *         this->left = nullptr;\\n *         this->right = nullptr;\\n *     }\\n * };\\n */\\nclass BST {\\npublic:\\n    TreeNode* root;\\n    \\n    BST() {\\n        root = nullptr;\\n    }\\n    \\n    TreeNode* insert(int val) {\\n        root = insert(root, val);\\n        return root;\\n    }\\n    \\n    TreeNode* insert(TreeNode* now, int val) {\\n        if (!now) now = new TreeNode(val);\\n        else if (val > now->val) now->right = insert(now->right, val);\\n        else if (val < now->val) now->left = insert(now->left, val);\\n        return now;\\n    }\\n    \\n    TreeNode* remove(int val) {\\n        root = remove(root, val);\\n        return root;\\n    }\\n    \\n    TreeNode* remove(TreeNode* now, int val) {\\n        if (!now) {\\n            return nullptr;\\n        } else if (val < now->val) {\\n            now->left = remove(now->left, val);\\n        } else if (val > now->val) {\\n            now->right = remove(now->right, val);\\n        } else {\\n            if (!now->left) {\\n                TreeNode *tmp = now->right;\\n                delete now;\\n                return tmp;\\n            } else if (!now->right) {\\n                TreeNode *tmp = now->left;\\n                delete now;\\n                return tmp;\\n            } else {\\n                TreeNode *tmp = now->right;\\n                while (tmp->left) tmp = tmp->left;\\n                now->val = tmp->val;\\n                now->right = remove(now->right, now->val);\\n            }\\n        }\\n        return now;\\n    }\\n    \\n    bool search(int val, int t) {\\n        return search(root, val, t);\\n    }\\n    \\n    bool search(TreeNode* now, long val, int t) {\\n        if (!now) return false;\\n        else if (abs(val - now->val) <= t) return true;\\n        else if (now->val - t > val) return search(now->left, val, t);\\n        else return search(now->right, val, t);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        if (nums.empty() || k == 0) return false;\\n        BST bst;\\n        for (int i = 1; i < nums.size(); ++i) {\\n            bst.insert(nums[i - 1]);\\n            if (i > k) bst.remove(nums[i - k - 1]);\\n            if (bst.search(long(nums[i]), t)) return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61783,
                "title": "a-c-o-nlogk-solution-by-using-sortedset",
                "content": "EDIT: Fix it by using SortedSet.GetViewBetween\\n\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if(t < 0) return false;\\n        SortedSet<long> ss = new SortedSet<long>();\\n        for(int i = 0; i < nums.Length; i++){\\n            if(ss.GetViewBetween((long)nums[i] - t, (long)nums[i] + t).Count > 0) return true;\\n            ss.Add(nums[i]);\\n            if(i >= k) ss.Remove(nums[i - k]);\\n        }\\n        return false;\\n    }\\n\\nBelow is the old version of O(Log(N*K))\\n\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        SortedList<int, int> sdc = new SortedList<int, int>();\\n        for (int i = 0; i < nums.Length && k != 0; i++){\\n            for (int j = 0, l = sdc.Count - 1; j <= l;)\\n                if ((long)nums[i] - (long)sdc.Keys[(j + l) / 2]  > (long)t)\\n                    l = (j + l) / 2 - 1;\\n                else if ((long)nums[i] - (long)sdc.Keys[(j + l) / 2] < -(long)t)\\n                    j = (j + l) / 2 + 1;\\n                else return true;\\n            if (sdc.Count == k)\\n               sdc.RemoveAt(sdc.IndexOfValue(i - k));\\n            sdc.Add(nums[i], i);\\n        }\\n        return false;\\n    }",
                "solutionTags": [],
                "code": "EDIT: Fix it by using SortedSet.GetViewBetween\\n\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if(t < 0) return false;\\n        SortedSet<long> ss = new SortedSet<long>();\\n        for(int i = 0; i < nums.Length; i++){\\n            if(ss.GetViewBetween((long)nums[i] - t, (long)nums[i] + t).Count > 0) return true;\\n            ss.Add(nums[i]);\\n            if(i >= k) ss.Remove(nums[i - k]);\\n        }\\n        return false;\\n    }\\n\\nBelow is the old version of O(Log(N*K))\\n\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        SortedList<int, int> sdc = new SortedList<int, int>();\\n        for (int i = 0; i < nums.Length && k != 0; i++){\\n            for (int j = 0, l = sdc.Count - 1; j <= l;)\\n                if ((long)nums[i] - (long)sdc.Keys[(j + l) / 2]  > (long)t)\\n                    l = (j + l) / 2 - 1;\\n                else if ((long)nums[i] - (long)sdc.Keys[(j + l) / 2] < -(long)t)\\n                    j = (j + l) / 2 + 1;\\n                else return true;\\n            if (sdc.Count == k)\\n               sdc.RemoveAt(sdc.IndexOfValue(i - k));\\n            sdc.Add(nums[i], i);\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1838689,
                "title": "o-nlogn-sliding-window-multiset-binary-search-based-solution",
                "content": "```\\n#define ll long long\\n#define push insert\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n       \\n        multiset<ll>st;\\n        for(ll i=0;i<nums.size();i++)\\n       {\\n            if(!st.size())\\n                st.push(nums[i]);\\n            \\n            else\\n            {\\n                if(st.size()>k)\\n                {\\n                     st.erase(nums[i-k-1]);\\n                }\\n                 \\n                \\n                if(st.size())\\n                {\\n                    auto x=st.lower_bound((ll)nums[i]-t);\\n               if(x!=st.end()&&*x<=(ll)nums[i]+t)\\n               {\\n                    return 1;\\n               }\\n                   \\n                if(abs(nums[i]-*st.begin())<=t)\\n                {\\n                     return 1;\\n                }\\n\\n                }\\n                st.push(nums[i]);\\n            }\\n        }\\n        return 0;\\n    }\\n  \\n};\\n```\\n![image](https://assets.leetcode.com/users/images/b367c6c4-6008-479e-a820-9a512c23e323_1646977841.2182415.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n#define ll long long\\n#define push insert\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n       \\n        multiset<ll>st;\\n        for(ll i=0;i<nums.size();i++)\\n       {\\n            if(!st.size())\\n                st.push(nums[i]);\\n            \\n            else\\n            {\\n                if(st.size()>k)\\n                {\\n                     st.erase(nums[i-k-1]);\\n                }\\n                 \\n                \\n                if(st.size())\\n                {\\n                    auto x=st.lower_bound((ll)nums[i]-t);\\n               if(x!=st.end()&&*x<=(ll)nums[i]+t)\\n               {\\n                    return 1;\\n               }\\n                   \\n                if(abs(nums[i]-*st.begin())<=t)\\n                {\\n                     return 1;\\n                }\\n\\n                }\\n                st.push(nums[i]);\\n            }\\n        }\\n        return 0;\\n    }\\n  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848915,
                "title": "javascript-bucket-sort-o-n",
                "content": "```\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    let bucket = {}, w = t+1;\\n    for (let i =0;i<nums.length;i++) {\\n        idx = Math.floor(nums[i]/w);\\n        if (bucket.hasOwnProperty(idx)) return true;\\n        else if (bucket.hasOwnProperty(idx+1) && Math.abs(nums[i] - bucket[idx+1]) < w) return true;\\n        else if (bucket.hasOwnProperty(idx-1) && Math.abs(nums[i] - bucket[idx-1]) < w) return true;\\n        bucket[idx] = nums[i];\\n        if (i >= k) {\\n            delete bucket[Math.floor(nums[i-k]/w)];\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Bucket Sort"
                ],
                "code": "```\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    let bucket = {}, w = t+1;\\n    for (let i =0;i<nums.length;i++) {\\n        idx = Math.floor(nums[i]/w);\\n        if (bucket.hasOwnProperty(idx)) return true;\\n        else if (bucket.hasOwnProperty(idx+1) && Math.abs(nums[i] - bucket[idx+1]) < w) return true;\\n        else if (bucket.hasOwnProperty(idx-1) && Math.abs(nums[i] - bucket[idx-1]) < w) return true;\\n        bucket[idx] = nums[i];\\n        if (i >= k) {\\n            delete bucket[Math.floor(nums[i-k]/w)];\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 825714,
                "title": "a-few-solutions",
                "content": "**Synopsis:**\\n\\nUse a sliding window of size `K`.  Return true immediately if two values within the window differ by less-than `T`.  To reduce the asymptotic bound for finding candidates within the window who\\'s values may differ by less-than `T`, use buckets who\\'s key is the value divided by `T`.  We divide into buckets of size `T` because only values in adjacent buckets are candidates who\\'s values may differ by less-than `T`, ie. if two candidates are two or more `T` bucket away from eachother, then their difference cannot be less-than `T` due to the fact that their values differ by greater-than `T` by definition of each bucket size `T`.  Candidates in the same bucket differ by less-than `T` due to the fact that each bucket covers a range of `T` values.\\n\\nLet `N` denote the cardinality of `A`, then we have `N / T` buckets, each covering a range of size `T` values.  Let `j` denote an arbitrary bucket.  Map each `i`<sup>th</sup> value in `A` to a `j`<sup>th</sup> bucket, and there are 3 use cases to consider for each `j`<sup>th</sup> bucket:\\n\\n* **Case 1:** there exists a value in the `\\uD83D\\uDC48 ` adjacent bucket to-the-left who\\'s difference with `A[i]` is less-than `T`\\n* **Case 2:** there already exists a value in the `\\uD83C\\uDFAF` same `j`<sup>th</sup> bucket\\n* **Case 3:** there exists a value in the `\\uD83D\\uDC49` adjacent bucket to-the-right who\\'s difference with `A[i]` is less-than `T`\\n\\nAnd we return true for any of those 3 use cases.  Otherwise return false.\\n\\n**Notes:**\\n* When `T == 0`, the bucket key would be equal to infinity, thus we add 1 for this use case to avoid division by 0.\\n* For the use case in which the same bucket is added onto the sliding window and simultaneously removed from the sliding window, it is important to add the value onto the window *before* removing the value from the window because the `i - K`<sup>th</sup> value which \"fell off the end\" of the window of size `K` is non-inclusive of the window of size `K`, ie. the window has \"slid\" to-the-right `\\uD83D\\uDC49` by one position to occupy `[i - K + 1 .. i]`, and `i`<sup>th</sup> value is added onto the window *before* the `i - K`<sup>th</sup> value is removed from the window.\\n* We only need to store one value per bucket, because we will return true immediately if there exists two values mapped to the same bucket.  Let `m[j] = A[i]` denote the the `i`<sup>th</sup> value of `A` is mapped to the `j`<sup>th</sup> bucket.\\n* A data type larger than a 32-bit integer is needed to store the result of the absolute differences of the 32-bit integer values in `A`, since C++ is the only statically typed language below, I explicitly chose to use a `long long` to store the map\\'s value, whereas the data type is implicit for Javascript and Python3.\\n\\n---\\n\\n**Similiar Problems:**\\n\\n* [217. Contains Duplicate](https://leetcode.com/problems/contains-duplicate/discuss/824996/Javascript-Python3-C%2B%2B-1-Liners-Seen-Set)\\n* [219. Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/discuss/825078/javascript-python3-c-sliding-window-seen-set)\\n\\n---\\n\\n*Javascript*\\n```\\nlet containsNearbyAlmostDuplicate = (A, K, T, m = {}, abs = Math.abs) => {\\n    let N = A.length;\\n    if (N < 2)\\n        return false;\\n    let bucket = x => T ? Math.floor(x / T) : Math.floor(x / (T + 1));  // \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n    let ok = (i, j) => m[j] != undefined && abs(m[j] - A[i]) <= T;\\n    for (let i = 0; i < N; ++i) {\\n\\t\\t// 1. check each j-th bucket for case 1 || case 2 || case 3\\n        let j = bucket(A[i]);\\n        if (ok(i, j - 1) || ok(i, j) || ok(i, j + 1))  // (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n            return true;\\n        // 2. slide window \\uD83D\\uDC49\\n        m[j] = A[i];                     // \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n        if (0 <= i - K) {\\n            let end = bucket(A[i - K]);  // \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n            delete m[end];\\n        }  \\n    }\\n    return false;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, A: List[int], K: int, T: int) -> bool:\\n        m = {}\\n        N = len(A)\\n        if N < 2:\\n            return False\\n        bucket = lambda x: x // T if T else x // (T + 1)  # \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n        ok = lambda i, j: j in m and abs(m[j] - A[i]) <= T\\n        for i in range(N):\\n\\t\\t\\t#  1. check each j-th bucket for case 1 || case 2 || case 3\\n            j = bucket(A[i])\\n            if ok(i, j - 1) or ok(i, j) or ok(i, j + 1):  # (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n                return True\\n            # slide window \\uD83D\\uDC49\\n            m[j] = A[i]                 # \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n            if 0 <= i - K:\\n                end = bucket(A[i - K])  # \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n                del m[end]\\n        return False\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, long long>;\\n    bool containsNearbyAlmostDuplicate(VI& A, int K, int T, Map m = {}) {\\n        int N = A.size();\\n        if (N < 2)\\n            return false;\\n        auto bucket = [=](auto x) { return T ? x / T : x / (T + 1); };  // \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n        auto ok = [&](auto i, auto j) { return m.find(j) != m.end() && abs(m[j] - A[i]) <= T; };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            // 1. check each j-th bucket for case 1 || case 2 || case 3\\n            auto j = bucket(A[i]);\\n            if (ok(i, j - 1) || ok(i, j) || ok(i, j + 1))  // (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n                return true;\\n            // 2. slide window \\uD83D\\uDC49\\n            m[j] = A[i];                      // \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n            if (0 <= i - K) {\\n                auto end = bucket(A[i - K]);  // \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n                m.erase(end);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet containsNearbyAlmostDuplicate = (A, K, T, m = {}, abs = Math.abs) => {\\n    let N = A.length;\\n    if (N < 2)\\n        return false;\\n    let bucket = x => T ? Math.floor(x / T) : Math.floor(x / (T + 1));  // \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n    let ok = (i, j) => m[j] != undefined && abs(m[j] - A[i]) <= T;\\n    for (let i = 0; i < N; ++i) {\\n\\t\\t// 1. check each j-th bucket for case 1 || case 2 || case 3\\n        let j = bucket(A[i]);\\n        if (ok(i, j - 1) || ok(i, j) || ok(i, j + 1))  // (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n            return true;\\n        // 2. slide window \\uD83D\\uDC49\\n        m[j] = A[i];                     // \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n        if (0 <= i - K) {\\n            let end = bucket(A[i - K]);  // \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n            delete m[end];\\n        }  \\n    }\\n    return false;\\n};\\n```\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, A: List[int], K: int, T: int) -> bool:\\n        m = {}\\n        N = len(A)\\n        if N < 2:\\n            return False\\n        bucket = lambda x: x // T if T else x // (T + 1)  # \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n        ok = lambda i, j: j in m and abs(m[j] - A[i]) <= T\\n        for i in range(N):\\n\\t\\t\\t#  1. check each j-th bucket for case 1 || case 2 || case 3\\n            j = bucket(A[i])\\n            if ok(i, j - 1) or ok(i, j) or ok(i, j + 1):  # (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n                return True\\n            # slide window \\uD83D\\uDC49\\n            m[j] = A[i]                 # \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n            if 0 <= i - K:\\n                end = bucket(A[i - K])  # \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n                del m[end]\\n        return False\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Map = unordered_map<int, long long>;\\n    bool containsNearbyAlmostDuplicate(VI& A, int K, int T, Map m = {}) {\\n        int N = A.size();\\n        if (N < 2)\\n            return false;\\n        auto bucket = [=](auto x) { return T ? x / T : x / (T + 1); };  // \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n        auto ok = [&](auto i, auto j) { return m.find(j) != m.end() && abs(m[j] - A[i]) <= T; };\\n        for (auto i{ 0 }; i < N; ++i) {\\n            // 1. check each j-th bucket for case 1 || case 2 || case 3\\n            auto j = bucket(A[i]);\\n            if (ok(i, j - 1) || ok(i, j) || ok(i, j + 1))  // (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n                return true;\\n            // 2. slide window \\uD83D\\uDC49\\n            m[j] = A[i];                      // \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n            if (0 <= i - K) {\\n                auto end = bucket(A[i - K]);  // \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n                m.erase(end);\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824742,
                "title": "java-clean-code-sliding-window-and-binary-search-tree-treeset",
                "content": "```\\nclass Solution {\\n\\t\\n\\tpublic boolean containsNearbyAlmostDuplicate (int[] nums, int k, int t) {\\n\\t\\t\\n\\t\\tTreeSet<Integer> set = new TreeSet <>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tInteger leftMax = set.floor (nums[i]);\\n\\t\\t\\tInteger rightMin = set.ceiling (nums[i]);\\n\\t\\t\\tif ((leftMax != null && (long) nums[i] - leftMax <= t) || (rightMin != null && (long) rightMin - nums[i] <= t)) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tset.add (nums[i]);\\n\\t\\t\\tif (i >= k) {\\n\\t\\t\\t\\tset.remove (nums[i - k]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n}\\n\\nTime Complexity: O(N log N)\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\t\\n\\tpublic boolean containsNearbyAlmostDuplicate (int[] nums, int k, int t) {\\n\\t\\t\\n\\t\\tTreeSet<Integer> set = new TreeSet <>();\\n\\t\\t\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tInteger leftMax = set.floor (nums[i]);\\n\\t\\t\\tInteger rightMin = set.ceiling (nums[i]);\\n\\t\\t\\tif ((leftMax != null && (long) nums[i] - leftMax <= t) || (rightMin != null && (long) rightMin - nums[i] <= t)) {\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tset.add (nums[i]);\\n\\t\\t\\tif (i >= k) {\\n\\t\\t\\t\\tset.remove (nums[i - k]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\treturn false;\\n\\t}\\n}\\n\\nTime Complexity: O(N log N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824545,
                "title": "java-10ms-beats-87-time-binary-src-idea-easy-explained-o-nlogn",
                "content": "```\\n// idea is that we can solve it using brute force which wil give O(nk) avg case bt worst case \\n // On^2  where k = n, it might give tle , so to improve we can sort the temp capy array once \\n // and then binary search for every elt in nums , if we can find an elt in temp which satifies 3 conditions \\n // 1 . abs(nums[i] - temp [i] [1] ) <= t \\n // 2.  abs ( i - temp[i][0]) <= k\\n // 3 . i != temp[i][0] , so now we get two seperate loops both Onlogn \\n // and we know On + On = On , so Onlogn + Onlogn = Onlogn\\n \\nclass Solution {\\n    private static boolean binSrc(int [][] temp , int val , int i ,int k , int t){\\n        int low = 0 ;\\n        int high = temp.length - 1;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2; \\n            long n_dif = (long)temp[mid][1] - (long)val; // take long to prevent integer over flow\\n            int i_diff = temp[mid][0] - i;\\n            // if we find an elt satisfying the two condtions also , they are diiferent elts , ie ->  i != j \\n            if( Math.abs(n_dif) <= t && Math.abs(i_diff) <= k && temp[mid][0] != i)\\n                return true;\\n            // else if abs diff b/w val and curr_mid elt > t our possible ans lies on the left part \\n            else if(Math.abs(n_dif) > t)\\n                high = mid - 1 ;\\n            else  // else our possible lies on the right part \\n                low = mid + 1;\\n           \\n        }\\n        return false;\\n    }\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        // temporary pair arr , tmp [i][0] = index , tmp[i][1] = its coresponding elt\\n        int temp [][] = new int [nums.length][2];\\n        for(int i = 0 ; i < nums.length ; i++){\\n            temp[i][0] = i; // index\\n            temp[i][1] = nums[i]; // elt \\n        }\\n        // sort in  ascending order of elts \\n        Arrays.sort(temp, (a,b) -> {\\n            return a[1] - b[1];\\n        });\\n        // for every elt in unsorted nums , binary src the sorted tmp array and check the given condition \\n        // required in question\\n        for(int i = 0 ; i < nums.length ; i++){\\n            int elt = nums[i];\\n            if(binSrc(temp,elt,i, k,t))\\n                return true;\\n        }\\n        return false;\\n    }\\n}\\n// hope it helps , tysm , if u",
                "solutionTags": [
                    "Binary Search",
                    "Sorting"
                ],
                "code": "class Solution {\\n    private static boolean binSrc(int [][] temp , int val , int i ,int k , int t){\\n        int low = 0 ;\\n        int high = temp.length - 1;\\n        while(low <= high){\\n            int mid = low + (high - low) / 2; \\n            long n_dif = (long)temp[mid][1] - (long)val; // take long to prevent integer over flow\\n            int i_diff = temp[mid][0] - i;\\n            // if we find an elt satisfying the two condtions also , they are diiferent elts , ie ->  i != j \\n            if( Math.abs(n_dif) <= t && Math.abs(i_diff) <= k && temp[mid][0] != i)\\n                return true;\\n            // else if abs diff b/w val and curr_mid elt > t our possible ans lies on the left part \\n            else if(Math.abs(n_dif) > t)\\n                high = mid - 1 ;\\n            else  // else our possible lies on the right part \\n                low = mid + 1;\\n           \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 512781,
                "title": "java-simple-with-detailed-explanation",
                "content": "```\\n   // core logic: sliding window + tree set. maintain the tree set in such a way that it always contains K elements and slide them accordingly (remove 1st element when we reach size >=k, etc..)\\n    // the fact that the absolute diff should always be utmost t means that we need to check the greatest low and lowest high for all the elements. if that satisfies the given condition, return true. eg: if t = 2 and nums[i] = 4, for the condition to be true the greatest element smaller than 4 should be in between 2 and 4, while smallest element greater than 4 should lie between 4 and 6. \\n    // TC: O(NlogK) - as the size of tree set is always k and n is the size of the array\\n    private static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length <= 1) {\\n            return false;\\n        }\\n        TreeSet<Integer> treeSet = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            Integer low = treeSet.floor(nums[i]);   // get the greatest element smaller than this number\\n            Integer high = treeSet.ceiling(nums[i]);  // get the smallest element greater than this number\\n\\n            if ((low != null && (long) nums[i] - low <= t) || (high != null && (long) high - nums[i] <= t)) {   // check for absolute differences\\n                return true;\\n            }\\n            treeSet.add(nums[i]);\\n\\n            if (i >= k) {   // remove the first element when size of the tree set exceeds K\\n                treeSet.remove(nums[i - k]);\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n   // core logic: sliding window + tree set. maintain the tree set in such a way that it always contains K elements and slide them accordingly (remove 1st element when we reach size >=k, etc..)\\n    // the fact that the absolute diff should always be utmost t means that we need to check the greatest low and lowest high for all the elements. if that satisfies the given condition, return true. eg: if t = 2 and nums[i] = 4, for the condition to be true the greatest element smaller than 4 should be in between 2 and 4, while smallest element greater than 4 should lie between 4 and 6. \\n    // TC: O(NlogK) - as the size of tree set is always k and n is the size of the array\\n    private static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length <= 1) {\\n            return false;\\n        }\\n        TreeSet<Integer> treeSet = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            Integer low = treeSet.floor(nums[i]);   // get the greatest element smaller than this number\\n            Integer high = treeSet.ceiling(nums[i]);  // get the smallest element greater than this number\\n\\n            if ((low != null && (long) nums[i] - low <= t) || (high != null && (long) high - nums[i] <= t)) {   // check for absolute differences\\n                return true;\\n            }\\n            treeSet.add(nums[i]);\\n\\n            if (i >= k) {   // remove the first element when size of the tree set exceeds K\\n                treeSet.remove(nums[i - k]);\\n            }\\n        }\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61777,
                "title": "ac-python-code-using-window-and-bucketing",
                "content": "    class Solution:\\n        # @param {integer[]} nums\\n        # @param {integer} k\\n        # @param {integer} t\\n        # @return {boolean}\\n        def containsNearbyAlmostDuplicate(self, nums, k, t):\\n            if k <= 0 or t < 0:\\n                return False\\n            numsDict = {}\\n            for i in range(len(nums)):\\n                bucket = nums[i]/(t+1)\\n                for key in [bucket-1, bucket, bucket+1]:\\n                    if key in numsDict and abs(numsDict[key] - nums[i]) <= t:\\n                        return True\\n                numsDict[bucket] = nums[i]\\n                if i+1 > k:\\n                    pop_key = nums[i-k]/(t+1)\\n                    numsDict.pop(pop_key)\\n            return False\\n\\nBasically, I kept a window of size k and put all integers in that window into buckets. The index of the bucket is integer mod (t+1), as to avoid zeroDivisionError when t = 0. The runtime should be O(n) for this algorithm.",
                "solutionTags": [],
                "code": "class Solution:\\n        # @param {integer[]}",
                "codeTag": "Java"
            },
            {
                "id": 3227563,
                "title": "220-time-94-72-and-space-92-33-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe solution uses bucketing technique to solve the problem.\\n\\n1. First, we check if the input list nums is not empty and if indexDiff is greater than 0 and valueDiff is non-negative. If not, we return False as no such pair exists.\\n\\n2. We find the minimum value in the list nums.\\n\\n3. We set the diff as valueDiff + 1. This is because, in case valueDiff is 0, we need to ensure that a difference of 0 is allowed.\\n\\n4. We create an empty dictionary bucket to store the elements in the current and adjacent buckets.\\n\\n5. We define a function getKey which takes an integer num as input and returns the key of the bucket to which the element belongs.\\n\\n6. We iterate through each element in the list nums along with its index i. For each element, we get its corresponding key using getKey function.\\n\\n7. We first check if the element already exists in the current bucket. If yes, then we return True as we have found the required pair.\\n\\n8. If not, we check if the left adjacent bucket exists and if the difference between the current element and the maximum element in the left adjacent bucket is less than diff. If yes, then we return True.\\n\\n9. Similarly, we check if the right adjacent bucket exists and if the difference between the minimum element in the right adjacent bucket and the current element is less than diff. If yes, then we return True.\\n\\n10. If none of the above conditions hold, we add the current element to the bucket with the key as the value returned by getKey. We also remove the element from the bucket whose index is greater than or equal to indexDiff.\\n\\n11. Finally, if no such pair exists in the entire list, we return False.\\n\\n# Complexity\\n- Time complexity:\\nBeats\\n94.72%\\n- Space complexity:\\nBeats\\n92.33%\\n\\n# Code\\n```\\nclass Solution:\\n  def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n    if not nums or indexDiff <= 0 or valueDiff < 0:\\n      return False\\n\\n    mini = min(nums)\\n    diff = valueDiff + 1  # In case of valueDiff = 0\\n    bucket = {}\\n\\n    def getKey(num: int) -> int:\\n      return (num - mini) // diff\\n\\n    for i, num in enumerate(nums):\\n      key = getKey(num)\\n      if key in bucket:  # Current bucket\\n        return True\\n      # Left adjacent bucket\\n      if key - 1 in bucket and num - bucket[key - 1] < diff:\\n        return True\\n      # Right adjacent bucket\\n      if key + 1 in bucket and bucket[key + 1] - num < diff:\\n        return True\\n      bucket[key] = num\\n      if i >= indexDiff:\\n        del bucket[getKey(nums[i - indexDiff])]\\n\\n    return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sliding Window",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n  def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n    if not nums or indexDiff <= 0 or valueDiff < 0:\\n      return False\\n\\n    mini = min(nums)\\n    diff = valueDiff + 1  # In case of valueDiff = 0\\n    bucket = {}\\n\\n    def getKey(num: int) -> int:\\n      return (num - mini) // diff\\n\\n    for i, num in enumerate(nums):\\n      key = getKey(num)\\n      if key in bucket:  # Current bucket\\n        return True\\n      # Left adjacent bucket\\n      if key - 1 in bucket and num - bucket[key - 1] < diff:\\n        return True\\n      # Right adjacent bucket\\n      if key + 1 in bucket and bucket[key + 1] - num < diff:\\n        return True\\n      bucket[key] = num\\n      if i >= indexDiff:\\n        del bucket[getKey(nums[i - indexDiff])]\\n\\n    return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2267867,
                "title": "sliding-window-multiset-o-n-log-k-easy-c-solution",
                "content": "So the idea is to make windows of k+1 (as (k+1-1) - 0 <= k) size in which the elements are sorted.\\nIt can be done with multiset.\\nNow lets understand with an example.\\n\\nLets suppose there is a window of size k+1 and some t (given)\\n\\nNow as soon as we found a consecutive pair of elements whose difference is <= t,\\nWe return true (as our window is of k+1 already size and we found diff <= t).\\n\\nOtherwise lets suppose a new element comes into play (say x at index k) and\\n\\nu = upper_bound(x) in a[0...k], return true if u - x <= t\\np = previous of upper bound, return true if x - p <= t\\n\\nelse, remove the (i-k)th element from the window and continue to next element.\\n\\nreturn false if no such element was found in the entire process.\\n\\n```\\na[] = 17 4 1 14 11 7 25 2 15 7\\nk = 4\\nt = 2\\n| 1 4 11 14 17 | 7 25 2 15 7\\n    3  7  3  3\\n17 | 1 4 7 11 14 | 25 2 15 7\\n       3 3  4  3\\n17 4 | 1 7 11 14 25 | 2 15 7\\n         6  4  3 11\\n17 4 1 | 2 7 11 14 25 | 15 7\\n           5  4  3 11\\n17 4 1 14 | 2 7 11 15 25 | 7\\n              5  4  4 10\\n17 4 1 14 11 | 2 7 7 15 25 |\\n                 5 0  8 10         0 <= t so return true\\n```\\n\\n\\n\\n```\\nstruct Solution {\\n\\n    bool containsNearbyAlmostDuplicate(vector<int> &a, int k, int t) {\\n        \\n        int n = a.size();\\n        k = min(k, n);\\n        \\n        multiset<long long> s(a.begin(), a.begin() + k);\\n        \\n        auto x = s.begin();\\n        \\n        for (int j = 1, i = *x; j < k; ++j) {\\n            ++x;\\n            if (*x - i <= t) {\\n                return 1;\\n            }\\n            i = *x;\\n        }\\n        \\n        for (int i = k; i < n; ++i) {\\n            \\n            x = s.upper_bound(a[i]);\\n            \\n            if (x != s.end() && *x - a[i] <= t) {\\n                return 1;\\n            }\\n            if (x != s.begin()) {\\n                --x;\\n                if (a[i] - *x <= t) {\\n                    return 1;\\n                }\\n            }\\n            \\n            s.insert(a[i]);\\n            s.erase(a[i-k]);\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```\\nPS: Please upvote, if found helpful...",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\na[] = 17 4 1 14 11 7 25 2 15 7\\nk = 4\\nt = 2\\n| 1 4 11 14 17 | 7 25 2 15 7\\n    3  7  3  3\\n17 | 1 4 7 11 14 | 25 2 15 7\\n       3 3  4  3\\n17 4 | 1 7 11 14 25 | 2 15 7\\n         6  4  3 11\\n17 4 1 | 2 7 11 14 25 | 15 7\\n           5  4  3 11\\n17 4 1 14 | 2 7 11 15 25 | 7\\n              5  4  4 10\\n17 4 1 14 11 | 2 7 7 15 25 |\\n                 5 0  8 10         0 <= t so return true\\n```\n```\\nstruct Solution {\\n\\n    bool containsNearbyAlmostDuplicate(vector<int> &a, int k, int t) {\\n        \\n        int n = a.size();\\n        k = min(k, n);\\n        \\n        multiset<long long> s(a.begin(), a.begin() + k);\\n        \\n        auto x = s.begin();\\n        \\n        for (int j = 1, i = *x; j < k; ++j) {\\n            ++x;\\n            if (*x - i <= t) {\\n                return 1;\\n            }\\n            i = *x;\\n        }\\n        \\n        for (int i = k; i < n; ++i) {\\n            \\n            x = s.upper_bound(a[i]);\\n            \\n            if (x != s.end() && *x - a[i] <= t) {\\n                return 1;\\n            }\\n            if (x != s.begin()) {\\n                --x;\\n                if (a[i] - *x <= t) {\\n                    return 1;\\n                }\\n            }\\n            \\n            s.insert(a[i]);\\n            s.erase(a[i-k]);\\n        }\\n        \\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2048581,
                "title": "python-sliding-window-sortedlist-simple-solution",
                "content": "```\\nfrom sortedcontainers import SortedList\\n    \\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        window = SortedList()\\n        for i in range(len(nums)):\\n            if i > k: \\n                window.remove(nums[i-k-1])   \\n            idx1 = SortedList.bisect_left(window, nums[i] - t)\\n            idx2 = SortedList.bisect_right(window, nums[i] + t)\\n            \\n            if idx1 != idx2 and idx1 != len(window): \\n                return True\\n            \\n            window.add(nums[i])\\n        \\n        return False\\n```\\n\\n***If you liked the above solution then please upvote!***",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\n    \\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        window = SortedList()\\n        for i in range(len(nums)):\\n            if i > k: \\n                window.remove(nums[i-k-1])   \\n            idx1 = SortedList.bisect_left(window, nums[i] - t)\\n            idx2 = SortedList.bisect_right(window, nums[i] + t)\\n            \\n            if idx1 != idx2 and idx1 != len(window): \\n                return True\\n            \\n            window.add(nums[i])\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1488457,
                "title": "20-ms-faster-than-97-easy-to-understand-c",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<int,int>> res;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            res.push_back({nums[i],i});\\n        }\\n        sort(res.begin(),res.end());\\n        for(int i = 0; i < res.size(); i++)\\n        {\\n            for(int j = i+1; j<res.size(); j++)\\n            {\\n                if(abs((long)res[i].first - (long)res[j].first) <= t)\\n                {\\n                    if(abs(res[i].second - res[j].second) <= k)\\n                        return true;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<int,int>> res;\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            res.push_back({nums[i],i});\\n        }\\n        sort(res.begin(),res.end());\\n        for(int i = 0; i < res.size(); i++)\\n        {\\n            for(int j = i+1; j<res.size(); j++)\\n            {\\n                if(abs((long)res[i].first - (long)res[j].first) <= t)\\n                {\\n                    if(abs(res[i].second - res[j].second) <= k)\\n                        return true;\\n                }\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1429653,
                "title": "java-clear-treeset-solution-and-bucket-hashmap-solution",
                "content": "TreeSet Solution \\n```\\n// TreeSet Solution \\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        final int N = nums.length;\\n        TreeSet<Long> treeSet = new TreeSet<>();\\n        for (int i = 0; i < N; i++) {\\n            long num = nums[i];\\n            Long floor = treeSet.floor(num + t);\\n            Long ceil = treeSet.ceiling(num - t);\\n            if ((floor != null && floor >= num) || (ceil != null && ceil <= num)) {\\n                return true;\\n            }\\n\\t\\t\\ttreeSet.add(num);\\n            if (i >= k) {\\n                treeSet.remove((long)nums[i-k]);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\\n\\n```\\n// Bucket HashMap Solution\\n// If two numbers the diff <= t, then 1) they are in the same bucket, or 2) they are in the adjacent buckets and diff <= t.\\n// Remove the number out of the window to guarantee numbers in the HashMap within the window (diff of index <= k).\\n// Time complexity: O(N)\\n// Space complexity: O(min(N, k))\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        final int N = nums.length;\\n        Map<Long, Long> map = new HashMap<>(Math.min(N, k));\\n        for (int i = 0; i < N; i++) {\\n            long num = nums[i];\\n            long bucketId = getBucket(num, t);\\n            // If two numbers the diff <= t, then \\n            // they are in the same bucket,\\n            // or they are in the adjacent buckets and diff <= t.\\n            if (map.containsKey(bucketId)\\n                || (map.containsKey(bucketId - 1) && num - map.get(bucketId - 1) <= t) \\n                || (map.containsKey(bucketId + 1) && map.get(bucketId + 1) - num <= t)) {\\n                return true;\\n            }\\n            if (map.size() >= k) {  // Remove the number out of the window\\n                long lastBucket = getBucket(nums[i - k], t);\\n                map.remove(lastBucket);\\n            }\\n            map.put(bucketId, num);\\n        }\\n        return false;\\n    }\\n    \\n    private long getBucket(long num, long div) {\\n        long bucketId = num / (div + 1);  // map num to bucket id: [0, div+1) => 0, [div+1, 2*(div+1)) => 1\\n        if (num < 0) return bucketId - 1;  // If num < 0, bucketId start from -1,-2,... instead of 0, -1,-2,...\\n        return bucketId;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// TreeSet Solution \\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        final int N = nums.length;\\n        TreeSet<Long> treeSet = new TreeSet<>();\\n        for (int i = 0; i < N; i++) {\\n            long num = nums[i];\\n            Long floor = treeSet.floor(num + t);\\n            Long ceil = treeSet.ceiling(num - t);\\n            if ((floor != null && floor >= num) || (ceil != null && ceil <= num)) {\\n                return true;\\n            }\\n\\t\\t\\ttreeSet.add(num);\\n            if (i >= k) {\\n                treeSet.remove((long)nums[i-k]);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```\n```\\n// Bucket HashMap Solution\\n// If two numbers the diff <= t, then 1) they are in the same bucket, or 2) they are in the adjacent buckets and diff <= t.\\n// Remove the number out of the window to guarantee numbers in the HashMap within the window (diff of index <= k).\\n// Time complexity: O(N)\\n// Space complexity: O(min(N, k))\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        final int N = nums.length;\\n        Map<Long, Long> map = new HashMap<>(Math.min(N, k));\\n        for (int i = 0; i < N; i++) {\\n            long num = nums[i];\\n            long bucketId = getBucket(num, t);\\n            // If two numbers the diff <= t, then \\n            // they are in the same bucket,\\n            // or they are in the adjacent buckets and diff <= t.\\n            if (map.containsKey(bucketId)\\n                || (map.containsKey(bucketId - 1) && num - map.get(bucketId - 1) <= t) \\n                || (map.containsKey(bucketId + 1) && map.get(bucketId + 1) - num <= t)) {\\n                return true;\\n            }\\n            if (map.size() >= k) {  // Remove the number out of the window\\n                long lastBucket = getBucket(nums[i - k], t);\\n                map.remove(lastBucket);\\n            }\\n            map.put(bucketId, num);\\n        }\\n        return false;\\n    }\\n    \\n    private long getBucket(long num, long div) {\\n        long bucketId = num / (div + 1);  // map num to bucket id: [0, div+1) => 0, [div+1, 2*(div+1)) => 1\\n        if (num < 0) return bucketId - 1;  // If num < 0, bucketId start from -1,-2,... instead of 0, -1,-2,...\\n        return bucketId;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269293,
                "title": "java-brute-and-optimized-both-sol",
                "content": "```\\nclass Solution {\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        return treemapsol(nums, k, t);\\n    }\\n    \\n\\t   // a = nums[i]\\n    // b = nums[j]\\n    // a - b <= t or b - a <= t\\n    // b >= a - t || b <= t + a \\n    public boolean treemapsol(int[] nums, int k , int t) {\\n         TreeSet<Long> map = new TreeSet<>();\\n         for(int i = 0; i < nums.length; i++) {\\n             long a = nums[i];\\n             long b1 = a-t;\\n             long b2 = t+a;\\n             \\n             Long v1 = map.ceiling(b1);\\n             Long v2 = map.floor(b2);\\n             \\n             if((v1 != null && v1 <= a) || (v2 != null && v2 >= a)) {\\n                 return true;\\n             }\\n             \\n             map.add(a);\\n             \\n             if(i >= k) {\\n                 map.remove((long)nums[i-k]);\\n             }\\n         }\\n        return false;\\n    }\\n    \\n    public boolean brute(int[] nums, int k, int t) {\\n        for(int i = 0; i < nums.length; i++) {\\n            long a = nums[i];\\n            for(int j = i+1; j < nums.length && j <= i + k; j++) {\\n                long b = nums[j];\\n                if(Math.abs(a-b) <= t) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        return treemapsol(nums, k, t);\\n    }\\n    \\n\\t   // a = nums[i]\\n    // b = nums[j]\\n    // a - b <= t or b - a <= t\\n    // b >= a - t || b <= t + a \\n    public boolean treemapsol(int[] nums, int k , int t) {\\n         TreeSet<Long> map = new TreeSet<>();\\n         for(int i = 0; i < nums.length; i++) {\\n             long a = nums[i];\\n             long b1 = a-t;\\n             long b2 = t+a;\\n             \\n             Long v1 = map.ceiling(b1);\\n             Long v2 = map.floor(b2);\\n             \\n             if((v1 != null && v1 <= a) || (v2 != null && v2 >= a)) {\\n                 return true;\\n             }\\n             \\n             map.add(a);\\n             \\n             if(i >= k) {\\n                 map.remove((long)nums[i-k]);\\n             }\\n         }\\n        return false;\\n    }\\n    \\n    public boolean brute(int[] nums, int k, int t) {\\n        for(int i = 0; i < nums.length; i++) {\\n            long a = nums[i];\\n            for(int j = i+1; j < nums.length && j <= i + k; j++) {\\n                long b = nums[j];\\n                if(Math.abs(a-b) <= t) return true;\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232802,
                "title": "python-bucketing",
                "content": "```\\nclass Solution(object):\\n    def _get_bucket_id(self, num, size):\\n        \"\"\"\\n        Assume buckets are k: [k*size, ..., (k+1)*size-1] for k >= 0\\n            and k: [-(k+2)size+1, ..., -(k+1)*size] for k < 0.\\n        By convention we place num = 0 to the k=0 bucket.\\n        This makes sure that the range of each bucket is <= size-1.\\n        \"\"\"\\n        if num >= 0:\\n            return num//size\\n        else:\\n            return num//size - 1\\n    \\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        bucket = {}\\n        size = t + 1\\n        \\n        for i, num in enumerate(nums):\\n            bucket_id = self._get_bucket_id(num, size)\\n            if bucket_id in bucket:\\n                return True\\n            \\n            # check adjacent buckets\\n            if (bucket_id+1) in bucket and bucket[bucket_id+1] - num <= t:\\n                return True\\n            if (bucket_id-1) in bucket and num - bucket[bucket_id-1] <= t:\\n                return True\\n            \\n            bucket[bucket_id] = num\\n            # we want the indices to be at most k apart\\n            # so once we have added k elements in the bucket,\\n            # everytime we want to add a new element, \\n            # we need to disregard the least recent element\\n            if i >= k:\\n                bucket.pop(self._get_bucket_id(nums[i-k], size))\\n        \\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def _get_bucket_id(self, num, size):\\n        \"\"\"\\n        Assume buckets are k: [k*size, ..., (k+1)*size-1] for k >= 0\\n            and k: [-(k+2)size+1, ..., -(k+1)*size] for k < 0.\\n        By convention we place num = 0 to the k=0 bucket.\\n        This makes sure that the range of each bucket is <= size-1.\\n        \"\"\"\\n        if num >= 0:\\n            return num//size\\n        else:\\n            return num//size - 1\\n    \\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        bucket = {}\\n        size = t + 1\\n        \\n        for i, num in enumerate(nums):\\n            bucket_id = self._get_bucket_id(num, size)\\n            if bucket_id in bucket:\\n                return True\\n            \\n            # check adjacent buckets\\n            if (bucket_id+1) in bucket and bucket[bucket_id+1] - num <= t:\\n                return True\\n            if (bucket_id-1) in bucket and num - bucket[bucket_id-1] <= t:\\n                return True\\n            \\n            bucket[bucket_id] = num\\n            # we want the indices to be at most k apart\\n            # so once we have added k elements in the bucket,\\n            # everytime we want to add a new element, \\n            # we need to disregard the least recent element\\n            if i >= k:\\n                bucket.pop(self._get_bucket_id(nums[i-k], size))\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 922176,
                "title": "java-tree-set-with-explanation",
                "content": "1. Initialize a Tree Set.  It can be imagined as a constantly updating binary search tree.  This means we can find the max and min values currently in the tree in an average O(log n) time. Where n is the amount of elements in the tree.\\n2. We then run through the list of numbers.  For each number, n, we check the tree for the current floor and cieling of n.  The floor is the largest number currently in the tree that is less then n.  The cieling is the smallest.\\n3. From here, we check to see if the cieling minus our current n is within the acceptable range (val diff).  If there is, we can stop looping and just return true. Same thing with the current n minus the floor.\\n4. We then add n to the tree set.  If the tree is now larger than the excepted indDifference we remove the first element that was added to the current tree.  This can be done by subtracting the current index, i, from the indDiff value.  This is because indDiff is the max number of elements allowed in the tree. \\n5. If we complete the loop through the list there was no valid cases, so we can return false.\\n\\n*Note that we convert all the ints to longs because if we have MAX Value or MIN Value or any combination where we would add or subtract and go out of bounds, long can handle those larger numbers.\\n\\n\\n```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int indDiff, int valDiff) {\\n\\t\\tTreeSet<Long> set = new TreeSet<Long>();\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tLong floor = set.floor((long) nums[i]); // Largest Number less then the num.\\n\\t\\t\\tLong cieling = set.ceiling((long) nums[i]); // Smallest Number greater than num.\\n\\t\\t\\t\\n\\t\\t    if (floor != null && (long) nums[i] - floor <= valDiff) return true;\\n\\t\\t\\tif (cieling != null && cieling - (long) nums[i] <= valDiff) return true;\\n            \\n\\t\\t\\tset.add((long)nums[i]);\\n\\t\\t\\tif(set.size()>indDiff) set.remove((long)nums[i-indDiff]);\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "solutionTags": [],
                "code": "1. Initialize a Tree Set.  It can be imagined as a constantly updating binary search tree.  This means we can find the max and min values currently in the tree in an average O(log n) time. Where n is the amount of elements in the tree.\\n2. We then run through the list of numbers.  For each number, n, we check the tree for the current floor and cieling of n.  The floor is the largest number currently in the tree that is less then n.  The cieling is the smallest.\\n3. From here, we check to see if the cieling minus our current n is within the acceptable range (val diff).  If there is, we can stop looping and just return true. Same thing with the current n minus the floor.\\n4. We then add n to the tree set.  If the tree is now larger than the excepted indDifference we remove the first element that was added to the current tree.  This can be done by subtracting the current index, i, from the indDiff value.  This is because indDiff is the max number of elements allowed in the tree. \\n5. If we complete the loop through the list there was no valid cases, so we can return false.\\n\\n*Note that we convert all the ints to longs because if we have MAX Value or MIN Value or any combination where we would add or subtract and go out of bounds, long can handle those larger numbers.\\n\\n\\n```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int indDiff, int valDiff) {\\n\\t\\tTreeSet<Long> set = new TreeSet<Long>();\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t\\tLong floor = set.floor((long) nums[i]); // Largest Number less then the num.\\n\\t\\t\\tLong cieling = set.ceiling((long) nums[i]); // Smallest Number greater than num.\\n\\t\\t\\t\\n\\t\\t    if (floor != null && (long) nums[i] - floor <= valDiff) return true;\\n\\t\\t\\tif (cieling != null && cieling - (long) nums[i] <= valDiff) return true;\\n            \\n\\t\\t\\tset.add((long)nums[i]);\\n\\t\\t\\tif(set.size()>indDiff) set.remove((long)nums[i-indDiff]);\\n\\t\\t}\\n\\t\\treturn false;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 860099,
                "title": "c-sliding-window-o-n-logk-solution",
                "content": "* Time: O(n*logk)\\n\\t* Explaination: k*log(k) + 2*(n-k)*log(k) (creating a balanced BST of k numbers + deleting and inserting (n-k) numbers in a balanced BST of k numbres)\\n* Space: O(k)\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {        \\n        if (k<=0) return false;\\n        if (k>=nums.size()) k = nums.size()-1;\\n        set<long long> s;\\n        for (int i=0; i<nums.size(); i++) {\\n            if(i > k) s.erase(nums[i-k-1]);\\n            auto pos1 = s.lower_bound((long long)nums[i]-t);     // cond 1\\n            //auto pos2 = s.lower_bound((long long)nums[i]+t);  // cond 2\\n\\t\\t\\t/* Above line and corresponding condition below are commented because they are not required.\\n\\t\\t\\t * Reason: Range: [n-t .... n .... n+t]\\n\\t\\t\\t * If a number greater than or equal to n-t is found in set and it satisfies the absolute difference in check, we don\\'t need to separately check for n+t.  cond1 is a super-set of cond2\\n\\t\\t\\t*/\\n            if ((pos1 != s.end() && abs(*pos1-nums[i]) <= t)/* || (pos2 != s.end() && abs(*pos2-nums[i]) <= t)*/)\\n                return true;\\n            s.insert(nums[i]);\\n        }\\n        return false;\\n    }\\n}; \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {        \\n        if (k<=0) return false;\\n        if (k>=nums.size()) k = nums.size()-1;\\n        set<long long> s;\\n        for (int i=0; i<nums.size(); i++) {\\n            if(i > k) s.erase(nums[i-k-1]);\\n            auto pos1 = s.lower_bound((long long)nums[i]-t);     // cond 1\\n            //auto pos2 = s.lower_bound((long long)nums[i]+t);  // cond 2\\n\\t\\t\\t/* Above line and corresponding condition below are commented because they are not required.\\n\\t\\t\\t * Reason: Range: [n-t .... n .... n+t]\\n\\t\\t\\t * If a number greater than or equal to n-t is found in set and it satisfies the absolute difference in check, we don\\'t need to separately check for n+t.  cond1 is a super-set of cond2\\n\\t\\t\\t*/\\n            if ((pos1 != s.end() && abs(*pos1-nums[i]) <= t)/* || (pos2 != s.end() && abs(*pos2-nums[i]) <= t)*/)\\n                return true;\\n            s.insert(nums[i]);\\n        }\\n        return false;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 824719,
                "title": "java-using-sliding-window-approach",
                "content": "```\\n// looking for atmost diff b/w indexes means indexDiff i.e sliding window size can vary from 1 to k, so size is initialized with 1 and checked upto k\\n// for each size, check the diff, between ith and i+kth, it should <= t. return true, else false\\n// PS - There is Time Limit Exceeded Error when you remove the 10k condition, because it is O(N*K) , I came up with this condition by checking the last test case.\\n\\n\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums.length > 9999) return false;\\n        int size = 1;\\n        while (size <= k) {\\n            for (int i = 0; i < nums.length - size; i++) {\\n                if (Math.abs((long) nums[i] - (long) nums[i + size]) <= t) {\\n                    return true;\\n                }\\n            }\\n            size++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// looking for atmost diff b/w indexes means indexDiff i.e sliding window size can vary from 1 to k, so size is initialized with 1 and checked upto k\\n// for each size, check the diff, between ith and i+kth, it should <= t. return true, else false\\n// PS - There is Time Limit Exceeded Error when you remove the 10k condition, because it is O(N*K) , I came up with this condition by checking the last test case.\\n\\n\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums.length > 9999) return false;\\n        int size = 1;\\n        while (size <= k) {\\n            for (int i = 0; i < nums.length - size; i++) {\\n                if (Math.abs((long) nums[i] - (long) nums[i + size]) <= t) {\\n                    return true;\\n                }\\n            }\\n            size++;\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824551,
                "title": "python-simple-intuitive-solution",
                "content": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        # regular duplication\\n        if t == 0 and len(set(nums)) == len(nums):\\n            return False\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1, min(i+k+1, len(nums))):\\n                if abs(nums[i] - nums[j]) <= t:\\n                    return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        # regular duplication\\n        if t == 0 and len(set(nums)) == len(nums):\\n            return False\\n        \\n        for i in range(len(nums)):\\n            for j in range(i+1, min(i+k+1, len(nums))):\\n                if abs(nums[i] - nums[j]) <= t:\\n                    return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61722,
                "title": "ugly-code-but-it-works-fast",
                "content": "```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    //trivial reject\\n    if (nums.length < 2) return false;\\n    if (k == 0 || t < 0) return false;\\n    \\n    int max = nums[0];\\n    int min = nums[0];\\n    \\n    for (int i : nums)\\n    {\\n        max = Math.max(i, max);\\n        min = Math.min(i, min);\\n    }\\n    \\n    // trivial accept\\n    if (max == min) return true;\\n    \\n    double temp = t;\\n    temp++;\\n    \\n    int length = (int)Math.ceil(((double)max-min)/temp) + 1;\\n    int[][] table = new int[3][length];\\n    \\n    for (int i = 0; i < nums.length; i++)\\n    {\\n        int num = nums[i];\\n        int place =(int) (((double)num - min)/temp);\\n        \\n        if (table[0][place] != 0)\\n            if (table[1][place] + k >= i)\\n                return true;\\n        if (place > 0 && table[0][place - 1] == 1 && table[1][place - 1] + k >= i && table[2][place - 1] + t >= num)\\n                return true;\\n        else if (place < length - 1 && table[0][place + 1] == 1 && table[1][place + 1] + k >= i && table[2][place + 1] - t <= num)\\n                return true;\\n        \\n        table[0][place] = 1;\\n        table[1][place] = i;\\n        table[2][place] = num;\\n    }\\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    //trivial reject\\n    if (nums.length < 2) return false;\\n    if (k == 0 || t < 0) return false;\\n    \\n    int max = nums[0];\\n    int min = nums[0];\\n    \\n    for (int i : nums)\\n    {\\n        max = Math.max(i, max);\\n        min = Math.min(i, min);\\n    }\\n    \\n    // trivial accept\\n    if (max == min) return true;\\n    \\n    double temp = t;\\n    temp++;\\n    \\n    int length = (int)Math.ceil(((double)max-min)/temp) + 1;\\n    int[][] table = new int[3][length];\\n    \\n    for (int i = 0; i < nums.length; i++)\\n    {\\n        int num = nums[i];\\n        int place =(int) (((double)num - min)/temp);\\n        \\n        if (table[0][place] != 0)\\n            if (table[1][place] + k >= i)\\n                return true;\\n        if (place > 0 && table[0][place - 1] == 1 && table[1][place - 1] + k >= i && table[2][place - 1] + t >= num)\\n                return true;\\n        else if (place < length - 1 && table[0][place + 1] == 1 && table[1][place + 1] + k >= i && table[2][place + 1] - t <= num)\\n                return true;\\n        \\n        table[0][place] = 1;\\n        table[1][place] = i;\\n        table[2][place] = num;\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 61728,
                "title": "easy-and-clear-java-solution-using-treeset",
                "content": "    public static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    \\t\\tif (nums.length <= 0 || k <= 0) {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\tTreeSet<Integer> set = new TreeSet<>();\\n    \\t\\tfor (int i = 0; i < nums.length; i++) {\\n    \\t\\t\\tint val = nums[i];\\n    \\t\\t\\t/*\\n    \\t\\t\\t * Returns the greatest element in this set less than or equal to\\n    \\t\\t\\t * the given element, or null if there is no such element. Specified\\n    \\t\\t\\t * by: floor(...) in NavigableSet Parameters: e the value to match\\n    \\t\\t\\t * Returns: the greatest element less than or equal to e, or null if\\n    \\t\\t\\t * there is no such element\\n    \\t\\t\\t */\\n    \\t\\t\\tif (set.floor(val) != null && (set.floor(val) + t) >= val)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\t/*\\n    \\t\\t\\t * Returns the least element in this set greater than or equal to\\n    \\t\\t\\t * the given element, or null if there is no such element. Specified\\n    \\t\\t\\t * by: ceiling(...) in NavigableSet Parameters: e the value to match\\n    \\t\\t\\t * Returns: the least element greater than or equal to e, or null if\\n    \\t\\t\\t * there is no such element\\n    \\t\\t\\t */\\n    \\t\\t\\tif (set.ceiling(val) != null && (set.ceiling(val) - t) <= val)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\tset.add(val);\\n    \\t\\t\\tif (i >= k)\\n    \\t\\t\\t\\tset.remove(nums[i - k]);\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}",
                "solutionTags": [],
                "code": "    public static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    \\t\\tif (nums.length <= 0 || k <= 0) {\\n    \\t\\t\\treturn false;\\n    \\t\\t}\\n    \\t\\tTreeSet<Integer> set = new TreeSet<>();\\n    \\t\\tfor (int i = 0; i < nums.length; i++) {\\n    \\t\\t\\tint val = nums[i];\\n    \\t\\t\\t/*\\n    \\t\\t\\t * Returns the greatest element in this set less than or equal to\\n    \\t\\t\\t * the given element, or null if there is no such element. Specified\\n    \\t\\t\\t * by: floor(...) in NavigableSet Parameters: e the value to match\\n    \\t\\t\\t * Returns: the greatest element less than or equal to e, or null if\\n    \\t\\t\\t * there is no such element\\n    \\t\\t\\t */\\n    \\t\\t\\tif (set.floor(val) != null && (set.floor(val) + t) >= val)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\t/*\\n    \\t\\t\\t * Returns the least element in this set greater than or equal to\\n    \\t\\t\\t * the given element, or null if there is no such element. Specified\\n    \\t\\t\\t * by: ceiling(...) in NavigableSet Parameters: e the value to match\\n    \\t\\t\\t * Returns: the least element greater than or equal to e, or null if\\n    \\t\\t\\t * there is no such element\\n    \\t\\t\\t */\\n    \\t\\t\\tif (set.ceiling(val) != null && (set.ceiling(val) - t) <= val)\\n    \\t\\t\\t\\treturn true;\\n    \\t\\t\\tset.add(val);\\n    \\t\\t\\tif (i >= k)\\n    \\t\\t\\t\\tset.remove(nums[i - k]);\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 61786,
                "title": "line-10-error-cannot-find-symbol-class-entry",
                "content": "    public class Solution {\\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    \\t        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n    \\t        for(int i =0;i<nums.length;i++){\\n    \\t            Integer oldv = map.put(nums[i], i);\\n    \\t            if(null!=oldv){\\n    \\t                map.remove(nums[i]);\\n    \\t            }\\n    \\t        }\\n    \\t        Iterator<Entry<Integer, Integer>> it = map.entrySet().iterator();\\n    \\t        if(!it.hasNext()){\\n    \\t            return false;\\n    \\t        }\\n    \\t        Map.Entry<Integer, Integer> entry = it.next();\\n    \\t        int curKey = entry.getKey();\\n    \\t        int curValue = entry.getValue();\\n    \\t        while(it.hasNext()){\\n    \\t            entry = it.next();\\n    \\t            int nextKey = entry.getKey();\\n    \\t            int nextValue = entry.getValue();\\n    \\t            if((nextKey-curKey<=t)&&(nextValue-curValue<=k)){\\n    \\t                return true;\\n    \\t            }\\n    \\t            curKey = nextKey;\\n    \\t            curValue = nextValue;\\n    \\t        }\\n    \\t        return false;\\n    \\t    }\\n    }\\n\\nLine 10: error: cannot find symbol: class Entry\\n\\nWhat's wrong with my code? It could complier through in my eclipse;",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    \\t        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n    \\t        for(int i =0;i<nums.length;i++){\\n    \\t            Integer oldv = map.put(nums[i], i);\\n    \\t            if(null!=oldv){\\n    \\t                map.remove(nums[i]);\\n    \\t            }",
                "codeTag": "Java"
            },
            {
                "id": 3506903,
                "title": "java-solution-for-contains-duplicate-iii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe given code checks whether there exist two elements in the input array with a difference in their indices at most equal to indexDiff and a difference in their values at most equal to valueDiff.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check if the indexDiff is less than 1 or valueDiff is less than 0. If either condition is true, return false.\\n- Create a SortedSet called \"set\" to store the unique elements in a sorted order.\\n- Iterate over each element \"nums[j]\" in the input array.\\n- Calculate the leftBoundary and rightBoundary based on the current element and valueDiff.\\n1. The leftBoundary is (nums[j] - valueDiff), which represents the lower limit of the range within which we look for potential duplicates.\\n2. The rightBoundary is (nums[j] + valueDiff + 1), which represents the upper limit of the range.\\n- Get a subset of elements from the set that falls within the range [leftBoundary, rightBoundary). If this subset is not empty, it means we have found a pair of elements satisfying the conditions, so return true.\\n- Add the current element to the set.\\n- If the current index \"j\" is greater than or equal to indexDiff, remove the element at (j - indexDiff) index from the set.\\n1. This ensures that the window of size indexDiff is maintained, as we are only interested in elements within this window.\\n- If the loop completes without finding any suitable pairs, return false.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this solution depends on the size of the input array, which is n. The code iterates over each element once, performs operations on the SortedSet (such as adding, removing, and subsetting), which have a time complexity of O(log n), and checks if the subset is empty. Therefore, the overall time complexity is O(n log n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this solution is O(min(n, indexDiff)). The SortedSet \"set\" stores unique elements within the window of size indexDiff. In the worst case, if all elements are unique and indexDiff is equal to n, the set will store at most n elements. However, if indexDiff is smaller than n, the space usage will be limited to indexDiff elements in the set.\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        if (indexDiff < 1 || valueDiff < 0)\\n            return false;\\n        SortedSet<Long> set = new TreeSet<Long>();\\n        for (int j = 0; j < nums.length; j++) \\n        {\\n            long leftBoundary = (long) nums[j] - valueDiff;\\n            long rightBoundary = (long) nums[j] + valueDiff + 1;\\n            SortedSet<Long> subSet = set.subSet(leftBoundary, rightBoundary);\\n            if (!subSet.isEmpty())\\n                return true;\\n            set.add((long) nums[j]);\\n            if (j >= indexDiff) \\n            {\\n                set.remove((long) nums[j - indexDiff]);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        if (indexDiff < 1 || valueDiff < 0)\\n            return false;\\n        SortedSet<Long> set = new TreeSet<Long>();\\n        for (int j = 0; j < nums.length; j++) \\n        {\\n            long leftBoundary = (long) nums[j] - valueDiff;\\n            long rightBoundary = (long) nums[j] + valueDiff + 1;\\n            SortedSet<Long> subSet = set.subSet(leftBoundary, rightBoundary);\\n            if (!subSet.isEmpty())\\n                return true;\\n            set.add((long) nums[j]);\\n            if (j >= indexDiff) \\n            {\\n                set.remove((long) nums[j - indexDiff]);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2823758,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic: \\n\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int a, int b) {\\n        vector<pair<int ,int> >ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(make_pair(nums[i],i));\\n        }\\n        sort(ans.begin(),ans.end());\\n        \\n       for(int i = 0; i < ans.size(); i++){\\n            for(int j = i+1; j < ans.size(); j++){\\n                if(abs(ans[i].first - ans[j].first) <= b){\\n                    if(abs(ans[i].second - ans[j].second) <= a)\\n                        return true; \\n                } \\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n\\xA0\\xA0\\xA0\\xA0}\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic: \\n\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int a, int b) {\\n        vector<pair<int ,int> >ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            ans.push_back(make_pair(nums[i],i));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2728306,
                "title": "python-sliding-window-sorted-data-structure-and-bucket-sort-solution-with-explanation",
                "content": "\\nA brute force method is to check ```indexDiff``` elements backward every time you traverse to any location ```i```, tc is ```O(indexDiff * len(nums))```\\n\\n### sliding window + sorted data structure\\nthe basic idea is\\nuse sliding window whose size is ```indexDiff+1```(include current element), and we need a data structure to sort element of the sliding window, then we can use binary search to check if the element whose diff with current element is smaller than or equal to ```valueDiff```(binary search),\\nand tc of insertion and deletion is affordable (preferably the same time complexity as binary search, e.g., bst) -> ```SortedList```.\\n\\n```leftbound``` is an index of element which is first element is greater than or equals to current element```n``` from the window\\'s left side\\n(which is smallest element is greater than or equals to current element```n``` in the window).\\ntc is ```O(len(nums)*log(indexDiff))```, sc is ```O(indexDiff)```\\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n        window = SortedList()\\n        leng = len(nums)\\n        for idx, n in enumerate(nums):\\n\\t\\t    # remove the element whose index is invalid\\n            if idx > indexDiff:\\n                window.remove(nums[idx-indexDiff-1])\\n\\t\\t\\t# add current element to sliding window\\n            window.add(n)\\n\\t\\t\\t# find the first location of current element\\n            leftbound = window.bisect_left(n)\\n\\t\\t\\t# check if its right and left side element meet the problem requirement.\\n            if leftbound > 0 and abs(window[leftbound] - window[leftbound-1]) <= valueDiff:\\n                return True\\n            if leftbound < len(window)-1 and abs(window[leftbound+1] - window[leftbound]) <= valueDiff:\\n                return True\\n        return False\\n```\\n\\n### bucket sort\\nthe size of each bucket is ```valueDiff+1```, bucket is to check if any element meet the ```valueDiff``` condition with ```O(1)```, every buckect only contain one element, because if we find the bucket for current element has contained other element, which mean we found the answer.\\nif there is no bucket for current element, we is going to check if the element in its left and right neighbor buckect meet the ```valueDiff``` condition.\\nthen create the buckect for current element and remove invalid buckect.\\n```\\nbuckect range\\n[-1-valueDiff, -1], [0, valueDiff], [valueDiff+1, 2*valueDiff+1], ...\\ne.g. valueDiff = 3, buckect size = 3+1 = 4\\n[-4, -1], [0, 3], [4, 7], ...\\nn = 2, put to buckect [0, 3]\\nif there is any element put to this buckect, we find the answer\\n```\\n\\n\\ntc is ```O(len(nums))```, sc is ```O(indexDiff)```\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n        bucket, bucketSize = {}, valueDiff+1\\n        def getIdx(m):\\n            return m//bucketSize if m >=0 else (m+1)//bucketSize-1\\n        \\n        for idx, n in enumerate(nums):\\n\\t\\t    # find index of current buckect\\n            buckectIdx = getIdx(n)\\n\\t\\t\\t# check if current buckect exists, if so, we find the answer\\n            if buckectIdx in bucket: return True\\n\\t\\t\\t\\n\\t\\t\\t# check if the element in left and right neugnbor of current buckect meet the valueDiff condition\\n            l, r = buckectIdx-1, buckectIdx+1\\n            if l in bucket and abs(bucket[l] - n) <= valueDiff:\\n                return True\\n            if r in bucket and abs(bucket[r] - n) <= valueDiff:\\n                return True\\n\\t\\t\\t\\n\\t\\t\\t# create new buckect for current element\\n            bucket[buckectIdx] = n\\n\\t\\t\\t\\n\\t\\t\\t# remove invalid buckect which element index not meets the indexDiff condition\\n            if idx >= indexDiff:\\n                bucket.pop(getIdx(nums[idx-indexDiff]))\\n        return False\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```indexDiff```\n```i```\n```O(indexDiff * len(nums))```\n```indexDiff+1```\n```valueDiff```\n```SortedList```\n```leftbound```\n```n```\n```n```\n```O(len(nums)*log(indexDiff))```\n```O(indexDiff)```\n```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n        window = SortedList()\\n        leng = len(nums)\\n        for idx, n in enumerate(nums):\\n\\t\\t    # remove the element whose index is invalid\\n            if idx > indexDiff:\\n                window.remove(nums[idx-indexDiff-1])\\n\\t\\t\\t# add current element to sliding window\\n            window.add(n)\\n\\t\\t\\t# find the first location of current element\\n            leftbound = window.bisect_left(n)\\n\\t\\t\\t# check if its right and left side element meet the problem requirement.\\n            if leftbound > 0 and abs(window[leftbound] - window[leftbound-1]) <= valueDiff:\\n                return True\\n            if leftbound < len(window)-1 and abs(window[leftbound+1] - window[leftbound]) <= valueDiff:\\n                return True\\n        return False\\n```\n```valueDiff+1```\n```valueDiff```\n```O(1)```\n```valueDiff```\n```\\nbuckect range\\n[-1-valueDiff, -1], [0, valueDiff], [valueDiff+1, 2*valueDiff+1], ...\\ne.g. valueDiff = 3, buckect size = 3+1 = 4\\n[-4, -1], [0, 3], [4, 7], ...\\nn = 2, put to buckect [0, 3]\\nif there is any element put to this buckect, we find the answer\\n```\n```O(len(nums))```\n```O(indexDiff)```\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], indexDiff: int, valueDiff: int) -> bool:\\n        bucket, bucketSize = {}, valueDiff+1\\n        def getIdx(m):\\n            return m//bucketSize if m >=0 else (m+1)//bucketSize-1\\n        \\n        for idx, n in enumerate(nums):\\n\\t\\t    # find index of current buckect\\n            buckectIdx = getIdx(n)\\n\\t\\t\\t# check if current buckect exists, if so, we find the answer\\n            if buckectIdx in bucket: return True\\n\\t\\t\\t\\n\\t\\t\\t# check if the element in left and right neugnbor of current buckect meet the valueDiff condition\\n            l, r = buckectIdx-1, buckectIdx+1\\n            if l in bucket and abs(bucket[l] - n) <= valueDiff:\\n                return True\\n            if r in bucket and abs(bucket[r] - n) <= valueDiff:\\n                return True\\n\\t\\t\\t\\n\\t\\t\\t# create new buckect for current element\\n            bucket[buckectIdx] = n\\n\\t\\t\\t\\n\\t\\t\\t# remove invalid buckect which element index not meets the indexDiff condition\\n            if idx >= indexDiff:\\n                bucket.pop(getIdx(nums[idx-indexDiff]))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2399524,
                "title": "python-o-n-tc-o-k-sc-bucket-sort-detailed-explanation",
                "content": "The task asks us to track two conditions at the same time:\\n1. Element indices are within `k` of each other\\n2. Element values are within `t` of each other\\n\\nThe first condition leads to using the sliding window of size `k+1`. We don\\'t need to consider windows of smaller size because if a smaller list contains elements `l1` and `l2`  whose values satisfy the condition `abs(l1 - l2) <= t` then adding another element to that list wouldn\\'t make the previous expression false.\\n\\nThe second condition warrants the use of a bucket sort/pigeonhole approach, where the bucket size is `t+1`. You calculate the bucket to place a number from the input list by just dividing its value by the bucket size:\\n```\\nfor n in nums:\\n\\tidx = n // (t+1)\\n```\\nSo if a bucket with a calculated index isn\\'t empty it means that we are guaranteed to have a pair of values close enough to each other:\\n```\\nnums = [1, 12, 18, 41], t = 10, k = 2\\nidx(1) = 1 // (10 + 1) == 0\\nidx(12) = 12 // 11 = 1\\nidx(18) = 18 // 11 = 1   - the same bucket index suggests that 12 and 18 are close enough\\nidx(41) = 41 // 11 = 3\\n```\\nThere\\'s one more thing to consider. Elements from adjacent buckets might still be close enough to each other:\\n```\\nnums = [4, 43, 15, 7], t = 4, k = 3\\nidx(4) = 4 // (t+1) = 0\\nidx(7) = 7 // 5 = 1\\n\\nhowever, abs(4-7) <= t\\n```\\nThe solution is to check for adjacent buckets when inserting a new number and comparing the actual number values to verify if they are close enough.\\n\\nNow we need to combine the bucket sort and the sliding window approaches in one algorithm:\\n\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: list[int], k: int, t: int) -> bool:\\n        pigeonholes: dict[int, int] = {}\\n        segment = t + 1\\n        \\n        for i in range(len(nums)):\\n            idx = (n := nums[i]) // segment\\n            if idx in pigeonholes:\\n                return True\\n            else:\\n                pigeonholes[idx] = n\\n                if n - pigeonholes.get(idx-1, n-t-1) <= t:\\n                    return True\\n                if pigeonholes.get(idx+1, n+t+1) - n <= t:\\n                    return True\\n            \\n            if i >= k:\\n                del pigeonholes[nums[i-k] // segment]\\n        \\n        return False\\n```\\nPlease upvote this post if you found it useful \\uD83D\\uDE04",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nfor n in nums:\\n\\tidx = n // (t+1)\\n```\n```\\nnums = [1, 12, 18, 41], t = 10, k = 2\\nidx(1) = 1 // (10 + 1) == 0\\nidx(12) = 12 // 11 = 1\\nidx(18) = 18 // 11 = 1   - the same bucket index suggests that 12 and 18 are close enough\\nidx(41) = 41 // 11 = 3\\n```\n```\\nnums = [4, 43, 15, 7], t = 4, k = 3\\nidx(4) = 4 // (t+1) = 0\\nidx(7) = 7 // 5 = 1\\n\\nhowever, abs(4-7) <= t\\n```\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: list[int], k: int, t: int) -> bool:\\n        pigeonholes: dict[int, int] = {}\\n        segment = t + 1\\n        \\n        for i in range(len(nums)):\\n            idx = (n := nums[i]) // segment\\n            if idx in pigeonholes:\\n                return True\\n            else:\\n                pigeonholes[idx] = n\\n                if n - pigeonholes.get(idx-1, n-t-1) <= t:\\n                    return True\\n                if pigeonholes.get(idx+1, n+t+1) - n <= t:\\n                    return True\\n            \\n            if i >= k:\\n                del pigeonholes[nums[i-k] // segment]\\n        \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884285,
                "title": "python-bucket-sort-the-most-clear-interpretation-and-strict-math-proof",
                "content": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\t\\n\\t\\t# This problem needs a clear mathematical proof on 2 core points, that is,\\n\\t\\t# 1) \"For the nums in the same bucket, the abs of their subtraction is always <= t.\"\\n        # 2) \"For the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\n        # the abs of their subtraction is always > t.\" \\n\\t\\t# see my math proof in the last part of this page.\\n        \\n        # 3 eyes in this problem:\\n        \\n        # 1, Recall when we study bucket sort in the algorithm course,\\n        # we have some range for every bucket, and the elements in every bucket\\n        # are all in this range in some sense.\\n        \\n        # 2, The range in this problem is that, \\n        # the abs of subtraction of elements in every bucket is <= t. \\n        # So this is why we say the bucket size is t.\\n        # And this problem needs a new concept of bucket label, which can\\n        # let us control the window length within k as the problem requires.\\n        \\n        # 3, please check my mathematical proof in the last below for two core points:\\n        # 1) \"For the nums in the same bucket, the abs of their subtraction is always <= t.\"\\n        # 2) \"For the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\n        # the abs of their subtraction is always > t.\"\\n\\t\\t\\n                \\n        # key is bucket label, value is num\\n        buckets = {}\\n        \\n        for i in range(len(nums)):\\n            \\n            # get bucket label. For the nums in the same bucket, the abs of their subtraction is always <= t.\\n            bucket_label = nums[i] // (t+1)\\n            \\n            \\n            # if this label had appeared before, this means the current num will go into this bucket\\n            # and by \"For the nums in the same bucket, the abs of their subtraction is always <= t.\",\\n            # it will return True since index is the same, and the abs of their subtraction is <= t.\\n            # check my strict mathematical proof below on\\n            # why \"For the nums in the same bucket, the abs of their subtraction is always <= t.\"\\n            if bucket_label in buckets:\\n                return True\\n            \\n            \\n            # if the current label has not appeared, add this new bucket with label\\n            buckets[bucket_label] = nums[i]\\n            \\n            \\n            # check the adjacent neighbor with only 1 label difference\\n            # check my strict mathematical proof below on\\n            # why \"For the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\n            # the abs of their subtraction is always > t.\"\\n\\t\\t\\t# So we do not need to check the case that the label difference is greater than or equal to 2.\\n            if bucket_label - 1 in buckets and abs(buckets[bucket_label - 1] - nums[i]) <= t:\\n                return True            \\n            if bucket_label + 1 in buckets and abs(buckets[bucket_label + 1] - nums[i]) <= t:\\n                return True \\n            \\n            \\n            # note we have a window.\\n            # update the window when the window length > k, our windows is fixed as k\\n            if i >= k:\\n                del buckets[nums[i-k] // (t+1)]\\n                \\n        \\n        return False\\n\\n    \\n    \\n\"\"\"\\nClaim 1: Under the operation nums[i] // (t+1), \\nfor the nums in the same bucket, the abs of their subtraction is always <= t.\\n\\n\\nProof. Suppose x and y are the nums in the same bucket label, and suppose\\n                 \\n                 x // (t+1) = a,    x % (t+1) = b,                 \\n                 y // (t+1) = c,    y % (t+1) = d,\\n\\nwhere 0 <= b < t+1,  0 <= d < t+1.  \\n(Understand here by for example 15 % 1, 15 % 2, 15 % 3, 15 % 4, 15 % 5 again. \\nthe remainder is 0, 1, 2, 3, 0 and never exceeds divisor). \\n\\nThen we know that \\n                \\n                 x = a(t+1) + b,    y = c(t+1) + d.\\n\\nThus, we need to show\\n                \\n                 |x - y| <= t for any t >= 0.\\n\\nIndeed,\\n    \\n                 |x - y| = |a(t+1) + b - c(t+1) - d|\\n                         = |(a-c)(t+1) + (b-d)|        (note here a = c since we have the same label)\\n                         = |b - d|                     (1)\\n\\nSince 0 <= b < t+1,  0 <= d < t+1,  we get\\n                 \\n                     0 <= b < t+1,\\n                  -t-1 < -d <= 0,\\n                  -t-1 < b - d < t+1,\\n                        |b - d| < t+1.                 (2)       \\n\\nTaking (2) into (1), we finally get\\n\\n                |x - y| = |b - d| < t + 1,            \\n           ---> |x - y| <= t.                          (since t >= 0 is an integer, so < t + 1 means <= t). \\n\\nThis finishes the proof of this claim.\\n\\n\\n\\n\\n\\n\\nClaim 2: Under the operation nums[i] // (t+1), \\nfor the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\nthe abs of their subtraction is always > t.\\n\\n\\nProof. Suppose x and y are the nums in two buckets with only 2 or more than 2 label difference, \\nand suppose\\n                 \\n                 x // (t+1) = a,    x % (t+1) = b,                 \\n                 y // (t+1) = c,    y % (t+1) = d,\\n\\nwhere 0 <= b < t+1,  0 <= d < t+1, and \"with only 2 or more than 2 label difference\" means \\n                \\n                    |a - c| >= 2.                       (3)\\n\\nThen we know that \\n                \\n                 x = a(t+1) + b,    y = c(t+1) + d.\\n\\nThus, we need to show\\n                \\n                 |x - y| > t for any t >= 0.\\n\\nIndeed,\\n    \\n                 |x - y| = |a(t+1) + b - c(t+1) - d|\\n                         = |(a-c)(t+1) + (b-d)|        (note here |a-c| >= 2 by (3))\\n                        >= | |(a-c)(t+1)| - |b-d| |,    (4)\\n\\nwhere we have used the triangle inequality |p+q| >= | |p|-|q| | in the last step. \\n\\nBy (2) in Claim 1 and (3), from (4), we get\\n\\n                 |a-c|(t+1) - |b-d| > (|a-c|-1) (t+1) >= (2-1)(t+1) > 0.\\n\\nSo we can strip the absolute value in (4). When |(a-c)(t+1)| - |b-d| > 0, by (3), using (2) in Claim 1, (4) gives\\n\\n                 |x - y| >= |a-c||t+1| - |b-d|\\n                          > 2(t+1) - (t+1)\\n                          = t + 1\\n                          > t.\\n\\nThis finishes the proof of the claim.\\n\"\"\"  \\n```",
                "solutionTags": [
                    "Python",
                    "Bucket Sort"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\t\\n\\t\\t# This problem needs a clear mathematical proof on 2 core points, that is,\\n\\t\\t# 1) \"For the nums in the same bucket, the abs of their subtraction is always <= t.\"\\n        # 2) \"For the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\n        # the abs of their subtraction is always > t.\" \\n\\t\\t# see my math proof in the last part of this page.\\n        \\n        # 3 eyes in this problem:\\n        \\n        # 1, Recall when we study bucket sort in the algorithm course,\\n        # we have some range for every bucket, and the elements in every bucket\\n        # are all in this range in some sense.\\n        \\n        # 2, The range in this problem is that, \\n        # the abs of subtraction of elements in every bucket is <= t. \\n        # So this is why we say the bucket size is t.\\n        # And this problem needs a new concept of bucket label, which can\\n        # let us control the window length within k as the problem requires.\\n        \\n        # 3, please check my mathematical proof in the last below for two core points:\\n        # 1) \"For the nums in the same bucket, the abs of their subtraction is always <= t.\"\\n        # 2) \"For the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\n        # the abs of their subtraction is always > t.\"\\n\\t\\t\\n                \\n        # key is bucket label, value is num\\n        buckets = {}\\n        \\n        for i in range(len(nums)):\\n            \\n            # get bucket label. For the nums in the same bucket, the abs of their subtraction is always <= t.\\n            bucket_label = nums[i] // (t+1)\\n            \\n            \\n            # if this label had appeared before, this means the current num will go into this bucket\\n            # and by \"For the nums in the same bucket, the abs of their subtraction is always <= t.\",\\n            # it will return True since index is the same, and the abs of their subtraction is <= t.\\n            # check my strict mathematical proof below on\\n            # why \"For the nums in the same bucket, the abs of their subtraction is always <= t.\"\\n            if bucket_label in buckets:\\n                return True\\n            \\n            \\n            # if the current label has not appeared, add this new bucket with label\\n            buckets[bucket_label] = nums[i]\\n            \\n            \\n            # check the adjacent neighbor with only 1 label difference\\n            # check my strict mathematical proof below on\\n            # why \"For the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\n            # the abs of their subtraction is always > t.\"\\n\\t\\t\\t# So we do not need to check the case that the label difference is greater than or equal to 2.\\n            if bucket_label - 1 in buckets and abs(buckets[bucket_label - 1] - nums[i]) <= t:\\n                return True            \\n            if bucket_label + 1 in buckets and abs(buckets[bucket_label + 1] - nums[i]) <= t:\\n                return True \\n            \\n            \\n            # note we have a window.\\n            # update the window when the window length > k, our windows is fixed as k\\n            if i >= k:\\n                del buckets[nums[i-k] // (t+1)]\\n                \\n        \\n        return False\\n\\n    \\n    \\n\"\"\"\\nClaim 1: Under the operation nums[i] // (t+1), \\nfor the nums in the same bucket, the abs of their subtraction is always <= t.\\n\\n\\nProof. Suppose x and y are the nums in the same bucket label, and suppose\\n                 \\n                 x // (t+1) = a,    x % (t+1) = b,                 \\n                 y // (t+1) = c,    y % (t+1) = d,\\n\\nwhere 0 <= b < t+1,  0 <= d < t+1.  \\n(Understand here by for example 15 % 1, 15 % 2, 15 % 3, 15 % 4, 15 % 5 again. \\nthe remainder is 0, 1, 2, 3, 0 and never exceeds divisor). \\n\\nThen we know that \\n                \\n                 x = a(t+1) + b,    y = c(t+1) + d.\\n\\nThus, we need to show\\n                \\n                 |x - y| <= t for any t >= 0.\\n\\nIndeed,\\n    \\n                 |x - y| = |a(t+1) + b - c(t+1) - d|\\n                         = |(a-c)(t+1) + (b-d)|        (note here a = c since we have the same label)\\n                         = |b - d|                     (1)\\n\\nSince 0 <= b < t+1,  0 <= d < t+1,  we get\\n                 \\n                     0 <= b < t+1,\\n                  -t-1 < -d <= 0,\\n                  -t-1 < b - d < t+1,\\n                        |b - d| < t+1.                 (2)       \\n\\nTaking (2) into (1), we finally get\\n\\n                |x - y| = |b - d| < t + 1,            \\n           ---> |x - y| <= t.                          (since t >= 0 is an integer, so < t + 1 means <= t). \\n\\nThis finishes the proof of this claim.\\n\\n\\n\\n\\n\\n\\nClaim 2: Under the operation nums[i] // (t+1), \\nfor the nums in the adjacent neighbor with only 2 or more than 2 label difference, \\nthe abs of their subtraction is always > t.\\n\\n\\nProof. Suppose x and y are the nums in two buckets with only 2 or more than 2 label difference, \\nand suppose\\n                 \\n                 x // (t+1) = a,    x % (t+1) = b,                 \\n                 y // (t+1) = c,    y % (t+1) = d,\\n\\nwhere 0 <= b < t+1,  0 <= d < t+1, and \"with only 2 or more than 2 label difference\" means \\n                \\n                    |a - c| >= 2.                       (3)\\n\\nThen we know that \\n                \\n                 x = a(t+1) + b,    y = c(t+1) + d.\\n\\nThus, we need to show\\n                \\n                 |x - y| > t for any t >= 0.\\n\\nIndeed,\\n    \\n                 |x - y| = |a(t+1) + b - c(t+1) - d|\\n                         = |(a-c)(t+1) + (b-d)|        (note here |a-c| >= 2 by (3))\\n                        >= | |(a-c)(t+1)| - |b-d| |,    (4)\\n\\nwhere we have used the triangle inequality |p+q| >= | |p|-|q| | in the last step. \\n\\nBy (2) in Claim 1 and (3), from (4), we get\\n\\n                 |a-c|(t+1) - |b-d| > (|a-c|-1) (t+1) >= (2-1)(t+1) > 0.\\n\\nSo we can strip the absolute value in (4). When |(a-c)(t+1)| - |b-d| > 0, by (3), using (2) in Claim 1, (4) gives\\n\\n                 |x - y| >= |a-c||t+1| - |b-d|\\n                          > 2(t+1) - (t+1)\\n                          = t + 1\\n                          > t.\\n\\nThis finishes the proof of the claim.\\n\"\"\"  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1114477,
                "title": "it-works-and-that-s-enough-for-me-python",
                "content": "Feast your eyes on this.\\n\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        # make a new list of nums that has the following properties\\n        # 1. each item is a tuple of (index, value)\\n        # 2. it\\'s sorted on value\\n        # create two pointers i & j that start at element 0 and 1\\n        # advance j when values are in valid range (<=t) otherwise advance i\\n        # because the list is sorted we can advance i moderately fast\\n        nums = sorted(enumerate(nums), key=lambda x: x[1])\\n        i    = 0\\n        j    = 1\\n        try:\\n            while True:\\n                # check if values in required range\\n                if abs(nums[j][1] - nums[i][1]) <= t:\\n                    # if they are check if indices are in required range\\n                    if abs(nums[j][0] - nums[i][0]) <= k:\\n                        # if so return True\\n                        return True\\n                    j += 1\\n                else:\\n                    i += 1\\n                    j = i + 1\\n        except:\\n            return False\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        # make a new list of nums that has the following properties\\n        # 1. each item is a tuple of (index, value)\\n        # 2. it\\'s sorted on value\\n        # create two pointers i & j that start at element 0 and 1\\n        # advance j when values are in valid range (<=t) otherwise advance i\\n        # because the list is sorted we can advance i moderately fast\\n        nums = sorted(enumerate(nums), key=lambda x: x[1])\\n        i    = 0\\n        j    = 1\\n        try:\\n            while True:\\n                # check if values in required range\\n                if abs(nums[j][1] - nums[i][1]) <= t:\\n                    # if they are check if indices are in required range\\n                    if abs(nums[j][0] - nums[i][0]) <= k:\\n                        # if so return True\\n                        return True\\n                    j += 1\\n                else:\\n                    i += 1\\n                    j = i + 1\\n        except:\\n            return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983596,
                "title": "simple-c-o-n-log-k-using-multiset-and-no-lower-bound-used",
                "content": "Simple C++, using multiset , no lower_bound() needed:\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        multiset<int> data;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (data.size() >= k + 1) {\\n                data.erase(data.find(nums[i - k - 1]));\\n            }\\n            multiset<int>::iterator it = data.insert(nums[i]);\\n            if (it != data.begin()) {\\n                --it;\\n                if ((long long)nums[i] - *it <= t)\\n                    return true;\\n                ++it;\\n            }\\n            ++it;\\n            if (it != data.end()) {\\n                if ((long long)*it - nums[i] <= t)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        multiset<int> data;\\n        for (int i = 0; i < nums.size(); ++i) {\\n            if (data.size() >= k + 1) {\\n                data.erase(data.find(nums[i - k - 1]));\\n            }\\n            multiset<int>::iterator it = data.insert(nums[i]);\\n            if (it != data.begin()) {\\n                --it;\\n                if ((long long)nums[i] - *it <= t)\\n                    return true;\\n                ++it;\\n            }\\n            ++it;\\n            if (it != data.end()) {\\n                if ((long long)*it - nums[i] <= t)\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};```",
                "codeTag": "Java"
            },
            {
                "id": 786359,
                "title": "using-c-set",
                "content": "The main thing in the question is to just find a suitable ele in window of size k which lies within a ceratin range,\\n& this task can be optimized by using a set which will do this task of finding ele in certain range in O(logk) (as set at max can contain only k elements at a time)\\n\\n**Below is some techniques, on how to find elemens withing a certain range->** \\nYou can use lower_bound and upper_bound together. Your example of testing for elements between 3 and 5, inclusive, could be written as follows:\\n* bool contains_elements_in_range = s.lower_bound(3) != s.upper_bound(5);\\n\\nYou can make the range inclusive or exclusive on either end by switching which function you are using (upper_bound or lower_bound):\\n*  s.upper_bound(2) != s.upper_bound(5); // Tests (2, 5] \\n* s.lower_bound(3) != s.lower_bound(6); // Tests [3, 6) \\n*  s.upper_bound(2) != s.lower_bound(6); // Tests (2, 6)\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        \\n        int n=nums.size();\\n        if(n==0 || t<0){\\n            return false;\\n        }\\n        \\n        vector<long long> v(nums.begin(),nums.end());\\n        set<long long> s;\\n        s.insert(v[n-1]);\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(i+k+1<n){\\n                s.erase(s.find(v[i+k+1]));\\n            }\\n           //cout<<\"hello\"<<endl;\\n\\t\\t   //our task is to find v[j] such that v[j] lies in range [v[i]-t,v[i]+t]\\n            bool ele_in_range = (s.lower_bound(v[i]-t) != s.upper_bound(v[i]+t));\\n               if(ele_in_range){\\n                   return true;\\n               }\\n            s.insert(v[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        \\n        int n=nums.size();\\n        if(n==0 || t<0){\\n            return false;\\n        }\\n        \\n        vector<long long> v(nums.begin(),nums.end());\\n        set<long long> s;\\n        s.insert(v[n-1]);\\n        \\n        for(int i=n-2;i>=0;i--){\\n            if(i+k+1<n){\\n                s.erase(s.find(v[i+k+1]));\\n            }\\n           //cout<<\"hello\"<<endl;\\n\\t\\t   //our task is to find v[j] such that v[j] lies in range [v[i]-t,v[i]+t]\\n            bool ele_in_range = (s.lower_bound(v[i]-t) != s.upper_bound(v[i]+t));\\n               if(ele_in_range){\\n                   return true;\\n               }\\n            s.insert(v[i]);\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 776655,
                "title": "java-treeset-uses-floor-and-ceiling-logic",
                "content": "```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Long> set = new TreeSet<>();\\n        for(int i=0; i<nums.length; i++) {\\n            Long floor = set.floor((long) nums[i]);\\n            if(floor != null && nums[i] - floor <= t)\\n                return true;\\n            \\n            Long ceiling = set.ceiling((long) nums[i]);\\n            if(ceiling != null && ceiling - nums[i] <= t)\\n                return true;\\n            \\n            set.add((long) nums[i]);\\n            if(set.size() > k)\\n                set.remove((long) nums[i - k]);\\n        }\\n        return false;\\n}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\npublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Long> set = new TreeSet<>();\\n        for(int i=0; i<nums.length; i++) {\\n            Long floor = set.floor((long) nums[i]);\\n            if(floor != null && nums[i] - floor <= t)\\n                return true;\\n            \\n            Long ceiling = set.ceiling((long) nums[i]);\\n            if(ceiling != null && ceiling - nums[i] <= t)\\n                return true;\\n            \\n            set.add((long) nums[i]);\\n            if(set.size() > k)\\n                set.remove((long) nums[i - k]);\\n        }\\n        return false;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 743853,
                "title": "javascript-o-n-bucketsort-hashmap-explanation",
                "content": "```\\n// Common explanation of algorithm (Bucket sort + HashMap):\\n//1. Assume that we will divide nums range on t+1 buckets\\n//2. It means that Max differense between nums in one bucket is t\\n//3. It means that nums[i] and nums[j] which difference is at most \\'t\\' can be in the same or neighboring buckets\\n//4. Next in the loop we will find current BucketID = nums[i]/t+1\\n//5. Then chek it in map, chek neighboring buckets and compare condition about absolute difference between i and j is at most k\\n//6. Then delete from map buckets out of range\\n\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    \\n    if (k < 1 || t < 0) return false;\\n    \\n    const map = new Map();\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        \\n        let bucket = Math.floor(nums[i] / (t+1));  \\n        \\n        if (map.has(bucket)) return true;\\n        if (map.has(bucket-1) && Math.abs(nums[i]-map.get(bucket-1)) <= t) return true;\\n        if (map.has(bucket+1) && Math.abs(map.get(bucket+1)-nums[i]) <= t) return true;\\n                       \\n        if (map.size >= k) {\\n            let outsideBucket = Math.floor((nums[i-k]) / (t+1));\\n            map.delete(outsideBucket);\\n        }\\n        \\n        map.set(bucket, nums[i]);\\n    }\\n    \\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// Common explanation of algorithm (Bucket sort + HashMap):\\n//1. Assume that we will divide nums range on t+1 buckets\\n//2. It means that Max differense between nums in one bucket is t\\n//3. It means that nums[i] and nums[j] which difference is at most \\'t\\' can be in the same or neighboring buckets\\n//4. Next in the loop we will find current BucketID = nums[i]/t+1\\n//5. Then chek it in map, chek neighboring buckets and compare condition about absolute difference between i and j is at most k\\n//6. Then delete from map buckets out of range\\n\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    \\n    if (k < 1 || t < 0) return false;\\n    \\n    const map = new Map();\\n    \\n    for (let i = 0; i < nums.length; i++) {\\n        \\n        let bucket = Math.floor(nums[i] / (t+1));  \\n        \\n        if (map.has(bucket)) return true;\\n        if (map.has(bucket-1) && Math.abs(nums[i]-map.get(bucket-1)) <= t) return true;\\n        if (map.has(bucket+1) && Math.abs(map.get(bucket+1)-nums[i]) <= t) return true;\\n                       \\n        if (map.size >= k) {\\n            let outsideBucket = Math.floor((nums[i-k]) / (t+1));\\n            map.delete(outsideBucket);\\n        }\\n        \\n        map.set(bucket, nums[i]);\\n    }\\n    \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 400978,
                "title": "very-simple-and-clean-solution-on-java-72-47",
                "content": "\\tThe sloution is based on the \"Sliding Window\" technique. We need to track the **range** of k numbers in the tree because the \\n\\tdifference of indexes should be in range <= k. Thus, keep track only k numbers in the tree. After k numbers, move the window \\n\\tby one iteration, delete the first number from the tree because it is no longer in the range of the k (recall the requirement of indexes |i-j| <= k).\\n\\tThen, add new number, check if there is a number |a-b| <= t in the tree. Recall, Red-Black tree makes search operation \\n\\tin O(log(k)) time complexity, hence, take the \"TreeSet\" or \"TreeMap\"(based on the Red-Black tree)  on this case. \\n\\tIn conclusion, the time complexity is nlog(k), space complexity is O(k). Here, log(k) is every operation on Red-Black tree, \\n\\tn - size of the array, number of operations.\\n\\t\\n\\tpublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\t\\tif (t < 0) {\\n\\t\\t  return false;\\n\\t\\t}\\n\\n\\t\\tTreeSet<Integer> set = new TreeSet<>();\\n\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t  // initially we fill the tree set (red black tree) with first k numbers\\n\\t\\t  // after k characters we need to delete the first number, because we move the window\\n\\t\\t  // according the requirements |i-j| <= k\\n\\t\\t  if (i > k) {\\n\\t\\t\\tset.remove(nums[i - k - 1]);\\n\\t\\t  }\\n\\n\\t\\t  // if tree has already such number, recall |a-b| <= k, here a=a, logically we get difference zero\\n\\t\\t  if (set.contains(nums[i])) {\\n\\t\\t\\treturn true;\\n\\t\\t  }\\n\\n\\t\\t  if (t > 0) {\\n\\t\\t    // we need to find the max from smallest number so that difference <= k\\n\\t\\t\\t// also include the case when the number could be negative or bigger\\n\\t\\t\\tInteger lowerKey = set.lower(nums[i]);\\n\\t\\t\\tInteger higherKey = set.higher(nums[i]);\\n\\n\\t\\t\\tif ((lowerKey != null && Math.abs((long) lowerKey - nums[i]) <= t) ||\\n\\t\\t\\t\\t(higherKey != null && Math.abs((long) higherKey - nums[i]) <= t)) {\\n\\t\\t\\t  return true;\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t  \\n\\t\\t  set.add(nums[i]);\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t  }",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "\\tThe sloution is based on the \"Sliding Window\" technique. We need to track the **range** of k numbers in the tree because the \\n\\tdifference of indexes should be in range <= k. Thus, keep track only k numbers in the tree. After k numbers, move the window \\n\\tby one iteration, delete the first number from the tree because it is no longer in the range of the k (recall the requirement of indexes |i-j| <= k).\\n\\tThen, add new number, check if there is a number |a-b| <= t in the tree. Recall, Red-Black tree makes search operation \\n\\tin O(log(k)) time complexity, hence, take the \"TreeSet\" or \"TreeMap\"(based on the Red-Black tree)  on this case. \\n\\tIn conclusion, the time complexity is nlog(k), space complexity is O(k). Here, log(k) is every operation on Red-Black tree, \\n\\tn - size of the array, number of operations.\\n\\t\\n\\tpublic boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\t\\tif (t < 0) {\\n\\t\\t  return false;\\n\\t\\t}\\n\\n\\t\\tTreeSet<Integer> set = new TreeSet<>();\\n\\n\\t\\tfor (int i = 0; i < nums.length; i++) {\\n\\t\\t  // initially we fill the tree set (red black tree) with first k numbers\\n\\t\\t  // after k characters we need to delete the first number, because we move the window\\n\\t\\t  // according the requirements |i-j| <= k\\n\\t\\t  if (i > k) {\\n\\t\\t\\tset.remove(nums[i - k - 1]);\\n\\t\\t  }\\n\\n\\t\\t  // if tree has already such number, recall |a-b| <= k, here a=a, logically we get difference zero\\n\\t\\t  if (set.contains(nums[i])) {\\n\\t\\t\\treturn true;\\n\\t\\t  }\\n\\n\\t\\t  if (t > 0) {\\n\\t\\t    // we need to find the max from smallest number so that difference <= k\\n\\t\\t\\t// also include the case when the number could be negative or bigger\\n\\t\\t\\tInteger lowerKey = set.lower(nums[i]);\\n\\t\\t\\tInteger higherKey = set.higher(nums[i]);\\n\\n\\t\\t\\tif ((lowerKey != null && Math.abs((long) lowerKey - nums[i]) <= t) ||\\n\\t\\t\\t\\t(higherKey != null && Math.abs((long) higherKey - nums[i]) <= t)) {\\n\\t\\t\\t  return true;\\n\\t\\t\\t}\\n\\t\\t  }\\n\\t\\t  \\n\\t\\t  set.add(nums[i]);\\n\\t\\t}\\n\\n\\t\\treturn false;\\n\\t  }",
                "codeTag": "Unknown"
            },
            {
                "id": 141084,
                "title": "python-sliding-window-and-bucket",
                "content": "```\\nclass Solution(object):\\n\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        if t < 0: # Input sanity check\\n            return False\\n        buckets = {}\\n        for i in xrange(0, len(nums)):\\n            m = nums[i] / (t+1)\\n            if m in buckets:\\n                return True\\n            if m-1 in buckets and abs(nums[i] - buckets[m-1]) <= t:\\n                return True\\n            if m+1 in buckets and abs(nums[i] - buckets[m+1]) <= t:\\n                return True\\n            buckets[m] = nums[i]\\n            if i - k >= 0:\\n                m_pop = nums[i-k] / (t+1)\\n                buckets.pop(m_pop, None)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        if t < 0: # Input sanity check\\n            return False\\n        buckets = {}\\n        for i in xrange(0, len(nums)):\\n            m = nums[i] / (t+1)\\n            if m in buckets:\\n                return True\\n            if m-1 in buckets and abs(nums[i] - buckets[m-1]) <= t:\\n                return True\\n            if m+1 in buckets and abs(nums[i] - buckets[m+1]) <= t:\\n                return True\\n            buckets[m] = nums[i]\\n            if i - k >= 0:\\n                m_pop = nums[i-k] / (t+1)\\n                buckets.pop(m_pop, None)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61717,
                "title": "java-solution-10-12ms-bit-97-65-97-27",
                "content": "```\\npublic class Solution {\\n    TreeNode root = null;\\n    boolean flag = false;\\n\\n    /**\\n     * I think a lot time, but I still can deal with it in my way.\\n     * So I see this hint tags: binary search tree, so I try below method to solve.\\n     * <p>\\n     * <strong>result of test:</strong><br/>\\n     * 31 / 31 test cases passed\\n     * Status: Accepted\\n     * Runtime: 10 - 12ms, bit 97.65 - 97.27%\\n     * \\n     * @param nums\\n     * @param k\\n     * @param t\\n     * @return\\n     */\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > k) {\\n                root = delete(root, nums[i - k - 1]);\\n            }\\n            root = insert(root, nums[i], t);\\n            if (flag) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n\\n    public TreeNode insert(TreeNode root, int num, int t) {\\n        if (root == null) {\\n            TreeNode curNode = new TreeNode(num);\\n            return curNode;\\n        }\\n\\n        if (Math.abs((long) (root.val - num)) <= t) {\\n            flag = true;\\n            return root;\\n        }\\n\\n        if (root.val < num) {\\n            root.right = insert(root.right, num, t);\\n        } else if (root.val > num) {\\n            root.left = insert(root.left, num, t);\\n        }\\n\\n        return root;\\n    }\\n\\n    public TreeNode delete(TreeNode root, int num) {\\n        if (root == null) return null;\\n\\n        if (root.val < num) {\\n            root.right = delete(root.right, num);\\n        } else if (root.val > num) {\\n            root.left = delete(root.left, num);\\n        } else {\\n            if (root.left == null || root.right == null) {\\n                return root.left == null ? root.right : root.left;\\n            } else {\\n                //this sense that left and right is none null\\n                //this is a easy method to deal with it.\\n                //that exchange the root val with the min or max node\\n                root.val = findMin(root.right).val;\\n                root.right = delete(root.right, root.val);\\n            }\\n        }\\n\\n        return root;\\n    }\\n\\n    public TreeNode findMin(TreeNode node) {\\n        if (node == null) return null;\\n        while (node.left != null) {\\n            node = node.left;\\n        }\\n        return node;\\n    }\\n\\n    class TreeNode {\\n        /**\\n         * \\u6570\\u8282\\u70b9\\u503c\\n         */\\n        public int val;\\n        /**\\n         * \\u5de6\\u5b50\\u6811\\n         */\\n        public TreeNode left;\\n        /**\\n         * \\u53f3\\u5b50\\u6811\\n         */\\n        public TreeNode right;\\n\\n        public TreeNode(int x) {\\n            val = x;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    TreeNode root = null;\\n    boolean flag = false;\\n\\n    /**\\n     * I think a lot time, but I still can deal with it in my way.\\n     * So I see this hint tags: binary search tree, so I try below method to solve.\\n     * <p>\\n     * <strong>result of test:</strong><br/>\\n     * 31 / 31 test cases passed\\n     * Status: Accepted\\n     * Runtime: 10 - 12ms, bit 97.65 - 97.27%\\n     * \\n     * @param nums\\n     * @param k\\n     * @param t\\n     * @return\\n     */\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            if (i > k) {\\n                root = delete(root, nums[i - k - 1]);\\n            }\\n            root = insert(root, nums[i], t);\\n            if (flag) return true;\\n        }\\n\\n        return false;\\n    }\\n\\n\\n    public TreeNode insert(TreeNode root, int num, int t) {\\n        if (root == null) {\\n            TreeNode curNode = new TreeNode(num);\\n            return curNode;\\n        }\\n\\n        if (Math.abs((long) (root.val - num)) <= t) {\\n            flag = true;\\n            return root;\\n        }\\n\\n        if (root.val < num) {\\n            root.right = insert(root.right, num, t);\\n        } else if (root.val > num) {\\n            root.left = insert(root.left, num, t);\\n        }\\n\\n        return root;\\n    }\\n\\n    public TreeNode delete(TreeNode root, int num) {\\n        if (root == null) return null;\\n\\n        if (root.val < num) {\\n            root.right = delete(root.right, num);\\n        } else if (root.val > num) {\\n            root.left = delete(root.left, num);\\n        } else {\\n            if (root.left == null || root.right == null) {\\n                return root.left == null ? root.right : root.left;\\n            } else {\\n                //this sense that left and right is none null\\n                //this is a easy method to deal with it.\\n                //that exchange the root val with the min or max node\\n                root.val = findMin(root.right).val;\\n                root.right = delete(root.right, root.val);\\n            }\\n        }\\n\\n        return root;\\n    }\\n\\n    public TreeNode findMin(TreeNode node) {\\n        if (node == null) return null;\\n        while (node.left != null) {\\n            node = node.left;\\n        }\\n        return node;\\n    }\\n\\n    class TreeNode {\\n        /**\\n         * \\u6570\\u8282\\u70b9\\u503c\\n         */\\n        public int val;\\n        /**\\n         * \\u5de6\\u5b50\\u6811\\n         */\\n        public TreeNode left;\\n        /**\\n         * \\u53f3\\u5b50\\u6811\\n         */\\n        public TreeNode right;\\n\\n        public TreeNode(int x) {\\n            val = x;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61701,
                "title": "simple-and-elegant-c-20ms-solution-easy-to-understand",
                "content": "    class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            vector<pair<int, int>> a;\\n            for(int i = 0; i < nums.size(); ++i){\\n                a.push_back(make_pair(nums[i], i));\\n            }\\n            sort(a.begin(), a.end(), [](const pair<int, int> & a, const pair<int, int> & b)->bool{ return a.first < b.first; });\\n            int fast = 0, slow = 0;\\n            for(fast = 1; fast < nums.size(); ++fast){\\n                while((long long)a[fast].first - a[slow].first > t) ++slow;\\n                for(int i = slow; i < fast; ++i){\\n                    if(abs(a[i].second - a[fast].second) <= k) return 1;\\n                }\\n            }\\n            return 0;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            vector<pair<int, int>> a;\\n            for(int i = 0; i < nums.size(); ++i){\\n                a.push_back(make_pair(nums[i], i));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 61651,
                "title": "o-nlgk-solution-using-binary-search-tree-java",
                "content": "public class Solution {\\n    class TreeNode{\\n        long val;\\n        TreeNode left;\\n        TreeNode right;\\n        public TreeNode(long x) {\\n            val = x;\\n        }\\n    }\\n    \\n    private TreeNode add(TreeNode root, TreeNode nNode) {\\n        if(root == null) {\\n            return nNode;\\n        }\\n        else if(root.val < nNode.val) {\\n            root.right = add(root.right, nNode);\\n            return root;\\n        }\\n        else {\\n            root.left = add(root.left, nNode);\\n            return root;\\n        }\\n    }\\n\\n    private TreeNode delete(TreeNode root, TreeNode dNode) {\\n        if(root == null) {\\n            return null;\\n        }\\n        else if(root.val < dNode.val) {\\n            root.right = delete(root.right, dNode);\\n            return root;\\n        }\\n        else if(root.val > dNode.val) {\\n            root.left = delete(root.left, dNode);\\n            return root;\\n        }\\n        else if(root == dNode) {\\n             if(dNode.left == null && dNode.right == null) return null;\\n             else if(dNode.left != null && dNode.right == null) return dNode.left;\\n             else if(dNode.right != null && dNode.left == null) return dNode.right;\\n             else {\\n                 TreeNode p = dNode.right;\\n                 while(p.left != null) p = p.left;\\n                 dNode.right = delete(dNode.right, p);\\n                 p.left = dNode.left;\\n                 p.right = dNode.right;\\n                 return p;\\n             }\\n        }\\n        else {\\n            return root;\\n        }\\n    }\\n\\n    private boolean search(TreeNode root, long val, int t) {\\n        if(root == null) {\\n            return false;\\n        }\\n        else if(Math.abs((root.val - val)) <= t) {\\n            return true;\\n        }\\n        else if((root.val - val) > t) {\\n            return search(root.left, val, t);\\n        }\\n        else {\\n            return search(root.right, val, t);\\n        }\\n    }\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if(k < 1 || t < 0 || nums.length <= 1) {\\n            return false;\\n        }\\n        int len = nums.length;\\n        TreeNode[] map = new TreeNode[len];\\n        map[0] = new TreeNode((long)nums[0]);\\n        TreeNode root = null;\\n        root = add(root, map[0]);\\n        for(int i = 1; i < len; i++) {\\n            if(search(root, (long)nums[i], t)) {\\n                return true;\\n            }\\n            map[i] = new TreeNode((long)nums[i]);\\n            if(i - k >= 0) {\\n                root = delete(root, map[i-k]);\\n            }\\n            root = add(root, map[i]);\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    class TreeNode{\\n        long val;\\n        TreeNode left;\\n        TreeNode right;\\n        public TreeNode(long x) {\\n            val = x;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 61715,
                "title": "ac-java-solution-using-subset",
                "content": "\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    /*handle special case*/\\n        if(nums.length <= 1 || t < 0 || k < 1) {return false;}\\n        TreeSet<Long> set = new TreeSet<Long>();\\n        for(int i = 0; i < nums.length; i++){\\n            long min = Math.min((long)nums[i] - t,(long)nums[i] + t + 1);\\n            long max = Math.max((long)nums[i] - t, (long)nums[i] + t + 1);\\n        /*1.if the subset is not empty, means that we have the element that satisfy the requirement \\n          2.if we cannot add the element to the set, that means we already have the element*/\\n            if(!set.subSet(min,max).isEmpty() || !set.add((long)nums[i])) {return true;}\\n            set.add((long)nums[i]);\\n            if(i >= k) {set.remove((long)nums[i - k]);}\\n        }\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n    /*handle special case*/\\n        if(nums.length <= 1 || t < 0 || k < 1) {return false;}\\n        TreeSet<Long> set = new TreeSet<Long>();\\n        for(int i = 0; i < nums.length; i++){\\n            long min = Math.min((long)nums[i] - t,(long)nums[i] + t + 1);\\n            long max = Math.max((long)nums[i] - t, (long)nums[i] + t + 1);\\n        /*1.if the subset is not empty, means that we have the element that satisfy the requirement \\n          2.if we cannot add the element to the set, that means we already have the element*/\\n            if(!set.subSet(min,max).isEmpty() || !set.add((long)nums[i])) {return true;}\\n            set.add((long)nums[i]);\\n            if(i >= k) {set.remove((long)nums[i - k]);}\\n        }\\n        return false;\\n    }\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 61729,
                "title": "java-treeset-26-ms-solution-optimized-with-a-custom-comparator",
                "content": "The problem with TreeSet solutions is not only that they are O(n log k) when there are O(n) solutions, but also that they search multiple times for the same value. Consider a typical `floor / ceiling` solution: first it checks for `floor` and `ceiling`, then it inserts the new value, and each of those operations is basically a search for the same value! How can we deal with that?\\n\\nOne idea is to perform the search once, finding the floor, ceiling and insertion point at the same time. Moreover, if the floor or the ceiling are too close, we don't even want to continue the search: we can return true immediately. But how do we do this?\\n\\nOne way is to create a custom BST implementation. This can get ugly especially if you do RBT rebalancing. But there is a smarter way. Note that `TreeSet` doesn't insert a value if there is already such value in the set (it is a set, after all). What if we want to achieve the same effect when the value is not exactly equal to some other, but almost equal (within the margin of `t`)? Why not trick it into thinking that these values are indeed equal? Especially since the docs openly state that `TreeSet` / `TreeMap` only relies on `compare` / `Comparator` and not on `equals` when checking for equality.\\n\\nNote that our \"equality\" violates one property of equality: it's not transitive. No big deal, though, because the set will only contain distinct (according to our \"equality\" criterion) values, and for \"less\" / \"greater\" relationships transitivity is preserved.\\n\\nSo here you go. Still O(n log k) but twice faster than the `floor / ceiling` one.\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, final int t) {\\n        if (k == 0 || nums.length <= 1) {\\n            return false;\\n        }\\n        if (k >= nums.length) {\\n            k = nums.length - 1; // note: mutating a formal parameter!\\n        }\\n        NavigableSet<Integer> kSet = new TreeSet<>(new Comparator<Integer>() {\\n            @Override\\n            public int compare(Integer i1, Integer i2) {\\n                long diff = (long) i1 - i2; // long because can overflow\\n                if (Math.abs(diff) <= t) {\\n                    return 0;\\n                } else {\\n                    return diff > 0 ? +1 : -1;\\n                }\\n            }\\n        });\\n        for (int i = 0; i <= k; ++i) {\\n            if (!kSet.add(nums[i])) {\\n                return true;\\n            }\\n        }\\n        for (int i = k + 1; i < nums.length; ++i) {\\n            kSet.remove(nums[i - k - 1]);\\n            if (!kSet.add(nums[i])) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "The problem with TreeSet solutions is not only that they are O(n log k) when there are O(n) solutions, but also that they search multiple times for the same value. Consider a typical `floor / ceiling` solution: first it checks for `floor` and `ceiling`, then it inserts the new value, and each of those operations is basically a search for the same value! How can we deal with that?\\n\\nOne idea is to perform the search once, finding the floor, ceiling and insertion point at the same time. Moreover, if the floor or the ceiling are too close, we don't even want to continue the search: we can return true immediately. But how do we do this?\\n\\nOne way is to create a custom BST implementation. This can get ugly especially if you do RBT rebalancing. But there is a smarter way. Note that `TreeSet` doesn't insert a value if there is already such value in the set (it is a set, after all). What if we want to achieve the same effect when the value is not exactly equal to some other, but almost equal (within the margin of `t`)? Why not trick it into thinking that these values are indeed equal? Especially since the docs openly state that `TreeSet` / `TreeMap` only relies on `compare` / `Comparator` and not on `equals` when checking for equality.\\n\\nNote that our \"equality\" violates one property of equality: it's not transitive. No big deal, though, because the set will only contain distinct (according to our \"equality\" criterion) values, and for \"less\" / \"greater\" relationships transitivity is preserved.\\n\\nSo here you go. Still O(n log k) but twice faster than the `floor / ceiling` one.\\n\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, final int t) {\\n        if (k == 0 || nums.length <= 1) {\\n            return false;\\n        }\\n        if (k >= nums.length) {\\n            k = nums.length - 1; // note: mutating a formal parameter!\\n        }\\n        NavigableSet<Integer> kSet = new TreeSet<>(new Comparator<Integer>() {\\n            @Override\\n            public int compare(Integer i1, Integer i2) {\\n                long diff = (long) i1 - i2; // long because can overflow\\n                if (Math.abs(diff) <= t) {\\n                    return 0;\\n                } else {\\n                    return diff > 0 ? +1 : -1;\\n                }\\n            }\\n        });\\n        for (int i = 0; i <= k; ++i) {\\n            if (!kSet.add(nums[i])) {\\n                return true;\\n            }\\n        }\\n        for (int i = k + 1; i < nums.length; ++i) {\\n            kSet.remove(nums[i - k - 1]);\\n            if (!kSet.add(nums[i])) {\\n                return true;\\n            }\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 61709,
                "title": "22ms-java-straight-forward-sorting-solution-beats-87-92-solutions-surprisingly-fast",
                "content": "This is my first thought on this problem, sort the input with index info saved and search as far as the value difference is less than or equal to k.  For worst case scenario, the search would be O(n^2), but this solution is surprisingly fast, my thought would be the test cases are not covering the case that all the input is within the value difference of k.\\n\\n    public class Solution {\\n        \\n        class Pair {\\n            int val;\\n            int index;\\n            Pair(int v, int i) {\\n                this.val = v;\\n                this.index = i;\\n            }\\n        }\\n        \\n        public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n            if (nums == null || nums.length < 2 || t < 0 || k < 1) {\\n                return false;\\n            }\\n            int len = nums.length;\\n            Pair[] pair = new Pair[len];\\n            for(int i = 0; i < len; i++) {\\n                pair[i] = new Pair(nums[i], i);\\n            }\\n            \\n            Arrays.sort(pair, new Comparator<Pair> () {\\n              public int compare(Pair p1, Pair p2) {\\n                  return p1.val - p2.val;\\n              } \\n            });\\n            \\n            for(int i = 0; i < len; i++) {\\n                for(int j = i + 1; j < len && Math.abs((long)pair[j].val - (long)pair[i].val) <= (long)t; j++){\\n                    int indexDiff = Math.abs(pair[i].index - pair[j].index);\\n                    if (indexDiff <= k) {\\n                        return true;\\n                    }\\n                }\\n            }\\n            return false;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        \\n        class Pair {\\n            int val;\\n            int index;\\n            Pair(int v, int i) {\\n                this.val = v;\\n                this.index = i;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 61719,
                "title": "why-no-one-posted-o-n-solution-in-c-using-bucket-sort",
                "content": "I couldn't find the C++ solution using bucket sort in the discussions. So I want to share my accepted version. Hopefully it could help those who only use C++ like me and really want to see people could improve upon it since it now runs 36ms.\\nHere is the explanation of this code. The logic is borrowed from https://leetcode.com/discuss/38206/ac-o-n-solution-in-java-using-buckets-with-explanation by lx223. My initial effort using the bucket sort on this problem failed miserably because I did not consider the situation that nums[i] and nums[j] could be put into neighboring buckets even if their difference is not greater than t. So I searched the forum and saw lx223's brilliant design/implementation. As the Java version, I used a unordered_map \"buckets\" to store the most recent k nums,\\nwhere the key is the bucket index calculated from nums[i] , and the value is simply the nums[i]. Therefore, whenever we encounter a new nums[i] there are 3 possibilities we can find a match: 1. the same bucket index of nums[i]: \"idx\" is already in buckets, since we define the bucket width to be w=t+1, this means a match has been found. 2. If the neighboring index idx-1 is in \"buckets\" and it's corresponding value nums[j] satisfies the constraint: abs(nums[i]-nums[j])<=t, then a match is also found. 3. The same condition check as #2 for the neighbor idx+1. Finally, whenever the size of buckets reached the limit k, we need to remove the oldest idx from buckets for the new one. However C++ unordered_map does not keep the insertion order of its keys, so I used a list to keep track of the oldest idx which is always the first node in the list. BTW: the using of long long is to handle the test cases where the t and values of nums are INT_MAX.\\n\\n    class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            int len=(int) nums.size();\\n            if(len<2||k<1||t<0) return false;\\n            \\n            int mn=nums[0]];\\n            for(int i=1; i<len; ++i) mn=min(mn, nums[i]);\\n            \\n            long long w=t+1;\\n            int numBuckets=k;\\n            unordered_map<int, int> buckets;\\n            list<int> idxList;\\n            for(int i=0; i<len; ++i) {\\n                int idx=((long long)nums[i]-mn)/w;\\n                \\n                if(buckets.find(idx)!=buckets.end()) return true;\\n                else if(buckets.find(idx-1)!=buckets.end()\\n                        &&abs((long long)nums[i]-buckets[idx-1])<=t) return true;\\n                else if(buckets.find(idx+1)!=buckets.end()\\n                         &&abs((long long)nums[i]-buckets[idx+1])<=t) return true;\\n                         \\n                if((int)buckets.size()==numBuckets) {\\n                    buckets.erase(idxList.front());\\n                    idxList.pop_front();\\n                }\\n                \\n                buckets[idx]=nums[i];\\n                idxList.push_back(idx);\\n            }\\n            return false;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n            int len=(int) nums.size();\\n            if(len<2||k<1||t<0) return false;\\n            \\n            int mn=nums[0]];\\n            for(int i=1; i<len; ++i) mn=min(mn, nums[i]);\\n            \\n            long long w=t+1;\\n            int numBuckets=k;\\n            unordered_map<int, int> buckets;\\n            list<int> idxList;\\n            for(int i=0; i<len; ++i) {\\n                int idx=((long long)nums[i]-mn)/w;\\n                \\n                if(buckets.find(idx)!=buckets.end()) return true;\\n                else if(buckets.find(idx-1)!=buckets.end()\\n                        &&abs((long long)nums[i]-buckets[idx-1])<=t) return true;\\n                else if(buckets.find(idx+1)!=buckets.end()\\n                         &&abs((long long)nums[i]-buckets[idx+1])<=t) return true;\\n                         \\n                if((int)buckets.size()==numBuckets) {\\n                    buckets.erase(idxList.front());\\n                    idxList.pop_front();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 61747,
                "title": "c-28ms-solution-using-multimap",
                "content": "    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        multimap<long, int> map;\\n        //sort and record index\\n        for (int i = 0; i < nums.size(); i++) {\\n            map.insert(make_pair(nums[i], i));\\n        }\\n        auto p1 = map.begin();\\n        while (p1 != map.end()) {\\n            auto p2 = p1;\\n            p2++;\\n            while (p2 != map.end() && p2->first - p1->first <= t) {\\n                if (abs(p1->second - p2->second) <= k)\\n                    return true;\\n                p2++;\\n            }\\n            p1++;\\n        }\\n        return false;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        multimap<long, int> map;\\n        //sort and record index\\n        for (int i = 0; i < nums.size(); i++) {\\n            map.insert(make_pair(nums[i], i));\\n        }\\n        auto p1 = map.begin();\\n        while (p1 != map.end()) {\\n            auto p2 = p1;\\n            p2++;\\n            while (p2 != map.end() && p2->first - p1->first <= t) {\\n                if (abs(p1->second - p2->second) <= k)\\n                    return true;\\n                p2++;\\n            }\\n            p1++;\\n        }\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2683830,
                "title": "custom-sliding-window-no-data-structure-used",
                "content": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int n = nums.length;\\n\\n        int window ;\\n        for (int i = 0; i < n; i++) {\\n            window = i + indexDiff;\\n            for (int j = i + 1; j <= window ; j++) {\\n                if(j == n){\\n                    break;\\n                }\\n                if (Math.abs(nums[i] - nums[j]) <= valueDiff){\\n                    return true;\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int n = nums.length;\\n\\n        int window ;\\n        for (int i = 0; i < n; i++) {\\n            window = i + indexDiff;\\n            for (int j = i + 1; j <= window ; j++) {\\n                if(j == n){\\n                    break;\\n                }\\n                if (Math.abs(nums[i] - nums[j]) <= valueDiff){\\n                    return true;\\n                }\\n            }\\n\\n        }\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298891,
                "title": "two-python-solutions-memory-optimization-speed-optimization",
                "content": "Good Memory Optimization But Slow\\n\\n```\\nimport sortedcontainers\\nimport bisect\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        k +=1\\n        res = sortedcontainers.SortedList(nums[:k])\\n        for i in range(1,len(res)):\\n            if res[i]-res[i-1] <= t :\\n                return True\\n        \\n        \\n        for i in range(1,len(nums)-k+1):\\n            \\n            num = nums[i+k-1]\\n            res.remove(nums[i-1])\\n            res.add(nums[i+k-1])\\n            idx = bisect.bisect_left(res, num)\\n            \\n            if (idx-1 >= 0 and num-res[idx-1]<=t) or (idx+1<k and res[idx+1]-num<=t):\\n                return True\\n            \\n        return False\\n```\\n\\nVery Fast but takes lot of memory\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if t == 0 and len(set(nums)) == len(nums): return False\\n        \\n        bucket = {}\\n        width = t + 1\\n        \\n        for i, n in enumerate(nums):\\n            bucket_i = n // width\\n            \\n            if bucket_i in bucket: return True\\n            elif bucket_i + 1 in bucket and abs(n - bucket[bucket_i + 1]) < width: return True\\n            elif bucket_i - 1 in bucket and abs(n - bucket[bucket_i - 1]) < width: return True\\n            \\n            bucket[bucket_i] = n\\n            if i >= k: del bucket[ nums[i-k] //width ]\\n                \\n        return False\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport sortedcontainers\\nimport bisect\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        k +=1\\n        res = sortedcontainers.SortedList(nums[:k])\\n        for i in range(1,len(res)):\\n            if res[i]-res[i-1] <= t :\\n                return True\\n        \\n        \\n        for i in range(1,len(nums)-k+1):\\n            \\n            num = nums[i+k-1]\\n            res.remove(nums[i-1])\\n            res.add(nums[i+k-1])\\n            idx = bisect.bisect_left(res, num)\\n            \\n            if (idx-1 >= 0 and num-res[idx-1]<=t) or (idx+1<k and res[idx+1]-num<=t):\\n                return True\\n            \\n        return False\\n```\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        if t == 0 and len(set(nums)) == len(nums): return False\\n        \\n        bucket = {}\\n        width = t + 1\\n        \\n        for i, n in enumerate(nums):\\n            bucket_i = n // width\\n            \\n            if bucket_i in bucket: return True\\n            elif bucket_i + 1 in bucket and abs(n - bucket[bucket_i + 1]) < width: return True\\n            elif bucket_i - 1 in bucket and abs(n - bucket[bucket_i - 1]) < width: return True\\n            \\n            bucket[bucket_i] = n\\n            if i >= k: del bucket[ nums[i-k] //width ]\\n                \\n        return False\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2191052,
                "title": "simple-java-solution-using-treeset",
                "content": "\\tclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Long> treeSet = new TreeSet<>();\\n        //nums = [1,2,3,1], k = 3, t = 0\\n        for(int i = 0; i < nums.length; i++){\\n            Long cur = (long) nums[i];\\n            //greatest element that is less than or equal to current\\n            Long floor = treeSet.floor(cur);\\n            //smallest element that is greater than or equal to current\\n            Long ceiling = treeSet.ceiling(cur);\\n            \\n            if(null != floor && Math.abs(floor - cur) <= t)\\n                return true;\\n            \\n            if(null != ceiling && Math.abs(ceiling - cur) <= t)\\n                return true;\\n            \\n            treeSet.add(cur);\\n            if(treeSet.size() > k)\\n                treeSet.remove((long)nums[i-k]);            \\n        }\\n        return false;        \\n    }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Long> treeSet = new TreeSet<>();\\n        //nums = [1,2,3,1], k = 3, t = 0\\n        for(int i = 0; i < nums.length; i++){\\n            Long cur = (long) nums[i];\\n            //greatest element that is less than or equal to current\\n            Long floor = treeSet.floor(cur);\\n            //smallest element that is greater than or equal to current\\n            Long ceiling = treeSet.ceiling(cur);\\n            \\n            if(null != floor && Math.abs(floor - cur) <= t)\\n                return true;\\n            \\n            if(null != ceiling && Math.abs(ceiling - cur) <= t)\\n                return true;\\n            \\n            treeSet.add(cur);\\n            if(treeSet.size() > k)\\n                treeSet.remove((long)nums[i-k]);            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2184020,
                "title": "c-o-n-hashmap-buckets-well-commented-easy-to-understand-beats-95",
                "content": "```\\n// The idea is that we maintain a set of ranges (buckets) that the given condition can be satisfied in.\\n// I.e. \\'k\\' buckets of size t + 1 - for each nums[i] that is currently in the window (hence the size k).\\n// The size of each container is t + 1 so that the absolute difference of any 2 numbers in the group will be at most t.\\n// E.g. 4, 5, 6, 7 or 0, -1, -2, -3\\n// Then, each number is mapped into its bucket by getBucketId. It\\'s a bit tricky in order to corrently handle negtive numbers.\\n// For example, buckets[0] has both positive and negative numbers mapped to it. E.g. when t = 3, number 3 and -3 would be mapped to \\n// buckets[0] if we just used simple division.\\n// As specified, the program should return true if any of the following conditions is true for a given nums[i]\\n// 1. the bucket for nums[i] already has a number in it - this means the existing number and nums[i] are within the range t\\n// 2. the bucket immediately to the left has a value and that value is within the range t\\n// 3. the bucket immediately to the right has a value and that value is within the range t\\n// Note that those are only 3 buckets that we need to check as by definition all other buckets are more than t apart from nums[i]\\n\\npublic class Solution {\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        \\n        Dictionary<long, long> buckets = new();\\n        \\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            long bucket = getBucketId(nums[i]);\\n            \\n            if (buckets.ContainsKey(bucket)) return true;\\n            \\n            if (buckets.TryGetValue(bucket - 1, out long leftValue) && Math.Abs(leftValue - nums[i]) <= t) return true;\\n            \\n            if (buckets.TryGetValue(bucket + 1, out long rightValue) && Math.Abs(rightValue - nums[i]) <= t) return true;\\n            \\n            buckets.Add(bucket, nums[i]);\\n            \\n            if (buckets.Count > k) buckets.Remove(getBucketId(nums[i - k]));\\n        }\\n        \\n        return false;\\n        \\n        \\n        int getBucketId(int number)\\n        {\\n            int bucketId = number / (t + 1);\\n            \\n            if (number < 0) bucketId--;\\n            \\n            return bucketId;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// The idea is that we maintain a set of ranges (buckets) that the given condition can be satisfied in.\\n// I.e. \\'k\\' buckets of size t + 1 - for each nums[i] that is currently in the window (hence the size k).\\n// The size of each container is t + 1 so that the absolute difference of any 2 numbers in the group will be at most t.\\n// E.g. 4, 5, 6, 7 or 0, -1, -2, -3\\n// Then, each number is mapped into its bucket by getBucketId. It\\'s a bit tricky in order to corrently handle negtive numbers.\\n// For example, buckets[0] has both positive and negative numbers mapped to it. E.g. when t = 3, number 3 and -3 would be mapped to \\n// buckets[0] if we just used simple division.\\n// As specified, the program should return true if any of the following conditions is true for a given nums[i]\\n// 1. the bucket for nums[i] already has a number in it - this means the existing number and nums[i] are within the range t\\n// 2. the bucket immediately to the left has a value and that value is within the range t\\n// 3. the bucket immediately to the right has a value and that value is within the range t\\n// Note that those are only 3 buckets that we need to check as by definition all other buckets are more than t apart from nums[i]\\n\\npublic class Solution {\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        \\n        Dictionary<long, long> buckets = new();\\n        \\n        for (int i = 0; i < nums.Length; i++)\\n        {\\n            long bucket = getBucketId(nums[i]);\\n            \\n            if (buckets.ContainsKey(bucket)) return true;\\n            \\n            if (buckets.TryGetValue(bucket - 1, out long leftValue) && Math.Abs(leftValue - nums[i]) <= t) return true;\\n            \\n            if (buckets.TryGetValue(bucket + 1, out long rightValue) && Math.Abs(rightValue - nums[i]) <= t) return true;\\n            \\n            buckets.Add(bucket, nums[i]);\\n            \\n            if (buckets.Count > k) buckets.Remove(getBucketId(nums[i - k]));\\n        }\\n        \\n        return false;\\n        \\n        \\n        int getBucketId(int number)\\n        {\\n            int bucketId = number / (t + 1);\\n            \\n            if (number < 0) bucketId--;\\n            \\n            return bucketId;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1850389,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution \\n{\\n    private SortedSet<long> neighbours = new();\\n    \\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) \\n    {\\n        \\n        for(int i=0; i<nums.Length; i++)\\n        {\\n            if(neighbours.GetViewBetween(Convert.ToInt64(nums[i]) - t, Convert.ToInt64(nums[i]) + t).Any())\\n                return true;\\n            \\n            neighbours.Add(nums[i]);\\n            \\n            if(i>=k)\\n                neighbours.Remove(nums[i-k]);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    private SortedSet<long> neighbours = new();\\n    \\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) \\n    {\\n        \\n        for(int i=0; i<nums.Length; i++)\\n        {\\n            if(neighbours.GetViewBetween(Convert.ToInt64(nums[i]) - t, Convert.ToInt64(nums[i]) + t).Any())\\n                return true;\\n            \\n            neighbours.Add(nums[i]);\\n            \\n            if(i>=k)\\n                neighbours.Remove(nums[i-k]);\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1790952,
                "title": "c-solution-beats-90-vector-simple-and-clean-code",
                "content": "```\\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n\\tint n=nums.size();\\n\\tvector<pair<long,int>> vec;//vector to store <value,index> pair\\n\\tfor(int i=0;i<n;i++) vec.push_back({nums[i],i});\\n\\tsort(vec.begin(),vec.end());//sort based on values\\n\\tfor(int i=0;i<n;i++){\\n\\t\\t//iterate from i+1th index to some j such that differnce of values (vec[j]-vec[i])<=t  \\n\\t\\tfor(int j=i+1;j<n and (vec[j].first*1L-vec[i].first)<=t;j++){\\n\\t\\t\\t//if the absolute difference of indices <=k then required pair is found \\n\\t\\t\\tif(abs(vec[j].second-vec[i].second)<=k) return true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```\\n\\n**Please Upvote :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n\\tint n=nums.size();\\n\\tvector<pair<long,int>> vec;//vector to store <value,index> pair\\n\\tfor(int i=0;i<n;i++) vec.push_back({nums[i],i});\\n\\tsort(vec.begin(),vec.end());//sort based on values\\n\\tfor(int i=0;i<n;i++){\\n\\t\\t//iterate from i+1th index to some j such that differnce of values (vec[j]-vec[i])<=t  \\n\\t\\tfor(int j=i+1;j<n and (vec[j].first*1L-vec[i].first)<=t;j++){\\n\\t\\t\\t//if the absolute difference of indices <=k then required pair is found \\n\\t\\t\\tif(abs(vec[j].second-vec[i].second)<=k) return true;\\n\\t\\t}\\n\\t}\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1754612,
                "title": "python-o-nlogk-sliding-window-sortedcontainers-binary-search",
                "content": "```\\nimport sortedcontainers\\nimport bisect\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        k+=1\\n        temp = sortedcontainers.SortedList(nums[:k])\\n        for i in range(1,len(temp)):\\n            if temp[i]-temp[i-1] <= t :\\n                return True\\n        \\n        \\n        for i in range(1,len(nums)-k+1):\\n            \\n            num = nums[i+k-1]\\n            temp.remove(nums[i-1])\\n            temp.add(nums[i+k-1])\\n            idx = bisect.bisect_left(temp, num)\\n            \\n            if (idx-1 >= 0 and num-temp[idx-1]<=t) or (idx+1<k and temp[idx+1]-num<=t):\\n                return True\\n            \\n        return False\\n            \\n            \\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nimport sortedcontainers\\nimport bisect\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        k+=1\\n        temp = sortedcontainers.SortedList(nums[:k])\\n        for i in range(1,len(temp)):\\n            if temp[i]-temp[i-1] <= t :\\n                return True\\n        \\n        \\n        for i in range(1,len(nums)-k+1):\\n            \\n            num = nums[i+k-1]\\n            temp.remove(nums[i-1])\\n            temp.add(nums[i+k-1])\\n            idx = bisect.bisect_left(temp, num)\\n            \\n            if (idx-1 >= 0 and num-temp[idx-1]<=t) or (idx+1<k and temp[idx+1]-num<=t):\\n                return True\\n            \\n        return False\\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1515793,
                "title": "go-clean-code-16ms-beats-100",
                "content": "```\\nfunc containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {\\n\\tdata := make(map[int]int)\\n\\tfor i, num := range nums {\\n\\t\\tbucket := helper(num, t+1)\\n\\t\\tif _, ok := data[bucket]; ok {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tif value, ok := data[bucket-1]; ok && num-value <= t {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tif value, ok := data[bucket+1]; ok && value-num <= t {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tdata[bucket] = num\\n\\t\\tif i >= k {\\n\\t\\t\\tdelete(data, helper(nums[i-k], t+1))\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc helper(num, w int) int {\\n\\tif num < 0 {\\n\\t\\treturn num/w - 1\\n\\t}\\n\\treturn num / w\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {\\n\\tdata := make(map[int]int)\\n\\tfor i, num := range nums {\\n\\t\\tbucket := helper(num, t+1)\\n\\t\\tif _, ok := data[bucket]; ok {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tif value, ok := data[bucket-1]; ok && num-value <= t {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tif value, ok := data[bucket+1]; ok && value-num <= t {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\tdata[bucket] = num\\n\\t\\tif i >= k {\\n\\t\\t\\tdelete(data, helper(nums[i-k], t+1))\\n\\t\\t}\\n\\t}\\n\\treturn false\\n}\\n\\nfunc helper(num, w int) int {\\n\\tif num < 0 {\\n\\t\\treturn num/w - 1\\n\\t}\\n\\treturn num / w\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1441301,
                "title": "python-simple-solution-without-using-heaps-bst-bucket-sort",
                "content": "A brute force solution for this problem would entail checking all the possible pairs and then see if their absolute values differ by less than equal to t and their indices differ by less than equal to k.\\n\\nThe following code considers the values and indices of each of the elements in the array and sorts them. We can then go through the sorted array and perform checks for each encountered index until it meets another index such that their difference is <= k as long as the abs difference between their values is <= t. We return such a find immediately so as to not continue checking.\\n\\nYour suggestions are welcome! Happy learning! \\n\\t\\n```\\ndef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n       \\n\\tsorted_nums = []\\n\\tfor i, num in enumerate(nums):\\n\\t\\tsorted_nums.append((num,i))\\n\\n\\tsorted_nums = sorted(sorted_nums)\\n\\n\\tfor i in range(len(nums)-1):\\n\\t\\tj = i+1\\n\\t\\twhile(j <= len(nums)-1 and abs(sorted_nums[j][0]-sorted_nums[i][0])<=t):\\n\\t\\t\\tif abs(sorted_nums[j][1]-sorted_nums[i][1]) <= k:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tj+=1\\n\\treturn False\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n       \\n\\tsorted_nums = []\\n\\tfor i, num in enumerate(nums):\\n\\t\\tsorted_nums.append((num,i))\\n\\n\\tsorted_nums = sorted(sorted_nums)\\n\\n\\tfor i in range(len(nums)-1):\\n\\t\\tj = i+1\\n\\t\\twhile(j <= len(nums)-1 and abs(sorted_nums[j][0]-sorted_nums[i][0])<=t):\\n\\t\\t\\tif abs(sorted_nums[j][1]-sorted_nums[i][1]) <= k:\\n\\t\\t\\t\\treturn True\\n\\t\\t\\tj+=1\\n\\treturn False\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1093140,
                "title": "c-easy-solution-using-pair-data-structure",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n=nums.size();\\n        if(n==0) return false; // Null vector\\n        pair<long long int,int> a[n]; \\n        for(int i=0;i<n;++i)\\n        {\\n            a[i].first = (long long int)nums[i]; // Elements \\n            a[i].second = i; // Indices\\n        }\\n        sort(a,a+n); // Sort the pair array in ascending order\\n        for(int i=0;i<n;++i)\\n        {\\n            long long int n1 = a[i].first; // Current element\\n            for(int j=i+1;j<n;++j) // Next element\\n            {\\n                long long int n2 = a[j].first; \\n                long long int diff = abs(n1-n2);\\n                if(diff>t) // We do not need to check any further\\n                    break;\\n                if(diff<=(long)t && abs(a[i].second-a[j].second)<=k) // Checking for both conditions\\n                    return true; // Return true if found such pair\\n            }\\n        }\\n        return false; // Return false if no such pair is found\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n=nums.size();\\n        if(n==0) return false; // Null vector\\n        pair<long long int,int> a[n]; \\n        for(int i=0;i<n;++i)\\n        {\\n            a[i].first = (long long int)nums[i]; // Elements \\n            a[i].second = i; // Indices\\n        }\\n        sort(a,a+n); // Sort the pair array in ascending order\\n        for(int i=0;i<n;++i)\\n        {\\n            long long int n1 = a[i].first; // Current element\\n            for(int j=i+1;j<n;++j) // Next element\\n            {\\n                long long int n2 = a[j].first; \\n                long long int diff = abs(n1-n2);\\n                if(diff>t) // We do not need to check any further\\n                    break;\\n                if(diff<=(long)t && abs(a[i].second-a[j].second)<=k) // Checking for both conditions\\n                    return true; // Return true if found such pair\\n            }\\n        }\\n        return false; // Return false if no such pair is found\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 842070,
                "title": "javascript-version-of-bst-implement-solution",
                "content": "Javascript has no TreeSet so just manually implement it.\\n\\n```\\nclass Node {\\n    constructor (x) {\\n        this.val = x;\\n        this.left = null;\\n        this.right = null;\\n    }\\n    \\n    successor () {\\n        var node = this;\\n        if (node && node.right) {\\n            node = node.right;\\n            while (node.left) {\\n                node = node.left;\\n            }\\n        }\\n        return node;\\n    }\\n    \\n    predecessor () {\\n        var node = this;\\n        if (node && node.left) {\\n            node = node.left;\\n            while (node.right) {\\n                node = node.right;\\n            }\\n        }\\n        return node;\\n    }\\n}\\n\\nclass BST {\\n    constructor () {\\n        this.root = null;\\n    }\\n    \\n    add (root, val) {\\n        if (!root) {\\n            return new Node(val);\\n        }\\n        if (root.val < val) root.right = this.add(root.right, val);\\n        else root.left = this.add(root.left, val);\\n        return root;\\n    }\\n    \\n    search (root, val) {\\n        if (!root) return null;\\n        if (root.val === val) return root;\\n        if (root.val < val) return this.search(root.right, val);\\n        else return this.search(root.left, val);\\n    }\\n    \\n    nextBigger(root, val) {\\n        var nextBigger = null;\\n        while (root) {\\n            if (root.val >= val) {\\n                nextBigger = root;\\n                root = root.left;\\n            }\\n            else {\\n                root = root.right;\\n            }\\n        }\\n        return nextBigger;\\n    }\\n    \\n    prevSmaller (root, val) {\\n        var prevSmaller = null;\\n        while (root) {\\n            if (root.val <= val) {\\n                prevSmaller = root;\\n                root = root.right;\\n            }\\n            else {\\n                root = root.left;\\n            }\\n        }\\n        return prevSmaller;\\n    }\\n    \\n    delete (root, val) {\\n        if (!root) return null;\\n        if (root.val < val) {\\n            root.right = this.delete(root.right, val);\\n        }\\n        else if (root.val > val) {\\n            root.left = this.delete(root.left, val);\\n        }\\n        else {\\n            if (root.right) {\\n                var next = root.successor();\\n                root.val = next.val;\\n                root.right = this.delete(root.right, next.val);\\n            }\\n            else if (root.left) {\\n                var prev = root.predecessor();\\n                root.val = prev.val;\\n                root.left = this.delete(root.left, prev.val);\\n            }\\n            else root = null;\\n        }\\n        return root;\\n    }\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    var bst = new BST();\\n    for (var i = 0; i < nums.length; i++) {\\n        // Get first node that is >= nums[i]\\n        var next = bst.nextBigger(bst.root, nums[i]);\\n        if (next && next.val <= nums[i] + t) return true;\\n        // Get last node that is <= nums[i]\\n        var prev = bst.prevSmaller(bst.root, nums[i]);\\n        if (prev && prev.val >= nums[i] - t) return true;\\n        bst.root = bst.add(bst.root, nums[i]);\\n        if (k <= i) {\\n            bst.root = bst.delete(bst.root, nums[i - k]);\\n        }\\n    }\\n    return false;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Node {\\n    constructor (x) {\\n        this.val = x;\\n        this.left = null;\\n        this.right = null;\\n    }\\n    \\n    successor () {\\n        var node = this;\\n        if (node && node.right) {\\n            node = node.right;\\n            while (node.left) {\\n                node = node.left;\\n            }\\n        }\\n        return node;\\n    }\\n    \\n    predecessor () {\\n        var node = this;\\n        if (node && node.left) {\\n            node = node.left;\\n            while (node.right) {\\n                node = node.right;\\n            }\\n        }\\n        return node;\\n    }\\n}\\n\\nclass BST {\\n    constructor () {\\n        this.root = null;\\n    }\\n    \\n    add (root, val) {\\n        if (!root) {\\n            return new Node(val);\\n        }\\n        if (root.val < val) root.right = this.add(root.right, val);\\n        else root.left = this.add(root.left, val);\\n        return root;\\n    }\\n    \\n    search (root, val) {\\n        if (!root) return null;\\n        if (root.val === val) return root;\\n        if (root.val < val) return this.search(root.right, val);\\n        else return this.search(root.left, val);\\n    }\\n    \\n    nextBigger(root, val) {\\n        var nextBigger = null;\\n        while (root) {\\n            if (root.val >= val) {\\n                nextBigger = root;\\n                root = root.left;\\n            }\\n            else {\\n                root = root.right;\\n            }\\n        }\\n        return nextBigger;\\n    }\\n    \\n    prevSmaller (root, val) {\\n        var prevSmaller = null;\\n        while (root) {\\n            if (root.val <= val) {\\n                prevSmaller = root;\\n                root = root.right;\\n            }\\n            else {\\n                root = root.left;\\n            }\\n        }\\n        return prevSmaller;\\n    }\\n    \\n    delete (root, val) {\\n        if (!root) return null;\\n        if (root.val < val) {\\n            root.right = this.delete(root.right, val);\\n        }\\n        else if (root.val > val) {\\n            root.left = this.delete(root.left, val);\\n        }\\n        else {\\n            if (root.right) {\\n                var next = root.successor();\\n                root.val = next.val;\\n                root.right = this.delete(root.right, next.val);\\n            }\\n            else if (root.left) {\\n                var prev = root.predecessor();\\n                root.val = prev.val;\\n                root.left = this.delete(root.left, prev.val);\\n            }\\n            else root = null;\\n        }\\n        return root;\\n    }\\n}\\n\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    var bst = new BST();\\n    for (var i = 0; i < nums.length; i++) {\\n        // Get first node that is >= nums[i]\\n        var next = bst.nextBigger(bst.root, nums[i]);\\n        if (next && next.val <= nums[i] + t) return true;\\n        // Get last node that is <= nums[i]\\n        var prev = bst.prevSmaller(bst.root, nums[i]);\\n        if (prev && prev.val >= nums[i] - t) return true;\\n        bst.root = bst.add(bst.root, nums[i]);\\n        if (k <= i) {\\n            bst.root = bst.delete(bst.root, nums[i - k]);\\n        }\\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 825896,
                "title": "go-golang-solution",
                "content": ">Runtime: 4 ms, faster than 100.00% of Go online submissions for Contains Duplicate III.\\nMemory Usage: 3.9 MB, less than 46.59% of Go online submissions for Contains Duplicate III.\\n\\n```go\\nfunc containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {\\n    if t < 0 { return false }\\n    m := make(map[int]int)\\n    for i := 0; i < len(nums); i++ {\\n        key := nums[i] / max(t, 1)\\n        if nums[i] < 0 { key-- }\\n        if _, ok := m[key]; ok { return true }\\n        if v, ok := m[key - 1]; ok && abs(nums[i] - v) <= t { return true }\\n        if v, ok := m[key + 1]; ok && abs(nums[i] - v) <= t { return true }\\n        m[key] = nums[i]\\n        if i >= k { delete(m, nums[i - k] / max(t, 1)) }\\n    }\\n    return false\\n}\\n\\nfunc abs(n int) int {\\n    if n > 0 { return n }\\n    return -n\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc containsNearbyAlmostDuplicate(nums []int, k int, t int) bool {\\n    if t < 0 { return false }\\n    m := make(map[int]int)\\n    for i := 0; i < len(nums); i++ {\\n        key := nums[i] / max(t, 1)\\n        if nums[i] < 0 { key-- }\\n        if _, ok := m[key]; ok { return true }\\n        if v, ok := m[key - 1]; ok && abs(nums[i] - v) <= t { return true }\\n        if v, ok := m[key + 1]; ok && abs(nums[i] - v) <= t { return true }\\n        m[key] = nums[i]\\n        if i >= k { delete(m, nums[i - k] / max(t, 1)) }\\n    }\\n    return false\\n}\\n\\nfunc abs(n int) int {\\n    if n > 0 { return n }\\n    return -n\\n}\\n\\nfunc max(a, b int) int {\\n    if a > b { return a }\\n    return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 825231,
                "title": "o-n-time-o-k-space-solution-code-explanation",
                "content": "**Code:**\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        # O(N) one-pass solution based on buckets with size t + 1\\n        if k <= 0 or t < 0:\\n            return False\\n        from collections import deque\\n        bucket_cache = deque([],k)\\n        bucket_dict = {}\\n        # O(N) one pass\\n        for i in range(len(nums)):\\n            # We calculate a bucket index containing nums[i]\\n            remainder = nums[i] % (t + 1)\\n            bucket = (nums[i] - remainder) / (t+1)\\n            # Checking cache for duplicates\\n            if bucket in bucket_dict:\\n                return True # We found two values in the same bucket\\n            if bucket - 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket - 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n            if bucket + 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket + 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n            # Adding new bucket to cache\\n            if i >= k: # Maximal cache size is equal to k\\n                bucket_to_remove = bucket_cache.popleft()\\n                del bucket_dict[bucket_to_remove]\\n            bucket_cache.append(bucket)\\n            bucket_dict[bucket] = nums[i]\\n        return False\\n```\\n**Explanation**\\nFirst things first: there are some annoying test cases to consider. For example: nums = [-1,-1], k = 1, t = -1 where t (absolute value) can be negative... Another weird case is when k = 0. Thus in the very first step we make sure that when k <= 0 or t < 0 the function returns False:\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        # O(N) one-pass solution based on buckets with size t + 1\\n        if k <= 0 or t < 0:\\n            return False\\n```\\nLet\\'s get to the main idea. We want to solve this problem in one-pass, that is in a time O(N).  First we divide all integer into buckets with size t+1. For example bucket with an index 0 consists of all numbers 0,1,...,t; bucket with an index 1 consists of all numbers t+1,...2 * t + 1 and so on. We will put all values in a respective bucket. The function returns True if and only if there are two values in the same bucket or there are two values in nearby by buckets with a difference smaller than t.\\nBecause we are looking for values with index difference at most k, we will use a [deque](https://docs.python.org/2/library/collections.html#collections.deque) bucket_cache with maximal size k to store all bucket indices of last k elements:\\n```\\n        from collections import deque\\n        bucket_cache = deque([],k)\\n```\\nAnd a dictionary bucket_dict storing all pairs (bucket index, value):\\n```\\n        bucket_dict = {}\\n```\\nWe start a loop over all values of nums:\\n```\\n        # O(N) one pass\\n        for i in range(len(nums)):\\n            # We calculate a bucket index containing nums[i]\\n            remainder = nums[i] % (t + 1)\\n            bucket = (nums[i] - remainder) / (t+1)\\n```\\nWe check our cache, if there are duplicates:\\n```\\n            if bucket in bucket_dict:\\n                return True # We found two values in the same bucket\\n            if bucket - 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket - 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n            if bucket + 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket + 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n```\\nWe add new value to our cache:\\n```\\n            if i >= k: # Maximal cache size is equal to k\\n                bucket_to_remove = bucket_cache.popleft()\\n                del bucket_dict[bucket_to_remove]\\n            bucket_cache.append(bucket)\\n            bucket_dict[bucket] = nums[i]\\n```\\nIf there were no duplicates the function returns False:\\n```\\n        return False\\n```\\n**Complexity**\\nBecause we check it in one-pass, time complexity is equal to O(N). Because we remember only last k values, space complexity is equal to O(k).",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        # O(N) one-pass solution based on buckets with size t + 1\\n        if k <= 0 or t < 0:\\n            return False\\n        from collections import deque\\n        bucket_cache = deque([],k)\\n        bucket_dict = {}\\n        # O(N) one pass\\n        for i in range(len(nums)):\\n            # We calculate a bucket index containing nums[i]\\n            remainder = nums[i] % (t + 1)\\n            bucket = (nums[i] - remainder) / (t+1)\\n            # Checking cache for duplicates\\n            if bucket in bucket_dict:\\n                return True # We found two values in the same bucket\\n            if bucket - 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket - 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n            if bucket + 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket + 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n            # Adding new bucket to cache\\n            if i >= k: # Maximal cache size is equal to k\\n                bucket_to_remove = bucket_cache.popleft()\\n                del bucket_dict[bucket_to_remove]\\n            bucket_cache.append(bucket)\\n            bucket_dict[bucket] = nums[i]\\n        return False\\n```\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        # O(N) one-pass solution based on buckets with size t + 1\\n        if k <= 0 or t < 0:\\n            return False\\n```\n```\\n        from collections import deque\\n        bucket_cache = deque([],k)\\n```\n```\\n        bucket_dict = {}\\n```\n```\\n        # O(N) one pass\\n        for i in range(len(nums)):\\n            # We calculate a bucket index containing nums[i]\\n            remainder = nums[i] % (t + 1)\\n            bucket = (nums[i] - remainder) / (t+1)\\n```\n```\\n            if bucket in bucket_dict:\\n                return True # We found two values in the same bucket\\n            if bucket - 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket - 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n            if bucket + 1 in bucket_dict and abs(nums[i] - bucket_dict[bucket + 1]) <= t:\\n                return True # Two values in adjacent buckets and nearby values\\n```\n```\\n            if i >= k: # Maximal cache size is equal to k\\n                bucket_to_remove = bucket_cache.popleft()\\n                del bucket_dict[bucket_to_remove]\\n            bucket_cache.append(bucket)\\n            bucket_dict[bucket] = nums[i]\\n```\n```\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824735,
                "title": "java-treemap-sliding-window-o-n-log-k",
                "content": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n        TreeMap<Long, Integer> map = new TreeMap<>();\\n        int j = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(i - j > k) {\\n                if(contains(map, nums, j, t)) return true;\\n                j++;\\n            }\\n            long val = nums[i];\\n            map.put(val, map.getOrDefault(val, 0) + 1);\\n        }\\n\\n        while(j < nums.length) {\\n            if(contains(map, nums, j, t)) return true;\\n            j++;\\n        }\\n        return false;\\n    }\\n\\n    private boolean contains(TreeMap<Long, Integer> map, int[] nums, int j, int t) {\\n        \\n        long val = nums[j];\\n        Integer count = map.get(val);\\n        Long diff;\\n        if(count != null && count > 1) {\\n            map.put(val, count - 1);\\n        } else {\\n            map.remove(val);\\n        }\\n        if((diff = map.floorKey(t + val)) != null && Math.abs(diff - nums[j]) <= t) return true;\\n        return false;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n        TreeMap<Long, Integer> map = new TreeMap<>();\\n        int j = 0;\\n        for(int i = 0; i < nums.length; i++) {\\n            if(i - j > k) {\\n                if(contains(map, nums, j, t)) return true;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 824613,
                "title": "c-simple-sorting-and-check-values-within-bound-o-n-log-n-nt",
                "content": "```csharp\\npublic bool ContainsNearbyAlmostDuplicate(int[] nums, int k, long t)\\n{\\n\\tvar sorted = nums.Select((value, index) => new { value, index }).OrderBy(x => x.value).ToArray();\\n\\n\\tfor(int i = 0; i < sorted.Length; i++)\\n\\t{\\n\\t\\tlong currentNum = sorted[i].value;\\n\\n\\t\\tfor(int j = i + 1; j < sorted.Length && (sorted[j].value - currentNum) <= t; j++)\\n\\t\\t{\\n\\t\\t\\tif(Math.Abs(sorted[i].index - sorted[j].index) <= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic bool ContainsNearbyAlmostDuplicate(int[] nums, int k, long t)\\n{\\n\\tvar sorted = nums.Select((value, index) => new { value, index }).OrderBy(x => x.value).ToArray();\\n\\n\\tfor(int i = 0; i < sorted.Length; i++)\\n\\t{\\n\\t\\tlong currentNum = sorted[i].value;\\n\\n\\t\\tfor(int j = i + 1; j < sorted.Length && (sorted[j].value - currentNum) <= t; j++)\\n\\t\\t{\\n\\t\\t\\tif(Math.Abs(sorted[i].index - sorted[j].index) <= k)\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t} \\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 771756,
                "title": "swift-bucket-solution",
                "content": "**Overview**\\nI\\'ve updated this solution since the problem was used in the September daily challenge. The idea is based on \"bucket sort\". Map each number to a bucket based on the width `t` (we use `t + 1` to ensure no division by zero). If a number is already in the bucket, then we have a match and return true. We also have to check the neighboring buckets because a number at the upper range of bucket `i` may match with a number at the lower end of bucket `i+1`. The value `k` defines a sliding window. Whenever a number is longer in the window we must remove it from the bucket. \\n\\n\\n**Solution**\\n```swift\\nfunc containsNearbyAlmostDuplicate(_ nums: [Int], _ k: Int, _ t: Int) -> Bool {\\n\\tguard t >= 0, k > 0 else { return false }\\n\\tvar buckets = [Int: Int]() \\n\\tvar window = k + 1 \\n\\tvar width = t + 1\\n\\n\\t/// Maps a number to its corresponding bucket \\n\\tfunc map(_ num: Int) -> Int {\\n\\t\\treturn (num / width) - ((num < 0) ? 1 : 0)\\n\\t}\\n\\n\\tfor (idx, num) in nums.enumerated() {\\n\\t\\tlet bucket = map(num)\\n\\n\\t\\t// Check exact bucket\\n\\t\\tif buckets[bucket] != nil {\\n\\t\\t\\treturn true \\n\\t\\t} else {\\n\\t\\t\\tbuckets[bucket] = num  \\n\\t\\t}\\n\\n\\t\\t// Check neighbor buckets\\n\\t\\tif let prev = buckets[bucket-1], abs(prev - num) <= t {\\n\\t\\t\\treturn true \\n\\t\\t}\\n\\n\\t\\tif let prev = buckets[bucket+1], abs(prev - num) <= t {\\n\\t\\t\\treturn true \\n\\t\\t}\\n\\n\\t\\t// Slide Window \\n\\t\\tif idx - k >= 0 {\\n\\t\\t\\tbuckets.removeValue(forKey: map(nums[idx-k]))\\n\\t\\t}\\n\\t}\\n\\n\\treturn false \\n}\\n```",
                "solutionTags": [],
                "code": "```swift\\nfunc containsNearbyAlmostDuplicate(_ nums: [Int], _ k: Int, _ t: Int) -> Bool {\\n\\tguard t >= 0, k > 0 else { return false }\\n\\tvar buckets = [Int: Int]() \\n\\tvar window = k + 1 \\n\\tvar width = t + 1\\n\\n\\t/// Maps a number to its corresponding bucket \\n\\tfunc map(_ num: Int) -> Int {\\n\\t\\treturn (num / width) - ((num < 0) ? 1 : 0)\\n\\t}\\n\\n\\tfor (idx, num) in nums.enumerated() {\\n\\t\\tlet bucket = map(num)\\n\\n\\t\\t// Check exact bucket\\n\\t\\tif buckets[bucket] != nil {\\n\\t\\t\\treturn true \\n\\t\\t} else {\\n\\t\\t\\tbuckets[bucket] = num  \\n\\t\\t}\\n\\n\\t\\t// Check neighbor buckets\\n\\t\\tif let prev = buckets[bucket-1], abs(prev - num) <= t {\\n\\t\\t\\treturn true \\n\\t\\t}\\n\\n\\t\\tif let prev = buckets[bucket+1], abs(prev - num) <= t {\\n\\t\\t\\treturn true \\n\\t\\t}\\n\\n\\t\\t// Slide Window \\n\\t\\tif idx - k >= 0 {\\n\\t\\t\\tbuckets.removeValue(forKey: map(nums[idx-k]))\\n\\t\\t}\\n\\t}\\n\\n\\treturn false \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736563,
                "title": "rust-cheapest-best",
                "content": "```\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn contains_nearby_almost_duplicate(nums: Vec<i32>, k: i32, t: i32) -> bool {\\n        if k <= 0 || t < 0 {\\n            return false;\\n        }\\n        let t = t as i64;\\n        nums.iter()\\n            .map(|n| *n as i64)\\n            .enumerate()\\n            .try_fold(BTreeSet::new(), |mut s, (i, n)| {\\n                match s.range((n - t)..=(n + t)).next() {\\n                    Some(_) => None,\\n                    _ => {\\n                        if i >= k as usize {\\n                            s.remove(&(nums[i - k as usize] as i64));\\n                        }\\n                        s.insert(n);\\n                        Some(s)\\n                    }\\n                }\\n            })\\n            .is_none()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn contains_nearby_almost_duplicate(nums: Vec<i32>, k: i32, t: i32) -> bool {\\n        if k <= 0 || t < 0 {\\n            return false;\\n        }\\n        let t = t as i64;\\n        nums.iter()\\n            .map(|n| *n as i64)\\n            .enumerate()\\n            .try_fold(BTreeSet::new(), |mut s, (i, n)| {\\n                match s.range((n - t)..=(n + t)).next() {\\n                    Some(_) => None,\\n                    _ => {\\n                        if i >= k as usize {\\n                            s.remove(&(nums[i - k as usize] as i64));\\n                        }\\n                        s.insert(n);\\n                        Some(s)\\n                    }\\n                }\\n            })\\n            .is_none()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674158,
                "title": "python-o-n-in-7-simple-lines",
                "content": "It\\'s actually a lot less tricky than a lot of code I\\'ve seen makes it out to be.  Use a defaultdict to avoid so many ifs.\\n\\n```\\ndef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\tif t < 0: return False\\n\\td = collections.defaultdict(lambda:float(\\'inf\\'))\\n\\tfor i,n in enumerate(nums):\\n\\t\\tif i-k > 0: del d[nums[i-k-1] // (t+1)]\\n\\t\\tkey = n // (t+1)\\n\\t\\tif min(map(abs, [n-d[key-1], n-d[key], n-d[key+1]])) <= t: return True\\n\\t\\td[key] = nums[i]\\n```",
                "solutionTags": [],
                "code": "```\\ndef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\tif t < 0: return False\\n\\td = collections.defaultdict(lambda:float(\\'inf\\'))\\n\\tfor i,n in enumerate(nums):\\n\\t\\tif i-k > 0: del d[nums[i-k-1] // (t+1)]\\n\\t\\tkey = n // (t+1)\\n\\t\\tif min(map(abs, [n-d[key-1], n-d[key], n-d[key+1]])) <= t: return True\\n\\t\\td[key] = nums[i]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 608981,
                "title": "java-solution-step-by-step",
                "content": "Clarify:\\nreturn true if (nums[i] - nums[j]) <= t && j - i <= k\\n\\nMethod1: Sliding Window\\n\\nWindow size: k + 1\\n\\nif(max - min <= t) return ture;\\n\\nTC: O(k + (n-k)*k)\\nSC: O(k)\\n    \\nMethod2: Using Balanced Binary Search Tree to reduce time to find cloest number.\\n    \\n1. Build a size (k + 1) bbs tree\\n2. Traverse the rest (n - k - 1) elements\\n    Step1: remove the last element ==> remove(nums[i - k])\\n    Step2: find the cloest number to the new element ==> findCloestInTree(nums[i])\\n            if foundElement - nums[i] <= t ==> return true\\n    Step3: add new element into tree ==> add(nums[i])\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Integer> bbsTree = new TreeSet<>();\\n        int output = 2147483647 - (-1);\\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > k) {\\n                bbsTree.remove(nums[i - k - 1]);\\n            }\\n            Integer ceil = bbsTree.ceiling(nums[i]);\\n            if(ceil != null && ceil <= t + nums[i]) {\\n                return true;\\n            }\\n            Integer floor = bbsTree.floor(nums[i]);\\n            if(floor != null && nums[i] <= t + floor) {\\n                return true;\\n            }\\n            bbsTree.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```\\nTC: O(k + (n - k)logk)\\nSC: O(k)\\n    \\nMethod3: Using Buckets to save the range numbers. Each bucket save range t numbers.\\nEach time, we find get save target into one bucket:\\n    1. if bucket is filled, return true;   \\n    2. if last bucket or next bucket is filled and difference between number in those bucket with current element is <= k, return true\\n    3. implement current bucket\\nImplementation: We use a map<Double, Integer> to save target Number and index\\nTC: O(n))\\nSC: O(buket_size) Worst Case: O(maximum number - minimum number)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Integer> bbsTree = new TreeSet<>();\\n        int output = 2147483647 - (-1);\\n        for(int i = 0; i < nums.length; i++) {\\n            if(i > k) {\\n                bbsTree.remove(nums[i - k - 1]);\\n            }\\n            Integer ceil = bbsTree.ceiling(nums[i]);\\n            if(ceil != null && ceil <= t + nums[i]) {\\n                return true;\\n            }\\n            Integer floor = bbsTree.floor(nums[i]);\\n            if(floor != null && nums[i] <= t + floor) {\\n                return true;\\n            }\\n            bbsTree.add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 599202,
                "title": "c-solutions-using-bst-or-buckets",
                "content": "SortedSet is actually BST.\\nIt has a method \\'GetViewBetween(lower, upper)\\', what can be used to check if we have already had an element in range \\'t\\'.\\nSo all we need is to run through the array once, adding new values to the BST and removing the least \\'k\\' value from it.\\nWhen ve find any item in \\'ViewBetween\\' -- that means we found Duplicate.\\n\\n```\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.Length == 0 || k < 1 || t < 0) return false;\\n\\n        var sortedSet = new SortedSet<int>();\\n\\n        for (var i = 0; i < nums.Length; i++) {\\n            if (ContainsElementsInRange(sortedSet, nums[i], t)) return true;\\n\\n            if (sortedSet.Count == k) sortedSet.Remove(nums[i - k]);\\n            if (!sortedSet.Add(nums[i])) return true;\\n        }\\n        return false;\\n    }\\n\\n    private static bool ContainsElementsInRange(SortedSet<int> sortedSet, int center, int radius) {\\n\\n        var lower = (long) center - radius < int.MinValue ? int.MinValue : center - radius;\\n        var upper = (long) center + radius > int.MaxValue ? int.MaxValue : center + radius;\\n\\n        return sortedSet.GetViewBetween(lower, upper).Count > 0;\\n    }\\n```\\n\\nAnd here is another solution using Dictionary of buckets instead of BST.\\nI\\'ve outspokenly stolen buckets idea from [here](https://leetcode.com/problems/contains-duplicate-iii/discuss/61645/AC-O(N)-solution-in-Java-using-buckets-with-explanation) ).\\n\\n```\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        var map = new Dictionary<long, long>();\\n        \\n        for (var i = 0; i < nums.Length; i++) {\\n            var (key, value) = GetBucket(nums[i], t);\\n            if (!map.TryAdd(key, value)\\n                || map.ContainsKey(key - 1) && value - map[key - 1] <= t\\n                || map.ContainsKey(key + 1) && map[key + 1] - value <= t) return true;\\n            if (map.Count > k) map.Remove(GetBucket(nums[i - k], t).Key);\\n        }\\n        return false;\\n    }\\n    \\n    private static KeyValuePair<long, long> GetBucket(int num, int t) {\\n        var value = (long) num - int.MinValue;\\n        var key = value / ((long) t + 1);\\n        return new KeyValuePair<long, long>(key, value);\\n    }\\n```",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.Length == 0 || k < 1 || t < 0) return false;\\n\\n        var sortedSet = new SortedSet<int>();\\n\\n        for (var i = 0; i < nums.Length; i++) {\\n            if (ContainsElementsInRange(sortedSet, nums[i], t)) return true;\\n\\n            if (sortedSet.Count == k) sortedSet.Remove(nums[i - k]);\\n            if (!sortedSet.Add(nums[i])) return true;\\n        }\\n        return false;\\n    }\\n\\n    private static bool ContainsElementsInRange(SortedSet<int> sortedSet, int center, int radius) {\\n\\n        var lower = (long) center - radius < int.MinValue ? int.MinValue : center - radius;\\n        var upper = (long) center + radius > int.MaxValue ? int.MaxValue : center + radius;\\n\\n        return sortedSet.GetViewBetween(lower, upper).Count > 0;\\n    }\\n```\n```\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        var map = new Dictionary<long, long>();\\n        \\n        for (var i = 0; i < nums.Length; i++) {\\n            var (key, value) = GetBucket(nums[i], t);\\n            if (!map.TryAdd(key, value)\\n                || map.ContainsKey(key - 1) && value - map[key - 1] <= t\\n                || map.ContainsKey(key + 1) && map[key + 1] - value <= t) return true;\\n            if (map.Count > k) map.Remove(GetBucket(nums[i - k], t).Key);\\n        }\\n        return false;\\n    }\\n    \\n    private static KeyValuePair<long, long> GetBucket(int num, int t) {\\n        var value = (long) num - int.MinValue;\\n        var key = value / ((long) t + 1);\\n        return new KeyValuePair<long, long>(key, value);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 512397,
                "title": "rust-4ms-solution-with-btreeset",
                "content": "```rust\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn contains_nearby_almost_duplicate(nums: Vec<i32>, k: i32, t: i32) -> bool {\\n        if t < 0 {\\n            return false;\\n        }\\n        let k = k as usize;\\n        let t = t as i64;\\n        let mut bts: BTreeSet<i64> = BTreeSet::new();\\n        for i in 0..nums.len() {\\n            if i > k as usize {\\n                bts.remove(&(nums[i - 1 - k] as i64));\\n            }\\n            if bts\\n                .range(nums[i] as i64 - t..=nums[i] as i64 + t)\\n                .next()\\n                .is_some()\\n            {\\n                return true;\\n            }\\n            bts.insert(nums[i] as i64);\\n        }\\n        false\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Ordered Set"
                ],
                "code": "```rust\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn contains_nearby_almost_duplicate(nums: Vec<i32>, k: i32, t: i32) -> bool {\\n        if t < 0 {\\n            return false;\\n        }\\n        let k = k as usize;\\n        let t = t as i64;\\n        let mut bts: BTreeSet<i64> = BTreeSet::new();\\n        for i in 0..nums.len() {\\n            if i > k as usize {\\n                bts.remove(&(nums[i - 1 - k] as i64));\\n            }\\n            if bts\\n                .range(nums[i] as i64 - t..=nums[i] as i64 + t)\\n                .next()\\n                .is_some()\\n            {\\n                return true;\\n            }\\n            bts.insert(nums[i] as i64);\\n        }\\n        false\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 442478,
                "title": "a-simple-java-solution-using-treemap-14-ms",
                "content": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        int len=nums.length;\\n        if(len<=1||k<=0||t<0) return false;\\n        TreeMap<Long,Integer> mp=new TreeMap<>();\\n        for(int i=0;i<len;++i){\\n            Map<Long,Integer> tmpMap=mp.subMap((long)nums[i]-t,(long)nums[i]+t+1);\\n            if(tmpMap.isEmpty()){\\n                mp.put((long)nums[i],i);\\n            }else{\\n                Map<Long,Integer> tmp=new TreeMap<>();\\n                for(long key:tmpMap.keySet()){\\n                    int tmpIndex=tmpMap.get(key);\\n                    if(i-tmpIndex<=k){\\n                        return true;\\n                    }else{\\n                        tmp.put((long)nums[i],i);\\n                    }\\n                }\\n                mp.putAll(tmp);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        int len=nums.length;\\n        if(len<=1||k<=0||t<0) return false;\\n        TreeMap<Long,Integer> mp=new TreeMap<>();\\n        for(int i=0;i<len;++i){\\n            Map<Long,Integer> tmpMap=mp.subMap((long)nums[i]-t,(long)nums[i]+t+1);\\n            if(tmpMap.isEmpty()){\\n                mp.put((long)nums[i],i);\\n            }else{\\n                Map<Long,Integer> tmp=new TreeMap<>();\\n                for(long key:tmpMap.keySet()){\\n                    int tmpIndex=tmpMap.get(key);\\n                    if(i-tmpIndex<=k){\\n                        return true;\\n                    }else{\\n                        tmp.put((long)nums[i],i);\\n                    }\\n                }\\n                mp.putAll(tmp);\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 365721,
                "title": "python-range-sum-using-bit-o-nlogn",
                "content": "```python\\nclass BIT(object):\\n    def __init__(self, N):\\n        self.vals = [0] * (N+1)\\n    def add(self, idx, val):\\n        while idx < len(self.vals):\\n            self.vals[idx] += val\\n            idx += idx & -idx\\n    def query(self, idx):\\n        res = 0\\n        while idx:\\n            res += self.vals[idx]\\n            idx -= idx & -idx\\n        return res\\n\\nclass Solution(object):\\n    def bin_search(self, arr, val):\\n        if arr[0] >= val:\\n            return -1\\n        if arr[-1] < val:\\n            return len(arr) - 1\\n        l, r = 0, len(arr) - 1\\n        while r - l > 1:\\n            m = (r + l) >> 1\\n            if arr[m] >= val:\\n                r = m\\n            else:\\n                l = m\\n        return l\\n    \\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        ns = sorted(list(set(nums)))\\n        n2i = {ns[i]: i for i in range(len(ns))}\\n        \\n        off = 5\\n        bit = BIT(len(ns) + 15)\\n        \\n        N = len(nums)\\n        for i in range(N):\\n            if i - k - 1 >= 0:\\n                bit.add(n2i[nums[i-k-1]] + off, -1)\\n                \\n            n = nums[i]\\n            lower = self.bin_search(ns, n - t)\\n            upper = self.bin_search(ns, n + t + 1)\\n            cnt = bit.query(upper + off) - bit.query(lower + off)\\n            if cnt > 0:\\n                return True\\n            bit.add(n2i[n] + off, 1)\\n        return False\\n```",
                "solutionTags": [],
                "code": "```python\\nclass BIT(object):\\n    def __init__(self, N):\\n        self.vals = [0] * (N+1)\\n    def add(self, idx, val):\\n        while idx < len(self.vals):\\n            self.vals[idx] += val\\n            idx += idx & -idx\\n    def query(self, idx):\\n        res = 0\\n        while idx:\\n            res += self.vals[idx]\\n            idx -= idx & -idx\\n        return res\\n\\nclass Solution(object):\\n    def bin_search(self, arr, val):\\n        if arr[0] >= val:\\n            return -1\\n        if arr[-1] < val:\\n            return len(arr) - 1\\n        l, r = 0, len(arr) - 1\\n        while r - l > 1:\\n            m = (r + l) >> 1\\n            if arr[m] >= val:\\n                r = m\\n            else:\\n                l = m\\n        return l\\n    \\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        \\n        ns = sorted(list(set(nums)))\\n        n2i = {ns[i]: i for i in range(len(ns))}\\n        \\n        off = 5\\n        bit = BIT(len(ns) + 15)\\n        \\n        N = len(nums)\\n        for i in range(N):\\n            if i - k - 1 >= 0:\\n                bit.add(n2i[nums[i-k-1]] + off, -1)\\n                \\n            n = nums[i]\\n            lower = self.bin_search(ns, n - t)\\n            upper = self.bin_search(ns, n + t + 1)\\n            cnt = bit.query(upper + off) - bit.query(lower + off)\\n            if cnt > 0:\\n                return True\\n            bit.add(n2i[n] + off, 1)\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 359420,
                "title": "o-n-solution-using-buckets-and-a-detailed-simplified-explanation-of-how-it-works",
                "content": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if( k < 1 || t < 0)\\n            return false;\\n            LinkedHashMap<Long, Long> map = new LinkedHashMap<>(k);\\n            for(int num : nums){\\n                // convert any negative into positive\\n                long remappedNum = (long)num - Integer.MIN_VALUE;\\n                long bucket;\\n                // this bucket concept is not clear out of the box, so I try to make it easier to understand.\\n                // suppose you have a num let\\'s say = 50, and t = 5\\n                // to achieve that we find a number X that Math.abs(50-X) == 5\\n                // we search or a number, that would have the same output, if we divide it by 5\\n                // given that we always round the output, as we use integers, not float\\n                // so 45/5=9 while 50/5=10, which means that 45 belongs to the bucket before 50\\n                // another example, 55/5 = 11, which means that 55 belongs to the same bucket as 50\\n                // which means, that the absolute difference between both = 5\\n                // if we consider 44 for ex, you find 44/5=8 which is less than 10-1 (50 bucket)\\n                // For the case for 56, so bucket is = 56/5=11, which is bucket(50)+1\\n                // in this case, we still need to validate manually that 56-50 <= 5\\n                if( t == 0)\\n                    bucket = remappedNum;\\n                else\\n                    bucket = remappedNum/((long)(t));\\n                if( map.containsKey(bucket)\\n                  || (map.containsKey(bucket-1) && Math.abs(map.get(bucket-1) - remappedNum) <= t)\\n                  || (map.containsKey(bucket+1) && Math.abs(map.get(bucket+1) - remappedNum) <= t)){\\n                    return true;\\n                }\\n                // to achieve the k goal which is the max diff between the positions\\n                // of the two numbers in the array, we maintain only max k numbers in the map\\n                // Since this is LinkedListMap which keeps track of the order of the elements\\n                // inserted, we can always remove the first element, whenever we reach the k size\\n                if( map.size() >= k){\\n                    map.remove(map.keySet().iterator().next());\\n                }\\n                map.put(bucket, remappedNum);\\n            }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if( k < 1 || t < 0)\\n            return false;\\n            LinkedHashMap<Long, Long> map = new LinkedHashMap<>(k);\\n            for(int num : nums){\\n                // convert any negative into positive\\n                long remappedNum = (long)num - Integer.MIN_VALUE;\\n                long bucket;\\n                // this bucket concept is not clear out of the box, so I try to make it easier to understand.\\n                // suppose you have a num let\\'s say = 50, and t = 5\\n                // to achieve that we find a number X that Math.abs(50-X) == 5\\n                // we search or a number, that would have the same output, if we divide it by 5\\n                // given that we always round the output, as we use integers, not float\\n                // so 45/5=9 while 50/5=10, which means that 45 belongs to the bucket before 50\\n                // another example, 55/5 = 11, which means that 55 belongs to the same bucket as 50\\n                // which means, that the absolute difference between both = 5\\n                // if we consider 44 for ex, you find 44/5=8 which is less than 10-1 (50 bucket)\\n                // For the case for 56, so bucket is = 56/5=11, which is bucket(50)+1\\n                // in this case, we still need to validate manually that 56-50 <= 5\\n                if( t == 0)\\n                    bucket = remappedNum;\\n                else\\n                    bucket = remappedNum/((long)(t));\\n                if( map.containsKey(bucket)\\n                  || (map.containsKey(bucket-1) && Math.abs(map.get(bucket-1) - remappedNum) <= t)\\n                  || (map.containsKey(bucket+1) && Math.abs(map.get(bucket+1) - remappedNum) <= t)){\\n                    return true;\\n                }\\n                // to achieve the k goal which is the max diff between the positions\\n                // of the two numbers in the array, we maintain only max k numbers in the map\\n                // Since this is LinkedListMap which keeps track of the order of the elements\\n                // inserted, we can always remove the first element, whenever we reach the k size\\n                if( map.size() >= k){\\n                    map.remove(map.keySet().iterator().next());\\n                }\\n                map.put(bucket, remappedNum);\\n            }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 352950,
                "title": "c-beating-98-67-simple-program",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<int, int>>dup;\\n        for(int i=0; i<nums.size();i++){\\n            dup.push_back(make_pair(nums[i],i));\\n        }\\n        \\n        sort(dup.begin(), dup.end());\\n        for(int i=0; i<nums.size();i++){\\n            for(int j=i+1; j<nums.size();j++){\\n                if(dup[i].first+t>=dup[j].first){\\n                   if(abs(dup[i].second-dup[j].second)<=k){\\n                        return true;\\n               } \\n                }\\n                else{\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<int, int>>dup;\\n        for(int i=0; i<nums.size();i++){\\n            dup.push_back(make_pair(nums[i],i));\\n        }\\n        \\n        sort(dup.begin(), dup.end());\\n        for(int i=0; i<nums.size();i++){\\n            for(int j=i+1; j<nums.size();j++){\\n                if(dup[i].first+t>=dup[j].first){\\n                   if(abs(dup[i].second-dup[j].second)<=k){\\n                        return true;\\n               } \\n                }\\n                else{\\n                    break;\\n                }\\n                \\n            }\\n        }\\n        \\n        return false;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 260610,
                "title": "javascript-95-o-nlogn",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    const sortedIndex = nums.map((num, i) => ({num, i})).sort((a,b) => a.num-b.num);\\n    let start = 0;\\n    let end = 1;\\n    \\n    while(end < sortedIndex.length) {\\n        if (start === end) {\\n            end++;\\n            continue;\\n        }\\n        \\n        const a = sortedIndex[start];\\n        const b = sortedIndex[end];\\n        \\n        if (b.num - a.num > t) {\\n            start++;\\n            continue;\\n        }\\n        \\n        if (Math.abs(b.i - a.i) > k) {\\n            end++;\\n            continue;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    return false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    const sortedIndex = nums.map((num, i) => ({num, i})).sort((a,b) => a.num-b.num);\\n    let start = 0;\\n    let end = 1;\\n    \\n    while(end < sortedIndex.length) {\\n        if (start === end) {\\n            end++;\\n            continue;\\n        }\\n        \\n        const a = sortedIndex[start];\\n        const b = sortedIndex[end];\\n        \\n        if (b.num - a.num > t) {\\n            start++;\\n            continue;\\n        }\\n        \\n        if (Math.abs(b.i - a.i) > k) {\\n            end++;\\n            continue;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 214078,
                "title": "java-solution-with-0-nk",
                "content": "Runtime: 6 ms, faster than 97.37% of Java online submissions for Contains Duplicate III.\\n\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        \\n        if(nums.length<2){\\n            return false;\\n        }\\n\\t\\tHashSet<Integer> hs = new HashSet<Integer>();\\n\\t\\t\\n\\t\\tfor(int i=0; i<nums.length; i++)\\n\\t\\t{\\n\\t\\ths.add(nums[i]);\\n\\t\\t}\\n\\t\\tif(t==0 && nums.length == hs.size())\\n\\t\\t{\\n\\t\\treturn false;\\n\\t\\t}\\n        \\n        for(int i=0; i<nums.length; i++)\\n        {\\n          for(int j=i+1;j<=i+k &&j<nums.length;j++)\\n          {\\n            /*if((nums[j] ==  Integer.MAX_VALUE && start<0) || (nums[j] <0 && start==Integer.MAX_VALUE))\\n            {\\n                return false;\\n            }*/ // dont do this. tradoff with variable data size.\\n             \\n              if(Math.abs((long)nums[j]-(long)nums[i]) <= (long)t)  {\\n                return true;\\n            }\\n          }\\n        }\\n        \\n     return false;   \\n    }\\n}\\n\\nTwo important points for noting down;\\n\\n1) Convert to long in case of overflow.\\n2) The hashset is needed incase t==0, and the list contains duplicate elements.\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        \\n        if(nums.length<2){\\n            return false;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 142040,
                "title": "naive-python-solution-beat-97",
                "content": "```\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        if t==0 and len(nums)== len(set(nums)): \\n            return False\\n        for i in range(len(nums)):\\n            for j in range(1,k+1):\\n                if i+j >= len(nums):break\\n                if abs(nums[i+j]-nums[i])<=t:return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type k: int\\n        :type t: int\\n        :rtype: bool\\n        \"\"\"\\n        if t==0 and len(nums)== len(set(nums)): \\n            return False\\n        for i in range(len(nums)):\\n            for j in range(1,k+1):\\n                if i+j >= len(nums):break\\n                if abs(nums[i+j]-nums[i])<=t:return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61674,
                "title": "my-c-solution-by-sortedset",
                "content": "```\\npublic class Solution {\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) \\n    {\\n        if(nums == null || nums.Count()<2 || k < 1 || t<0)\\n            return false;\\n        var ss = new SortedSet<long>();\\n        for(int i = 0; i<nums.Count(); i++)\\n        {\\n            if(i>k)\\n            {\\n                ss.Remove(nums[i-k-1]);\\n            }\\n            if(ss.GetViewBetween((long)nums[i]-t, (long)nums[i]+t).Count()>0)\\n                return true;\\n            ss.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public bool ContainsNearbyAlmostDuplicate(int[] nums, int k, int t) \\n    {\\n        if(nums == null || nums.Count()<2 || k < 1 || t<0)\\n            return false;\\n        var ss = new SortedSet<long>();\\n        for(int i = 0; i<nums.Count(); i++)\\n        {\\n            if(i>k)\\n            {\\n                ss.Remove(nums[i-k-1]);\\n            }\\n            if(ss.GetViewBetween((long)nums[i]-t, (long)nums[i]+t).Count()>0)\\n                return true;\\n            ss.Add(nums[i]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61713,
                "title": "c-solution-using-bucket-beats-99-6",
                "content": "Inspired by @maruchan76 https://discuss.leetcode.com/topic/29477/why-no-one-posted-o-n-solution-in-c-using-bucket-sort,  but use a array (buckets) to store the indices of numbers in vector \"nums\" without using unordered_map. Use type long long to prevent overflow.\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        int min_num = INT_MAX;\\n        int max_num = INT_MIN;\\n        for (auto& num: nums) {\\n            min_num = std::min(min_num, num);\\n            max_num = std::max(max_num, num);\\n        }\\n        long long bucket_width = static_cast<long long>(t) + 1;\\n        int size = (static_cast<long long>(max_num) - static_cast<long long>(min_num)) / bucket_width + 1;\\n        int* bucket = new int[size];\\n        memset(bucket, -1, sizeof(int) * size);\\n        for (int i = 0; i < nums.size(); i++) {\\n            int bucket_idx = (static_cast<long long>(nums[i])-min_num) / bucket_width;\\n            if (bucket[bucket_idx] >= 0)\\n                return true;\\n            bucket[bucket_idx] = i;\\n            if (bucket_idx >= 1) {\\n                int j = bucket[bucket_idx-1];\\n                if (j >= 0 && abs(static_cast<long long>(nums[i]) - nums[j]) <= t)\\n                    return true;\\n            }\\n            if (bucket_idx < size-1) {\\n                int l = bucket[bucket_idx+1];\\n                if (l >= 0 && abs(static_cast<long long>(nums[i]) - nums[l]) <= t)\\n                    return true;\\n            }\\n            if (i >= k) {\\n                bucket[(nums[i-k] - min_num) / bucket_width] = -1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        if (k < 1 || t < 0) return false;\\n        int min_num = INT_MAX;\\n        int max_num = INT_MIN;\\n        for (auto& num: nums) {\\n            min_num = std::min(min_num, num);\\n            max_num = std::max(max_num, num);\\n        }\\n        long long bucket_width = static_cast<long long>(t) + 1;\\n        int size = (static_cast<long long>(max_num) - static_cast<long long>(min_num)) / bucket_width + 1;\\n        int* bucket = new int[size];\\n        memset(bucket, -1, sizeof(int) * size);\\n        for (int i = 0; i < nums.size(); i++) {\\n            int bucket_idx = (static_cast<long long>(nums[i])-min_num) / bucket_width;\\n            if (bucket[bucket_idx] >= 0)\\n                return true;\\n            bucket[bucket_idx] = i;\\n            if (bucket_idx >= 1) {\\n                int j = bucket[bucket_idx-1];\\n                if (j >= 0 && abs(static_cast<long long>(nums[i]) - nums[j]) <= t)\\n                    return true;\\n            }\\n            if (bucket_idx < size-1) {\\n                int l = bucket[bucket_idx+1];\\n                if (l >= 0 && abs(static_cast<long long>(nums[i]) - nums[l]) <= t)\\n                    return true;\\n            }\\n            if (i >= k) {\\n                bucket[(nums[i-k] - min_num) / bucket_width] = -1;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 61772,
                "title": "i-finally-got-ac-in-java-with-the-coherent-code",
                "content": "First,let's start with simple and instuitive method which is two loop ,one for enumerating the nums[i] ,the other one for enumerating the nums[j] ,j-i<=k;\\n\\n    Pseudo code:\\n                            for(int i=0;i<nums.length-1;i++)\\n                                     for(int j=1;j<=k;j++) //becaust the problem indicate the distinct i and j,so j start from 1\\n                                             see if there exist the difference bettween nums[i] and nums[j+i]\\n                                              is at most t;\\n\\n\\nthis method is timeout with no doubt,how can we improve it?.if we notice  in the second loop that everytime i++, we will take o(n) time make comparison,but the number used to compare  actually change one.so if we use a good data structure store it,everytime we will just take o(logN) to compare and O(logN) to change one number in this data structure.most People use set data structure to store it.you can choose the others.\\n\\n    Pseudo code:\\n                           for(int i=0;i<nums.length-1;i++)\\n                                     see if there exist the difference bettween nums[i] and the number\\n                                                      in the set is at most t.               \\n\\n                               \\nfinally ,if you want the AC,you must take care some boundary problems. the following is my AC code which is not perfect ,just for refer.\\n\\n     public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t){\\n\\t\\t TreeSet<Integer> set = new TreeSet<Integer>();\\n\\t\\t if(nums.length==0 || k==0)\\n\\t\\t\\t return false;\\n\\t\\t k=k<nums.length-1?k:nums.length-1;\\n\\t\\t for(int i=1;i<=k;i++)\\n\\t\\t\\t set.add(nums[i]);\\n\\t\\t for(int i=0;i<nums.length-1;i++){\\n\\t\\t\\t if(nums[i]-t-1>=nums[i]+t)\\n\\t\\t\\t\\t return false;\\n\\t\\t\\t if(!set.subSet(nums[i]-t, nums[i]+t).isEmpty()||set.contains(nums[i]+t))\\t\\t \\n\\t\\t\\t\\t return true;\\t\\t\\t\\t \\n\\t\\t\\t else{\\n\\t\\t\\t\\t if(i!=nums.length-2)\\n\\t\\t\\t\\t\\t set.remove(nums[i+1]);\\n\\t\\t\\t\\t else\\n\\t\\t\\t\\t\\t break;\\n\\t\\t\\t\\t if(i+k+1 <nums.length)\\n\\t\\t\\t\\t\\t set.add(nums[i+k+1]);\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t return false;\\n\\t }",
                "solutionTags": [
                    "Java",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "First,let's start with simple and instuitive method which is two loop ,one for enumerating the nums[i] ,the other one for enumerating the nums[j] ,j-i<=k;\\n\\n    Pseudo code:\\n                            for(int i=0;i<nums.length-1;i++)\\n                                     for(int j=1;j<=k;j++) //becaust the problem indicate the distinct i and j,so j start from 1\\n                                             see if there exist the difference bettween nums[i] and nums[j+i]\\n                                              is at most t;\\n\\n\\nthis method is timeout with no doubt,how can we improve it?.if we notice  in the second loop that everytime i++, we will take o(n) time make comparison,but the number used to compare  actually change one.so if we use a good data structure store it,everytime we will just take o(logN) to compare and O(logN) to change one number in this data structure.most People use set data structure to store it.you can choose the others.\\n\\n    Pseudo code:\\n                           for(int i=0;i<nums.length-1;i++)\\n                                     see if there exist the difference bettween nums[i] and the number\\n                                                      in the set is at most t.               \\n\\n                               \\nfinally ,if you want the AC,you must take care some boundary problems. the following is my AC code which is not perfect ,just for refer.\\n\\n     public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t){\\n\\t\\t TreeSet<Integer> set = new TreeSet<Integer>();\\n\\t\\t if(nums.length==0 || k==0)\\n\\t\\t\\t return false;\\n\\t\\t k=k<nums.length-1?k:nums.length-1;\\n\\t\\t for(int i=1;i<=k;i++)\\n\\t\\t\\t set.add(nums[i]);\\n\\t\\t for(int i=0;i<nums.length-1;i++){\\n\\t\\t\\t if(nums[i]-t-1>=nums[i]+t)\\n\\t\\t\\t\\t return false;\\n\\t\\t\\t if(!set.subSet(nums[i]-t, nums[i]+t).isEmpty()||set.contains(nums[i]+t))\\t\\t \\n\\t\\t\\t\\t return true;\\t\\t\\t\\t \\n\\t\\t\\t else{\\n\\t\\t\\t\\t if(i!=nums.length-2)\\n\\t\\t\\t\\t\\t set.remove(nums[i+1]);\\n\\t\\t\\t\\t else\\n\\t\\t\\t\\t\\t break;\\n\\t\\t\\t\\t if(i+k+1 <nums.length)\\n\\t\\t\\t\\t\\t set.add(nums[i+k+1]);\\n\\t\\t\\t }\\n\\t\\t }\\n\\t\\t return false;\\n\\t }",
                "codeTag": "Unknown"
            },
            {
                "id": 3695012,
                "title": "simple-and-easier-way-to-solve-using-java",
                "content": "# Intuition\\nThe program asks us to check whether 2 elements has difference in their indices at most equal to indexDiff and a difference in their values at most equal to valueDiff..\\n\\n# Approach\\n 1.initial loop should cover each element\\'s position\\n  2.second loop should start from the following element of i and should work till i+IndexDiff,since we need to find the indices whose difference is equal to IndexDiff.\\nEvery time we have i and we have a fixed IndexDiff so to find the range of j we can just add i and indexdiff but to find exact which value of j works we start the j loop where we continue with the checkings and if succeded return true\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) \\n    {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<=i+indexDiff;j++)\\n            {\\n                if(j<nums.length)\\n                {\\n                 if(Math.abs(i-j)<=indexDiff && Math.abs(nums[i]-nums[j])<=valueDiff)\\n                    {\\n                       return true;\\n                        \\n                    }\\n                }\\n                \\n\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) \\n    {\\n        for(int i=0;i<nums.length;i++)\\n        {\\n            for(int j=i+1;j<=i+indexDiff;j++)\\n            {\\n                if(j<nums.length)\\n                {\\n                 if(Math.abs(i-j)<=indexDiff && Math.abs(nums[i]-nums[j])<=valueDiff)\\n                    {\\n                       return true;\\n                        \\n                    }\\n                }\\n                \\n\\n            }\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435588,
                "title": "simple-c-vector-of-pair-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        vector<pair<int,int>> v;    //val,pos\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v.push_back(make_pair(nums[i],i));\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=i+1;j<v.size();j++)\\n            {\\n                if(abs(v[i].first-v[j].first)<=valueDiff && abs(v[i].second-v[j].second)<=indexDiff)\\n                    return true;\\n                else if(abs(v[i].first-v[j].first)>valueDiff)\\n                    break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        vector<pair<int,int>> v;    //val,pos\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            v.push_back(make_pair(nums[i],i));\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<v.size();i++)\\n        {\\n            for(int j=i+1;j<v.size();j++)\\n            {\\n                if(abs(v[i].first-v[j].first)<=valueDiff && abs(v[i].second-v[j].second)<=indexDiff)\\n                    return true;\\n                else if(abs(v[i].first-v[j].first)>valueDiff)\\n                    break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773111,
                "title": "javascript-solution",
                "content": "1)Sliding Window\\nvar containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {\\n    \\n\\tlet first = 0\\n    let i = 0\\n    while (first < nums.length-1) {\\n        let diif1 = Math.abs(first - i++)\\n        let dif = Math.abs(nums[first] - nums[i])\\n        if (diif1 <= indexDiff && dif <= valueDiff)\\n            return true\\n        else if (i - first == indexDiff) {\\n            first++\\n            i = first\\n        }\\n    }\\n    return false\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "1)Sliding Window\\nvar containsNearbyAlmostDuplicate = function(nums, indexDiff, valueDiff) {\\n    \\n\\tlet first = 0\\n    let i = 0\\n    while (first < nums.length-1) {\\n        let diif1 = Math.abs(first - i++)\\n        let dif = Math.abs(nums[first] - nums[i])\\n        if (diif1 <= indexDiff && dif <= valueDiff)\\n            return true\\n        else if (i - first == indexDiff) {\\n            first++\\n            i = first\\n        }\\n    }\\n    return false\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2750238,
                "title": "java-ordered-set-using-treeset",
                "content": "# Intuition\\nVariable Length Sliding Window. \\n\\n\\n# Approach\\n1) Need a Data Structure to store the previously seen Elements (Some set is preferred). \\n2) Since we are given a condition to get abs(nums[l]-nums[r]) <= valueDiff 2.1) As we progress we begin to observe that at any point we need the closest min and max value to the current element that is being processed.\\n2.2) With these values we will be able to calculate if any of the valueDiff obtained from min or max values is less than or equal to given valueDiff\\n3) Data Structure which provides closest values of a given number effeciently is --- *TreeSet*\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int n = nums.length;\\n        if(n == 1){\\n            return false;\\n        }\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        int l = 0, r = 0, minLimit = Integer.MIN_VALUE, maxLimit = Integer.MAX_VALUE;\\n        while(r<n){\\n            if(r-l <= indexDiff){\\n                int mi = ts.floor(nums[r]) == null ? Integer.MAX_VALUE : Math.abs(ts.floor(nums[r]) - nums[r]), \\n                ma = ts.ceiling(nums[r]) == null ? Integer.MAX_VALUE : Math.abs(ts.ceiling(nums[r]) - nums[r]);\\n                if(mi <= valueDiff){\\n                    return true;\\n                }\\n                else if(ma <= valueDiff){\\n                    return true;\\n                }\\n                else{\\n                    ts.add(nums[r]);\\n                    r++;\\n                }\\n            }\\n            else{\\n                ts.remove(nums[l]);\\n                l++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int indexDiff, int valueDiff) {\\n        int n = nums.length;\\n        if(n == 1){\\n            return false;\\n        }\\n        TreeSet<Integer> ts = new TreeSet<>();\\n        int l = 0, r = 0, minLimit = Integer.MIN_VALUE, maxLimit = Integer.MAX_VALUE;\\n        while(r<n){\\n            if(r-l <= indexDiff){\\n                int mi = ts.floor(nums[r]) == null ? Integer.MAX_VALUE : Math.abs(ts.floor(nums[r]) - nums[r]), \\n                ma = ts.ceiling(nums[r]) == null ? Integer.MAX_VALUE : Math.abs(ts.ceiling(nums[r]) - nums[r]);\\n                if(mi <= valueDiff){\\n                    return true;\\n                }\\n                else if(ma <= valueDiff){\\n                    return true;\\n                }\\n                else{\\n                    ts.add(nums[r]);\\n                    r++;\\n                }\\n            }\\n            else{\\n                ts.remove(nums[l]);\\n                l++;\\n            }\\n        }\\n\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2567804,
                "title": "javascript-solution-two-approaches-bf-sliding-window",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com\\nIt is very useful, and I just wanted to share it with you.\\nNote: You can bookmark it as a resource, and for another approaches\\n<br>\\n\\n**1) Brute Force Approach**\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n   for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(Math.abs(nums[i]-nums[j])<=t && (Math.abs(i-j)<=k)){\\n                return true;\\n            }\\n        }\\n   }\\n    return false;\\n};\\n```\\n\\n\\n**2) Sliding Window Approach**\\n\\n```\\nlet containsNearbyAlmostDuplicate = (A, K, T, m = {}, abs = Math.abs) => {\\n    let N = A.length;\\n    if (N < 2)\\n        return false;\\n    let bucket = x => T ? Math.floor(x / T) : Math.floor(x / (T + 1));  // \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n    let ok = (i, j) => m[j] != undefined && abs(m[j] - A[i]) <= T;\\n    for (let i = 0; i < N; ++i) {\\n\\t\\t// 1. check each j-th bucket for case 1 || case 2 || case 3\\n        let j = bucket(A[i]);\\n        if (ok(i, j - 1) || ok(i, j) || ok(i, j + 1))  // (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n            return true;\\n        // 2. slide window \\uD83D\\uDC49\\n        m[j] = A[i];                     // \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n        if (0 <= i - K) {\\n            let end = bucket(A[i - K]);  // \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n            delete m[end];\\n        }  \\n    }\\n    return false;\\n};\\n```\\n\\nPlease refer below link for detail explanation:\\nhttps://leet-codes.blogspot.com/2022/09/219-contains-duplicate-ii.html\\nhttps://leet-codes.blogspot.com/2022/09/220-contains-duplicate-iii.html",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n   for(let i=0;i<nums.length;i++){\\n        for(let j=i+1;j<nums.length;j++){\\n            if(Math.abs(nums[i]-nums[j])<=t && (Math.abs(i-j)<=k)){\\n                return true;\\n            }\\n        }\\n   }\\n    return false;\\n};\\n```\n```\\nlet containsNearbyAlmostDuplicate = (A, K, T, m = {}, abs = Math.abs) => {\\n    let N = A.length;\\n    if (N < 2)\\n        return false;\\n    let bucket = x => T ? Math.floor(x / T) : Math.floor(x / (T + 1));  // \\u2B50\\uFE0F +1 to avoid division by 0 when T == 0\\n    let ok = (i, j) => m[j] != undefined && abs(m[j] - A[i]) <= T;\\n    for (let i = 0; i < N; ++i) {\\n\\t\\t// 1. check each j-th bucket for case 1 || case 2 || case 3\\n        let j = bucket(A[i]);\\n        if (ok(i, j - 1) || ok(i, j) || ok(i, j + 1))  // (\\uD83D\\uDC48 adjacent bucket to-the-left || \\uD83C\\uDFAF same bucket || adjacent bucket to-the-right \\uD83D\\uDC49)\\n            return true;\\n        // 2. slide window \\uD83D\\uDC49\\n        m[j] = A[i];                     // \\u2705 add current value A[i] onto the window by mapping A[i] to the j-th bucket\\n        if (0 <= i - K) {\\n            let end = bucket(A[i - K]);  // \\uD83D\\uDEAB remove end value A[i - K] from window by removing mapping A[i - K] to end-th bucket which \"fell off the end\" of window of size K\\n            delete m[end];\\n        }  \\n    }\\n    return false;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2541332,
                "title": "optimal-solution-c-easy-to-understand",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int> &nums, int k, int t)\\n    {\\n        vector<pair<long, long>> v;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            v.push_back({nums[i], i});\\n        }\\n        sort(v.begin(), v.end());\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            for (int j = i + 1; j < nums.size(); j++)\\n            {\\n                if (abs(v[i].first + t >= v[j].first))\\n                {\\n                    if (abs(v[i].second - v[j].second) <= k)\\n                        return true;\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int> &nums, int k, int t)\\n    {\\n        vector<pair<long, long>> v;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            v.push_back({nums[i], i});\\n        }\\n        sort(v.begin(), v.end());\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            for (int j = i + 1; j < nums.size(); j++)\\n            {\\n                if (abs(v[i].first + t >= v[j].first))\\n                {\\n                    if (abs(v[i].second - v[j].second) <= k)\\n                        return true;\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477569,
                "title": "python-simplest-one-pass-solution-with-buckets-in-8-lines",
                "content": "A sliding window of size `t+1` is used so that we don\\'t have to handle the case when `t=0`. Since Python 3.7, dictionaries are ordered, so we can implement LRU cache functionality using `buckets.pop(next(iter(buckets)))`.\\n\\n```python\\ndef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\tbuckets = {}\\n\\tfor i, num in enumerate(nums):\\n\\t\\tv = num // (t + 1)\\n\\t\\tfor bucket in range(v - 1, v + 2):\\n\\t\\t\\tif bucket in buckets and abs(buckets[bucket] - num) <= t: return True\\n\\t\\tbuckets[v] = num\\n\\t\\tif(len(buckets) > k): buckets.pop(next(iter(buckets)))\\n\\treturn False\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\tbuckets = {}\\n\\tfor i, num in enumerate(nums):\\n\\t\\tv = num // (t + 1)\\n\\t\\tfor bucket in range(v - 1, v + 2):\\n\\t\\t\\tif bucket in buckets and abs(buckets[bucket] - num) <= t: return True\\n\\t\\tbuckets[v] = num\\n\\t\\tif(len(buckets) > k): buckets.pop(next(iter(buckets)))\\n\\treturn False\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2256476,
                "title": "python-simple-bucket-approach",
                "content": "\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        dict1, width = {}, t + 1\\n        \\n        for i in range(len(nums)):\\n            bucket = nums[i]//width\\n            \\n            if bucket in dict1:\\n                return True\\n            \\n            if bucket - 1 in dict1 and abs(dict1[bucket - 1] - nums[i]) <= t:\\n                return True\\n            \\n            if bucket + 1 in dict1 and abs(dict1[bucket + 1] - nums[i]) <= t:\\n                return True\\n            \\n            dict1[bucket] = nums[i]\\n            \\n            if i >= k:\\n                del dict1[nums[i-k]//width]\\n            \\n        return False",
                "solutionTags": [],
                "code": "\\n    def containsNearbyAlmostDuplicate(self, nums, k, t):\\n        dict1, width = {}, t + 1\\n        \\n        for i in range(len(nums)):\\n            bucket = nums[i]//width\\n            \\n            if bucket in dict1:\\n                return True\\n            \\n            if bucket - 1 in dict1 and abs(dict1[bucket - 1] - nums[i]) <= t:\\n                return True\\n            \\n            if bucket + 1 in dict1 and abs(dict1[bucket + 1] - nums[i]) <= t:\\n                return True\\n            \\n            dict1[bucket] = nums[i]\\n            \\n            if i >= k:\\n                del dict1[nums[i-k]//width]\\n            \\n        return False",
                "codeTag": "Python3"
            },
            {
                "id": 2238750,
                "title": "python-bucket-with-line-by-line-explanation",
                "content": "\\tclass Solution:\\n\\t\\tdef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tbucket= {}\\n\\t\\t\\t# We use t + 1 here to avoid dividing by 0\\n\\t\\t\\tw = t + 1\\n\\t\\t\\tfor i in range(n):\\n\\t\\t\\t\\t# We calculate the label of the value\\n\\t\\t\\t\\tlabel = nums[i] // w\\n\\n\\t\\t\\t\\tif label in bucket:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t# We will check if there are value in the neighbor groups and if the distance is valid\\n\\t\\t\\t\\tif label - 1 in bucket and abs(nums[i] - bucket[label-1]) <= t:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\tif label + 1 in bucket and abs(nums[i] - bucket[label+1]) <= t:\\n\\t\\t\\t\\t\\treturn True\\n\\t\\t\\t\\t# Replce the bucket with the new value\\n\\t\\t\\t\\tbucket[label] = nums[i]\\n\\t\\t\\t\\t# In the bucket, we will only save the value that is in the window of size k. When i larger than k, we will delete the the values that is not in the window\\n\\t\\t\\t\\t# We we delete this, we will need to add another checking step for the first if statement, if label in bucket, we need to check if the k window size constrain valid.\\n\\t\\t\\t\\tif i >= k:\\n\\t\\t\\t\\t\\tdel bucket[nums[i-k] // w]\\n\\t\\t\\treturn False",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n\\t\\t\\tn = len(nums)\\n\\t\\t\\tbucket= {}",
                "codeTag": "Java"
            },
            {
                "id": 2138742,
                "title": "bst-based-sol-in-java-o-n-log-k",
                "content": "- if we think about the brute force sol, in outer loop we are going through the array and in inner loop we are checking the diff between nums[i] and elements from i + 1 to k elements so essentially for each element we are doing k operations so it O(n * k)\\n- we can optimise the k operations runtime if we use a BST because in BST insertion, deletion, searching all operation are log n so here we can maintain a BST of size k that way we can do all operation in log(k) size , so we can use treeset here we can add k elements to tree and while adding the numbers we can check the range num - t or num + t + 1 in the set if any num exists between this range then we found the nearest duplicate \\nor alternatively you use floor and ceiling method of treeset to check if nearest duplicate exists\\ngive a thumbs up if you like the solution.\\n```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Long> set = new TreeSet<>();\\n        for(int i = 0; i < nums.length; i++){\\n            long from = (long) nums[i] - t;\\n            long to = (long) nums[i] + t + 1;\\n            SortedSet<Long> subSet = set.subSet(from, to);\\n\\n            if(subSet.size() > 0)\\n                return true;\\n\\n            set.add((long)nums[i]);\\n            if(set.size() > k)\\n                set.remove((long)nums[i - k]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        TreeSet<Long> set = new TreeSet<>();\\n        for(int i = 0; i < nums.length; i++){\\n            long from = (long) nums[i] - t;\\n            long to = (long) nums[i] + t + 1;\\n            SortedSet<Long> subSet = set.subSet(from, to);\\n\\n            if(subSet.size() > 0)\\n                return true;\\n\\n            set.add((long)nums[i]);\\n            if(set.size() > k)\\n                set.remove((long)nums[i - k]);\\n        }\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2115793,
                "title": "c-fast-25-ms-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<long,long>> v;\\n        for(int i=0;i<nums.size();i++) {\\n            v.push_back(make_pair(nums[i],i));\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            for(int j = i+1; j<nums.size(); j++){\\n                // cout<<\"abs(nums[i]-nums[j]): \"<<abs(nums[i]-nums[j]);\\n                long long int p = abs((v[i]).first-(v[j]).first);\\n                // cout<<\"Int p: \"<<(long long int)p<<endl;\\n                if(p<= t){\\n                    if(abs(v[i].second - v[j].second)<=k){\\n                        // cout<<\"True \"<<endl;\\n                        return true;                        \\n                    }\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        vector<pair<long,long>> v;\\n        for(int i=0;i<nums.size();i++) {\\n            v.push_back(make_pair(nums[i],i));\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i = 0; i<nums.size(); i++){\\n\\n            for(int j = i+1; j<nums.size(); j++){\\n                // cout<<\"abs(nums[i]-nums[j]): \"<<abs(nums[i]-nums[j]);\\n                long long int p = abs((v[i]).first-(v[j]).first);\\n                // cout<<\"Int p: \"<<(long long int)p<<endl;\\n                if(p<= t){\\n                    if(abs(v[i].second - v[j].second)<=k){\\n                        // cout<<\"True \"<<endl;\\n                        return true;                        \\n                    }\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2096834,
                "title": "java-solution",
                "content": "```\\n// Contains Duplicate III\\n// Leetcode: https://leetcode.com/problems/contains-duplicate-iii/\\n\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length == 0 || k <= 0 || t < 0) {\\n            return false;\\n        }\\n        TreeSet<Long> set = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            long num = (long) nums[i];\\n            Long floor = set.floor(num);\\n            if (floor != null && num - floor <= t) {\\n                return true;\\n            }\\n            Long ceiling = set.ceiling(num);\\n            if (ceiling != null && ceiling - num <= t) {\\n                return true;\\n            }\\n            set.add(num);\\n            if (i >= k) {\\n                set.remove((long) nums[i - k]);\\n            }\\n        }\\n        return false;       \\n    }\\n}\\n```\\n\\n## Explanation -\\n1. The first line of code is to create a TreeSet<Long> set.\\n   This is because we are going to use this set to check if there are duplicates in the array.\\n   This set is sorted and can be used to find duplicates in the array.\\n2. Next, we loop through the array, nums.\\n   For each element in the array, we first create a long variable num, which is the current element in the array.\\n   Then, we create a long variable floor, which is the floor of the current element in the array.\\n   Then, we create a long variable ceiling, which is the ceiling of the current element in the array.\\n   Then, we check if the floor is not null, which means that the floor is not null.\\n   Then, we check if the difference between the floor and the current element in the array is less than or equal to t.\\n   If this is true, then we return true.\\n   If the ceiling is not null, which means that the ceiling is not null.\\n   Then, we check if the difference between the ceiling and the current element in the array is less than or equal to t.\\n   If this is true, then we return true.\\n   Then, we add the current element in the array to the set.\\n   Then, we check if the current element in the array is less than or equal to k.\\n   If this is true, we then remove the element in the set that is k away from the current element in the array.\\n   After that, we continue the loop.\\n3. If the loop finishes, which means that there are no duplicates in the array, then we return false.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n// Contains Duplicate III\\n// Leetcode: https://leetcode.com/problems/contains-duplicate-iii/\\n\\nclass Solution {\\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n        if (nums == null || nums.length == 0 || k <= 0 || t < 0) {\\n            return false;\\n        }\\n        TreeSet<Long> set = new TreeSet<>();\\n        for (int i = 0; i < nums.length; i++) {\\n            long num = (long) nums[i];\\n            Long floor = set.floor(num);\\n            if (floor != null && num - floor <= t) {\\n                return true;\\n            }\\n            Long ceiling = set.ceiling(num);\\n            if (ceiling != null && ceiling - num <= t) {\\n                return true;\\n            }\\n            set.add(num);\\n            if (i >= k) {\\n                set.remove((long) nums[i - k]);\\n            }\\n        }\\n        return false;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1974142,
                "title": "python-sliding-window-with-buckets-approach-3",
                "content": "The trick is to understand that each bucket will have at most one element at a time, and has an incremental range of t. The three if conditions check\\n1) We find an element that has the same hashkey (`num//t`) ==> within the current range. \\n2) We find an element in the previous bucket (subtract one from hashkey => the previous range) and the difference is less than or equal to `t`\\n3) We find an element in the next bucket (add one from hashkey => the next range) and the difference is less than or equal to `t`\\n\\nThe hashmap will never have more than k elements, which is handled with the sliding window technique.\\n\\n```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        buckets = {}\\n        # increment by one in case t is 0 (we need to divide by a non-zero number to find the key aka \"label\" in the article)\\n        w = t + 1\\n        for i, num in enumerate(nums):\\n            key = num//w\\n\\t\\t\\t\\n\\t\\t\\t# We found another element within t counts away that\\'s stored in this bucket range\\n            if key in buckets:\\n                return True\\n            \\n\\t\\t\\t# We found another element that is stored in the prevous bucket\\n            if key - 1 in buckets and abs(num - buckets[key-1]) < w:\\n                return True\\n\\t\\t\\t\\t\\n\\t\\t\\t# We found another element that is stored in hte next bucket\\n            if key + 1 in buckets and abs(num - buckets[key + 1]) < w:\\n                return True\\n            \\n            buckets[key] = num\\n            \\n\\t\\t\\t# remove the left-most element of the sliding window\\n            if i >= k:\\n                bKey = nums[i - k]//w\\n                del buckets[bKey]\\n                \\n        return False\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def containsNearbyAlmostDuplicate(self, nums: List[int], k: int, t: int) -> bool:\\n        \\n        buckets = {}\\n        # increment by one in case t is 0 (we need to divide by a non-zero number to find the key aka \"label\" in the article)\\n        w = t + 1\\n        for i, num in enumerate(nums):\\n            key = num//w\\n\\t\\t\\t\\n\\t\\t\\t# We found another element within t counts away that\\'s stored in this bucket range\\n            if key in buckets:\\n                return True\\n            \\n\\t\\t\\t# We found another element that is stored in the prevous bucket\\n            if key - 1 in buckets and abs(num - buckets[key-1]) < w:\\n                return True\\n\\t\\t\\t\\t\\n\\t\\t\\t# We found another element that is stored in hte next bucket\\n            if key + 1 in buckets and abs(num - buckets[key + 1]) < w:\\n                return True\\n            \\n            buckets[key] = num\\n            \\n\\t\\t\\t# remove the left-most element of the sliding window\\n            if i >= k:\\n                bKey = nums[i - k]//w\\n                del buckets[bKey]\\n                \\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856757,
                "title": "c-binary-search",
                "content": "```\\n#define lln long long int\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n= nums.size();\\n        vector<pair<lln,int>>v(n);\\n        for(int i=0;i<n;i++){\\n            v[i]={nums[i],i};\\n        }\\n        sort(v.begin(),v.end());\\n        for(int i=0;i<n;i++){\\n            // |x-y| < =t      =>  x-y <=t => x<=t+y\\n            lln y=v[i].first;\\n            lln x=t+y;\\n            int idx=upper_bound(v.begin(),v.end(),pair<lln,int>{x,INT_MAX})-v.begin();\\n            for(int j=i+1;j<idx;j++){\\n                if((v[j].first-v[i].first <=t) && (abs(v[j].second-v[i].second) <= k))\\n                    return true;\\n            }\\n        }\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        int n= nums.size();\\n        vector<pair<lln,int>>v(n);\\n        for(int i=0;i<n;i++){\\n            v[i]={nums[i],i}",
                "codeTag": "Java"
            },
            {
                "id": 1755835,
                "title": "c-o-n-solution-using-buckets-with-comments",
                "content": "Approach:\\n1. We walk through the numbers left to right linearly keeping a sliding window of width `k`\\n2. We maintain the numbers that lie within this sliding window inside of \"buckets\". Each bucket has a `bucket-id` which is continguous and has width `t + 1`. This ensures that if two numbers `x` and `y` are such that they get placed in the same bucket i.e. have same `bucket-id`, then `|x - y| <= t`\\n3. So, as we slide our window of width `k` across the array, we\\'d have exactly `k` buckets maintained (Otherwise, by the pigeonhole principle, we\\'d have atleast two numbers that lie in the same bucket and we\\'ve found a solution)\\n4. Additionally, when adding a new element in our window, we also have to check neighbouring buckets to see if they have a number that lies within `t` distance of the newcomer.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        // Impossible to have two distinct indices that are k apart\\n        if(size(nums) < 2 || k < 1)\\n            return false;\\n        \\n        // This is because we compute t+1 and given the bounds on t, that can overflow for int\\n        // So, we need a large type\\n        using val_t_ = long;\\n\\n        // id-of-bucket -> element\\n        // As we\\'ll see later we\\'d need to ever keep only a single element with a given bucket-id\\n        // even though the bucket_size is t + 1.\\n        unordered_map<val_t_, val_t_> bucket;\\n        \\n        //  ...   {-1 : -bucket_size, ...    , -2, -1},\\n        //        { 0 : 0, 1, 2, ..., bucket_size - 1},\\n        //        { 1 : bucket_size, bucket_size + 1, ..., 2*bucket_size - 1}, ...\\n        auto bucket_id = [](val_t_ num, val_t_ bucket_size) {\\n            if(num < 0)\\n                return ((num + 1) / bucket_size) - 1;  // ensure uniform bucket_size\\n            return num / bucket_size;\\n        };\\n        \\n        // +1 because t can be zero\\n        // The fact that any two elements in buckets of size t+1\\n        // are at most t apart (inclusive) still holds\\n        // In fact t+1 is the largest bucket size for which this holds.\\n        auto bucket_size = static_cast<val_t_>(t) + 1;\\n        \\n        for(int i = 0; i < size(nums); i++) {\\n            auto const &num = nums[i];\\n            auto id = bucket_id(num, bucket_size);\\n            \\n            // Already have something in this bucket, newcomer \\'num\\' is guaranteed to be at most \"t\" away from this old resident\\n            if(bucket.count(id))\\n                return true;\\n            \\n            // elements in immediate neighbouring buckets can also be within \"t\" of the newcomer\\n            // No other buckets would have any elements at most \"t\" closer.\\n            // This would not have been guaranteed if bucket_size were smaller than t+1\\n            for(auto neighbour : {id - 1, id + 1})\\n                if(auto it = bucket.find(neighbour); it != bucket.end() && abs(it->second - num) <= t)\\n                    return true;\\n            \\n            // Add current element to bucket (and the sliding window)\\n            bucket[id] = num;\\n            \\n            // If we go through k numbers without exiting early above, that means all of those\\n            // have landed in different buckets. So bucket size must be same as our sliding window size.\\n            // Here we remove the leftmost element from the bucket (and from the sliding window)\\n            // to keep the invariant that the indices are at most k apart.\\n            if(bucket.size() > k)\\n                bucket.erase(bucket_id(nums[i - k], bucket_size));\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        // Impossible to have two distinct indices that are k apart\\n        if(size(nums) < 2 || k < 1)\\n            return false;\\n        \\n        // This is because we compute t+1 and given the bounds on t, that can overflow for int\\n        // So, we need a large type\\n        using val_t_ = long;\\n\\n        // id-of-bucket -> element\\n        // As we\\'ll see later we\\'d need to ever keep only a single element with a given bucket-id\\n        // even though the bucket_size is t + 1.\\n        unordered_map<val_t_, val_t_> bucket;\\n        \\n        //  ...   {-1 : -bucket_size, ...    , -2, -1},\\n        //        { 0 : 0, 1, 2, ..., bucket_size - 1},\\n        //        { 1 : bucket_size, bucket_size + 1, ..., 2*bucket_size - 1}, ...\\n        auto bucket_id = [](val_t_ num, val_t_ bucket_size) {\\n            if(num < 0)\\n                return ((num + 1) / bucket_size) - 1;  // ensure uniform bucket_size\\n            return num / bucket_size;\\n        };\\n        \\n        // +1 because t can be zero\\n        // The fact that any two elements in buckets of size t+1\\n        // are at most t apart (inclusive) still holds\\n        // In fact t+1 is the largest bucket size for which this holds.\\n        auto bucket_size = static_cast<val_t_>(t) + 1;\\n        \\n        for(int i = 0; i < size(nums); i++) {\\n            auto const &num = nums[i];\\n            auto id = bucket_id(num, bucket_size);\\n            \\n            // Already have something in this bucket, newcomer \\'num\\' is guaranteed to be at most \"t\" away from this old resident\\n            if(bucket.count(id))\\n                return true;\\n            \\n            // elements in immediate neighbouring buckets can also be within \"t\" of the newcomer\\n            // No other buckets would have any elements at most \"t\" closer.\\n            // This would not have been guaranteed if bucket_size were smaller than t+1\\n            for(auto neighbour : {id - 1, id + 1})\\n                if(auto it = bucket.find(neighbour); it != bucket.end() && abs(it->second - num) <= t)\\n                    return true;\\n            \\n            // Add current element to bucket (and the sliding window)\\n            bucket[id] = num;\\n            \\n            // If we go through k numbers without exiting early above, that means all of those\\n            // have landed in different buckets. So bucket size must be same as our sliding window size.\\n            // Here we remove the leftmost element from the bucket (and from the sliding window)\\n            // to keep the invariant that the indices are at most k apart.\\n            if(bucket.size() > k)\\n                bucket.erase(bucket_id(nums[i - k], bucket_size));\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1674554,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        \\n        set<int> values;\\n        \\n        //sliding window\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            auto upper = values.upper_bound(nums[i]); //find greater value\\n            if(upper != values.end() && abs((long)nums[i] - *(upper)) <= t)\\n                return true;\\n            \\n            auto lower = values.lower_bound(nums[i]); //find smaller or equal value\\n            if(lower != values.end() && nums[i] == *(lower)) //return true if found equal value\\n                return true;\\n            if(lower != values.begin() && abs((long)nums[i] - *(--lower)) <= t) \\n                return true;\\n            \\n            //Update sliding window\\n            if(i-k >= 0)\\n                values.erase(nums[i-k]); \\n            \\n            if(k >= 1)\\n                values.insert(nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\\n        \\n        set<int> values;\\n        \\n        //sliding window\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            auto upper = values.upper_bound(nums[i]); //find greater value\\n            if(upper != values.end() && abs((long)nums[i] - *(upper)) <= t)\\n                return true;\\n            \\n            auto lower = values.lower_bound(nums[i]); //find smaller or equal value\\n            if(lower != values.end() && nums[i] == *(lower)) //return true if found equal value\\n                return true;\\n            if(lower != values.begin() && abs((long)nums[i] - *(--lower)) <= t) \\n                return true;\\n            \\n            //Update sliding window\\n            if(i-k >= 0)\\n                values.erase(nums[i-k]); \\n            \\n            if(k >= 1)\\n                values.insert(nums[i]);\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647131,
                "title": "javascript-with-buckets",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    if (t < 0) return false\\n    \\n    let getBucketId = function(i, t) {\\n        if (t == 0) return i\\n        return Math.floor( i / t )\\n    }\\n    \\n    let buckets = {}\\n    \\n    for (let i = 0; i < nums.length; i ++) {\\n        //console.log(buckets)\\n\\n        \\n        let bucketId = getBucketId(nums[i], t)\\n        \\n        // there exists one in the bucket\\n        if (bucketId in buckets) return true \\n        \\n        // check one before and one after\\n        let bucketIdBack = (bucketId - 1) + \"\"\\n        if (bucketIdBack in buckets && Math.abs(nums[i] - buckets[bucketIdBack]) <= t) return true\\n        \\n        let bucketIdForward = (bucketId + 1) + \"\"\\n        if (bucketIdForward in buckets && Math.abs(nums[i] - buckets[bucketIdForward]) <= t) return true\\n        \\n        buckets[bucketId] = nums[i]\\n        \\n        // if i >= k delete trailing \\n        if (i >= k) {\\n            delete buckets[ getBucketId(nums[i - k], t) ]\\n        }\\n        \\n    }\\n    \\n    \\n    return false \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    if (t < 0) return false\\n    \\n    let getBucketId = function(i, t) {\\n        if (t == 0) return i\\n        return Math.floor( i / t )\\n    }\\n    \\n    let buckets = {}\\n    \\n    for (let i = 0; i < nums.length; i ++) {\\n        //console.log(buckets)\\n\\n        \\n        let bucketId = getBucketId(nums[i], t)\\n        \\n        // there exists one in the bucket\\n        if (bucketId in buckets) return true \\n        \\n        // check one before and one after\\n        let bucketIdBack = (bucketId - 1) + \"\"\\n        if (bucketIdBack in buckets && Math.abs(nums[i] - buckets[bucketIdBack]) <= t) return true\\n        \\n        let bucketIdForward = (bucketId + 1) + \"\"\\n        if (bucketIdForward in buckets && Math.abs(nums[i] - buckets[bucketIdForward]) <= t) return true\\n        \\n        buckets[bucketId] = nums[i]\\n        \\n        // if i >= k delete trailing \\n        if (i >= k) {\\n            delete buckets[ getBucketId(nums[i - k], t) ]\\n        }\\n        \\n    }\\n    \\n    \\n    return false \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1466518,
                "title": "java-easy-solution-explained",
                "content": "We will use treeset as a data structure because we need to find out the minimum and maximum in the structure, more precisely INFINIMUM and SUPREMUM of that number, that is, the highest minimum close to this number and the smaller one that is in the data set(infinimum)  and   the smallest maximum higher than that number located in the data set(supremum). Infinimum is located with the floor api(), and will be done the operation nums[i] - treeSet.floor((long)nums[i]) <= t that satisfies the condition. Analogous to supremum, it will be  with ceil api and will be done the operation treeSet.ceiling(((long)nums[i]) - nums[i] <= t to check the condition.  The size of the data structure must be maximum k and if it is exceeded we will remove the oldest element located at the i-k position in the nums array.\\n\\n\\n```\\n static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n        TreeSet<Long> treeSet = new TreeSet<>();\\n\\n        for(int i = 0; i < nums.length; i++) {\\n\\n            if(treeSet.floor((long)nums[i]) != null && nums[i] - treeSet.floor((long)nums[i]) <= t) return true;\\n            if(treeSet.ceiling((long)nums[i]) != null && treeSet.ceiling((long)nums[i]) - nums[i] <= t) return true;\\n\\n            treeSet.add((long)nums[i]);\\n            if(treeSet.size() > k){\\n                treeSet.remove((long)nums[i - k]);\\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n static boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\\n\\n        TreeSet<Long> treeSet = new TreeSet<>();\\n\\n        for(int i = 0; i < nums.length; i++) {\\n\\n            if(treeSet.floor((long)nums[i]) != null && nums[i] - treeSet.floor((long)nums[i]) <= t) return true;\\n            if(treeSet.ceiling((long)nums[i]) != null && treeSet.ceiling((long)nums[i]) - nums[i] <= t) return true;\\n\\n            treeSet.add((long)nums[i]);\\n            if(treeSet.size() > k){\\n                treeSet.remove((long)nums[i - k]);\\n            }\\n\\n        }\\n\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1444564,
                "title": "javascript-o-n",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    let buckets = {};\\n    \\n    for(let idx in nums) {\\n        const num = nums[idx];\\n        const b = Math.floor(num / (t+1));\\n        // console.log(num, b)\\n        if(buckets[b] !== undefined) return true;\\n        if(buckets[b-1] !== undefined && (num - buckets[b-1]) <= t) return true;\\n        if(buckets[b+1] !== undefined && (buckets[b+1] - num) <= t) return true;\\n        \\n        buckets[b] = num;\\n        if(idx >= k) delete buckets[Math.floor(nums[idx-k] / (t+1))];\\n    }\\n    return false;\\n}\\n```\\n\\nReference (explaination there): https://leetcode.com/problems/contains-duplicate-iii/discuss/824578/C%2B%2B-O(N)-time-complexity-or-Explained-or-Buckets-or-O(K)-space-complexity",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} k\\n * @param {number} t\\n * @return {boolean}\\n */\\nvar containsNearbyAlmostDuplicate = function(nums, k, t) {\\n    let buckets = {};\\n    \\n    for(let idx in nums) {\\n        const num = nums[idx];\\n        const b = Math.floor(num / (t+1));\\n        // console.log(num, b)\\n        if(buckets[b] !== undefined) return true;\\n        if(buckets[b-1] !== undefined && (num - buckets[b-1]) <= t) return true;\\n        if(buckets[b+1] !== undefined && (buckets[b+1] - num) <= t) return true;\\n        \\n        buckets[b] = num;\\n        if(idx >= k) delete buckets[Math.floor(nums[idx-k] / (t+1))];\\n    }\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1418545,
                "title": "c-set-like-in-the-solution",
                "content": "```\\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int D, int t) {\\n\\n\\tconst int N = nums.size();\\n\\n\\t// num - t <= it <= num + t\\n\\n\\tset<int> s;\\n\\n\\n\\tfor (int i=0; i<N; i++) {\\n\\n\\t\\tauto succ=s.lower_bound(nums[i]);\\n\\t\\tif (succ!=s.end() and (long)*succ - nums[i] <= t) \\n\\t\\t\\treturn true;\\n\\n\\t\\tauto pred=succ;\\n\\t\\tif (pred!=s.begin() and (long)nums[i]-*(--pred) <= t) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\ts.insert(nums[i]);\\n\\t\\tif (s.size()>D)\\n\\t\\t\\ts.erase(nums[i-D]);\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nbool containsNearbyAlmostDuplicate(vector<int>& nums, int D, int t) {\\n\\n\\tconst int N = nums.size();\\n\\n\\t// num - t <= it <= num + t\\n\\n\\tset<int> s;\\n\\n\\n\\tfor (int i=0; i<N; i++) {\\n\\n\\t\\tauto succ=s.lower_bound(nums[i]);\\n\\t\\tif (succ!=s.end() and (long)*succ - nums[i] <= t) \\n\\t\\t\\treturn true;\\n\\n\\t\\tauto pred=succ;\\n\\t\\tif (pred!=s.begin() and (long)nums[i]-*(--pred) <= t) {\\n\\t\\t\\treturn true;\\n\\t\\t}\\n\\n\\t\\ts.insert(nums[i]);\\n\\t\\tif (s.size()>D)\\n\\t\\t\\ts.erase(nums[i-D]);\\n\\t}\\n\\n\\treturn false;\\n}\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1575276,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1569666,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1565204,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1572994,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1566768,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1575092,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1567336,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1567529,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1730331,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1569030,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1575276,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1569666,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1565204,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1572994,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1566768,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1575092,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1567336,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1567529,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1730331,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1569030,
                "content": [
                    {
                        "username": "parakhc4",
                        "content": "They completely abandoned the \\'duplicate\\' part of the question lmao."
                    },
                    {
                        "username": "lchitundu",
                        "content": "apparently...\\n"
                    },
                    {
                        "username": "ignorant_ppp",
                        "content": "exactly..!!"
                    },
                    {
                        "username": "rupkhurana",
                        "content": "[](http://)![image](https://assets.leetcode.com/users/rupkhurana/image_1572242418.png)\\nContains Duplicate : true"
                    },
                    {
                        "username": "adam24",
                        "content": "The problem statement:\\nGiven an array of integers, find out whether there are two distinct indices i and j in the array such that the difference between nums[i] and nums[j] is at most t and the difference between i and j is at most k.\\n\\nSo then if the following are true then return true:\\n\\nnums[i] - nums[j] <=t      and\\n\\ni-j<=k  \\n\\nThen [4,2], 1,1 should be true:\\n\\n2-4<=1  check\\n\\n1-0<=1 check\\n\\nreturn true;\\n\\nSo then you have to assume what they're asking for is:\\n\\nabs(nums[i] - nums[j]) <=t      and\\n\\nabs(i-j)<=k\\n\\nbut then I propose the question of why offer a possible scenario of t<0.    \\n\\nEither way, this problem is not correct as written."
                    },
                    {
                        "username": "Dan1c",
                        "content": "nums = [1,0,1,1], k = 1, **t = 2.**\\nWhy result is true?\\n\\n"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "lonely_wolf",
                        "content": "Hi,\\n\\nI think that the description of the code challenge is not very fortunate. In fact, we need to think in terms of a \"distance metric\" for both the indices and the values of the vector. And as such the differences should be in terms of abs(). So abs(i-j) <= k and abs(nums[i] - nums[j]) <= t, I believe.\\n\\nRegards."
                    },
                    {
                        "username": "vpelyush",
                        "content": "I was looking at runtimes achieved by other Java solutions, and the two solutions that popped up for 0 and 1ms are clearly gaming the lack of a test case with 10,000 or more elements in the nums array.\\n\\nThese are the two solutions in question: https://imgur.com/a/DIab60k\\nThey explicitly check if the length of the array is more than 9999, and returning false early if so.\\n\\nThe original constraints note that the length of the nums array can be up to 2 * 10^4, and k can be up to 10^4.\\n\\nI\\'ll add a test case to cover this scenario,..\\nI\\'m new to LeetCode. Do past solution get tested against new test cases for a problem?\\nIt may be possible that the answer to that question is no, in which case someone may have already added such a test case anyways. Oh well."
                    },
                    {
                        "username": "lambor123",
                        "content": "**the absolute difference between nums[i] and nums[j] is at most t**\\nwhy **t** can be negative?"
                    },
                    {
                        "username": "bismeet",
                        "content": "This isnt a medium by any means."
                    },
                    {
                        "username": "mskamel",
                        "content": "Well, it's a hard one now."
                    },
                    {
                        "username": "littleguyshane",
                        "content": "[@st_parker](/st_parker) apparently hard..."
                    },
                    {
                        "username": "st_parker",
                        "content": "Why not? Should it be easy or hard instead?"
                    },
                    {
                        "username": "psrswami92",
                        "content": "nums = [1,0,1,1] indexDiff = 1 valueDiff = 2 \\nwhy the expected value is true for the above test case?\\nCould someone please explain?"
                    },
                    {
                        "username": "sifisom599",
                        "content": "because it is not just equals to, its equals to and less than for both the valueDiff and the indexDiff"
                    },
                    {
                        "username": "NKT",
                        "content": "How is the expected output for this false? [1,2] 1 -1, (1-2 = -1 == t) k=1 as well, Please explain?"
                    },
                    {
                        "username": "janis__",
                        "content": "In the test case with nums = [1,2], indexDiff = 1, and valueDiff = -1, the code returns False because a negative valueDiff is nonsensical in this context. The absolute difference between any two numbers can never be negative. Thus, the code\\'s early check for valueDiff < 0 instantly terminates further processing for such cases."
                    }
                ]
            },
            {
                "id": 1569031,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 1568625,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 2006073,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 1899500,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 1574314,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 1571450,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 1574319,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 2036993,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 2013451,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 1942615,
                "content": [
                    {
                        "username": "vocalnoUA",
                        "content": "I failed at a case similar to the following:\\n\\n{2,3}, k=1, t=-1, expected output: false\\n\\nIt seems the difference is computed as follows\\n\\ndifference = nums[j] - nums[i] where j > i\\n\\notherwise I should be able to pass the test case because nums[0] - nums[1] <= -1\\n\\n\\nIf that's the case, please make it clear in the description"
                    },
                    {
                        "username": "progpeter",
                        "content": "Can anyone tell why this is wrong, as the problem stated that **abs(nums[i]-nums[j]) <=t** and **abs(-2147483648 - 2147483647) <= t which is 1** !!\\n\\n![image](https://assets.leetcode.com/users/images/9b1511d7-3ced-40d1-ad06-22356bb2770f_1629250595.350183.png)\\n"
                    },
                    {
                        "username": "nanda31",
                        "content": "um may I know how  abs(-2147483648 - 2147483647) can be 1 ?"
                    },
                    {
                        "username": "AdityaGaikwad888",
                        "content": "I'm getting TLE on code with liner search approach,,\nis there any other way to do this ??"
                    },
                    {
                        "username": "janis__",
                        "content": "Your linear search approach is causing the time limit exceeded (TLE) error due to its inefficiency for larger datasets. To address this, you can leverage data structures such as hashmaps to store and quickly check for elements, or utilize balanced trees to keep the data sorted and reduce lookup times. "
                    },
                    {
                        "username": "karimfadel",
                        "content": "i couldn't understand how the result of this testcase equals 'True' \n`num=  [7,2,3], indexDiff = 2, valueDiff =3`\n\nAssume:- \n` index [0] - index [2]  => Math.abs(0-2) (2<=indexDiff)  True`\n `nums[0] - nums[2] (7 - 3) = 4`\n`Math.abs(7 - 3)  => (4 <= 3)  False` \n\nis there any explanation? \n"
                    },
                    {
                        "username": "ajayvishnu",
                        "content": "I didn\\'t understand the 2nd challenge. Can anyone explain?"
                    },
                    {
                        "username": "johnsonlu",
                        "content": "My solution fails on this case\\n\\nnums:  [-1,-1]\\nk:         1\\nt:          -1\\n\\nwhy it should return false?"
                    },
                    {
                        "username": "Raakshas",
                        "content": "Input ::\\nnums = [-1,-1]\\nk = 1\\nt = -1\\n\\nMy code is failing for the above test case.\\nHow is t = -1 (a negative number) a valid test case?\\n\\nCan the absolute difference be a negative number?"
                    },
                    {
                        "username": "sergei99",
                        "content": "75 ms 71.2 MB - it's so amazing...\nFound a simple criteria to choose between linear and bsearch implementations based on input parameters."
                    },
                    {
                        "username": "user8104ko",
                        "content": "I got TLE  at the 47 test case out of 49 Actually I wrote my code in 0(N^2) Can any once help me to reduce the time complexity ?"
                    },
                    {
                        "username": "janis__",
                        "content": "To avoid the O(N2)O(N2) time complexity, consider using data structures like balanced trees or buckets to keep track of elements within the indexDiff window. This will allow you to check conditions more efficiently. Implementing such a strategy should push the complexity closer to O(N)O(N) and resolve the TLE issue."
                    },
                    {
                        "username": "feschber",
                        "content": "Aaan again, Testcases that accept my O(n^2) solution no questions asked ..."
                    }
                ]
            },
            {
                "id": 1926938,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1925736,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1910746,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1867465,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1835271,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1820747,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1817664,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1798218,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1797052,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1757537,
                "content": [
                    {
                        "username": "sehajdeep2611",
                        "content": "My 49th testcase is not running. The testcase is empty in all 3 inputs. Dont know how to solve this problem. If someone understands, please explain.\\n\\nclass Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        if(indexDiff == 0){\\n            return false;\\n        }\\n        \\n        for(int i=0; i<nums.size()-1; i++) {\\n            for(int j=indexDiff; j>=1; j--) {\\n                if((i+j) < nums.size()) {\\n                    int m = abs(nums[i] - nums[i + j]);\\n                    if(m <= valueDiff)\\n                        return true;                    \\n                }                                     \\n            }\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "janis__",
                        "content": "Your code doesn\\'t handle the case when the input nums is an empty list, leading to potential out-of-bounds access. Furthermore, your double loop structure inherently goes beyond the given indexDiff distance, checking unnecessary pairs. To fix this, you need to check for empty input and optimize the inner loop to only check up to indexDiff away."
                    },
                    {
                        "username": "Vladislav-Sidorovich",
                        "content": "looks like medium complexity "
                    },
                    {
                        "username": "laticm",
                        "content": "this should be easy, brute force is straightforward"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "How I wish python had a built-in structure for BSTs...\\nImplementing it by hand was painful and took all of my time, not to mention my version wasn\\'t even self-balancing and should probably not have been accepted"
                    },
                    {
                        "username": "bahrainwala",
                        "content": "My solutions says that I have cleared 49/49 test cases and still says time exceeded.\\n\\nTime Limit Exceeded\\n49 / 49 testcases passed\\n\\nWhat does this mean"
                    },
                    {
                        "username": "NeeatCode",
                        "content": "Us bruh us"
                    },
                    {
                        "username": "NeeatCode",
                        "content": " `class Solution {\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff) {\\n        int i = 0;\\n\\t\\tint ws = 1;\\n\\t\\tint j = i + ws;\\n\\t\\twhile(ws<=indexDiff) {\\n\\t\\t\\twhile(j < nums.size()) {\\n\\t\\t\\t\\tint t = abs(nums[i]-nums[j]);\\n\\t\\t\\t\\tif(t<=valueDiff) return true;\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\t\\t\\tws++;\\n\\t\\t\\ti=0;\\n\\t\\t\\tj=i+ws;\\n\\t\\t}\\n\\t\\treturn false;\\n    }\\n};`\\nMay I know why it gives me TLE even if executing all 49 test cases...\\nhttps://leetcode.com/problems/contains-duplicate-iii/submissions/908201340/\\n\\n"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I don't tink you may know until you format your code better.\nMaybe when they say 49/49, it actually means that you are currently testing the 49th case and failed on it, If your solution is O(nk), it's normal"
                    },
                    {
                        "username": "kashiiifshakeel",
                        "content": "can anyone help me in this it passes all the testcases but gives TLE error how can i improve it\\n\\n\\nclass Solution\\n{\\npublic:\\n    bool containsNearbyAlmostDuplicate(vector<int>& nums, int indexDiff, int valueDiff)\\n    {\\n        int i=0;int j=0;\\n        while(i<nums.size())\\n        {\\n            for(j=i+1;j<nums.size();j++)\\n            {\\n                if(i!=j && abs(i-j)<=indexDiff && abs(nums[i]-nums[j])<=valueDiff)\\n                return true;\\n            }\\n            i++;\\n        }\\n        return false;\\n    }\\n};"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "This is an O(n^2) brute force solution, of course it's gonna give you a TLE. A slightly better brute force on a sliding window would be O(nk) and would still fail\nYou need to figure out another approach, this is a hard problem. Can you think of a data structure or a classic algorithm that would allow you to keep track of the relevant data that you have seen in the array, without having to re-scan the whole array every time?"
                    },
                    {
                        "username": "luchici123",
                        "content": "If the relation between elements indexes is one of the requirements, why sorting is recommended?\\n\\nIf we sort the list we will lost the original indexes, so abs(i - j) <= indexDiff become obsolete. "
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "[@manifold1985](/manifold1985) Did you really implement that? How do you delete/add elements to your sorted array as your window is sliding? This is gonna be an O(k) operation, giving you a total complexity of O(nk) which will TLE unless you have a trick up your sleeve"
                    },
                    {
                        "username": "cartesPerforees",
                        "content": "I used a BST, which is kind of partial sorting. But that would be a bad way to hint at that"
                    },
                    {
                        "username": "manifold1985",
                        "content": "Here is how I go about this problem: I use the sliding window technique. But I will use another array, called \"window\", to store the numbers in the window. I will keep the numbers in the \"window\" sorted, so that whenever I arrive at a new candidate, I can use binary search to see if there is any number in window  that is close enough to the new candidate. Does this make sense to you?"
                    },
                    {
                        "username": "abhinav____06",
                        "content": "      for(int i=0;i<nums.size();i++)\\n      {\\n          int j=i+1;\\n          while(abs(i-j)<=indexDiff&&j<nums.size())\\n          {\\n                  if(abs(nums[i]-nums[j])<=valueDiff)\\n                  {\\n                      return true;\\n                  }\\n                  j++;   \\n          }\\n      }\\n      return false;\\nthis solution has passed all the testcase but it was showing time limit exceed still.\\ncan anybody tell me why\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            }
        ]
    },
    {
        "title": "Binary Search",
        "question_content": "<p>Given an array of integers <code>nums</code> which is sorted in ascending order, and an integer <code>target</code>, write a function to search <code>target</code> in <code>nums</code>. If <code>target</code> exists, then return its index. Otherwise, return <code>-1</code>.</p>\n\n<p>You must write an algorithm with <code>O(log n)</code> runtime complexity.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0,3,5,9,12], target = 9\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> 9 exists in nums and its index is 4\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [-1,0,3,5,9,12], target = 2\n<strong>Output:</strong> -1\n<strong>Explanation:</strong> 2 does not exist in nums so return -1\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 10<sup>4</sup></code></li>\n\t<li><code>-10<sup>4</sup> &lt; nums[i], target &lt; 10<sup>4</sup></code></li>\n\t<li>All the integers in <code>nums</code> are <strong>unique</strong>.</li>\n\t<li><code>nums</code> is sorted in ascending order.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 423162,
                "title": "binary-search-101",
                "content": "Binary search is often a topic that\\'s easy to be explained on the abstract level, but when it comes to writing bug free implementations, it\\'s rather difficult. \\n\\nSome of the most common problems include:\\n\\n1. Infinity loop \\n2. Can\\'t decide where to shrink\\n3. Do I use lo or hi\\n4. When to exit the loop\\n5. ...\\n\\nIn this article, I will be sharing my insights on how to write bug free binary search with just a little pattern.\\n\\n*If you are familiar with binary search and just want to see the pattern, you can go directly to the part: The Pattern.*\\n\\n## What is binary search?\\n\\nNormally, to find the target in a group, such as an array of numbers, the worst case scenario is we need to go through every single element (O(n)). However, when these elements are sorted, we are able to take the privilege of this extra information to bring down the search time to O(log n), that is if we have 100 elements, the worst case scenario would be 10 searches. That is a huge performance improvement.\\n\\nThe Gif below demonstrates the power of binary search.\\n\\n![https://assets.leetcode.com/static_assets/posts/1EYkSkQaoduFBhpCVx7nyEA.gif](https://assets.leetcode.com/static_assets/posts/1EYkSkQaoduFBhpCVx7nyEA.gif)\\n\\nThe reason behind this huge performance increase is because for each search iterations, we are able to cut the elements we will be looking at in half. Fewer elements to look at = faster search time. And this all comes from the simple fact that in a sorted list, everything to the right of n will be greater or equal to it, and vice versa.\\n\\nBefore we look at the abstract ideas of binary search, let\\'s see the code first:\\n\\n```jsx\\nvar search = function(nums, target) {\\n    let lo = 0, hi = nums.length-1;\\n    while (lo < hi) {\\n        let mid = lo + Math.floor((hi-lo+1)/2);\\n        if (target < nums[mid]) {\\n            hi = mid - 1\\n        } else {\\n            lo = mid; \\n        }\\n    }\\n    return nums[lo]==target?lo:-1;\\n};\\n```\\n\\n## The fundamental idea\\n\\n**1. `lo` & `hi`**\\nWe define two variables, let\\'s call them `lo` and `hi` . They will store array indexes and they work like a boundary such that we will only be looking at elements inside the boundary.\\nNormally, we would want initialize the boundary to be the entire array.\\n```javascript\\nlet lo = 0, hi = nums.length-1;\\n```\\n\\n**2. `mid`**\\nThe `mid` variable indicates the middle element within the boundary. It separates our boundary into 2 parts. Remember how I said binary search works by keep cutting the elements in half, the `mid` element works like a traffic police, it indicates us which side do we want to cut our boundary to.\\n\\nNote when an array has even number of elements, it\\'s your decision to use either the left `mid` (lower `mid`) or the right `mid` (upper mid)\\n\\n```javascript\\nlet mid = lo + Math.floor((hi - lo) / 2); // left/lower mid\\n\\nlet mid = lo + Math.floor((hi - lo + 1) / 2); // right/upper mid\\n```\\n\\n**3. Comparing the target to `mid`**\\nBy comparing our target to `mid`, we can identify which side of the boundary does the target belong. For example, If our target is greater than `mid`, this means it must exist in the right of `mid` . In this case, there is no reason to even keep a record of all the numbers to its left. And this is the fundamental mechanics of binary search - keep shrinking the boundary.\\n```javascript\\nif (target < nums[mid]) {\\n\\thi = mid - 1\\n} else {\\n\\tlo = mid; \\n}\\n```\\n**4. Keep the loop going**\\nLastly, we use a while loop to keep the search going:\\n```javascript\\nwhile (lo < hi) { ... }\\n```\\nThe while loop only exits when `lo == hi`, which means there\\'s only one element left. And if we implemented everything correctly, that only element should be our answer(assume if the target is in the array).\\n\\n## The pattern\\n\\nIt may seem like binary search is such a simple idea, but when you look closely in the code, we are making some serious decisions that can completely change the behavior of our code. \\nThese decisions include:\\n\\n1. Do I use left or right `mid`?\\n2. Do I use `<` or `<=` , `>` or `>=`?\\n3. How much do I shrink the boundary? is it `mid` or `mid - 1` or even `mid + 1` ?\\n4. ...\\n\\nAnd just by messing up one of these decisions, either because you don\\'t understand it completely or by mistake, it\\'s going to break your code.\\nTo solve these decision problems, I use the following set of rules to always keep me away from trouble, most importantly, it makes my code more consistent and predictable in all edge cases.\\n\\n**1. Choice of `lo` and `hi`, aka the boundary**\\nNormally, we set the initial boundary to the number of elements in the array\\n```javascript\\nlet lo = 0, hi = nums.length - 1;\\n```\\nBut this is not always the case.\\nWe need to remember: the boundary is the range of elements we will be searching from.\\nThe initial boundary should include **ALL** the elements, meaning all the possible answers should be included. Binary search can be applied to none array problems, such as Math, and this statement is still valid.\\n\\nFor example, In LeetCode 35, the question asks us to find an index to **insert** into the array.\\nIt is possible that we insert after the last element of the array, thus the complete range of boundary becomes\\n\\n```javascript\\nlet lo = 0, hi = nums.length;\\n```\\n\\n**2. Calculate `mid`**\\nCalculating mid can result in overflow when the numbers are extremely big. I ll demonstrate a few ways of calculating `mid` from the worst to the best.\\n```javascript\\nlet mid = Math.floor((lo + hi) / 2) // worst, very easy to overflow\\n\\nlet mid = lo + Math.floor((hi - lo) / 2) // much better, but still possible\\n\\nlet mid = (lo + hi) >>> 1 // the best, but hard to understand\\n```\\n\\nWhen we are dealing with even elements, it is our choice to pick the left `mid` or the right `mid` , and as I ll be explaining in a later section, a bad choice will lead to an infinity loop.\\n```javascript\\nlet mid = lo + Math.floor((hi - lo) / 2) // left/lower mid\\n\\nlet mid = lo + Math.floor((hi - lo + 1) / 2) // right/upper mid\\n```\\n\\n**3. How do we shrink boundary**\\nI always try to keep the logic as simple as possible, that is a single pair of `if...else`. But what kind of logic are we using here? My rule of thumb is always use a logic that you can **exclude** `mid`.\\nLet\\'s see an example:\\n```javascript\\nif (target < nums[mid]) {\\n\\thi = mid - 1\\n} else {\\n\\tlo = mid; \\n}\\n```\\nHere, if the target is less than `mid`, there\\'s no way `mid` will be our answer, and we can exclude it very confidently using `hi = mid - 1`. Otherwise, `mid` still has the potential to be the target, thus we include it in the boundary `lo = mid`. \\nOn the other hand, we can rewrite the logic as:\\n```javascript\\nif (target > nums[mid]) {\\n\\tlo = mid + 1; // mid is excluded\\n} else {\\n\\thi = mid; // mid is included\\n}\\n```\\n**4. while loop**\\nTo keep the logic simple, I always use\\n```javascript\\nwhile(lo < hi) { ... }\\n```\\nWhy? Because this way, the only condition the loop exits is `lo == hi`. I know they will be pointing to the same element, and I know that element always exists.\\n\\n**5. Avoid infinity loop**\\nRemember I said a bad choice of left or right `mid` will lead to an infinity loop? Let\\'s tackle this down. \\nExample:\\n```javascript\\nlet mid = lo + ((hi - lo) / 2); // Bad! We should use right/upper mid!\\n\\nif (target < nums[mid]) {\\n\\thi = mid - 1\\n} else {\\n\\tlo = mid; \\n}\\n```\\nNow, imagine when there are only 2 elements left in the boundary. If the logic fell into the `else` statement, since we are using the left/lower mid, it\\'s simply not doing anything. It just keeps shrinking itself to itself, and the program got stuck.\\nWe have to keep in mind that, the choice of  `mid` and our shrinking logic has to work together in a way that every time, at least 1 element is excluded. \\n```javascript\\nlet mid = lo + ((hi - lo + 1) / 2); // Bad! We should use left/lower mid!\\n\\nif (target > nums[mid]) {\\n\\tlo = mid + 1; // mid is excluded\\n} else {\\n\\thi = mid; // mid is included\\n}\\n```\\nSo when your binary search is stuck, think of the situation when there are only 2 elements left. Did the boundary shrink correctly? \\n\\n## TD;DR\\nMy rule of thumb when it comes to binary search:\\n\\n1. Include **ALL** possible answers when initialize `lo` & `hi`\\n2. Don\\'t overflow the `mid` calculation\\n3. Shrink boundary using a logic that will **exclude** mid\\n4. Avoid infinity loop by picking the correct `mid` and shrinking logic\\n5. Always think of the case when there are 2 elements left\\n\\n*Because this problem is a failrly easy, the implementions may be pretty straight forward and you may wonder why do I need so many rules. However, binary search problems can get much much more complex, and without consistent rules, it\\'s very hard to write predictable code. In the end, I would say everybody has their own style of binary serach, find the style that works for you!*",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```jsx\\nvar search = function(nums, target) {\\n    let lo = 0, hi = nums.length-1;\\n    while (lo < hi) {\\n        let mid = lo + Math.floor((hi-lo+1)/2);\\n        if (target < nums[mid]) {\\n            hi = mid - 1\\n        } else {\\n            lo = mid; \\n        }\\n    }\\n    return nums[lo]==target?lo:-1;\\n};\\n```\n```javascript\\nlet lo = 0, hi = nums.length-1;\\n```\n```javascript\\nlet mid = lo + Math.floor((hi - lo) / 2); // left/lower mid\\n\\nlet mid = lo + Math.floor((hi - lo + 1) / 2); // right/upper mid\\n```\n```javascript\\nif (target < nums[mid]) {\\n\\thi = mid - 1\\n} else {\\n\\tlo = mid; \\n}\\n```\n```javascript\\nwhile (lo < hi) { ... }\\n```\n```javascript\\nlet lo = 0, hi = nums.length - 1;\\n```\n```javascript\\nlet lo = 0, hi = nums.length;\\n```\n```javascript\\nlet mid = Math.floor((lo + hi) / 2) // worst, very easy to overflow\\n\\nlet mid = lo + Math.floor((hi - lo) / 2) // much better, but still possible\\n\\nlet mid = (lo + hi) >>> 1 // the best, but hard to understand\\n```\n```javascript\\nlet mid = lo + Math.floor((hi - lo) / 2) // left/lower mid\\n\\nlet mid = lo + Math.floor((hi - lo + 1) / 2) // right/upper mid\\n```\n```javascript\\nif (target < nums[mid]) {\\n\\thi = mid - 1\\n} else {\\n\\tlo = mid; \\n}\\n```\n```javascript\\nif (target > nums[mid]) {\\n\\tlo = mid + 1; // mid is excluded\\n} else {\\n\\thi = mid; // mid is included\\n}\\n```\n```javascript\\nwhile(lo < hi) { ... }\\n```\n```javascript\\nlet mid = lo + ((hi - lo) / 2); // Bad! We should use right/upper mid!\\n\\nif (target < nums[mid]) {\\n\\thi = mid - 1\\n} else {\\n\\tlo = mid; \\n}\\n```\n```javascript\\nlet mid = lo + ((hi - lo + 1) / 2); // Bad! We should use left/lower mid!\\n\\nif (target > nums[mid]) {\\n\\tlo = mid + 1; // mid is excluded\\n} else {\\n\\thi = mid; // mid is included\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3363885,
                "title": "easy-solutions-in-java-python-and-c-look-at-once-with-exaplanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBinary search is an efficient algorithm for searching for a specific target value within a sorted array. The basic idea is to repeatedly divide the search interval in half until the target value is found or the interval is empty. By using this approach, we can quickly eliminate half of the remaining search space at each iteration, resulting in a time complexity of O(log n).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm starts by comparing the target value to the middle element of the sorted array. If the target is equal to the middle element, we return the index of the middle element. If the target is less than the middle element, we repeat the search on the left half of the array. If the target is greater than the middle element, we repeat the search on the right half of the array. We continue this process until either the target is found or the search interval is empty.\\n\\n- Initialize left and right pointers to the beginning and end of the array, respectively.\\n- While the left pointer is less than or equal to the right pointer:\\n \\n    a. Calculate the middle index as the average of the left and right pointers.\\n    b. If the middle element is equal to the target, return the index of the middle element.\\n    c. If the middle element is less than the target, update the left pointer to mid + 1.\\n    d. If the middle element is greater than the target, update the right pointer to mid - 1.\\n\\n- If the target is not found, return -1.\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$ - Since binary search reduces the search space by half at each step, the maximum number of iterations required to find the target is log base 2 of n, where n is the size of the array. Therefore, the time complexity of binary search is $$O(log n)$$.\\n\\n- Space complexity: $$O(1)$$ - Binary search only uses a constant amount of additional space for the two pointers and the middle index variable, so the space complexity is $$O(1)$$.\\n\\n`Note that the above complexity analysis assumes that the array is already sorted. If the array needs to be sorted first, then the time complexity would be dominated by the sorting algorithm, which is typically `$$O(n log n)$$` for comparison-based sorts.`\\n\\n![image.png](https://assets.leetcode.com/users/images/b427e686-2e5d-469a-8e7a-db5140022a6b_1677715904.0948765.png)\\n\\n\\n# Please Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\\n# Code\\n\\n```Java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0; // initialize left pointer to 0\\n        int right = nums.length - 1; // initialize right pointer to the last index of the array\\n        \\n        while (left <= right) { // continue the loop till left pointer is less than or equal to right pointer\\n            int mid = left + (right - left) / 2; // calculate the middle index of the array\\n            \\n            if (nums[mid] == target) { // check if the middle element is equal to target\\n                return mid; // return the middle index\\n            } else if (nums[mid] < target) { // check if the middle element is less than target\\n                left = mid + 1; // move the left pointer to the right of middle element\\n            } else { // if the middle element is greater than target\\n                right = mid - 1; // move the right pointer to the left of middle element\\n            }\\n        }\\n        \\n        return -1; // target not found in the array\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\\n``` Python []\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        \\n        return -1\\n\\n```\\n```javascript []\\nfunction binarySearch(nums, target) {\\n  let left = 0;\\n  let right = nums.length - 1;\\n  \\n  while (left <= right) {\\n    const mid = Math.floor((left + right) / 2);\\n    \\n    if (nums[mid] === target) {\\n      return mid;\\n    } else if (nums[mid] < target) {\\n      left = mid + 1;\\n    } else {\\n      right = mid - 1;\\n    }\\n  }\\n  \\n  return -1;\\n}\\n\\n```\\n\\n# Several different ways to implement  \\nThere are actually several different ways to implement the binary search algorithm, although they all follow the same basic idea of dividing the search space in half at each step. Here are a few variations:\\n``` Recursive_implementation []\\n<!-- Recursive implementation: Instead of using a while loop, you can implement binary search recursively by calling the search function on the left or right half of the array depending on whether the target is greater or less than the middle element. Here\\'s an example implementation: -->\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def binary_search(left, right):\\n            if left > right:\\n                return -1\\n            \\n            mid = (left + right) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                return binary_search(mid + 1, right)\\n            else:\\n                return binary_search(left, mid - 1)\\n        \\n        return binary_search(0, len(nums) - 1)\\n```\\n``` Two_pointers []\\n<!-- Two pointers: Instead of calculating the middle index directly, you can use two pointers to keep track of the search space. The left pointer points to the beginning of the array, and the right pointer points to the end. At each step, you calculate the middle index as the average of the left and right pointers, and then update the pointers accordingly. Here\\'s an example implementation: -->\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        \\n        return -1\\n\\n```\\n``` ModifiedBinarySearch []\\n\\n<!-- Modified binary search: If the array has some special properties, you can modify the binary search algorithm to take advantage of those properties and achieve better performance. For example, if the array is rotated, you can still use binary search if you check whether the left or right half is sorted before deciding which half to search next. Here\\'s an example implementation: -->\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            \\n            if nums[left] <= nums[mid]:\\n                if nums[left] <= target and target < nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            else:\\n                if nums[mid] < target and target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n        \\n        return -1\\n```   \\n```Recursive_approach_Java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        return binarySearch(nums, target, 0, nums.length - 1);\\n    }\\n    \\n    private int binarySearch(int[] nums, int target, int left, int right) {\\n        if (left > right) {\\n            return -1;\\n        }\\n        \\n        int mid = left + (right - left) / 2;\\n        \\n        if (nums[mid] == target) {\\n            return mid;\\n        } else if (nums[mid] < target) {\\n            return binarySearch(nums, target, mid + 1, right);\\n        } else {\\n            return binarySearch(nums, target, left, mid - 1);\\n        }\\n    }\\n}\\n\\n```\\n``` Two_pointer_Approach []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n```\\nThese are just a few examples of how you can implement binary search. Depending on the problem constraints and requirements, there may be other variations or optimizations that can be used as well.\\ncode in java\\n# Please Comment\\uD83D\\uDC4D\\uD83D\\uDC4D\\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n``````",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "Binary Search"
                ],
                "code": "```\\nThanks for visiting my solution.\\uD83D\\uDE0A Keep Learning\\nPlease give my solution an upvote! \\uD83D\\uDC4D\\nIt\\'s a simple way to show your appreciation and\\nkeep me motivated. Thank you! \\uD83D\\uDE0A\\n```\n```Java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0; // initialize left pointer to 0\\n        int right = nums.length - 1; // initialize right pointer to the last index of the array\\n        \\n        while (left <= right) { // continue the loop till left pointer is less than or equal to right pointer\\n            int mid = left + (right - left) / 2; // calculate the middle index of the array\\n            \\n            if (nums[mid] == target) { // check if the middle element is equal to target\\n                return mid; // return the middle index\\n            } else if (nums[mid] < target) { // check if the middle element is less than target\\n                left = mid + 1; // move the left pointer to the right of middle element\\n            } else { // if the middle element is greater than target\\n                right = mid - 1; // move the right pointer to the left of middle element\\n            }\\n        }\\n        \\n        return -1; // target not found in the array\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```\n``` Python []\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        left = 0\\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        \\n        return -1\\n\\n```\n```javascript []\\nfunction binarySearch(nums, target) {\\n  let left = 0;\\n  let right = nums.length - 1;\\n  \\n  while (left <= right) {\\n    const mid = Math.floor((left + right) / 2);\\n    \\n    if (nums[mid] === target) {\\n      return mid;\\n    } else if (nums[mid] < target) {\\n      left = mid + 1;\\n    } else {\\n      right = mid - 1;\\n    }\\n  }\\n  \\n  return -1;\\n}\\n\\n```\n``` Recursive_implementation []\\n<!-- Recursive implementation: Instead of using a while loop, you can implement binary search recursively by calling the search function on the left or right half of the array depending on whether the target is greater or less than the middle element. Here\\'s an example implementation: -->\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        def binary_search(left, right):\\n            if left > right:\\n                return -1\\n            \\n            mid = (left + right) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                return binary_search(mid + 1, right)\\n            else:\\n                return binary_search(left, mid - 1)\\n        \\n        return binary_search(0, len(nums) - 1)\\n```\n``` Two_pointers []\\n<!-- Two pointers: Instead of calculating the middle index directly, you can use two pointers to keep track of the search space. The left pointer points to the beginning of the array, and the right pointer points to the end. At each step, you calculate the middle index as the average of the left and right pointers, and then update the pointers accordingly. Here\\'s an example implementation: -->\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        \\n        return -1\\n\\n```\n``` ModifiedBinarySearch []\\n\\n<!-- Modified binary search: If the array has some special properties, you can modify the binary search algorithm to take advantage of those properties and achieve better performance. For example, if the array is rotated, you can still use binary search if you check whether the left or right half is sorted before deciding which half to search next. Here\\'s an example implementation: -->\\n\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        left, right = 0, len(nums) - 1\\n        \\n        while left <= right:\\n            mid = (left + right) // 2\\n            \\n            if nums[mid] == target:\\n                return mid\\n            \\n            if nums[left] <= nums[mid]:\\n                if nums[left] <= target and target < nums[mid]:\\n                    right = mid - 1\\n                else:\\n                    left = mid + 1\\n            else:\\n                if nums[mid] < target and target <= nums[right]:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n        \\n        return -1\\n```\n```Recursive_approach_Java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        return binarySearch(nums, target, 0, nums.length - 1);\\n    }\\n    \\n    private int binarySearch(int[] nums, int target, int left, int right) {\\n        if (left > right) {\\n            return -1;\\n        }\\n        \\n        int mid = left + (right - left) / 2;\\n        \\n        if (nums[mid] == target) {\\n            return mid;\\n        } else if (nums[mid] < target) {\\n            return binarySearch(nums, target, mid + 1, right);\\n        } else {\\n            return binarySearch(nums, target, left, mid - 1);\\n        }\\n    }\\n}\\n\\n```\n``` Two_pointer_Approach []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        \\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            \\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (nums[mid] < target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n\\n```\n```\\nThanks for visiting my solution comment below if you like it.\\uD83D\\uDE0A\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1456130,
                "title": "c-simple-and-fast-binary-search",
                "content": "**Upvote to motivate**\\n```\\nint search(vector<int>& nums, int target) {\\n        int n = nums.size()-1;\\n        int low = 0, high = n;\\n        while( low <= high){\\n            int mid = low + (high-low)/2;\\n            if (nums[mid] == target) return mid;\\n            else if (nums[mid] > target) high = mid -1;\\n            else low = mid + 1;\\n        }\\n        return -1;\\n  }\\n  ```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nint search(vector<int>& nums, int target) {\\n        int n = nums.size()-1;\\n        int low = 0, high = n;\\n        while( low <= high){\\n            int mid = low + (high-low)/2;\\n            if (nums[mid] == target) return mid;\\n            else if (nums[mid] > target) high = mid -1;\\n            else low = mid + 1;\\n        }\\n        return -1;\\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884068,
                "title": "python-javascript-easy-solution-with-very-clear-explanation",
                "content": "**Please dont downvote guys if cannot support,We are putting lot of effort in it\\uD83D\\uDE42**\\n\\n```\\nHello guys \\uD83D\\uDE00 !\\n\\nGiven question:\\nGiven an array of integers nums which is sorted in   ascending order` ,\\nan integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\\n\\nQuestion Explanation:\\n    basically, we need to check if the target is in the array. using binary search.\\n\\t\\n\\tBig O:\\n    n--> number of elements in the array\\n    Time Complexity: O(log(n)) - because we are using binary search\\n    Space Complexity: O(1)\\n```\\n\\n\\n![image](https://assets.leetcode.com/users/images/961c518c-e23c-472a-b2ba-d8a4082593e7_1648267807.7802362.png)\\n\\n![image](https://assets.leetcode.com/users/images/9d49a199-2c3a-472f-a4be-48bc5dfa8d17_1648268518.5380454.gif)\\n\\n\\n`Javascript`\\n```\\nconst search = (nums, target) => {\\n  let left = 0;\\n  let right = nums.length - 1;\\n  console.log(right);\\n  while (left <= right) {\\n    let mid = Math.floor((left + right) / 2); // ! getting out mid val\\n    if (nums[mid] === target) { // ! if mid val is equal to target we will return the mid \\n      return mid;\\n    } else if (nums[mid] < target) { \\n\\n      left = mid + 1; /// ! if mid val is less than target we will move the left pointer to mid+1\\n    } else {\\n        right = mid - 1; // ! if mid val is greater than target we will move the right pointer mid-1\\n    }\\n  }\\n  //! if we cant find the target we will return -1\\n  return -1;\\n};\\n```\\n\\n`Python`\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left=0\\n        right=len(nums)-1\\n        while(left<= right):\\n            mid=(left+right)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid] < target:\\n                 left=mid+1\\n            else:\\n                right=mid-1\\n        return -1\\n```\\n\\n`UPVOTE if you like \\uD83D\\uDE03 , If you have any question, feel free to ask.\\n`\\n",
                "solutionTags": [
                    "Python",
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nHello guys \\uD83D\\uDE00 !\\n\\nGiven question:\\nGiven an array of integers nums which is sorted in   ascending order` ,\\nan integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\\n\\nQuestion Explanation:\\n    basically, we need to check if the target is in the array. using binary search.\\n\\t\\n\\tBig O:\\n    n--> number of elements in the array\\n    Time Complexity: O(log(n)) - because we are using binary search\\n    Space Complexity: O(1)\\n```\n```\\nconst search = (nums, target) => {\\n  let left = 0;\\n  let right = nums.length - 1;\\n  console.log(right);\\n  while (left <= right) {\\n    let mid = Math.floor((left + right) / 2); // ! getting out mid val\\n    if (nums[mid] === target) { // ! if mid val is equal to target we will return the mid \\n      return mid;\\n    } else if (nums[mid] < target) { \\n\\n      left = mid + 1; /// ! if mid val is less than target we will move the left pointer to mid+1\\n    } else {\\n        right = mid - 1; // ! if mid val is greater than target we will move the right pointer mid-1\\n    }\\n  }\\n  //! if we cant find the target we will return -1\\n  return -1;\\n};\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left=0\\n        right=len(nums)-1\\n        while(left<= right):\\n            mid=(left+right)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid] < target:\\n                 left=mid+1\\n            else:\\n                right=mid-1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322419,
                "title": "5-variations-of-binary-search-a-self-note",
                "content": "Here are the 5 variations of Binary search for [search for an element in an sorted array](https://leetcode.com/problems/binary-search).\\n\\n>Discrete binary search on an sorted(ascending) array which may or may not have repeated elements.\\n\\n**Your upvote can make my day :) enjoy**\\n\\nLink to [original article (posted anonymously but it is my original article)](https://leetcode.com/discuss/interview-question/algorithms/1322500/5-variations-of-Binary-search-(A-Self-Note))\\n\\n**Few Insights first:**\\n* With every iteration we reduce the search space by half.\\n* At every step we compare mid element with the target, if mid element is not the target then we proceed to the half where target if present should be at and discard the another half.\\n* After all the iterations when `low == high`, if target is present in the array then it should be present at `low == high == mid` , if not then we can surely say that target is not present in the array.\\n* Note this, for the very **first time** when `low > high` in that case `ceil(target) = arr[low]` and `floor(target) = arr[high]`.\\n\\n**1. The usual solution**\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n - 1;\\n        \\n        while (low <= high) {\\n            int mid = (low + high) / 2; // this may cause integer overflow\\n\\t\\t\\tif (nums[mid] == target)\\n\\t\\t\\t\\treturn mid;\\n            else if (nums[mid] < target)\\n                low = mid + 1;\\n            else\\n                high = mid - 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\n**2. Round down**\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2; // round down (eliminates integer overflow)\\n\\t\\t\\tif (nums[mid] == target)\\n\\t\\t\\t\\treturn mid;\\n            else if (nums[mid] < target)\\n                low = mid + 1;\\n            else\\n                high = mid - 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\n**3. Round up**\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low + 1) / 2; // round up (eliminates integer overflow)\\n\\t\\t\\tif (nums[mid] == target)\\n\\t\\t\\t\\treturn mid;\\n            else if (nums[mid] < target)\\n                low = mid + 1;\\n            else\\n                high = mid - 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n\\n**NOTE:** Round up and Round down yields different result when size of search space is even, because `mid` in case of even number of elements is not clearly defined, so *round down* makes **left element as mid** and *round up* makes **right element as mid**.\\n\\n## **Gets Tricky now**\\n\\nIn below two variations we do not compare mid element with the target. The only comparision we make is when we get out of loop (exhausted our serach space completely).\\n\\n`Mid` may be the target so we keep mid element in our search space and search space will **eventually shrink down** to that original `mid` if it was equals target(ofcourse guaranteed only if duplicates are not present).\\n\\n**4. Round down no comparision**\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n - 1;\\n        \\n        while (low < high) { // notice we do not compare element at mid with our target\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] >= target)\\n                high = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        \\n\\t\\t /* at this point our search space has shrinked to \\n\\t\\tonly one element if current element is the target element\\n\\t\\tthen return its index else we can safely assume that element was not found*/\\n\\t\\t\\n        return nums[low] == target ? low : -1; // low == high\\n    }\\n}\\n```\\n\\n**5. Round up no comparision**\\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n - 1;\\n        \\n        while (low < high) { // notice we do not compare element at mid with our target\\n            int mid = low + (high - low + 1) / 2;\\n            if (nums[mid] <= target)\\n                low = mid;\\n            else\\n                high = mid - 1;\\n        }\\n\\t\\t\\n        /* at this point our search space has shrinked to \\n\\t\\tonly one element if current element is the target element\\n\\t\\tthen return its index else we can safely assume that element was not found*/\\n\\t\\t\\n\\t\\treturn nums[low] == target ? low : -1;  // low == high\\n    }\\n}\\n```\\n\\n## **Where is this kind of binary search used?**\\n\\nWell a very good application of these two variations is in finding pivot in an **[sorted rotated array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)**.\\n\\nCode for finding `pivot(minimum)` element in an **sorted rotated array**.\\n\\n```java\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n - 1;\\n        \\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] < nums[high])\\n                high = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        \\n        return nums[low];\\n    }\\n}\\n```\\n\\n**Note:** Duplicates are not present in the array. A slight modification in the code can handle duplicates as well.",
                "solutionTags": [
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n - 1;\\n        \\n        while (low <= high) {\\n            int mid = (low + high) / 2; // this may cause integer overflow\\n\\t\\t\\tif (nums[mid] == target)\\n\\t\\t\\t\\treturn mid;\\n            else if (nums[mid] < target)\\n                low = mid + 1;\\n            else\\n                high = mid - 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low) / 2; // round down (eliminates integer overflow)\\n\\t\\t\\tif (nums[mid] == target)\\n\\t\\t\\t\\treturn mid;\\n            else if (nums[mid] < target)\\n                low = mid + 1;\\n            else\\n                high = mid - 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n - 1;\\n        \\n        while (low <= high) {\\n            int mid = low + (high - low + 1) / 2; // round up (eliminates integer overflow)\\n\\t\\t\\tif (nums[mid] == target)\\n\\t\\t\\t\\treturn mid;\\n            else if (nums[mid] < target)\\n                low = mid + 1;\\n            else\\n                high = mid - 1;\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n - 1;\\n        \\n        while (low < high) { // notice we do not compare element at mid with our target\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] >= target)\\n                high = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        \\n\\t\\t /* at this point our search space has shrinked to \\n\\t\\tonly one element if current element is the target element\\n\\t\\tthen return its index else we can safely assume that element was not found*/\\n\\t\\t\\n        return nums[low] == target ? low : -1; // low == high\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n - 1;\\n        \\n        while (low < high) { // notice we do not compare element at mid with our target\\n            int mid = low + (high - low + 1) / 2;\\n            if (nums[mid] <= target)\\n                low = mid;\\n            else\\n                high = mid - 1;\\n        }\\n\\t\\t\\n        /* at this point our search space has shrinked to \\n\\t\\tonly one element if current element is the target element\\n\\t\\tthen return its index else we can safely assume that element was not found*/\\n\\t\\t\\n\\t\\treturn nums[low] == target ? low : -1;  // low == high\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public int findMin(int[] nums) {\\n        int n = nums.length;\\n        int low = 0;\\n        int high = n - 1;\\n        \\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] < nums[high])\\n                high = mid;\\n            else\\n                low = mid + 1;\\n        }\\n        \\n        return nums[low];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2700642,
                "title": "python-classic-binary-search-problem-99-faster-fastest-solution",
                "content": "**IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\nVisit this blog to learn Python tips and techniques and to find a Leetcode solution with an explanation: https://www.python-techs.com/\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums)-1\\n        \\n        while left<=right:\\n            mid = (left+right)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]>target:\\n                right = mid-1\\n            else:\\n                left = mid+1\\n        \\n        return -1\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums)-1\\n        \\n        while left<=right:\\n            mid = (left+right)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif nums[mid]>target:\\n                right = mid-1\\n            else:\\n                left = mid+1\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 151320,
                "title": "concise-java-solution-beats-100",
                "content": "```\\n    public int search(int[] nums, int target) {\\n        // corner case\\n        if (nums == null || nums.length == 0) return -1;\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[mid] > target) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int search(int[] nums, int target) {\\n        // corner case\\n        if (nums == null || nums.length == 0) return -1;\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[mid] > target) right = mid - 1;\\n            else left = mid + 1;\\n        }\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1883825,
                "title": "java-c-as-simple-as-you-think",
                "content": "How\\'s going Ladies - n - Gentlemen, today we are going to solve another coolest problem i.e. **Binary Search**\\n```\\nYou can skip some of the part\\'s if you already knew the basics of how Binary Search work!\\n```\\nOkay, so first of all let\\'s understand how you can identify it\\'s an Binary Search problem or not!!\\nAnd the answer is simple, if an **sorted Array is given** then just simply think of **Binary Search**\\n\\n>But what if you don\\'t know the Binary Search you will solve that problem recursively, you just **traverse the array** & check if it is `equals to your target`. If it is present then **return it\\'s index**, otherwise **return -1**\\n\\n`But it\\'s not a good Practice!!`\\nBecause let\\'s say you have given **10^6** elements from which you have to find your target. So if you solve it recursively you may have to tarverse 10^6 elements\\n**But using Binary search :**\\n```\\nlog2(10^6) --> 6 log2(10)\\n\\t\\t |---> 6 * 3.2222-----\\n\\t\\t |---> 19.----\\n```\\nSo as you seen using Binary search to get your element from 10^6 elements you just have to perform Approx. of 20 operations\\n\\n**Okay, Now inorder to implement Binary Search there are few Steps:-**\\n1. Find mid index :- **mid = (low + high) / 2**\\n\\n\\n2. If **nums[mid] == target**, return mid\\n3. If **target > nums[mid]**, Repeat `low = mid + 1`\\n4. If **target < nums[mid]**, Repeat `high = mid - 1`\\n\\nLet\\'s take on example inorder to understand this,\\n\\n**Input**: nums = [-4,-1,3,7,10,11], **target** = 7\\n**Output**: 4\\n\\nSo, first of all we calculate our mid :-\\nfor that we want our low & high & intially they\\'ll be\\n```\\n\\t\\t\\t\\t\\t[-4,-1,3,7,10,11]\\n\\t\\t\\t\\t\\t  l            h\\n```\\nSo our, low is intially at **0th** index & high is at last index i.e. **5** \\n\\nNow calculate mid :- `mid = (low + high) / 2` **=** `mid = 0 + 5 / 2` **=** `mid = 2`\\n```\\nIndex\\t\\t\\t\\t\" 0  1 2 3 4  5 \"\\n\\t\\t\\t\\t\\t[-4,-1,3,7,10,11]\\n\\t\\t\\t\\t\\t  l    ^       h\\n```\\n\\n* If we check is **target** equals to mid & the answer is no. \\n* Our target is **<** so the element which we want will never be present on left half from the mid, so we completely discard the left side.\\n* Now we again repeat it and calculate our mid, but first we will shift our low i.e. **low = mid + 1**\\n\\nSo our, low is at **3rd** index & high is at last index i.e. **5th** \\n\\nNow calculate mid :- `mid = (low + high) / 2` **=** `mid = 3 + 5 / 2` **=** `mid = 4`\\n```\\nIndex\\t\\t\\t\\t\" 0  1 2 3 4  5 \"\\n\\t\\t\\t\\t\\t[-4,-1,3,7,10,11]\\n\\t\\t\\t\\t\\t         l  ^  h\\n```\\n\\n* If we check is **target** equals to mid & the answer is no. \\n* Our target is **>** so the element which we want will never be present on right half from the mid, so we completely discard the right side.\\n* Now we again repeat it and calculate our mid, but first we will shift our high i.e. **high = mid - 1**\\n\\nSo our, low is at **3rd** index & high is at last index i.e. **3th** \\n\\nNow calculate mid :- `mid = (low + high) / 2` **=** `mid = 3 + 3 / 2` **=** `mid = 3`\\n```\\nIndex\\t\\t\\t\\t\" 0  1 2 3 4  5 \"\\n\\t\\t\\t\\t\\t[-4,-1,3,7,10,11]\\n\\t\\t\\t\\t\\t         ^ \\n\\t\\t\\t\\t\\t\\t\\t l\\n\\t\\t\\t\\t\\t\\t\\t h\\n```\\n* If we check is **target** equals to mid & the answer is Yes. We\\'ll **`return our mid`** \\n\\n*I hope ladies - n - gentlemen, everything is absolute clear.* **Let\\'s code it up**\\n\\n**Iterative :-** a.k.a Binary Search \\n**Java**\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        \\n        while(low <= high){\\n            int mid = (low + high) / 2;\\n            if(nums[mid] == target) return mid;\\n            \\n            else if(target > nums[mid]) low = mid + 1;\\n            else high = mid - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size() - 1;\\n        \\n        while(low <= high){\\n            int mid = (low + high) / 2;\\n            if(nums[mid] == target) return mid;\\n            \\n            else if(target > nums[mid]) low = mid + 1;\\n            else high = mid - 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(logN)\\n\\n* **Space Complexity :-** BigO(1)\\n\\n\\n**Recursive :-**\\n**Java**\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        return recursive(nums, low, high, target);\\n    }\\n    public int recursive(int[] nums, int low, int high, int target) {\\n        if(low > high) return -1;\\n        int mid = (low + high) / 2;\\n        \\n        if(nums[mid] == target) return mid;\\n        \\n        if(target > nums[mid]) return recursive(nums, mid + 1, high, target);\\n        else return recursive(nums, low, mid - 1, target);\\n    }\\n}\\n```\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size() - 1;\\n        return recursive(nums, low, high, target);\\n    }\\n    int recursive(vector<int>& nums, int low, int high, int target) {\\n        if(low > high) return -1;\\n        int mid = (low + high) / 2;\\n        \\n        if(nums[mid] == target) return mid;\\n        \\n        if(target > nums[mid]) return recursive(nums, mid + 1, high, target);\\n        else return recursive(nums, low, mid - 1, target);\\n    }\\n};\\n```\\nANALYSIS :-\\n* **Time Complexity :-** BigO(logN)\\n\\n* **Space Complexity :-** BigO(logN)",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nYou can skip some of the part\\'s if you already knew the basics of how Binary Search work!\\n```\n```\\nlog2(10^6) --> 6 log2(10)\\n\\t\\t |---> 6 * 3.2222-----\\n\\t\\t |---> 19.----\\n```\n```\\n\\t\\t\\t\\t\\t[-4,-1,3,7,10,11]\\n\\t\\t\\t\\t\\t  l            h\\n```\n```\\nIndex\\t\\t\\t\\t\" 0  1 2 3 4  5 \"\\n\\t\\t\\t\\t\\t[-4,-1,3,7,10,11]\\n\\t\\t\\t\\t\\t  l    ^       h\\n```\n```\\nIndex\\t\\t\\t\\t\" 0  1 2 3 4  5 \"\\n\\t\\t\\t\\t\\t[-4,-1,3,7,10,11]\\n\\t\\t\\t\\t\\t         l  ^  h\\n```\n```\\nIndex\\t\\t\\t\\t\" 0  1 2 3 4  5 \"\\n\\t\\t\\t\\t\\t[-4,-1,3,7,10,11]\\n\\t\\t\\t\\t\\t         ^ \\n\\t\\t\\t\\t\\t\\t\\t l\\n\\t\\t\\t\\t\\t\\t\\t h\\n```\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        \\n        while(low <= high){\\n            int mid = (low + high) / 2;\\n            if(nums[mid] == target) return mid;\\n            \\n            else if(target > nums[mid]) low = mid + 1;\\n            else high = mid - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size() - 1;\\n        \\n        while(low <= high){\\n            int mid = (low + high) / 2;\\n            if(nums[mid] == target) return mid;\\n            \\n            else if(target > nums[mid]) low = mid + 1;\\n            else high = mid - 1;\\n        }\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length - 1;\\n        return recursive(nums, low, high, target);\\n    }\\n    public int recursive(int[] nums, int low, int high, int target) {\\n        if(low > high) return -1;\\n        int mid = (low + high) / 2;\\n        \\n        if(nums[mid] == target) return mid;\\n        \\n        if(target > nums[mid]) return recursive(nums, mid + 1, high, target);\\n        else return recursive(nums, low, mid - 1, target);\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size() - 1;\\n        return recursive(nums, low, high, target);\\n    }\\n    int recursive(vector<int>& nums, int low, int high, int target) {\\n        if(low > high) return -1;\\n        int mid = (low + high) / 2;\\n        \\n        if(nums[mid] == target) return mid;\\n        \\n        if(target > nums[mid]) return recursive(nums, mid + 1, high, target);\\n        else return recursive(nums, low, mid - 1, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 148840,
                "title": "python-typical-solutions-beat-100",
                "content": "```\\nclass Solution:\\n    def search(self, nums, target):\\n        index = bisect.bisect_left(nums, target)\\n        return index if index < len(nums) and nums[index] == target else -1\\n```\\n```\\nclass Solution:\\n    def search(self, nums, target):\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] < target:\\n                l = mid + 1\\n            elif nums[mid] > target:\\n                r = mid - 1\\n            else:\\n                return mid\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def search(self, nums, target):\\n        index = bisect.bisect_left(nums, target)\\n        return index if index < len(nums) and nums[index] == target else -1\\n```\n```\\nclass Solution:\\n    def search(self, nums, target):\\n        l, r = 0, len(nums) - 1\\n        while l <= r:\\n            mid = (l + r) // 2\\n            if nums[mid] < target:\\n                l = mid + 1\\n            elif nums[mid] > target:\\n                r = mid - 1\\n            else:\\n                return mid\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363888,
                "title": "image-explanation-most-generalized-binary-search-c-java-python",
                "content": "# Video Solution (`Aryan Mittal`) - Link in LeetCode Profile\\n`Binary Search` by `Aryan Mittal`\\n![microsoft4.png](https://assets.leetcode.com/users/images/c8d29640-620e-4b7e-a50e-a6e734b05df2_1680315753.004149.png)\\n\\n\\n# Approach & Intution\\n![image.png](https://assets.leetcode.com/users/images/b10453cf-6a12-4ae0-8c1a-7d84184e627f_1680311196.4401176.png)\\n`MOST GENERALIZED BINARY SEARCH FORMAT`-`WILL WORK 99.9% TIMES`\\n![image.png](https://assets.leetcode.com/users/images/7bdd9fd1-499f-4d2a-adcf-e8fb680143b7_1680311212.1065965.png)\\n![image.png](https://assets.leetcode.com/users/images/fd463097-bd01-4c85-9e76-7c88bcce8994_1680311223.3428323.png)\\n![image.png](https://assets.leetcode.com/users/images/d1fbb04f-d69a-4b22-b900-cbb8b101d823_1680311241.2380607.png)\\n![image.png](https://assets.leetcode.com/users/images/cc1f8839-2a2d-4252-b210-edd0ee154b9c_1680311251.2596347.png)\\n![image.png](https://assets.leetcode.com/users/images/a4a0532b-b946-40c5-b690-65f4614de439_1680311266.7789154.png)\\n![image.png](https://assets.leetcode.com/users/images/50574523-fdff-4206-aa8a-b1bf9e72243b_1680311277.0665152.png)\\n![image.png](https://assets.leetcode.com/users/images/521a25a7-74e6-486a-835c-8eb8e4213a98_1680311287.141478.png)\\n![image.png](https://assets.leetcode.com/users/images/2991f9d5-3205-42e7-acaa-65bfb417890c_1680311619.9424775.png)\\n\\n\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l=0, r=nums.size()-1;\\n        while(l<r){\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] >= target)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n\\n        if(nums[l] != target) return -1;\\n        return l;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int l = 0, r = nums.length - 1;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] >= target)\\n                r = mid;\\n            else\\n                l = mid + 1;  \\n        }\\n\\n        if (nums[l] != target) return -1;\\n        return l;\\n    }\\n}\\n```\\n```Python []\\nfrom typing import List\\n\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l = 0\\n        r = len(nums) - 1\\n\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if nums[mid] >= target:\\n                r = mid\\n            else:\\n                l = mid + 1\\n\\n        if nums[l] != target:\\n            return -1\\n        return l\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l=0, r=nums.size()-1;\\n        while(l<r){\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] >= target)\\n                r = mid;\\n            else\\n                l = mid + 1;\\n        }\\n\\n        if(nums[l] != target) return -1;\\n        return l;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int l = 0, r = nums.length - 1;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] >= target)\\n                r = mid;\\n            else\\n                l = mid + 1;  \\n        }\\n\\n        if (nums[l] != target) return -1;\\n        return l;\\n    }\\n}\\n```\n```Python []\\nfrom typing import List\\n\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l = 0\\n        r = len(nums) - 1\\n\\n        while l < r:\\n            mid = l + (r - l) // 2\\n            if nums[mid] >= target:\\n                r = mid\\n            else:\\n                l = mid + 1\\n\\n        if nums[l] != target:\\n            return -1\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 884759,
                "title": "python-very-simple-solution-explained",
                "content": "We just need to do what is asked in the name of this problem: binary search! Also we need to find index of found element, so we check `3` conditions: `nums[mid] == target`, `nums[mid] < target` and `nums[mid] > target`.\\n\\n\\n**Complexity** is `O(log n)`, classical complexity of binary search, because on each step we reduce searching region twice.\\n\\n```\\nclass Solution:\\n    def search(self, nums, target):\\n        beg, end = 0, len(nums) - 1\\n        while beg <= end:\\n            mid = (beg + end)//2\\n            if nums[mid] == target: return mid\\n            if nums[mid] < target:\\n                beg = mid + 1\\n            else:\\n                end = mid - 1\\n        return -1\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums, target):\\n        beg, end = 0, len(nums) - 1\\n        while beg <= end:\\n            mid = (beg + end)//2\\n            if nums[mid] == target: return mid\\n            if nums[mid] < target:\\n                beg = mid + 1\\n            else:\\n                end = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 205763,
                "title": "share-three-common-templates-for-binary-search",
                "content": "For more detailed analysis of each them, please check\\nhttps://leetcode.com/articles/introduction-to-binary-search/\\nNOTE: My implementation is slightly different than the ones used in that article, and I personally prefer the third one in general.  \\n**Classic Binary Search:**\\n```\\nclass Solution {\\n    // template 1\\n    public int search(int[] nums, int target) {\\n         if (nums == null || nums.length == 0)  return -1;\\n         int start = 0, end = nums.length - 1;\\n         while (start <= end) {\\n             int mid = start + (end - start) / 2;\\n             if (nums[mid] == target)   return mid;\\n             else if (nums[mid] < target)   start = mid + 1;\\n             else   end = mid - 1;\\n         }\\n         return -1;\\n    }\\n    // template 2\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0)  return -1;\\n        int start = 0, end = nums.length - 1;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < target) start = mid + 1;\\n            else    end = mid;\\n        }\\n        if (nums[start] == target)   return start;\\n        return -1;\\n    }\\n    // template 3\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0)  return -1;\\n        int start = 0, end = nums.length - 1;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < target) start = mid;\\n            else    end = mid;\\n        }\\n        if (nums[start] == target)  return start;\\n        if (nums[end] == target)    return end;\\n        return -1;\\n    }\\n}\\n```\\n\\n**Find last position of target using template 3:**\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0)   return -1;\\n        int start = 0, end = nums.length - 1;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] == target)    start = mid;\\n            else if (nums[mid] < target)    start = mid + 1;\\n            else    end = mid - 1;\\n        }\\n        if (nums[end] == target)    return end;\\n        if (nums[start] == target)  return start;\\n        return -1;\\n    }\\n}\\n```\\n**Find first position of target using template 3:**\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0)   return -1;\\n        int start = 0, end = nums.length - 1;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] == target)    end = mid;\\n            else if (nums[mid] > target)    end = mid - 1;\\n            else    start = mid + 1;\\n        }\\n        if (nums[start] == target)  return start;\\n        if (nums[end] == target)    return end;\\n        return -1;\\n    }\\n}\\n```\\nHappy coding",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // template 1\\n    public int search(int[] nums, int target) {\\n         if (nums == null || nums.length == 0)  return -1;\\n         int start = 0, end = nums.length - 1;\\n         while (start <= end) {\\n             int mid = start + (end - start) / 2;\\n             if (nums[mid] == target)   return mid;\\n             else if (nums[mid] < target)   start = mid + 1;\\n             else   end = mid - 1;\\n         }\\n         return -1;\\n    }\\n    // template 2\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0)  return -1;\\n        int start = 0, end = nums.length - 1;\\n        while (start < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < target) start = mid + 1;\\n            else    end = mid;\\n        }\\n        if (nums[start] == target)   return start;\\n        return -1;\\n    }\\n    // template 3\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0)  return -1;\\n        int start = 0, end = nums.length - 1;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] < target) start = mid;\\n            else    end = mid;\\n        }\\n        if (nums[start] == target)  return start;\\n        if (nums[end] == target)    return end;\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0)   return -1;\\n        int start = 0, end = nums.length - 1;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] == target)    start = mid;\\n            else if (nums[mid] < target)    start = mid + 1;\\n            else    end = mid - 1;\\n        }\\n        if (nums[end] == target)    return end;\\n        if (nums[start] == target)  return start;\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        if (nums == null || nums.length == 0)   return -1;\\n        int start = 0, end = nums.length - 1;\\n        while (start + 1 < end) {\\n            int mid = start + (end - start) / 2;\\n            if (nums[mid] == target)    end = mid;\\n            else if (nums[mid] > target)    end = mid - 1;\\n            else    start = mid + 1;\\n        }\\n        if (nums[start] == target)  return start;\\n        if (nums[end] == target)    return end;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883790,
                "title": "c-explained-algorithm-iterative-recursive-simple-easy",
                "content": "# 704. Binary Search\\n**KNOCKCAT**\\n\\n```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Begin with an interval covering the whole array.\\n   narrow the interval to the lower half or upper half based on key to be searched.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\\n``` ```\\n[LeetCode](http://github.com/knockcat/Leetcode) **LINK TO LEETCODE REPOSITORY**\\n``` ```\\n\\nPlease upvote my comment so that i get to win the 2022 giveaway and motivate to make such discussion post.\\n**Happy new Year 2023 to all of you**\\n**keep solving keep improving**\\nLink To comment\\n[Leetcode Give away comment](https://leetcode.com/discuss/general-discussion/2946993/2022-Annual-Badge-and-the-Giveaway/1734919)\\n\\n\\n* **Binary Search** is a **searching algorithm used in a sorted array** by **repeatedly dividing the search interval in half.**\\n* The **idea of binary search is to use the information that the array is sorted** and **reduce the time complexity to O(Log n).**\\n\\n**ALGORITHM**\\n* **Begin with an interval of the whole vector** from **start to end, 0 to nums.size() - 1**.\\n* If the **value of the search key is less than the item in the middle of the interval,** **narrow the interval to the lower half.** end = mid - 1\\n* Otherwise, **narrow it to the upper half.** start = mid + 1\\n* Repeatedly **check until the value is found or the interval is empty.** else return -1\\n``` ```\\n\\n**ITERATIVE APPROACH**\\n```\\n\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start = 0,end = nums.size() - 1;\\n        \\n\\t\\t// iterate till start doesn\\'t exceed end\\n        while(start <= end)\\n        {\\n\\t\\t\\t// calculating mid\\n            int mid = start + (end - start)/2;\\n\\t\\t\\t\\n\\t\\t\\t// if value at mid is equals to target\\n            if(nums[mid] == target)\\n                return mid;\\n\\t\\t\\t\\t\\n\\t\\t\\t// value at mid is less than target\\n\\t\\t\\t// update the start by mid + 1\\n\\t\\t\\t// key should be in range mid + 1 to end\\n            else if(nums[mid] < target)\\n                start = mid+1;\\n\\t\\t\\t\\t\\n\\t\\t\\t// else update the end by mid - 1\\n\\t\\t\\t// value should be in range 0 to mid - 1\\n            else\\n                end = mid-1;\\n        }\\n        \\n\\t\\t// if target doesn;t found\\n        return -1;\\n        \\n    }\\n\\t// for github repository link go to my profile.\\n};\\n\\n```\\n**ALGORITHM**\\n* **Compare x** with the **middle element**.\\n* If **x matches with the middle element**, we **return the mid index.** return mid\\n* Else If x is **greater than the mid element,** then **x can only lie in the right half subarray after the mid element**. So we **recur call for the right half.**\\n* return binary(v, mid+1, r, key)\\n* **Else** (x is smaller) **recur call for the left half.** return binary(v, l, mid-1, key)\\n``` ```\\n\\n**RECURSIVE APPROACH**\\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int binary(vector<int>v,int l, int r, int key)\\n    {\\n\\t\\t// till l doesn\\'t exceed r\\n        if(r >= l)\\n        {\\n            int mid = (l+r)/2;\\n\\t\\t\\t\\n\\t\\t\\t// if key equals mid return mid\\n            if(key == v[mid])\\n                return mid;\\n\\t\\t\\t\\t\\n\\t\\t\\t// if key is less than mid\\n\\t\\t\\t// recursive call for left half\\n            else if(key < v[mid])\\n                return binary(v,l,mid-1,key);\\n\\t\\t\\t\\t\\n\\t\\t\\t// key is greater than mid\\n\\t\\t\\t// recursive call for right half\\n            else\\n                return binary(v,mid+1,r,key);\\n        }\\n\\t\\t\\n\\t\\t// if key not found\\n        return -1;\\n    }\\n    \\n    \\n    int search(vector<int>& nums, int target) {\\n        int result = binary(nums,0,nums.size()-1,target);\\n\\t\\t\\n\\t\\t// if func returns -1 key doesn\\'t exists\\n        if (result == -1)\\n            return -1;\\n\\t\\t\\n\\t\\t// return index of key\\n        else\\n            return result;   \\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n1. Easy C++\\n2. Line by Line Explanation with Comments.\\n3. Detailed Explanation \\u2705\\n4. Begin with an interval covering the whole array.\\n   narrow the interval to the lower half or upper half based on key to be searched.\\n5. Please Upvote if it helps\\u2B06\\uFE0F\\n6. Link to my Github Profile contains a repository of Leetcode with all my Solutions. \\u2B07\\uFE0F\\n\\t// \\uD83D\\uDE09If you Like the repository don\\'t foget to star & fork the repository\\uD83D\\uDE09\\n```\n``` ```\n``` ```\n``` ```\n```\\n\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start = 0,end = nums.size() - 1;\\n        \\n\\t\\t// iterate till start doesn\\'t exceed end\\n        while(start <= end)\\n        {\\n\\t\\t\\t// calculating mid\\n            int mid = start + (end - start)/2;\\n\\t\\t\\t\\n\\t\\t\\t// if value at mid is equals to target\\n            if(nums[mid] == target)\\n                return mid;\\n\\t\\t\\t\\t\\n\\t\\t\\t// value at mid is less than target\\n\\t\\t\\t// update the start by mid + 1\\n\\t\\t\\t// key should be in range mid + 1 to end\\n            else if(nums[mid] < target)\\n                start = mid+1;\\n\\t\\t\\t\\t\\n\\t\\t\\t// else update the end by mid - 1\\n\\t\\t\\t// value should be in range 0 to mid - 1\\n            else\\n                end = mid-1;\\n        }\\n        \\n\\t\\t// if target doesn;t found\\n        return -1;\\n        \\n    }\\n\\t// for github repository link go to my profile.\\n};\\n\\n```\n``` ```\n```\\n\\t\\t\\t\\t// \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09Please upvote if it helps \\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\uD83D\\uDE09\\nclass Solution {\\npublic:\\n    int binary(vector<int>v,int l, int r, int key)\\n    {\\n\\t\\t// till l doesn\\'t exceed r\\n        if(r >= l)\\n        {\\n            int mid = (l+r)/2;\\n\\t\\t\\t\\n\\t\\t\\t// if key equals mid return mid\\n            if(key == v[mid])\\n                return mid;\\n\\t\\t\\t\\t\\n\\t\\t\\t// if key is less than mid\\n\\t\\t\\t// recursive call for left half\\n            else if(key < v[mid])\\n                return binary(v,l,mid-1,key);\\n\\t\\t\\t\\t\\n\\t\\t\\t// key is greater than mid\\n\\t\\t\\t// recursive call for right half\\n            else\\n                return binary(v,mid+1,r,key);\\n        }\\n\\t\\t\\n\\t\\t// if key not found\\n        return -1;\\n    }\\n    \\n    \\n    int search(vector<int>& nums, int target) {\\n        int result = binary(nums,0,nums.size()-1,target);\\n\\t\\t\\n\\t\\t// if func returns -1 key doesn\\'t exists\\n        if (result == -1)\\n            return -1;\\n\\t\\t\\n\\t\\t// return index of key\\n        else\\n            return result;   \\n    }\\n\\t// for github repository link go to my profile.\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1482517,
                "title": "c-python",
                "content": "In this problem we\\'ve to find out the index of the *target* element in the array nums. If *target* is present in the array nums then we\\'ve to return it\\'s index, otherwise we\\'ve to return **-1.**\\n\\nWe\\'ll take the following three conditions under consideration:-\\n1. If `nums[mid] == target`, then we\\'ll just return `mid`.\\n2. If `nums[mid] < target`,  then we\\'ll have to set `low = mid + 1`.\\n3. If `nums[mid] > target`, then we\\'ll have to set `high = mid - 1`.\\n\\n<iframe src=\"https://leetcode.com/playground/oB7K3yA4/shared\" frameBorder=\"0\" width=\"500\" height=\"350\"></iframe>\\n\\n**Time Complexity:-**  `O(logn)`, n is the size of the given array.\\n**Space Complexity:-** `O(1)`\\n\\n\\n**Checkout my github repository:- https://github.com/hassanrahim26/LEETCODE**",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "In this problem we\\'ve to find out the index of the *target* element in the array nums. If *target* is present in the array nums then we\\'ve to return it\\'s index, otherwise we\\'ve to return **-1.**\\n\\nWe\\'ll take the following three conditions under consideration:-\\n1. If `nums[mid] == target`, then we\\'ll just return `mid`.\\n2. If `nums[mid] < target`,  then we\\'ll have to set `low = mid + 1`.\\n3. If `nums[mid] > target`, then we\\'ll have to set `high = mid - 1`.\\n\\n<iframe src=\"https://leetcode.com/playground/oB7K3yA4/shared\" frameBorder=\"0\" width=\"500\" height=\"350\"></iframe>\\n\\n**Time Complexity:-**  `O(logn)`, n is the size of the given array.\\n**Space Complexity:-** `O(1)`\\n\\n\\n**Checkout my github repository:- https://github.com/hassanrahim26/LEETCODE**",
                "codeTag": "Unknown"
            },
            {
                "id": 1641029,
                "title": "rust-solution",
                "content": "```\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\\n        use std::cmp::Ordering;\\n        let (mut low, mut high) = (0, nums.len());\\n        while low < high {\\n            let mid = low + (high - low) / 2;\\n            match nums[mid].cmp(&target) {\\n                Ordering::Equal => return mid as i32,\\n                Ordering::Less => low = mid + 1,\\n                Ordering::Greater => high = mid,\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Binary Tree"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\\n        use std::cmp::Ordering;\\n        let (mut low, mut high) = (0, nums.len());\\n        while low < high {\\n            let mid = low + (high - low) / 2;\\n            match nums[mid].cmp(&target) {\\n                Ordering::Equal => return mid as i32,\\n                Ordering::Less => low = mid + 1,\\n                Ordering::Greater => high = mid,\\n            }\\n        }\\n        -1\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1914265,
                "title": "binary-search-for-beginners-intuition-building",
                "content": "```\\n2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48\\n Try finding 38 in it\\n Let me tell you list is sorted.\\n How did you do it?\\n Where did you look first?\\n Somewhere at the back of list.\\n \\n Now find 4. Where did you start your search?\\n At the front of the list?\\n ```\\n \\n*When you wanted to find a smaller value you looked at the front and for bigger values you went at the back without looking at the front values.*\\n\\n`Think about why you did that`\\n\\n**You knew list starts from 2 and ends at 48 so 4 is much closer to 2 so you looked at the front. You looked in a space where you are more likely to find it. You discarded the space where you were sure you won\\'t find it.**\\n\\nBinary Search does something similar in more methodical way.\\n\\n```\\nYou pick a pivot point (middle element). Is the pivot element, the element you are trying to find?\\n* If yes return the element and job is done.\\n* If not, then decide in which direction you\\'d go? Whether you should go right or left of the pivot?\\n```\\n\\n`Let\\'s see`\\n\\n**We will search for 38 again. This time in the way binary search would do it.**\\n\\n**2 <sub>L</sub>** , 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, **24 <sub>M</sub>** , 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, **48 <sub>R</sub>**\\n\\nleft pointer pointing at first element of our search space\\nright pointer at last\\n\\n```\\nleft = 0  (0th index: element value =2)\\nright = 23 (last index: element = 48)\\nmiddle = (0+23)//2 =11 (ele : 24)\\n```\\n\\nwhere would` 38` be?\\n`right, right?`\\n\\n```\\nCode:\\nif nums[mid]<target:\\n\\tleft=mid+1\\n```\\n\\n~~2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24~~, **26 <sub>L</sub>** , 28, 30, 32, 34, **36 <sub>M</sub>** , 38, 40, 42, 44, 46, **48 <sub>R</sub>**\\n \\n```\\nleft=12 (ele: 26)\\nright=23 (ele: 48)\\nmid=(12+23)//2 =17 (ele: 36)\\n```\\n\\n36 is less than 38.\\nagain go in right\\n\\n~~2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36~~, **38 <sub>L</sub>** , 40, **42 <sub>M</sub>** , 44, 46, **48 <sub>R</sub>**\\n\\n```\\nleft=18 (ele: 38)\\nright=23 (ele:  48)\\nmid=(18+23)//2 =20 (ele: 42)\\n```\\n 42 is greater than 38. So search in left of it. You will find elements smaller than 42 there\\n \\n ```\\nCode:\\nif nums[mid]>target:\\n\\tright=mid-1\\n```\\n \\n~~2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36~~, **38<sub>L</sub> <sub>M</sub>**, **40<sub>R</sub>**, ~~42, 44, 46, 48~~\\n\\n```\\nleft=18 (ele: 38)\\nright=19 (ele: 40 )\\nmid=(18+19)//2 =18 (ele: 38)\\n```\\n\\nMid is equal to 38. Congratulations! you found it.\\n\\n ```\\nCode:\\nif nums[mid]==target:\\n\\treturn mid\\n```\\n\\n\\n\\n### When target is not present in the list\\n\\n```\\nNow say you are searching for a number which is not listed. When should you stop you search?\\n\\nLet\\'s say we want to find 39.\\nAt middle we have 38 which is less than 39. So we will go to right, where greater elements are. \\n```\\n~~2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38~~, **40 <sub>L</sub> <sub>M</sub> <sub>R</sub>** , ~~42, 44, 46, 48~~\\n```\\nleft=19 (ele: 40)\\nright=19 (ele: 40 )\\nmid=(19+19)//2 =19 (ele: 40)\\n```\\n\\nAs you can see we are now left with only one element in our search space and it isn\\'t the number we are looking for. \\n 40 is greater than 39. Looking for smaller elements? Go in left direction. But there is no element left. \\n \\n ~~2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, **38<sub>R</sub>**, **40 <sub>L</sub> ** , 42, 44, 46, 48~~\\n```\\nleft=19 (ele: 40)\\nright=18 (ele: 38 )\\n```\\n\\n*We should stop here. \\nObserve the relation between left and right pointer\\n`Left is greater than right point`*\\n\\n**Loop while left is smaller or equal to right**\\n\\n```\\ndef search(self, nums: List[int], target: int) -> int:\\n        l=0\\n        r=len(nums)-1\\n        while l<=r:\\n            mid=(l+r)//2           \\n            if nums[mid]==target:\\n                return mid\\n            if nums[mid]<target:\\n                l=mid+1\\n            elif nums[mid]>target:\\n                r=mid-1\\n        return -1\\n```\\n \\n",
                "solutionTags": [
                    "Python",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\n2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 44, 46, 48\\n Try finding 38 in it\\n Let me tell you list is sorted.\\n How did you do it?\\n Where did you look first?\\n Somewhere at the back of list.\\n \\n Now find 4. Where did you start your search?\\n At the front of the list?\\n ```\n```\\nYou pick a pivot point (middle element). Is the pivot element, the element you are trying to find?\\n* If yes return the element and job is done.\\n* If not, then decide in which direction you\\'d go? Whether you should go right or left of the pivot?\\n```\n```\\nleft = 0  (0th index: element value =2)\\nright = 23 (last index: element = 48)\\nmiddle = (0+23)//2 =11 (ele : 24)\\n```\n```\\nCode:\\nif nums[mid]<target:\\n\\tleft=mid+1\\n```\n```\\nleft=12 (ele: 26)\\nright=23 (ele: 48)\\nmid=(12+23)//2 =17 (ele: 36)\\n```\n```\\nleft=18 (ele: 38)\\nright=23 (ele:  48)\\nmid=(18+23)//2 =20 (ele: 42)\\n```\n```\\nCode:\\nif nums[mid]>target:\\n\\tright=mid-1\\n```\n```\\nleft=18 (ele: 38)\\nright=19 (ele: 40 )\\nmid=(18+19)//2 =18 (ele: 38)\\n```\n```\\nCode:\\nif nums[mid]==target:\\n\\treturn mid\\n```\n```\\nNow say you are searching for a number which is not listed. When should you stop you search?\\n\\nLet\\'s say we want to find 39.\\nAt middle we have 38 which is less than 39. So we will go to right, where greater elements are. \\n```\n```\\nleft=19 (ele: 40)\\nright=19 (ele: 40 )\\nmid=(19+19)//2 =19 (ele: 40)\\n```\n```\\nleft=19 (ele: 40)\\nright=18 (ele: 38 )\\n```\n```\\ndef search(self, nums: List[int], target: int) -> int:\\n        l=0\\n        r=len(nums)-1\\n        while l<=r:\\n            mid=(l+r)//2           \\n            if nums[mid]==target:\\n                return mid\\n            if nums[mid]<target:\\n                l=mid+1\\n            elif nums[mid]>target:\\n                r=mid-1\\n        return -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1884717,
                "title": "two-solutions-own-binary-search-vs-the-built-in-one",
                "content": "The Array class has the binary search built in. The only catch is that the built-in method can return any negative number when the element is not found (not just `-1`). So we need to guard against it:\\n```csharp\\npublic int Search(int[] nums, int target)\\n{\\n    int i = Array.BinarySearch(nums, target);\\n    return (i < 0) ? -1 : i; // or use Math.Clamp\\n}\\n```\\nWell, this is just too easy, right? For learning purposes, we want to implement a binary search ourselves:\\n```csharp\\npublic int Search(int[] nums, int target)\\n{\\n    int lo = 0;\\n    int hi = nums.Length - 1;\\n    \\n    while (lo <= hi)\\n    {\\n        int mid = lo + (hi - lo) / 2;\\n            \\n        if (nums[mid] == target)\\n            return mid;\\n            \\n        if (nums[mid] > target)\\n            hi = mid - 1;\\n        else\\n            lo = mid + 1;\\n    }\\n        \\n    return -1;\\n}\\n```\\n\\nPay attention to how you calculate the arithmetic mean. There are at least four ways to do that, one of which is wrong:\\n```csharp\\n(lo + hi) / 2;                   // WRONG because lo + hi might result in an int overflow\\nlo + (hi - lo) / 2;              // RIGHT, also best performance in .NET\\nlo & hi + (lo ^ hi) / 2;         // CONFUSING\\nlo / 2 + hi / 2 + lo & hi & 1;   // FANCY\\n```",
                "solutionTags": [
                    "C#",
                    "Binary Tree"
                ],
                "code": "```csharp\\npublic int Search(int[] nums, int target)\\n{\\n    int i = Array.BinarySearch(nums, target);\\n    return (i < 0) ? -1 : i; // or use Math.Clamp\\n}\\n```\n```csharp\\npublic int Search(int[] nums, int target)\\n{\\n    int lo = 0;\\n    int hi = nums.Length - 1;\\n    \\n    while (lo <= hi)\\n    {\\n        int mid = lo + (hi - lo) / 2;\\n            \\n        if (nums[mid] == target)\\n            return mid;\\n            \\n        if (nums[mid] > target)\\n            hi = mid - 1;\\n        else\\n            lo = mid + 1;\\n    }\\n        \\n    return -1;\\n}\\n```\n```csharp\\n(lo + hi) / 2;                   // WRONG because lo + hi might result in an int overflow\\nlo + (hi - lo) / 2;              // RIGHT, also best performance in .NET\\nlo & hi + (lo ^ hi) / 2;         // CONFUSING\\nlo / 2 + hi / 2 + lo & hi & 1;   // FANCY\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3364223,
                "title": "java-easy-solution-explained-why-left-right-left-2-instead-of-left-right-2",
                "content": "# Intuition\\nSince the array is sorted, we need to take advantage of this. So we use binary search, binary search will divide the array in left and right side thus reducing our search space, we keep doing this until we find the target or run out of indexes. The  index on which it is divied is called mid which is average of left and right pointers.\\n\\n---\\n\\n# Approach\\n1) Intialize left=0, and right = nums.length-1\\n2) Why mid = left + (right-left)/2 is done than simple mid = (left + right)/2 when both are mathematically same, because in first case we will never face ***integer overflow condition*** while in second if array size if big enought we mat exceed integer limit as we are adding 2 big integers\\n\\n3) If nums[mid] = target we return as we have found the target.\\n4) If nums[mid]<target , since target is greater than mid we will never find target in left side of mid so we discard our search space on left side of array by setting new left = mid+1.\\n5) If nums[mid]>target we discard right side of array to reduce array search so right=mid;\\n\\nwe keep repeating the steps, algorithm ends when condition left<right fails, that is left and right pointer cross each other or reach at one index\\n\\n6) At end we check left index, if nums[left]==target than left is the ans else -1. (left because binary search is left biased).\\n---\\n\\n\\nNOTE: \\n- I follow template left= mid+1 and right=mid, rather thatn left=mid+1 and right=mid-1, that is just my preference and there are lot of different ways to do this.\\n- Keep in mind that binary search is left biased as left+right/2 is integer division and it is closer to left side ex 0+5/2 = 2.5 but it returns mid = 2\\n\\n---\\n\\n\\n# Complexity\\n- Time complexity:\\nO(logn) : Since each time binary sort reduces the search by 2 times, the max iteration required will be logn(base 2)\\n\\n- Space complexity: \\nO(1) as no extra space\\n\\n\\n---\\n\\nHope it is easy to understand.\\nLet me know if there is something unclear and i can fix it.\\n\\nOtherwise, please upvote if you like the solution, it would be encouraging\\n\\n![LCUpvote.png](https://assets.leetcode.com/users/images/b7e6c164-29b1-4881-83fe-bb5dc7896d81_1680322188.2721322.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left=0;\\n        int right= nums.length-1;\\n\\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]<target){\\n                left=mid+1;\\n            }else{\\n                right=mid;\\n            }\\n        }\\n\\n        return target==nums[left] ? left : -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left=0;\\n        int right= nums.length-1;\\n\\n        while(left<right){\\n            int mid = left + (right-left)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n            else if(nums[mid]<target){\\n                left=mid+1;\\n            }else{\\n                right=mid;\\n            }\\n        }\\n\\n        return target==nums[left] ? left : -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3193723,
                "title": "simple-java-solution-runtime-0-ms-beats-100",
                "content": "# Approach\\nSimple Binary Search Program.\\n\\n# Complexity\\n- Time complexity:\\nO(log n)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int low=0,high=nums.length-1;\\n     \\n\\n        while(low<=high)\\n        {\\n          int mid =(low+high)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n\\n            if(nums[mid]<target)\\n                low=mid+1;\\n            else\\n                high=mid-1;\\n\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```\\n![8873f9b1-dfa4-4d9c-bb67-1b6db9d65e35_1674992431.3815322.jpeg](https://assets.leetcode.com/users/images/95be5a43-de07-4c11-ac70-0a4e96d4786a_1676559033.69966.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n\\n        int low=0,high=nums.length-1;\\n     \\n\\n        while(low<=high)\\n        {\\n          int mid =(low+high)/2;\\n            if(nums[mid]==target)\\n                return mid;\\n\\n            if(nums[mid]<target)\\n                low=mid+1;\\n            else\\n                high=mid-1;\\n\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1743624,
                "title": "python-simple-python-solution-using-binary-search-with-two-approach",
                "content": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using While Loop : -\\n# Runtime: 262 ms, faster than 66.52% of Python3 online submissions for Binary Search.\\n# Memory Usage: 15.5 MB, less than 24.23% of Python3 online submissions for Binary Search.\\n\\n\\tclass Solution:\\n\\t\\tdef search(self, nums: List[int], target: int) -> int:\\n\\n\\t\\t\\tstart = 0\\n\\t\\t\\tend = len(nums) - 1\\n\\n\\t\\t\\twhile start <= end:\\n\\n\\t\\t\\t\\tmid = (start + end) // 2\\n\\n\\t\\t\\t\\tif nums[mid] == target:\\n\\t\\t\\t\\t\\treturn mid\\n\\n\\t\\t\\t\\telif nums[mid] < target:\\n\\t\\t\\t\\t\\tstart = mid + 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tend = mid - 1\\n\\n\\t\\t\\treturn -1\\n# Apporach 2 Using Recursion : -\\n# Runtime: 414 ms, faster than 31.95% of Python3 online submissions for Binary Search.\\n# Memory Usage: 22.9 MB, less than 22.24% of Python3 online submissions for Binary Search.\\n\\tclass Solution:\\n\\t\\tdef search(self, nums: List[int], target: int) -> int:\\n\\n\\t\\t\\tdef BinarySearch(array, start, end, target):\\n\\n\\t\\t\\t\\tif start <= end:\\n\\n\\t\\t\\t\\t\\tmid = (start + end)//2\\n\\n\\t\\t\\t\\t\\tif array[mid] == target:\\n\\t\\t\\t\\t\\t\\treturn mid\\n\\n\\t\\t\\t\\t\\telif array[mid] < target:\\n\\t\\t\\t\\t\\t\\tstart = mid + 1\\n\\n\\t\\t\\t\\t\\tif array[mid] > target:\\n\\t\\t\\t\\t\\t\\tend = mid - 1\\n\\n\\t\\t\\t\\t\\treturn BinarySearch(nums, start, end, target)\\n\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\tstart = 0\\n\\t\\t\\tend = len(nums)-1\\n\\n\\t\\t\\tresult = BinarySearch(nums, start, end, target) \\n\\n\\t\\t\\treturn result",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "# If You like the Solution, Don\\'t Forget To UpVote Me, Please UpVote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# Approach 1 Using While Loop : -\\n# Runtime: 262 ms, faster than 66.52% of Python3 online submissions for Binary Search.\\n# Memory Usage: 15.5 MB, less than 24.23% of Python3 online submissions for Binary Search.\\n\\n\\tclass Solution:\\n\\t\\tdef search(self, nums: List[int], target: int) -> int:\\n\\n\\t\\t\\tstart = 0\\n\\t\\t\\tend = len(nums) - 1\\n\\n\\t\\t\\twhile start <= end:\\n\\n\\t\\t\\t\\tmid = (start + end) // 2\\n\\n\\t\\t\\t\\tif nums[mid] == target:\\n\\t\\t\\t\\t\\treturn mid\\n\\n\\t\\t\\t\\telif nums[mid] < target:\\n\\t\\t\\t\\t\\tstart = mid + 1\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tend = mid - 1\\n\\n\\t\\t\\treturn -1\\n# Apporach 2 Using Recursion : -\\n# Runtime: 414 ms, faster than 31.95% of Python3 online submissions for Binary Search.\\n# Memory Usage: 22.9 MB, less than 22.24% of Python3 online submissions for Binary Search.\\n\\tclass Solution:\\n\\t\\tdef search(self, nums: List[int], target: int) -> int:\\n\\n\\t\\t\\tdef BinarySearch(array, start, end, target):\\n\\n\\t\\t\\t\\tif start <= end:\\n\\n\\t\\t\\t\\t\\tmid = (start + end)//2\\n\\n\\t\\t\\t\\t\\tif array[mid] == target:\\n\\t\\t\\t\\t\\t\\treturn mid\\n\\n\\t\\t\\t\\t\\telif array[mid] < target:\\n\\t\\t\\t\\t\\t\\tstart = mid + 1\\n\\n\\t\\t\\t\\t\\tif array[mid] > target:\\n\\t\\t\\t\\t\\t\\tend = mid - 1\\n\\n\\t\\t\\t\\t\\treturn BinarySearch(nums, start, end, target)\\n\\n\\t\\t\\t\\treturn -1\\n\\n\\t\\t\\tstart = 0\\n\\t\\t\\tend = len(nums)-1\\n\\n\\t\\t\\tresult = BinarySearch(nums, start, end, target) \\n\\n\\t\\t\\treturn result",
                "codeTag": "Java"
            },
            {
                "id": 2766064,
                "title": "easy-java-binary-search-solution-with-explanation-faster-than-100-00",
                "content": "**I solved this problem using Binary Search Algorithm.**\\n\\n**Approach** : Instead of searching every element in an array like linear search. Binary search first finds the middle element of the array and checks three condition : \\nhassign 0. And a end variable and assign it array length -1;\\n\\n**Example :**\\n\\n**arr = {1,2,3,4,5,6,7}\\ntarget = 3;**\\n\\nThe three conditions :\\n\\n1. **Target>nums[mid] -** It checks whether the target element is greater than the middle element. If it is greater than the middle element. It means that the element is in the right side of the array. So it shifts the start pointer to mid +1. In the example this condition is false. So it moves to the next condition.\\n\\n2. \\t**Target<nums[mid] -**  It checks wether the target element is smallet than the middle element. If it is smaller than the middle element. Which it is in our case. The end pointer shifts to mid - 1;\\n\\n3. **Target==nums[mid] -** It checks if they are equal. If they are then simple return mid.\\n\\n*Extra condition for start and end :*\\n\\n4. **Target == nums[start] -**  It checks if they are equal. If they are then simple return start.\\n\\n5. **Target == nums[end] -**  It checks if they are equal. If they are then simple return end.\\n\\n**Below is the code implementation for the same :**\\n\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while(start<=end) {\\n            int mid = start + (end - start)/2;\\n            if(target<nums[mid]) {\\n                end = mid - 1;\\n            }\\n            else if (target>nums[mid]) {\\n                start = mid + 1;\\n            }\\n            else  if(nums[start] == target) {\\n                return start;\\n            }\\n            else if(nums[end] == target) {\\n                return end;\\n        }\\n            else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n**Please upvote if this helps!** \\u2764\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length - 1;\\n        while(start<=end) {\\n            int mid = start + (end - start)/2;\\n            if(target<nums[mid]) {\\n                end = mid - 1;\\n            }\\n            else if (target>nums[mid]) {\\n                start = mid + 1;\\n            }\\n            else  if(nums[start] == target) {\\n                return start;\\n            }\\n            else if(nums[end] == target) {\\n                return end;\\n        }\\n            else {\\n                return mid;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 157435,
                "title": "java-solution",
                "content": "  \\n\\tpublic int search(int[] nums, int target) \\n    {\\n        int lo = 0;\\n        int hi = nums.length - 1;\\n\\n        while(lo <= hi)\\n        {\\n        \\tint mid = (lo + hi) >>> 1;\\n\\n        \\tif(nums[mid] < target)\\n        \\t\\tlo = mid + 1;\\n        \\telse if(nums[mid] > target)\\n        \\t\\thi = mid - 1;\\n        \\telse\\n        \\t\\treturn mid;\\n        }\\n\\n        return -1;\\n    }\\n```",
                "solutionTags": [],
                "code": "  \\n\\tpublic int search(int[] nums, int target) \\n    {\\n        int lo = 0;\\n        int hi = nums.length - 1;\\n\\n        while(lo <= hi)\\n        {\\n        \\tint mid = (lo + hi) >>> 1;\\n\\n        \\tif(nums[mid] < target)\\n        \\t\\tlo = mid + 1;\\n        \\telse if(nums[mid] > target)\\n        \\t\\thi = mid - 1;\\n        \\telse\\n        \\t\\treturn mid;\\n        }\\n\\n        return -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1479404,
                "title": "clear-binary-search-algorithm-with-one-post-thought-process-explained",
                "content": "Hi Everyone, \\n\\nAs I am continuing my problem-solving journey, I often see how crucial ***Binary Search*** is. So, here, I would try to explain this algorithm in as simple words as possible. The code is simple, and I have added it for reference.\\n\\nHere, we are looking for the position of element in a given array. If it is not present, we will return -1. The given array is sorted. Imagine the array like [1,2,3,4,5] and required element as 5. We need to find its position.\\n\\n\\n**Thought Process** : \\n\\n* As compared to *Linear Search*, where our search space reduces only by 1 unit as we keep traversing from 0th index till the (n-1)th index to find the position of element, in *Binary Search*, ***we will aim to reduce our search space by a larger margin***.\\n\\n*  Now, we will fix two variables, one pointing to 0th index(***left***) and other pointing to the last index(***right***). This will be our first interval or the search space where we are looking for the element. We will take middle value of this, or (left + right)//2\\n\\n* **Case 1** : We will find the element at the middle index, and if it is equals to our target element, we will return it.\\n\\n*  **Case 2** : Else, we will use the fact that given array is a sorted array. So, if arr[middle] < given element, then our required element will definitely lie towards the right of middle index. So, our search space will now be from (middle + 1)th index till last index. To achieve this, we will do : left = middle + 1\\n\\n*  **Case 3** :  If arr[middle] > given element, the required element will definitely lie towards the left hand side of middle index. So, our search space now becomes from 0th index till (m-1)th index. To achieve this, we will do :\\n right = middle - 1\\n \\n ***Important Observations***\\n \\n1.  **After every iteration, our search space is getting reduced by half. This is much better in comparison to the Linear Search Algorithm.**\\n\\n2.  It would be incomplete to say that Binary Search Algorithm works only on sorted arrays. If there is some form of order that we can extract from a question, we can involve Binary Search on it. This is an advanced concept, and is useful across many problems.\\n\\n3. Instead of using mid = (left + right) // 2, we can use mid = left + (right - left) // 2 to avoid integer overflow issues.\\n\\n4. **Time Complexity - O(log(N))** and **Space Complexity - O(1)** is involved.\\n \\n \\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        left = 0 \\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            mid = left + (right - left)//2 \\n            \\n\\t\\t\\t#Case 1\\n            if nums[mid] == target:\\n                return mid\\n            \\n\\t\\t\\t#Case 2\\n            if nums[mid] < target:\\n                left = mid + 1\\n            \\n\\t\\t\\t#Case 3\\n            if nums[mid] > target:\\n                right = mid - 1 \\n\\t\\t\\t\\t\\n        #if the element is not present in the array\\n\\t\\t#the condition inside the while loop will fail and we will return -1\\n        return -1\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        left = 0 \\n        right = len(nums) - 1\\n        \\n        while left <= right:\\n            mid = left + (right - left)//2 \\n            \\n\\t\\t\\t#Case 1\\n            if nums[mid] == target:\\n                return mid\\n            \\n\\t\\t\\t#Case 2\\n            if nums[mid] < target:\\n                left = mid + 1\\n            \\n\\t\\t\\t#Case 3\\n            if nums[mid] > target:\\n                right = mid - 1 \\n\\t\\t\\t\\t\\n        #if the element is not present in the array\\n\\t\\t#the condition inside the while loop will fail and we will return -1\\n        return -1\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 719458,
                "title": "javascript-beats-90-runtime",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n    let start = 0,end = nums.length-1\\n    while(start <= end){\\n        let mid = Math.floor((start+end)/2)\\n        if(nums[mid] == target){\\n            return mid\\n        }else if(nums[mid] < target){\\n            start = mid+1\\n        }else{\\n            end = mid-1\\n        }\\n    }\\n    return -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n    let start = 0,end = nums.length-1\\n    while(start <= end){\\n        let mid = Math.floor((start+end)/2)\\n        if(nums[mid] == target){\\n            return mid\\n        }else if(nums[mid] < target){\\n            start = mid+1\\n        }else{\\n            end = mid-1\\n        }\\n    }\\n    return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3066998,
                "title": "o-logn-time-and-o-1-space-c-java-python-detailed-explanation-solution",
                "content": "![download.jfif](https://assets.leetcode.com/users/images/00428e3c-1b54-416c-87d9-fafef6ffc0cb_1673891907.850472.jpeg)\\n**If my solution is helpful to you then please upvote me.**\\n\\n# Approach\\n1. Initialize two variables, startIndex and lastIndex, to the first and last indices of the input array nums.\\n2. Use a while loop to repeatedly check if startIndex is less than or equal to lastIndex.\\n3. Within the while loop, calculate the midpoint index of the current subarray by adding startIndex and lastIndex and dividing by 2.\\n4. Check if the element at the midpoint index is equal to the target value. If it is, return the midpoint index as the result.\\n5. If the element at the midpoint index is greater than the target value, update lastIndex to be one less than the midpoint index.\\n6. If the element at the midpoint index is less than the target value, update startIndex to be one more than the midpoint index.\\n7. Once the while loop terminates (i.e. the target value is not found in the array), return -1 as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code\\n```C++ []\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int startIndex = 0; \\n        int lastIndex = nums.size() - 1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex)/2);\\n            if(nums[midIndex] == target){\\n                return midIndex;\\n            }\\n            else if(nums[midIndex] > target){\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return -1;   \\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int startIndex = 0; \\n        int lastIndex = nums.length - 1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound \\n            int midIndex = (startIndex + (lastIndex - startIndex)/2);\\n            if(nums[midIndex] == target){\\n                return midIndex;\\n            }\\n            else if(nums[midIndex] > target){\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return -1;   \\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        startIndex = 0\\n        lastIndex = len(nums) - 1\\n        while(startIndex <= lastIndex):\\n            midIndex = (startIndex + (lastIndex - startIndex)//2)\\n            if(nums[midIndex] == target):\\n                return midIndex\\n            elif(nums[midIndex] > target):\\n                lastIndex = midIndex - 1\\n            else:\\n                startIndex = midIndex + 1\\n        return -1   \\n\\n```\\n# Complexity\\n- Time complexity: **O(logN)** // where N is the size of array\\n\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)** // we are not using any extra space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int startIndex = 0; \\n        int lastIndex = nums.size() - 1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex)/2);\\n            if(nums[midIndex] == target){\\n                return midIndex;\\n            }\\n            else if(nums[midIndex] > target){\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return -1;   \\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int startIndex = 0; \\n        int lastIndex = nums.length - 1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound \\n            int midIndex = (startIndex + (lastIndex - startIndex)/2);\\n            if(nums[midIndex] == target){\\n                return midIndex;\\n            }\\n            else if(nums[midIndex] > target){\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return -1;   \\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        startIndex = 0\\n        lastIndex = len(nums) - 1\\n        while(startIndex <= lastIndex):\\n            midIndex = (startIndex + (lastIndex - startIndex)//2)\\n            if(nums[midIndex] == target):\\n                return midIndex\\n            elif(nums[midIndex] > target):\\n                lastIndex = midIndex - 1\\n            else:\\n                startIndex = midIndex + 1\\n        return -1   \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3181847,
                "title": "clean-simple-python-solution",
                "content": "\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        def binary_search(l, r):\\n            while l <= r:\\n                mid = (l + r) >> 1\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    l = mid + 1\\n                elif nums[mid] > target:\\n                    r = mid - 1\\n            return - 1\\n\\n        return binary_search(0, len(nums) - 1)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        def binary_search(l, r):\\n            while l <= r:\\n                mid = (l + r) >> 1\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    l = mid + 1\\n                elif nums[mid] > target:\\n                    r = mid - 1\\n            return - 1\\n\\n        return binary_search(0, len(nums) - 1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791231,
                "title": "c-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> > generate(int numRows) {\\n        vector<vector<int>> r(numRows);\\n\\n        for (int i = 0; i < numRows; i++) {\\n            r[i].resize(i + 1);\\n            r[i][0] = r[i][i] = 1;\\n  \\n            for (int j = 1; j < i; j++)\\n                r[i][j] = r[i - 1][j - 1] + r[i - 1][j];\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int> > generate(int numRows) {\\n        vector<vector<int>> r(numRows);\\n\\n        for (int i = 0; i < numRows; i++) {\\n            r[i].resize(i + 1);\\n            r[i][0] = r[i][i] = 1;\\n  \\n            for (int j = 1; j < i; j++)\\n                r[i][j] = r[i - 1][j - 1] + r[i - 1][j];\\n        }\\n        \\n        return r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1557479,
                "title": "java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n       \\n        int n = nums.length;\\n        int low = 0;\\n        int high = n-1;\\n        while(low<=high) {\\n            int mid = low + high >> 1;\\n            if(nums[mid] == target) return mid;\\n            if(nums[mid] < target) low = mid + 1;\\n            else high = mid - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n       \\n        int n = nums.length;\\n        int low = 0;\\n        int high = n-1;\\n        while(low<=high) {\\n            int mid = low + high >> 1;\\n            if(nums[mid] == target) return mid;\\n            if(nums[mid] < target) low = mid + 1;\\n            else high = mid - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802495,
                "title": "python-simple-solution-to-find-the-target-element-in-o-log-n-using-binary-search",
                "content": "# Intuition\\nFind the next-smallest or next-largest element in the array relative to the target\\nby mid index and remove the half elements (i.e left or right part of the array).\\n\\n# Approach\\n1. Begin with the mid element of the whole array as a search key.\\n2. If the value of the search key is equal to the item then return an index of the search key.\\n3. Or if the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half.\\n4. Otherwise, narrow it to the upper half.\\nRepeatedly check from the second point until the value is found or the interval is empty.\\n\\n# Complexity\\n- Time complexity: $$O(log n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l = 0\\n        r = len(nums)-1\\n\\n        while l<=r:\\n            mid = (l + r) // 2\\n            if nums[mid] == target:\\n                return mid\\n            if nums[mid] < target:\\n                l = mid + 1\\n            else:\\n                r = mid -1\\n        \\n        return -1\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l = 0\\n        r = len(nums)-1\\n\\n        while l<=r:\\n            mid = (l + r) // 2\\n            if nums[mid] == target:\\n                return mid\\n            if nums[mid] < target:\\n                l = mid + 1\\n            else:\\n                r = mid -1\\n        \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 850762,
                "title": "go-solution-with-and-without-standard-library",
                "content": "Go has **sort.SearchInts()** that returns the index where target number should be inserted into a sorted array. This means we have to check if the return index is length of array or if idx matches target.\\n\\nhttps://github.com/phea/leetcode-go\\n```go\\nfunc searchB(nums []int, target int) int {\\n\\tidx := sort.SearchInts(nums, target)\\n\\tif idx >= len(nums) || nums[idx] != target {\\n\\t\\treturn -1\\n\\t}\\n\\treturn idx\\n}\\n```\\n\\nHere\\'s the classic binary search algorithm:\\n\\n```go\\n\\nfunc search(nums []int, target int) int {\\n\\tlow, high := 0, len(nums)-1\\n\\tvar mid int\\n\\tfor low <= high {\\n\\t\\tmid = (low + high) / 2\\n\\t\\tif nums[mid] < target {\\n\\t\\t\\tlow = mid + 1\\n\\t\\t} else if nums[mid] > target {\\n\\t\\t\\thigh = mid - 1\\n\\t\\t} else {\\n\\t\\t\\treturn mid\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc searchB(nums []int, target int) int {\\n\\tidx := sort.SearchInts(nums, target)\\n\\tif idx >= len(nums) || nums[idx] != target {\\n\\t\\treturn -1\\n\\t}\\n\\treturn idx\\n}\\n```\n```go\\n\\nfunc search(nums []int, target int) int {\\n\\tlow, high := 0, len(nums)-1\\n\\tvar mid int\\n\\tfor low <= high {\\n\\t\\tmid = (low + high) / 2\\n\\t\\tif nums[mid] < target {\\n\\t\\t\\tlow = mid + 1\\n\\t\\t} else if nums[mid] > target {\\n\\t\\t\\thigh = mid - 1\\n\\t\\t} else {\\n\\t\\t\\treturn mid\\n\\t\\t}\\n\\t}\\n\\n\\treturn -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3365646,
                "title": "c-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& n, int t) {\\n        int ind = lower_bound(n.begin(),n.end() , t) - n.begin();\\n        if(ind < n.size() && n[ind]==t ) return ind;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& n, int t) {\\n        int ind = lower_bound(n.begin(),n.end() , t) - n.begin();\\n        if(ind < n.size() && n[ind]==t ) return ind;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364351,
                "title": "3-line-code-c-using-stl",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& n, int t) {\\n        int ind = lower_bound(n.begin(),n.end() , t) - n.begin();\\n        if(ind < n.size() && n[ind]==t ) return ind;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& n, int t) {\\n        int ind = lower_bound(n.begin(),n.end() , t) - n.begin();\\n        if(ind < n.size() && n[ind]==t ) return ind;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591523,
                "title": "java-best-solution",
                "content": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        return binarySearch(nums, 0, nums.length-1, target);\\n    }\\n    \\n    public int binarySearch(int[] nums, int l, int r, int target){\\n        if(l <= r){\\n            int mid = l + (r - l)/2;\\n            if(nums[mid] == target){\\n                return mid;\\n            }if(nums[mid] < target){\\n                return binarySearch(nums, mid+1, r, target);\\n            }\\n            return binarySearch(nums, l, mid-1, target);\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        return binarySearch(nums, 0, nums.length-1, target);\\n    }\\n    \\n    public int binarySearch(int[] nums, int l, int r, int target){\\n        if(l <= r){\\n            int mid = l + (r - l)/2;\\n            if(nums[mid] == target){\\n                return mid;\\n            }if(nums[mid] < target){\\n                return binarySearch(nums, mid+1, r, target);\\n            }\\n            return binarySearch(nums, l, mid-1, target);\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1998248,
                "title": "100-fastest-solution-explained",
                "content": "Easy to understand and detailed step by step explanation with code:\\n\\nhttps://www.code-recipe.com/post/binary-search\\n\\nLet me know in comments section if you have any doubts. I will be happy to answer.\\n\\n**Kindly upvote if this helps you. Thank You**",
                "solutionTags": [
                    "Go"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 554926,
                "title": "python-97-binary-search-2-lines",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        i = bisect_left(nums, target) \\n        return i if i != len(nums) and nums[i] == target else -1   \\n```\\n\\nIf you were curious how to to do binary search in Python, maybe it\\'s a good opportunity to learn `bisect_left()` ... it returns  leftmost insertion point of `target` in a sorted list `nums`, so it\\'s perfect for our case.\\n\\nBut, frankly, for the test cases attached to this problem, the built in `index()` method seems to beat everything.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        i = bisect_left(nums, target) \\n        return i if i != len(nums) and nums[i] == target else -1   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 256469,
                "title": "3-line-100-fast-100-less-mempry-stl-and-fast-i-o",
                "content": "```\\nint search(vector<int>& nums, int target) {\\n        vector<int> :: iterator it2=nums.begin();        \\n        vector<int> :: iterator it=std :: lower_bound(nums.begin(),nums.end(),target);        \\n        if(it==nums.end() || *it!=target) return -1;        \\n            else return (it-it2) ;        \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint search(vector<int>& nums, int target) {\\n        vector<int> :: iterator it2=nums.begin();        \\n        vector<int> :: iterator it=std :: lower_bound(nums.begin(),nums.end(),target);        \\n        if(it==nums.end() || *it!=target) return -1;        \\n            else return (it-it2) ;        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 209245,
                "title": "python-solution",
                "content": "```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        #corner case: nums is empty\\n        if not nums or len(nums) == 0:\\n            return -1\\n        left, right = 0, len(nums) - 1\\n        #corner case: target value is out of the list\\'s value range\\n        if target < nums[left] or target > nums[right]:\\n            return -1\\n        #lock the target in left, right and mid three numbers.\\n        while left + 1 < right:     \\n            mid = left + (right - left) / 2\\n            if nums[mid] > target:\\n                right = mid\\n            elif nums[mid] < target:\\n                left = mid\\n            else:\\n                return mid    \\n        #if the target is not the mid, check the right and left\\n        if nums[right] == target:\\n            return right\\n        if nums[left] == target:\\n            return left\\n        return -1\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        #corner case: nums is empty\\n        if not nums or len(nums) == 0:\\n            return -1\\n        left, right = 0, len(nums) - 1\\n        #corner case: target value is out of the list\\'s value range\\n        if target < nums[left] or target > nums[right]:\\n            return -1\\n        #lock the target in left, right and mid three numbers.\\n        while left + 1 < right:     \\n            mid = left + (right - left) / 2\\n            if nums[mid] > target:\\n                right = mid\\n            elif nums[mid] < target:\\n                left = mid\\n            else:\\n                return mid    \\n        #if the target is not the mid, check the right and left\\n        if nums[right] == target:\\n            return right\\n        if nums[left] == target:\\n            return left\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 208932,
                "title": "js-top-100-log-n-bs",
                "content": "```\\nconst search = (nums, target) => {\\n    let left = 0, right = nums.length - 1;\\n    \\n    while (left <= right) {\\n        let mid = (left + right) / 2 | 0;\\n        \\n        if (nums[mid] === target) { return mid; }\\n        if (nums[mid] > target) { right = mid - 1; }\\n        else { left = mid + 1; }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nconst search = (nums, target) => {\\n    let left = 0, right = nums.length - 1;\\n    \\n    while (left <= right) {\\n        let mid = (left + right) / 2 | 0;\\n        \\n        if (nums[mid] === target) { return mid; }\\n        if (nums[mid] > target) { right = mid - 1; }\\n        else { left = mid + 1; }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082292,
                "title": "simple-java-solutions-runtime-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0 , high = nums.length -1 ;\\n        while (low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target){\\n                return mid;\\n            }else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }else {\\n                high = mid - 1 ;\\n            }\\n\\n        }\\n\\n        return -1;\\n    }\\n}\\n```\\n\\n![abcd1.jpeg](https://assets.leetcode.com/users/images/55e92eca-d0f1-40b4-9090-6badf07bbdd1_1695504687.4252684.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0 , high = nums.length -1 ;\\n        while (low <= high)\\n        {\\n            int mid = low + (high - low) / 2;\\n            if (nums[mid] == target){\\n                return mid;\\n            }else if (nums[mid] < target) {\\n                low = mid + 1;\\n            }else {\\n                high = mid - 1 ;\\n            }\\n\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363882,
                "title": "java-easy-solution-100-faster-code-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nPLEASE UPVOTE IF YOU LIKE.\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int st = 0,end = nums.length-1,mid;\\n        while(st<=end) {\\n            mid = (end-st)/2 + st;\\n            if(target < nums[mid])\\n                end = mid-1;\\n            else if(target>nums[mid])\\n                st = mid+1;\\n            else\\n                return mid;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int st = 0,end = nums.length-1,mid;\\n        while(st<=end) {\\n            mid = (end-st)/2 + st;\\n            if(target < nums[mid])\\n                end = mid-1;\\n            else if(target>nums[mid])\\n                st = mid+1;\\n            else\\n                return mid;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3162730,
                "title": "easiest-c-code-for-binary-search-using-single-while-loop-super-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& arr, int x) {\\n        int n=arr.size();\\n        int l=0;\\n        int r=n-1;\\n             while (l <= r) {\\n        int m = l + (r - l) / 2;\\n \\n        // Check if x is present at mid\\n        if (arr[m] == x)\\n            return m;\\n \\n        // If x greater, ignore left half\\n        if (arr[m] < x)\\n            l = m + 1;\\n \\n        // If x is smaller, ignore right half\\n        else\\n            r = m - 1;\\n    }\\n \\n    // if we reach here, then element was\\n    // not present\\n    return -1;\\n    \\n\\n        \\n        \\n    }\\n};\\nDo upvote if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& arr, int x) {\\n        int n=arr.size();\\n        int l=0;\\n        int r=n-1;\\n             while (l <= r) {\\n        int m = l + (r - l) / 2;\\n \\n        // Check if x is present at mid\\n        if (arr[m] == x)\\n            return m;\\n \\n        // If x greater, ignore left half\\n        if (arr[m] < x)\\n            l = m + 1;\\n \\n        // If x is smaller, ignore right half\\n        else\\n            r = m - 1;\\n    }\\n \\n    // if we reach here, then element was\\n    // not present\\n    return -1;\\n    \\n\\n        \\n        \\n    }\\n};\\nDo upvote if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2592091,
                "title": "simple-python3-solution-o-logn",
                "content": "**UPVOTE** if it is helpful\\n``` \\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        hi = len(nums)-1\\n        lo = 0\\n        while lo<=hi:\\n            mid = (lo+hi)//2\\n            if nums[mid]==target: return mid\\n            if target>nums[mid]: lo = mid+1\\n            else: hi = mid-1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "``` \\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        hi = len(nums)-1\\n        lo = 0\\n        while lo<=hi:\\n            mid = (lo+hi)//2\\n            if nums[mid]==target: return mid\\n            if target>nums[mid]: lo = mid+1\\n            else: hi = mid-1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571755,
                "title": "memory-usage-less-than-68-user-upvote-if-you-like",
                "content": "`class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        \\n        int size=nums.size();\\n        int begin=0;\\n        int mid=0;\\n        int end=size-1;\\n        while(begin<=end)\\n        {\\n         mid = begin+(end-begin)/2;\\n            if(nums[mid]==target)\\n            {\\n                return mid;\\n                \\n            }\\n            if(nums[mid]<target)\\n            {\\n                begin =mid+1;\\n            }\\n            if(nums[mid]>target)\\n            {\\n                end=mid-1;\\n            }\\n        }\\n        return -1;\\n        \\n    }\\n};`",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        \\n        int size=nums.size();\\n        int begin=0;\\n        int mid=0;\\n        int end=size-1;\\n        while(begin<=end)\\n        {\\n         mid = begin+(end-begin)/2;\\n            if(nums[mid]==target)\\n            {\\n                return mid;\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2529910,
                "title": "c-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0;\\n        int h = nums.size()-1;\\n        while(l <= h){\\n            int mid  = (l+h)/2;\\n            if(nums[mid] == target)\\n            {\\n                return mid;\\n            }\\n            else if(nums[mid] > target){\\n                h = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Don\\'t forget to Upvote the post, if it\\'s been any help to you**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0;\\n        int h = nums.size()-1;\\n        while(l <= h){\\n            int mid  = (l+h)/2;\\n            if(nums[mid] == target)\\n            {\\n                return mid;\\n            }\\n            else if(nums[mid] > target){\\n                h = mid-1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676494,
                "title": "python-iterative-binary-search",
                "content": "**Python :**\\n\\n```\\ndef search(self, nums: List[int], target: int) -> int:\\n\\tlow = 0\\n\\thigh = len(nums) - 1\\n\\n\\twhile low <= high:\\n\\t\\tmid = (low + high) // 2\\n\\t\\tif nums[mid] == target:\\n\\t\\t\\treturn mid\\n\\n\\t\\telif nums[mid] < target:\\n\\t\\t\\tlow = mid + 1\\n\\n\\t\\telse:\\n\\t\\t\\thigh = mid - 1\\n\\n\\treturn -1\\n```\\n\\n**Like it ? please upvote !**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\ndef search(self, nums: List[int], target: int) -> int:\\n\\tlow = 0\\n\\thigh = len(nums) - 1\\n\\n\\twhile low <= high:\\n\\t\\tmid = (low + high) // 2\\n\\t\\tif nums[mid] == target:\\n\\t\\t\\treturn mid\\n\\n\\t\\telif nums[mid] < target:\\n\\t\\t\\tlow = mid + 1\\n\\n\\t\\telse:\\n\\t\\t\\thigh = mid - 1\\n\\n\\treturn -1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3365818,
                "title": "c-easy-binary-search",
                "content": "# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n       int s=0,e=nums.size()-1;\\n       while(s<=e){\\n           int m=(s+e)/2;\\n           if(nums[m]==target)return m;\\n           else if(nums[m]>target)e=m-1;\\n           else s=m+1;\\n       }\\n       return -1; \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n       int s=0,e=nums.size()-1;\\n       while(s<=e){\\n           int m=(s+e)/2;\\n           if(nums[m]==target)return m;\\n           else if(nums[m]>target)e=m-1;\\n           else s=m+1;\\n       }\\n       return -1; \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3363784,
                "title": "daily-leetcoding-challenge-april-day-1",
                "content": "This problem is the Daily LeetCoding Challenge for April, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3098117,
                "title": "best-o-logn-solution",
                "content": "# Approach 1\\nLinear Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        for (int i = 0; i < nums.size(); i++) \\n            if (nums[i] == target) \\n                return i;\\n        return -1;\\n    }\\n};\\n```\\n\\n# Approach 2\\nBinary Search\\n\\n# Complexity\\n- Time complexity:\\n$$O(logn)$$ \\n\\n- Space complexity:\\n$$O(1)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        int mid;\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (nums[mid] == target)\\n                return mid;\\n            else if (nums[mid] > target)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;        \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        for (int i = 0; i < nums.size(); i++) \\n            if (nums[i] == target) \\n                return i;\\n        return -1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        int mid;\\n        while (low <= high) {\\n            mid = (low + high) / 2;\\n            if (nums[mid] == target)\\n                return mid;\\n            else if (nums[mid] > target)\\n                high = mid - 1;\\n            else\\n                low = mid + 1;        \\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1883755,
                "title": "python3-loool-too-ez-explained",
                "content": "**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**\\n\\nRecipe:\\n\\n1. **init** lowest possible value as `lo` and highest possible as `hi`\\n2. **while** cycle until `lo <= hi`\\n3. find **middle** `mi = (lo + hi) // 2`\\n4. **return** result if the target is found\\n5. **adjust** `lo` and `hi` depending on where the target is located relatively to middle `mi`\\n\\nTime: **O(logn)**\\nSpace: **O(1)**\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        lo, hi = 0, len(nums) - 1\\n        while lo <= hi:\\n            mi = (lo + hi) // 2\\n            if nums[mi] == target:\\n                return mi\\n            \\n            if nums[mi] < target:\\n                lo = mi + 1\\n            else:\\n                hi = mi - 1\\n                \\n        return -1\\n```\\n\\n**UPVOTE if you like (\\uD83C\\uDF38\\u25E0\\u203F\\u25E0), If you have any question, feel free to ask.**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        lo, hi = 0, len(nums) - 1\\n        while lo <= hi:\\n            mi = (lo + hi) // 2\\n            if nums[mi] == target:\\n                return mi\\n            \\n            if nums[mi] < target:\\n                lo = mi + 1\\n            else:\\n                hi = mi - 1\\n                \\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1584624,
                "title": "javascript-solution",
                "content": "Somehow, it says that this is faster than 99.44% of JavaScript submissions. Don\\'t know why though, this is a straightforward application of the algorithm without any optimizations.\\n\\n```javascript\\nvar search = function(nums, target) {\\n    var lo = 0,\\n        hi = nums.length - 1,\\n        mid;\\n\\n    while (lo <= hi) {\\n        mid = Math.floor((lo + hi) / 2);\\n        if (nums[mid] == target)\\n            return mid;\\n        if (nums[mid] < target)\\n            lo = mid + 1;\\n        else\\n            hi = mid - 1;\\n    }\\n\\n    return -1;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar search = function(nums, target) {\\n    var lo = 0,\\n        hi = nums.length - 1,\\n        mid;\\n\\n    while (lo <= hi) {\\n        mid = Math.floor((lo + hi) / 2);\\n        if (nums[mid] == target)\\n            return mid;\\n        if (nums[mid] < target)\\n            lo = mid + 1;\\n        else\\n            hi = mid - 1;\\n    }\\n\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1273788,
                "title": "c-soln-with-simple-logic-of-binary-search",
                "content": "Since the array is always sorted we know that our target will either be in the upper or lower or middle of array so we target that part and change it accordingly :\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int t) \\n    {\\n       int low = 0 , high = nums.size() - 1;\\n        while(low<=high)\\n        {\\n            int mid = (low + high)/2;\\n            \\n            if(nums[mid] == t)\\n            {\\n                return mid;\\n            }\\n            else if (nums[mid] < t)\\n            {\\n                low = mid +1;\\n            }\\n            else\\n            {\\n                high = mid -1 ;\\n            }\\n        }\\n        return -1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int t) \\n    {\\n       int low = 0 , high = nums.size() - 1;\\n        while(low<=high)\\n        {\\n            int mid = (low + high)/2;\\n            \\n            if(nums[mid] == t)\\n            {\\n                return mid;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 884652,
                "title": "c-c-eeeasssy-solution",
                "content": "```\\nint search(int* nums, int numsSize, int target)\\n{\\n    int left = 0, right = numsSize - 1;\\n    \\n    while (left <= right)\\n    {\\n        int middle = left + (right - left) / 2;\\n        \\n        if (nums[middle] == target)\\n            return middle;\\n        \\n        else if (nums[middle] < target)\\n            left = middle + 1;\\n        \\n        else\\n            right = middle - 1;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint search(int* nums, int numsSize, int target)\\n{\\n    int left = 0, right = numsSize - 1;\\n    \\n    while (left <= right)\\n    {\\n        int middle = left + (right - left) / 2;\\n        \\n        if (nums[middle] == target)\\n            return middle;\\n        \\n        else if (nums[middle] < target)\\n            left = middle + 1;\\n        \\n        else\\n            right = middle - 1;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 377812,
                "title": "javascript-solution-using-bitwise-or",
                "content": "### Problem Approach\\nBinary search is an efficient way to search a *sorted* array, since we can make guess where its range is each time before finding the target. This is possible with a `midpoint`, which is the distance between the `low` index and `high` index of the array.  \\n* If the element at the midpoint is **less than** the target, then we search the lower half by moving the `high` index down, and recalculate the midpoint.\\n*  If the element at the midpoint is **greater than** the target, then we search the upper half by moving the `low` index up and recalculating the midpoint.\\n*  If the element at the midpoint **equals** the target, return the midpoint. \\n\\nOne way of calculating the midpoint without using function calls like `Math.floor()` or `Math.trunc()` is to use the [bitwise OR operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Bitwise_Operators#(Bitwise_OR)) as follows: \\n\\n`mid = ((low + high) / 2) | 0`\\n\\n### Solution\\n```js\\n/**\\n * @param {number[]} nums The array to search\\n * @param {number} target The target element \\n * @return {number} the index of the target element if found\\n */\\nconst search = (nums, target) => {\\n    // Declare our low index, high index, and mid\\n    let low = 0, high = nums.length - 1, mid\\n    \\n    while (low <= high) {\\n        // Calculate the midpoint of the array length\\n        mid = ((low + high) / 2) | 0\\n        \\n        // Return the index if we found our target\\n        if (target === nums[mid]) \\n            return mid\\n        \\n        // Move to the upper half of the array if target is bigger,\\n        // Else move to the lower hald.\\n        if (target > nums[mid]) \\n            low = mid + 1\\n        else \\n            high = mid - 1\\n    }\\n    // Return -1 if we couldn\\'t find our target\\n    return -1\\n}\\n```\\n\\n### Bitwise OR Explanation:\\n`|` pairs each bit on the left operand with the right operand. The neat factor here is **bitwise operators cast the number to an integer before its applied**. That is why the number gets rounded. The cast truncates any fractional part.\\n\\n`0` is used as the second operand so that it doesn\\'t modify the original value after the cast.",
                "solutionTags": [
                    "JavaScript",
                    "Bit Manipulation",
                    "Binary Tree"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums The array to search\\n * @param {number} target The target element \\n * @return {number} the index of the target element if found\\n */\\nconst search = (nums, target) => {\\n    // Declare our low index, high index, and mid\\n    let low = 0, high = nums.length - 1, mid\\n    \\n    while (low <= high) {\\n        // Calculate the midpoint of the array length\\n        mid = ((low + high) / 2) | 0\\n        \\n        // Return the index if we found our target\\n        if (target === nums[mid]) \\n            return mid\\n        \\n        // Move to the upper half of the array if target is bigger,\\n        // Else move to the lower hald.\\n        if (target > nums[mid]) \\n            low = mid + 1\\n        else \\n            high = mid - 1\\n    }\\n    // Return -1 if we couldn\\'t find our target\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 168585,
                "title": "c-solution",
                "content": "```\\nint search(vector<int>& nums, int target) {\\n        \\n        int left = 0;\\n        int right = nums.size()-1;\\n        \\n        while(left <= right) {\\n            int mid = left + (right-left)/2;\\n            if(nums[mid] < target) {\\n                left = mid+1;\\n            } else if(nums[mid] > target) {\\n                right = mid-1;\\n            } else {\\n                return mid;\\n            }\\n        }\\n        \\n        return -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint search(vector<int>& nums, int target) {\\n        \\n        int left = 0;\\n        int right = nums.size()-1;\\n        \\n        while(left <= right) {\\n            int mid = left + (right-left)/2;\\n            if(nums[mid] < target) {\\n                left = mid+1;\\n            } else if(nums[mid] > target) {\\n                right = mid-1;\\n            } else {\\n                return mid;\\n            }\\n        }\\n        \\n        return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3453264,
                "title": "c-with-an-explanation",
                "content": "# Approach\\nIf element in the middle is equal to the target -> return middle index\\nelse if target > middle -> left = middle + 1 and we check side on the right\\nelse check side on he left\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        int middle = (left + right) / 2;\\n\\n        while (left <= right) {\\n            if (nums[middle] == target)\\n                return middle;\\n            if (target > nums[middle])\\n                left = middle + 1;\\n            else if (target < nums[middle])\\n                right = middle - 1;\\n            \\n            middle = (left + right) / 2;\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0;\\n        int right = nums.size() - 1;\\n        int middle = (left + right) / 2;\\n\\n        while (left <= right) {\\n            if (nums[middle] == target)\\n                return middle;\\n            if (target > nums[middle])\\n                left = middle + 1;\\n            else if (target < nums[middle])\\n                right = middle - 1;\\n            \\n            middle = (left + right) / 2;\\n        }\\n\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3372073,
                "title": "binary-search-90",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.Length - 1;\\n\\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int Search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.Length - 1;\\n\\n        while(left <= right){\\n            int mid = (left + right) / 2;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            if(nums[mid] > target){\\n                right = mid - 1;\\n            }\\n            else{\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367265,
                "title": "easiest-approach-out-there",
                "content": "# Intuition\\nSimple and lazy :)\\n\\n# Approach\\nSimple algorithm via a for loop.\\nIf target is found return the index \\nIf not keep iterating till you reach the end of the array\\nIf target is still not found yet , return -1 \\n\\n# Complexity\\n- Time complexity:\\nO\\n\\n- Space complexity:\\nO\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nconst search = function(nums, target) {\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i]=== target){\\n            return i;\\n        }\\n    }\\n    return -1 ;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nconst search = function(nums, target) {\\n    for(let i=0; i<nums.length;i++){\\n        if(nums[i]=== target){\\n            return i;\\n        }\\n    }\\n    return -1 ;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3364635,
                "title": "c-time-space-100-beats-binary-search",
                "content": "you can upvote this solution this more helpful for me..\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& v, int k) {\\n        int i =0,j=v.size()-1,mid;\\n        while(i<=j){\\n            mid = (j-i)/2+i;\\n            if(v[mid]>k)\\n                j = mid-1;\\n            else if(v[mid]<k)\\n                i = mid+1;\\n            else return mid;\\n        }\\n        return -1;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& v, int k) {\\n        int i =0,j=v.size()-1,mid;\\n        while(i<=j){\\n            mid = (j-i)/2+i;\\n            if(v[mid]>k)\\n                j = mid-1;\\n            else if(v[mid]<k)\\n                i = mid+1;\\n            else return mid;\\n        }\\n        return -1;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364016,
                "title": "day-91-binary-search-o-logn-time-easiest-beginner-friendly-sol",
                "content": "**NOTE - PLEASE READ INTUITION AND APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Intuition of this Problem :\\n*This is an implementation of binary search algorithm to find a target element in a sorted array of integers. The algorithm starts by initializing two pointers, startIndex and lastIndex, which point to the first and last indices of the array respectively.*\\n\\n*Then, it repeatedly divides the search range in half by calculating the midIndex as the average of the startIndex and lastIndex. The value at the midIndex is compared with the target value. If they are equal, the midIndex is returned as the index of the target element.*\\n\\n*Otherwise, if the value at midIndex is greater than the target, it means that the target element lies in the first half of the search range. Therefore, the lastIndex is updated to midIndex - 1 to search in the first half of the array. On the other hand, if the value at midIndex is less than the target, it means that the target element lies in the second half of the search range. Therefore, the startIndex is updated to midIndex + 1 to search in the second half of the array.*\\n\\n*This process is repeated until either the target element is found and its index is returned, or the startIndex becomes greater than the lastIndex, indicating that the target element is not present in the array. In the latter case, the function returns -1 to indicate that the target element was not found.*\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach for this Problem :\\n1. Initialize two variables, startIndex and lastIndex, to the first and last indices of the input array nums.\\n2. Use a while loop to repeatedly check if startIndex is less than or equal to lastIndex.\\n3. Within the while loop, calculate the midpoint index of the current subarray by adding startIndex and lastIndex and dividing by 2.\\n4. Check if the element at the midpoint index is equal to the target value. If it is, return the midpoint index as the result.\\n5. If the element at the midpoint index is greater than the target value, update lastIndex to be one less than the midpoint index.\\n6. If the element at the midpoint index is less than the target value, update startIndex to be one more than the midpoint index.\\n7. Once the while loop terminates (i.e. the target value is not found in the array), return -1 as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Code :\\n```C++ []\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int startIndex = 0; \\n        int lastIndex = nums.size() - 1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if(nums[midIndex] == target){\\n                return midIndex;\\n            }\\n            else if(nums[midIndex] > target){\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return -1;   \\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int startIndex = 0; \\n        int lastIndex = nums.length - 1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound \\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if(nums[midIndex] == target){\\n                return midIndex;\\n            }\\n            else if(nums[midIndex] > target){\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return -1;   \\n    }\\n}\\n```\\n```Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        startIndex = 0\\n        lastIndex = len(nums) - 1\\n        while(startIndex <= lastIndex):\\n            midIndex = (startIndex + (lastIndex - startIndex)//2)\\n            if(nums[midIndex] == target):\\n                return midIndex\\n            elif(nums[midIndex] > target):\\n                lastIndex = midIndex - 1\\n            else:\\n                startIndex = midIndex + 1\\n        return -1   \\n```\\n\\n# Time Complexity and Space Complexity:\\n- **Time Complexity :** **O(logN)** // where N is the size of array\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- **Space Complexity :** **O(1)** // we are not using any extra space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array",
                    "Binary Search"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int startIndex = 0; \\n        int lastIndex = nums.size() - 1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound\\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if(nums[midIndex] == target){\\n                return midIndex;\\n            }\\n            else if(nums[midIndex] > target){\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return -1;   \\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int startIndex = 0; \\n        int lastIndex = nums.length - 1;\\n        while(startIndex <= lastIndex){\\n            //helps to prevent from out of bound \\n            int midIndex = (startIndex + (lastIndex - startIndex) / 2);\\n            if(nums[midIndex] == target){\\n                return midIndex;\\n            }\\n            else if(nums[midIndex] > target){\\n                lastIndex = midIndex - 1;\\n            }\\n            else{\\n                startIndex = midIndex + 1;\\n            }\\n        }\\n        return -1;   \\n    }\\n}\\n```\n```Python []\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        startIndex = 0\\n        lastIndex = len(nums) - 1\\n        while(startIndex <= lastIndex):\\n            midIndex = (startIndex + (lastIndex - startIndex)//2)\\n            if(nums[midIndex] == target):\\n                return midIndex\\n            elif(nums[midIndex] > target):\\n                lastIndex = midIndex - 1\\n            else:\\n                startIndex = midIndex + 1\\n        return -1   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103579,
                "title": "javascript-easy-solution-with-explanation-o-log-n",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n It has O(log n) time complexity. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n It has O(1) space complexity.\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\n\\n\\nvar search = function(nums, target) {\\n    \\n    let low = 0, \\n         high = nums.length-1;\\n         //It initializes two variables \"low\" and \"high\" to 0 and the last index of the array respectively.\\n    \\n    while(low <= high) {\\n        //The function enters a while loop that continues as long as low is less than or equal   to high.\\n    let mid = Math.floor((low+high)/2);\\n    //Within the loop, it calculates the middle index of the array by taking the floor of the average of low and high.\\n    \\n        if(nums[mid] === target)\\n            return mid;\\n            //It then checks if the element at the middle index is equal to the target, if it is it returns the middle index.\\n        \\n        else if(nums[mid] > target)\\n            high = mid - 1;\\n            //If the element at the middle index is greater than the target, it updates high to be one less than the middle index.\\n        \\n        else \\n            low = mid + 1;\\n            //If the element at the middle index is less than the target, it updates low to be one more than the middle index.\\n    }\\n    return -1;\\n    //If the target is not found in the array, the function returns -1.\\n    \\n};\\n```\\n# \\nif this is helpful for you , Please Upvote!\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\n\\n\\nvar search = function(nums, target) {\\n    \\n    let low = 0, \\n         high = nums.length-1;\\n         //It initializes two variables \"low\" and \"high\" to 0 and the last index of the array respectively.\\n    \\n    while(low <= high) {\\n        //The function enters a while loop that continues as long as low is less than or equal   to high.\\n    let mid = Math.floor((low+high)/2);\\n    //Within the loop, it calculates the middle index of the array by taking the floor of the average of low and high.\\n    \\n        if(nums[mid] === target)\\n            return mid;\\n            //It then checks if the element at the middle index is equal to the target, if it is it returns the middle index.\\n        \\n        else if(nums[mid] > target)\\n            high = mid - 1;\\n            //If the element at the middle index is greater than the target, it updates high to be one less than the middle index.\\n        \\n        else \\n            low = mid + 1;\\n            //If the element at the middle index is less than the target, it updates low to be one more than the middle index.\\n    }\\n    return -1;\\n    //If the target is not found in the array, the function returns -1.\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3053538,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums, int l,  int h, int target)\\n    {\\n        if(l>h)\\n            return -1;\\n        int m=(l+h)/2;\\n        if(nums[m]==target)\\n            return m;\\n        if(target<nums[m])\\n            return f(nums, l, m-1, target);\\n        else\\n            return f(nums, m+1, h, target);\\n    }\\n    int search(vector<int>& nums, int target) {\\n        return f(nums, 0, nums.size()-1, target);\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(vector<int>& nums, int l,  int h, int target)\\n    {\\n        if(l>h)\\n            return -1;\\n        int m=(l+h)/2;\\n        if(nums[m]==target)\\n            return m;\\n        if(target<nums[m])\\n            return f(nums, l, m-1, target);\\n        else\\n            return f(nums, m+1, h, target);\\n    }\\n    int search(vector<int>& nums, int target) {\\n        return f(nums, 0, nums.size()-1, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668145,
                "title": "js-o-log-n-binary-search-algorithm",
                "content": "Binary search is a search algorithm that finds the index of a target value in a sorted array. Binary search compares the target value with the middle element of the array (rounding to get an integer, in my case with a double bitwise NOT (~), i.e. (~~)). If they are not equal, the half in which the target cannot lie is discarded and the search continues on the other half, we again take the middle element to compare with the target value and repeat this until the target value is found. If the search ends with half remaining empty, it means that the target is not in the array, so we return -1.\\n\\n```\\nvar search = function (nums, target) {\\n    let low = 0;\\n    let high = nums.length - 1;\\n    while (low <= high) {\\n        let mid = ~~(low + (high - low) / 2);\\n\\n        if (nums[mid] > target) high = --mid;\\n        else if (nums[mid] < target) low = ++mid;\\n        else return mid;\\n    }\\n    return -1;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```\\nvar search = function (nums, target) {\\n    let low = 0;\\n    let high = nums.length - 1;\\n    while (low <= high) {\\n        let mid = ~~(low + (high - low) / 2);\\n\\n        if (nums[mid] > target) high = --mid;\\n        else if (nums[mid] < target) low = ++mid;\\n        else return mid;\\n    }\\n    return -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2653399,
                "title": "easiest-solution-for-beginners-iterative-and-recursive-method-explanation",
                "content": "\\nWhat is ***Binary Search***?\\n* It is a method, to find a particular target, in a given array/ vector.\\n* This method, is faster than the *Linear Search method*, since it is based on Divide & Conquer method.\\n* It uses 2-pointer approach, to save time and space both.\\n\\nHello learners, for this problem, we can use 2 methods:\\n1. Iterative method\\n2. Recursive method.\\n\\n# Iterative Method\\nIn this method, we will use 2 pointers, for example ( start and end ) where initially, start=0 and end=arr.size()-1.\\n\\n*Algorithm*\\n1. At start, initialize start=0 and end=arr.size()-1;         //Here arr is an array/vector.\\n2. Initialize, mid=(start+end)/2;\\n3. While (start<=end): \\n\\t1. If arr[mid]==key, then return mid.\\n\\t2. Else if arr[mid]<key, then start=mid+1;\\n\\t3. Else end=mid-1;\\n\\n\\nUpvote , if found useful \\uD83D\\uDE01\\uD83D\\uDE09\\n\\n***Code***\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();                     // Size of  Vector.\\n        int start=0, end= n-1;                 // Here \\'start\\' is start index, and \\'end\\' is end index.\\n       \\n\\t   // Check if (start<=end) \\n\\t   while(start<=end){                                  \\n            int mid=(start+end)/2;                   // Initialize middle index, at each loop.\\n            if(nums[mid]==target) return mid;        // If target is equal to value at index.\\n            else if(nums[mid]<target) i=mid+1;       // If target is greater than value at index.\\n            else j=mid-1;                            // If target is lesser than value at index.\\n        }\\n        return -1;                                   // Return -1, if the target not present in vector.\\n    }\\n};\\n```\\n```\\nTime Complexity: O(logn)\\nSpace Complexity: O(1)\\n```\\n# Recursive Approach\\nIn this method, we will use 2 pointers, for example ( start and end ) where initially, start=0 and end=arr.size()-1.\\n\\n*Algorithm*\\nIn recursive function,\\n* Initialize ***mid= low+(high-low)/2***        \\n\\t1. If target ==arr[mid], then ***return mid***\\n\\t2. Else if arr[mid]<key, then call the recursive loop with updated \\'start\\' value , and ***return binarysearch(nums, target, mid+1, high).***\\n\\t3. Else end=mid-1, then call the recursive loop with updated \\'end\\' value and ***return binarysearch(nums, target, low, mid-1)***\\n\\n\\nUpvote , if found useful \\uD83D\\uDE01\\uD83D\\uDE09\\n\\n```\\nint binarysearch(vector<int> &nums, int target, int low, int high) {\\n        int mid = low + (high-low)/2;                              // Initialize middle index, at each loop.\\n        if(low<=high) {                                            // Check intial condition \\n            if(nums[mid] == target) {\\n                return mid;                                         // If target is equal to value at index.\\n            } \\n\\t\\t\\telse if(nums[mid] < target) {\\n                return binarysearch(nums, target, mid+1, high);      // If target is greater than value at index.\\n            } \\n\\t\\t\\telse return binarysearch(nums, target, low, mid-1);       // If target is lesser than value at index.\\n        }\\n        return -1;                                       // Return -1, if the target not present in vector.            \\n    }\\n    \\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();                              // Size of vector.\\n        return binarysearch(nums, target, 0, n-1);        // Call the recursive funcition\\n    } \\n```\\n\\n```\\nTime Complexity: O(logn)\\nSpace Complexity: O(logn) [auxiliary space]\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n=nums.size();                     // Size of  Vector.\\n        int start=0, end= n-1;                 // Here \\'start\\' is start index, and \\'end\\' is end index.\\n       \\n\\t   // Check if (start<=end) \\n\\t   while(start<=end){                                  \\n            int mid=(start+end)/2;                   // Initialize middle index, at each loop.\\n            if(nums[mid]==target) return mid;        // If target is equal to value at index.\\n            else if(nums[mid]<target) i=mid+1;       // If target is greater than value at index.\\n            else j=mid-1;                            // If target is lesser than value at index.\\n        }\\n        return -1;                                   // Return -1, if the target not present in vector.\\n    }\\n};\\n```\n```\\nTime Complexity: O(logn)\\nSpace Complexity: O(1)\\n```\n```\\nint binarysearch(vector<int> &nums, int target, int low, int high) {\\n        int mid = low + (high-low)/2;                              // Initialize middle index, at each loop.\\n        if(low<=high) {                                            // Check intial condition \\n            if(nums[mid] == target) {\\n                return mid;                                         // If target is equal to value at index.\\n            } \\n\\t\\t\\telse if(nums[mid] < target) {\\n                return binarysearch(nums, target, mid+1, high);      // If target is greater than value at index.\\n            } \\n\\t\\t\\telse return binarysearch(nums, target, low, mid-1);       // If target is lesser than value at index.\\n        }\\n        return -1;                                       // Return -1, if the target not present in vector.            \\n    }\\n    \\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();                              // Size of vector.\\n        return binarysearch(nums, target, 0, n-1);        // Call the recursive funcition\\n    } \\n```\n```\\nTime Complexity: O(logn)\\nSpace Complexity: O(logn) [auxiliary space]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2351181,
                "title": "c-code-easy-and-fast",
                "content": "**Code is available in comment**",
                "solutionTags": [
                    "C"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1884365,
                "title": "o-log-n-c-beats-100-with-explanation-iterative-binary-search",
                "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\t// declaring low and high iterators\\n        int lo=0;\\n        int hi=nums.size()-1;\\n\\t\\t\\n        int mid; // only declaration here \\n        while(lo<=hi)\\n        {\\n            mid=(lo+hi)/2; // initializing mid with an avg value\\n\\t\\t\\t\\n\\t\\t\\t// base condition , here we\\'ll get the index\\n            if(target==nums[mid])\\n                return mid;\\n\\t\\t\\t\\t\\n\\t\\t\\t// this condition tells us that the target element lies to the left side of mid index \\n            else if(target<nums[mid])\\n                hi=mid-1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// hidden condition is if(target>nums[mid] here, it tells that target is on the right side\\n            else\\n                lo=mid+1;\\n            \\n        }\\n\\t\\t\\n\\t\\t// in case if the element isn\\'t found we\\'d return -1 depicting the unavalibility of targert in the array\\n        return -1;\\n    }\\n};\\n\\n// Please upvote !! this is my first solution :)\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n\\t// declaring low and high iterators\\n        int lo=0;\\n        int hi=nums.size()-1;\\n\\t\\t\\n        int mid; // only declaration here \\n        while(lo<=hi)\\n        {\\n            mid=(lo+hi)/2; // initializing mid with an avg value\\n\\t\\t\\t\\n\\t\\t\\t// base condition , here we\\'ll get the index\\n            if(target==nums[mid])\\n                return mid;\\n\\t\\t\\t\\t\\n\\t\\t\\t// this condition tells us that the target element lies to the left side of mid index \\n            else if(target<nums[mid])\\n                hi=mid-1;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// hidden condition is if(target>nums[mid] here, it tells that target is on the right side\\n            else\\n                lo=mid+1;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1681186,
                "title": "python-solution",
                "content": "**Runtime: 110 ms, faster than 96.08% of Python online submissions for Binary Search.\\nMemory Usage: 11.8 MB, less than 37.88% of Python online submissions for Binary Search.**\\n\\n```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        lower = 0\\n        upper = len(nums)-1\\n        \\n        while lower <= upper:\\n            mid = (lower) + (upper-lower)//2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                lower = mid + 1\\n            else:\\n                upper = mid - 1\\n        return -1\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        lower = 0\\n        upper = len(nums)-1\\n        \\n        while lower <= upper:\\n            mid = (lower) + (upper-lower)//2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                lower = mid + 1\\n            else:\\n                upper = mid - 1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1667054,
                "title": "python-easy-solution-optimized-approach",
                "content": "\\t# Time: O(logn)\\n\\tclass Solution:\\n\\t\\tdef search(self, nums: List[int], target: int) -> int:\\n\\t\\t\\tdef bSearch(nums, low, high, targ):\\n\\t\\t\\t\\tif high >= low:\\n\\t\\t\\t\\t\\tmid = low+(high-low)//2\\n\\t\\t\\t\\t\\tif nums[mid] == targ:\\n\\t\\t\\t\\t\\t\\treturn mid\\n\\t\\t\\t\\t\\telif nums[mid] > targ:\\n\\t\\t\\t\\t\\t\\treturn bSearch(nums, low, mid-1, targ)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn bSearch(nums, mid+1, high, targ)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\treturn bSearch(nums, 0, len(nums)-1, target)\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "\\t# Time: O(logn)\\n\\tclass Solution:\\n\\t\\tdef search(self, nums: List[int], target: int) -> int:\\n\\t\\t\\tdef bSearch(nums, low, high, targ):\\n\\t\\t\\t\\tif high >= low:\\n\\t\\t\\t\\t\\tmid = low+(high-low)//2\\n\\t\\t\\t\\t\\tif nums[mid] == targ:\\n\\t\\t\\t\\t\\t\\treturn mid\\n\\t\\t\\t\\t\\telif nums[mid] > targ:\\n\\t\\t\\t\\t\\t\\treturn bSearch(nums, low, mid-1, targ)\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\treturn bSearch(nums, mid+1, high, targ)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\treturn -1\\n\\t\\t\\treturn bSearch(nums, 0, len(nums)-1, target)\\nIf you have any questions, please ask me, and if you like this approach, please **vote it up**!",
                "codeTag": "Java"
            },
            {
                "id": 1502704,
                "title": "python-beginner-easy",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        start=0\\n        end=len(nums)-1\\n        \\n        def binary_search(nums,start,end,target):\\n            if end >= start:\\n                \\n                mid=(end+start)//2\\n                \\n                if target == nums[mid]:\\n                    return mid\\n                \\n                elif target > nums[mid]:\\n                    return binary_search(nums,mid+1,end,target)\\n                \\n                elif target < nums[mid]: \\n                    return binary_search(nums,start,mid-1,target)\\n                \\n            else:\\n                return -1\\n            \\n        return binary_search(nums,start,end,target)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        start=0\\n        end=len(nums)-1\\n        \\n        def binary_search(nums,start,end,target):\\n            if end >= start:\\n                \\n                mid=(end+start)//2\\n                \\n                if target == nums[mid]:\\n                    return mid\\n                \\n                elif target > nums[mid]:\\n                    return binary_search(nums,mid+1,end,target)\\n                \\n                elif target < nums[mid]: \\n                    return binary_search(nums,start,mid-1,target)\\n                \\n            else:\\n                return -1\\n            \\n        return binary_search(nums,start,end,target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1461864,
                "title": "ruby-solution",
                "content": "find midpoint point within array. compare target with mid point value. If its a match, were done. Else if target is smaller than midpoint value, repeat steps with subarray[start : mid -1], else repeat steps with subarray[mid + 1 : end]. We dont need to check the mid twice hence the - or + after each step.\\n```\\ndef search(nums, target)\\n    low = 0\\n    high = nums.length - 1\\n    while(low <= high) do\\n        mid = (high + low) / 2\\n        if(nums[mid] == target)\\n            return mid\\n        elsif nums[mid] > target\\n            high = mid - 1\\n        else\\n            low = mid + 1\\n        end\\n    end\\n    return -1\\nend\\n\\n```",
                "solutionTags": [],
                "code": "```\\ndef search(nums, target)\\n    low = 0\\n    high = nums.length - 1\\n    while(low <= high) do\\n        mid = (high + low) / 2\\n        if(nums[mid] == target)\\n            return mid\\n        elsif nums[mid] > target\\n            high = mid - 1\\n        else\\n            low = mid + 1\\n        end\\n    end\\n    return -1\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1141678,
                "title": "python3-simple-solution-beats-90-users",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        def binSearch(low,high,nums):\\n            if low <= high:\\n                mid = (low+high)//2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    return binSearch(mid+1,high,nums)\\n                else:\\n                    return binSearch(low,mid-1,nums)\\n            else:\\n                return -1\\n        return binSearch(0,len(nums)-1,nums)\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        def binSearch(low,high,nums):\\n            if low <= high:\\n                mid = (low+high)//2\\n                if nums[mid] == target:\\n                    return mid\\n                elif nums[mid] < target:\\n                    return binSearch(mid+1,high,nums)\\n                else:\\n                    return binSearch(low,mid-1,nums)\\n            else:\\n                return -1\\n        return binSearch(0,len(nums)-1,nums)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 747899,
                "title": "100-faster-0ms-very-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[mid] < target)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n        while(left <= right){\\n            int mid = (left + right)/2;\\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[mid] < target)\\n                left = mid + 1;\\n            else\\n                right = mid - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 439643,
                "title": "python-recursive-implementation",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        self.nums, self.target = nums, target\\n        return self.helper(0, len(nums)-1)\\n    \\n    def helper(self, low: int, high: int) -> int:\\n        if low > high: return -1\\n        mid = (high + low) // 2\\n        \\n        if self.target == self.nums[mid]: return mid\\n        elif self.target < self.nums[mid]: return self.helper(low, mid-1)\\n        else: return self.helper(mid+1, high)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        self.nums, self.target = nums, target\\n        return self.helper(0, len(nums)-1)\\n    \\n    def helper(self, low: int, high: int) -> int:\\n        if low > high: return -1\\n        mid = (high + low) // 2\\n        \\n        if self.target == self.nums[mid]: return mid\\n        elif self.target < self.nums[mid]: return self.helper(low, mid-1)\\n        else: return self.helper(mid+1, high)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415121,
                "title": "c-binary-search",
                "content": "```csharp\\npublic class Solution \\n{\\n    public int Search(int[] nums, int target) \\n    {\\n        int low = 0;\\n        int high = nums.Length - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            \\n            if(nums[mid] == target)\\n            {\\n                return mid;\\n            }\\n            else if(nums[mid] < target)\\n            {\\n                low = mid + 1;                \\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n            \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic class Solution \\n{\\n    public int Search(int[] nums, int target) \\n    {\\n        int low = 0;\\n        int high = nums.Length - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            \\n            if(nums[mid] == target)\\n            {\\n                return mid;\\n            }\\n            else if(nums[mid] < target)\\n            {\\n                low = mid + 1;                \\n            }\\n            else\\n            {\\n                high = mid - 1;\\n            }\\n        }\\n            \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 384104,
                "title": "clean-code-for-c-binary-seach-44ms-beats-98",
                "content": "Runtime: 44 ms, faster than 98.01% of C++ online submissions for Binary Search.\\nMemory Usage: 10.9 MB, less than 61.11% of C++ online submissions for Binary Search.\\n\\n```\\nint search(vector<int>& nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.size() - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            \\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[mid] < target)\\n                low = mid + 1;\\n            else\\n                high = mid - 1;    \\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "Runtime: 44 ms, faster than 98.01% of C++ online submissions for Binary Search.\\nMemory Usage: 10.9 MB, less than 61.11% of C++ online submissions for Binary Search.\\n\\n```\\nint search(vector<int>& nums, int target) {\\n        \\n        int low = 0;\\n        int high = nums.size() - 1;\\n        \\n        while(low <= high)\\n        {\\n            int mid = low + (high - low)/2;\\n            \\n            if(nums[mid] == target)\\n                return mid;\\n            else if(nums[mid] < target)\\n                low = mid + 1;\\n            else\\n                high = mid - 1;    \\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3718865,
                "title": "java-solution-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe need to find the target in the given sorted array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe have used the two pointer approach to solve the problem.\\nFor every iteration, the array will be divided in the half part and then we will search in the divided half part until we don\\'t find our target element.\\n\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n            int mid = (end-start)/2 + start;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            else if(target>nums[mid]){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0;\\n        int end = nums.length-1;\\n\\n        while(start<=end){\\n            int mid = (end-start)/2 + start;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            else if(target>nums[mid]){\\n                start = mid + 1;\\n            }\\n            else{\\n                end = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3511975,
                "title": "recursion-approach-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int ans = binarySearch(nums,0,nums.length-1,target);\\n        return ans;\\n    }\\n    private int binarySearch(int[] nums , int start , int end , int target){\\n        if(start>end) return -1;\\n        int mid = (start)+(end-start)/2;\\n        if(target==nums[mid]) return mid;\\n        else if(target>nums[mid]) return binarySearch(nums,mid+1,end,target);\\n        else return binarySearch(nums,start , mid-1,target); \\n    }\\n}\\n```\\n![upvote.png](https://assets.leetcode.com/users/images/591e1440-b8d9-44e0-9204-295bbd580a8d_1683800074.5621686.png)\\n",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int ans = binarySearch(nums,0,nums.length-1,target);\\n        return ans;\\n    }\\n    private int binarySearch(int[] nums , int start , int end , int target){\\n        if(start>end) return -1;\\n        int mid = (start)+(end-start)/2;\\n        if(target==nums[mid]) return mid;\\n        else if(target>nums[mid]) return binarySearch(nums,mid+1,end,target);\\n        else return binarySearch(nums,start , mid-1,target); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455250,
                "title": "binary-search-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![image.png](https://assets.leetcode.com/users/images/a00e3433-c589-4601-bf1f-05df7054b552_1682456624.1862972.png)\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right) {\\n            int middle = (left + right) / 2;\\n            if (nums[middle] == target) {\\n                return middle;\\n            }\\n\\n            if (target > nums[middle]) {\\n                left = middle + 1;\\n            } else {\\n                right = middle - 1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right) {\\n            int middle = (left + right) / 2;\\n            if (nums[middle] == target) {\\n                return middle;\\n            }\\n\\n            if (target > nums[middle]) {\\n                left = middle + 1;\\n            } else {\\n                right = middle - 1;\\n            }\\n        }\\n\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3420740,
                "title": "solution-in-python",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nBinary Search\\n1. Assigning left=0 & right=(length of the given list)\\n2. Finding the middle element: (left+right)//2\\n3. than simply compare middle element value the target value and go the left/right according the target\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left=0\\n        right=len(nums)-1\\n        while(left<=right):\\n            mid=(left+right)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif target<nums[mid]:\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left=0\\n        right=len(nums)-1\\n        while(left<=right):\\n            mid=(left+right)//2\\n            if nums[mid]==target:\\n                return mid\\n            elif target<nums[mid]:\\n                right=mid-1\\n            else:\\n                left=mid+1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3366196,
                "title": "easiest-c-solution-3-lines-of-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == target)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        for(int i=0; i<nums.size(); i++){\\n            if(nums[i] == target)\\n                return i;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365415,
                "title": "c-easy-explanation-beginner-friendly",
                "content": "# Intuition\\nAlready given we have to use binary search algorithm.\\n\\n# Approach\\nWe will divide the array into many sub-arrays and find the target value in all those sub-arrays so basically binary search is divide and conquer algorithm which divides the problems into small sub-problems.\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int binarySearch(vector<int>&nums ,int left, int right, int target) {\\n\\n        // If target value not found return -1.\\n        if(left > right)\\n            return -1;\\n\\n        // We will use index of the array to find the value.\\n        int mid = (left+right)/2;\\n\\n\\n        // Target value found\\n        if(nums[mid] == target)\\n            return mid;\\n\\n        // Divide the array into sub-arrays and proceed to that su-array according to target value. \\n        // As the array is sorted, if the target value is more than mid value of current sub-array \\n        // that means the given target value might be present in the sub-array with index greater than mid. \\n        if(target > nums[mid])\\n            return binarySearch(nums, mid+1, right, target);\\n        else\\n            return binarySearch(nums, left, mid-1, target);\\n    }\\n\\n    int search(vector<int>& nums, int target) {\\n        return binarySearch(nums, 0, nums.size()-1, target);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int binarySearch(vector<int>&nums ,int left, int right, int target) {\\n\\n        // If target value not found return -1.\\n        if(left > right)\\n            return -1;\\n\\n        // We will use index of the array to find the value.\\n        int mid = (left+right)/2;\\n\\n\\n        // Target value found\\n        if(nums[mid] == target)\\n            return mid;\\n\\n        // Divide the array into sub-arrays and proceed to that su-array according to target value. \\n        // As the array is sorted, if the target value is more than mid value of current sub-array \\n        // that means the given target value might be present in the sub-array with index greater than mid. \\n        if(target > nums[mid])\\n            return binarySearch(nums, mid+1, right, target);\\n        else\\n            return binarySearch(nums, left, mid-1, target);\\n    }\\n\\n    int search(vector<int>& nums, int target) {\\n        return binarySearch(nums, 0, nums.size()-1, target);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364891,
                "title": "beats-100-short-and-clean-code-with-explained-approach-non-recursive",
                "content": "# Approach\\nThe approach used in this code is an iterative implementation of binary search. The function search takes two arguments: the sorted array nums and the target value target. The function initializes two pointers low and high to the first and last indices of the array, respectively. The while loop runs as long as the difference between high and low is greater than 1, which means that there are at least two elements in the search space. In each iteration, the function computes the middle index mid as the average of low and high. If the middle element is less than the target, the search is continued in the upper half of the search space by updating low to mid + 1. Otherwise, the search is continued in the lower half of the search space by updating high to mid.\\n\\nWhen the while loop terminates, the function checks if the target value is equal to nums[low] or nums[high]. If either of them is true, the function returns the index of the matching element. Otherwise, the function returns -1 to indicate that the target is not found in the array.\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) \\n    {\\n        int low = 0, high = nums.length - 1;\\n        while (high - low > 1) {\\n            int mid = (high + low) / 2;\\n            if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid;\\n            }\\n        }\\n        if (nums[low] == target) {\\n            return low;\\n        }\\n        else if (nums[high] == target) {\\n            return high;\\n        }\\n        else {\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) \\n    {\\n        int low = 0, high = nums.length - 1;\\n        while (high - low > 1) {\\n            int mid = (high + low) / 2;\\n            if (nums[mid] < target) {\\n                low = mid + 1;\\n            }\\n            else {\\n                high = mid;\\n            }\\n        }\\n        if (nums[low] == target) {\\n            return low;\\n        }\\n        else if (nums[high] == target) {\\n            return high;\\n        }\\n        else {\\n            return -1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364497,
                "title": "c-easy-solution-binary-search",
                "content": "# Intuition\\nIt is already mentioned that this problem must be solved using Binary Search.\\n\\n# Approach\\nWe will be taking 2 pointers (let say st and en) initially pointed at the ends of the array. \\n\\nNow consider the middle element between 2 pointers (let say m).\\n\\nif(nums[m] == target): \\nYes we found the element at index m so return it.\\n\\nif(target < nums[m]):\\nAs vector is in ascending order, nums[m]<=nums[m+1]<=nums[m+2]<=....nums[en].\\nSo target will be less than all the elements in the index range [m,en]. Target can be found in the index range [st,m-1]. \\n\\n**Update en = m-1.**(Searching in left half of array).\\n\\nif(target>nums[m]):\\nAs vector is in ascending order, nums[st]>=nums[st+1]>=nums[st+2]>=....nums[m].\\nSo target will be greater than all the elements in the index range [st,m]. Target can be found in the index range [m+1,en].\\n \\n**Update st = m+1.**(Seaching in right half of array).\\n\\n**If not found after traversing whole array return -1 at the end.**\\n\\n# Complexity\\n- Time complexity:\\nO(logN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int st = 0;\\n        int en = nums.size()-1;\\n        while(st<=en){\\n            int m = (en+st)/2;\\n            if(nums[m] == target){\\n                return m;\\n            }else if(nums[m]>target){\\n                en = m-1;\\n            }else{\\n                st = m+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int st = 0;\\n        int en = nums.size()-1;\\n        while(st<=en){\\n            int m = (en+st)/2;\\n            if(nums[m] == target){\\n                return m;\\n            }else if(nums[m]>target){\\n                en = m-1;\\n            }else{\\n                st = m+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364205,
                "title": "java-solution-with-comments-beginner-friendly-beats-100",
                "content": "# Intuition\\nBinary Search nothing much \\n\\n# Approach\\nAs it is binary search the first condition is for the elements in the arrays to be sorted otherwise we cannot perform a binary search on it.\\nSet two variables high and low with last and first index of the array\\nUsing a while loop iterate towards each element of the array and set a mid value with which you will compare the target each time you iterate, if mid is on target that is the value of array element at mid position is equal to target return the mid value, if value of array element at mid position is greater than target we set the value of high at mid - 1 else we set low at mid + 1. Otherwise return -1        \\n\\n# Complexity\\n- Time complexity:\\n$$O(log n)$$\\n\\n- Space complexity:\\n$$O(log N) (1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0 , high = nums.length-1;\\n \\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(nums[mid]==target) return mid;  //when mid is on the same position as target \\n            if(nums[mid]>target) high = mid - 1; //when the value on mid index is greater than target we set high on a positon mid - 1  \\n            else low = mid + 1; //when the value on mid index is less than target we set low on a postion mid + 1\\n        } \\n        return -1;\\n    }\\n}\\n\\n```\\n\\n![cat.jpg](https://assets.leetcode.com/users/images/a9767e6b-64e5-426e-8ebe-9d0212dce94b_1680330349.1245263.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0 , high = nums.length-1;\\n \\n        while(low<=high){\\n            int mid = (low+high)/2;\\n            if(nums[mid]==target) return mid;  //when mid is on the same position as target \\n            if(nums[mid]>target) high = mid - 1; //when the value on mid index is greater than target we set high on a positon mid - 1  \\n            else low = mid + 1; //when the value on mid index is less than target we set low on a postion mid + 1\\n        } \\n        return -1;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303071,
                "title": "awesome-o-log-n-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n    //time complexity----->O(Log N)\\n        left,right=0,len(nums)-1\\n        while left<=right:\\n            mid=left+(right-left)//2\\n            if nums[mid]>target:\\n                right=mid-1\\n            elif nums[mid]<target:\\n                left=mid+1\\n            else:\\n                return mid\\n        return -1\\n```\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n    #time complexity---->O(N)\\n        return nums.index(target) if target in nums else -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n    //time complexity----->O(Log N)\\n        left,right=0,len(nums)-1\\n        while left<=right:\\n            mid=left+(right-left)//2\\n            if nums[mid]>target:\\n                right=mid-1\\n            elif nums[mid]<target:\\n                left=mid+1\\n            else:\\n                return mid\\n        return -1\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n    #time complexity---->O(N)\\n        return nums.index(target) if target in nums else -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140876,
                "title": "java-best-solution-binary-search-in-2-ways-beats-100",
                "content": "# Recursive Approach :- \\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(log(n))\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int a = 0, r = nums.length - 1;\\n        return recur(nums,target,a,r); \\n    }\\n    public static int recur(int[] nums, int target,int a,int r){\\n        int mid = (a+r)/2;\\n        while(a <= r){\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>=target){\\n               return  recur(nums,target,a,mid - 1);\\n            }\\n            else if(nums[mid]<=target){\\n               return  recur(nums,target,mid + 1,r);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n# Iterative Approach :- \\n# Complexity\\n- Time complexity: O(log(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) \\n    {\\n        int a= 0,r= nums.length -1,mid = (a+r)/2;\\n        while(a<=r)\\n        {\\n            if(target < nums[mid])\\n            {\\n              r =mid-1;\\n            }\\n            else if(target > nums[mid])\\n            {\\n              a= mid+1;\\n            }\\n            else if(target == nums[mid])\\n            {\\n                return mid;\\n            }\\n            mid = (a+r)/2;\\n        }\\n        return -1;\\n    }\\n}\\n    \\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int a = 0, r = nums.length - 1;\\n        return recur(nums,target,a,r); \\n    }\\n    public static int recur(int[] nums, int target,int a,int r){\\n        int mid = (a+r)/2;\\n        while(a <= r){\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>=target){\\n               return  recur(nums,target,a,mid - 1);\\n            }\\n            else if(nums[mid]<=target){\\n               return  recur(nums,target,mid + 1,r);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int search(int[] nums, int target) \\n    {\\n        int a= 0,r= nums.length -1,mid = (a+r)/2;\\n        while(a<=r)\\n        {\\n            if(target < nums[mid])\\n            {\\n              r =mid-1;\\n            }\\n            else if(target > nums[mid])\\n            {\\n              a= mid+1;\\n            }\\n            else if(target == nums[mid])\\n            {\\n                return mid;\\n            }\\n            mid = (a+r)/2;\\n        }\\n        return -1;\\n    }\\n}\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138092,
                "title": "easy-c-solution-binary-search-linear-search-brute-force-optimize",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can Solved this question using Two approach.\\n\\n1. Using Linear Search (Brute Force).\\n2. Using Binary Search (Optimize).\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can easily understand All the approaches by seeing the code which is easy to understand with comments.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity provided in code comment.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity provided in code comment.\\n\\n# Code\\n```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case, the target element may be present at the end of the array.\\n    Thus the time complexity is linear.\\n\\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved Using linear Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved Using Binary Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            else if(nums[mid] > target){\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\n/*\\n\\n    Time Complexity : O(N), because in the worst case, the target element may be present at the end of the array.\\n    Thus the time complexity is linear.\\n\\n    Space Complexity : O(1), the space complexity is constant.\\n\\n    Solved Using linear Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n= nums.size();\\n        for(int i=0; i<n; i++){\\n            if(nums[i] == target){\\n                return i;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\n\\n\\n\\n\\n\\n/*\\n\\n    Time Complexity : O(log N), since we have used binary search to find the target element. The time complexity\\n    is logarithmic.\\n\\n    Space Complexity : O(1), since we stored only some constant number of elements, the space complexity is\\n    constant.\\n\\n    Solved Using Binary Search + Array.\\n\\n*/\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0;\\n        int high = nums.size()-1;\\n        while(low <= high){\\n            int mid = (low + high) >> 1;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            else if(nums[mid] > target){\\n                high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3051145,
                "title": "classic-binary-search-on-swift",
                "content": "# Code\\n```\\nclass Solution {\\n    func search(_ nums: [Int], _ target: Int) -> Int {\\n        var low = 0\\n        var high = nums.count - 1\\n        while low <= high {\\n            let mid = (high + low) / 2\\n            if nums[mid] == target {\\n                return mid\\n            }\\n            if nums[mid] < target {\\n                low = mid + 1\\n            } else if nums[mid] > target {\\n                high = mid - 1\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```\\n### Please upvote if the solution was useful!",
                "solutionTags": [
                    "Swift",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    func search(_ nums: [Int], _ target: Int) -> Int {\\n        var low = 0\\n        var high = nums.count - 1\\n        while low <= high {\\n            let mid = (high + low) / 2\\n            if nums[mid] == target {\\n                return mid\\n            }\\n            if nums[mid] < target {\\n                low = mid + 1\\n            } else if nums[mid] > target {\\n                high = mid - 1\\n            }\\n        }\\n        return -1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010584,
                "title": "typescript-binary-search",
                "content": "# Approach\\nBinary Search method: use left pointer, middle pointer, and right pointer. Half the search space with each iteration (left or right of middle pointer).\\n\\n# Complexity\\n- Time complexity:\\n$$O(log n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nfunction search(nums: number[], target: number): number {\\n  let l = 0, r = nums.length-1, m; // declare l and r ptr, initialize mid ptr\\n  while (l <= r) {\\n    m = Math.floor((l+r)/2) // middle point between l and r ptrs\\n    if (nums[m] == target) return m\\n    else if (nums[m] < target) l = m+1 // check right half\\n    else r = m-1 // check left half\\n  }\\n  return -1\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Binary Search"
                ],
                "code": "```\\nfunction search(nums: number[], target: number): number {\\n  let l = 0, r = nums.length-1, m; // declare l and r ptr, initialize mid ptr\\n  while (l <= r) {\\n    m = Math.floor((l+r)/2) // middle point between l and r ptrs\\n    if (nums[m] == target) return m\\n    else if (nums[m] < target) l = m+1 // check right half\\n    else r = m-1 // check left half\\n  }\\n  return -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2880602,
                "title": "javascript-simple-and-fast-binary-search",
                "content": "var search = function (nums, target) {\\n  let start = 0;\\n  let end = nums.length - 1;\\n  let curr = null;\\n  while (start <= end) {\\n    curr = Math.round((end - start) / 2) + start;\\n    if (nums[curr] === target) {\\n      return curr;\\n    } else if (target < nums[curr]) {\\n      end = curr - 1;\\n    } else {\\n      start = curr + 1;\\n    }\\n  }\\n  return -1;\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "var search = function (nums, target) {\\n  let start = 0;\\n  let end = nums.length - 1;\\n  let curr = null;\\n  while (start <= end) {\\n    curr = Math.round((end - start) / 2) + start;\\n    if (nums[curr] === target) {\\n      return curr;\\n    } else if (target < nums[curr]) {\\n      end = curr - 1;\\n    } else {\\n      start = curr + 1;\\n    }\\n  }\\n  return -1;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2843199,
                "title": "binary-search-code-java-solution-o-logn-time-complexity-and-o-1-space-complexity",
                "content": "# Intuition\\nBinary search works on the principal of dividing the list into equal halves and solving them and doing this process recursively till you find the solution\\n\\n# Approach\\n\\nLets find the mid first and then compare the target element if its less than and greater than the mid.\\nIf its greater than them search the right side or else left side\\n\\n# Complexity\\n- Time complexity:\\nO(logn) - Since we are dividing the list for every call and reducing the search space.\\n\\n- Space complexity:\\nO(1) since we are not using external variables to store the result. Here we are not considering how the recursion calls are made and how they are handled by the stack internally.\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        return binarySearch(0,nums.length-1,nums,target);\\n    }\\n    public int binarySearch(int left, int right,int[] nums,int target){\\n        if (left <= right) {\\n            int mid = (left + right) / 2;\\n            if (nums[mid] == target) return mid;\\n            else if (target < nums[mid])\\n                return binarySearch(left, mid - 1, nums, target);\\n            else if (target > nums[mid])\\n                return binarySearch(mid + 1, right, nums, target);\\n        }\\n     return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        return binarySearch(0,nums.length-1,nums,target);\\n    }\\n    public int binarySearch(int left, int right,int[] nums,int target){\\n        if (left <= right) {\\n            int mid = (left + right) / 2;\\n            if (nums[mid] == target) return mid;\\n            else if (target < nums[mid])\\n                return binarySearch(left, mid - 1, nums, target);\\n            else if (target > nums[mid])\\n                return binarySearch(mid + 1, right, nums, target);\\n        }\\n     return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794162,
                "title": "cpp-solution-binary-search-explained",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint search(vector<int>& nums, int target)\\n\\t\\t{\\n\\t\\t\\tint start=0;\\n\\t\\t\\tint end=nums.size();\\n\\t\\t\\tint mid=0;\\n\\t\\t\\tif(nums[0]==target)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\twhile(start!=end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmid=(start+end)/2;\\n\\t\\t\\t\\tif(nums[mid]==target)\\n\\t\\t\\t\\t\\treturn mid;\\n\\t\\t\\t\\tif(target>nums[mid])\\n\\t\\t\\t\\t\\tstart=mid+1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tend=mid;\\n\\t\\t\\t}\\n\\t\\t\\treturn -1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint search(vector<int>& nums, int target)\\n\\t\\t{\\n\\t\\t\\tint start=0;\\n\\t\\t\\tint end=nums.size();\\n\\t\\t\\tint mid=0;\\n\\t\\t\\tif(nums[0]==target)\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\twhile(start!=end)\\n\\t\\t\\t{\\n\\t\\t\\t\\tmid=(start+end)/2;\\n\\t\\t\\t\\tif(nums[mid]==target)\\n\\t\\t\\t\\t\\treturn mid;\\n\\t\\t\\t\\tif(target>nums[mid])\\n\\t\\t\\t\\t\\tstart=mid+1;\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\tend=mid;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2712885,
                "title": "c-simple-lower-bound-concept",
                "content": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n        int ind = lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        if(ind==nums.size())\\n            return -1;\\n        return nums[ind]==target ? ind:-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n        int ind = lower_bound(nums.begin(),nums.end(),target)-nums.begin();\\n        if(ind==nums.size())\\n            return -1;\\n        return nums[ind]==target ? ind:-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573506,
                "title": "fast-javascript-solution-67-ms",
                "content": "### Solution\\n\\n```js\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\n\\nconst calcMid = (l, r) => {\\n    return l + Math.floor((r - l) / 2);\\n}\\n\\nvar search = function(nums, target) {\\n    let left = 0;\\n    let right = nums.length - 1;\\n    \\n    while (right >= left) {\\n        const mid = calcMid(left, right);\\n   \\n        if (nums[mid] == target) {\\n            return mid;  \\n        } else if (nums[mid] > target) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```\\n\\n### LeetCode Output\\nRuntime: **67 ms**, faster than **94.38%** of JavaScript online submissions for Binary Search.\\nMemory Usage: **45.3 MB**, less than **21.03%** of JavaScript online submissions for Binary Search.",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\n\\nconst calcMid = (l, r) => {\\n    return l + Math.floor((r - l) / 2);\\n}\\n\\nvar search = function(nums, target) {\\n    let left = 0;\\n    let right = nums.length - 1;\\n    \\n    while (right >= left) {\\n        const mid = calcMid(left, right);\\n   \\n        if (nums[mid] == target) {\\n            return mid;  \\n        } else if (nums[mid] > target) {\\n            right = mid - 1;\\n        } else {\\n            left = mid + 1;\\n        }\\n    }\\n    \\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2515422,
                "title": "java-binary-search-two-pointer",
                "content": "## Java || Binary Search O(logn) || Easy to Understand\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int r = nums.length - 1;\\n        int l = 0;\\n        while(l <= r){\\n            int m = l + (r - l)/2;\\n            if(nums[m]==target){\\n                return m;\\n            }\\n            else if(nums[m]>target){\\n                r = m - 1;\\n            }else{\\n                l = m + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int r = nums.length - 1;\\n        int l = 0;\\n        while(l <= r){\\n            int m = l + (r - l)/2;\\n            if(nums[m]==target){\\n                return m;\\n            }\\n            else if(nums[m]>target){\\n                r = m - 1;\\n            }else{\\n                l = m + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2439192,
                "title": "multiple-java-solutions-fastest-optimal-solution-faster-than-100",
                "content": "**1st Solution Using Normal Binary Search**\\n\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length-1;\\n        while (start <= end) {\\n            int mid = start + (end - start)/2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[mid] < target) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**2nd Solution Using Recursion**\\n\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length-1;\\n        int mid = start + (end - start)/2;\\n        return searchtwo(nums, target, mid, start, end);\\n    }\\n    \\n    public int searchtwo(int[] nums, int target, int mid, int start, int end) {\\n        while (start <= end) {\\n            if (nums[mid] == target) return mid;\\n            if (nums[mid] > target) {\\n                end = mid - 1;\\n                mid = (start + end)/2;\\n                return searchtwo(nums, target, mid, start, end);\\n            }\\n            else {\\n                start = mid + 1;\\n                mid = (start + end)/2;\\n                return searchtwo(nums, target, mid, start, end);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```\\n\\n**Please Upvote if you like my approach.**",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length-1;\\n        while (start <= end) {\\n            int mid = start + (end - start)/2;\\n            if (nums[mid] == target) return mid;\\n            if (nums[mid] < target) start = mid + 1;\\n            else end = mid - 1;\\n        }\\n        return -1;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start = 0, end = nums.length-1;\\n        int mid = start + (end - start)/2;\\n        return searchtwo(nums, target, mid, start, end);\\n    }\\n    \\n    public int searchtwo(int[] nums, int target, int mid, int start, int end) {\\n        while (start <= end) {\\n            if (nums[mid] == target) return mid;\\n            if (nums[mid] > target) {\\n                end = mid - 1;\\n                mid = (start + end)/2;\\n                return searchtwo(nums, target, mid, start, end);\\n            }\\n            else {\\n                start = mid + 1;\\n                mid = (start + end)/2;\\n                return searchtwo(nums, target, mid, start, end);\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2397164,
                "title": "java-0ms-faster-than-100",
                "content": "```\\npublic int search(int[] nums, int target) \\n    {\\n        int start = 0;\\n        int end = nums.length-1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end-start) / 2; // This statement is to prevent Integer overflow in case of larger values. Otherwise mid =(start+end)/2 is also correct.\\n            \\n            if(nums[mid] == target)\\n                    return mid;\\n            \\n            if(nums[mid] < target)\\n                start = mid + 1;\\n            \\n            else \\n                end = mid-1;\\n        }\\n        \\n        return -1;\\n    }\\n\\t```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\npublic int search(int[] nums, int target) \\n    {\\n        int start = 0;\\n        int end = nums.length-1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = start + (end-start) / 2; // This statement is to prevent Integer overflow in case of larger values. Otherwise mid =(start+end)/2 is also correct.\\n            \\n            if(nums[mid] == target)\\n                    return mid;\\n            \\n            if(nums[mid] < target)\\n                start = mid + 1;\\n            \\n            else \\n                end = mid-1;\\n        }\\n        \\n        return -1;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2381394,
                "title": "c-0ms-fast-than-100-only-see-if-you-re-good-at-cpp",
                "content": "![image](https://assets.leetcode.com/users/images/6b4c76d1-5178-4bbb-9e3c-65faa9dbaac9_1659676977.5693378.png)\\n\\n```\\nint init = [] {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    ofstream out(\"user.out\");\\n    cout.rdbuf(out.rdbuf());\\n    for (string s; getline(cin, s); cout << \\'\\\\n\\') {\\n        string t;\\n        getline(cin, t);\\n        int tar = stoi(t);\\n        for (int i = 0, _i = 1, _n = s.length(); _i < _n; ++i, ++_i) {\\n            bool _neg = false;\\n            if (s[_i] == \\'-\\') ++_i, _neg = true;\\n            int v = s[_i++] & 15;\\n            while ((s[_i] & 15) < 10) v = v * 10 + (s[_i++] & 15);\\n            if (_neg) v = -v;\\n            if (v == tar) {\\n                cout << i;\\n                goto next;\\n            }\\n            if (v > tar) break;\\n        }\\n        cout << -1;\\n        next:;\\n    }\\n    exit(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>, int) { return 0; }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint init = [] {\\n    ios_base::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    ofstream out(\"user.out\");\\n    cout.rdbuf(out.rdbuf());\\n    for (string s; getline(cin, s); cout << \\'\\\\n\\') {\\n        string t;\\n        getline(cin, t);\\n        int tar = stoi(t);\\n        for (int i = 0, _i = 1, _n = s.length(); _i < _n; ++i, ++_i) {\\n            bool _neg = false;\\n            if (s[_i] == \\'-\\') ++_i, _neg = true;\\n            int v = s[_i++] & 15;\\n            while ((s[_i] & 15) < 10) v = v * 10 + (s[_i++] & 15);\\n            if (_neg) v = -v;\\n            if (v == tar) {\\n                cout << i;\\n                goto next;\\n            }\\n            if (v > tar) break;\\n        }\\n        cout << -1;\\n        next:;\\n    }\\n    exit(0);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int search(vector<int>, int) { return 0; }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2365767,
                "title": "java-one-liner-super-simple-explained",
                "content": "Java code:\\n\\n```\\n    public int search(int[] nums, int target) {\\n        return Arrays.stream(nums).boxed().collect(Collectors.toList()).indexOf(target);\\n\\t\\t// use the indexOf() function to get the index of target or -1\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\n    public int search(int[] nums, int target) {\\n        return Arrays.stream(nums).boxed().collect(Collectors.toList()).indexOf(target);\\n\\t\\t// use the indexOf() function to get the index of target or -1\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2324592,
                "title": "python-explained-time-complexity-explained-o-logn-time-o-1-space",
                "content": "we get our current element to be the middle of the array we are currently working with thus between l and r.\\nmid = (l+r)//2\\n\\nBinary search is done by checking if out target is lower or heigher than our current element. If lower than current, it must mean our target is either in the left of current ( since array is sorted in ascending ) or does not exist.\\nIf heigher than current, it must mean our target is either in the right of current ( since array is sorted in ascending ) or does not exist.\\nWe run the loop while l<=r, if the loop stops it means the target does not exist.\\n\\n```\\n        l, r = 0 , len(nums)-1\\n        while l<=r:\\n            mid = (l+r)//2\\n            if nums[mid] == target: return mid\\n            if nums[mid] < target: l= mid+1\\n            else: r = mid -1\\n        \\n        return -1\\n```\\n\\n\\nTime complexity -  O(logn)\\nSpace complexity - O(1) since we only used constant extra space\\n\\nTo get the time complexity let\\'s use the recurrence relation \\n\\nT(n) = T(n/2) + 1    since in each iteration we half the size of the array we are working with \\n\\nT(n) = T(n/4) + 1 + 1\\nT(n) = T(n/k^2) + k\\n\\nwe stop when k^2 = n or at T(1)\\n\\nT(n) = T(1) + k\\nT(n) = k\\n\\nsince k^2 = n\\nk = log(n)\\n\\nthus T(n) = logn\\n\\nThis is a simplified version of the mathametics for easy understanding\\n\\nNOTE :  write mid = l + (r-l)//2 to avoid integer overflow in some languages (like c++)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Iterator"
                ],
                "code": "```\\n        l, r = 0 , len(nums)-1\\n        while l<=r:\\n            mid = (l+r)//2\\n            if nums[mid] == target: return mid\\n            if nums[mid] < target: l= mid+1\\n            else: r = mid -1\\n        \\n        return -1\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1884394,
                "title": "simple-2-line-solution-c",
                "content": "`lb` is the iterator to lower_bound of `target`, i.e., the smallest possible value such that `lb` >= `target`\\n\\n`lb == end(nums) || *lb != target` indicates `target` is not found\\n\\n`lb-begin(nums)` is the position of `target` if found\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        auto lb = lower_bound(begin(nums), end(nums), target);\\n        return ((lb == end(nums) || *lb != target) ? -1 : (lb-begin(nums)));\\n    }\\n};\\n```\\n\\nTime complexity : `O(log n)`",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        auto lb = lower_bound(begin(nums), end(nums), target);\\n        return ((lb == end(nums) || *lb != target) ? -1 : (lb-begin(nums)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1849941,
                "title": "javascript-solution",
                "content": "Runtime: 60 ms, faster than 97.87% of JavaScript online submissions for Binary Search.\\nMemory Usage: 45.2 MB, less than 41.64% of JavaScript online submissions for Binary Search.\\n```\\nvar search = function(nums, target) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    while (start <= end){\\n        let mid = Math.floor((start + end) / 2);\\n        if (nums[mid] === target) return mid;\\n        if (nums[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar search = function(nums, target) {\\n    let start = 0;\\n    let end = nums.length - 1;\\n    while (start <= end){\\n        let mid = Math.floor((start + end) / 2);\\n        if (nums[mid] === target) return mid;\\n        if (nums[mid] < target) {\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n    return -1;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1717584,
                "title": "binary-search-code",
                "content": "``` class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int e = nums.size() - 1 ; \\n        int mid = s + (e-s)/2 ;\\n        int ans = -1;\\n        while(s<=e)\\n        {\\n            if ( nums[mid] == target)\\n            {\\n                ans = mid;\\n                break;\\n            }\\n            else if ( nums[mid] < target)\\n            {\\n                s = mid +1 ;\\n            }\\n            else \\n            {\\n                e = mid -1;\\n            }\\n            mid =  s + (e-s)/2;\\n            \\n        }\\n      return ans;  \\n    \\n    }\\n};",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s = 0;\\n        int e = nums.size() - 1 ; \\n        int mid = s + (e-s)/2 ;\\n        int ans = -1;\\n        while(s<=e)\\n        {\\n            if ( nums[mid] == target)\\n            {\\n                ans = mid;\\n                break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1594860,
                "title": "simple-rust-solution",
                "content": "```rust\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut min: i32 = 0;\\n        let mut max = (nums.len() - 1) as i32; // use i32 to be able to go under zero\\n\\n        while min <= max {\\n            let mid = (min + max) / 2;\\n            match nums[mid as usize].cmp(&target) {\\n                Ordering::Equal => return mid,\\n                Ordering::Less => min = mid + 1,\\n                Ordering::Greater => max = mid - 1,\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp::Ordering;\\n\\nimpl Solution {\\n    pub fn search(nums: Vec<i32>, target: i32) -> i32 {\\n        let mut min: i32 = 0;\\n        let mut max = (nums.len() - 1) as i32; // use i32 to be able to go under zero\\n\\n        while min <= max {\\n            let mid = (min + max) / 2;\\n            match nums[mid as usize].cmp(&target) {\\n                Ordering::Equal => return mid,\\n                Ordering::Less => min = mid + 1,\\n                Ordering::Greater => max = mid - 1,\\n            }\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1539436,
                "title": "python-98-faster-o-logn-solution",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], key: int) -> int:\\n        \\n        i, j = 0, len(nums)-1\\n        \\n        while i <= j:\\n            m = (i + j) // 2\\n            mid = nums[m]\\n            if mid > key : j = m - 1\\n            elif mid < key : i = m + 1\\n            else : return m\\n        else:\\n            return -1\\n```\\n![image](https://assets.leetcode.com/users/images/909838c9-a6de-45ac-9047-df777c9008e3_1635135603.1870964.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], key: int) -> int:\\n        \\n        i, j = 0, len(nums)-1\\n        \\n        while i <= j:\\n            m = (i + j) // 2\\n            mid = nums[m]\\n            if mid > key : j = m - 1\\n            elif mid < key : i = m + 1\\n            else : return m\\n        else:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1523061,
                "title": "binary-search-using-recursion-java",
                "content": "```\\npublic int search(int[] nums, int target) {\\n        return binarySearch(nums, target, 0, nums.length-1);\\n    }\\n    \\n    int  binarySearch(int[] nums, int target, int left, int right) {\\n        if(left> right) {\\n            return -1;\\n        }\\n        int mid = (left + right)/2;\\n        if(target == nums[mid]) {\\n            return mid;\\n        }\\n        if(target > nums[mid]) {\\n            return   binarySearch(nums, target, mid+1, right);\\n        }\\n        \\n        return binarySearch(nums, target, left, mid-1);\\n    }\\n\\'\\'\\'\\n```",
                "solutionTags": [],
                "code": "```\\npublic int search(int[] nums, int target) {\\n        return binarySearch(nums, target, 0, nums.length-1);\\n    }\\n    \\n    int  binarySearch(int[] nums, int target, int left, int right) {\\n        if(left> right) {\\n            return -1;\\n        }\\n        int mid = (left + right)/2;\\n        if(target == nums[mid]) {\\n            return mid;\\n        }\\n        if(target > nums[mid]) {\\n            return   binarySearch(nums, target, mid+1, right);\\n        }\\n        \\n        return binarySearch(nums, target, left, mid-1);\\n    }\\n\\'\\'\\'\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1495627,
                "title": "faster-than-100-binary-search",
                "content": "#     Runtime: 204 ms, faster than 100.00% of Python3 online submissions for Binary Search.\\n# Memory Usage: 15.7 MB, less than 28.00% of Python3 online submissions for Binary Search.\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = (start + end) // 2\\n            if nums[mid] < target:\\n                start = mid + 1\\n            elif nums[mid] > target:\\n                end = mid - 1\\n            else:\\n                return mid\\n        return -1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        start = 0\\n        end = len(nums) - 1\\n        while start <= end:\\n            mid = (start + end) // 2\\n            if nums[mid] < target:\\n                start = mid + 1\\n            elif nums[mid] > target:\\n                end = mid - 1\\n            else:\\n                return mid\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280562,
                "title": "easy-python-solution-99-23",
                "content": "Runtime: 220 ms, faster than 99.23% of Python3 online submissions for Binary Search.\\nMemory Usage: 15.5 MB, less than 68.54% of Python3 online submissions for Binary Search.\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l=0\\n        r=len(nums)\\n        while(l<r):\\n            m=l+(r-l)//2\\n            # print(m)\\n            if(nums[m]==target):\\n                return m\\n            elif(nums[m]<target):\\n                l=m+1\\n            else:\\n                r=m\\n        return -1",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 220 ms, faster than 99.23% of Python3 online submissions for Binary Search.\\nMemory Usage: 15.5 MB, less than 68.54% of Python3 online submissions for Binary Search.\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l=0\\n        r=len(nums)\\n        while(l<r):\\n            m=l+(r-l)//2\\n            # print(m)\\n            if(nums[m]==target):\\n                return m\\n            elif(nums[m]<target):\\n                l=m+1\\n            else:\\n                r=m\\n        return -1",
                "codeTag": "Java"
            },
            {
                "id": 1273477,
                "title": "c-simple-and-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target)\\n    {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = (start + end) / 2;\\n            if(target == nums[mid])\\n            {\\n                return mid;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                end = mid - 1;\\n            }\\n            else\\n            {\\n                start = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t able to understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target)\\n    {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        \\n        while(start <= end)\\n        {\\n            int mid = (start + end) / 2;\\n            if(target == nums[mid])\\n            {\\n                return mid;\\n            }\\n            else if(target < nums[mid])\\n            {\\n                end = mid - 1;\\n            }\\n            else\\n            {\\n                start = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138062,
                "title": "simple-recursive-python-solution",
                "content": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        def bs(nums, l, r, target):\\n            mid = ((r - l + 1) // 2) + l\\n            if l > r:\\n                return -1\\n            elif nums[mid] == target:\\n                return mid\\n            elif l > r:\\n                return -1\\n            elif nums[mid] < target:\\n                return bs(nums, mid+1, r, target)\\n            else:\\n                return bs(nums, l, mid-1, target)\\n        return bs(nums, 0, len(nums)-1, target)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        def bs(nums, l, r, target):\\n            mid = ((r - l + 1) // 2) + l\\n            if l > r:\\n                return -1\\n            elif nums[mid] == target:\\n                return mid\\n            elif l > r:\\n                return -1\\n            elif nums[mid] < target:\\n                return bs(nums, mid+1, r, target)\\n            else:\\n                return bs(nums, l, mid-1, target)\\n        return bs(nums, 0, len(nums)-1, target)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 817160,
                "title": "swift-solution",
                "content": "I am not a Swift expert, learning the language by doing code challenges.\\n\\n```\\nclass Solution {\\n    func search(_ nums: [Int], _ target: Int) -> Int {\\n        \\n        var left = 0, right = nums.count-1\\n        \\n        while left <= right{\\n            let pos = left + (right-left) / 2\\n            if nums[pos] == target{\\n                return pos\\n            }\\n            \\n            if target < nums[pos]\\n            {\\n                right = pos - 1\\n            }\\n            else\\n            {\\n                left = pos + 1\\n            }\\n        }\\n\\n        // We didn\\'t find it\\n        return -1\\n\\t\\t}\\n}\\n```",
                "solutionTags": [
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    func search(_ nums: [Int], _ target: Int) -> Int {\\n        \\n        var left = 0, right = nums.count-1\\n        \\n        while left <= right{\\n            let pos = left + (right-left) / 2\\n            if nums[pos] == target{\\n                return pos\\n            }\\n            \\n            if target < nums[pos]\\n            {\\n                right = pos - 1\\n            }\\n            else\\n            {\\n                left = pos + 1\\n            }\\n        }\\n\\n        // We didn\\'t find it\\n        return -1\\n\\t\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 495026,
                "title": "python-js-go-c-log-n-sol-by-divide-and-conquer-with-explanation",
                "content": "log( n ) sol. by divide-and-conquer.\\n\\n[\\u4E2D\\u6587\\u89E3\\u984C \\u89E3\\u6790\\u6587\\u7AE0](https://vocus.cc/article/650d505ffd8978000156c148)\\n\\n\\nReference:\\n[Wiki: Classical Binary Search on sorted array](https://en.wikipedia.org/wiki/Binary_search_algorithm)\\n\\n[Wiki: Divide and conquer algorithm](https://en.wikipedia.org/wiki/Divide-and-conquer_algorithm)\\n\\n[Video: Tutorial of binary search](https://bit.ly/2OfMNDc)\\n\\nRelative advanced leetcode challenge:\\n[Leetcode #33: Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)\\n\\n---\\n\\nMethod_#1 Iterative implementation\\nPython:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        left, right = 0, len(nums)-1\\n\\t\\t\\n        while left <= right:\\n            \\n\\t\\t\\t# update index of mid point \\n            mid = left + (right-left)//2\\n            \\n            if nums[mid] == target:\\n                \\n                # base case:\\n                # hit\\n                return mid\\n            \\n            if target > nums[mid]:\\n                \\n                # search target in right half\\n                left = mid + 1\\n            \\n            else:\\n                \\n                # search target in left half\\n                right = mid - 1\\n                \\n        # base case:\\n        # miss\\n        # target does not exist in input array\\n        return -1\\n```\\n\\n---\\n\\nMethod_#2 Recursive implementation\\nPython:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        def binary_search(nums, left, right, target ):\\n            \\n            if left > right:\\n                # base case:\\n                # miss\\n                # target does not exist in input array\\n                return -1\\n            \\n\\t\\t\\t# update index of mid point\\n            mid = left + (right-left)//2\\n\\n            if nums[mid] == target:\\n\\n                # base case:\\n                # hit\\n                return mid\\n\\n            if target > nums[mid]:\\n                \\n                # search target in right half\\n                return binary_search(nums, mid+1, right, target)\\n\\n            else:\\n\\n                # search target in left half\\n                return binary_search(nums, left, mid-1, target)\\n        \\n        \\n        \\n        return binary_search(nums, 0, len(nums)-1, target)\\n```\\n\\n---\\n\\n**Implementation** in Go\\n\\nIterative:\\n\\n```\\nfunc search(nums []int, target int) int {\\n \\n    // binary search with two-pointers\\n    left, right := 0, len(nums)-1\\n    \\n    // binary search core\\n    for left <= right{\\n        \\n        mid := left + (right - left)/2\\n        mid_element := nums[mid] \\n        \\n        if target == mid_element{\\n            \\n            // hit\\n            return mid\\n        \\n        }else if target > mid_element{\\n            \\n            // target is on the right hand side of mid element\\n            left = mid+1\\n        } else{\\n            \\n            // target is on the left hand side of mid element\\n            right = mid-1\\n        }\\n        \\n    }\\n    \\n    // target doesn\\'t exist in input array\\n    return -1\\n}\\n//end of function search\\n```\\n\\n---\\n\\nRecursive\\n\\n```\\nfunc biSearch(nums *[]int, left, right, target int) int{\\n    \\n    // base case aka stop condition\\n    if left > right{\\n        return -1\\n    }\\n    \\n    // general case:\\n    \\n    mid := left + (right - left)/2\\n    mid_element := (*nums)[mid] \\n\\n    if target == mid_element{\\n\\n        // hit\\n        return mid\\n\\n    } else if target > mid_element{\\n\\n        // target is on the right hand side of mid element\\n        return biSearch(nums, mid+1,right, target)\\n        \\n    } else{\\n\\n        // target is on the left hand side of mid element\\n        return biSearch(nums, left, mid-1, target)\\n        \\n    }\\n}\\n//End of function biSearch\\n\\n\\nfunc search(nums []int, target int) int {\\n \\n    // binary search with two-pointers\\n    left, right := 0, len(nums)-1\\n    \\n    // binary search core\\n    return biSearch(&nums, left, right, target)\\n        \\n}\\n//end of function search\\n\\n```\\n\\n---\\n\\nMethod_#1 Iterative implementation\\nJavascript:\\n\\n```\\nvar search = function(nums, target) {\\n    \\n    let [left, right] = [0, nums.length-1];\\n    \\n    while( left <= right ){\\n        \\n        // update index of mid point\\n        // Here, we use right shift to avoid floating number division\\n        let mid = ( left + right ) >> 1;\\n        \\n        if( target == nums[mid] ){\\n            return mid;\\n            \\n        }else if( target > nums[mid]) {\\n            left = mid+1;\\n        }else{\\n            right = mid-1;\\n        }\\n    } \\n    return -1;\\n};\\n```\\n\\n---\\n\\nMethod_#2 Recursive implementation\\nJavascript:\\n\\n\\n```\\nvar search = function(nums, target) {\\n    \\n    var finder = function(left, right){\\n        \\n        // Base case aka stop condition\\n        if( left > right ){\\n            return -1;\\n        }        \\n        \\n        let mid = (left + right) >> 1;\\n        \\n        // General cases\\n        if( nums[mid] == target ){\\n            return mid;\\n            \\n        }else if( nums[mid] > target){\\n            return finder(left, mid-1);\\n            \\n        }else{\\n            return finder(mid+1, right);\\n        }\\n    }\\n    // ----------------------------\\n    \\n    return finder(0, nums.length-1);\\n    \\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        \\n        int left=0, right=nums.size()-1;\\n        \\n        while( left <= right ){\\n            \\n            int mid = (left + right) >> 1;\\n            \\n            if( nums[mid] == target ){\\n                \\n                // hit\\n                return mid;\\n            }else if( nums[mid] > target ){\\n                \\n                // search target on the lefthand side next time\\n                right = mid-1;\\n                \\n            }else{\\n                \\n                // search target on the righthand side next time\\n                left = mid+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        left, right = 0, len(nums)-1\\n\\t\\t\\n        while left <= right:\\n            \\n\\t\\t\\t# update index of mid point \\n            mid = left + (right-left)//2\\n            \\n            if nums[mid] == target:\\n                \\n                # base case:\\n                # hit\\n                return mid\\n            \\n            if target > nums[mid]:\\n                \\n                # search target in right half\\n                left = mid + 1\\n            \\n            else:\\n                \\n                # search target in left half\\n                right = mid - 1\\n                \\n        # base case:\\n        # miss\\n        # target does not exist in input array\\n        return -1\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        \\n        def binary_search(nums, left, right, target ):\\n            \\n            if left > right:\\n                # base case:\\n                # miss\\n                # target does not exist in input array\\n                return -1\\n            \\n\\t\\t\\t# update index of mid point\\n            mid = left + (right-left)//2\\n\\n            if nums[mid] == target:\\n\\n                # base case:\\n                # hit\\n                return mid\\n\\n            if target > nums[mid]:\\n                \\n                # search target in right half\\n                return binary_search(nums, mid+1, right, target)\\n\\n            else:\\n\\n                # search target in left half\\n                return binary_search(nums, left, mid-1, target)\\n        \\n        \\n        \\n        return binary_search(nums, 0, len(nums)-1, target)\\n```\n```\\nfunc search(nums []int, target int) int {\\n \\n    // binary search with two-pointers\\n    left, right := 0, len(nums)-1\\n    \\n    // binary search core\\n    for left <= right{\\n        \\n        mid := left + (right - left)/2\\n        mid_element := nums[mid] \\n        \\n        if target == mid_element{\\n            \\n            // hit\\n            return mid\\n        \\n        }else if target > mid_element{\\n            \\n            // target is on the right hand side of mid element\\n            left = mid+1\\n        } else{\\n            \\n            // target is on the left hand side of mid element\\n            right = mid-1\\n        }\\n        \\n    }\\n    \\n    // target doesn\\'t exist in input array\\n    return -1\\n}\\n//end of function search\\n```\n```\\nfunc biSearch(nums *[]int, left, right, target int) int{\\n    \\n    // base case aka stop condition\\n    if left > right{\\n        return -1\\n    }\\n    \\n    // general case:\\n    \\n    mid := left + (right - left)/2\\n    mid_element := (*nums)[mid] \\n\\n    if target == mid_element{\\n\\n        // hit\\n        return mid\\n\\n    } else if target > mid_element{\\n\\n        // target is on the right hand side of mid element\\n        return biSearch(nums, mid+1,right, target)\\n        \\n    } else{\\n\\n        // target is on the left hand side of mid element\\n        return biSearch(nums, left, mid-1, target)\\n        \\n    }\\n}\\n//End of function biSearch\\n\\n\\nfunc search(nums []int, target int) int {\\n \\n    // binary search with two-pointers\\n    left, right := 0, len(nums)-1\\n    \\n    // binary search core\\n    return biSearch(&nums, left, right, target)\\n        \\n}\\n//end of function search\\n\\n```\n```\\nvar search = function(nums, target) {\\n    \\n    let [left, right] = [0, nums.length-1];\\n    \\n    while( left <= right ){\\n        \\n        // update index of mid point\\n        // Here, we use right shift to avoid floating number division\\n        let mid = ( left + right ) >> 1;\\n        \\n        if( target == nums[mid] ){\\n            return mid;\\n            \\n        }else if( target > nums[mid]) {\\n            left = mid+1;\\n        }else{\\n            right = mid-1;\\n        }\\n    } \\n    return -1;\\n};\\n```\n```\\nvar search = function(nums, target) {\\n    \\n    var finder = function(left, right){\\n        \\n        // Base case aka stop condition\\n        if( left > right ){\\n            return -1;\\n        }        \\n        \\n        let mid = (left + right) >> 1;\\n        \\n        // General cases\\n        if( nums[mid] == target ){\\n            return mid;\\n            \\n        }else if( nums[mid] > target){\\n            return finder(left, mid-1);\\n            \\n        }else{\\n            return finder(mid+1, right);\\n        }\\n    }\\n    // ----------------------------\\n    \\n    return finder(0, nums.length-1);\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        \\n        int left=0, right=nums.size()-1;\\n        \\n        while( left <= right ){\\n            \\n            int mid = (left + right) >> 1;\\n            \\n            if( nums[mid] == target ){\\n                \\n                // hit\\n                return mid;\\n            }else if( nums[mid] > target ){\\n                \\n                // search target on the lefthand side next time\\n                right = mid-1;\\n                \\n            }else{\\n                \\n                // search target on the righthand side next time\\n                left = mid+1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397067,
                "title": "recursive-and-iterative-solutions-with-explanations",
                "content": "## Recursive Solution\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar search = function(nums, target, low = 0, high = nums.length - 1) {\\n  if (low > high) {\\n    /* base condition when recursion terminates */\\n    return -1;\\n  }\\n  /*\\n    calculating mid using the technique below\\n    is a solution for integer overflow when working\\n    with large arrays (1 billion elements).\\n  */\\n  let mid = Math.floor(low + (high - low) / 2);\\n  if (target === nums[mid]) {\\n    /* exact match, return the index */\\n    return mid;\\n  } else if (target < nums[mid]) {\\n    /*\\n      when true, we can disregard the element at nums[mid] and the \\n      elements to the right (greater).\\n    */\\n    return search(nums, target, low, mid - 1);\\n  } else {\\n    /*\\n      If the element was not at nums[mid] and the target is less than nums[mid],\\n      we \\'shrink\\' the left half by one.\\n    */\\n    return search(nums, target, mid + 1, high);\\n  }\\n};\\n```\\n\\n## Iterative Solution\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n  let low = 0;\\n  let high = nums.length - 1;\\n  /*\\n    Instead of using recursion to iterate, we use a while loop, bounded\\n    by low less than or equal to high.\\n  */\\n  while (low <= high) {\\n    let mid = Math.floor(low + (high - low) / 2);\\n    if (target == nums[mid]) {\\n      return mid;\\n    } else if (target < nums[mid]) {\\n      /* Move \\'inward\\' from the high element */\\n      high = mid - 1;\\n    } else {\\n      low = mid + 1; /* Move inward from the low element */\\n    }\\n  }\\n  return -1; /* Element not found */\\n};\\n```\\n\\nPlease comment with comments/criticism/improvements ;) . Thanks for reading!",
                "solutionTags": [
                    "JavaScript",
                    "Binary Tree"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @param {number} low\\n * @param {number} high\\n * @return {number}\\n */\\nvar search = function(nums, target, low = 0, high = nums.length - 1) {\\n  if (low > high) {\\n    /* base condition when recursion terminates */\\n    return -1;\\n  }\\n  /*\\n    calculating mid using the technique below\\n    is a solution for integer overflow when working\\n    with large arrays (1 billion elements).\\n  */\\n  let mid = Math.floor(low + (high - low) / 2);\\n  if (target === nums[mid]) {\\n    /* exact match, return the index */\\n    return mid;\\n  } else if (target < nums[mid]) {\\n    /*\\n      when true, we can disregard the element at nums[mid] and the \\n      elements to the right (greater).\\n    */\\n    return search(nums, target, low, mid - 1);\\n  } else {\\n    /*\\n      If the element was not at nums[mid] and the target is less than nums[mid],\\n      we \\'shrink\\' the left half by one.\\n    */\\n    return search(nums, target, mid + 1, high);\\n  }\\n};\\n```\n```javascript\\n/**\\n * @param {number[]} nums\\n * @param {number} target\\n * @return {number}\\n */\\nvar search = function(nums, target) {\\n  let low = 0;\\n  let high = nums.length - 1;\\n  /*\\n    Instead of using recursion to iterate, we use a while loop, bounded\\n    by low less than or equal to high.\\n  */\\n  while (low <= high) {\\n    let mid = Math.floor(low + (high - low) / 2);\\n    if (target == nums[mid]) {\\n      return mid;\\n    } else if (target < nums[mid]) {\\n      /* Move \\'inward\\' from the high element */\\n      high = mid - 1;\\n    } else {\\n      low = mid + 1; /* Move inward from the low element */\\n    }\\n  }\\n  return -1; /* Element not found */\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 393819,
                "title": "golang-o-n",
                "content": "```\\n\\nfunc search(nums []int, target int) int {\\n    start := 0\\n    end := len(nums) - 1\\n    \\n    for start <= end {\\n        mid := (end + start) >> 1\\n        if nums[mid] == target {\\n            return mid\\n        } else if nums[mid] < target {\\n            start = mid + 1\\n        } else {\\n            end = mid - 1\\n        }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc search(nums []int, target int) int {\\n    start := 0\\n    end := len(nums) - 1\\n    \\n    for start <= end {\\n        mid := (end + start) >> 1\\n        if nums[mid] == target {\\n            return mid\\n        } else if nums[mid] < target {\\n            start = mid + 1\\n        } else {\\n            end = mid - 1\\n        }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 381093,
                "title": "go-golang-solution",
                "content": ">Runtime: 32 ms, faster than 94.53% of Go online submissions for Binary Search.\\nMemory Usage: 6.4 MB, less than 100.00% of Go online submissions for Binary Search.\\n\\n```go\\nfunc search(nums []int, target int) int {\\n    l, r := 0, len(nums) - 1\\n    for l <= r {\\n        m := l + (r - l) / 2\\n        if nums[m] == target {\\n            return m\\n        } else if nums[m] < target {\\n            l = m + 1\\n        } else {\\n            r = m - 1\\n        }\\n    }\\n    return -1\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc search(nums []int, target int) int {\\n    l, r := 0, len(nums) - 1\\n    for l <= r {\\n        m := l + (r - l) / 2\\n        if nums[m] == target {\\n            return m\\n        } else if nums[m] < target {\\n            l = m + 1\\n        } else {\\n            r = m - 1\\n        }\\n    }\\n    return -1\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 152204,
                "title": "javascript-solution",
                "content": "```js\\nfunction search(nums, target) {\\n  let l = 0;\\n  let r = nums.length-1;\\n  \\n  while (l <= r) {\\n    let m = l+r>>1;\\n    if (nums[m] <= target) {\\n      l = m+1;\\n    } else {\\n      r = m-1;\\n    }\\n  }\\n  \\n  return r >= 0 && nums[r] === target ? r : -1;\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction search(nums, target) {\\n  let l = 0;\\n  let r = nums.length-1;\\n  \\n  while (l <= r) {\\n    let m = l+r>>1;\\n    if (nums[m] <= target) {\\n      l = m+1;\\n    } else {\\n      r = m-1;\\n    }\\n  }\\n  \\n  return r >= 0 && nums[r] === target ? r : -1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4080421,
                "title": "easy-easy-java-solution-beats-100-00-runtime-beats-92-65-memory",
                "content": "\\n# Approach\\nJust create a fuction with all the cases and parameters.\\nThen call it repeatedly until we find the target.\\n\\n# Complexity\\n- Time complexity:\\n    log(n)\\n    n= size of array.\\n\\n\\n# Code\\n```\\nclass Solution {\\n        public static int binarySearch(int[] nums, int low, int high, int target){\\n        if (low > high) return -1;\\n\\n        \\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n        else if (target > nums[mid])\\n            return binarySearch(nums, mid + 1, high, target);\\n        return binarySearch(nums, low, mid - 1, target);\\n    }\\n     public int search(int[] nums, int target) {\\n         return binarySearch(nums, 0, nums.length - 1, target);\\n\\n     } \\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n        public static int binarySearch(int[] nums, int low, int high, int target){\\n        if (low > high) return -1;\\n\\n        \\n        int mid = (low + high) / 2;\\n        if (nums[mid] == target) return mid;\\n        else if (target > nums[mid])\\n            return binarySearch(nums, mid + 1, high, target);\\n        return binarySearch(nums, low, mid - 1, target);\\n    }\\n     public int search(int[] nums, int target) {\\n         return binarySearch(nums, 0, nums.length - 1, target);\\n\\n     } \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714777,
                "title": "super-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int ans=-1;int mid;\\n        int start=0;int end=nums.size()-1;\\n        while(start<=end){\\n           mid=start+(end-start )/2;\\n          if(nums[mid]==target){\\n            ans=mid;\\n            break;\\n          }\\n          else if(nums[mid]<target){\\n           start=mid+1;           \\n          }\\n          else end=mid-1;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int ans=-1;int mid;\\n        int start=0;int end=nums.size()-1;\\n        while(start<=end){\\n           mid=start+(end-start )/2;\\n          if(nums[mid]==target){\\n            ans=mid;\\n            break;\\n          }\\n          else if(nums[mid]<target){\\n           start=mid+1;           \\n          }\\n          else end=mid-1;\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3367534,
                "title": "java-clean-code-beats-100-o-log-n-time",
                "content": "# Complexity\\n- Time complexity: $$O(log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int search(int[] nums, int target) {\\n    var l = 0;\\n    var r = nums.length - 1;\\n\\n    while (l <= r) {\\n      var m = l + (r-l) / 2;\\n\\n      if (nums[m] < target) l = m+1;\\n      else if (nums[m] > target) r = m-1;\\n      else return m;\\n    }\\n    return -1;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n  public int search(int[] nums, int target) {\\n    var l = 0;\\n    var r = nums.length - 1;\\n\\n    while (l <= r) {\\n      var m = l + (r-l) / 2;\\n\\n      if (nums[m] < target) l = m+1;\\n      else if (nums[m] > target) r = m-1;\\n      else return m;\\n    }\\n    return -1;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364841,
                "title": "clean-code-with-full-explanation-recursive-approach",
                "content": "# Approach\\nThe approach used in this code is a recursive implementation of binary search. The function binarySearch takes four arguments: the array arr, the indices start and end that define the search space, and the target value k. The function first checks if the start index is greater than the end index, in which case the search space is empty and the function returns -1 to indicate that the target is not found. Otherwise, it computes the middle index mid by taking the average of start and end. If the middle element is equal to the target, the function returns the index of the middle element. If the target is less than the middle element, the function recursively calls itself with the lower half of the search space (from start to mid-1). If the target is greater than the middle element, the function recursively calls itself with the upper half of the search space (from mid+1 to end).\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n\\n- Space complexity:\\nO(log(n))\\n\\n# Code\\n```\\nclass Solution\\n{\\npublic:\\n  int binarySearch(vector<int> &arr, int start, int end, int k)\\n  {\\n    if (start > end)\\n    {\\n      return -1;\\n    }\\n    int mid = (start + end) / 2;\\n    if (k == arr[mid])\\n    {\\n      return mid;\\n    }\\n    else if (k < arr[mid])\\n    {\\n      return binarySearch(arr, start, mid - 1, k);\\n    }\\n    else\\n    {\\n      return binarySearch(arr, mid + 1, end, k);\\n    }\\n  }\\n  int search(vector<int> &nums, int target)\\n  {\\n    int ans = binarySearch(nums, 0, nums.size() - 1, target);\\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n  int binarySearch(vector<int> &arr, int start, int end, int k)\\n  {\\n    if (start > end)\\n    {\\n      return -1;\\n    }\\n    int mid = (start + end) / 2;\\n    if (k == arr[mid])\\n    {\\n      return mid;\\n    }\\n    else if (k < arr[mid])\\n    {\\n      return binarySearch(arr, start, mid - 1, k);\\n    }\\n    else\\n    {\\n      return binarySearch(arr, mid + 1, end, k);\\n    }\\n  }\\n  int search(vector<int> &nums, int target)\\n  {\\n    int ans = binarySearch(nums, 0, nums.size() - 1, target);\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364794,
                "title": "python-elegant-short-log-log-n-interpolation-search",
                "content": "# Classic binary search\\n\\n## Complexity\\n- Time complexity: $$O(\\\\log_2 {n})$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return mid\\n\\n            if nums[mid] > target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n\\n        return -1\\n\\n```\\n\\n# Interpolation search\\n\\n## Complexity\\n- Time complexity: $$O(\\\\log_2 \\\\log_2 {n})$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right and nums[left] <= target <= nums[right]:\\n            if nums[right] == nums[left]:\\n                m = left\\n            else:\\n                m = ((nums[right] - target) * left + (target - nums[left]) * right) // (nums[right] - nums[left])\\n\\n            if nums[m] > target:\\n                right = m - 1\\n            elif nums[m] < target:\\n                left = m + 1\\n            else:\\n                return m\\n\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right:\\n            mid = (left + right) // 2\\n\\n            if nums[mid] == target:\\n                return mid\\n\\n            if nums[mid] > target:\\n                right = mid - 1\\n            else:\\n                left = mid + 1\\n\\n        return -1\\n\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left, right = 0, len(nums) - 1\\n\\n        while left <= right and nums[left] <= target <= nums[right]:\\n            if nums[right] == nums[left]:\\n                m = left\\n            else:\\n                m = ((nums[right] - target) * left + (target - nums[left]) * right) // (nums[right] - nums[left])\\n\\n            if nums[m] > target:\\n                right = m - 1\\n            elif nums[m] < target:\\n                left = m + 1\\n            else:\\n                return m\\n\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364568,
                "title": "kindly-upvote-easy-cpp-solution-you-can-easily-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIts a very easy problem you can easy able to solve this problem by thins approach \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere we are using \\n\\nint mid = low + (high \\u2013 low)/2;\\nCompare x with the middle element.\\nIf x matches with the middle element, we return the mid index.\\nElse If x is greater than the mid element, then x can only lie in the right half subarray after the mid element. So we recur for the right half.\\nElse (x is smaller) recur for the left half.\\n# Complexity\\n- Time complexity: O(log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1). \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n KEEEP VOTE UP \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l= 0;\\n        int r= nums.size()-1;\\n        while(l<=r){\\n        int mid = l+(r-l)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                r=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n        } \\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l= 0;\\n        int r= nums.size()-1;\\n        while(l<=r){\\n        int mid = l+(r-l)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            else if(nums[mid]>target){\\n                r=mid-1;\\n            }\\n            else if(nums[mid]<target){\\n                l=mid+1;\\n            }\\n        } \\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364175,
                "title": "python3-solution",
                "content": "\\n# Code\\n```\\n\\nclass Solution:\\n    def search(self,nums:List[int],target:int)->int:\\n        n=len(nums)\\n        for i in range(n):\\n            if nums[i]==target:\\n                return i\\n\\n        return -1                                    \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\nclass Solution:\\n    def search(self,nums:List[int],target:int)->int:\\n        n=len(nums)\\n        for i in range(n):\\n            if nums[i]==target:\\n                return i\\n\\n        return -1                                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3112467,
                "title": "fastest-solution-in-java",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm uses a while loop to iterate over the array. It compares the target value with the middle element of the array. If they are equal, it returns the index of that element. If not, it checks if the target is greater or less than that element and then repeats this process on either half of the array (the left or right side).\\n\\n# Complexity\\n- Time complexity: $$O(logn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(nums[mid]==target) return mid;\\n            else if(nums[mid]>target) high=mid-1;\\n            else low = mid+1;\\n        }\\n        return -1;\\n    }\\n}\\n```\\n### Please Upvote me if you like the solution",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low = 0;\\n        int high = nums.length-1;\\n        while(low<=high){\\n            int mid = low + (high-low)/2;\\n            if(nums[mid]==target) return mid;\\n            else if(nums[mid]>target) high=mid-1;\\n            else low = mid+1;\\n        }\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3069742,
                "title": "one-line-hack-kotlin-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun search(nums: IntArray, target: Int): Int {\\n        return Math.max(-1,nums.binarySearch(target))\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun search(nums: IntArray, target: Int): Int {\\n        return Math.max(-1,nums.binarySearch(target))\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3064687,
                "title": "binary-search-without-binary-search-algorithm",
                "content": "# Intuition\\ni thought of doing binary search without binary search algorithm.\\n\\n# Approach\\nAt the same time i had looked into 2 value. which decreased my loop into half.it\\'s not a good practice though. Just tried to do something diffrent.\\n# Complexity\\n- Time complexity:\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        lenght = len(nums)\\n        i = 0\\n        j = lenght -1\\n        while i <= j:\\n            print(nums[i],\\'ii\\')\\n            if nums[i] == target:\\n                return i\\n            if nums[j] == target:\\n                return j\\n            i+=1\\n            j-=1\\n        return -1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        lenght = len(nums)\\n        i = 0\\n        j = lenght -1\\n        while i <= j:\\n            print(nums[i],\\'ii\\')\\n            if nums[i] == target:\\n                return i\\n            if nums[j] == target:\\n                return j\\n            i+=1\\n            j-=1\\n        return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884510,
                "title": "easy-c-solution-binary-search",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0; int high= nums.size()-1;\\n        while (low<=high){\\n            int mid= low+ (high-low)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            if (nums[mid] < target){\\n                low= mid+1;\\n            }\\n            else{\\n                high= mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n# Complexity\\n- Time complexity: O(logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low=0; int high= nums.size()-1;\\n        while (low<=high){\\n            int mid= low+ (high-low)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            if (nums[mid] < target){\\n                low= mid+1;\\n            }\\n            else{\\n                high= mid-1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882963,
                "title": "recursive-approach-of-binary-search-using-java",
                "content": "# Intuition\\nBinary Search Using Recursive Approach in Java\\n\\n# Approach\\nFirstly, we create two non static global variables \\'int[] arr\\' and \\'int key\\'\\n\\nIn the main function we initialise the global variables to the parameters from the \\'int search\\' function such that we don\\'t have to pass them again and again while calling binarySearch function\\n\\nCopy input parameter\\'s \\'int[] nums\\' array elements to the global variable \\'static int arr[]\\' and likewise we assign global variable \\'key\\' to input \\'target\\'\\n\\nWe recursively call function \\'binary_search()\\' having low and high as the parameters (initially 0 , length of array -1 )\\n\\nWe return the value of this funciton.\\n\\n- Space complexity:\\n    O(log N)\\n\\n# Code\\n```\\nclass Solution {\\n\\n    //global variables\\n\\n    int[] arr; \\n    int key;\\n\\n    int search(int[] nums, int target) \\n    {\\n        arr = nums //copying nums to global variable arr\\n        key = target; //copying target to global variable key\\n        return (binary_search(0,arr.length - 1));\\n    }\\n\\n    int binary_search(int low, int high)\\n    {\\n        int mid = low + (high - low) / 2;\\n\\n        if(arr[mid] == key)\\n            return mid;\\n\\n        if(low == high)\\n            return -1;\\n\\n        if(arr[mid] < key)\\n            return binary_search(mid+1 , high);\\n\\n        return binary_search(0,mid);\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\n\\n    //global variables\\n\\n    int[] arr; \\n    int key;\\n\\n    int search(int[] nums, int target) \\n    {\\n        arr = nums //copying nums to global variable arr\\n        key = target; //copying target to global variable key\\n        return (binary_search(0,arr.length - 1));\\n    }\\n\\n    int binary_search(int low, int high)\\n    {\\n        int mid = low + (high - low) / 2;\\n\\n        if(arr[mid] == key)\\n            return mid;\\n\\n        if(low == high)\\n            return -1;\\n\\n        if(arr[mid] < key)\\n            return binary_search(mid+1 , high);\\n\\n        return binary_search(0,mid);\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2881004,
                "title": "c-solution",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(log n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1;\\n        while(l <= r) {\\n            int mid = (l + r) / 2;\\n            if(nums[mid] == target) return mid;\\n            else if(nums[mid] < target) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l = 0, r = nums.size() - 1;\\n        while(l <= r) {\\n            int mid = (l + r) / 2;\\n            if(nums[mid] == target) return mid;\\n            else if(nums[mid] < target) l = mid + 1;\\n            else r = mid - 1;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2831996,
                "title": "solution-of-binary-search-in-c-o-log-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSolution of binary Search\\n\\n\\n# Approach\\n1. find the middle element of the sorted array..\\n2. Compare with given target (step 3 to step 5 ).\\n3. if middle element equal to target  then return index of middle element.\\n4. Otherwise if middle element greater than target then update right pointer is equal to mid-1.\\n5. else update left pointer is equal to mid+1;\\n6. if element not present then return -1.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n\\n$$O(log n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& arr, int k) {\\n        int n =arr.size();\\n         int l = 0;\\n        int r =n-1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            if(arr[mid] == k){\\n                return mid;\\n            }\\n            else if(arr[mid]> k){\\n                r = mid -1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& arr, int k) {\\n        int n =arr.size();\\n         int l = 0;\\n        int r =n-1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            if(arr[mid] == k){\\n                return mid;\\n            }\\n            else if(arr[mid]> k){\\n                r = mid -1;\\n            }\\n            else{\\n                l = mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745379,
                "title": "0ms-100-faster-java-solution",
                "content": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low=0;\\n        int high=nums.length-1;\\n      \\n        \\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target) return mid;\\n            else if(nums[mid]<target){\\n                low=mid+1;\\n            }\\n            else {\\n                high=mid-1;\\n            }\\n        }\\n        return-1;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int low=0;\\n        int high=nums.length-1;\\n      \\n        \\n        while(low<=high){\\n            int mid=(low+high)/2;\\n            if(nums[mid]==target) return mid;\\n            else if(nums[mid]<target){\\n                low=mid+1;\\n            }\\n            else {\\n                high=mid-1;\\n            }\\n        }\\n        return-1;\\n        \\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2734639,
                "title": "solved-in-0ms-time-using-recursion",
                "content": "**#Time taken**\\n**0ms**\\n\\n# Intuition\\nI have solved the problem using recursion. Checked for each element from backwards and if it\\'s equal to the target. If it\\'s not and n reaches 0 then return -1 because no such target exists.\\n\\n# Approach\\n1. Pass nums,nums.length and target as arguments\\n2. check if target == nums[n-1] return n-1;//index\\n3. else if target != nums[n-1] then call the function again passing n-1 as the parameter. Basically you are reducing the size of the array from backwards and comparing the last element with the target.\\n4. Base case would be when n reaches zero return -1.//target doesn\\'t exist\\n5. Otherwise nums[n-1] would give an error.\\n\\n# Complexity\\n- Time complexity:\\nO(n) as we are traversing the complete array\\n\\n- Space complexity:\\nO(1) as we are not using any extra space or data structure.\\n\\n# Code\\n```\\nclass Solution {\\n    //using recursion\\n    public int searchValue(int[] nums,int n,int target){\\n       if(n==0)\\n       return -1;\\n       if(nums[n-1] == target)\\n       return n-1;\\n       int ans = searchValue(nums,n-1,target);\\n       return ans;\\n    }\\n    public int search(int[] nums, int target) {\\n        int ans = searchValue(nums,nums.length,target);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    //using recursion\\n    public int searchValue(int[] nums,int n,int target){\\n       if(n==0)\\n       return -1;\\n       if(nums[n-1] == target)\\n       return n-1;\\n       int ans = searchValue(nums,n-1,target);\\n       return ans;\\n    }\\n    public int search(int[] nums, int target) {\\n        int ans = searchValue(nums,nums.length,target);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2702030,
                "title": "c-fast-and-easy-recursion-iterative",
                "content": "I\\'ve included both recursive & iterative solutions below for binary search\\n\\n\\n# Recursion solution\\n\\nThis is the recusive approach for solving the question:\\n```\\nclass Solution {\\nprivate:\\n\\n    // this has the same name as the original function but both are distinct as they require different number of arguments\\n    int search(vector<int>& nums, int target, int start, int end) {\\n\\n        // start <= end is the necessary condition for binary search\\n        if (start>end) return -1;\\n        int mid = start + (end-start)/2;\\n        if (nums[mid]==target) return mid;\\n\\n        // if the value is higher at mid of the subarray, and since the array is sorted, the value required shall be in the left half of the array\\n        else if (nums[mid] > target) return search(nums, target, start, mid-1);\\n\\n        // the value is present in the right half of the array as the value at mid of current subarray is lower than needed\\n        else return search(nums, target, mid+1, end);\\n    }\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        return search(nums, target, 0, nums.size()-1);\\n    }\\n};\\n```\\n\\n# Iterative solution\\n\\nThis is a better solution as it reduces the need of storage of stack memory\\n```\\nclass Solution {\\npublic:\\n    \\n    int search(vector<int>& nums, int target) {\\n        \\n        int start = 0, end = nums.size()-1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start)/2;\\n            if (nums[mid]==target) return mid;\\n            else if (nums[mid] < target) start = mid+1;\\n            else end = mid-1;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```\\n\\n*Please upvote to motivate me to write more solutions and contribute to the community*",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n\\n    // this has the same name as the original function but both are distinct as they require different number of arguments\\n    int search(vector<int>& nums, int target, int start, int end) {\\n\\n        // start <= end is the necessary condition for binary search\\n        if (start>end) return -1;\\n        int mid = start + (end-start)/2;\\n        if (nums[mid]==target) return mid;\\n\\n        // if the value is higher at mid of the subarray, and since the array is sorted, the value required shall be in the left half of the array\\n        else if (nums[mid] > target) return search(nums, target, start, mid-1);\\n\\n        // the value is present in the right half of the array as the value at mid of current subarray is lower than needed\\n        else return search(nums, target, mid+1, end);\\n    }\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        return search(nums, target, 0, nums.size()-1);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    int search(vector<int>& nums, int target) {\\n        \\n        int start = 0, end = nums.size()-1;\\n\\n        while (start <= end) {\\n            int mid = start + (end - start)/2;\\n            if (nums[mid]==target) return mid;\\n            else if (nums[mid] < target) start = mid+1;\\n            else end = mid-1;\\n        }\\n\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677095,
                "title": "c-solution-recursive-approach",
                "content": "Please UpVote if it helps...\\n\\n```\\nclass Solution {\\npublic:\\n        int binary(vector<int>v,int l, int r, int key)\\n    {\\n\\t\\t// till l doesn\\'t exceed r\\n        if(r >= l)\\n        {\\n            int mid = (l+r)/2;\\n\\t\\t\\t\\n\\t\\t\\t// if key equals mid return mid\\n            if(key == v[mid])\\n                return mid;\\n\\t\\t\\t\\t\\n\\t\\t\\t// if key is less than mid\\n\\t\\t\\t// recursive call for left half\\n            else if(key < v[mid])\\n                return binary(v,l,mid-1,key);\\n\\t\\t\\t\\t\\n\\t\\t\\t// key is greater than mid\\n\\t\\t\\t// recursive call for right half\\n            else\\n                return binary(v,mid+1,r,key);\\n        }\\n\\t\\t\\n\\t\\t// if key not found\\n        return -1;\\n    }\\n    int search(vector<int>& nums, int target) {\\n       int result = binary(nums,0,nums.size()-1,target);\\n\\t\\t\\n\\t\\t// if func returns -1 key doesn\\'t exists\\n        if (result == -1)\\n            return -1;\\n\\t\\t\\n\\t\\t// return index of key\\n        else\\n            return result;   \\n    }\\n\\t\\n};\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n        int binary(vector<int>v,int l, int r, int key)\\n    {\\n\\t\\t// till l doesn\\'t exceed r\\n        if(r >= l)\\n        {\\n            int mid = (l+r)/2;\\n\\t\\t\\t\\n\\t\\t\\t// if key equals mid return mid\\n            if(key == v[mid])\\n                return mid;\\n\\t\\t\\t\\t\\n\\t\\t\\t// if key is less than mid\\n\\t\\t\\t// recursive call for left half\\n            else if(key < v[mid])\\n                return binary(v,l,mid-1,key);\\n\\t\\t\\t\\t\\n\\t\\t\\t// key is greater than mid\\n\\t\\t\\t// recursive call for right half\\n            else\\n                return binary(v,mid+1,r,key);\\n        }\\n\\t\\t\\n\\t\\t// if key not found\\n        return -1;\\n    }\\n    int search(vector<int>& nums, int target) {\\n       int result = binary(nums,0,nums.size()-1,target);\\n\\t\\t\\n\\t\\t// if func returns -1 key doesn\\'t exists\\n        if (result == -1)\\n            return -1;\\n\\t\\t\\n\\t\\t// return index of key\\n        else\\n            return result;   \\n    }\\n\\t\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2665932,
                "title": "explained-one-line-solution",
                "content": "```\\n    int search(vector<int>& n, int t) {\\n        return (binary_search(n.begin(),n.end(), t)) ? (lower_bound(n.begin(), n.end(), t) - n.begin()) : -1;\\n    }\\n```\\n# **EXPLANATION!**\\n\\n`return (condition) ? a : b;`\\nif (condition is true ) return `a`, else return `b`;\\n\\nHere, function `binary_search` will search in the range (`n.begin() `to `n.end()`) and find target `t`,\\nif not found (condition is `false`, we\\'ll simply return `-1`.\\n\\nif found (condition is `true`)\\nwe\\'ll return position of target `t` in terms of index.\\nBUT, lower_bound will return iterator not index. \\n\\n`lower_bound()` will search in the range of array and it\\'ll return the iterator of the target element.\\n\\nNOTE: first index of array is `0` and last index is `n - 1`,\\nbut incase of iterator `n.end()` is after the end of array, so to get the position of elements in terms of `0-indexed array`, we need to **substract the target iterator from n.begin()** :\\n(iterator of target ) - n.begin();\\n\\ne.g : Target = 6, \\n\\n\\tn[]         = [ 2, 3 ,4, 6, 8 ]\\n\\tindex       =   0, 1, 2, 3, 4\\n\\titerator    =   5, 6, 7, 8, 9,10    //we can take any contiguous number\\n\\t\\t n.begin()->5             n.end() -> 10\\nsince target is `6`, we need to return it\\'s index i.e `3` , `n[3] == 6 == target`.\\n`lower_bound` will return `8`, we can see that `8 - n.begin()  == 8 - 5 = 3`.\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n    int search(vector<int>& n, int t) {\\n        return (binary_search(n.begin(),n.end(), t)) ? (lower_bound(n.begin(), n.end(), t) - n.begin()) : -1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2622924,
                "title": "easy-typescript-solution-with-detailed-explanation",
                "content": "The description and general algorithm of Binary Search is easy, but the details are devil: `mid` +1 or -1, using \\u2264 or < in the while loop.\\n\\n### Framework of binary search\\n\\n```ts\\nconst binarySearch = (nums: number[], target: number): number => {\\n\\tlet [left, right] = [0, 0];\\n\\twhile (...) {\\n\\t\\tconst mid = left + (right - left) / 2;\\n\\t\\tif (nums[mid] === target) {\\n\\t\\t\\t...\\n\\t\\t} else if (nums[mid] < target) {\\n\\t\\t\\t...\\n\\t\\t} else if (nums[mid] > target) {\\n\\t\\t\\t...\\n\\t\\t} \\n\\t}\\n\\treturn ...;\\n}\\n```\\n\\nWhen analysing binary search, try to avoid `else` statement, and use `else if` to display each details. `...` is the place where might go wrong. Also `left + (right - left) / 2` is equivalent to `(left + right) / 2` , to avoid the memory leak caused by the large value of `left` and `right` , the first is better. \\n\\n### Find only one index (basic Binary Search)\\n\\n```ts\\nfunction binaraySearch(nums: number[], target: number): number {\\n  let left = 0;\\n\\tlet right = nums.length - 1; // attention\\n\\twhile(left <= right) {\\n\\t\\t// js(dynamic type) remember to use Math.floor() to make it a integer\\n\\t    const mid = left + Math.floor((right - left) / 2);\\n        if (nums[mid] === target) {\\n            return mid;\\n        } else if (nums[mid] < target) {\\n            left = mid + 1; // attention\\n        } else if (nums[mid] > target) {\\n            right = mid - 1; // attention\\n        }  \\n    }\\n\\treturn -1;\\n};\\n```\\n\\n **1. In the while loop condition, why `\\u2264` instead of `<`?**\\n\\nBecause the initialisation of `right` is `nums.length-1` . \\n\\nThese two operators are both used in binary search, but for different scenario. The first is equal to `[left, right]`, and the latter is equal to `[left, right)`. In this algorithm, we use `[left, right]` closing interval, which is the exact range each time we search.\\n\\nBut when to stop searching? 1. we find the target value; 2. the searching interval is empty, which means we don\\u2019t find the target.\\n\\n- the break condition of `while(left \\u2264 right)` is `left == right + 1`, which is equal to `[right+1, right]`, the interval is obviously empty. For example, take `right = 2`, then the interval is `[3, 2]`, which is empty. You cannot find a number that is larger or equal than 2, but smaller or equal than 3.\\n- the break condition of `while(left < right)` is `left == right + 1`, which is equal to `[right, right]`, it is not empty, since right itself is in this interval. For example, take `right = 2`, then the interval is  `[2, 2]`. and 2 is in this interval.\\n\\nHence, if using open interval, there will be one missing element that we are not included in the searching process. But since we know where is the problem, and if we insist to use open interval, just update the return statement.\\n\\n```ts\\n// ...\\nwhile (left < right) {\\n\\t//...\\n}\\nreturn nums[left] === target ? left : -1;\\n```\\n\\n1. **Why `left = mid + 1`, `right = mid -  1`? I saw other materials are using `right = mid` or `left = mid`**\\n\\nBased on previous explanation, the searching interval is `[left, right]`. What is the next interval we want if `mid` is not `target`? `[left, mid - 1]`, `[mid+1, right]`. Because we already searched `mid`, it should be excluded in the next round searching. \\n\\n1. **What is the con of this algorithm?**\\n\\nFor example, given `nums=[1, 2, 2, 2, 3]`, and `target=2`, it will only return index 3. What if we want we want the first occurring index 1? or the last occurring index 3.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Binary Tree"
                ],
                "code": "```ts\\nconst binarySearch = (nums: number[], target: number): number => {\\n\\tlet [left, right] = [0, 0];\\n\\twhile (...) {\\n\\t\\tconst mid = left + (right - left) / 2;\\n\\t\\tif (nums[mid] === target) {\\n\\t\\t\\t...\\n\\t\\t} else if (nums[mid] < target) {\\n\\t\\t\\t...\\n\\t\\t} else if (nums[mid] > target) {\\n\\t\\t\\t...\\n\\t\\t} \\n\\t}\\n\\treturn ...;\\n}\\n```\n```ts\\nfunction binaraySearch(nums: number[], target: number): number {\\n  let left = 0;\\n\\tlet right = nums.length - 1; // attention\\n\\twhile(left <= right) {\\n\\t\\t// js(dynamic type) remember to use Math.floor() to make it a integer\\n\\t    const mid = left + Math.floor((right - left) / 2);\\n        if (nums[mid] === target) {\\n            return mid;\\n        } else if (nums[mid] < target) {\\n            left = mid + 1; // attention\\n        } else if (nums[mid] > target) {\\n            right = mid - 1; // attention\\n        }  \\n    }\\n\\treturn -1;\\n};\\n```\n```ts\\n// ...\\nwhile (left < right) {\\n\\t//...\\n}\\nreturn nums[left] === target ? left : -1;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454940,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q704. Binary Search***\\nGiven an array of integers `nums` which is sorted in ascending order, and an integer `target`, write a function to search `target `in `nums`. If `target` exists, then return its index. Otherwise, return -1.\\n\\nYou must write an algorithm with `O(log n) `runtime complexity.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        low, high = 0, len(nums) - 1\\n        while(low <= high):\\n            mid = (low + (high - low)//2)\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return -1\\n```\\n**Runtime:**  282 ms\\t\\n**Memory Usage:**  14.2 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int s=0;\\n        int e = nums.length-1;\\n        while(s<=e)\\n        {\\n            int mid = (s+e)/2;\\n            \\n            if(nums[mid]==target)\\n                return mid;\\n            if(nums[mid]>target)\\n                e = mid-1;\\n            else\\n                s=mid+1;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\\n**Runtime:**  0ms\\t\\n**Memory Usage:**  50.4 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s=0;\\n        int e = nums.size()-1;\\n        while(s<=e){\\n            int mid = (s+e)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            if(nums[mid]>target){\\n                e = mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Runtime:** 50ms\\t\\t\\n**Memory Usage:**  26.1 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        low, high = 0, len(nums) - 1\\n        while(low <= high):\\n            mid = (low + (high - low)//2)\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return -1\\n```\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int s=0;\\n        int e = nums.length-1;\\n        while(s<=e)\\n        {\\n            int mid = (s+e)/2;\\n            \\n            if(nums[mid]==target)\\n                return mid;\\n            if(nums[mid]>target)\\n                e = mid-1;\\n            else\\n                s=mid+1;\\n        }\\n        return -1;\\n    }\\n}\\n\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s=0;\\n        int e = nums.size()-1;\\n        while(s<=e){\\n            int mid = (s+e)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            if(nums[mid]>target){\\n                e = mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2426160,
                "title": "python-c-beginner-level-solution-as-simple-as-you-think-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q704. Binary Search***\\n\\nGiven an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\\n\\nYou must write an algorithm with O(log n) runtime complexity.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        low, high = 0, len(nums) - 1\\n        while(low <= high):\\n            mid = (low + (high - low)//2)\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return -1\\n```\\n**Runtime:**  262ms\\n**Memory Usage:**  15.5 MB\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s=0;\\n        int e = nums.size()-1;\\n        while(s<=e){\\n            int mid = (s+e)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            if(nums[mid]>target){\\n                e = mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Runtime:**  50s\\n**Memory Usage:**  27.6MB\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F",
                "solutionTags": [
                    "Python",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        low, high = 0, len(nums) - 1\\n        while(low <= high):\\n            mid = (low + (high - low)//2)\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] < target:\\n                low = mid + 1\\n            else:\\n                high = mid - 1\\n        return -1\\n```\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int s=0;\\n        int e = nums.size()-1;\\n        while(s<=e){\\n            int mid = (s+e)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n            }\\n            if(nums[mid]>target){\\n                e = mid-1;\\n            }\\n            else{\\n                s=mid+1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2275330,
                "title": "python-binary-search-and-cheat-solution",
                "content": "**1. Binary Search Algorithm**\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        s, e = 0, len(nums)-1\\n        while s<=e:\\n            m = (s+e)//2\\n            if nums[m] == target:\\n                return m\\n            elif nums[m] > target:\\n                e = m - 1\\n            else:\\n                s = m + 1\\n        return -1\\n```\\n\\n**2. Cheat Solution if you want faster Time**\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n\\t\\ttry:\\n\\t\\t\\treturn nums.index(target)\\n\\t\\texcept:\\n            return -1\\n```\\n\\t\\t\\n",
                "solutionTags": [
                    "Python",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        s, e = 0, len(nums)-1\\n        while s<=e:\\n            m = (s+e)//2\\n            if nums[m] == target:\\n                return m\\n            elif nums[m] > target:\\n                e = m - 1\\n            else:\\n                s = m + 1\\n        return -1\\n```\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n\\t\\ttry:\\n\\t\\t\\treturn nums.index(target)\\n\\t\\texcept:\\n            return -1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2015726,
                "title": "java-c-reversive-and-iterative-solution-with-a-simple-explanation-to-avoid-overflow-error",
                "content": "we use `(high+low)/2` lead to an error if high is `Integer.MAX_VALUE()`.  but if we use `(high-low)/2 + low` which avoid overflow error.\\n\\n## Java Solution\\n```java\\nclass Solution {\\n\\n\\t// iterative\\n    public int search(int[] nums, int target) {\\n        \\n\\t\\t// Corner case\\n        if(nums == null || nums.length == 0) return -1;\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        \\n        while(low <= high){\\n            int mid = (high-low)/2 + low;\\n            if(nums[mid] == target) return mid;\\n            if(nums[mid] < target) low = mid + 1;\\n            else high = mid  - 1;\\n\\t    }\\n        return -1;\\n    }\\n\\n\\t// Recursive \\n\\tpublic static int Rsearch(int[] nums, int low, int high, int target){\\n\\n\\t\\tif(low > high) return -1;\\n\\n\\t\\tint mid = low + (high-low)/2;\\n\\t\\tif(target == nums[mid])\\n\\t\\t\\treturn mid;\\n\\t\\telse if(target < nums[mid])\\n\\t\\t\\treturn Rsearch(nums, low, mid-1, target);\\n\\t\\telse\\n\\t\\t\\treturn Rsearch(nums, mid+1, high, target);\\n\\t}\\n}\\n```\\n## C++\\n```c++\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        \\n        int mid, low = 0, high = nums.size()-1;\\n        while(low <= high){ \\n            mid = (high-low)/2 + low;\\n            if(nums[mid] == target) return mid;\\n            if(nums[mid] > target) high = mid -1;\\n            else low = mid +1;\\n        }\\n        return -1;\\n    }\\n\\t\\n\\t// Recursive \\n\\tint Rsearch(vector<int> nums, int low, int high, int target){\\n    \\n\\t\\tif(low > high) return -1;\\n\\n\\t\\tint mid = low + (high-low)/2;\\n\\t\\tif(target == nums[mid]) return mid;\\n\\t\\telse if(target < nums[mid])\\n\\t\\t\\treturn Rsearch(nums, low, mid-1, target);\\n\\t\\telse\\n\\t\\t\\treturn Rsearch(nums, mid+1, high, target);\\n\\t}\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "Recursion"
                ],
                "code": "```java\\nclass Solution {\\n\\n\\t// iterative\\n    public int search(int[] nums, int target) {\\n        \\n\\t\\t// Corner case\\n        if(nums == null || nums.length == 0) return -1;\\n        \\n        int low = 0;\\n        int high = nums.length-1;\\n        \\n        while(low <= high){\\n            int mid = (high-low)/2 + low;\\n            if(nums[mid] == target) return mid;\\n            if(nums[mid] < target) low = mid + 1;\\n            else high = mid  - 1;\\n\\t    }\\n        return -1;\\n    }\\n\\n\\t// Recursive \\n\\tpublic static int Rsearch(int[] nums, int low, int high, int target){\\n\\n\\t\\tif(low > high) return -1;\\n\\n\\t\\tint mid = low + (high-low)/2;\\n\\t\\tif(target == nums[mid])\\n\\t\\t\\treturn mid;\\n\\t\\telse if(target < nums[mid])\\n\\t\\t\\treturn Rsearch(nums, low, mid-1, target);\\n\\t\\telse\\n\\t\\t\\treturn Rsearch(nums, mid+1, high, target);\\n\\t}\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        \\n        int mid, low = 0, high = nums.size()-1;\\n        while(low <= high){ \\n            mid = (high-low)/2 + low;\\n            if(nums[mid] == target) return mid;\\n            if(nums[mid] > target) high = mid -1;\\n            else low = mid +1;\\n        }\\n        return -1;\\n    }\\n\\t\\n\\t// Recursive \\n\\tint Rsearch(vector<int> nums, int low, int high, int target){\\n    \\n\\t\\tif(low > high) return -1;\\n\\n\\t\\tint mid = low + (high-low)/2;\\n\\t\\tif(target == nums[mid]) return mid;\\n\\t\\telse if(target < nums[mid])\\n\\t\\t\\treturn Rsearch(nums, low, mid-1, target);\\n\\t\\telse\\n\\t\\t\\treturn Rsearch(nums, mid+1, high, target);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1980381,
                "title": "js-solution-1-liner",
                "content": "```\\nvar search = function(nums, target) {\\n    return nums.includes(target) ? nums.indexOf(target) : -1\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar search = function(nums, target) {\\n    return nums.includes(target) ? nums.indexOf(target) : -1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1886311,
                "title": "java-most-easy-solution",
                "content": "\\n\\tclass Solution {\\n     public int search(int[] nums, int target) {\\n       if(nums.length == 0 || nums == null)\\n        return -1;\\n        int s = 0;\\n        int end = nums.length-1;\\n        while(s<=end){\\n            int mid = s + (end - s)/2;\\n            if(nums[mid] == target){\\n              return mid;   \\n            }\\n            if(nums[mid]<target){\\n                 s = mid+1;\\n            }\\n            if(nums[mid]>target){\\n                 end = mid-1;      \\n            } \\n        }\\n        return -1;\\n     }\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n     public int search(int[] nums, int target) {\\n       if(nums.length == 0 || nums == null)\\n        return -1;\\n        int s = 0;\\n        int end = nums.length-1;\\n        while(s<=end){\\n            int mid = s + (end - s)/2;\\n            if(nums[mid] == target){\\n              return mid;   \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1886251,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranties of any kind. You can are to use the content as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func search(_ n: [Int], _ t: Int) -> Int {\\n        var lhs = 0, rhs = n.count - 1\\n        while lhs <= rhs {\\n            let mid = lhs + (rhs - lhs) / 2, nmid = n[mid]\\n            guard nmid != t else { return mid }\\n            nmid > t ? (rhs = mid - 1) : (lhs = mid + 1)\\n        }\\n        return -1\\n    }\\n}\\n```\\n\\n<hr>\\n\\n<p><details>\\n<summary><img src=\"https://git.io/JDblm\" height=\"24\"> <b>TEST CASES</b></summary>\\n\\n```swift\\nclass Tests {\\n    \\n    private typealias s = Solution\\n    \\n    // 9 exists in nums and its index is 4\\n    static func testExample1() {\\n        let val = s().search([-1,0,3,5,9,12], 9)\\n        print(val == 4)\\n    }\\n    \\n    // 2 does not exist in nums so return -1\\n    static func testExample2() {\\n        let val = s().search([-1,0,3,5,9,12], 2)\\n        print(val == -1)\\n    }\\n}\\n\\nTests.testExample1()\\nTests.testExample2()\\n```\\n\\n</details></p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func search(_ n: [Int], _ t: Int) -> Int {\\n        var lhs = 0, rhs = n.count - 1\\n        while lhs <= rhs {\\n            let mid = lhs + (rhs - lhs) / 2, nmid = n[mid]\\n            guard nmid != t else { return mid }\\n            nmid > t ? (rhs = mid - 1) : (lhs = mid + 1)\\n        }\\n        return -1\\n    }\\n}\\n```\n```swift\\nclass Tests {\\n    \\n    private typealias s = Solution\\n    \\n    // 9 exists in nums and its index is 4\\n    static func testExample1() {\\n        let val = s().search([-1,0,3,5,9,12], 9)\\n        print(val == 4)\\n    }\\n    \\n    // 2 does not exist in nums so return -1\\n    static func testExample2() {\\n        let val = s().search([-1,0,3,5,9,12], 2)\\n        print(val == -1)\\n    }\\n}\\n\\nTests.testExample1()\\nTests.testExample2()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1886186,
                "title": "704-c-easy-o-logn-solution",
                "content": "**Code:**\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n        int start=0, end=nums.size()-1;\\n        \\n        while(start<=end)\\n        {\\n            //find mid index and then compare its value with target\\n            int mid=(start+end)/2;\\n            \\n            //if equal return mid\\n            if(nums[mid] == target) return mid;\\n        \\n            //if its value is less than target then initialize start = mid+1\\n            else if(nums[mid] < target) start = mid+1;\\n            \\n            //if its value is greater than target then initializae end=mid-1\\n            else end = mid-1;\\n    \\n        }\\n        //return -1 since target is not exist\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n        int start=0, end=nums.size()-1;\\n        \\n        while(start<=end)\\n        {\\n            //find mid index and then compare its value with target\\n            int mid=(start+end)/2;\\n            \\n            //if equal return mid\\n            if(nums[mid] == target) return mid;\\n        \\n            //if its value is less than target then initialize start = mid+1\\n            else if(nums[mid] < target) start = mid+1;\\n            \\n            //if its value is greater than target then initializae end=mid-1\\n            else end = mid-1;\\n    \\n        }\\n        //return -1 since target is not exist\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884994,
                "title": "binary-search-easy-c",
                "content": "``` \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l =  0;\\n        int r = nums.size() - 1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] == target){\\n                return mid;\\n            }else if(nums[mid] < target){\\n                l = mid + 1;\\n            }else{\\n                r = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search"
                ],
                "code": "``` \\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int l =  0;\\n        int r = nums.size() - 1;\\n        while(l<=r){\\n            int mid = l + (r-l)/2;\\n            if(nums[mid] == target){\\n                return mid;\\n            }else if(nums[mid] < target){\\n                l = mid + 1;\\n            }else{\\n                r = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813501,
                "title": "c-easy-2-solutions",
                "content": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        \\n        int low=0,high=nums.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]==target)\\n            {\\n                return mid;\\n            }\\n            else if(nums[mid]>target)\\n            {\\n               high=mid-1; \\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n        \\n//         int i=0;\\n//         while(i<nums.size())\\n//         {\\n//             if(nums[i]==target)\\n//             {\\n//                 return i;\\n//             }\\n//             i++;\\n//         }\\n//         return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        \\n        int low=0,high=nums.size()-1;\\n        while(low<=high)\\n        {\\n            int mid=low+(high-low)/2;\\n            if(nums[mid]==target)\\n            {\\n                return mid;\\n            }\\n            else if(nums[mid]>target)\\n            {\\n               high=mid-1; \\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n        \\n        return -1;\\n        \\n        \\n//         int i=0;\\n//         while(i<nums.size())\\n//         {\\n//             if(nums[i]==target)\\n//             {\\n//                 return i;\\n//             }\\n//             i++;\\n//         }\\n//         return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1739198,
                "title": "c-binary-search-simple-explain",
                "content": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n        int s = 0; // start index\\n        int m;  // mid index\\n        int e = nums.size()-1; // end index\\n        while(s<=e)\\n        {\\n            m = s+(e-s)/2; // calculate mid\\n            if(nums[m] == target) return m;  // check for target\\n            else if(nums[m] > target) e=m-1; // if we dont find targer move start and end as it required\\n            else s=m+1;\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n        int s = 0; // start index\\n        int m;  // mid index\\n        int e = nums.size()-1; // end index\\n        while(s<=e)\\n        {\\n            m = s+(e-s)/2; // calculate mid\\n            if(nums[m] == target) return m;  // check for target\\n            else if(nums[m] > target) e=m-1; // if we dont find targer move start and end as it required\\n            else s=m+1;\\n        }\\n        return -1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1632447,
                "title": "binary-search-with-easy-explanation-of-approach",
                "content": "*  Checkout this article for better understanding: [Binary search Explanation](https://atharvayadav.hashnode.dev/704-binary-search-leetcode-solution)\\n#### Approach\\n\\n1. First of all, we will create two pointers, `start` and `end`.  The `start` will point to the first element of an array and the `end` will point to the last element of an array.\\n2. Then we will find the middle index of an array. While finding the middle element we will use `mid = start + (end - start) / 2` formula instead of `mid = start + end /2`. The reason is `start + end` might give an overflow error if numbers are large.\\n3. Now, if the element at the middle index is less than the `target` element, then we will ignore the left part of the middle element. Because the array is sorted and if the middle element is less than the target, then the target must be at the right part of the middle element. We will update the `start` pointer to `mid+1` to ignore the left part.\\n4. Similarly, if the element at the middle index is greater than the `target` element, then we will ignore the right part of the middle element. We will change the `end` pointer to `mid-1`.\\n5. The time complexity provided by this algorithm is `O(long)` as at each step array size gets reduced to half.\\n\\n#### Code \\n\\n```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        \\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n            if(nums[mid] == target)\\n                return mid;\\n            \\n            else if(nums[mid] < target){\\n                // Ignore the left part of mid, because array is sorted and target might found in right part\\n                start = mid +1;\\n            }\\n                \\n             else{\\n                 // Ignore the right part of mid, because array is sorted and target might found in left part\\n                 end = mid-1;\\n             }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start = 0;\\n        int end = nums.size()-1;\\n        \\n        while(start <= end){\\n            int mid = start + (end - start) / 2;\\n            if(nums[mid] == target)\\n                return mid;\\n            \\n            else if(nums[mid] < target){\\n                // Ignore the left part of mid, because array is sorted and target might found in right part\\n                start = mid +1;\\n            }\\n                \\n             else{\\n                 // Ignore the right part of mid, because array is sorted and target might found in left part\\n                 end = mid-1;\\n             }   \\n        }\\n        return -1;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1624945,
                "title": "elixir-solution",
                "content": "```elixir\\ndefmodule Solution do\\n  @doc \"Farshid Ashouri\"\\n  @spec search(nums :: [integer], target :: integer) :: integer\\n  def search(list, value), do: search(List.to_tuple(list), value, 0, length(list)-1)\\n \\n  def search(_tuple, _value, low, high) when high < low, do: -1\\n  def search(tuple, value, low, high) do\\n    mid = div(low + high, 2)\\n    midval = elem(tuple, mid)\\n    cond do\\n      value <  midval -> search(tuple, value, low, mid-1)\\n      value >  midval -> search(tuple, value, mid+1, high)\\n      value == midval -> mid \\n    end\\n  end\\nend\\n```",
                "solutionTags": [],
                "code": "```elixir\\ndefmodule Solution do\\n  @doc \"Farshid Ashouri\"\\n  @spec search(nums :: [integer], target :: integer) :: integer\\n  def search(list, value), do: search(List.to_tuple(list), value, 0, length(list)-1)\\n \\n  def search(_tuple, _value, low, high) when high < low, do: -1\\n  def search(tuple, value, low, high) do\\n    mid = div(low + high, 2)\\n    midval = elem(tuple, mid)\\n    cond do\\n      value <  midval -> search(tuple, value, low, mid-1)\\n      value >  midval -> search(tuple, value, mid+1, high)\\n      value == midval -> mid \\n    end\\n  end\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1556435,
                "title": "java-solution-beats-100",
                "content": "```\\nclass Solution {\\n    // Time O(log(n))\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = 0;\\n        while (left <= right) { // need <= in case array is size 1\\n            mid = left + (right-left) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (target > nums[mid]) {\\n                left = mid+1; // change left bound\\n            }\\n            else if(target < nums[mid]) {\\n                right = mid-1; // change right bound\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Time O(log(n))\\n    public int search(int[] nums, int target) {\\n        int left = 0;\\n        int right = nums.length-1;\\n        int mid = 0;\\n        while (left <= right) { // need <= in case array is size 1\\n            mid = left + (right-left) / 2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            } else if (target > nums[mid]) {\\n                left = mid+1; // change left bound\\n            }\\n            else if(target < nums[mid]) {\\n                right = mid-1; // change right bound\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552919,
                "title": "java-iterative-solution",
                "content": "Time Complexity : O(logN)\\nSpace Complexity : O(1)\\nRuntime : 1ms\\n\\nSolution : \\n\\n```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int start = 0;\\n        int end = nums.length-1;\\n        \\n        if (nums == null || nums.length == 0) return -1;\\n        \\n        while(start <= end){\\n            int middle = start + end-start/2;\\n            if(nums[middle]==target) return middle;\\n            \\n            if(nums[middle]<target){\\n                start=middle+1;\\n            }else{\\n                end=middle-1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        \\n        int start = 0;\\n        int end = nums.length-1;\\n        \\n        if (nums == null || nums.length == 0) return -1;\\n        \\n        while(start <= end){\\n            int middle = start + end-start/2;\\n            if(nums[middle]==target) return middle;\\n            \\n            if(nums[middle]<target){\\n                start=middle+1;\\n            }else{\\n                end=middle-1;\\n            }\\n        }\\n        \\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1849660,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1788131,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1725665,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1566570,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1566432,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1573898,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1849707,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1849704,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1576209,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1733576,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1849660,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1788131,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1725665,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1566570,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1566432,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1573898,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1849707,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1849704,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1576209,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1733576,
                "content": [
                    {
                        "username": "AlecLC",
                        "content": "We deserve this question after 3 hards in a row lol"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "I swear lmao"
                    },
                    {
                        "username": "prabal17",
                        "content": "\\uD83E\\uDD23"
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "[@rahul1995](/rahul1995) facts man. I hate it but still gotta grind"
                    },
                    {
                        "username": "eduard92",
                        "content": "already had it solved lol"
                    },
                    {
                        "username": "zenfred",
                        "content": "They should assign Easies on weekdays and Hards on weekends."
                    },
                    {
                        "username": "rahul1995",
                        "content": "they start the month with easy and make it harder by the end."
                    },
                    {
                        "username": "joseph261059",
                        "content": "Thank god I survive the DP week"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Really wish people would stop posting working solutions in Discussion\\u2026."
                    },
                    {
                        "username": "Jeetaksh",
                        "content": "Constraints not useful\\n1 <= nums.length <= 10^4\\n\\nWhat is the use of this problem with such a small size of array?\\nIt can easily pass linear search with such a less size.\\nIt should be made upto 10^9 so that it only passes binary search and not linear search so that the purpose of the problem to check your binary search abilities gets solved.\\n\\nThankyou"
                    },
                    {
                        "username": "cswartzell",
                        "content": "Sure, but you could also follow the instructions. If you want to waste your time tricking leetcode into accepting suboptimal solutions and not learn or practice... thats sort of on you. "
                    },
                    {
                        "username": "kortemaki",
                        "content": "##### There are a lot of \"python one-liner\" comments in the discussion (see [here](https://leetcode.com/problems/binary-search/discuss/332405/Python-so-simple-solution), [here](https://leetcode.com/problems/binary-search/discuss/307897/smple-python-solve), [here](https://leetcode.com/problems/binary-search/discuss/304065/Python-One-liner), [here](https://leetcode.com/problems/binary-search/discuss/281674/Python-Different-solution-that-doesn\\'t-use-binary-search-but-unsure-of-time-complexity), [...](https://leetcode.com/problems/binary-search/discuss/290671/Python-beats-93-very-concise)) that basically just return nums.index(target), which is not a binary search and takes O(n) time.  Assuming these submissions are getting accepted, the testbench ought to have more rigorous test cases!\\n\\nSure enough, linear time solutions do pass the testbench.  I wrote a solution using binary search (via bisect) that clocked in at 100% for Python3, and a solution using linear search (via nums.index) that clocked in at around 10% for Python3 (though some of the linear search solutions above cite performance in the low 90s).  You can find my implementations at [this playground link](https://leetcode.com/playground/2XGMofZT).\\n\\nThis was disappointing, but I wanted to submit some new test cases that would work for sublinear time search and time out for linear search.  I tried making some arrays with large numbers of elements <1M, but the LeetCode test code button fails on account of the JSON string limit of 2MB.  Testing with ~970K elements works fine for both my solutions and the Expected/reference implementation, but the time performance on 10 attempts was not significantly different (p=.81) and the outlier ranges were comparable.  I suspect the bulk of the time is spent in setting up the python test (list creation is O(n)), which dwarfs the time taken for a single search query.\\n\\nThe real difference between binary and linear search is in their relative performance when repeatedly querying for multiple keys, so maybe this question should be rewritten to search for indices to a list of k queries in the sorted list nums (binary search O(k log n) time vs linear search O(kn) time; both O(k) memory), which would differentiate at n>>k.\\n\\nWithout changing the problem setup or making some question-specific, (and worse, language-specific) code on the LeetCode backend to enable querying the solution multiple times on the same input array, I don\\'t know how realistic it is to try to find a time limit threshold that can accurately discriminate between linear and sublinear implementations.  Maybe we just need a better Binary Search question (or to acknowledge that this isn\\'t a Binary Search question)."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :) "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for March, Day 26.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/binary-search/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 1 approach in the official solution</summary>\n\n  \n**Approach 1:** Binary Search \n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "SF26",
                        "content": "this video quickly explains how this algorithm works in a real example\\nhttps://youtu.be/Itp19oKCtO8"
                    },
                    {
                        "username": "harshsingh22440",
                        "content": "i know the solution but some test cases like [2,5] and [2] it gives me wrong answer\n"
                    },
                    {
                        "username": "dhruvdd8888",
                        "content": "# After streak of hard questions, leetcode lets you relax. Saying happy new month."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the Algo:-)***\\n\\n- Binary search is a search algorithm that works by repeatedly dividing the search interval in half. The algorithm starts by comparing the target value to the middle element of the sorted array. If the target value is equal to the middle element, the search is successful, and the index of the middle element is returned. If the target value is less than the middle element, the search continues in the lower half of the array. If the target value is greater than the middle element, the search continues in the upper half of the array. The process is repeated until the target value is found or the search interval is empty.\\n\\n- The time complexity of binary search is O(log n), where n is the number of elements in the array. This makes it an efficient algorithm for searching large arrays. However, binary search requires the input array to be sorted, which can be a disadvantage if the array is frequently updated."
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "***Here is the code link:-)***\\nhttps://leetcode.com/problems/binary-search/solutions/2040776/binary-search-c-java/?orderBy=most_votes"
                    },
                    {
                        "username": "zshzbh",
                        "content": "var search = function(nums, target) {\\nlet left =0;\\nlet right =nums.length-1;\\nwhile(left<=right){\\nlet mid = Math.floor(left +(right-left)/2);\\nif(nums[mid]===target) return mid;\\nelse if(nums[mid]> target) right=mid-1;\\nelse if(nums[mid]<target) left = mid+1;\\n}\\nreturn -1;\\n};"
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "chatgpt vale log???\\n"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best Explanation:\\nhttps://youtu.be/zx-c48gtCsc"
                    },
                    {
                        "username": "Akshat724",
                        "content": "Thanks for this!"
                    }
                ]
            },
            {
                "id": 1683365,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :)"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s a pity we can\\'t follow people on LeetCode"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro it\\'s MAANG now"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "3 interesting facts about binary search | Hindi | 2 min video\\nyoutube .com/watch?v=pK_8-rgTV8s"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "When I used linear search my runtime was 37ms but when i used binary search my runtime was 84 ms how is it possible with o(log n) time complexity has higher runtime than o(n) complexity?"
                    },
                    {
                        "username": "Liam33",
                        "content": "its because o(log n) isn\\'t just flat out faster. It just scales better with larger data sets. Working with smaller inputs like this, linear search is faster, and then at a certain size binary search starts becoming way faster"
                    },
                    {
                        "username": "jsaez",
                        "content": "Recursion limit is set low enough so that perfectly working recursive code crashes. You are forced to implement an iterative solution."
                    },
                    {
                        "username": "chiranjibmohapatra2001",
                        "content": "why this is not working??\\n\\nint l=nums.length,low=0,up=l;\\n        for(int i=l/2;i<=l/2;i=(Math.abs(low-up)/2)){\\n            if(nums[i]==target)\\n                return i;\\n            else if(target>nums[i])\\n                low=i+1; \\n            else \\n                up=i-1;\\n        }\\n        return -1;"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "The loop condition \"i <= l/2\", means that the loop will only check one element, which is not sufficient. Try using a while loop that compares the most left pointer and the most right pointer.\n\nAlso \" i = Math.abs(low - up) / 2\", it should be \" mid = (low + up) // 2 \""
                    },
                    {
                        "username": "shantanu1405",
                        "content": "Leetcode trying to april fool us :) "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Happy April Fools"
                    },
                    {
                        "username": "alexanderkahn",
                        "content": "Does this problem actually test the time complexity of the solution? I wrote one in Go that iterates through all the numbers and returns the index of the matching one. This should be O(n) not O(log n), and thus not a valid solution, right? "
                    },
                    {
                        "username": "c8763yee",
                        "content": "how does this code work and why this code runs far faster than others solutions\n```python\nf = open(\"user.out\", 'w')\nfor nums, tar in zip(stdin, stdin):\n    a = nums[1:-2].split(',')\n    tar = tar.rstrip()\n    t = int(tar)\n    i = bisect_left(a, True, key=lambda x: int(x) >= t)\n    print(i if i < len(a) and a[i] == tar else -1, file=f)\nexit(0)\n```"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "holy shit bro ! That\\'s something new I have learned today. Thanks"
                    },
                    {
                        "username": "pushpesh_Shandilya",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int len  =nums.length;\\n        int str= 0;\\n        int end = len-1;\\n        while(str<=end){\\n            int mid= (str+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n\\n            }else if(nums[mid]>target){\\n                end= mid-1;\\n\\n            }else{\\n                str=mid+1;\\n                \\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1576551,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :)"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s a pity we can\\'t follow people on LeetCode"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro it\\'s MAANG now"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "3 interesting facts about binary search | Hindi | 2 min video\\nyoutube .com/watch?v=pK_8-rgTV8s"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "When I used linear search my runtime was 37ms but when i used binary search my runtime was 84 ms how is it possible with o(log n) time complexity has higher runtime than o(n) complexity?"
                    },
                    {
                        "username": "Liam33",
                        "content": "its because o(log n) isn\\'t just flat out faster. It just scales better with larger data sets. Working with smaller inputs like this, linear search is faster, and then at a certain size binary search starts becoming way faster"
                    },
                    {
                        "username": "jsaez",
                        "content": "Recursion limit is set low enough so that perfectly working recursive code crashes. You are forced to implement an iterative solution."
                    },
                    {
                        "username": "chiranjibmohapatra2001",
                        "content": "why this is not working??\\n\\nint l=nums.length,low=0,up=l;\\n        for(int i=l/2;i<=l/2;i=(Math.abs(low-up)/2)){\\n            if(nums[i]==target)\\n                return i;\\n            else if(target>nums[i])\\n                low=i+1; \\n            else \\n                up=i-1;\\n        }\\n        return -1;"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "The loop condition \"i <= l/2\", means that the loop will only check one element, which is not sufficient. Try using a while loop that compares the most left pointer and the most right pointer.\n\nAlso \" i = Math.abs(low - up) / 2\", it should be \" mid = (low + up) // 2 \""
                    },
                    {
                        "username": "shantanu1405",
                        "content": "Leetcode trying to april fool us :) "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Happy April Fools"
                    },
                    {
                        "username": "alexanderkahn",
                        "content": "Does this problem actually test the time complexity of the solution? I wrote one in Go that iterates through all the numbers and returns the index of the matching one. This should be O(n) not O(log n), and thus not a valid solution, right? "
                    },
                    {
                        "username": "c8763yee",
                        "content": "how does this code work and why this code runs far faster than others solutions\n```python\nf = open(\"user.out\", 'w')\nfor nums, tar in zip(stdin, stdin):\n    a = nums[1:-2].split(',')\n    tar = tar.rstrip()\n    t = int(tar)\n    i = bisect_left(a, True, key=lambda x: int(x) >= t)\n    print(i if i < len(a) and a[i] == tar else -1, file=f)\nexit(0)\n```"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "holy shit bro ! That\\'s something new I have learned today. Thanks"
                    },
                    {
                        "username": "pushpesh_Shandilya",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int len  =nums.length;\\n        int str= 0;\\n        int end = len-1;\\n        while(str<=end){\\n            int mid= (str+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n\\n            }else if(nums[mid]>target){\\n                end= mid-1;\\n\\n            }else{\\n                str=mid+1;\\n                \\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1942017,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :)"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s a pity we can\\'t follow people on LeetCode"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro it\\'s MAANG now"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "3 interesting facts about binary search | Hindi | 2 min video\\nyoutube .com/watch?v=pK_8-rgTV8s"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "When I used linear search my runtime was 37ms but when i used binary search my runtime was 84 ms how is it possible with o(log n) time complexity has higher runtime than o(n) complexity?"
                    },
                    {
                        "username": "Liam33",
                        "content": "its because o(log n) isn\\'t just flat out faster. It just scales better with larger data sets. Working with smaller inputs like this, linear search is faster, and then at a certain size binary search starts becoming way faster"
                    },
                    {
                        "username": "jsaez",
                        "content": "Recursion limit is set low enough so that perfectly working recursive code crashes. You are forced to implement an iterative solution."
                    },
                    {
                        "username": "chiranjibmohapatra2001",
                        "content": "why this is not working??\\n\\nint l=nums.length,low=0,up=l;\\n        for(int i=l/2;i<=l/2;i=(Math.abs(low-up)/2)){\\n            if(nums[i]==target)\\n                return i;\\n            else if(target>nums[i])\\n                low=i+1; \\n            else \\n                up=i-1;\\n        }\\n        return -1;"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "The loop condition \"i <= l/2\", means that the loop will only check one element, which is not sufficient. Try using a while loop that compares the most left pointer and the most right pointer.\n\nAlso \" i = Math.abs(low - up) / 2\", it should be \" mid = (low + up) // 2 \""
                    },
                    {
                        "username": "shantanu1405",
                        "content": "Leetcode trying to april fool us :) "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Happy April Fools"
                    },
                    {
                        "username": "alexanderkahn",
                        "content": "Does this problem actually test the time complexity of the solution? I wrote one in Go that iterates through all the numbers and returns the index of the matching one. This should be O(n) not O(log n), and thus not a valid solution, right? "
                    },
                    {
                        "username": "c8763yee",
                        "content": "how does this code work and why this code runs far faster than others solutions\n```python\nf = open(\"user.out\", 'w')\nfor nums, tar in zip(stdin, stdin):\n    a = nums[1:-2].split(',')\n    tar = tar.rstrip()\n    t = int(tar)\n    i = bisect_left(a, True, key=lambda x: int(x) >= t)\n    print(i if i < len(a) and a[i] == tar else -1, file=f)\nexit(0)\n```"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "holy shit bro ! That\\'s something new I have learned today. Thanks"
                    },
                    {
                        "username": "pushpesh_Shandilya",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int len  =nums.length;\\n        int str= 0;\\n        int end = len-1;\\n        while(str<=end){\\n            int mid= (str+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n\\n            }else if(nums[mid]>target){\\n                end= mid-1;\\n\\n            }else{\\n                str=mid+1;\\n                \\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1881084,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :)"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s a pity we can\\'t follow people on LeetCode"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro it\\'s MAANG now"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "3 interesting facts about binary search | Hindi | 2 min video\\nyoutube .com/watch?v=pK_8-rgTV8s"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "When I used linear search my runtime was 37ms but when i used binary search my runtime was 84 ms how is it possible with o(log n) time complexity has higher runtime than o(n) complexity?"
                    },
                    {
                        "username": "Liam33",
                        "content": "its because o(log n) isn\\'t just flat out faster. It just scales better with larger data sets. Working with smaller inputs like this, linear search is faster, and then at a certain size binary search starts becoming way faster"
                    },
                    {
                        "username": "jsaez",
                        "content": "Recursion limit is set low enough so that perfectly working recursive code crashes. You are forced to implement an iterative solution."
                    },
                    {
                        "username": "chiranjibmohapatra2001",
                        "content": "why this is not working??\\n\\nint l=nums.length,low=0,up=l;\\n        for(int i=l/2;i<=l/2;i=(Math.abs(low-up)/2)){\\n            if(nums[i]==target)\\n                return i;\\n            else if(target>nums[i])\\n                low=i+1; \\n            else \\n                up=i-1;\\n        }\\n        return -1;"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "The loop condition \"i <= l/2\", means that the loop will only check one element, which is not sufficient. Try using a while loop that compares the most left pointer and the most right pointer.\n\nAlso \" i = Math.abs(low - up) / 2\", it should be \" mid = (low + up) // 2 \""
                    },
                    {
                        "username": "shantanu1405",
                        "content": "Leetcode trying to april fool us :) "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Happy April Fools"
                    },
                    {
                        "username": "alexanderkahn",
                        "content": "Does this problem actually test the time complexity of the solution? I wrote one in Go that iterates through all the numbers and returns the index of the matching one. This should be O(n) not O(log n), and thus not a valid solution, right? "
                    },
                    {
                        "username": "c8763yee",
                        "content": "how does this code work and why this code runs far faster than others solutions\n```python\nf = open(\"user.out\", 'w')\nfor nums, tar in zip(stdin, stdin):\n    a = nums[1:-2].split(',')\n    tar = tar.rstrip()\n    t = int(tar)\n    i = bisect_left(a, True, key=lambda x: int(x) >= t)\n    print(i if i < len(a) and a[i] == tar else -1, file=f)\nexit(0)\n```"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "holy shit bro ! That\\'s something new I have learned today. Thanks"
                    },
                    {
                        "username": "pushpesh_Shandilya",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int len  =nums.length;\\n        int str= 0;\\n        int end = len-1;\\n        while(str<=end){\\n            int mid= (str+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n\\n            }else if(nums[mid]>target){\\n                end= mid-1;\\n\\n            }else{\\n                str=mid+1;\\n                \\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1861179,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :)"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s a pity we can\\'t follow people on LeetCode"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro it\\'s MAANG now"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "3 interesting facts about binary search | Hindi | 2 min video\\nyoutube .com/watch?v=pK_8-rgTV8s"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "When I used linear search my runtime was 37ms but when i used binary search my runtime was 84 ms how is it possible with o(log n) time complexity has higher runtime than o(n) complexity?"
                    },
                    {
                        "username": "Liam33",
                        "content": "its because o(log n) isn\\'t just flat out faster. It just scales better with larger data sets. Working with smaller inputs like this, linear search is faster, and then at a certain size binary search starts becoming way faster"
                    },
                    {
                        "username": "jsaez",
                        "content": "Recursion limit is set low enough so that perfectly working recursive code crashes. You are forced to implement an iterative solution."
                    },
                    {
                        "username": "chiranjibmohapatra2001",
                        "content": "why this is not working??\\n\\nint l=nums.length,low=0,up=l;\\n        for(int i=l/2;i<=l/2;i=(Math.abs(low-up)/2)){\\n            if(nums[i]==target)\\n                return i;\\n            else if(target>nums[i])\\n                low=i+1; \\n            else \\n                up=i-1;\\n        }\\n        return -1;"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "The loop condition \"i <= l/2\", means that the loop will only check one element, which is not sufficient. Try using a while loop that compares the most left pointer and the most right pointer.\n\nAlso \" i = Math.abs(low - up) / 2\", it should be \" mid = (low + up) // 2 \""
                    },
                    {
                        "username": "shantanu1405",
                        "content": "Leetcode trying to april fool us :) "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Happy April Fools"
                    },
                    {
                        "username": "alexanderkahn",
                        "content": "Does this problem actually test the time complexity of the solution? I wrote one in Go that iterates through all the numbers and returns the index of the matching one. This should be O(n) not O(log n), and thus not a valid solution, right? "
                    },
                    {
                        "username": "c8763yee",
                        "content": "how does this code work and why this code runs far faster than others solutions\n```python\nf = open(\"user.out\", 'w')\nfor nums, tar in zip(stdin, stdin):\n    a = nums[1:-2].split(',')\n    tar = tar.rstrip()\n    t = int(tar)\n    i = bisect_left(a, True, key=lambda x: int(x) >= t)\n    print(i if i < len(a) and a[i] == tar else -1, file=f)\nexit(0)\n```"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "holy shit bro ! That\\'s something new I have learned today. Thanks"
                    },
                    {
                        "username": "pushpesh_Shandilya",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int len  =nums.length;\\n        int str= 0;\\n        int end = len-1;\\n        while(str<=end){\\n            int mid= (str+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n\\n            }else if(nums[mid]>target){\\n                end= mid-1;\\n\\n            }else{\\n                str=mid+1;\\n                \\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1850533,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :)"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s a pity we can\\'t follow people on LeetCode"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro it\\'s MAANG now"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "3 interesting facts about binary search | Hindi | 2 min video\\nyoutube .com/watch?v=pK_8-rgTV8s"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "When I used linear search my runtime was 37ms but when i used binary search my runtime was 84 ms how is it possible with o(log n) time complexity has higher runtime than o(n) complexity?"
                    },
                    {
                        "username": "Liam33",
                        "content": "its because o(log n) isn\\'t just flat out faster. It just scales better with larger data sets. Working with smaller inputs like this, linear search is faster, and then at a certain size binary search starts becoming way faster"
                    },
                    {
                        "username": "jsaez",
                        "content": "Recursion limit is set low enough so that perfectly working recursive code crashes. You are forced to implement an iterative solution."
                    },
                    {
                        "username": "chiranjibmohapatra2001",
                        "content": "why this is not working??\\n\\nint l=nums.length,low=0,up=l;\\n        for(int i=l/2;i<=l/2;i=(Math.abs(low-up)/2)){\\n            if(nums[i]==target)\\n                return i;\\n            else if(target>nums[i])\\n                low=i+1; \\n            else \\n                up=i-1;\\n        }\\n        return -1;"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "The loop condition \"i <= l/2\", means that the loop will only check one element, which is not sufficient. Try using a while loop that compares the most left pointer and the most right pointer.\n\nAlso \" i = Math.abs(low - up) / 2\", it should be \" mid = (low + up) // 2 \""
                    },
                    {
                        "username": "shantanu1405",
                        "content": "Leetcode trying to april fool us :) "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Happy April Fools"
                    },
                    {
                        "username": "alexanderkahn",
                        "content": "Does this problem actually test the time complexity of the solution? I wrote one in Go that iterates through all the numbers and returns the index of the matching one. This should be O(n) not O(log n), and thus not a valid solution, right? "
                    },
                    {
                        "username": "c8763yee",
                        "content": "how does this code work and why this code runs far faster than others solutions\n```python\nf = open(\"user.out\", 'w')\nfor nums, tar in zip(stdin, stdin):\n    a = nums[1:-2].split(',')\n    tar = tar.rstrip()\n    t = int(tar)\n    i = bisect_left(a, True, key=lambda x: int(x) >= t)\n    print(i if i < len(a) and a[i] == tar else -1, file=f)\nexit(0)\n```"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "holy shit bro ! That\\'s something new I have learned today. Thanks"
                    },
                    {
                        "username": "pushpesh_Shandilya",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int len  =nums.length;\\n        int str= 0;\\n        int end = len-1;\\n        while(str<=end){\\n            int mid= (str+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n\\n            }else if(nums[mid]>target){\\n                end= mid-1;\\n\\n            }else{\\n                str=mid+1;\\n                \\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1850155,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :)"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s a pity we can\\'t follow people on LeetCode"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro it\\'s MAANG now"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "3 interesting facts about binary search | Hindi | 2 min video\\nyoutube .com/watch?v=pK_8-rgTV8s"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "When I used linear search my runtime was 37ms but when i used binary search my runtime was 84 ms how is it possible with o(log n) time complexity has higher runtime than o(n) complexity?"
                    },
                    {
                        "username": "Liam33",
                        "content": "its because o(log n) isn\\'t just flat out faster. It just scales better with larger data sets. Working with smaller inputs like this, linear search is faster, and then at a certain size binary search starts becoming way faster"
                    },
                    {
                        "username": "jsaez",
                        "content": "Recursion limit is set low enough so that perfectly working recursive code crashes. You are forced to implement an iterative solution."
                    },
                    {
                        "username": "chiranjibmohapatra2001",
                        "content": "why this is not working??\\n\\nint l=nums.length,low=0,up=l;\\n        for(int i=l/2;i<=l/2;i=(Math.abs(low-up)/2)){\\n            if(nums[i]==target)\\n                return i;\\n            else if(target>nums[i])\\n                low=i+1; \\n            else \\n                up=i-1;\\n        }\\n        return -1;"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "The loop condition \"i <= l/2\", means that the loop will only check one element, which is not sufficient. Try using a while loop that compares the most left pointer and the most right pointer.\n\nAlso \" i = Math.abs(low - up) / 2\", it should be \" mid = (low + up) // 2 \""
                    },
                    {
                        "username": "shantanu1405",
                        "content": "Leetcode trying to april fool us :) "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Happy April Fools"
                    },
                    {
                        "username": "alexanderkahn",
                        "content": "Does this problem actually test the time complexity of the solution? I wrote one in Go that iterates through all the numbers and returns the index of the matching one. This should be O(n) not O(log n), and thus not a valid solution, right? "
                    },
                    {
                        "username": "c8763yee",
                        "content": "how does this code work and why this code runs far faster than others solutions\n```python\nf = open(\"user.out\", 'w')\nfor nums, tar in zip(stdin, stdin):\n    a = nums[1:-2].split(',')\n    tar = tar.rstrip()\n    t = int(tar)\n    i = bisect_left(a, True, key=lambda x: int(x) >= t)\n    print(i if i < len(a) and a[i] == tar else -1, file=f)\nexit(0)\n```"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "holy shit bro ! That\\'s something new I have learned today. Thanks"
                    },
                    {
                        "username": "pushpesh_Shandilya",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int len  =nums.length;\\n        int str= 0;\\n        int end = len-1;\\n        while(str<=end){\\n            int mid= (str+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n\\n            }else if(nums[mid]>target){\\n                end= mid-1;\\n\\n            }else{\\n                str=mid+1;\\n                \\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1845404,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :)"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s a pity we can\\'t follow people on LeetCode"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro it\\'s MAANG now"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "3 interesting facts about binary search | Hindi | 2 min video\\nyoutube .com/watch?v=pK_8-rgTV8s"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "When I used linear search my runtime was 37ms but when i used binary search my runtime was 84 ms how is it possible with o(log n) time complexity has higher runtime than o(n) complexity?"
                    },
                    {
                        "username": "Liam33",
                        "content": "its because o(log n) isn\\'t just flat out faster. It just scales better with larger data sets. Working with smaller inputs like this, linear search is faster, and then at a certain size binary search starts becoming way faster"
                    },
                    {
                        "username": "jsaez",
                        "content": "Recursion limit is set low enough so that perfectly working recursive code crashes. You are forced to implement an iterative solution."
                    },
                    {
                        "username": "chiranjibmohapatra2001",
                        "content": "why this is not working??\\n\\nint l=nums.length,low=0,up=l;\\n        for(int i=l/2;i<=l/2;i=(Math.abs(low-up)/2)){\\n            if(nums[i]==target)\\n                return i;\\n            else if(target>nums[i])\\n                low=i+1; \\n            else \\n                up=i-1;\\n        }\\n        return -1;"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "The loop condition \"i <= l/2\", means that the loop will only check one element, which is not sufficient. Try using a while loop that compares the most left pointer and the most right pointer.\n\nAlso \" i = Math.abs(low - up) / 2\", it should be \" mid = (low + up) // 2 \""
                    },
                    {
                        "username": "shantanu1405",
                        "content": "Leetcode trying to april fool us :) "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Happy April Fools"
                    },
                    {
                        "username": "alexanderkahn",
                        "content": "Does this problem actually test the time complexity of the solution? I wrote one in Go that iterates through all the numbers and returns the index of the matching one. This should be O(n) not O(log n), and thus not a valid solution, right? "
                    },
                    {
                        "username": "c8763yee",
                        "content": "how does this code work and why this code runs far faster than others solutions\n```python\nf = open(\"user.out\", 'w')\nfor nums, tar in zip(stdin, stdin):\n    a = nums[1:-2].split(',')\n    tar = tar.rstrip()\n    t = int(tar)\n    i = bisect_left(a, True, key=lambda x: int(x) >= t)\n    print(i if i < len(a) and a[i] == tar else -1, file=f)\nexit(0)\n```"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "holy shit bro ! That\\'s something new I have learned today. Thanks"
                    },
                    {
                        "username": "pushpesh_Shandilya",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int len  =nums.length;\\n        int str= 0;\\n        int end = len-1;\\n        while(str<=end){\\n            int mid= (str+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n\\n            }else if(nums[mid]>target){\\n                end= mid-1;\\n\\n            }else{\\n                str=mid+1;\\n                \\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1833308,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :)"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s a pity we can\\'t follow people on LeetCode"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro it\\'s MAANG now"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "3 interesting facts about binary search | Hindi | 2 min video\\nyoutube .com/watch?v=pK_8-rgTV8s"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "When I used linear search my runtime was 37ms but when i used binary search my runtime was 84 ms how is it possible with o(log n) time complexity has higher runtime than o(n) complexity?"
                    },
                    {
                        "username": "Liam33",
                        "content": "its because o(log n) isn\\'t just flat out faster. It just scales better with larger data sets. Working with smaller inputs like this, linear search is faster, and then at a certain size binary search starts becoming way faster"
                    },
                    {
                        "username": "jsaez",
                        "content": "Recursion limit is set low enough so that perfectly working recursive code crashes. You are forced to implement an iterative solution."
                    },
                    {
                        "username": "chiranjibmohapatra2001",
                        "content": "why this is not working??\\n\\nint l=nums.length,low=0,up=l;\\n        for(int i=l/2;i<=l/2;i=(Math.abs(low-up)/2)){\\n            if(nums[i]==target)\\n                return i;\\n            else if(target>nums[i])\\n                low=i+1; \\n            else \\n                up=i-1;\\n        }\\n        return -1;"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "The loop condition \"i <= l/2\", means that the loop will only check one element, which is not sufficient. Try using a while loop that compares the most left pointer and the most right pointer.\n\nAlso \" i = Math.abs(low - up) / 2\", it should be \" mid = (low + up) // 2 \""
                    },
                    {
                        "username": "shantanu1405",
                        "content": "Leetcode trying to april fool us :) "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Happy April Fools"
                    },
                    {
                        "username": "alexanderkahn",
                        "content": "Does this problem actually test the time complexity of the solution? I wrote one in Go that iterates through all the numbers and returns the index of the matching one. This should be O(n) not O(log n), and thus not a valid solution, right? "
                    },
                    {
                        "username": "c8763yee",
                        "content": "how does this code work and why this code runs far faster than others solutions\n```python\nf = open(\"user.out\", 'w')\nfor nums, tar in zip(stdin, stdin):\n    a = nums[1:-2].split(',')\n    tar = tar.rstrip()\n    t = int(tar)\n    i = bisect_left(a, True, key=lambda x: int(x) >= t)\n    print(i if i < len(a) and a[i] == tar else -1, file=f)\nexit(0)\n```"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "holy shit bro ! That\\'s something new I have learned today. Thanks"
                    },
                    {
                        "username": "pushpesh_Shandilya",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int len  =nums.length;\\n        int str= 0;\\n        int end = len-1;\\n        while(str<=end){\\n            int mid= (str+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n\\n            }else if(nums[mid]>target){\\n                end= mid-1;\\n\\n            }else{\\n                str=mid+1;\\n                \\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1787415,
                "content": [
                    {
                        "username": "AdityaBhate",
                        "content": "Look at my content. I post multiple Optimized codes asked in FAANG / Dream MNC\\'s :)"
                    },
                    {
                        "username": "zenfred",
                        "content": "It\\'s a pity we can\\'t follow people on LeetCode"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "Bro it\\'s MAANG now"
                    },
                    {
                        "username": "Gaurav_Kungwani_",
                        "content": "3 interesting facts about binary search | Hindi | 2 min video\\nyoutube .com/watch?v=pK_8-rgTV8s"
                    },
                    {
                        "username": "Ashnu_B",
                        "content": "When I used linear search my runtime was 37ms but when i used binary search my runtime was 84 ms how is it possible with o(log n) time complexity has higher runtime than o(n) complexity?"
                    },
                    {
                        "username": "Liam33",
                        "content": "its because o(log n) isn\\'t just flat out faster. It just scales better with larger data sets. Working with smaller inputs like this, linear search is faster, and then at a certain size binary search starts becoming way faster"
                    },
                    {
                        "username": "jsaez",
                        "content": "Recursion limit is set low enough so that perfectly working recursive code crashes. You are forced to implement an iterative solution."
                    },
                    {
                        "username": "chiranjibmohapatra2001",
                        "content": "why this is not working??\\n\\nint l=nums.length,low=0,up=l;\\n        for(int i=l/2;i<=l/2;i=(Math.abs(low-up)/2)){\\n            if(nums[i]==target)\\n                return i;\\n            else if(target>nums[i])\\n                low=i+1; \\n            else \\n                up=i-1;\\n        }\\n        return -1;"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "The loop condition \"i <= l/2\", means that the loop will only check one element, which is not sufficient. Try using a while loop that compares the most left pointer and the most right pointer.\n\nAlso \" i = Math.abs(low - up) / 2\", it should be \" mid = (low + up) // 2 \""
                    },
                    {
                        "username": "shantanu1405",
                        "content": "Leetcode trying to april fool us :) "
                    },
                    {
                        "username": "bhuppidhamii",
                        "content": "Happy April Fools"
                    },
                    {
                        "username": "alexanderkahn",
                        "content": "Does this problem actually test the time complexity of the solution? I wrote one in Go that iterates through all the numbers and returns the index of the matching one. This should be O(n) not O(log n), and thus not a valid solution, right? "
                    },
                    {
                        "username": "c8763yee",
                        "content": "how does this code work and why this code runs far faster than others solutions\n```python\nf = open(\"user.out\", 'w')\nfor nums, tar in zip(stdin, stdin):\n    a = nums[1:-2].split(',')\n    tar = tar.rstrip()\n    t = int(tar)\n    i = bisect_left(a, True, key=lambda x: int(x) >= t)\n    print(i if i < len(a) and a[i] == tar else -1, file=f)\nexit(0)\n```"
                    },
                    {
                        "username": "Ayush_Singh_610",
                        "content": "holy shit bro ! That\\'s something new I have learned today. Thanks"
                    },
                    {
                        "username": "pushpesh_Shandilya",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int len  =nums.length;\\n        int str= 0;\\n        int end = len-1;\\n        while(str<=end){\\n            int mid= (str+end)/2;\\n            if(nums[mid]==target){\\n                return mid;\\n\\n            }else if(nums[mid]>target){\\n                end= mid-1;\\n\\n            }else{\\n                str=mid+1;\\n                \\n            }\\n        }\\n        return -1;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1576189,
                "content": [
                    {
                        "username": "wisdomkhan",
                        "content": "I did the binary search same as the one in solution but still runtime is 43ms. Is there some optimised way to do binary search?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Binary search is already the optimized method."
                    },
                    {
                        "username": "shvkhzod",
                        "content": "why would you use binary search for the arrays with the length of 2 or less"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is a test case to check ,if your algorithm can handle it."
                    },
                    {
                        "username": "delphington",
                        "content": "Perfect."
                    },
                    {
                        "username": "AllwinJohnson",
                        "content": "this is not the proper solution for the problem but still I just wanted to post. \\nuse a Binary Search while implementing a solution for this. \\n\\n\\n`return if(arr.toList().contains(target)) arr.toList().indexOf(target) else -1`\\n\\n ~kotlin"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the runtime of this compared to a manually implemented binary search?"
                    },
                    {
                        "username": "Aayush003",
                        "content": "Line 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().search(param_1, param_2);\\n                    ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\nwhat to do with this ?\\n"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nMinimum Path Sum (Grid)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "hairloss",
                        "content": "it takes 700 problem, to meet our beloved friend binary search"
                    },
                    {
                        "username": "ar3s1337",
                        "content": "```go\\nfunc search(nums []int, target int) int {\\n    left, right := 0, len(nums) - 1\\n\\n    for left <= right {\\n        mid := left + (right - left) >> 1\\n        \\n        if nums[mid] > target {\\n            right = mid\\n        } else if nums[mid] < target {\\n            left = mid\\n        } else {\\n            return mid\\n        }\\n    }\\n\\n    return -1\\n}\\n```\\n\\nCan anyone tell me why the above code will cause TLE but if I put `-1` and `+1` to right/left assignment it will AC?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because without -1 , +1, your code is wrong."
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n\\n         int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid; // Target found\\n            } else if (nums[mid] < target) {\\n                left = mid + 1; // Adjust the left boundary\\n            } else {\\n                right = mid - 1; // Adjust the right boundary\\n            }\\n        }\\n\\n        return -1; // Target not found\\n    }\\n}"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the problem?"
                    }
                ]
            },
            {
                "id": 2075743,
                "content": [
                    {
                        "username": "wisdomkhan",
                        "content": "I did the binary search same as the one in solution but still runtime is 43ms. Is there some optimised way to do binary search?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Binary search is already the optimized method."
                    },
                    {
                        "username": "shvkhzod",
                        "content": "why would you use binary search for the arrays with the length of 2 or less"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is a test case to check ,if your algorithm can handle it."
                    },
                    {
                        "username": "delphington",
                        "content": "Perfect."
                    },
                    {
                        "username": "AllwinJohnson",
                        "content": "this is not the proper solution for the problem but still I just wanted to post. \\nuse a Binary Search while implementing a solution for this. \\n\\n\\n`return if(arr.toList().contains(target)) arr.toList().indexOf(target) else -1`\\n\\n ~kotlin"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the runtime of this compared to a manually implemented binary search?"
                    },
                    {
                        "username": "Aayush003",
                        "content": "Line 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().search(param_1, param_2);\\n                    ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\nwhat to do with this ?\\n"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nMinimum Path Sum (Grid)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "hairloss",
                        "content": "it takes 700 problem, to meet our beloved friend binary search"
                    },
                    {
                        "username": "ar3s1337",
                        "content": "```go\\nfunc search(nums []int, target int) int {\\n    left, right := 0, len(nums) - 1\\n\\n    for left <= right {\\n        mid := left + (right - left) >> 1\\n        \\n        if nums[mid] > target {\\n            right = mid\\n        } else if nums[mid] < target {\\n            left = mid\\n        } else {\\n            return mid\\n        }\\n    }\\n\\n    return -1\\n}\\n```\\n\\nCan anyone tell me why the above code will cause TLE but if I put `-1` and `+1` to right/left assignment it will AC?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because without -1 , +1, your code is wrong."
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n\\n         int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid; // Target found\\n            } else if (nums[mid] < target) {\\n                left = mid + 1; // Adjust the left boundary\\n            } else {\\n                right = mid - 1; // Adjust the right boundary\\n            }\\n        }\\n\\n        return -1; // Target not found\\n    }\\n}"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the problem?"
                    }
                ]
            },
            {
                "id": 2069328,
                "content": [
                    {
                        "username": "wisdomkhan",
                        "content": "I did the binary search same as the one in solution but still runtime is 43ms. Is there some optimised way to do binary search?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Binary search is already the optimized method."
                    },
                    {
                        "username": "shvkhzod",
                        "content": "why would you use binary search for the arrays with the length of 2 or less"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is a test case to check ,if your algorithm can handle it."
                    },
                    {
                        "username": "delphington",
                        "content": "Perfect."
                    },
                    {
                        "username": "AllwinJohnson",
                        "content": "this is not the proper solution for the problem but still I just wanted to post. \\nuse a Binary Search while implementing a solution for this. \\n\\n\\n`return if(arr.toList().contains(target)) arr.toList().indexOf(target) else -1`\\n\\n ~kotlin"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the runtime of this compared to a manually implemented binary search?"
                    },
                    {
                        "username": "Aayush003",
                        "content": "Line 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().search(param_1, param_2);\\n                    ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\nwhat to do with this ?\\n"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nMinimum Path Sum (Grid)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "hairloss",
                        "content": "it takes 700 problem, to meet our beloved friend binary search"
                    },
                    {
                        "username": "ar3s1337",
                        "content": "```go\\nfunc search(nums []int, target int) int {\\n    left, right := 0, len(nums) - 1\\n\\n    for left <= right {\\n        mid := left + (right - left) >> 1\\n        \\n        if nums[mid] > target {\\n            right = mid\\n        } else if nums[mid] < target {\\n            left = mid\\n        } else {\\n            return mid\\n        }\\n    }\\n\\n    return -1\\n}\\n```\\n\\nCan anyone tell me why the above code will cause TLE but if I put `-1` and `+1` to right/left assignment it will AC?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because without -1 , +1, your code is wrong."
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n\\n         int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid; // Target found\\n            } else if (nums[mid] < target) {\\n                left = mid + 1; // Adjust the left boundary\\n            } else {\\n                right = mid - 1; // Adjust the right boundary\\n            }\\n        }\\n\\n        return -1; // Target not found\\n    }\\n}"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the problem?"
                    }
                ]
            },
            {
                "id": 2067309,
                "content": [
                    {
                        "username": "wisdomkhan",
                        "content": "I did the binary search same as the one in solution but still runtime is 43ms. Is there some optimised way to do binary search?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Binary search is already the optimized method."
                    },
                    {
                        "username": "shvkhzod",
                        "content": "why would you use binary search for the arrays with the length of 2 or less"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is a test case to check ,if your algorithm can handle it."
                    },
                    {
                        "username": "delphington",
                        "content": "Perfect."
                    },
                    {
                        "username": "AllwinJohnson",
                        "content": "this is not the proper solution for the problem but still I just wanted to post. \\nuse a Binary Search while implementing a solution for this. \\n\\n\\n`return if(arr.toList().contains(target)) arr.toList().indexOf(target) else -1`\\n\\n ~kotlin"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the runtime of this compared to a manually implemented binary search?"
                    },
                    {
                        "username": "Aayush003",
                        "content": "Line 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().search(param_1, param_2);\\n                    ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\nwhat to do with this ?\\n"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nMinimum Path Sum (Grid)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "hairloss",
                        "content": "it takes 700 problem, to meet our beloved friend binary search"
                    },
                    {
                        "username": "ar3s1337",
                        "content": "```go\\nfunc search(nums []int, target int) int {\\n    left, right := 0, len(nums) - 1\\n\\n    for left <= right {\\n        mid := left + (right - left) >> 1\\n        \\n        if nums[mid] > target {\\n            right = mid\\n        } else if nums[mid] < target {\\n            left = mid\\n        } else {\\n            return mid\\n        }\\n    }\\n\\n    return -1\\n}\\n```\\n\\nCan anyone tell me why the above code will cause TLE but if I put `-1` and `+1` to right/left assignment it will AC?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because without -1 , +1, your code is wrong."
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n\\n         int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid; // Target found\\n            } else if (nums[mid] < target) {\\n                left = mid + 1; // Adjust the left boundary\\n            } else {\\n                right = mid - 1; // Adjust the right boundary\\n            }\\n        }\\n\\n        return -1; // Target not found\\n    }\\n}"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the problem?"
                    }
                ]
            },
            {
                "id": 2067132,
                "content": [
                    {
                        "username": "wisdomkhan",
                        "content": "I did the binary search same as the one in solution but still runtime is 43ms. Is there some optimised way to do binary search?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Binary search is already the optimized method."
                    },
                    {
                        "username": "shvkhzod",
                        "content": "why would you use binary search for the arrays with the length of 2 or less"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is a test case to check ,if your algorithm can handle it."
                    },
                    {
                        "username": "delphington",
                        "content": "Perfect."
                    },
                    {
                        "username": "AllwinJohnson",
                        "content": "this is not the proper solution for the problem but still I just wanted to post. \\nuse a Binary Search while implementing a solution for this. \\n\\n\\n`return if(arr.toList().contains(target)) arr.toList().indexOf(target) else -1`\\n\\n ~kotlin"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the runtime of this compared to a manually implemented binary search?"
                    },
                    {
                        "username": "Aayush003",
                        "content": "Line 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().search(param_1, param_2);\\n                    ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\nwhat to do with this ?\\n"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nMinimum Path Sum (Grid)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "hairloss",
                        "content": "it takes 700 problem, to meet our beloved friend binary search"
                    },
                    {
                        "username": "ar3s1337",
                        "content": "```go\\nfunc search(nums []int, target int) int {\\n    left, right := 0, len(nums) - 1\\n\\n    for left <= right {\\n        mid := left + (right - left) >> 1\\n        \\n        if nums[mid] > target {\\n            right = mid\\n        } else if nums[mid] < target {\\n            left = mid\\n        } else {\\n            return mid\\n        }\\n    }\\n\\n    return -1\\n}\\n```\\n\\nCan anyone tell me why the above code will cause TLE but if I put `-1` and `+1` to right/left assignment it will AC?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because without -1 , +1, your code is wrong."
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n\\n         int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid; // Target found\\n            } else if (nums[mid] < target) {\\n                left = mid + 1; // Adjust the left boundary\\n            } else {\\n                right = mid - 1; // Adjust the right boundary\\n            }\\n        }\\n\\n        return -1; // Target not found\\n    }\\n}"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the problem?"
                    }
                ]
            },
            {
                "id": 2064686,
                "content": [
                    {
                        "username": "wisdomkhan",
                        "content": "I did the binary search same as the one in solution but still runtime is 43ms. Is there some optimised way to do binary search?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Binary search is already the optimized method."
                    },
                    {
                        "username": "shvkhzod",
                        "content": "why would you use binary search for the arrays with the length of 2 or less"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is a test case to check ,if your algorithm can handle it."
                    },
                    {
                        "username": "delphington",
                        "content": "Perfect."
                    },
                    {
                        "username": "AllwinJohnson",
                        "content": "this is not the proper solution for the problem but still I just wanted to post. \\nuse a Binary Search while implementing a solution for this. \\n\\n\\n`return if(arr.toList().contains(target)) arr.toList().indexOf(target) else -1`\\n\\n ~kotlin"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the runtime of this compared to a manually implemented binary search?"
                    },
                    {
                        "username": "Aayush003",
                        "content": "Line 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().search(param_1, param_2);\\n                    ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\nwhat to do with this ?\\n"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nMinimum Path Sum (Grid)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "hairloss",
                        "content": "it takes 700 problem, to meet our beloved friend binary search"
                    },
                    {
                        "username": "ar3s1337",
                        "content": "```go\\nfunc search(nums []int, target int) int {\\n    left, right := 0, len(nums) - 1\\n\\n    for left <= right {\\n        mid := left + (right - left) >> 1\\n        \\n        if nums[mid] > target {\\n            right = mid\\n        } else if nums[mid] < target {\\n            left = mid\\n        } else {\\n            return mid\\n        }\\n    }\\n\\n    return -1\\n}\\n```\\n\\nCan anyone tell me why the above code will cause TLE but if I put `-1` and `+1` to right/left assignment it will AC?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because without -1 , +1, your code is wrong."
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n\\n         int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid; // Target found\\n            } else if (nums[mid] < target) {\\n                left = mid + 1; // Adjust the left boundary\\n            } else {\\n                right = mid - 1; // Adjust the right boundary\\n            }\\n        }\\n\\n        return -1; // Target not found\\n    }\\n}"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the problem?"
                    }
                ]
            },
            {
                "id": 2064682,
                "content": [
                    {
                        "username": "wisdomkhan",
                        "content": "I did the binary search same as the one in solution but still runtime is 43ms. Is there some optimised way to do binary search?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Binary search is already the optimized method."
                    },
                    {
                        "username": "shvkhzod",
                        "content": "why would you use binary search for the arrays with the length of 2 or less"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is a test case to check ,if your algorithm can handle it."
                    },
                    {
                        "username": "delphington",
                        "content": "Perfect."
                    },
                    {
                        "username": "AllwinJohnson",
                        "content": "this is not the proper solution for the problem but still I just wanted to post. \\nuse a Binary Search while implementing a solution for this. \\n\\n\\n`return if(arr.toList().contains(target)) arr.toList().indexOf(target) else -1`\\n\\n ~kotlin"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the runtime of this compared to a manually implemented binary search?"
                    },
                    {
                        "username": "Aayush003",
                        "content": "Line 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().search(param_1, param_2);\\n                    ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\nwhat to do with this ?\\n"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nMinimum Path Sum (Grid)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "hairloss",
                        "content": "it takes 700 problem, to meet our beloved friend binary search"
                    },
                    {
                        "username": "ar3s1337",
                        "content": "```go\\nfunc search(nums []int, target int) int {\\n    left, right := 0, len(nums) - 1\\n\\n    for left <= right {\\n        mid := left + (right - left) >> 1\\n        \\n        if nums[mid] > target {\\n            right = mid\\n        } else if nums[mid] < target {\\n            left = mid\\n        } else {\\n            return mid\\n        }\\n    }\\n\\n    return -1\\n}\\n```\\n\\nCan anyone tell me why the above code will cause TLE but if I put `-1` and `+1` to right/left assignment it will AC?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because without -1 , +1, your code is wrong."
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n\\n         int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid; // Target found\\n            } else if (nums[mid] < target) {\\n                left = mid + 1; // Adjust the left boundary\\n            } else {\\n                right = mid - 1; // Adjust the right boundary\\n            }\\n        }\\n\\n        return -1; // Target not found\\n    }\\n}"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the problem?"
                    }
                ]
            },
            {
                "id": 2061347,
                "content": [
                    {
                        "username": "wisdomkhan",
                        "content": "I did the binary search same as the one in solution but still runtime is 43ms. Is there some optimised way to do binary search?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Binary search is already the optimized method."
                    },
                    {
                        "username": "shvkhzod",
                        "content": "why would you use binary search for the arrays with the length of 2 or less"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is a test case to check ,if your algorithm can handle it."
                    },
                    {
                        "username": "delphington",
                        "content": "Perfect."
                    },
                    {
                        "username": "AllwinJohnson",
                        "content": "this is not the proper solution for the problem but still I just wanted to post. \\nuse a Binary Search while implementing a solution for this. \\n\\n\\n`return if(arr.toList().contains(target)) arr.toList().indexOf(target) else -1`\\n\\n ~kotlin"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the runtime of this compared to a manually implemented binary search?"
                    },
                    {
                        "username": "Aayush003",
                        "content": "Line 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().search(param_1, param_2);\\n                    ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\nwhat to do with this ?\\n"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nMinimum Path Sum (Grid)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "hairloss",
                        "content": "it takes 700 problem, to meet our beloved friend binary search"
                    },
                    {
                        "username": "ar3s1337",
                        "content": "```go\\nfunc search(nums []int, target int) int {\\n    left, right := 0, len(nums) - 1\\n\\n    for left <= right {\\n        mid := left + (right - left) >> 1\\n        \\n        if nums[mid] > target {\\n            right = mid\\n        } else if nums[mid] < target {\\n            left = mid\\n        } else {\\n            return mid\\n        }\\n    }\\n\\n    return -1\\n}\\n```\\n\\nCan anyone tell me why the above code will cause TLE but if I put `-1` and `+1` to right/left assignment it will AC?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because without -1 , +1, your code is wrong."
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n\\n         int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid; // Target found\\n            } else if (nums[mid] < target) {\\n                left = mid + 1; // Adjust the left boundary\\n            } else {\\n                right = mid - 1; // Adjust the right boundary\\n            }\\n        }\\n\\n        return -1; // Target not found\\n    }\\n}"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the problem?"
                    }
                ]
            },
            {
                "id": 2056605,
                "content": [
                    {
                        "username": "wisdomkhan",
                        "content": "I did the binary search same as the one in solution but still runtime is 43ms. Is there some optimised way to do binary search?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Binary search is already the optimized method."
                    },
                    {
                        "username": "shvkhzod",
                        "content": "why would you use binary search for the arrays with the length of 2 or less"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is a test case to check ,if your algorithm can handle it."
                    },
                    {
                        "username": "delphington",
                        "content": "Perfect."
                    },
                    {
                        "username": "AllwinJohnson",
                        "content": "this is not the proper solution for the problem but still I just wanted to post. \\nuse a Binary Search while implementing a solution for this. \\n\\n\\n`return if(arr.toList().contains(target)) arr.toList().indexOf(target) else -1`\\n\\n ~kotlin"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the runtime of this compared to a manually implemented binary search?"
                    },
                    {
                        "username": "Aayush003",
                        "content": "Line 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().search(param_1, param_2);\\n                    ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\nwhat to do with this ?\\n"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nMinimum Path Sum (Grid)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "hairloss",
                        "content": "it takes 700 problem, to meet our beloved friend binary search"
                    },
                    {
                        "username": "ar3s1337",
                        "content": "```go\\nfunc search(nums []int, target int) int {\\n    left, right := 0, len(nums) - 1\\n\\n    for left <= right {\\n        mid := left + (right - left) >> 1\\n        \\n        if nums[mid] > target {\\n            right = mid\\n        } else if nums[mid] < target {\\n            left = mid\\n        } else {\\n            return mid\\n        }\\n    }\\n\\n    return -1\\n}\\n```\\n\\nCan anyone tell me why the above code will cause TLE but if I put `-1` and `+1` to right/left assignment it will AC?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because without -1 , +1, your code is wrong."
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n\\n         int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid; // Target found\\n            } else if (nums[mid] < target) {\\n                left = mid + 1; // Adjust the left boundary\\n            } else {\\n                right = mid - 1; // Adjust the right boundary\\n            }\\n        }\\n\\n        return -1; // Target not found\\n    }\\n}"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the problem?"
                    }
                ]
            },
            {
                "id": 2049415,
                "content": [
                    {
                        "username": "wisdomkhan",
                        "content": "I did the binary search same as the one in solution but still runtime is 43ms. Is there some optimised way to do binary search?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Binary search is already the optimized method."
                    },
                    {
                        "username": "shvkhzod",
                        "content": "why would you use binary search for the arrays with the length of 2 or less"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "It is a test case to check ,if your algorithm can handle it."
                    },
                    {
                        "username": "delphington",
                        "content": "Perfect."
                    },
                    {
                        "username": "AllwinJohnson",
                        "content": "this is not the proper solution for the problem but still I just wanted to post. \\nuse a Binary Search while implementing a solution for this. \\n\\n\\n`return if(arr.toList().contains(target)) arr.toList().indexOf(target) else -1`\\n\\n ~kotlin"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the runtime of this compared to a manually implemented binary search?"
                    },
                    {
                        "username": "Aayush003",
                        "content": "Line 7: error: cannot find symbol [in __Driver__.java]\\n      int ret = new Solution().search(param_1, param_2);\\n                    ^\\n  symbol:   class Solution\\n  location: class __DriverSolution__\\n\\nwhat to do with this ?\\n"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nMinimum Path Sum (Grid)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "kanukolanuManjith",
                        "content": " [@Ashnu B](/Ashnu_B)\\n\\nclass Solution {\\npublic:\\nint m,n;\\nint minPathSum(vector<vector>& grid) {\\nint a=1000;\\nm=grid.size();\\nn=grid[0].size();\\npathSum(grid,0,0,0,a);\\nreturn a;\\n}\\nvoid pathSum(vector<vector>& grid,int i,int j,int k,int &a)\\n{\\nif(i==m && j==n)\\n{\\na=min(a,k);\\nreturn ;\\n}\\nif(i==m || j==n)\\n{\\nreturn ;\\n}\\nk=k+grid[i][j];\\npathSum(grid,i,j+1,k,a);\\npathSum(grid,i+1,j,k,a);\\n}\\n};\\n\\ncan anyone tell what goes wrong in code. please!!!!!!!!!!!!!!!"
                    },
                    {
                        "username": "hairloss",
                        "content": "it takes 700 problem, to meet our beloved friend binary search"
                    },
                    {
                        "username": "ar3s1337",
                        "content": "```go\\nfunc search(nums []int, target int) int {\\n    left, right := 0, len(nums) - 1\\n\\n    for left <= right {\\n        mid := left + (right - left) >> 1\\n        \\n        if nums[mid] > target {\\n            right = mid\\n        } else if nums[mid] < target {\\n            left = mid\\n        } else {\\n            return mid\\n        }\\n    }\\n\\n    return -1\\n}\\n```\\n\\nCan anyone tell me why the above code will cause TLE but if I put `-1` and `+1` to right/left assignment it will AC?"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "Because without -1 , +1, your code is wrong."
                    },
                    {
                        "username": "rounakkumar0018",
                        "content": "\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n\\n         int left = 0;\\n        int right = nums.length - 1;\\n\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (nums[mid] == target) {\\n                return mid; // Target found\\n            } else if (nums[mid] < target) {\\n                left = mid + 1; // Adjust the left boundary\\n            } else {\\n                right = mid - 1; // Adjust the right boundary\\n            }\\n        }\\n\\n        return -1; // Target not found\\n    }\\n}"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "What is the problem?"
                    }
                ]
            },
            {
                "id": 2039935,
                "content": [
                    {
                        "username": "vinogradov-m",
                        "content": "I believe it\\'s worth mentioning in the task description, that the number list is guaranteed to be strictly increasing (i.e. it doesn\\'t contain duplicates). "
                    },
                    {
                        "username": "learner0904",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums)\\n        while (left<= right):\\n            mid = (left + right)//2\\n            if(nums[mid] == target):\\n                return mid\\n            if(nums[mid] < target):\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1 \\n\\nThe above code is passing for 15 testcases but failing afterwards with runtime error saying list index out of range in line if(nums[mid] == target):. Can someone help in letting me know what\\'s wrong with this line?"
                    },
                    {
                        "username": "fa21bscs0030",
                        "content": "Class-1: https://youtu.be/lpj289CbCgg\\nCheck complete C++ course Playlist: \\nhttps://www.youtube.com/playlist?list=PLOx6r18dj7b25JCFE-00Trl3XzG1U5tr8"
                    },
                    {
                        "username": "Jyothiswaroop18",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        lo, hi =0, len(nums)-1\\n        while lo<=hi:\\n            mid = lo+hi//2\\n            mid_number = nums[mid]\\n            if mid_number== target:\\n                return mid\\n            elif mid_number>target:\\n                hi = mid-1\\n            elif mid_number<target:\\n                lo = mid+1\\n        return -1\\n\\n\\n\\ncan you pls tell why this code is returning time limit exceeded"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\n    private:\\n     int binaryserach(vector<int>&arr, int s , int e , int k){\\n          if(s>e){\\n            return -1;\\n        }\\n            int mid = s+(e-s)/2;\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(arr[mid] <k){\\n            return  binaryserach(arr,mid+1 , e , k);\\n        }\\n        else{\\n            return  binaryserach(arr,s,mid-1,k);\\n        }\\n        \\n           \\n     }\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int ans =   binaryserach(nums,0,n-1,target);\\n         return ans;\\n    }\\n   \\n};\\nBinary serach using recursion\\n"
                    },
                    {
                        "username": "IGabeh",
                        "content": "**Compile Error**\\nLine 30: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)\\nLine 36: Char 6: syntax error: unexpected main, expecting ( (solution.go)"
                    },
                    {
                        "username": "Kunal_697",
                        "content": "why it is not accepting if i use size = sizeof(nums)/sizeof(nums[0]) to find the size?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is one of simplest question in coding"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero programmer."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "i don't understand why i am getting issue in such a esay problem of negative number test case number 42"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "easy but u need to implement a binary search algorithm if u want to learn"
                    }
                ]
            },
            {
                "id": 2036069,
                "content": [
                    {
                        "username": "vinogradov-m",
                        "content": "I believe it\\'s worth mentioning in the task description, that the number list is guaranteed to be strictly increasing (i.e. it doesn\\'t contain duplicates). "
                    },
                    {
                        "username": "learner0904",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums)\\n        while (left<= right):\\n            mid = (left + right)//2\\n            if(nums[mid] == target):\\n                return mid\\n            if(nums[mid] < target):\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1 \\n\\nThe above code is passing for 15 testcases but failing afterwards with runtime error saying list index out of range in line if(nums[mid] == target):. Can someone help in letting me know what\\'s wrong with this line?"
                    },
                    {
                        "username": "fa21bscs0030",
                        "content": "Class-1: https://youtu.be/lpj289CbCgg\\nCheck complete C++ course Playlist: \\nhttps://www.youtube.com/playlist?list=PLOx6r18dj7b25JCFE-00Trl3XzG1U5tr8"
                    },
                    {
                        "username": "Jyothiswaroop18",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        lo, hi =0, len(nums)-1\\n        while lo<=hi:\\n            mid = lo+hi//2\\n            mid_number = nums[mid]\\n            if mid_number== target:\\n                return mid\\n            elif mid_number>target:\\n                hi = mid-1\\n            elif mid_number<target:\\n                lo = mid+1\\n        return -1\\n\\n\\n\\ncan you pls tell why this code is returning time limit exceeded"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\n    private:\\n     int binaryserach(vector<int>&arr, int s , int e , int k){\\n          if(s>e){\\n            return -1;\\n        }\\n            int mid = s+(e-s)/2;\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(arr[mid] <k){\\n            return  binaryserach(arr,mid+1 , e , k);\\n        }\\n        else{\\n            return  binaryserach(arr,s,mid-1,k);\\n        }\\n        \\n           \\n     }\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int ans =   binaryserach(nums,0,n-1,target);\\n         return ans;\\n    }\\n   \\n};\\nBinary serach using recursion\\n"
                    },
                    {
                        "username": "IGabeh",
                        "content": "**Compile Error**\\nLine 30: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)\\nLine 36: Char 6: syntax error: unexpected main, expecting ( (solution.go)"
                    },
                    {
                        "username": "Kunal_697",
                        "content": "why it is not accepting if i use size = sizeof(nums)/sizeof(nums[0]) to find the size?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is one of simplest question in coding"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero programmer."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "i don't understand why i am getting issue in such a esay problem of negative number test case number 42"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "easy but u need to implement a binary search algorithm if u want to learn"
                    }
                ]
            },
            {
                "id": 2023194,
                "content": [
                    {
                        "username": "vinogradov-m",
                        "content": "I believe it\\'s worth mentioning in the task description, that the number list is guaranteed to be strictly increasing (i.e. it doesn\\'t contain duplicates). "
                    },
                    {
                        "username": "learner0904",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums)\\n        while (left<= right):\\n            mid = (left + right)//2\\n            if(nums[mid] == target):\\n                return mid\\n            if(nums[mid] < target):\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1 \\n\\nThe above code is passing for 15 testcases but failing afterwards with runtime error saying list index out of range in line if(nums[mid] == target):. Can someone help in letting me know what\\'s wrong with this line?"
                    },
                    {
                        "username": "fa21bscs0030",
                        "content": "Class-1: https://youtu.be/lpj289CbCgg\\nCheck complete C++ course Playlist: \\nhttps://www.youtube.com/playlist?list=PLOx6r18dj7b25JCFE-00Trl3XzG1U5tr8"
                    },
                    {
                        "username": "Jyothiswaroop18",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        lo, hi =0, len(nums)-1\\n        while lo<=hi:\\n            mid = lo+hi//2\\n            mid_number = nums[mid]\\n            if mid_number== target:\\n                return mid\\n            elif mid_number>target:\\n                hi = mid-1\\n            elif mid_number<target:\\n                lo = mid+1\\n        return -1\\n\\n\\n\\ncan you pls tell why this code is returning time limit exceeded"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\n    private:\\n     int binaryserach(vector<int>&arr, int s , int e , int k){\\n          if(s>e){\\n            return -1;\\n        }\\n            int mid = s+(e-s)/2;\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(arr[mid] <k){\\n            return  binaryserach(arr,mid+1 , e , k);\\n        }\\n        else{\\n            return  binaryserach(arr,s,mid-1,k);\\n        }\\n        \\n           \\n     }\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int ans =   binaryserach(nums,0,n-1,target);\\n         return ans;\\n    }\\n   \\n};\\nBinary serach using recursion\\n"
                    },
                    {
                        "username": "IGabeh",
                        "content": "**Compile Error**\\nLine 30: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)\\nLine 36: Char 6: syntax error: unexpected main, expecting ( (solution.go)"
                    },
                    {
                        "username": "Kunal_697",
                        "content": "why it is not accepting if i use size = sizeof(nums)/sizeof(nums[0]) to find the size?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is one of simplest question in coding"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero programmer."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "i don't understand why i am getting issue in such a esay problem of negative number test case number 42"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "easy but u need to implement a binary search algorithm if u want to learn"
                    }
                ]
            },
            {
                "id": 1997215,
                "content": [
                    {
                        "username": "vinogradov-m",
                        "content": "I believe it\\'s worth mentioning in the task description, that the number list is guaranteed to be strictly increasing (i.e. it doesn\\'t contain duplicates). "
                    },
                    {
                        "username": "learner0904",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums)\\n        while (left<= right):\\n            mid = (left + right)//2\\n            if(nums[mid] == target):\\n                return mid\\n            if(nums[mid] < target):\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1 \\n\\nThe above code is passing for 15 testcases but failing afterwards with runtime error saying list index out of range in line if(nums[mid] == target):. Can someone help in letting me know what\\'s wrong with this line?"
                    },
                    {
                        "username": "fa21bscs0030",
                        "content": "Class-1: https://youtu.be/lpj289CbCgg\\nCheck complete C++ course Playlist: \\nhttps://www.youtube.com/playlist?list=PLOx6r18dj7b25JCFE-00Trl3XzG1U5tr8"
                    },
                    {
                        "username": "Jyothiswaroop18",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        lo, hi =0, len(nums)-1\\n        while lo<=hi:\\n            mid = lo+hi//2\\n            mid_number = nums[mid]\\n            if mid_number== target:\\n                return mid\\n            elif mid_number>target:\\n                hi = mid-1\\n            elif mid_number<target:\\n                lo = mid+1\\n        return -1\\n\\n\\n\\ncan you pls tell why this code is returning time limit exceeded"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\n    private:\\n     int binaryserach(vector<int>&arr, int s , int e , int k){\\n          if(s>e){\\n            return -1;\\n        }\\n            int mid = s+(e-s)/2;\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(arr[mid] <k){\\n            return  binaryserach(arr,mid+1 , e , k);\\n        }\\n        else{\\n            return  binaryserach(arr,s,mid-1,k);\\n        }\\n        \\n           \\n     }\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int ans =   binaryserach(nums,0,n-1,target);\\n         return ans;\\n    }\\n   \\n};\\nBinary serach using recursion\\n"
                    },
                    {
                        "username": "IGabeh",
                        "content": "**Compile Error**\\nLine 30: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)\\nLine 36: Char 6: syntax error: unexpected main, expecting ( (solution.go)"
                    },
                    {
                        "username": "Kunal_697",
                        "content": "why it is not accepting if i use size = sizeof(nums)/sizeof(nums[0]) to find the size?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is one of simplest question in coding"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero programmer."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "i don't understand why i am getting issue in such a esay problem of negative number test case number 42"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "easy but u need to implement a binary search algorithm if u want to learn"
                    }
                ]
            },
            {
                "id": 1989845,
                "content": [
                    {
                        "username": "vinogradov-m",
                        "content": "I believe it\\'s worth mentioning in the task description, that the number list is guaranteed to be strictly increasing (i.e. it doesn\\'t contain duplicates). "
                    },
                    {
                        "username": "learner0904",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums)\\n        while (left<= right):\\n            mid = (left + right)//2\\n            if(nums[mid] == target):\\n                return mid\\n            if(nums[mid] < target):\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1 \\n\\nThe above code is passing for 15 testcases but failing afterwards with runtime error saying list index out of range in line if(nums[mid] == target):. Can someone help in letting me know what\\'s wrong with this line?"
                    },
                    {
                        "username": "fa21bscs0030",
                        "content": "Class-1: https://youtu.be/lpj289CbCgg\\nCheck complete C++ course Playlist: \\nhttps://www.youtube.com/playlist?list=PLOx6r18dj7b25JCFE-00Trl3XzG1U5tr8"
                    },
                    {
                        "username": "Jyothiswaroop18",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        lo, hi =0, len(nums)-1\\n        while lo<=hi:\\n            mid = lo+hi//2\\n            mid_number = nums[mid]\\n            if mid_number== target:\\n                return mid\\n            elif mid_number>target:\\n                hi = mid-1\\n            elif mid_number<target:\\n                lo = mid+1\\n        return -1\\n\\n\\n\\ncan you pls tell why this code is returning time limit exceeded"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\n    private:\\n     int binaryserach(vector<int>&arr, int s , int e , int k){\\n          if(s>e){\\n            return -1;\\n        }\\n            int mid = s+(e-s)/2;\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(arr[mid] <k){\\n            return  binaryserach(arr,mid+1 , e , k);\\n        }\\n        else{\\n            return  binaryserach(arr,s,mid-1,k);\\n        }\\n        \\n           \\n     }\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int ans =   binaryserach(nums,0,n-1,target);\\n         return ans;\\n    }\\n   \\n};\\nBinary serach using recursion\\n"
                    },
                    {
                        "username": "IGabeh",
                        "content": "**Compile Error**\\nLine 30: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)\\nLine 36: Char 6: syntax error: unexpected main, expecting ( (solution.go)"
                    },
                    {
                        "username": "Kunal_697",
                        "content": "why it is not accepting if i use size = sizeof(nums)/sizeof(nums[0]) to find the size?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is one of simplest question in coding"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero programmer."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "i don't understand why i am getting issue in such a esay problem of negative number test case number 42"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "easy but u need to implement a binary search algorithm if u want to learn"
                    }
                ]
            },
            {
                "id": 1989481,
                "content": [
                    {
                        "username": "vinogradov-m",
                        "content": "I believe it\\'s worth mentioning in the task description, that the number list is guaranteed to be strictly increasing (i.e. it doesn\\'t contain duplicates). "
                    },
                    {
                        "username": "learner0904",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums)\\n        while (left<= right):\\n            mid = (left + right)//2\\n            if(nums[mid] == target):\\n                return mid\\n            if(nums[mid] < target):\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1 \\n\\nThe above code is passing for 15 testcases but failing afterwards with runtime error saying list index out of range in line if(nums[mid] == target):. Can someone help in letting me know what\\'s wrong with this line?"
                    },
                    {
                        "username": "fa21bscs0030",
                        "content": "Class-1: https://youtu.be/lpj289CbCgg\\nCheck complete C++ course Playlist: \\nhttps://www.youtube.com/playlist?list=PLOx6r18dj7b25JCFE-00Trl3XzG1U5tr8"
                    },
                    {
                        "username": "Jyothiswaroop18",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        lo, hi =0, len(nums)-1\\n        while lo<=hi:\\n            mid = lo+hi//2\\n            mid_number = nums[mid]\\n            if mid_number== target:\\n                return mid\\n            elif mid_number>target:\\n                hi = mid-1\\n            elif mid_number<target:\\n                lo = mid+1\\n        return -1\\n\\n\\n\\ncan you pls tell why this code is returning time limit exceeded"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\n    private:\\n     int binaryserach(vector<int>&arr, int s , int e , int k){\\n          if(s>e){\\n            return -1;\\n        }\\n            int mid = s+(e-s)/2;\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(arr[mid] <k){\\n            return  binaryserach(arr,mid+1 , e , k);\\n        }\\n        else{\\n            return  binaryserach(arr,s,mid-1,k);\\n        }\\n        \\n           \\n     }\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int ans =   binaryserach(nums,0,n-1,target);\\n         return ans;\\n    }\\n   \\n};\\nBinary serach using recursion\\n"
                    },
                    {
                        "username": "IGabeh",
                        "content": "**Compile Error**\\nLine 30: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)\\nLine 36: Char 6: syntax error: unexpected main, expecting ( (solution.go)"
                    },
                    {
                        "username": "Kunal_697",
                        "content": "why it is not accepting if i use size = sizeof(nums)/sizeof(nums[0]) to find the size?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is one of simplest question in coding"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero programmer."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "i don't understand why i am getting issue in such a esay problem of negative number test case number 42"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "easy but u need to implement a binary search algorithm if u want to learn"
                    }
                ]
            },
            {
                "id": 1982551,
                "content": [
                    {
                        "username": "vinogradov-m",
                        "content": "I believe it\\'s worth mentioning in the task description, that the number list is guaranteed to be strictly increasing (i.e. it doesn\\'t contain duplicates). "
                    },
                    {
                        "username": "learner0904",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums)\\n        while (left<= right):\\n            mid = (left + right)//2\\n            if(nums[mid] == target):\\n                return mid\\n            if(nums[mid] < target):\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1 \\n\\nThe above code is passing for 15 testcases but failing afterwards with runtime error saying list index out of range in line if(nums[mid] == target):. Can someone help in letting me know what\\'s wrong with this line?"
                    },
                    {
                        "username": "fa21bscs0030",
                        "content": "Class-1: https://youtu.be/lpj289CbCgg\\nCheck complete C++ course Playlist: \\nhttps://www.youtube.com/playlist?list=PLOx6r18dj7b25JCFE-00Trl3XzG1U5tr8"
                    },
                    {
                        "username": "Jyothiswaroop18",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        lo, hi =0, len(nums)-1\\n        while lo<=hi:\\n            mid = lo+hi//2\\n            mid_number = nums[mid]\\n            if mid_number== target:\\n                return mid\\n            elif mid_number>target:\\n                hi = mid-1\\n            elif mid_number<target:\\n                lo = mid+1\\n        return -1\\n\\n\\n\\ncan you pls tell why this code is returning time limit exceeded"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\n    private:\\n     int binaryserach(vector<int>&arr, int s , int e , int k){\\n          if(s>e){\\n            return -1;\\n        }\\n            int mid = s+(e-s)/2;\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(arr[mid] <k){\\n            return  binaryserach(arr,mid+1 , e , k);\\n        }\\n        else{\\n            return  binaryserach(arr,s,mid-1,k);\\n        }\\n        \\n           \\n     }\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int ans =   binaryserach(nums,0,n-1,target);\\n         return ans;\\n    }\\n   \\n};\\nBinary serach using recursion\\n"
                    },
                    {
                        "username": "IGabeh",
                        "content": "**Compile Error**\\nLine 30: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)\\nLine 36: Char 6: syntax error: unexpected main, expecting ( (solution.go)"
                    },
                    {
                        "username": "Kunal_697",
                        "content": "why it is not accepting if i use size = sizeof(nums)/sizeof(nums[0]) to find the size?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is one of simplest question in coding"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero programmer."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "i don't understand why i am getting issue in such a esay problem of negative number test case number 42"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "easy but u need to implement a binary search algorithm if u want to learn"
                    }
                ]
            },
            {
                "id": 1975106,
                "content": [
                    {
                        "username": "vinogradov-m",
                        "content": "I believe it\\'s worth mentioning in the task description, that the number list is guaranteed to be strictly increasing (i.e. it doesn\\'t contain duplicates). "
                    },
                    {
                        "username": "learner0904",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums)\\n        while (left<= right):\\n            mid = (left + right)//2\\n            if(nums[mid] == target):\\n                return mid\\n            if(nums[mid] < target):\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1 \\n\\nThe above code is passing for 15 testcases but failing afterwards with runtime error saying list index out of range in line if(nums[mid] == target):. Can someone help in letting me know what\\'s wrong with this line?"
                    },
                    {
                        "username": "fa21bscs0030",
                        "content": "Class-1: https://youtu.be/lpj289CbCgg\\nCheck complete C++ course Playlist: \\nhttps://www.youtube.com/playlist?list=PLOx6r18dj7b25JCFE-00Trl3XzG1U5tr8"
                    },
                    {
                        "username": "Jyothiswaroop18",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        lo, hi =0, len(nums)-1\\n        while lo<=hi:\\n            mid = lo+hi//2\\n            mid_number = nums[mid]\\n            if mid_number== target:\\n                return mid\\n            elif mid_number>target:\\n                hi = mid-1\\n            elif mid_number<target:\\n                lo = mid+1\\n        return -1\\n\\n\\n\\ncan you pls tell why this code is returning time limit exceeded"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\n    private:\\n     int binaryserach(vector<int>&arr, int s , int e , int k){\\n          if(s>e){\\n            return -1;\\n        }\\n            int mid = s+(e-s)/2;\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(arr[mid] <k){\\n            return  binaryserach(arr,mid+1 , e , k);\\n        }\\n        else{\\n            return  binaryserach(arr,s,mid-1,k);\\n        }\\n        \\n           \\n     }\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int ans =   binaryserach(nums,0,n-1,target);\\n         return ans;\\n    }\\n   \\n};\\nBinary serach using recursion\\n"
                    },
                    {
                        "username": "IGabeh",
                        "content": "**Compile Error**\\nLine 30: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)\\nLine 36: Char 6: syntax error: unexpected main, expecting ( (solution.go)"
                    },
                    {
                        "username": "Kunal_697",
                        "content": "why it is not accepting if i use size = sizeof(nums)/sizeof(nums[0]) to find the size?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is one of simplest question in coding"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero programmer."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "i don't understand why i am getting issue in such a esay problem of negative number test case number 42"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "easy but u need to implement a binary search algorithm if u want to learn"
                    }
                ]
            },
            {
                "id": 1950852,
                "content": [
                    {
                        "username": "vinogradov-m",
                        "content": "I believe it\\'s worth mentioning in the task description, that the number list is guaranteed to be strictly increasing (i.e. it doesn\\'t contain duplicates). "
                    },
                    {
                        "username": "learner0904",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums)\\n        while (left<= right):\\n            mid = (left + right)//2\\n            if(nums[mid] == target):\\n                return mid\\n            if(nums[mid] < target):\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1 \\n\\nThe above code is passing for 15 testcases but failing afterwards with runtime error saying list index out of range in line if(nums[mid] == target):. Can someone help in letting me know what\\'s wrong with this line?"
                    },
                    {
                        "username": "fa21bscs0030",
                        "content": "Class-1: https://youtu.be/lpj289CbCgg\\nCheck complete C++ course Playlist: \\nhttps://www.youtube.com/playlist?list=PLOx6r18dj7b25JCFE-00Trl3XzG1U5tr8"
                    },
                    {
                        "username": "Jyothiswaroop18",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        lo, hi =0, len(nums)-1\\n        while lo<=hi:\\n            mid = lo+hi//2\\n            mid_number = nums[mid]\\n            if mid_number== target:\\n                return mid\\n            elif mid_number>target:\\n                hi = mid-1\\n            elif mid_number<target:\\n                lo = mid+1\\n        return -1\\n\\n\\n\\ncan you pls tell why this code is returning time limit exceeded"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\n    private:\\n     int binaryserach(vector<int>&arr, int s , int e , int k){\\n          if(s>e){\\n            return -1;\\n        }\\n            int mid = s+(e-s)/2;\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(arr[mid] <k){\\n            return  binaryserach(arr,mid+1 , e , k);\\n        }\\n        else{\\n            return  binaryserach(arr,s,mid-1,k);\\n        }\\n        \\n           \\n     }\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int ans =   binaryserach(nums,0,n-1,target);\\n         return ans;\\n    }\\n   \\n};\\nBinary serach using recursion\\n"
                    },
                    {
                        "username": "IGabeh",
                        "content": "**Compile Error**\\nLine 30: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)\\nLine 36: Char 6: syntax error: unexpected main, expecting ( (solution.go)"
                    },
                    {
                        "username": "Kunal_697",
                        "content": "why it is not accepting if i use size = sizeof(nums)/sizeof(nums[0]) to find the size?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is one of simplest question in coding"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero programmer."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "i don't understand why i am getting issue in such a esay problem of negative number test case number 42"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "easy but u need to implement a binary search algorithm if u want to learn"
                    }
                ]
            },
            {
                "id": 1949377,
                "content": [
                    {
                        "username": "vinogradov-m",
                        "content": "I believe it\\'s worth mentioning in the task description, that the number list is guaranteed to be strictly increasing (i.e. it doesn\\'t contain duplicates). "
                    },
                    {
                        "username": "learner0904",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        left = 0\\n        right = len(nums)\\n        while (left<= right):\\n            mid = (left + right)//2\\n            if(nums[mid] == target):\\n                return mid\\n            if(nums[mid] < target):\\n                left = mid + 1\\n            else:\\n                right = mid - 1\\n        return -1 \\n\\nThe above code is passing for 15 testcases but failing afterwards with runtime error saying list index out of range in line if(nums[mid] == target):. Can someone help in letting me know what\\'s wrong with this line?"
                    },
                    {
                        "username": "fa21bscs0030",
                        "content": "Class-1: https://youtu.be/lpj289CbCgg\\nCheck complete C++ course Playlist: \\nhttps://www.youtube.com/playlist?list=PLOx6r18dj7b25JCFE-00Trl3XzG1U5tr8"
                    },
                    {
                        "username": "Jyothiswaroop18",
                        "content": "class Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        lo, hi =0, len(nums)-1\\n        while lo<=hi:\\n            mid = lo+hi//2\\n            mid_number = nums[mid]\\n            if mid_number== target:\\n                return mid\\n            elif mid_number>target:\\n                hi = mid-1\\n            elif mid_number<target:\\n                lo = mid+1\\n        return -1\\n\\n\\n\\ncan you pls tell why this code is returning time limit exceeded"
                    },
                    {
                        "username": "kumkumsisodiya9630",
                        "content": "class Solution {\\n    private:\\n     int binaryserach(vector<int>&arr, int s , int e , int k){\\n          if(s>e){\\n            return -1;\\n        }\\n            int mid = s+(e-s)/2;\\n        if(arr[mid] == k){\\n            return mid;\\n        }\\n        else if(arr[mid] <k){\\n            return  binaryserach(arr,mid+1 , e , k);\\n        }\\n        else{\\n            return  binaryserach(arr,s,mid-1,k);\\n        }\\n        \\n           \\n     }\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int n = nums.size();\\n        int ans =   binaryserach(nums,0,n-1,target);\\n         return ans;\\n    }\\n   \\n};\\nBinary serach using recursion\\n"
                    },
                    {
                        "username": "IGabeh",
                        "content": "**Compile Error**\\nLine 30: Char 6: syntax error: unexpected __helper__, expecting ( (solution.go)\\nLine 36: Char 6: syntax error: unexpected main, expecting ( (solution.go)"
                    },
                    {
                        "username": "Kunal_697",
                        "content": "why it is not accepting if i use size = sizeof(nums)/sizeof(nums[0]) to find the size?"
                    },
                    {
                        "username": "Harshsharma12",
                        "content": "This is one of simplest question in coding"
                    },
                    {
                        "username": "Tom_Dev",
                        "content": "You are a hero programmer."
                    },
                    {
                        "username": "swapnils_leetcode",
                        "content": "i don't understand why i am getting issue in such a esay problem of negative number test case number 42"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "easy but u need to implement a binary search algorithm if u want to learn"
                    }
                ]
            },
            {
                "id": 1949171,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "Leetcode was easy on us today...(sob)"
                    },
                    {
                        "username": "marciobernardes39",
                        "content": "FYI: I`ve spent too many time to understand that was not my code it was wrong, it was the misunderstanding of left and right xp"
                    },
                    {
                        "username": "stutigoel96",
                        "content": "Use built in functions in java, it will be lot easier"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "yes but u will not learn"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nclass Solution {\\n    int helper(int []nums,int target,int start,int end){\\n        if(start>end){\\n            return -1;\\n        }\\n        int mid=start+end;\\n        mid=mid/2;\\n        if(target==nums[mid]){\\n            return mid;\\n        }else if(nums[mid]>target){\\n            return helper(nums,target,start,mid-1);\\n        }else{\\n            return helper(nums,target,mid+1,end);\\n        }\\n    }\\n    public int search(int[] nums, int target) {\\n        return helper(nums,target,0,nums.length-1);\\n    }\\n}\\n` "
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Say \"binary search\" without \"binary search\", lol "
                    },
                    {
                        "username": "singh_3662",
                        "content": "Today, the beginners can also complete today\\'s streak."
                    },
                    {
                        "username": "greeneyed",
                        "content": "Firstly, I thought it is April Fool\\'s joke after 3 hard ones in a row"
                    },
                    {
                        "username": "serinsabu",
                        "content": "Wow, really happy with this problem today\\uD83E\\uDD73"
                    },
                    {
                        "username": "ashish0401",
                        "content": "Finally a problem of my level"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Search week incoming!"
                    }
                ]
            },
            {
                "id": 1917184,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "Leetcode was easy on us today...(sob)"
                    },
                    {
                        "username": "marciobernardes39",
                        "content": "FYI: I`ve spent too many time to understand that was not my code it was wrong, it was the misunderstanding of left and right xp"
                    },
                    {
                        "username": "stutigoel96",
                        "content": "Use built in functions in java, it will be lot easier"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "yes but u will not learn"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nclass Solution {\\n    int helper(int []nums,int target,int start,int end){\\n        if(start>end){\\n            return -1;\\n        }\\n        int mid=start+end;\\n        mid=mid/2;\\n        if(target==nums[mid]){\\n            return mid;\\n        }else if(nums[mid]>target){\\n            return helper(nums,target,start,mid-1);\\n        }else{\\n            return helper(nums,target,mid+1,end);\\n        }\\n    }\\n    public int search(int[] nums, int target) {\\n        return helper(nums,target,0,nums.length-1);\\n    }\\n}\\n` "
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Say \"binary search\" without \"binary search\", lol "
                    },
                    {
                        "username": "singh_3662",
                        "content": "Today, the beginners can also complete today\\'s streak."
                    },
                    {
                        "username": "greeneyed",
                        "content": "Firstly, I thought it is April Fool\\'s joke after 3 hard ones in a row"
                    },
                    {
                        "username": "serinsabu",
                        "content": "Wow, really happy with this problem today\\uD83E\\uDD73"
                    },
                    {
                        "username": "ashish0401",
                        "content": "Finally a problem of my level"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Search week incoming!"
                    }
                ]
            },
            {
                "id": 1857691,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "Leetcode was easy on us today...(sob)"
                    },
                    {
                        "username": "marciobernardes39",
                        "content": "FYI: I`ve spent too many time to understand that was not my code it was wrong, it was the misunderstanding of left and right xp"
                    },
                    {
                        "username": "stutigoel96",
                        "content": "Use built in functions in java, it will be lot easier"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "yes but u will not learn"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nclass Solution {\\n    int helper(int []nums,int target,int start,int end){\\n        if(start>end){\\n            return -1;\\n        }\\n        int mid=start+end;\\n        mid=mid/2;\\n        if(target==nums[mid]){\\n            return mid;\\n        }else if(nums[mid]>target){\\n            return helper(nums,target,start,mid-1);\\n        }else{\\n            return helper(nums,target,mid+1,end);\\n        }\\n    }\\n    public int search(int[] nums, int target) {\\n        return helper(nums,target,0,nums.length-1);\\n    }\\n}\\n` "
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Say \"binary search\" without \"binary search\", lol "
                    },
                    {
                        "username": "singh_3662",
                        "content": "Today, the beginners can also complete today\\'s streak."
                    },
                    {
                        "username": "greeneyed",
                        "content": "Firstly, I thought it is April Fool\\'s joke after 3 hard ones in a row"
                    },
                    {
                        "username": "serinsabu",
                        "content": "Wow, really happy with this problem today\\uD83E\\uDD73"
                    },
                    {
                        "username": "ashish0401",
                        "content": "Finally a problem of my level"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Search week incoming!"
                    }
                ]
            },
            {
                "id": 1850166,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "Leetcode was easy on us today...(sob)"
                    },
                    {
                        "username": "marciobernardes39",
                        "content": "FYI: I`ve spent too many time to understand that was not my code it was wrong, it was the misunderstanding of left and right xp"
                    },
                    {
                        "username": "stutigoel96",
                        "content": "Use built in functions in java, it will be lot easier"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "yes but u will not learn"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nclass Solution {\\n    int helper(int []nums,int target,int start,int end){\\n        if(start>end){\\n            return -1;\\n        }\\n        int mid=start+end;\\n        mid=mid/2;\\n        if(target==nums[mid]){\\n            return mid;\\n        }else if(nums[mid]>target){\\n            return helper(nums,target,start,mid-1);\\n        }else{\\n            return helper(nums,target,mid+1,end);\\n        }\\n    }\\n    public int search(int[] nums, int target) {\\n        return helper(nums,target,0,nums.length-1);\\n    }\\n}\\n` "
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Say \"binary search\" without \"binary search\", lol "
                    },
                    {
                        "username": "singh_3662",
                        "content": "Today, the beginners can also complete today\\'s streak."
                    },
                    {
                        "username": "greeneyed",
                        "content": "Firstly, I thought it is April Fool\\'s joke after 3 hard ones in a row"
                    },
                    {
                        "username": "serinsabu",
                        "content": "Wow, really happy with this problem today\\uD83E\\uDD73"
                    },
                    {
                        "username": "ashish0401",
                        "content": "Finally a problem of my level"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Search week incoming!"
                    }
                ]
            },
            {
                "id": 1850150,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "Leetcode was easy on us today...(sob)"
                    },
                    {
                        "username": "marciobernardes39",
                        "content": "FYI: I`ve spent too many time to understand that was not my code it was wrong, it was the misunderstanding of left and right xp"
                    },
                    {
                        "username": "stutigoel96",
                        "content": "Use built in functions in java, it will be lot easier"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "yes but u will not learn"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nclass Solution {\\n    int helper(int []nums,int target,int start,int end){\\n        if(start>end){\\n            return -1;\\n        }\\n        int mid=start+end;\\n        mid=mid/2;\\n        if(target==nums[mid]){\\n            return mid;\\n        }else if(nums[mid]>target){\\n            return helper(nums,target,start,mid-1);\\n        }else{\\n            return helper(nums,target,mid+1,end);\\n        }\\n    }\\n    public int search(int[] nums, int target) {\\n        return helper(nums,target,0,nums.length-1);\\n    }\\n}\\n` "
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Say \"binary search\" without \"binary search\", lol "
                    },
                    {
                        "username": "singh_3662",
                        "content": "Today, the beginners can also complete today\\'s streak."
                    },
                    {
                        "username": "greeneyed",
                        "content": "Firstly, I thought it is April Fool\\'s joke after 3 hard ones in a row"
                    },
                    {
                        "username": "serinsabu",
                        "content": "Wow, really happy with this problem today\\uD83E\\uDD73"
                    },
                    {
                        "username": "ashish0401",
                        "content": "Finally a problem of my level"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Search week incoming!"
                    }
                ]
            },
            {
                "id": 1850131,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "Leetcode was easy on us today...(sob)"
                    },
                    {
                        "username": "marciobernardes39",
                        "content": "FYI: I`ve spent too many time to understand that was not my code it was wrong, it was the misunderstanding of left and right xp"
                    },
                    {
                        "username": "stutigoel96",
                        "content": "Use built in functions in java, it will be lot easier"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "yes but u will not learn"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nclass Solution {\\n    int helper(int []nums,int target,int start,int end){\\n        if(start>end){\\n            return -1;\\n        }\\n        int mid=start+end;\\n        mid=mid/2;\\n        if(target==nums[mid]){\\n            return mid;\\n        }else if(nums[mid]>target){\\n            return helper(nums,target,start,mid-1);\\n        }else{\\n            return helper(nums,target,mid+1,end);\\n        }\\n    }\\n    public int search(int[] nums, int target) {\\n        return helper(nums,target,0,nums.length-1);\\n    }\\n}\\n` "
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Say \"binary search\" without \"binary search\", lol "
                    },
                    {
                        "username": "singh_3662",
                        "content": "Today, the beginners can also complete today\\'s streak."
                    },
                    {
                        "username": "greeneyed",
                        "content": "Firstly, I thought it is April Fool\\'s joke after 3 hard ones in a row"
                    },
                    {
                        "username": "serinsabu",
                        "content": "Wow, really happy with this problem today\\uD83E\\uDD73"
                    },
                    {
                        "username": "ashish0401",
                        "content": "Finally a problem of my level"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Search week incoming!"
                    }
                ]
            },
            {
                "id": 1849993,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "Leetcode was easy on us today...(sob)"
                    },
                    {
                        "username": "marciobernardes39",
                        "content": "FYI: I`ve spent too many time to understand that was not my code it was wrong, it was the misunderstanding of left and right xp"
                    },
                    {
                        "username": "stutigoel96",
                        "content": "Use built in functions in java, it will be lot easier"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "yes but u will not learn"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nclass Solution {\\n    int helper(int []nums,int target,int start,int end){\\n        if(start>end){\\n            return -1;\\n        }\\n        int mid=start+end;\\n        mid=mid/2;\\n        if(target==nums[mid]){\\n            return mid;\\n        }else if(nums[mid]>target){\\n            return helper(nums,target,start,mid-1);\\n        }else{\\n            return helper(nums,target,mid+1,end);\\n        }\\n    }\\n    public int search(int[] nums, int target) {\\n        return helper(nums,target,0,nums.length-1);\\n    }\\n}\\n` "
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Say \"binary search\" without \"binary search\", lol "
                    },
                    {
                        "username": "singh_3662",
                        "content": "Today, the beginners can also complete today\\'s streak."
                    },
                    {
                        "username": "greeneyed",
                        "content": "Firstly, I thought it is April Fool\\'s joke after 3 hard ones in a row"
                    },
                    {
                        "username": "serinsabu",
                        "content": "Wow, really happy with this problem today\\uD83E\\uDD73"
                    },
                    {
                        "username": "ashish0401",
                        "content": "Finally a problem of my level"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Search week incoming!"
                    }
                ]
            },
            {
                "id": 1849988,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "Leetcode was easy on us today...(sob)"
                    },
                    {
                        "username": "marciobernardes39",
                        "content": "FYI: I`ve spent too many time to understand that was not my code it was wrong, it was the misunderstanding of left and right xp"
                    },
                    {
                        "username": "stutigoel96",
                        "content": "Use built in functions in java, it will be lot easier"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "yes but u will not learn"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nclass Solution {\\n    int helper(int []nums,int target,int start,int end){\\n        if(start>end){\\n            return -1;\\n        }\\n        int mid=start+end;\\n        mid=mid/2;\\n        if(target==nums[mid]){\\n            return mid;\\n        }else if(nums[mid]>target){\\n            return helper(nums,target,start,mid-1);\\n        }else{\\n            return helper(nums,target,mid+1,end);\\n        }\\n    }\\n    public int search(int[] nums, int target) {\\n        return helper(nums,target,0,nums.length-1);\\n    }\\n}\\n` "
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Say \"binary search\" without \"binary search\", lol "
                    },
                    {
                        "username": "singh_3662",
                        "content": "Today, the beginners can also complete today\\'s streak."
                    },
                    {
                        "username": "greeneyed",
                        "content": "Firstly, I thought it is April Fool\\'s joke after 3 hard ones in a row"
                    },
                    {
                        "username": "serinsabu",
                        "content": "Wow, really happy with this problem today\\uD83E\\uDD73"
                    },
                    {
                        "username": "ashish0401",
                        "content": "Finally a problem of my level"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Search week incoming!"
                    }
                ]
            },
            {
                "id": 1849977,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "Leetcode was easy on us today...(sob)"
                    },
                    {
                        "username": "marciobernardes39",
                        "content": "FYI: I`ve spent too many time to understand that was not my code it was wrong, it was the misunderstanding of left and right xp"
                    },
                    {
                        "username": "stutigoel96",
                        "content": "Use built in functions in java, it will be lot easier"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "yes but u will not learn"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nclass Solution {\\n    int helper(int []nums,int target,int start,int end){\\n        if(start>end){\\n            return -1;\\n        }\\n        int mid=start+end;\\n        mid=mid/2;\\n        if(target==nums[mid]){\\n            return mid;\\n        }else if(nums[mid]>target){\\n            return helper(nums,target,start,mid-1);\\n        }else{\\n            return helper(nums,target,mid+1,end);\\n        }\\n    }\\n    public int search(int[] nums, int target) {\\n        return helper(nums,target,0,nums.length-1);\\n    }\\n}\\n` "
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Say \"binary search\" without \"binary search\", lol "
                    },
                    {
                        "username": "singh_3662",
                        "content": "Today, the beginners can also complete today\\'s streak."
                    },
                    {
                        "username": "greeneyed",
                        "content": "Firstly, I thought it is April Fool\\'s joke after 3 hard ones in a row"
                    },
                    {
                        "username": "serinsabu",
                        "content": "Wow, really happy with this problem today\\uD83E\\uDD73"
                    },
                    {
                        "username": "ashish0401",
                        "content": "Finally a problem of my level"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Search week incoming!"
                    }
                ]
            },
            {
                "id": 1849957,
                "content": [
                    {
                        "username": "HeatOn123",
                        "content": "Leetcode was easy on us today...(sob)"
                    },
                    {
                        "username": "marciobernardes39",
                        "content": "FYI: I`ve spent too many time to understand that was not my code it was wrong, it was the misunderstanding of left and right xp"
                    },
                    {
                        "username": "stutigoel96",
                        "content": "Use built in functions in java, it will be lot easier"
                    },
                    {
                        "username": "HeatOn123",
                        "content": "yes but u will not learn"
                    },
                    {
                        "username": "teckyshubham",
                        "content": " `\\nclass Solution {\\n    int helper(int []nums,int target,int start,int end){\\n        if(start>end){\\n            return -1;\\n        }\\n        int mid=start+end;\\n        mid=mid/2;\\n        if(target==nums[mid]){\\n            return mid;\\n        }else if(nums[mid]>target){\\n            return helper(nums,target,start,mid-1);\\n        }else{\\n            return helper(nums,target,mid+1,end);\\n        }\\n    }\\n    public int search(int[] nums, int target) {\\n        return helper(nums,target,0,nums.length-1);\\n    }\\n}\\n` "
                    },
                    {
                        "username": "FrontEndDeveloping",
                        "content": "Say \"binary search\" without \"binary search\", lol "
                    },
                    {
                        "username": "singh_3662",
                        "content": "Today, the beginners can also complete today\\'s streak."
                    },
                    {
                        "username": "greeneyed",
                        "content": "Firstly, I thought it is April Fool\\'s joke after 3 hard ones in a row"
                    },
                    {
                        "username": "serinsabu",
                        "content": "Wow, really happy with this problem today\\uD83E\\uDD73"
                    },
                    {
                        "username": "ashish0401",
                        "content": "Finally a problem of my level"
                    },
                    {
                        "username": "s1ttu",
                        "content": "Binary Search week incoming!"
                    }
                ]
            },
            {
                "id": 1849932,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**thank u for EASY problem**"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Ahh I see! End the month with 3 hard Q.s but start next month with an extremely easy one... 🫡"
                    },
                    {
                        "username": "umar2002zaib",
                        "content": "It made day!"
                    },
                    {
                        "username": "user7478F",
                        "content": "The pure weekend vibe\\n\\nLeetcode after giving multiple HARD=\"Galti se Mistake hogya tha\""
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Feels like solving Div4A problem after 3 consecutive Div2F POTD\\'s."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just really liked that they made me do dp problems , cause I such at them, and really wanted to get better at them, though I was not able to solve them fully (prev 2 days) on my own, but I now have a better understanding of dp so, that\\'s a plus."
                    },
                    {
                        "username": "daring-calf",
                        "content": "So long DP, howdy binary search!"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "\nA Recursive🤔 & iterative✌️ Solution\nhttps://leetcode.com/problems/binary-search/solutions/3364302/a-recursive-iterative-solution/"
                    },
                    {
                        "username": "vetor",
                        "content": "finally hope it isnt april fool "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "After consecutive days of hard problems , I think we deserve this warrior rest. Thank you LeetCode!"
                    }
                ]
            },
            {
                "id": 1849883,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**thank u for EASY problem**"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Ahh I see! End the month with 3 hard Q.s but start next month with an extremely easy one... 🫡"
                    },
                    {
                        "username": "umar2002zaib",
                        "content": "It made day!"
                    },
                    {
                        "username": "user7478F",
                        "content": "The pure weekend vibe\\n\\nLeetcode after giving multiple HARD=\"Galti se Mistake hogya tha\""
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Feels like solving Div4A problem after 3 consecutive Div2F POTD\\'s."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just really liked that they made me do dp problems , cause I such at them, and really wanted to get better at them, though I was not able to solve them fully (prev 2 days) on my own, but I now have a better understanding of dp so, that\\'s a plus."
                    },
                    {
                        "username": "daring-calf",
                        "content": "So long DP, howdy binary search!"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "\nA Recursive🤔 & iterative✌️ Solution\nhttps://leetcode.com/problems/binary-search/solutions/3364302/a-recursive-iterative-solution/"
                    },
                    {
                        "username": "vetor",
                        "content": "finally hope it isnt april fool "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "After consecutive days of hard problems , I think we deserve this warrior rest. Thank you LeetCode!"
                    }
                ]
            },
            {
                "id": 1849877,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**thank u for EASY problem**"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Ahh I see! End the month with 3 hard Q.s but start next month with an extremely easy one... 🫡"
                    },
                    {
                        "username": "umar2002zaib",
                        "content": "It made day!"
                    },
                    {
                        "username": "user7478F",
                        "content": "The pure weekend vibe\\n\\nLeetcode after giving multiple HARD=\"Galti se Mistake hogya tha\""
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Feels like solving Div4A problem after 3 consecutive Div2F POTD\\'s."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just really liked that they made me do dp problems , cause I such at them, and really wanted to get better at them, though I was not able to solve them fully (prev 2 days) on my own, but I now have a better understanding of dp so, that\\'s a plus."
                    },
                    {
                        "username": "daring-calf",
                        "content": "So long DP, howdy binary search!"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "\nA Recursive🤔 & iterative✌️ Solution\nhttps://leetcode.com/problems/binary-search/solutions/3364302/a-recursive-iterative-solution/"
                    },
                    {
                        "username": "vetor",
                        "content": "finally hope it isnt april fool "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "After consecutive days of hard problems , I think we deserve this warrior rest. Thank you LeetCode!"
                    }
                ]
            },
            {
                "id": 1849870,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**thank u for EASY problem**"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Ahh I see! End the month with 3 hard Q.s but start next month with an extremely easy one... 🫡"
                    },
                    {
                        "username": "umar2002zaib",
                        "content": "It made day!"
                    },
                    {
                        "username": "user7478F",
                        "content": "The pure weekend vibe\\n\\nLeetcode after giving multiple HARD=\"Galti se Mistake hogya tha\""
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Feels like solving Div4A problem after 3 consecutive Div2F POTD\\'s."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just really liked that they made me do dp problems , cause I such at them, and really wanted to get better at them, though I was not able to solve them fully (prev 2 days) on my own, but I now have a better understanding of dp so, that\\'s a plus."
                    },
                    {
                        "username": "daring-calf",
                        "content": "So long DP, howdy binary search!"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "\nA Recursive🤔 & iterative✌️ Solution\nhttps://leetcode.com/problems/binary-search/solutions/3364302/a-recursive-iterative-solution/"
                    },
                    {
                        "username": "vetor",
                        "content": "finally hope it isnt april fool "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "After consecutive days of hard problems , I think we deserve this warrior rest. Thank you LeetCode!"
                    }
                ]
            },
            {
                "id": 1849854,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**thank u for EASY problem**"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Ahh I see! End the month with 3 hard Q.s but start next month with an extremely easy one... 🫡"
                    },
                    {
                        "username": "umar2002zaib",
                        "content": "It made day!"
                    },
                    {
                        "username": "user7478F",
                        "content": "The pure weekend vibe\\n\\nLeetcode after giving multiple HARD=\"Galti se Mistake hogya tha\""
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Feels like solving Div4A problem after 3 consecutive Div2F POTD\\'s."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just really liked that they made me do dp problems , cause I such at them, and really wanted to get better at them, though I was not able to solve them fully (prev 2 days) on my own, but I now have a better understanding of dp so, that\\'s a plus."
                    },
                    {
                        "username": "daring-calf",
                        "content": "So long DP, howdy binary search!"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "\nA Recursive🤔 & iterative✌️ Solution\nhttps://leetcode.com/problems/binary-search/solutions/3364302/a-recursive-iterative-solution/"
                    },
                    {
                        "username": "vetor",
                        "content": "finally hope it isnt april fool "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "After consecutive days of hard problems , I think we deserve this warrior rest. Thank you LeetCode!"
                    }
                ]
            },
            {
                "id": 1849846,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**thank u for EASY problem**"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Ahh I see! End the month with 3 hard Q.s but start next month with an extremely easy one... 🫡"
                    },
                    {
                        "username": "umar2002zaib",
                        "content": "It made day!"
                    },
                    {
                        "username": "user7478F",
                        "content": "The pure weekend vibe\\n\\nLeetcode after giving multiple HARD=\"Galti se Mistake hogya tha\""
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Feels like solving Div4A problem after 3 consecutive Div2F POTD\\'s."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just really liked that they made me do dp problems , cause I such at them, and really wanted to get better at them, though I was not able to solve them fully (prev 2 days) on my own, but I now have a better understanding of dp so, that\\'s a plus."
                    },
                    {
                        "username": "daring-calf",
                        "content": "So long DP, howdy binary search!"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "\nA Recursive🤔 & iterative✌️ Solution\nhttps://leetcode.com/problems/binary-search/solutions/3364302/a-recursive-iterative-solution/"
                    },
                    {
                        "username": "vetor",
                        "content": "finally hope it isnt april fool "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "After consecutive days of hard problems , I think we deserve this warrior rest. Thank you LeetCode!"
                    }
                ]
            },
            {
                "id": 1849826,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**thank u for EASY problem**"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Ahh I see! End the month with 3 hard Q.s but start next month with an extremely easy one... 🫡"
                    },
                    {
                        "username": "umar2002zaib",
                        "content": "It made day!"
                    },
                    {
                        "username": "user7478F",
                        "content": "The pure weekend vibe\\n\\nLeetcode after giving multiple HARD=\"Galti se Mistake hogya tha\""
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Feels like solving Div4A problem after 3 consecutive Div2F POTD\\'s."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just really liked that they made me do dp problems , cause I such at them, and really wanted to get better at them, though I was not able to solve them fully (prev 2 days) on my own, but I now have a better understanding of dp so, that\\'s a plus."
                    },
                    {
                        "username": "daring-calf",
                        "content": "So long DP, howdy binary search!"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "\nA Recursive🤔 & iterative✌️ Solution\nhttps://leetcode.com/problems/binary-search/solutions/3364302/a-recursive-iterative-solution/"
                    },
                    {
                        "username": "vetor",
                        "content": "finally hope it isnt april fool "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "After consecutive days of hard problems , I think we deserve this warrior rest. Thank you LeetCode!"
                    }
                ]
            },
            {
                "id": 1849810,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**thank u for EASY problem**"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Ahh I see! End the month with 3 hard Q.s but start next month with an extremely easy one... 🫡"
                    },
                    {
                        "username": "umar2002zaib",
                        "content": "It made day!"
                    },
                    {
                        "username": "user7478F",
                        "content": "The pure weekend vibe\\n\\nLeetcode after giving multiple HARD=\"Galti se Mistake hogya tha\""
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Feels like solving Div4A problem after 3 consecutive Div2F POTD\\'s."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just really liked that they made me do dp problems , cause I such at them, and really wanted to get better at them, though I was not able to solve them fully (prev 2 days) on my own, but I now have a better understanding of dp so, that\\'s a plus."
                    },
                    {
                        "username": "daring-calf",
                        "content": "So long DP, howdy binary search!"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "\nA Recursive🤔 & iterative✌️ Solution\nhttps://leetcode.com/problems/binary-search/solutions/3364302/a-recursive-iterative-solution/"
                    },
                    {
                        "username": "vetor",
                        "content": "finally hope it isnt april fool "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "After consecutive days of hard problems , I think we deserve this warrior rest. Thank you LeetCode!"
                    }
                ]
            },
            {
                "id": 1849749,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**thank u for EASY problem**"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Ahh I see! End the month with 3 hard Q.s but start next month with an extremely easy one... 🫡"
                    },
                    {
                        "username": "umar2002zaib",
                        "content": "It made day!"
                    },
                    {
                        "username": "user7478F",
                        "content": "The pure weekend vibe\\n\\nLeetcode after giving multiple HARD=\"Galti se Mistake hogya tha\""
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Feels like solving Div4A problem after 3 consecutive Div2F POTD\\'s."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just really liked that they made me do dp problems , cause I such at them, and really wanted to get better at them, though I was not able to solve them fully (prev 2 days) on my own, but I now have a better understanding of dp so, that\\'s a plus."
                    },
                    {
                        "username": "daring-calf",
                        "content": "So long DP, howdy binary search!"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "\nA Recursive🤔 & iterative✌️ Solution\nhttps://leetcode.com/problems/binary-search/solutions/3364302/a-recursive-iterative-solution/"
                    },
                    {
                        "username": "vetor",
                        "content": "finally hope it isnt april fool "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "After consecutive days of hard problems , I think we deserve this warrior rest. Thank you LeetCode!"
                    }
                ]
            },
            {
                "id": 1849715,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "**thank u for EASY problem**"
                    },
                    {
                        "username": "AmeyDhimte",
                        "content": "Ahh I see! End the month with 3 hard Q.s but start next month with an extremely easy one... 🫡"
                    },
                    {
                        "username": "umar2002zaib",
                        "content": "It made day!"
                    },
                    {
                        "username": "user7478F",
                        "content": "The pure weekend vibe\\n\\nLeetcode after giving multiple HARD=\"Galti se Mistake hogya tha\""
                    },
                    {
                        "username": "psycho_pirate",
                        "content": "Feels like solving Div4A problem after 3 consecutive Div2F POTD\\'s."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I just really liked that they made me do dp problems , cause I such at them, and really wanted to get better at them, though I was not able to solve them fully (prev 2 days) on my own, but I now have a better understanding of dp so, that\\'s a plus."
                    },
                    {
                        "username": "daring-calf",
                        "content": "So long DP, howdy binary search!"
                    },
                    {
                        "username": "gulshanitsyou",
                        "content": "\nA Recursive🤔 & iterative✌️ Solution\nhttps://leetcode.com/problems/binary-search/solutions/3364302/a-recursive-iterative-solution/"
                    },
                    {
                        "username": "vetor",
                        "content": "finally hope it isnt april fool "
                    },
                    {
                        "username": "UchihaKim",
                        "content": "After consecutive days of hard problems , I think we deserve this warrior rest. Thank you LeetCode!"
                    }
                ]
            },
            {
                "id": 1843573,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "The tests should deny `indexOf` built-in method.\\n\\nThe solution must implemented with `O(log n)` runtime complexity."
                    },
                    {
                        "username": "mdavidn",
                        "content": "This is not possible with all of the languages, though the test cases could try a much larger array to check time complexity."
                    },
                    {
                        "username": "antoniogrosu",
                        "content": "Am I writing something wrong ?\\nC++  as I learnt it looks something like this \\n#include <iostream>\\nusing namespace std;\\nvoid binarySearch(int v[10001], int target)\\n{\\n\\tbool found = 0;\\n\\tint r = 0; [.... etc]\\ni see solutions are written really different ?\\nCan somebody explain to me what\\'s wrong with my code"
                    },
                    {
                        "username": "sri4",
                        "content": "My code is working fine on my laptop for a test cases 1,2. but for same test cases it is throwing time limit exceeded error on leetcode when i press RUN(not submit.) anyone help? TLE on submission can be understood but i\\'m getting TLE on run itself. i dont understand.\\n \\ndef search(self, nums, target):\\n        l=len(nums)\\n        i=(l//2)\\n        while(i>0 and i< l-1):\\n            if nums[i]==target:\\n                return i\\n            elif nums[i]> target:\\n                i=(i//2)\\n            else:\\n                i=(l+i)//2\\n        if((i==0 and nums[i]==target )or (i==l-1 and nums[i]==target)):\\n            return i\\n        return -1"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "This problem can be solve using devide and conquer method"
                    },
                    {
                        "username": "aar-rafi",
                        "content": "can someone explain me a little about the lowest runtime 0ms sample solution?"
                    },
                    {
                        "username": "bdaws",
                        "content": "I recognize that posting solutions here is discouraged, but why doesn\\'t this TypeScript solution work?\\n\\n```\\nfunction search(nums: number[], target: number): number {\\n    let seek = Math.floor((nums.length - 1)/2);\\n    while(seek >= 0 && seek <= nums.length - 1) {\\n        if(nums[seek] === target) {\\n            return seek;\\n        }\\n        if (nums[seek] > target){\\n            // The number we\\'re on is greater than the target,\\n            // meaning the target is earlier in the array,\\n            // if at all.\\n            seek = Math.floor(seek / 2);\\n        } else if(nums[seek] < target) {\\n            seek = seek * 2;\\n        }\\n    }\\n\\n    return -1;\\n};\\n```\\n\\nI get \"time limit exceeded\", despite the second iteration of the `while` loop finding `target` in the first test case. In LeetCode\\'s runner, it continues after this iteration. I added a log statement in the `if(nums[seek] === target)` block to verify it was evaluated. \\n\\nRunning it locally though, it works:\\n\\n```\\n# running with `console.log(search([-1,0,3,5,9,12], 9))` appended\\n\\u276F ts-node workplace/leetcode/typescript/foo.ts\\n4\\n```\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Imagine an array with the answer in the second quarter, like the fourth element in an array with length nine. `seek` in your solution will endlessly flip between the middle of the array and the end of the first quarter."
                    },
                    {
                        "username": "nileshk_",
                        "content": "can someone please explain why I am getting Time Limit Exceeded fir this code. \\n    ` \\n\\nint search(vector<int>& nums, int target) {  \\n\\n        int i = 0;  \\n        int j = nums.size()-1;  \\n        int ans = -1;\\n        while(i <= j) {\\n            int m = i + ((j-i)/2);\\n            if(nums[m] == target) ans = m;\\n            else if(target < nums[m]) j = m-1;\\n            else i = m+1;\\n        }\\n        return ans;\\n   `"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Once your loop finds the answer, it ceases to modify `i` or `j` and never satisfies its exit condition."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "can some one help me where am i going wrong i cant get output\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start=0;\\n       int end=nums.length-1;\\n       \\n       while(start<=end){\\n           int mid= (end-start)+start/ 2;\\n           if(nums[mid]<target){\\n               end=mid-1;\\n\\n           }\\n           else if(nums[mid]==target){\\n               return target;\\n           }\\n           else{\\n               start=mid+1;\\n               mid= (end-start)+start/ 2;\\n           }\\n        \\n       } \\n return -1; \\n    }\\n} "
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "[@Praveena_V](/Praveena_V) \nVery welcome. I hope you were able to figure it out :)\n\nUseful rule of thumb:\nCheck edge cases/stop conditions first, then check to determine what to do for next  step."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "[@hashimjacobs](/hashimjacobs)  thank you so much for answering, I always go wrong in these conditions and loops how to improve it"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Praveena_V](/Praveena_V),\n\nI ran your solution and I see a couple issues. \n\n1. ***Take a closer look at your conditional statements where you are determining what to set *start* and *end* to.*** It may be easier to see if you ***invert the conditional statements***, comparing *target* to whatever value. So the order would be in which the statement is written is *target, operator, value at mid*.\n\n2. ***Double-check what you are setting *mid* to.*** You are subtracting *start* from *end*, then adding *start* back to *end*, which negates *start* throughout the entire loop, so you will keep getting the same value for *mid*. What operation can be done to make sure that mid varies?\n\n3. ***Should the while loop stop if start == end?*** What if the target is in the last index?\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "devcode98",
                        "content": "Guys, can you help me where I am going wrong, my bs() functions is getting called again and again\\n\\n\\n\\n\\n\\nclass Solution:\\n\\n    def bs(self,nums,left,right,target)-> int:\\n\\n        mid = int((left + right)/2)\\n        if nums[mid]==target:\\n            print(\\'Finally The Condition matched\\')\\n            return int(mid)\\n        if target < nums[mid]:\\n            # The number would be present in the Left Half of the Array\\n            print(\\'Moving towards the LHS of the array\\')\\n            val = self.bs(nums,left,mid-1,target)\\n            return val\\n        elif target > nums[mid]:\\n            print(\\'Moving to the RHS of the array\\')\\n            val = self.bs(nums,mid+1,right,target)\\n            print(\\'The valu received from the RHS array is\\')\\n            print(val)\\n            return val\\n        return -1\\n\\n\\n    def search(self, nums: List[int], target: int) -> int:\\n\\n        left = 0\\n        right = len(nums)-1\\n        print(\\'invoking the external Function\\')\\n        incoming_value = self.bs(nums,left,right,target)\\n        print(\\'THe Incoming value received from the function is\\')\\n        print(incoming_value)\\n\\n        return incoming_value"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Devang Nayar](/devcode98),\nI reproduced your error and then found the issue. The issue is that you are not determining if ***the target does not exist*** in time. Here's a hint: ***Figure out how and where to check that the target does not exist and return -1.***  It might also help your debugging if you remove redundant comments, print statements, and variables. It will help you focus on the code and keep it clean. If you want to keep the print statements, you can compress two into one using formatting. See below for an example on how Python3 formatting works.\n\n```\nprint(f\"Nums: {nums}\")\nprint(f\"Left: {left}\")\nprint(f\"Right: {right}\")\nprint(f\"Target: {target}\")\n\ntarget_index = self.bs(nums, left, right, target)\nprint(f\"The target index is {target_index}\")\n```\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "Rajeswari21",
                        "content": "I m getting an error for len() function  => \\n\\n\"TypeError: object of type \\'NoneType\\' has no len()\\n    high= len(nums)-1\\nLine 6 in search (Solution.py)\\n    ret = Solution().search(param_1, param_2)\\nLine 46 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\"\\n\\n\\nMay I know what will be the reason?\\nProgramming Language: Python"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Rajeswari21](/Rajeswari21),\\n\\nCould you please share the rest of your solution? It\\'s difficult to determine the issue with one line of code.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1834014,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "The tests should deny `indexOf` built-in method.\\n\\nThe solution must implemented with `O(log n)` runtime complexity."
                    },
                    {
                        "username": "mdavidn",
                        "content": "This is not possible with all of the languages, though the test cases could try a much larger array to check time complexity."
                    },
                    {
                        "username": "antoniogrosu",
                        "content": "Am I writing something wrong ?\\nC++  as I learnt it looks something like this \\n#include <iostream>\\nusing namespace std;\\nvoid binarySearch(int v[10001], int target)\\n{\\n\\tbool found = 0;\\n\\tint r = 0; [.... etc]\\ni see solutions are written really different ?\\nCan somebody explain to me what\\'s wrong with my code"
                    },
                    {
                        "username": "sri4",
                        "content": "My code is working fine on my laptop for a test cases 1,2. but for same test cases it is throwing time limit exceeded error on leetcode when i press RUN(not submit.) anyone help? TLE on submission can be understood but i\\'m getting TLE on run itself. i dont understand.\\n \\ndef search(self, nums, target):\\n        l=len(nums)\\n        i=(l//2)\\n        while(i>0 and i< l-1):\\n            if nums[i]==target:\\n                return i\\n            elif nums[i]> target:\\n                i=(i//2)\\n            else:\\n                i=(l+i)//2\\n        if((i==0 and nums[i]==target )or (i==l-1 and nums[i]==target)):\\n            return i\\n        return -1"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "This problem can be solve using devide and conquer method"
                    },
                    {
                        "username": "aar-rafi",
                        "content": "can someone explain me a little about the lowest runtime 0ms sample solution?"
                    },
                    {
                        "username": "bdaws",
                        "content": "I recognize that posting solutions here is discouraged, but why doesn\\'t this TypeScript solution work?\\n\\n```\\nfunction search(nums: number[], target: number): number {\\n    let seek = Math.floor((nums.length - 1)/2);\\n    while(seek >= 0 && seek <= nums.length - 1) {\\n        if(nums[seek] === target) {\\n            return seek;\\n        }\\n        if (nums[seek] > target){\\n            // The number we\\'re on is greater than the target,\\n            // meaning the target is earlier in the array,\\n            // if at all.\\n            seek = Math.floor(seek / 2);\\n        } else if(nums[seek] < target) {\\n            seek = seek * 2;\\n        }\\n    }\\n\\n    return -1;\\n};\\n```\\n\\nI get \"time limit exceeded\", despite the second iteration of the `while` loop finding `target` in the first test case. In LeetCode\\'s runner, it continues after this iteration. I added a log statement in the `if(nums[seek] === target)` block to verify it was evaluated. \\n\\nRunning it locally though, it works:\\n\\n```\\n# running with `console.log(search([-1,0,3,5,9,12], 9))` appended\\n\\u276F ts-node workplace/leetcode/typescript/foo.ts\\n4\\n```\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Imagine an array with the answer in the second quarter, like the fourth element in an array with length nine. `seek` in your solution will endlessly flip between the middle of the array and the end of the first quarter."
                    },
                    {
                        "username": "nileshk_",
                        "content": "can someone please explain why I am getting Time Limit Exceeded fir this code. \\n    ` \\n\\nint search(vector<int>& nums, int target) {  \\n\\n        int i = 0;  \\n        int j = nums.size()-1;  \\n        int ans = -1;\\n        while(i <= j) {\\n            int m = i + ((j-i)/2);\\n            if(nums[m] == target) ans = m;\\n            else if(target < nums[m]) j = m-1;\\n            else i = m+1;\\n        }\\n        return ans;\\n   `"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Once your loop finds the answer, it ceases to modify `i` or `j` and never satisfies its exit condition."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "can some one help me where am i going wrong i cant get output\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start=0;\\n       int end=nums.length-1;\\n       \\n       while(start<=end){\\n           int mid= (end-start)+start/ 2;\\n           if(nums[mid]<target){\\n               end=mid-1;\\n\\n           }\\n           else if(nums[mid]==target){\\n               return target;\\n           }\\n           else{\\n               start=mid+1;\\n               mid= (end-start)+start/ 2;\\n           }\\n        \\n       } \\n return -1; \\n    }\\n} "
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "[@Praveena_V](/Praveena_V) \nVery welcome. I hope you were able to figure it out :)\n\nUseful rule of thumb:\nCheck edge cases/stop conditions first, then check to determine what to do for next  step."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "[@hashimjacobs](/hashimjacobs)  thank you so much for answering, I always go wrong in these conditions and loops how to improve it"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Praveena_V](/Praveena_V),\n\nI ran your solution and I see a couple issues. \n\n1. ***Take a closer look at your conditional statements where you are determining what to set *start* and *end* to.*** It may be easier to see if you ***invert the conditional statements***, comparing *target* to whatever value. So the order would be in which the statement is written is *target, operator, value at mid*.\n\n2. ***Double-check what you are setting *mid* to.*** You are subtracting *start* from *end*, then adding *start* back to *end*, which negates *start* throughout the entire loop, so you will keep getting the same value for *mid*. What operation can be done to make sure that mid varies?\n\n3. ***Should the while loop stop if start == end?*** What if the target is in the last index?\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "devcode98",
                        "content": "Guys, can you help me where I am going wrong, my bs() functions is getting called again and again\\n\\n\\n\\n\\n\\nclass Solution:\\n\\n    def bs(self,nums,left,right,target)-> int:\\n\\n        mid = int((left + right)/2)\\n        if nums[mid]==target:\\n            print(\\'Finally The Condition matched\\')\\n            return int(mid)\\n        if target < nums[mid]:\\n            # The number would be present in the Left Half of the Array\\n            print(\\'Moving towards the LHS of the array\\')\\n            val = self.bs(nums,left,mid-1,target)\\n            return val\\n        elif target > nums[mid]:\\n            print(\\'Moving to the RHS of the array\\')\\n            val = self.bs(nums,mid+1,right,target)\\n            print(\\'The valu received from the RHS array is\\')\\n            print(val)\\n            return val\\n        return -1\\n\\n\\n    def search(self, nums: List[int], target: int) -> int:\\n\\n        left = 0\\n        right = len(nums)-1\\n        print(\\'invoking the external Function\\')\\n        incoming_value = self.bs(nums,left,right,target)\\n        print(\\'THe Incoming value received from the function is\\')\\n        print(incoming_value)\\n\\n        return incoming_value"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Devang Nayar](/devcode98),\nI reproduced your error and then found the issue. The issue is that you are not determining if ***the target does not exist*** in time. Here's a hint: ***Figure out how and where to check that the target does not exist and return -1.***  It might also help your debugging if you remove redundant comments, print statements, and variables. It will help you focus on the code and keep it clean. If you want to keep the print statements, you can compress two into one using formatting. See below for an example on how Python3 formatting works.\n\n```\nprint(f\"Nums: {nums}\")\nprint(f\"Left: {left}\")\nprint(f\"Right: {right}\")\nprint(f\"Target: {target}\")\n\ntarget_index = self.bs(nums, left, right, target)\nprint(f\"The target index is {target_index}\")\n```\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "Rajeswari21",
                        "content": "I m getting an error for len() function  => \\n\\n\"TypeError: object of type \\'NoneType\\' has no len()\\n    high= len(nums)-1\\nLine 6 in search (Solution.py)\\n    ret = Solution().search(param_1, param_2)\\nLine 46 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\"\\n\\n\\nMay I know what will be the reason?\\nProgramming Language: Python"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Rajeswari21](/Rajeswari21),\\n\\nCould you please share the rest of your solution? It\\'s difficult to determine the issue with one line of code.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1829929,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "The tests should deny `indexOf` built-in method.\\n\\nThe solution must implemented with `O(log n)` runtime complexity."
                    },
                    {
                        "username": "mdavidn",
                        "content": "This is not possible with all of the languages, though the test cases could try a much larger array to check time complexity."
                    },
                    {
                        "username": "antoniogrosu",
                        "content": "Am I writing something wrong ?\\nC++  as I learnt it looks something like this \\n#include <iostream>\\nusing namespace std;\\nvoid binarySearch(int v[10001], int target)\\n{\\n\\tbool found = 0;\\n\\tint r = 0; [.... etc]\\ni see solutions are written really different ?\\nCan somebody explain to me what\\'s wrong with my code"
                    },
                    {
                        "username": "sri4",
                        "content": "My code is working fine on my laptop for a test cases 1,2. but for same test cases it is throwing time limit exceeded error on leetcode when i press RUN(not submit.) anyone help? TLE on submission can be understood but i\\'m getting TLE on run itself. i dont understand.\\n \\ndef search(self, nums, target):\\n        l=len(nums)\\n        i=(l//2)\\n        while(i>0 and i< l-1):\\n            if nums[i]==target:\\n                return i\\n            elif nums[i]> target:\\n                i=(i//2)\\n            else:\\n                i=(l+i)//2\\n        if((i==0 and nums[i]==target )or (i==l-1 and nums[i]==target)):\\n            return i\\n        return -1"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "This problem can be solve using devide and conquer method"
                    },
                    {
                        "username": "aar-rafi",
                        "content": "can someone explain me a little about the lowest runtime 0ms sample solution?"
                    },
                    {
                        "username": "bdaws",
                        "content": "I recognize that posting solutions here is discouraged, but why doesn\\'t this TypeScript solution work?\\n\\n```\\nfunction search(nums: number[], target: number): number {\\n    let seek = Math.floor((nums.length - 1)/2);\\n    while(seek >= 0 && seek <= nums.length - 1) {\\n        if(nums[seek] === target) {\\n            return seek;\\n        }\\n        if (nums[seek] > target){\\n            // The number we\\'re on is greater than the target,\\n            // meaning the target is earlier in the array,\\n            // if at all.\\n            seek = Math.floor(seek / 2);\\n        } else if(nums[seek] < target) {\\n            seek = seek * 2;\\n        }\\n    }\\n\\n    return -1;\\n};\\n```\\n\\nI get \"time limit exceeded\", despite the second iteration of the `while` loop finding `target` in the first test case. In LeetCode\\'s runner, it continues after this iteration. I added a log statement in the `if(nums[seek] === target)` block to verify it was evaluated. \\n\\nRunning it locally though, it works:\\n\\n```\\n# running with `console.log(search([-1,0,3,5,9,12], 9))` appended\\n\\u276F ts-node workplace/leetcode/typescript/foo.ts\\n4\\n```\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Imagine an array with the answer in the second quarter, like the fourth element in an array with length nine. `seek` in your solution will endlessly flip between the middle of the array and the end of the first quarter."
                    },
                    {
                        "username": "nileshk_",
                        "content": "can someone please explain why I am getting Time Limit Exceeded fir this code. \\n    ` \\n\\nint search(vector<int>& nums, int target) {  \\n\\n        int i = 0;  \\n        int j = nums.size()-1;  \\n        int ans = -1;\\n        while(i <= j) {\\n            int m = i + ((j-i)/2);\\n            if(nums[m] == target) ans = m;\\n            else if(target < nums[m]) j = m-1;\\n            else i = m+1;\\n        }\\n        return ans;\\n   `"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Once your loop finds the answer, it ceases to modify `i` or `j` and never satisfies its exit condition."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "can some one help me where am i going wrong i cant get output\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start=0;\\n       int end=nums.length-1;\\n       \\n       while(start<=end){\\n           int mid= (end-start)+start/ 2;\\n           if(nums[mid]<target){\\n               end=mid-1;\\n\\n           }\\n           else if(nums[mid]==target){\\n               return target;\\n           }\\n           else{\\n               start=mid+1;\\n               mid= (end-start)+start/ 2;\\n           }\\n        \\n       } \\n return -1; \\n    }\\n} "
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "[@Praveena_V](/Praveena_V) \nVery welcome. I hope you were able to figure it out :)\n\nUseful rule of thumb:\nCheck edge cases/stop conditions first, then check to determine what to do for next  step."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "[@hashimjacobs](/hashimjacobs)  thank you so much for answering, I always go wrong in these conditions and loops how to improve it"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Praveena_V](/Praveena_V),\n\nI ran your solution and I see a couple issues. \n\n1. ***Take a closer look at your conditional statements where you are determining what to set *start* and *end* to.*** It may be easier to see if you ***invert the conditional statements***, comparing *target* to whatever value. So the order would be in which the statement is written is *target, operator, value at mid*.\n\n2. ***Double-check what you are setting *mid* to.*** You are subtracting *start* from *end*, then adding *start* back to *end*, which negates *start* throughout the entire loop, so you will keep getting the same value for *mid*. What operation can be done to make sure that mid varies?\n\n3. ***Should the while loop stop if start == end?*** What if the target is in the last index?\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "devcode98",
                        "content": "Guys, can you help me where I am going wrong, my bs() functions is getting called again and again\\n\\n\\n\\n\\n\\nclass Solution:\\n\\n    def bs(self,nums,left,right,target)-> int:\\n\\n        mid = int((left + right)/2)\\n        if nums[mid]==target:\\n            print(\\'Finally The Condition matched\\')\\n            return int(mid)\\n        if target < nums[mid]:\\n            # The number would be present in the Left Half of the Array\\n            print(\\'Moving towards the LHS of the array\\')\\n            val = self.bs(nums,left,mid-1,target)\\n            return val\\n        elif target > nums[mid]:\\n            print(\\'Moving to the RHS of the array\\')\\n            val = self.bs(nums,mid+1,right,target)\\n            print(\\'The valu received from the RHS array is\\')\\n            print(val)\\n            return val\\n        return -1\\n\\n\\n    def search(self, nums: List[int], target: int) -> int:\\n\\n        left = 0\\n        right = len(nums)-1\\n        print(\\'invoking the external Function\\')\\n        incoming_value = self.bs(nums,left,right,target)\\n        print(\\'THe Incoming value received from the function is\\')\\n        print(incoming_value)\\n\\n        return incoming_value"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Devang Nayar](/devcode98),\nI reproduced your error and then found the issue. The issue is that you are not determining if ***the target does not exist*** in time. Here's a hint: ***Figure out how and where to check that the target does not exist and return -1.***  It might also help your debugging if you remove redundant comments, print statements, and variables. It will help you focus on the code and keep it clean. If you want to keep the print statements, you can compress two into one using formatting. See below for an example on how Python3 formatting works.\n\n```\nprint(f\"Nums: {nums}\")\nprint(f\"Left: {left}\")\nprint(f\"Right: {right}\")\nprint(f\"Target: {target}\")\n\ntarget_index = self.bs(nums, left, right, target)\nprint(f\"The target index is {target_index}\")\n```\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "Rajeswari21",
                        "content": "I m getting an error for len() function  => \\n\\n\"TypeError: object of type \\'NoneType\\' has no len()\\n    high= len(nums)-1\\nLine 6 in search (Solution.py)\\n    ret = Solution().search(param_1, param_2)\\nLine 46 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\"\\n\\n\\nMay I know what will be the reason?\\nProgramming Language: Python"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Rajeswari21](/Rajeswari21),\\n\\nCould you please share the rest of your solution? It\\'s difficult to determine the issue with one line of code.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1828783,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "The tests should deny `indexOf` built-in method.\\n\\nThe solution must implemented with `O(log n)` runtime complexity."
                    },
                    {
                        "username": "mdavidn",
                        "content": "This is not possible with all of the languages, though the test cases could try a much larger array to check time complexity."
                    },
                    {
                        "username": "antoniogrosu",
                        "content": "Am I writing something wrong ?\\nC++  as I learnt it looks something like this \\n#include <iostream>\\nusing namespace std;\\nvoid binarySearch(int v[10001], int target)\\n{\\n\\tbool found = 0;\\n\\tint r = 0; [.... etc]\\ni see solutions are written really different ?\\nCan somebody explain to me what\\'s wrong with my code"
                    },
                    {
                        "username": "sri4",
                        "content": "My code is working fine on my laptop for a test cases 1,2. but for same test cases it is throwing time limit exceeded error on leetcode when i press RUN(not submit.) anyone help? TLE on submission can be understood but i\\'m getting TLE on run itself. i dont understand.\\n \\ndef search(self, nums, target):\\n        l=len(nums)\\n        i=(l//2)\\n        while(i>0 and i< l-1):\\n            if nums[i]==target:\\n                return i\\n            elif nums[i]> target:\\n                i=(i//2)\\n            else:\\n                i=(l+i)//2\\n        if((i==0 and nums[i]==target )or (i==l-1 and nums[i]==target)):\\n            return i\\n        return -1"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "This problem can be solve using devide and conquer method"
                    },
                    {
                        "username": "aar-rafi",
                        "content": "can someone explain me a little about the lowest runtime 0ms sample solution?"
                    },
                    {
                        "username": "bdaws",
                        "content": "I recognize that posting solutions here is discouraged, but why doesn\\'t this TypeScript solution work?\\n\\n```\\nfunction search(nums: number[], target: number): number {\\n    let seek = Math.floor((nums.length - 1)/2);\\n    while(seek >= 0 && seek <= nums.length - 1) {\\n        if(nums[seek] === target) {\\n            return seek;\\n        }\\n        if (nums[seek] > target){\\n            // The number we\\'re on is greater than the target,\\n            // meaning the target is earlier in the array,\\n            // if at all.\\n            seek = Math.floor(seek / 2);\\n        } else if(nums[seek] < target) {\\n            seek = seek * 2;\\n        }\\n    }\\n\\n    return -1;\\n};\\n```\\n\\nI get \"time limit exceeded\", despite the second iteration of the `while` loop finding `target` in the first test case. In LeetCode\\'s runner, it continues after this iteration. I added a log statement in the `if(nums[seek] === target)` block to verify it was evaluated. \\n\\nRunning it locally though, it works:\\n\\n```\\n# running with `console.log(search([-1,0,3,5,9,12], 9))` appended\\n\\u276F ts-node workplace/leetcode/typescript/foo.ts\\n4\\n```\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Imagine an array with the answer in the second quarter, like the fourth element in an array with length nine. `seek` in your solution will endlessly flip between the middle of the array and the end of the first quarter."
                    },
                    {
                        "username": "nileshk_",
                        "content": "can someone please explain why I am getting Time Limit Exceeded fir this code. \\n    ` \\n\\nint search(vector<int>& nums, int target) {  \\n\\n        int i = 0;  \\n        int j = nums.size()-1;  \\n        int ans = -1;\\n        while(i <= j) {\\n            int m = i + ((j-i)/2);\\n            if(nums[m] == target) ans = m;\\n            else if(target < nums[m]) j = m-1;\\n            else i = m+1;\\n        }\\n        return ans;\\n   `"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Once your loop finds the answer, it ceases to modify `i` or `j` and never satisfies its exit condition."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "can some one help me where am i going wrong i cant get output\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start=0;\\n       int end=nums.length-1;\\n       \\n       while(start<=end){\\n           int mid= (end-start)+start/ 2;\\n           if(nums[mid]<target){\\n               end=mid-1;\\n\\n           }\\n           else if(nums[mid]==target){\\n               return target;\\n           }\\n           else{\\n               start=mid+1;\\n               mid= (end-start)+start/ 2;\\n           }\\n        \\n       } \\n return -1; \\n    }\\n} "
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "[@Praveena_V](/Praveena_V) \nVery welcome. I hope you were able to figure it out :)\n\nUseful rule of thumb:\nCheck edge cases/stop conditions first, then check to determine what to do for next  step."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "[@hashimjacobs](/hashimjacobs)  thank you so much for answering, I always go wrong in these conditions and loops how to improve it"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Praveena_V](/Praveena_V),\n\nI ran your solution and I see a couple issues. \n\n1. ***Take a closer look at your conditional statements where you are determining what to set *start* and *end* to.*** It may be easier to see if you ***invert the conditional statements***, comparing *target* to whatever value. So the order would be in which the statement is written is *target, operator, value at mid*.\n\n2. ***Double-check what you are setting *mid* to.*** You are subtracting *start* from *end*, then adding *start* back to *end*, which negates *start* throughout the entire loop, so you will keep getting the same value for *mid*. What operation can be done to make sure that mid varies?\n\n3. ***Should the while loop stop if start == end?*** What if the target is in the last index?\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "devcode98",
                        "content": "Guys, can you help me where I am going wrong, my bs() functions is getting called again and again\\n\\n\\n\\n\\n\\nclass Solution:\\n\\n    def bs(self,nums,left,right,target)-> int:\\n\\n        mid = int((left + right)/2)\\n        if nums[mid]==target:\\n            print(\\'Finally The Condition matched\\')\\n            return int(mid)\\n        if target < nums[mid]:\\n            # The number would be present in the Left Half of the Array\\n            print(\\'Moving towards the LHS of the array\\')\\n            val = self.bs(nums,left,mid-1,target)\\n            return val\\n        elif target > nums[mid]:\\n            print(\\'Moving to the RHS of the array\\')\\n            val = self.bs(nums,mid+1,right,target)\\n            print(\\'The valu received from the RHS array is\\')\\n            print(val)\\n            return val\\n        return -1\\n\\n\\n    def search(self, nums: List[int], target: int) -> int:\\n\\n        left = 0\\n        right = len(nums)-1\\n        print(\\'invoking the external Function\\')\\n        incoming_value = self.bs(nums,left,right,target)\\n        print(\\'THe Incoming value received from the function is\\')\\n        print(incoming_value)\\n\\n        return incoming_value"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Devang Nayar](/devcode98),\nI reproduced your error and then found the issue. The issue is that you are not determining if ***the target does not exist*** in time. Here's a hint: ***Figure out how and where to check that the target does not exist and return -1.***  It might also help your debugging if you remove redundant comments, print statements, and variables. It will help you focus on the code and keep it clean. If you want to keep the print statements, you can compress two into one using formatting. See below for an example on how Python3 formatting works.\n\n```\nprint(f\"Nums: {nums}\")\nprint(f\"Left: {left}\")\nprint(f\"Right: {right}\")\nprint(f\"Target: {target}\")\n\ntarget_index = self.bs(nums, left, right, target)\nprint(f\"The target index is {target_index}\")\n```\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "Rajeswari21",
                        "content": "I m getting an error for len() function  => \\n\\n\"TypeError: object of type \\'NoneType\\' has no len()\\n    high= len(nums)-1\\nLine 6 in search (Solution.py)\\n    ret = Solution().search(param_1, param_2)\\nLine 46 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\"\\n\\n\\nMay I know what will be the reason?\\nProgramming Language: Python"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Rajeswari21](/Rajeswari21),\\n\\nCould you please share the rest of your solution? It\\'s difficult to determine the issue with one line of code.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1828324,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "The tests should deny `indexOf` built-in method.\\n\\nThe solution must implemented with `O(log n)` runtime complexity."
                    },
                    {
                        "username": "mdavidn",
                        "content": "This is not possible with all of the languages, though the test cases could try a much larger array to check time complexity."
                    },
                    {
                        "username": "antoniogrosu",
                        "content": "Am I writing something wrong ?\\nC++  as I learnt it looks something like this \\n#include <iostream>\\nusing namespace std;\\nvoid binarySearch(int v[10001], int target)\\n{\\n\\tbool found = 0;\\n\\tint r = 0; [.... etc]\\ni see solutions are written really different ?\\nCan somebody explain to me what\\'s wrong with my code"
                    },
                    {
                        "username": "sri4",
                        "content": "My code is working fine on my laptop for a test cases 1,2. but for same test cases it is throwing time limit exceeded error on leetcode when i press RUN(not submit.) anyone help? TLE on submission can be understood but i\\'m getting TLE on run itself. i dont understand.\\n \\ndef search(self, nums, target):\\n        l=len(nums)\\n        i=(l//2)\\n        while(i>0 and i< l-1):\\n            if nums[i]==target:\\n                return i\\n            elif nums[i]> target:\\n                i=(i//2)\\n            else:\\n                i=(l+i)//2\\n        if((i==0 and nums[i]==target )or (i==l-1 and nums[i]==target)):\\n            return i\\n        return -1"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "This problem can be solve using devide and conquer method"
                    },
                    {
                        "username": "aar-rafi",
                        "content": "can someone explain me a little about the lowest runtime 0ms sample solution?"
                    },
                    {
                        "username": "bdaws",
                        "content": "I recognize that posting solutions here is discouraged, but why doesn\\'t this TypeScript solution work?\\n\\n```\\nfunction search(nums: number[], target: number): number {\\n    let seek = Math.floor((nums.length - 1)/2);\\n    while(seek >= 0 && seek <= nums.length - 1) {\\n        if(nums[seek] === target) {\\n            return seek;\\n        }\\n        if (nums[seek] > target){\\n            // The number we\\'re on is greater than the target,\\n            // meaning the target is earlier in the array,\\n            // if at all.\\n            seek = Math.floor(seek / 2);\\n        } else if(nums[seek] < target) {\\n            seek = seek * 2;\\n        }\\n    }\\n\\n    return -1;\\n};\\n```\\n\\nI get \"time limit exceeded\", despite the second iteration of the `while` loop finding `target` in the first test case. In LeetCode\\'s runner, it continues after this iteration. I added a log statement in the `if(nums[seek] === target)` block to verify it was evaluated. \\n\\nRunning it locally though, it works:\\n\\n```\\n# running with `console.log(search([-1,0,3,5,9,12], 9))` appended\\n\\u276F ts-node workplace/leetcode/typescript/foo.ts\\n4\\n```\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Imagine an array with the answer in the second quarter, like the fourth element in an array with length nine. `seek` in your solution will endlessly flip between the middle of the array and the end of the first quarter."
                    },
                    {
                        "username": "nileshk_",
                        "content": "can someone please explain why I am getting Time Limit Exceeded fir this code. \\n    ` \\n\\nint search(vector<int>& nums, int target) {  \\n\\n        int i = 0;  \\n        int j = nums.size()-1;  \\n        int ans = -1;\\n        while(i <= j) {\\n            int m = i + ((j-i)/2);\\n            if(nums[m] == target) ans = m;\\n            else if(target < nums[m]) j = m-1;\\n            else i = m+1;\\n        }\\n        return ans;\\n   `"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Once your loop finds the answer, it ceases to modify `i` or `j` and never satisfies its exit condition."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "can some one help me where am i going wrong i cant get output\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start=0;\\n       int end=nums.length-1;\\n       \\n       while(start<=end){\\n           int mid= (end-start)+start/ 2;\\n           if(nums[mid]<target){\\n               end=mid-1;\\n\\n           }\\n           else if(nums[mid]==target){\\n               return target;\\n           }\\n           else{\\n               start=mid+1;\\n               mid= (end-start)+start/ 2;\\n           }\\n        \\n       } \\n return -1; \\n    }\\n} "
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "[@Praveena_V](/Praveena_V) \nVery welcome. I hope you were able to figure it out :)\n\nUseful rule of thumb:\nCheck edge cases/stop conditions first, then check to determine what to do for next  step."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "[@hashimjacobs](/hashimjacobs)  thank you so much for answering, I always go wrong in these conditions and loops how to improve it"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Praveena_V](/Praveena_V),\n\nI ran your solution and I see a couple issues. \n\n1. ***Take a closer look at your conditional statements where you are determining what to set *start* and *end* to.*** It may be easier to see if you ***invert the conditional statements***, comparing *target* to whatever value. So the order would be in which the statement is written is *target, operator, value at mid*.\n\n2. ***Double-check what you are setting *mid* to.*** You are subtracting *start* from *end*, then adding *start* back to *end*, which negates *start* throughout the entire loop, so you will keep getting the same value for *mid*. What operation can be done to make sure that mid varies?\n\n3. ***Should the while loop stop if start == end?*** What if the target is in the last index?\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "devcode98",
                        "content": "Guys, can you help me where I am going wrong, my bs() functions is getting called again and again\\n\\n\\n\\n\\n\\nclass Solution:\\n\\n    def bs(self,nums,left,right,target)-> int:\\n\\n        mid = int((left + right)/2)\\n        if nums[mid]==target:\\n            print(\\'Finally The Condition matched\\')\\n            return int(mid)\\n        if target < nums[mid]:\\n            # The number would be present in the Left Half of the Array\\n            print(\\'Moving towards the LHS of the array\\')\\n            val = self.bs(nums,left,mid-1,target)\\n            return val\\n        elif target > nums[mid]:\\n            print(\\'Moving to the RHS of the array\\')\\n            val = self.bs(nums,mid+1,right,target)\\n            print(\\'The valu received from the RHS array is\\')\\n            print(val)\\n            return val\\n        return -1\\n\\n\\n    def search(self, nums: List[int], target: int) -> int:\\n\\n        left = 0\\n        right = len(nums)-1\\n        print(\\'invoking the external Function\\')\\n        incoming_value = self.bs(nums,left,right,target)\\n        print(\\'THe Incoming value received from the function is\\')\\n        print(incoming_value)\\n\\n        return incoming_value"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Devang Nayar](/devcode98),\nI reproduced your error and then found the issue. The issue is that you are not determining if ***the target does not exist*** in time. Here's a hint: ***Figure out how and where to check that the target does not exist and return -1.***  It might also help your debugging if you remove redundant comments, print statements, and variables. It will help you focus on the code and keep it clean. If you want to keep the print statements, you can compress two into one using formatting. See below for an example on how Python3 formatting works.\n\n```\nprint(f\"Nums: {nums}\")\nprint(f\"Left: {left}\")\nprint(f\"Right: {right}\")\nprint(f\"Target: {target}\")\n\ntarget_index = self.bs(nums, left, right, target)\nprint(f\"The target index is {target_index}\")\n```\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "Rajeswari21",
                        "content": "I m getting an error for len() function  => \\n\\n\"TypeError: object of type \\'NoneType\\' has no len()\\n    high= len(nums)-1\\nLine 6 in search (Solution.py)\\n    ret = Solution().search(param_1, param_2)\\nLine 46 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\"\\n\\n\\nMay I know what will be the reason?\\nProgramming Language: Python"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Rajeswari21](/Rajeswari21),\\n\\nCould you please share the rest of your solution? It\\'s difficult to determine the issue with one line of code.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1814499,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "The tests should deny `indexOf` built-in method.\\n\\nThe solution must implemented with `O(log n)` runtime complexity."
                    },
                    {
                        "username": "mdavidn",
                        "content": "This is not possible with all of the languages, though the test cases could try a much larger array to check time complexity."
                    },
                    {
                        "username": "antoniogrosu",
                        "content": "Am I writing something wrong ?\\nC++  as I learnt it looks something like this \\n#include <iostream>\\nusing namespace std;\\nvoid binarySearch(int v[10001], int target)\\n{\\n\\tbool found = 0;\\n\\tint r = 0; [.... etc]\\ni see solutions are written really different ?\\nCan somebody explain to me what\\'s wrong with my code"
                    },
                    {
                        "username": "sri4",
                        "content": "My code is working fine on my laptop for a test cases 1,2. but for same test cases it is throwing time limit exceeded error on leetcode when i press RUN(not submit.) anyone help? TLE on submission can be understood but i\\'m getting TLE on run itself. i dont understand.\\n \\ndef search(self, nums, target):\\n        l=len(nums)\\n        i=(l//2)\\n        while(i>0 and i< l-1):\\n            if nums[i]==target:\\n                return i\\n            elif nums[i]> target:\\n                i=(i//2)\\n            else:\\n                i=(l+i)//2\\n        if((i==0 and nums[i]==target )or (i==l-1 and nums[i]==target)):\\n            return i\\n        return -1"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "This problem can be solve using devide and conquer method"
                    },
                    {
                        "username": "aar-rafi",
                        "content": "can someone explain me a little about the lowest runtime 0ms sample solution?"
                    },
                    {
                        "username": "bdaws",
                        "content": "I recognize that posting solutions here is discouraged, but why doesn\\'t this TypeScript solution work?\\n\\n```\\nfunction search(nums: number[], target: number): number {\\n    let seek = Math.floor((nums.length - 1)/2);\\n    while(seek >= 0 && seek <= nums.length - 1) {\\n        if(nums[seek] === target) {\\n            return seek;\\n        }\\n        if (nums[seek] > target){\\n            // The number we\\'re on is greater than the target,\\n            // meaning the target is earlier in the array,\\n            // if at all.\\n            seek = Math.floor(seek / 2);\\n        } else if(nums[seek] < target) {\\n            seek = seek * 2;\\n        }\\n    }\\n\\n    return -1;\\n};\\n```\\n\\nI get \"time limit exceeded\", despite the second iteration of the `while` loop finding `target` in the first test case. In LeetCode\\'s runner, it continues after this iteration. I added a log statement in the `if(nums[seek] === target)` block to verify it was evaluated. \\n\\nRunning it locally though, it works:\\n\\n```\\n# running with `console.log(search([-1,0,3,5,9,12], 9))` appended\\n\\u276F ts-node workplace/leetcode/typescript/foo.ts\\n4\\n```\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Imagine an array with the answer in the second quarter, like the fourth element in an array with length nine. `seek` in your solution will endlessly flip between the middle of the array and the end of the first quarter."
                    },
                    {
                        "username": "nileshk_",
                        "content": "can someone please explain why I am getting Time Limit Exceeded fir this code. \\n    ` \\n\\nint search(vector<int>& nums, int target) {  \\n\\n        int i = 0;  \\n        int j = nums.size()-1;  \\n        int ans = -1;\\n        while(i <= j) {\\n            int m = i + ((j-i)/2);\\n            if(nums[m] == target) ans = m;\\n            else if(target < nums[m]) j = m-1;\\n            else i = m+1;\\n        }\\n        return ans;\\n   `"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Once your loop finds the answer, it ceases to modify `i` or `j` and never satisfies its exit condition."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "can some one help me where am i going wrong i cant get output\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start=0;\\n       int end=nums.length-1;\\n       \\n       while(start<=end){\\n           int mid= (end-start)+start/ 2;\\n           if(nums[mid]<target){\\n               end=mid-1;\\n\\n           }\\n           else if(nums[mid]==target){\\n               return target;\\n           }\\n           else{\\n               start=mid+1;\\n               mid= (end-start)+start/ 2;\\n           }\\n        \\n       } \\n return -1; \\n    }\\n} "
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "[@Praveena_V](/Praveena_V) \nVery welcome. I hope you were able to figure it out :)\n\nUseful rule of thumb:\nCheck edge cases/stop conditions first, then check to determine what to do for next  step."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "[@hashimjacobs](/hashimjacobs)  thank you so much for answering, I always go wrong in these conditions and loops how to improve it"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Praveena_V](/Praveena_V),\n\nI ran your solution and I see a couple issues. \n\n1. ***Take a closer look at your conditional statements where you are determining what to set *start* and *end* to.*** It may be easier to see if you ***invert the conditional statements***, comparing *target* to whatever value. So the order would be in which the statement is written is *target, operator, value at mid*.\n\n2. ***Double-check what you are setting *mid* to.*** You are subtracting *start* from *end*, then adding *start* back to *end*, which negates *start* throughout the entire loop, so you will keep getting the same value for *mid*. What operation can be done to make sure that mid varies?\n\n3. ***Should the while loop stop if start == end?*** What if the target is in the last index?\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "devcode98",
                        "content": "Guys, can you help me where I am going wrong, my bs() functions is getting called again and again\\n\\n\\n\\n\\n\\nclass Solution:\\n\\n    def bs(self,nums,left,right,target)-> int:\\n\\n        mid = int((left + right)/2)\\n        if nums[mid]==target:\\n            print(\\'Finally The Condition matched\\')\\n            return int(mid)\\n        if target < nums[mid]:\\n            # The number would be present in the Left Half of the Array\\n            print(\\'Moving towards the LHS of the array\\')\\n            val = self.bs(nums,left,mid-1,target)\\n            return val\\n        elif target > nums[mid]:\\n            print(\\'Moving to the RHS of the array\\')\\n            val = self.bs(nums,mid+1,right,target)\\n            print(\\'The valu received from the RHS array is\\')\\n            print(val)\\n            return val\\n        return -1\\n\\n\\n    def search(self, nums: List[int], target: int) -> int:\\n\\n        left = 0\\n        right = len(nums)-1\\n        print(\\'invoking the external Function\\')\\n        incoming_value = self.bs(nums,left,right,target)\\n        print(\\'THe Incoming value received from the function is\\')\\n        print(incoming_value)\\n\\n        return incoming_value"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Devang Nayar](/devcode98),\nI reproduced your error and then found the issue. The issue is that you are not determining if ***the target does not exist*** in time. Here's a hint: ***Figure out how and where to check that the target does not exist and return -1.***  It might also help your debugging if you remove redundant comments, print statements, and variables. It will help you focus on the code and keep it clean. If you want to keep the print statements, you can compress two into one using formatting. See below for an example on how Python3 formatting works.\n\n```\nprint(f\"Nums: {nums}\")\nprint(f\"Left: {left}\")\nprint(f\"Right: {right}\")\nprint(f\"Target: {target}\")\n\ntarget_index = self.bs(nums, left, right, target)\nprint(f\"The target index is {target_index}\")\n```\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "Rajeswari21",
                        "content": "I m getting an error for len() function  => \\n\\n\"TypeError: object of type \\'NoneType\\' has no len()\\n    high= len(nums)-1\\nLine 6 in search (Solution.py)\\n    ret = Solution().search(param_1, param_2)\\nLine 46 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\"\\n\\n\\nMay I know what will be the reason?\\nProgramming Language: Python"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Rajeswari21](/Rajeswari21),\\n\\nCould you please share the rest of your solution? It\\'s difficult to determine the issue with one line of code.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1806597,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "The tests should deny `indexOf` built-in method.\\n\\nThe solution must implemented with `O(log n)` runtime complexity."
                    },
                    {
                        "username": "mdavidn",
                        "content": "This is not possible with all of the languages, though the test cases could try a much larger array to check time complexity."
                    },
                    {
                        "username": "antoniogrosu",
                        "content": "Am I writing something wrong ?\\nC++  as I learnt it looks something like this \\n#include <iostream>\\nusing namespace std;\\nvoid binarySearch(int v[10001], int target)\\n{\\n\\tbool found = 0;\\n\\tint r = 0; [.... etc]\\ni see solutions are written really different ?\\nCan somebody explain to me what\\'s wrong with my code"
                    },
                    {
                        "username": "sri4",
                        "content": "My code is working fine on my laptop for a test cases 1,2. but for same test cases it is throwing time limit exceeded error on leetcode when i press RUN(not submit.) anyone help? TLE on submission can be understood but i\\'m getting TLE on run itself. i dont understand.\\n \\ndef search(self, nums, target):\\n        l=len(nums)\\n        i=(l//2)\\n        while(i>0 and i< l-1):\\n            if nums[i]==target:\\n                return i\\n            elif nums[i]> target:\\n                i=(i//2)\\n            else:\\n                i=(l+i)//2\\n        if((i==0 and nums[i]==target )or (i==l-1 and nums[i]==target)):\\n            return i\\n        return -1"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "This problem can be solve using devide and conquer method"
                    },
                    {
                        "username": "aar-rafi",
                        "content": "can someone explain me a little about the lowest runtime 0ms sample solution?"
                    },
                    {
                        "username": "bdaws",
                        "content": "I recognize that posting solutions here is discouraged, but why doesn\\'t this TypeScript solution work?\\n\\n```\\nfunction search(nums: number[], target: number): number {\\n    let seek = Math.floor((nums.length - 1)/2);\\n    while(seek >= 0 && seek <= nums.length - 1) {\\n        if(nums[seek] === target) {\\n            return seek;\\n        }\\n        if (nums[seek] > target){\\n            // The number we\\'re on is greater than the target,\\n            // meaning the target is earlier in the array,\\n            // if at all.\\n            seek = Math.floor(seek / 2);\\n        } else if(nums[seek] < target) {\\n            seek = seek * 2;\\n        }\\n    }\\n\\n    return -1;\\n};\\n```\\n\\nI get \"time limit exceeded\", despite the second iteration of the `while` loop finding `target` in the first test case. In LeetCode\\'s runner, it continues after this iteration. I added a log statement in the `if(nums[seek] === target)` block to verify it was evaluated. \\n\\nRunning it locally though, it works:\\n\\n```\\n# running with `console.log(search([-1,0,3,5,9,12], 9))` appended\\n\\u276F ts-node workplace/leetcode/typescript/foo.ts\\n4\\n```\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Imagine an array with the answer in the second quarter, like the fourth element in an array with length nine. `seek` in your solution will endlessly flip between the middle of the array and the end of the first quarter."
                    },
                    {
                        "username": "nileshk_",
                        "content": "can someone please explain why I am getting Time Limit Exceeded fir this code. \\n    ` \\n\\nint search(vector<int>& nums, int target) {  \\n\\n        int i = 0;  \\n        int j = nums.size()-1;  \\n        int ans = -1;\\n        while(i <= j) {\\n            int m = i + ((j-i)/2);\\n            if(nums[m] == target) ans = m;\\n            else if(target < nums[m]) j = m-1;\\n            else i = m+1;\\n        }\\n        return ans;\\n   `"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Once your loop finds the answer, it ceases to modify `i` or `j` and never satisfies its exit condition."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "can some one help me where am i going wrong i cant get output\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start=0;\\n       int end=nums.length-1;\\n       \\n       while(start<=end){\\n           int mid= (end-start)+start/ 2;\\n           if(nums[mid]<target){\\n               end=mid-1;\\n\\n           }\\n           else if(nums[mid]==target){\\n               return target;\\n           }\\n           else{\\n               start=mid+1;\\n               mid= (end-start)+start/ 2;\\n           }\\n        \\n       } \\n return -1; \\n    }\\n} "
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "[@Praveena_V](/Praveena_V) \nVery welcome. I hope you were able to figure it out :)\n\nUseful rule of thumb:\nCheck edge cases/stop conditions first, then check to determine what to do for next  step."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "[@hashimjacobs](/hashimjacobs)  thank you so much for answering, I always go wrong in these conditions and loops how to improve it"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Praveena_V](/Praveena_V),\n\nI ran your solution and I see a couple issues. \n\n1. ***Take a closer look at your conditional statements where you are determining what to set *start* and *end* to.*** It may be easier to see if you ***invert the conditional statements***, comparing *target* to whatever value. So the order would be in which the statement is written is *target, operator, value at mid*.\n\n2. ***Double-check what you are setting *mid* to.*** You are subtracting *start* from *end*, then adding *start* back to *end*, which negates *start* throughout the entire loop, so you will keep getting the same value for *mid*. What operation can be done to make sure that mid varies?\n\n3. ***Should the while loop stop if start == end?*** What if the target is in the last index?\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "devcode98",
                        "content": "Guys, can you help me where I am going wrong, my bs() functions is getting called again and again\\n\\n\\n\\n\\n\\nclass Solution:\\n\\n    def bs(self,nums,left,right,target)-> int:\\n\\n        mid = int((left + right)/2)\\n        if nums[mid]==target:\\n            print(\\'Finally The Condition matched\\')\\n            return int(mid)\\n        if target < nums[mid]:\\n            # The number would be present in the Left Half of the Array\\n            print(\\'Moving towards the LHS of the array\\')\\n            val = self.bs(nums,left,mid-1,target)\\n            return val\\n        elif target > nums[mid]:\\n            print(\\'Moving to the RHS of the array\\')\\n            val = self.bs(nums,mid+1,right,target)\\n            print(\\'The valu received from the RHS array is\\')\\n            print(val)\\n            return val\\n        return -1\\n\\n\\n    def search(self, nums: List[int], target: int) -> int:\\n\\n        left = 0\\n        right = len(nums)-1\\n        print(\\'invoking the external Function\\')\\n        incoming_value = self.bs(nums,left,right,target)\\n        print(\\'THe Incoming value received from the function is\\')\\n        print(incoming_value)\\n\\n        return incoming_value"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Devang Nayar](/devcode98),\nI reproduced your error and then found the issue. The issue is that you are not determining if ***the target does not exist*** in time. Here's a hint: ***Figure out how and where to check that the target does not exist and return -1.***  It might also help your debugging if you remove redundant comments, print statements, and variables. It will help you focus on the code and keep it clean. If you want to keep the print statements, you can compress two into one using formatting. See below for an example on how Python3 formatting works.\n\n```\nprint(f\"Nums: {nums}\")\nprint(f\"Left: {left}\")\nprint(f\"Right: {right}\")\nprint(f\"Target: {target}\")\n\ntarget_index = self.bs(nums, left, right, target)\nprint(f\"The target index is {target_index}\")\n```\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "Rajeswari21",
                        "content": "I m getting an error for len() function  => \\n\\n\"TypeError: object of type \\'NoneType\\' has no len()\\n    high= len(nums)-1\\nLine 6 in search (Solution.py)\\n    ret = Solution().search(param_1, param_2)\\nLine 46 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\"\\n\\n\\nMay I know what will be the reason?\\nProgramming Language: Python"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Rajeswari21](/Rajeswari21),\\n\\nCould you please share the rest of your solution? It\\'s difficult to determine the issue with one line of code.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1778142,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "The tests should deny `indexOf` built-in method.\\n\\nThe solution must implemented with `O(log n)` runtime complexity."
                    },
                    {
                        "username": "mdavidn",
                        "content": "This is not possible with all of the languages, though the test cases could try a much larger array to check time complexity."
                    },
                    {
                        "username": "antoniogrosu",
                        "content": "Am I writing something wrong ?\\nC++  as I learnt it looks something like this \\n#include <iostream>\\nusing namespace std;\\nvoid binarySearch(int v[10001], int target)\\n{\\n\\tbool found = 0;\\n\\tint r = 0; [.... etc]\\ni see solutions are written really different ?\\nCan somebody explain to me what\\'s wrong with my code"
                    },
                    {
                        "username": "sri4",
                        "content": "My code is working fine on my laptop for a test cases 1,2. but for same test cases it is throwing time limit exceeded error on leetcode when i press RUN(not submit.) anyone help? TLE on submission can be understood but i\\'m getting TLE on run itself. i dont understand.\\n \\ndef search(self, nums, target):\\n        l=len(nums)\\n        i=(l//2)\\n        while(i>0 and i< l-1):\\n            if nums[i]==target:\\n                return i\\n            elif nums[i]> target:\\n                i=(i//2)\\n            else:\\n                i=(l+i)//2\\n        if((i==0 and nums[i]==target )or (i==l-1 and nums[i]==target)):\\n            return i\\n        return -1"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "This problem can be solve using devide and conquer method"
                    },
                    {
                        "username": "aar-rafi",
                        "content": "can someone explain me a little about the lowest runtime 0ms sample solution?"
                    },
                    {
                        "username": "bdaws",
                        "content": "I recognize that posting solutions here is discouraged, but why doesn\\'t this TypeScript solution work?\\n\\n```\\nfunction search(nums: number[], target: number): number {\\n    let seek = Math.floor((nums.length - 1)/2);\\n    while(seek >= 0 && seek <= nums.length - 1) {\\n        if(nums[seek] === target) {\\n            return seek;\\n        }\\n        if (nums[seek] > target){\\n            // The number we\\'re on is greater than the target,\\n            // meaning the target is earlier in the array,\\n            // if at all.\\n            seek = Math.floor(seek / 2);\\n        } else if(nums[seek] < target) {\\n            seek = seek * 2;\\n        }\\n    }\\n\\n    return -1;\\n};\\n```\\n\\nI get \"time limit exceeded\", despite the second iteration of the `while` loop finding `target` in the first test case. In LeetCode\\'s runner, it continues after this iteration. I added a log statement in the `if(nums[seek] === target)` block to verify it was evaluated. \\n\\nRunning it locally though, it works:\\n\\n```\\n# running with `console.log(search([-1,0,3,5,9,12], 9))` appended\\n\\u276F ts-node workplace/leetcode/typescript/foo.ts\\n4\\n```\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Imagine an array with the answer in the second quarter, like the fourth element in an array with length nine. `seek` in your solution will endlessly flip between the middle of the array and the end of the first quarter."
                    },
                    {
                        "username": "nileshk_",
                        "content": "can someone please explain why I am getting Time Limit Exceeded fir this code. \\n    ` \\n\\nint search(vector<int>& nums, int target) {  \\n\\n        int i = 0;  \\n        int j = nums.size()-1;  \\n        int ans = -1;\\n        while(i <= j) {\\n            int m = i + ((j-i)/2);\\n            if(nums[m] == target) ans = m;\\n            else if(target < nums[m]) j = m-1;\\n            else i = m+1;\\n        }\\n        return ans;\\n   `"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Once your loop finds the answer, it ceases to modify `i` or `j` and never satisfies its exit condition."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "can some one help me where am i going wrong i cant get output\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start=0;\\n       int end=nums.length-1;\\n       \\n       while(start<=end){\\n           int mid= (end-start)+start/ 2;\\n           if(nums[mid]<target){\\n               end=mid-1;\\n\\n           }\\n           else if(nums[mid]==target){\\n               return target;\\n           }\\n           else{\\n               start=mid+1;\\n               mid= (end-start)+start/ 2;\\n           }\\n        \\n       } \\n return -1; \\n    }\\n} "
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "[@Praveena_V](/Praveena_V) \nVery welcome. I hope you were able to figure it out :)\n\nUseful rule of thumb:\nCheck edge cases/stop conditions first, then check to determine what to do for next  step."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "[@hashimjacobs](/hashimjacobs)  thank you so much for answering, I always go wrong in these conditions and loops how to improve it"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Praveena_V](/Praveena_V),\n\nI ran your solution and I see a couple issues. \n\n1. ***Take a closer look at your conditional statements where you are determining what to set *start* and *end* to.*** It may be easier to see if you ***invert the conditional statements***, comparing *target* to whatever value. So the order would be in which the statement is written is *target, operator, value at mid*.\n\n2. ***Double-check what you are setting *mid* to.*** You are subtracting *start* from *end*, then adding *start* back to *end*, which negates *start* throughout the entire loop, so you will keep getting the same value for *mid*. What operation can be done to make sure that mid varies?\n\n3. ***Should the while loop stop if start == end?*** What if the target is in the last index?\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "devcode98",
                        "content": "Guys, can you help me where I am going wrong, my bs() functions is getting called again and again\\n\\n\\n\\n\\n\\nclass Solution:\\n\\n    def bs(self,nums,left,right,target)-> int:\\n\\n        mid = int((left + right)/2)\\n        if nums[mid]==target:\\n            print(\\'Finally The Condition matched\\')\\n            return int(mid)\\n        if target < nums[mid]:\\n            # The number would be present in the Left Half of the Array\\n            print(\\'Moving towards the LHS of the array\\')\\n            val = self.bs(nums,left,mid-1,target)\\n            return val\\n        elif target > nums[mid]:\\n            print(\\'Moving to the RHS of the array\\')\\n            val = self.bs(nums,mid+1,right,target)\\n            print(\\'The valu received from the RHS array is\\')\\n            print(val)\\n            return val\\n        return -1\\n\\n\\n    def search(self, nums: List[int], target: int) -> int:\\n\\n        left = 0\\n        right = len(nums)-1\\n        print(\\'invoking the external Function\\')\\n        incoming_value = self.bs(nums,left,right,target)\\n        print(\\'THe Incoming value received from the function is\\')\\n        print(incoming_value)\\n\\n        return incoming_value"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Devang Nayar](/devcode98),\nI reproduced your error and then found the issue. The issue is that you are not determining if ***the target does not exist*** in time. Here's a hint: ***Figure out how and where to check that the target does not exist and return -1.***  It might also help your debugging if you remove redundant comments, print statements, and variables. It will help you focus on the code and keep it clean. If you want to keep the print statements, you can compress two into one using formatting. See below for an example on how Python3 formatting works.\n\n```\nprint(f\"Nums: {nums}\")\nprint(f\"Left: {left}\")\nprint(f\"Right: {right}\")\nprint(f\"Target: {target}\")\n\ntarget_index = self.bs(nums, left, right, target)\nprint(f\"The target index is {target_index}\")\n```\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "Rajeswari21",
                        "content": "I m getting an error for len() function  => \\n\\n\"TypeError: object of type \\'NoneType\\' has no len()\\n    high= len(nums)-1\\nLine 6 in search (Solution.py)\\n    ret = Solution().search(param_1, param_2)\\nLine 46 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\"\\n\\n\\nMay I know what will be the reason?\\nProgramming Language: Python"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Rajeswari21](/Rajeswari21),\\n\\nCould you please share the rest of your solution? It\\'s difficult to determine the issue with one line of code.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1778123,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "The tests should deny `indexOf` built-in method.\\n\\nThe solution must implemented with `O(log n)` runtime complexity."
                    },
                    {
                        "username": "mdavidn",
                        "content": "This is not possible with all of the languages, though the test cases could try a much larger array to check time complexity."
                    },
                    {
                        "username": "antoniogrosu",
                        "content": "Am I writing something wrong ?\\nC++  as I learnt it looks something like this \\n#include <iostream>\\nusing namespace std;\\nvoid binarySearch(int v[10001], int target)\\n{\\n\\tbool found = 0;\\n\\tint r = 0; [.... etc]\\ni see solutions are written really different ?\\nCan somebody explain to me what\\'s wrong with my code"
                    },
                    {
                        "username": "sri4",
                        "content": "My code is working fine on my laptop for a test cases 1,2. but for same test cases it is throwing time limit exceeded error on leetcode when i press RUN(not submit.) anyone help? TLE on submission can be understood but i\\'m getting TLE on run itself. i dont understand.\\n \\ndef search(self, nums, target):\\n        l=len(nums)\\n        i=(l//2)\\n        while(i>0 and i< l-1):\\n            if nums[i]==target:\\n                return i\\n            elif nums[i]> target:\\n                i=(i//2)\\n            else:\\n                i=(l+i)//2\\n        if((i==0 and nums[i]==target )or (i==l-1 and nums[i]==target)):\\n            return i\\n        return -1"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "This problem can be solve using devide and conquer method"
                    },
                    {
                        "username": "aar-rafi",
                        "content": "can someone explain me a little about the lowest runtime 0ms sample solution?"
                    },
                    {
                        "username": "bdaws",
                        "content": "I recognize that posting solutions here is discouraged, but why doesn\\'t this TypeScript solution work?\\n\\n```\\nfunction search(nums: number[], target: number): number {\\n    let seek = Math.floor((nums.length - 1)/2);\\n    while(seek >= 0 && seek <= nums.length - 1) {\\n        if(nums[seek] === target) {\\n            return seek;\\n        }\\n        if (nums[seek] > target){\\n            // The number we\\'re on is greater than the target,\\n            // meaning the target is earlier in the array,\\n            // if at all.\\n            seek = Math.floor(seek / 2);\\n        } else if(nums[seek] < target) {\\n            seek = seek * 2;\\n        }\\n    }\\n\\n    return -1;\\n};\\n```\\n\\nI get \"time limit exceeded\", despite the second iteration of the `while` loop finding `target` in the first test case. In LeetCode\\'s runner, it continues after this iteration. I added a log statement in the `if(nums[seek] === target)` block to verify it was evaluated. \\n\\nRunning it locally though, it works:\\n\\n```\\n# running with `console.log(search([-1,0,3,5,9,12], 9))` appended\\n\\u276F ts-node workplace/leetcode/typescript/foo.ts\\n4\\n```\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Imagine an array with the answer in the second quarter, like the fourth element in an array with length nine. `seek` in your solution will endlessly flip between the middle of the array and the end of the first quarter."
                    },
                    {
                        "username": "nileshk_",
                        "content": "can someone please explain why I am getting Time Limit Exceeded fir this code. \\n    ` \\n\\nint search(vector<int>& nums, int target) {  \\n\\n        int i = 0;  \\n        int j = nums.size()-1;  \\n        int ans = -1;\\n        while(i <= j) {\\n            int m = i + ((j-i)/2);\\n            if(nums[m] == target) ans = m;\\n            else if(target < nums[m]) j = m-1;\\n            else i = m+1;\\n        }\\n        return ans;\\n   `"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Once your loop finds the answer, it ceases to modify `i` or `j` and never satisfies its exit condition."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "can some one help me where am i going wrong i cant get output\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start=0;\\n       int end=nums.length-1;\\n       \\n       while(start<=end){\\n           int mid= (end-start)+start/ 2;\\n           if(nums[mid]<target){\\n               end=mid-1;\\n\\n           }\\n           else if(nums[mid]==target){\\n               return target;\\n           }\\n           else{\\n               start=mid+1;\\n               mid= (end-start)+start/ 2;\\n           }\\n        \\n       } \\n return -1; \\n    }\\n} "
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "[@Praveena_V](/Praveena_V) \nVery welcome. I hope you were able to figure it out :)\n\nUseful rule of thumb:\nCheck edge cases/stop conditions first, then check to determine what to do for next  step."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "[@hashimjacobs](/hashimjacobs)  thank you so much for answering, I always go wrong in these conditions and loops how to improve it"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Praveena_V](/Praveena_V),\n\nI ran your solution and I see a couple issues. \n\n1. ***Take a closer look at your conditional statements where you are determining what to set *start* and *end* to.*** It may be easier to see if you ***invert the conditional statements***, comparing *target* to whatever value. So the order would be in which the statement is written is *target, operator, value at mid*.\n\n2. ***Double-check what you are setting *mid* to.*** You are subtracting *start* from *end*, then adding *start* back to *end*, which negates *start* throughout the entire loop, so you will keep getting the same value for *mid*. What operation can be done to make sure that mid varies?\n\n3. ***Should the while loop stop if start == end?*** What if the target is in the last index?\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "devcode98",
                        "content": "Guys, can you help me where I am going wrong, my bs() functions is getting called again and again\\n\\n\\n\\n\\n\\nclass Solution:\\n\\n    def bs(self,nums,left,right,target)-> int:\\n\\n        mid = int((left + right)/2)\\n        if nums[mid]==target:\\n            print(\\'Finally The Condition matched\\')\\n            return int(mid)\\n        if target < nums[mid]:\\n            # The number would be present in the Left Half of the Array\\n            print(\\'Moving towards the LHS of the array\\')\\n            val = self.bs(nums,left,mid-1,target)\\n            return val\\n        elif target > nums[mid]:\\n            print(\\'Moving to the RHS of the array\\')\\n            val = self.bs(nums,mid+1,right,target)\\n            print(\\'The valu received from the RHS array is\\')\\n            print(val)\\n            return val\\n        return -1\\n\\n\\n    def search(self, nums: List[int], target: int) -> int:\\n\\n        left = 0\\n        right = len(nums)-1\\n        print(\\'invoking the external Function\\')\\n        incoming_value = self.bs(nums,left,right,target)\\n        print(\\'THe Incoming value received from the function is\\')\\n        print(incoming_value)\\n\\n        return incoming_value"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Devang Nayar](/devcode98),\nI reproduced your error and then found the issue. The issue is that you are not determining if ***the target does not exist*** in time. Here's a hint: ***Figure out how and where to check that the target does not exist and return -1.***  It might also help your debugging if you remove redundant comments, print statements, and variables. It will help you focus on the code and keep it clean. If you want to keep the print statements, you can compress two into one using formatting. See below for an example on how Python3 formatting works.\n\n```\nprint(f\"Nums: {nums}\")\nprint(f\"Left: {left}\")\nprint(f\"Right: {right}\")\nprint(f\"Target: {target}\")\n\ntarget_index = self.bs(nums, left, right, target)\nprint(f\"The target index is {target_index}\")\n```\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "Rajeswari21",
                        "content": "I m getting an error for len() function  => \\n\\n\"TypeError: object of type \\'NoneType\\' has no len()\\n    high= len(nums)-1\\nLine 6 in search (Solution.py)\\n    ret = Solution().search(param_1, param_2)\\nLine 46 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\"\\n\\n\\nMay I know what will be the reason?\\nProgramming Language: Python"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Rajeswari21](/Rajeswari21),\\n\\nCould you please share the rest of your solution? It\\'s difficult to determine the issue with one line of code.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1776581,
                "content": [
                    {
                        "username": "MenaiAla",
                        "content": "The tests should deny `indexOf` built-in method.\\n\\nThe solution must implemented with `O(log n)` runtime complexity."
                    },
                    {
                        "username": "mdavidn",
                        "content": "This is not possible with all of the languages, though the test cases could try a much larger array to check time complexity."
                    },
                    {
                        "username": "antoniogrosu",
                        "content": "Am I writing something wrong ?\\nC++  as I learnt it looks something like this \\n#include <iostream>\\nusing namespace std;\\nvoid binarySearch(int v[10001], int target)\\n{\\n\\tbool found = 0;\\n\\tint r = 0; [.... etc]\\ni see solutions are written really different ?\\nCan somebody explain to me what\\'s wrong with my code"
                    },
                    {
                        "username": "sri4",
                        "content": "My code is working fine on my laptop for a test cases 1,2. but for same test cases it is throwing time limit exceeded error on leetcode when i press RUN(not submit.) anyone help? TLE on submission can be understood but i\\'m getting TLE on run itself. i dont understand.\\n \\ndef search(self, nums, target):\\n        l=len(nums)\\n        i=(l//2)\\n        while(i>0 and i< l-1):\\n            if nums[i]==target:\\n                return i\\n            elif nums[i]> target:\\n                i=(i//2)\\n            else:\\n                i=(l+i)//2\\n        if((i==0 and nums[i]==target )or (i==l-1 and nums[i]==target)):\\n            return i\\n        return -1"
                    },
                    {
                        "username": "adityachauhan5566",
                        "content": "This problem can be solve using devide and conquer method"
                    },
                    {
                        "username": "aar-rafi",
                        "content": "can someone explain me a little about the lowest runtime 0ms sample solution?"
                    },
                    {
                        "username": "bdaws",
                        "content": "I recognize that posting solutions here is discouraged, but why doesn\\'t this TypeScript solution work?\\n\\n```\\nfunction search(nums: number[], target: number): number {\\n    let seek = Math.floor((nums.length - 1)/2);\\n    while(seek >= 0 && seek <= nums.length - 1) {\\n        if(nums[seek] === target) {\\n            return seek;\\n        }\\n        if (nums[seek] > target){\\n            // The number we\\'re on is greater than the target,\\n            // meaning the target is earlier in the array,\\n            // if at all.\\n            seek = Math.floor(seek / 2);\\n        } else if(nums[seek] < target) {\\n            seek = seek * 2;\\n        }\\n    }\\n\\n    return -1;\\n};\\n```\\n\\nI get \"time limit exceeded\", despite the second iteration of the `while` loop finding `target` in the first test case. In LeetCode\\'s runner, it continues after this iteration. I added a log statement in the `if(nums[seek] === target)` block to verify it was evaluated. \\n\\nRunning it locally though, it works:\\n\\n```\\n# running with `console.log(search([-1,0,3,5,9,12], 9))` appended\\n\\u276F ts-node workplace/leetcode/typescript/foo.ts\\n4\\n```\\n\\nWhat am I missing?"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Imagine an array with the answer in the second quarter, like the fourth element in an array with length nine. `seek` in your solution will endlessly flip between the middle of the array and the end of the first quarter."
                    },
                    {
                        "username": "nileshk_",
                        "content": "can someone please explain why I am getting Time Limit Exceeded fir this code. \\n    ` \\n\\nint search(vector<int>& nums, int target) {  \\n\\n        int i = 0;  \\n        int j = nums.size()-1;  \\n        int ans = -1;\\n        while(i <= j) {\\n            int m = i + ((j-i)/2);\\n            if(nums[m] == target) ans = m;\\n            else if(target < nums[m]) j = m-1;\\n            else i = m+1;\\n        }\\n        return ans;\\n   `"
                    },
                    {
                        "username": "mdavidn",
                        "content": "Once your loop finds the answer, it ceases to modify `i` or `j` and never satisfies its exit condition."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "can some one help me where am i going wrong i cant get output\\nclass Solution {\\n    public int search(int[] nums, int target) {\\n        int start=0;\\n       int end=nums.length-1;\\n       \\n       while(start<=end){\\n           int mid= (end-start)+start/ 2;\\n           if(nums[mid]<target){\\n               end=mid-1;\\n\\n           }\\n           else if(nums[mid]==target){\\n               return target;\\n           }\\n           else{\\n               start=mid+1;\\n               mid= (end-start)+start/ 2;\\n           }\\n        \\n       } \\n return -1; \\n    }\\n} "
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "[@Praveena_V](/Praveena_V) \nVery welcome. I hope you were able to figure it out :)\n\nUseful rule of thumb:\nCheck edge cases/stop conditions first, then check to determine what to do for next  step."
                    },
                    {
                        "username": "Praveena_V",
                        "content": "[@hashimjacobs](/hashimjacobs)  thank you so much for answering, I always go wrong in these conditions and loops how to improve it"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Praveena_V](/Praveena_V),\n\nI ran your solution and I see a couple issues. \n\n1. ***Take a closer look at your conditional statements where you are determining what to set *start* and *end* to.*** It may be easier to see if you ***invert the conditional statements***, comparing *target* to whatever value. So the order would be in which the statement is written is *target, operator, value at mid*.\n\n2. ***Double-check what you are setting *mid* to.*** You are subtracting *start* from *end*, then adding *start* back to *end*, which negates *start* throughout the entire loop, so you will keep getting the same value for *mid*. What operation can be done to make sure that mid varies?\n\n3. ***Should the while loop stop if start == end?*** What if the target is in the last index?\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "devcode98",
                        "content": "Guys, can you help me where I am going wrong, my bs() functions is getting called again and again\\n\\n\\n\\n\\n\\nclass Solution:\\n\\n    def bs(self,nums,left,right,target)-> int:\\n\\n        mid = int((left + right)/2)\\n        if nums[mid]==target:\\n            print(\\'Finally The Condition matched\\')\\n            return int(mid)\\n        if target < nums[mid]:\\n            # The number would be present in the Left Half of the Array\\n            print(\\'Moving towards the LHS of the array\\')\\n            val = self.bs(nums,left,mid-1,target)\\n            return val\\n        elif target > nums[mid]:\\n            print(\\'Moving to the RHS of the array\\')\\n            val = self.bs(nums,mid+1,right,target)\\n            print(\\'The valu received from the RHS array is\\')\\n            print(val)\\n            return val\\n        return -1\\n\\n\\n    def search(self, nums: List[int], target: int) -> int:\\n\\n        left = 0\\n        right = len(nums)-1\\n        print(\\'invoking the external Function\\')\\n        incoming_value = self.bs(nums,left,right,target)\\n        print(\\'THe Incoming value received from the function is\\')\\n        print(incoming_value)\\n\\n        return incoming_value"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Devang Nayar](/devcode98),\nI reproduced your error and then found the issue. The issue is that you are not determining if ***the target does not exist*** in time. Here's a hint: ***Figure out how and where to check that the target does not exist and return -1.***  It might also help your debugging if you remove redundant comments, print statements, and variables. It will help you focus on the code and keep it clean. If you want to keep the print statements, you can compress two into one using formatting. See below for an example on how Python3 formatting works.\n\n```\nprint(f\"Nums: {nums}\")\nprint(f\"Left: {left}\")\nprint(f\"Right: {right}\")\nprint(f\"Target: {target}\")\n\ntarget_index = self.bs(nums, left, right, target)\nprint(f\"The target index is {target_index}\")\n```\n\nGive it a go. You got this. Let me know if you have any questions."
                    },
                    {
                        "username": "Rajeswari21",
                        "content": "I m getting an error for len() function  => \\n\\n\"TypeError: object of type \\'NoneType\\' has no len()\\n    high= len(nums)-1\\nLine 6 in search (Solution.py)\\n    ret = Solution().search(param_1, param_2)\\nLine 46 in _driver (Solution.py)\\n    _driver()\\nLine 57 in <module> (Solution.py)\"\\n\\n\\nMay I know what will be the reason?\\nProgramming Language: Python"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Rajeswari21](/Rajeswari21),\\n\\nCould you please share the rest of your solution? It\\'s difficult to determine the issue with one line of code.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1774343,
                "content": [
                    {
                        "username": "devesht709",
                        "content": "I think, It starts by setting the left pointer to the first element of the array and the right pointer to the last element. It then finds the middle element of the current search range by taking the average of the left and right pointers."
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "correct. now what?"
                    },
                    {
                        "username": "rahullakhchaura70",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        s=0\\n        e=len(nums)-1\\n        while s<=e:\\n            m=(s+e)//2\\n            if nums[m]>target:\\n                e=m-1\\n            elif nums[m]<target:\\n                s=m+1\\n            else:\\n                return m\\n        return -1"
                    },
                    {
                        "username": "rajKhatua",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int s=0;\\n        int e=nums.length-1; @\\n[leetcode](https://leetcode.com)\\n        while (s <= e) {\\n            int mid=s+(e-s)/2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (target>nums[mid]) {\\n                s=mid+1;\\n            }\\n            else if (target<nums[mid]){\\n                e=mid-1;\\n            }\\n            else{\\n                return mid;\\n            }\\n        }\\n        return -1;  \\n    }\\n}"
                    },
                    {
                        "username": "Er_Raja_Babu",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n    int n=nums.size();\\n    int low=0;\\n    int high=n-1;\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        if (nums[mid]==target)\\n        return mid;\\n        else if (nums[mid]<target)\\n        low=mid+1;\\n        else \\n        high=mid-1;\\n    }\\n    return -1;\\n    }    \\n};"
                    },
                    {
                        "username": "AnayNandode",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while(low <= high){\\n            int mid = (low >> 1) + (high >> 1);\\n            cout << mid << endl;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            else if(target > nums[mid]){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nwhy this code is giving tle?\\n"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Anay](/AnayNandode),\\n\\nYou\\'re almost there, but I see a few issues. Quick note: expand acronyms so that noobs understand what you are referring to. E.g. *tle -> time limit exceeded*\\nThere is a minor error in your syntax. When defining a vector in C++, you have to specify the data type of its elements. \\nE.g. ```vector<int> nums```\\nNot sure why you\\'re using bit manipulation, but eventually it starts returning incorrect results. You may want to consider keeping it simple and, honestly, it is rarely used for something like this. You probably wouldn\\'t want this in a codebase. Keep it simple.\\nAfter these corrections, you should be good to go."
                    },
                    {
                        "username": "silenthouse33011",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x0000003458fe bp 0x7fffcdc1d990 sp 0x7fffcdc1d988\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nCode : \\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0; int right = nums.size();\\n        int mid;\\n\\n        while(left <= right) {\\n            int mid = (left + right) / 2;\\n\\n            if(target == nums[mid]) {\\n                return mid;\\n            }\\n            if(nums[mid] > target) {\\n                right = mid - 1;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nWtf leetcode??"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "You set *right* to the size of the vector, which is not a valid index as vectors begin with index 0 and end at size - 1. Attempting to access an index that doesn\\'t exist will throw an error as you are trying to access memory outside of what\\'s been allocated. Also, not sure why your vector argument does not define the data type of its elements...is this a new C++ feature or something? I see this in others\\' C++ solutions that have failed as well."
                    },
                    {
                        "username": "TYork",
                        "content": "It sounds that  this one has been shot to the outer space, by the look of it"
                    },
                    {
                        "username": "Yash_Infinity",
                        "content": "can you tell me what\\'s the problem with this problem, i know this aint binary search or has time complexity of O(logn), but this gives error in general terms as well\\n\\n\\n\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int flag = -1 ;\\n        for(int i = 0; i < nums.size() ; i++)\\n        {\\n            if(nums[i] == target){\\n            flag = i - 1  ;\\n            break;}\\n        \\n\\n        }\\n        return flag;\\n        \\n    }"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "What's the error message?\n\nI couldn't reproduce any errors from your solution, but I can tell you what might change your results.\n\nWhat is the purpose of the flag variable? Is there another existing variable that can be used in place of it to return the index of the target?\n\nWhy are you setting the value of flag to the previous index? Your for loop starts at 0 and ends at 8 if the size() of nums is 9, for example.\n\nOnce you find the target, you can return the index from the function. If the function makes it past the loop, then whatever value representing no solution found can be returned."
                    },
                    {
                        "username": "abhiroopvadnam1289",
                        "content": "can you check my code  and tell me where i was wrong"
                    },
                    {
                        "username": "allubhurji",
                        "content": "# What edge cases am I not considering:\\n\\nif I don\\'t update using  ` r= mid -1 ` and ` l = mid+1 ` and instead use  `r = mid ` and  `l= mid` in the following code:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l = 0\\n        r = len(nums) -1 \\n        while l<r:\\n            mid =(l+r)//2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] > target:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        if nums[l] == target: return l\\n        \\n        return -1\\n```\\n"
                    },
                    {
                        "username": "Amir_tkbr",
                        "content": "I think that you can just spend more attempts trying to get target number. Try this code with r = mid n l  = mid:\n```\ndef search(nums: list[int], target: int):\n    attempts = 0\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        attempts += 1\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid, attempts\n        elif nums[mid] > target:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if nums[l] == target:\n        return l, attempts\n\n    return -1, attempts\n\n\nls = [i for i in range(10000)]\n\nprint(search(ls, 83))\n```"
                    },
                    {
                        "username": "ParthSharma007",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start=0;\\n        int end = nums.size()-1;\\n        \\n        while (start <= end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if (target > nums[mid]){\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            \\n        }\\n        return -1;\\n    }        \\n};"
                    }
                ]
            },
            {
                "id": 1773815,
                "content": [
                    {
                        "username": "devesht709",
                        "content": "I think, It starts by setting the left pointer to the first element of the array and the right pointer to the last element. It then finds the middle element of the current search range by taking the average of the left and right pointers."
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "correct. now what?"
                    },
                    {
                        "username": "rahullakhchaura70",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        s=0\\n        e=len(nums)-1\\n        while s<=e:\\n            m=(s+e)//2\\n            if nums[m]>target:\\n                e=m-1\\n            elif nums[m]<target:\\n                s=m+1\\n            else:\\n                return m\\n        return -1"
                    },
                    {
                        "username": "rajKhatua",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int s=0;\\n        int e=nums.length-1; @\\n[leetcode](https://leetcode.com)\\n        while (s <= e) {\\n            int mid=s+(e-s)/2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (target>nums[mid]) {\\n                s=mid+1;\\n            }\\n            else if (target<nums[mid]){\\n                e=mid-1;\\n            }\\n            else{\\n                return mid;\\n            }\\n        }\\n        return -1;  \\n    }\\n}"
                    },
                    {
                        "username": "Er_Raja_Babu",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n    int n=nums.size();\\n    int low=0;\\n    int high=n-1;\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        if (nums[mid]==target)\\n        return mid;\\n        else if (nums[mid]<target)\\n        low=mid+1;\\n        else \\n        high=mid-1;\\n    }\\n    return -1;\\n    }    \\n};"
                    },
                    {
                        "username": "AnayNandode",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while(low <= high){\\n            int mid = (low >> 1) + (high >> 1);\\n            cout << mid << endl;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            else if(target > nums[mid]){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nwhy this code is giving tle?\\n"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Anay](/AnayNandode),\\n\\nYou\\'re almost there, but I see a few issues. Quick note: expand acronyms so that noobs understand what you are referring to. E.g. *tle -> time limit exceeded*\\nThere is a minor error in your syntax. When defining a vector in C++, you have to specify the data type of its elements. \\nE.g. ```vector<int> nums```\\nNot sure why you\\'re using bit manipulation, but eventually it starts returning incorrect results. You may want to consider keeping it simple and, honestly, it is rarely used for something like this. You probably wouldn\\'t want this in a codebase. Keep it simple.\\nAfter these corrections, you should be good to go."
                    },
                    {
                        "username": "silenthouse33011",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x0000003458fe bp 0x7fffcdc1d990 sp 0x7fffcdc1d988\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nCode : \\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0; int right = nums.size();\\n        int mid;\\n\\n        while(left <= right) {\\n            int mid = (left + right) / 2;\\n\\n            if(target == nums[mid]) {\\n                return mid;\\n            }\\n            if(nums[mid] > target) {\\n                right = mid - 1;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nWtf leetcode??"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "You set *right* to the size of the vector, which is not a valid index as vectors begin with index 0 and end at size - 1. Attempting to access an index that doesn\\'t exist will throw an error as you are trying to access memory outside of what\\'s been allocated. Also, not sure why your vector argument does not define the data type of its elements...is this a new C++ feature or something? I see this in others\\' C++ solutions that have failed as well."
                    },
                    {
                        "username": "TYork",
                        "content": "It sounds that  this one has been shot to the outer space, by the look of it"
                    },
                    {
                        "username": "Yash_Infinity",
                        "content": "can you tell me what\\'s the problem with this problem, i know this aint binary search or has time complexity of O(logn), but this gives error in general terms as well\\n\\n\\n\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int flag = -1 ;\\n        for(int i = 0; i < nums.size() ; i++)\\n        {\\n            if(nums[i] == target){\\n            flag = i - 1  ;\\n            break;}\\n        \\n\\n        }\\n        return flag;\\n        \\n    }"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "What's the error message?\n\nI couldn't reproduce any errors from your solution, but I can tell you what might change your results.\n\nWhat is the purpose of the flag variable? Is there another existing variable that can be used in place of it to return the index of the target?\n\nWhy are you setting the value of flag to the previous index? Your for loop starts at 0 and ends at 8 if the size() of nums is 9, for example.\n\nOnce you find the target, you can return the index from the function. If the function makes it past the loop, then whatever value representing no solution found can be returned."
                    },
                    {
                        "username": "abhiroopvadnam1289",
                        "content": "can you check my code  and tell me where i was wrong"
                    },
                    {
                        "username": "allubhurji",
                        "content": "# What edge cases am I not considering:\\n\\nif I don\\'t update using  ` r= mid -1 ` and ` l = mid+1 ` and instead use  `r = mid ` and  `l= mid` in the following code:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l = 0\\n        r = len(nums) -1 \\n        while l<r:\\n            mid =(l+r)//2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] > target:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        if nums[l] == target: return l\\n        \\n        return -1\\n```\\n"
                    },
                    {
                        "username": "Amir_tkbr",
                        "content": "I think that you can just spend more attempts trying to get target number. Try this code with r = mid n l  = mid:\n```\ndef search(nums: list[int], target: int):\n    attempts = 0\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        attempts += 1\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid, attempts\n        elif nums[mid] > target:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if nums[l] == target:\n        return l, attempts\n\n    return -1, attempts\n\n\nls = [i for i in range(10000)]\n\nprint(search(ls, 83))\n```"
                    },
                    {
                        "username": "ParthSharma007",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start=0;\\n        int end = nums.size()-1;\\n        \\n        while (start <= end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if (target > nums[mid]){\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            \\n        }\\n        return -1;\\n    }        \\n};"
                    }
                ]
            },
            {
                "id": 1770629,
                "content": [
                    {
                        "username": "devesht709",
                        "content": "I think, It starts by setting the left pointer to the first element of the array and the right pointer to the last element. It then finds the middle element of the current search range by taking the average of the left and right pointers."
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "correct. now what?"
                    },
                    {
                        "username": "rahullakhchaura70",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        s=0\\n        e=len(nums)-1\\n        while s<=e:\\n            m=(s+e)//2\\n            if nums[m]>target:\\n                e=m-1\\n            elif nums[m]<target:\\n                s=m+1\\n            else:\\n                return m\\n        return -1"
                    },
                    {
                        "username": "rajKhatua",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int s=0;\\n        int e=nums.length-1; @\\n[leetcode](https://leetcode.com)\\n        while (s <= e) {\\n            int mid=s+(e-s)/2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (target>nums[mid]) {\\n                s=mid+1;\\n            }\\n            else if (target<nums[mid]){\\n                e=mid-1;\\n            }\\n            else{\\n                return mid;\\n            }\\n        }\\n        return -1;  \\n    }\\n}"
                    },
                    {
                        "username": "Er_Raja_Babu",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n    int n=nums.size();\\n    int low=0;\\n    int high=n-1;\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        if (nums[mid]==target)\\n        return mid;\\n        else if (nums[mid]<target)\\n        low=mid+1;\\n        else \\n        high=mid-1;\\n    }\\n    return -1;\\n    }    \\n};"
                    },
                    {
                        "username": "AnayNandode",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while(low <= high){\\n            int mid = (low >> 1) + (high >> 1);\\n            cout << mid << endl;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            else if(target > nums[mid]){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nwhy this code is giving tle?\\n"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Anay](/AnayNandode),\\n\\nYou\\'re almost there, but I see a few issues. Quick note: expand acronyms so that noobs understand what you are referring to. E.g. *tle -> time limit exceeded*\\nThere is a minor error in your syntax. When defining a vector in C++, you have to specify the data type of its elements. \\nE.g. ```vector<int> nums```\\nNot sure why you\\'re using bit manipulation, but eventually it starts returning incorrect results. You may want to consider keeping it simple and, honestly, it is rarely used for something like this. You probably wouldn\\'t want this in a codebase. Keep it simple.\\nAfter these corrections, you should be good to go."
                    },
                    {
                        "username": "silenthouse33011",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x0000003458fe bp 0x7fffcdc1d990 sp 0x7fffcdc1d988\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nCode : \\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0; int right = nums.size();\\n        int mid;\\n\\n        while(left <= right) {\\n            int mid = (left + right) / 2;\\n\\n            if(target == nums[mid]) {\\n                return mid;\\n            }\\n            if(nums[mid] > target) {\\n                right = mid - 1;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nWtf leetcode??"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "You set *right* to the size of the vector, which is not a valid index as vectors begin with index 0 and end at size - 1. Attempting to access an index that doesn\\'t exist will throw an error as you are trying to access memory outside of what\\'s been allocated. Also, not sure why your vector argument does not define the data type of its elements...is this a new C++ feature or something? I see this in others\\' C++ solutions that have failed as well."
                    },
                    {
                        "username": "TYork",
                        "content": "It sounds that  this one has been shot to the outer space, by the look of it"
                    },
                    {
                        "username": "Yash_Infinity",
                        "content": "can you tell me what\\'s the problem with this problem, i know this aint binary search or has time complexity of O(logn), but this gives error in general terms as well\\n\\n\\n\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int flag = -1 ;\\n        for(int i = 0; i < nums.size() ; i++)\\n        {\\n            if(nums[i] == target){\\n            flag = i - 1  ;\\n            break;}\\n        \\n\\n        }\\n        return flag;\\n        \\n    }"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "What's the error message?\n\nI couldn't reproduce any errors from your solution, but I can tell you what might change your results.\n\nWhat is the purpose of the flag variable? Is there another existing variable that can be used in place of it to return the index of the target?\n\nWhy are you setting the value of flag to the previous index? Your for loop starts at 0 and ends at 8 if the size() of nums is 9, for example.\n\nOnce you find the target, you can return the index from the function. If the function makes it past the loop, then whatever value representing no solution found can be returned."
                    },
                    {
                        "username": "abhiroopvadnam1289",
                        "content": "can you check my code  and tell me where i was wrong"
                    },
                    {
                        "username": "allubhurji",
                        "content": "# What edge cases am I not considering:\\n\\nif I don\\'t update using  ` r= mid -1 ` and ` l = mid+1 ` and instead use  `r = mid ` and  `l= mid` in the following code:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l = 0\\n        r = len(nums) -1 \\n        while l<r:\\n            mid =(l+r)//2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] > target:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        if nums[l] == target: return l\\n        \\n        return -1\\n```\\n"
                    },
                    {
                        "username": "Amir_tkbr",
                        "content": "I think that you can just spend more attempts trying to get target number. Try this code with r = mid n l  = mid:\n```\ndef search(nums: list[int], target: int):\n    attempts = 0\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        attempts += 1\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid, attempts\n        elif nums[mid] > target:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if nums[l] == target:\n        return l, attempts\n\n    return -1, attempts\n\n\nls = [i for i in range(10000)]\n\nprint(search(ls, 83))\n```"
                    },
                    {
                        "username": "ParthSharma007",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start=0;\\n        int end = nums.size()-1;\\n        \\n        while (start <= end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if (target > nums[mid]){\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            \\n        }\\n        return -1;\\n    }        \\n};"
                    }
                ]
            },
            {
                "id": 1761643,
                "content": [
                    {
                        "username": "devesht709",
                        "content": "I think, It starts by setting the left pointer to the first element of the array and the right pointer to the last element. It then finds the middle element of the current search range by taking the average of the left and right pointers."
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "correct. now what?"
                    },
                    {
                        "username": "rahullakhchaura70",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        s=0\\n        e=len(nums)-1\\n        while s<=e:\\n            m=(s+e)//2\\n            if nums[m]>target:\\n                e=m-1\\n            elif nums[m]<target:\\n                s=m+1\\n            else:\\n                return m\\n        return -1"
                    },
                    {
                        "username": "rajKhatua",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int s=0;\\n        int e=nums.length-1; @\\n[leetcode](https://leetcode.com)\\n        while (s <= e) {\\n            int mid=s+(e-s)/2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (target>nums[mid]) {\\n                s=mid+1;\\n            }\\n            else if (target<nums[mid]){\\n                e=mid-1;\\n            }\\n            else{\\n                return mid;\\n            }\\n        }\\n        return -1;  \\n    }\\n}"
                    },
                    {
                        "username": "Er_Raja_Babu",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n    int n=nums.size();\\n    int low=0;\\n    int high=n-1;\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        if (nums[mid]==target)\\n        return mid;\\n        else if (nums[mid]<target)\\n        low=mid+1;\\n        else \\n        high=mid-1;\\n    }\\n    return -1;\\n    }    \\n};"
                    },
                    {
                        "username": "AnayNandode",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while(low <= high){\\n            int mid = (low >> 1) + (high >> 1);\\n            cout << mid << endl;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            else if(target > nums[mid]){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nwhy this code is giving tle?\\n"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Anay](/AnayNandode),\\n\\nYou\\'re almost there, but I see a few issues. Quick note: expand acronyms so that noobs understand what you are referring to. E.g. *tle -> time limit exceeded*\\nThere is a minor error in your syntax. When defining a vector in C++, you have to specify the data type of its elements. \\nE.g. ```vector<int> nums```\\nNot sure why you\\'re using bit manipulation, but eventually it starts returning incorrect results. You may want to consider keeping it simple and, honestly, it is rarely used for something like this. You probably wouldn\\'t want this in a codebase. Keep it simple.\\nAfter these corrections, you should be good to go."
                    },
                    {
                        "username": "silenthouse33011",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x0000003458fe bp 0x7fffcdc1d990 sp 0x7fffcdc1d988\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nCode : \\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0; int right = nums.size();\\n        int mid;\\n\\n        while(left <= right) {\\n            int mid = (left + right) / 2;\\n\\n            if(target == nums[mid]) {\\n                return mid;\\n            }\\n            if(nums[mid] > target) {\\n                right = mid - 1;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nWtf leetcode??"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "You set *right* to the size of the vector, which is not a valid index as vectors begin with index 0 and end at size - 1. Attempting to access an index that doesn\\'t exist will throw an error as you are trying to access memory outside of what\\'s been allocated. Also, not sure why your vector argument does not define the data type of its elements...is this a new C++ feature or something? I see this in others\\' C++ solutions that have failed as well."
                    },
                    {
                        "username": "TYork",
                        "content": "It sounds that  this one has been shot to the outer space, by the look of it"
                    },
                    {
                        "username": "Yash_Infinity",
                        "content": "can you tell me what\\'s the problem with this problem, i know this aint binary search or has time complexity of O(logn), but this gives error in general terms as well\\n\\n\\n\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int flag = -1 ;\\n        for(int i = 0; i < nums.size() ; i++)\\n        {\\n            if(nums[i] == target){\\n            flag = i - 1  ;\\n            break;}\\n        \\n\\n        }\\n        return flag;\\n        \\n    }"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "What's the error message?\n\nI couldn't reproduce any errors from your solution, but I can tell you what might change your results.\n\nWhat is the purpose of the flag variable? Is there another existing variable that can be used in place of it to return the index of the target?\n\nWhy are you setting the value of flag to the previous index? Your for loop starts at 0 and ends at 8 if the size() of nums is 9, for example.\n\nOnce you find the target, you can return the index from the function. If the function makes it past the loop, then whatever value representing no solution found can be returned."
                    },
                    {
                        "username": "abhiroopvadnam1289",
                        "content": "can you check my code  and tell me where i was wrong"
                    },
                    {
                        "username": "allubhurji",
                        "content": "# What edge cases am I not considering:\\n\\nif I don\\'t update using  ` r= mid -1 ` and ` l = mid+1 ` and instead use  `r = mid ` and  `l= mid` in the following code:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l = 0\\n        r = len(nums) -1 \\n        while l<r:\\n            mid =(l+r)//2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] > target:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        if nums[l] == target: return l\\n        \\n        return -1\\n```\\n"
                    },
                    {
                        "username": "Amir_tkbr",
                        "content": "I think that you can just spend more attempts trying to get target number. Try this code with r = mid n l  = mid:\n```\ndef search(nums: list[int], target: int):\n    attempts = 0\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        attempts += 1\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid, attempts\n        elif nums[mid] > target:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if nums[l] == target:\n        return l, attempts\n\n    return -1, attempts\n\n\nls = [i for i in range(10000)]\n\nprint(search(ls, 83))\n```"
                    },
                    {
                        "username": "ParthSharma007",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start=0;\\n        int end = nums.size()-1;\\n        \\n        while (start <= end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if (target > nums[mid]){\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            \\n        }\\n        return -1;\\n    }        \\n};"
                    }
                ]
            },
            {
                "id": 1757381,
                "content": [
                    {
                        "username": "devesht709",
                        "content": "I think, It starts by setting the left pointer to the first element of the array and the right pointer to the last element. It then finds the middle element of the current search range by taking the average of the left and right pointers."
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "correct. now what?"
                    },
                    {
                        "username": "rahullakhchaura70",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        s=0\\n        e=len(nums)-1\\n        while s<=e:\\n            m=(s+e)//2\\n            if nums[m]>target:\\n                e=m-1\\n            elif nums[m]<target:\\n                s=m+1\\n            else:\\n                return m\\n        return -1"
                    },
                    {
                        "username": "rajKhatua",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int s=0;\\n        int e=nums.length-1; @\\n[leetcode](https://leetcode.com)\\n        while (s <= e) {\\n            int mid=s+(e-s)/2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (target>nums[mid]) {\\n                s=mid+1;\\n            }\\n            else if (target<nums[mid]){\\n                e=mid-1;\\n            }\\n            else{\\n                return mid;\\n            }\\n        }\\n        return -1;  \\n    }\\n}"
                    },
                    {
                        "username": "Er_Raja_Babu",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n    int n=nums.size();\\n    int low=0;\\n    int high=n-1;\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        if (nums[mid]==target)\\n        return mid;\\n        else if (nums[mid]<target)\\n        low=mid+1;\\n        else \\n        high=mid-1;\\n    }\\n    return -1;\\n    }    \\n};"
                    },
                    {
                        "username": "AnayNandode",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while(low <= high){\\n            int mid = (low >> 1) + (high >> 1);\\n            cout << mid << endl;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            else if(target > nums[mid]){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nwhy this code is giving tle?\\n"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Anay](/AnayNandode),\\n\\nYou\\'re almost there, but I see a few issues. Quick note: expand acronyms so that noobs understand what you are referring to. E.g. *tle -> time limit exceeded*\\nThere is a minor error in your syntax. When defining a vector in C++, you have to specify the data type of its elements. \\nE.g. ```vector<int> nums```\\nNot sure why you\\'re using bit manipulation, but eventually it starts returning incorrect results. You may want to consider keeping it simple and, honestly, it is rarely used for something like this. You probably wouldn\\'t want this in a codebase. Keep it simple.\\nAfter these corrections, you should be good to go."
                    },
                    {
                        "username": "silenthouse33011",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x0000003458fe bp 0x7fffcdc1d990 sp 0x7fffcdc1d988\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nCode : \\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0; int right = nums.size();\\n        int mid;\\n\\n        while(left <= right) {\\n            int mid = (left + right) / 2;\\n\\n            if(target == nums[mid]) {\\n                return mid;\\n            }\\n            if(nums[mid] > target) {\\n                right = mid - 1;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nWtf leetcode??"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "You set *right* to the size of the vector, which is not a valid index as vectors begin with index 0 and end at size - 1. Attempting to access an index that doesn\\'t exist will throw an error as you are trying to access memory outside of what\\'s been allocated. Also, not sure why your vector argument does not define the data type of its elements...is this a new C++ feature or something? I see this in others\\' C++ solutions that have failed as well."
                    },
                    {
                        "username": "TYork",
                        "content": "It sounds that  this one has been shot to the outer space, by the look of it"
                    },
                    {
                        "username": "Yash_Infinity",
                        "content": "can you tell me what\\'s the problem with this problem, i know this aint binary search or has time complexity of O(logn), but this gives error in general terms as well\\n\\n\\n\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int flag = -1 ;\\n        for(int i = 0; i < nums.size() ; i++)\\n        {\\n            if(nums[i] == target){\\n            flag = i - 1  ;\\n            break;}\\n        \\n\\n        }\\n        return flag;\\n        \\n    }"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "What's the error message?\n\nI couldn't reproduce any errors from your solution, but I can tell you what might change your results.\n\nWhat is the purpose of the flag variable? Is there another existing variable that can be used in place of it to return the index of the target?\n\nWhy are you setting the value of flag to the previous index? Your for loop starts at 0 and ends at 8 if the size() of nums is 9, for example.\n\nOnce you find the target, you can return the index from the function. If the function makes it past the loop, then whatever value representing no solution found can be returned."
                    },
                    {
                        "username": "abhiroopvadnam1289",
                        "content": "can you check my code  and tell me where i was wrong"
                    },
                    {
                        "username": "allubhurji",
                        "content": "# What edge cases am I not considering:\\n\\nif I don\\'t update using  ` r= mid -1 ` and ` l = mid+1 ` and instead use  `r = mid ` and  `l= mid` in the following code:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l = 0\\n        r = len(nums) -1 \\n        while l<r:\\n            mid =(l+r)//2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] > target:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        if nums[l] == target: return l\\n        \\n        return -1\\n```\\n"
                    },
                    {
                        "username": "Amir_tkbr",
                        "content": "I think that you can just spend more attempts trying to get target number. Try this code with r = mid n l  = mid:\n```\ndef search(nums: list[int], target: int):\n    attempts = 0\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        attempts += 1\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid, attempts\n        elif nums[mid] > target:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if nums[l] == target:\n        return l, attempts\n\n    return -1, attempts\n\n\nls = [i for i in range(10000)]\n\nprint(search(ls, 83))\n```"
                    },
                    {
                        "username": "ParthSharma007",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start=0;\\n        int end = nums.size()-1;\\n        \\n        while (start <= end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if (target > nums[mid]){\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            \\n        }\\n        return -1;\\n    }        \\n};"
                    }
                ]
            },
            {
                "id": 1753760,
                "content": [
                    {
                        "username": "devesht709",
                        "content": "I think, It starts by setting the left pointer to the first element of the array and the right pointer to the last element. It then finds the middle element of the current search range by taking the average of the left and right pointers."
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "correct. now what?"
                    },
                    {
                        "username": "rahullakhchaura70",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        s=0\\n        e=len(nums)-1\\n        while s<=e:\\n            m=(s+e)//2\\n            if nums[m]>target:\\n                e=m-1\\n            elif nums[m]<target:\\n                s=m+1\\n            else:\\n                return m\\n        return -1"
                    },
                    {
                        "username": "rajKhatua",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int s=0;\\n        int e=nums.length-1; @\\n[leetcode](https://leetcode.com)\\n        while (s <= e) {\\n            int mid=s+(e-s)/2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (target>nums[mid]) {\\n                s=mid+1;\\n            }\\n            else if (target<nums[mid]){\\n                e=mid-1;\\n            }\\n            else{\\n                return mid;\\n            }\\n        }\\n        return -1;  \\n    }\\n}"
                    },
                    {
                        "username": "Er_Raja_Babu",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n    int n=nums.size();\\n    int low=0;\\n    int high=n-1;\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        if (nums[mid]==target)\\n        return mid;\\n        else if (nums[mid]<target)\\n        low=mid+1;\\n        else \\n        high=mid-1;\\n    }\\n    return -1;\\n    }    \\n};"
                    },
                    {
                        "username": "AnayNandode",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while(low <= high){\\n            int mid = (low >> 1) + (high >> 1);\\n            cout << mid << endl;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            else if(target > nums[mid]){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nwhy this code is giving tle?\\n"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Anay](/AnayNandode),\\n\\nYou\\'re almost there, but I see a few issues. Quick note: expand acronyms so that noobs understand what you are referring to. E.g. *tle -> time limit exceeded*\\nThere is a minor error in your syntax. When defining a vector in C++, you have to specify the data type of its elements. \\nE.g. ```vector<int> nums```\\nNot sure why you\\'re using bit manipulation, but eventually it starts returning incorrect results. You may want to consider keeping it simple and, honestly, it is rarely used for something like this. You probably wouldn\\'t want this in a codebase. Keep it simple.\\nAfter these corrections, you should be good to go."
                    },
                    {
                        "username": "silenthouse33011",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x0000003458fe bp 0x7fffcdc1d990 sp 0x7fffcdc1d988\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nCode : \\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0; int right = nums.size();\\n        int mid;\\n\\n        while(left <= right) {\\n            int mid = (left + right) / 2;\\n\\n            if(target == nums[mid]) {\\n                return mid;\\n            }\\n            if(nums[mid] > target) {\\n                right = mid - 1;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nWtf leetcode??"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "You set *right* to the size of the vector, which is not a valid index as vectors begin with index 0 and end at size - 1. Attempting to access an index that doesn\\'t exist will throw an error as you are trying to access memory outside of what\\'s been allocated. Also, not sure why your vector argument does not define the data type of its elements...is this a new C++ feature or something? I see this in others\\' C++ solutions that have failed as well."
                    },
                    {
                        "username": "TYork",
                        "content": "It sounds that  this one has been shot to the outer space, by the look of it"
                    },
                    {
                        "username": "Yash_Infinity",
                        "content": "can you tell me what\\'s the problem with this problem, i know this aint binary search or has time complexity of O(logn), but this gives error in general terms as well\\n\\n\\n\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int flag = -1 ;\\n        for(int i = 0; i < nums.size() ; i++)\\n        {\\n            if(nums[i] == target){\\n            flag = i - 1  ;\\n            break;}\\n        \\n\\n        }\\n        return flag;\\n        \\n    }"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "What's the error message?\n\nI couldn't reproduce any errors from your solution, but I can tell you what might change your results.\n\nWhat is the purpose of the flag variable? Is there another existing variable that can be used in place of it to return the index of the target?\n\nWhy are you setting the value of flag to the previous index? Your for loop starts at 0 and ends at 8 if the size() of nums is 9, for example.\n\nOnce you find the target, you can return the index from the function. If the function makes it past the loop, then whatever value representing no solution found can be returned."
                    },
                    {
                        "username": "abhiroopvadnam1289",
                        "content": "can you check my code  and tell me where i was wrong"
                    },
                    {
                        "username": "allubhurji",
                        "content": "# What edge cases am I not considering:\\n\\nif I don\\'t update using  ` r= mid -1 ` and ` l = mid+1 ` and instead use  `r = mid ` and  `l= mid` in the following code:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l = 0\\n        r = len(nums) -1 \\n        while l<r:\\n            mid =(l+r)//2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] > target:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        if nums[l] == target: return l\\n        \\n        return -1\\n```\\n"
                    },
                    {
                        "username": "Amir_tkbr",
                        "content": "I think that you can just spend more attempts trying to get target number. Try this code with r = mid n l  = mid:\n```\ndef search(nums: list[int], target: int):\n    attempts = 0\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        attempts += 1\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid, attempts\n        elif nums[mid] > target:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if nums[l] == target:\n        return l, attempts\n\n    return -1, attempts\n\n\nls = [i for i in range(10000)]\n\nprint(search(ls, 83))\n```"
                    },
                    {
                        "username": "ParthSharma007",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start=0;\\n        int end = nums.size()-1;\\n        \\n        while (start <= end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if (target > nums[mid]){\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            \\n        }\\n        return -1;\\n    }        \\n};"
                    }
                ]
            },
            {
                "id": 1751350,
                "content": [
                    {
                        "username": "devesht709",
                        "content": "I think, It starts by setting the left pointer to the first element of the array and the right pointer to the last element. It then finds the middle element of the current search range by taking the average of the left and right pointers."
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "correct. now what?"
                    },
                    {
                        "username": "rahullakhchaura70",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        s=0\\n        e=len(nums)-1\\n        while s<=e:\\n            m=(s+e)//2\\n            if nums[m]>target:\\n                e=m-1\\n            elif nums[m]<target:\\n                s=m+1\\n            else:\\n                return m\\n        return -1"
                    },
                    {
                        "username": "rajKhatua",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int s=0;\\n        int e=nums.length-1; @\\n[leetcode](https://leetcode.com)\\n        while (s <= e) {\\n            int mid=s+(e-s)/2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (target>nums[mid]) {\\n                s=mid+1;\\n            }\\n            else if (target<nums[mid]){\\n                e=mid-1;\\n            }\\n            else{\\n                return mid;\\n            }\\n        }\\n        return -1;  \\n    }\\n}"
                    },
                    {
                        "username": "Er_Raja_Babu",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n    int n=nums.size();\\n    int low=0;\\n    int high=n-1;\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        if (nums[mid]==target)\\n        return mid;\\n        else if (nums[mid]<target)\\n        low=mid+1;\\n        else \\n        high=mid-1;\\n    }\\n    return -1;\\n    }    \\n};"
                    },
                    {
                        "username": "AnayNandode",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while(low <= high){\\n            int mid = (low >> 1) + (high >> 1);\\n            cout << mid << endl;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            else if(target > nums[mid]){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nwhy this code is giving tle?\\n"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Anay](/AnayNandode),\\n\\nYou\\'re almost there, but I see a few issues. Quick note: expand acronyms so that noobs understand what you are referring to. E.g. *tle -> time limit exceeded*\\nThere is a minor error in your syntax. When defining a vector in C++, you have to specify the data type of its elements. \\nE.g. ```vector<int> nums```\\nNot sure why you\\'re using bit manipulation, but eventually it starts returning incorrect results. You may want to consider keeping it simple and, honestly, it is rarely used for something like this. You probably wouldn\\'t want this in a codebase. Keep it simple.\\nAfter these corrections, you should be good to go."
                    },
                    {
                        "username": "silenthouse33011",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x0000003458fe bp 0x7fffcdc1d990 sp 0x7fffcdc1d988\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nCode : \\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0; int right = nums.size();\\n        int mid;\\n\\n        while(left <= right) {\\n            int mid = (left + right) / 2;\\n\\n            if(target == nums[mid]) {\\n                return mid;\\n            }\\n            if(nums[mid] > target) {\\n                right = mid - 1;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nWtf leetcode??"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "You set *right* to the size of the vector, which is not a valid index as vectors begin with index 0 and end at size - 1. Attempting to access an index that doesn\\'t exist will throw an error as you are trying to access memory outside of what\\'s been allocated. Also, not sure why your vector argument does not define the data type of its elements...is this a new C++ feature or something? I see this in others\\' C++ solutions that have failed as well."
                    },
                    {
                        "username": "TYork",
                        "content": "It sounds that  this one has been shot to the outer space, by the look of it"
                    },
                    {
                        "username": "Yash_Infinity",
                        "content": "can you tell me what\\'s the problem with this problem, i know this aint binary search or has time complexity of O(logn), but this gives error in general terms as well\\n\\n\\n\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int flag = -1 ;\\n        for(int i = 0; i < nums.size() ; i++)\\n        {\\n            if(nums[i] == target){\\n            flag = i - 1  ;\\n            break;}\\n        \\n\\n        }\\n        return flag;\\n        \\n    }"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "What's the error message?\n\nI couldn't reproduce any errors from your solution, but I can tell you what might change your results.\n\nWhat is the purpose of the flag variable? Is there another existing variable that can be used in place of it to return the index of the target?\n\nWhy are you setting the value of flag to the previous index? Your for loop starts at 0 and ends at 8 if the size() of nums is 9, for example.\n\nOnce you find the target, you can return the index from the function. If the function makes it past the loop, then whatever value representing no solution found can be returned."
                    },
                    {
                        "username": "abhiroopvadnam1289",
                        "content": "can you check my code  and tell me where i was wrong"
                    },
                    {
                        "username": "allubhurji",
                        "content": "# What edge cases am I not considering:\\n\\nif I don\\'t update using  ` r= mid -1 ` and ` l = mid+1 ` and instead use  `r = mid ` and  `l= mid` in the following code:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l = 0\\n        r = len(nums) -1 \\n        while l<r:\\n            mid =(l+r)//2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] > target:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        if nums[l] == target: return l\\n        \\n        return -1\\n```\\n"
                    },
                    {
                        "username": "Amir_tkbr",
                        "content": "I think that you can just spend more attempts trying to get target number. Try this code with r = mid n l  = mid:\n```\ndef search(nums: list[int], target: int):\n    attempts = 0\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        attempts += 1\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid, attempts\n        elif nums[mid] > target:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if nums[l] == target:\n        return l, attempts\n\n    return -1, attempts\n\n\nls = [i for i in range(10000)]\n\nprint(search(ls, 83))\n```"
                    },
                    {
                        "username": "ParthSharma007",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start=0;\\n        int end = nums.size()-1;\\n        \\n        while (start <= end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if (target > nums[mid]){\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            \\n        }\\n        return -1;\\n    }        \\n};"
                    }
                ]
            },
            {
                "id": 1744699,
                "content": [
                    {
                        "username": "devesht709",
                        "content": "I think, It starts by setting the left pointer to the first element of the array and the right pointer to the last element. It then finds the middle element of the current search range by taking the average of the left and right pointers."
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "correct. now what?"
                    },
                    {
                        "username": "rahullakhchaura70",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        s=0\\n        e=len(nums)-1\\n        while s<=e:\\n            m=(s+e)//2\\n            if nums[m]>target:\\n                e=m-1\\n            elif nums[m]<target:\\n                s=m+1\\n            else:\\n                return m\\n        return -1"
                    },
                    {
                        "username": "rajKhatua",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int s=0;\\n        int e=nums.length-1; @\\n[leetcode](https://leetcode.com)\\n        while (s <= e) {\\n            int mid=s+(e-s)/2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (target>nums[mid]) {\\n                s=mid+1;\\n            }\\n            else if (target<nums[mid]){\\n                e=mid-1;\\n            }\\n            else{\\n                return mid;\\n            }\\n        }\\n        return -1;  \\n    }\\n}"
                    },
                    {
                        "username": "Er_Raja_Babu",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n    int n=nums.size();\\n    int low=0;\\n    int high=n-1;\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        if (nums[mid]==target)\\n        return mid;\\n        else if (nums[mid]<target)\\n        low=mid+1;\\n        else \\n        high=mid-1;\\n    }\\n    return -1;\\n    }    \\n};"
                    },
                    {
                        "username": "AnayNandode",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while(low <= high){\\n            int mid = (low >> 1) + (high >> 1);\\n            cout << mid << endl;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            else if(target > nums[mid]){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nwhy this code is giving tle?\\n"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Anay](/AnayNandode),\\n\\nYou\\'re almost there, but I see a few issues. Quick note: expand acronyms so that noobs understand what you are referring to. E.g. *tle -> time limit exceeded*\\nThere is a minor error in your syntax. When defining a vector in C++, you have to specify the data type of its elements. \\nE.g. ```vector<int> nums```\\nNot sure why you\\'re using bit manipulation, but eventually it starts returning incorrect results. You may want to consider keeping it simple and, honestly, it is rarely used for something like this. You probably wouldn\\'t want this in a codebase. Keep it simple.\\nAfter these corrections, you should be good to go."
                    },
                    {
                        "username": "silenthouse33011",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x0000003458fe bp 0x7fffcdc1d990 sp 0x7fffcdc1d988\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nCode : \\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0; int right = nums.size();\\n        int mid;\\n\\n        while(left <= right) {\\n            int mid = (left + right) / 2;\\n\\n            if(target == nums[mid]) {\\n                return mid;\\n            }\\n            if(nums[mid] > target) {\\n                right = mid - 1;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nWtf leetcode??"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "You set *right* to the size of the vector, which is not a valid index as vectors begin with index 0 and end at size - 1. Attempting to access an index that doesn\\'t exist will throw an error as you are trying to access memory outside of what\\'s been allocated. Also, not sure why your vector argument does not define the data type of its elements...is this a new C++ feature or something? I see this in others\\' C++ solutions that have failed as well."
                    },
                    {
                        "username": "TYork",
                        "content": "It sounds that  this one has been shot to the outer space, by the look of it"
                    },
                    {
                        "username": "Yash_Infinity",
                        "content": "can you tell me what\\'s the problem with this problem, i know this aint binary search or has time complexity of O(logn), but this gives error in general terms as well\\n\\n\\n\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int flag = -1 ;\\n        for(int i = 0; i < nums.size() ; i++)\\n        {\\n            if(nums[i] == target){\\n            flag = i - 1  ;\\n            break;}\\n        \\n\\n        }\\n        return flag;\\n        \\n    }"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "What's the error message?\n\nI couldn't reproduce any errors from your solution, but I can tell you what might change your results.\n\nWhat is the purpose of the flag variable? Is there another existing variable that can be used in place of it to return the index of the target?\n\nWhy are you setting the value of flag to the previous index? Your for loop starts at 0 and ends at 8 if the size() of nums is 9, for example.\n\nOnce you find the target, you can return the index from the function. If the function makes it past the loop, then whatever value representing no solution found can be returned."
                    },
                    {
                        "username": "abhiroopvadnam1289",
                        "content": "can you check my code  and tell me where i was wrong"
                    },
                    {
                        "username": "allubhurji",
                        "content": "# What edge cases am I not considering:\\n\\nif I don\\'t update using  ` r= mid -1 ` and ` l = mid+1 ` and instead use  `r = mid ` and  `l= mid` in the following code:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l = 0\\n        r = len(nums) -1 \\n        while l<r:\\n            mid =(l+r)//2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] > target:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        if nums[l] == target: return l\\n        \\n        return -1\\n```\\n"
                    },
                    {
                        "username": "Amir_tkbr",
                        "content": "I think that you can just spend more attempts trying to get target number. Try this code with r = mid n l  = mid:\n```\ndef search(nums: list[int], target: int):\n    attempts = 0\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        attempts += 1\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid, attempts\n        elif nums[mid] > target:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if nums[l] == target:\n        return l, attempts\n\n    return -1, attempts\n\n\nls = [i for i in range(10000)]\n\nprint(search(ls, 83))\n```"
                    },
                    {
                        "username": "ParthSharma007",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start=0;\\n        int end = nums.size()-1;\\n        \\n        while (start <= end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if (target > nums[mid]){\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            \\n        }\\n        return -1;\\n    }        \\n};"
                    }
                ]
            },
            {
                "id": 1742553,
                "content": [
                    {
                        "username": "devesht709",
                        "content": "I think, It starts by setting the left pointer to the first element of the array and the right pointer to the last element. It then finds the middle element of the current search range by taking the average of the left and right pointers."
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "correct. now what?"
                    },
                    {
                        "username": "rahullakhchaura70",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        s=0\\n        e=len(nums)-1\\n        while s<=e:\\n            m=(s+e)//2\\n            if nums[m]>target:\\n                e=m-1\\n            elif nums[m]<target:\\n                s=m+1\\n            else:\\n                return m\\n        return -1"
                    },
                    {
                        "username": "rajKhatua",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int s=0;\\n        int e=nums.length-1; @\\n[leetcode](https://leetcode.com)\\n        while (s <= e) {\\n            int mid=s+(e-s)/2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (target>nums[mid]) {\\n                s=mid+1;\\n            }\\n            else if (target<nums[mid]){\\n                e=mid-1;\\n            }\\n            else{\\n                return mid;\\n            }\\n        }\\n        return -1;  \\n    }\\n}"
                    },
                    {
                        "username": "Er_Raja_Babu",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n    int n=nums.size();\\n    int low=0;\\n    int high=n-1;\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        if (nums[mid]==target)\\n        return mid;\\n        else if (nums[mid]<target)\\n        low=mid+1;\\n        else \\n        high=mid-1;\\n    }\\n    return -1;\\n    }    \\n};"
                    },
                    {
                        "username": "AnayNandode",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while(low <= high){\\n            int mid = (low >> 1) + (high >> 1);\\n            cout << mid << endl;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            else if(target > nums[mid]){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nwhy this code is giving tle?\\n"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Anay](/AnayNandode),\\n\\nYou\\'re almost there, but I see a few issues. Quick note: expand acronyms so that noobs understand what you are referring to. E.g. *tle -> time limit exceeded*\\nThere is a minor error in your syntax. When defining a vector in C++, you have to specify the data type of its elements. \\nE.g. ```vector<int> nums```\\nNot sure why you\\'re using bit manipulation, but eventually it starts returning incorrect results. You may want to consider keeping it simple and, honestly, it is rarely used for something like this. You probably wouldn\\'t want this in a codebase. Keep it simple.\\nAfter these corrections, you should be good to go."
                    },
                    {
                        "username": "silenthouse33011",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x0000003458fe bp 0x7fffcdc1d990 sp 0x7fffcdc1d988\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nCode : \\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0; int right = nums.size();\\n        int mid;\\n\\n        while(left <= right) {\\n            int mid = (left + right) / 2;\\n\\n            if(target == nums[mid]) {\\n                return mid;\\n            }\\n            if(nums[mid] > target) {\\n                right = mid - 1;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nWtf leetcode??"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "You set *right* to the size of the vector, which is not a valid index as vectors begin with index 0 and end at size - 1. Attempting to access an index that doesn\\'t exist will throw an error as you are trying to access memory outside of what\\'s been allocated. Also, not sure why your vector argument does not define the data type of its elements...is this a new C++ feature or something? I see this in others\\' C++ solutions that have failed as well."
                    },
                    {
                        "username": "TYork",
                        "content": "It sounds that  this one has been shot to the outer space, by the look of it"
                    },
                    {
                        "username": "Yash_Infinity",
                        "content": "can you tell me what\\'s the problem with this problem, i know this aint binary search or has time complexity of O(logn), but this gives error in general terms as well\\n\\n\\n\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int flag = -1 ;\\n        for(int i = 0; i < nums.size() ; i++)\\n        {\\n            if(nums[i] == target){\\n            flag = i - 1  ;\\n            break;}\\n        \\n\\n        }\\n        return flag;\\n        \\n    }"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "What's the error message?\n\nI couldn't reproduce any errors from your solution, but I can tell you what might change your results.\n\nWhat is the purpose of the flag variable? Is there another existing variable that can be used in place of it to return the index of the target?\n\nWhy are you setting the value of flag to the previous index? Your for loop starts at 0 and ends at 8 if the size() of nums is 9, for example.\n\nOnce you find the target, you can return the index from the function. If the function makes it past the loop, then whatever value representing no solution found can be returned."
                    },
                    {
                        "username": "abhiroopvadnam1289",
                        "content": "can you check my code  and tell me where i was wrong"
                    },
                    {
                        "username": "allubhurji",
                        "content": "# What edge cases am I not considering:\\n\\nif I don\\'t update using  ` r= mid -1 ` and ` l = mid+1 ` and instead use  `r = mid ` and  `l= mid` in the following code:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l = 0\\n        r = len(nums) -1 \\n        while l<r:\\n            mid =(l+r)//2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] > target:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        if nums[l] == target: return l\\n        \\n        return -1\\n```\\n"
                    },
                    {
                        "username": "Amir_tkbr",
                        "content": "I think that you can just spend more attempts trying to get target number. Try this code with r = mid n l  = mid:\n```\ndef search(nums: list[int], target: int):\n    attempts = 0\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        attempts += 1\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid, attempts\n        elif nums[mid] > target:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if nums[l] == target:\n        return l, attempts\n\n    return -1, attempts\n\n\nls = [i for i in range(10000)]\n\nprint(search(ls, 83))\n```"
                    },
                    {
                        "username": "ParthSharma007",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start=0;\\n        int end = nums.size()-1;\\n        \\n        while (start <= end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if (target > nums[mid]){\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            \\n        }\\n        return -1;\\n    }        \\n};"
                    }
                ]
            },
            {
                "id": 1738600,
                "content": [
                    {
                        "username": "devesht709",
                        "content": "I think, It starts by setting the left pointer to the first element of the array and the right pointer to the last element. It then finds the middle element of the current search range by taking the average of the left and right pointers."
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "correct. now what?"
                    },
                    {
                        "username": "rahullakhchaura70",
                        "content": "class Solution(object):\\n    def search(self, nums, target):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type target: int\\n        :rtype: int\\n        \"\"\"\\n        s=0\\n        e=len(nums)-1\\n        while s<=e:\\n            m=(s+e)//2\\n            if nums[m]>target:\\n                e=m-1\\n            elif nums[m]<target:\\n                s=m+1\\n            else:\\n                return m\\n        return -1"
                    },
                    {
                        "username": "rajKhatua",
                        "content": "class Solution {\\n    public int search(int[] nums, int target) {\\n        int s=0;\\n        int e=nums.length-1; @\\n[leetcode](https://leetcode.com)\\n        while (s <= e) {\\n            int mid=s+(e-s)/2;\\n            if (nums[mid] == target) {\\n                return mid;\\n            }\\n            else if (target>nums[mid]) {\\n                s=mid+1;\\n            }\\n            else if (target<nums[mid]){\\n                e=mid-1;\\n            }\\n            else{\\n                return mid;\\n            }\\n        }\\n        return -1;  \\n    }\\n}"
                    },
                    {
                        "username": "Er_Raja_Babu",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) \\n    {\\n    int n=nums.size();\\n    int low=0;\\n    int high=n-1;\\n    while(low<=high)\\n    {\\n        int mid=(low+high)/2;\\n        if (nums[mid]==target)\\n        return mid;\\n        else if (nums[mid]<target)\\n        low=mid+1;\\n        else \\n        high=mid-1;\\n    }\\n    return -1;\\n    }    \\n};"
                    },
                    {
                        "username": "AnayNandode",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int low = 0, high = nums.size() - 1;\\n        while(low <= high){\\n            int mid = (low >> 1) + (high >> 1);\\n            cout << mid << endl;\\n            if(nums[mid] == target){\\n                return mid;\\n            }\\n            else if(target > nums[mid]){\\n                low = mid + 1;\\n            }\\n            else{\\n                high = mid - 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nwhy this code is giving tle?\\n"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "Hi [@Anay](/AnayNandode),\\n\\nYou\\'re almost there, but I see a few issues. Quick note: expand acronyms so that noobs understand what you are referring to. E.g. *tle -> time limit exceeded*\\nThere is a minor error in your syntax. When defining a vector in C++, you have to specify the data type of its elements. \\nE.g. ```vector<int> nums```\\nNot sure why you\\'re using bit manipulation, but eventually it starts returning incorrect results. You may want to consider keeping it simple and, honestly, it is rarely used for something like this. You probably wouldn\\'t want this in a codebase. Keep it simple.\\nAfter these corrections, you should be good to go."
                    },
                    {
                        "username": "silenthouse33011",
                        "content": "=================================================================\\n==34==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000001b94 at pc 0x0000003458fe bp 0x7fffcdc1d990 sp 0x7fffcdc1d988\\nREAD of size 4 at 0x602000001b94 thread T0\\n    #2 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x602000001b94 is located 0 bytes to the right of 4-byte region [0x602000001b90,0x602000001b94)\\nallocated by thread T0 here:\\n    #6 0x7f4e05b3b0b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c047fff8320: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fa\\n  0x0c047fff8330: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fd\\n  0x0c047fff8340: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8350: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\\n  0x0c047fff8360: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa\\n=>0x0c047fff8370: fa fa[04]fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8380: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff8390: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c047fff83c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==34==ABORTING\\n\\nCode : \\n\\nclass Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int left = 0; int right = nums.size();\\n        int mid;\\n\\n        while(left <= right) {\\n            int mid = (left + right) / 2;\\n\\n            if(target == nums[mid]) {\\n                return mid;\\n            }\\n            if(nums[mid] > target) {\\n                right = mid - 1;\\n            }\\n            else {\\n                left = mid + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n};\\n\\nWtf leetcode??"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "You set *right* to the size of the vector, which is not a valid index as vectors begin with index 0 and end at size - 1. Attempting to access an index that doesn\\'t exist will throw an error as you are trying to access memory outside of what\\'s been allocated. Also, not sure why your vector argument does not define the data type of its elements...is this a new C++ feature or something? I see this in others\\' C++ solutions that have failed as well."
                    },
                    {
                        "username": "TYork",
                        "content": "It sounds that  this one has been shot to the outer space, by the look of it"
                    },
                    {
                        "username": "Yash_Infinity",
                        "content": "can you tell me what\\'s the problem with this problem, i know this aint binary search or has time complexity of O(logn), but this gives error in general terms as well\\n\\n\\n\\n\\n\\n    int search(vector<int>& nums, int target) {\\n        int flag = -1 ;\\n        for(int i = 0; i < nums.size() ; i++)\\n        {\\n            if(nums[i] == target){\\n            flag = i - 1  ;\\n            break;}\\n        \\n\\n        }\\n        return flag;\\n        \\n    }"
                    },
                    {
                        "username": "hashimjacobs",
                        "content": "What's the error message?\n\nI couldn't reproduce any errors from your solution, but I can tell you what might change your results.\n\nWhat is the purpose of the flag variable? Is there another existing variable that can be used in place of it to return the index of the target?\n\nWhy are you setting the value of flag to the previous index? Your for loop starts at 0 and ends at 8 if the size() of nums is 9, for example.\n\nOnce you find the target, you can return the index from the function. If the function makes it past the loop, then whatever value representing no solution found can be returned."
                    },
                    {
                        "username": "abhiroopvadnam1289",
                        "content": "can you check my code  and tell me where i was wrong"
                    },
                    {
                        "username": "allubhurji",
                        "content": "# What edge cases am I not considering:\\n\\nif I don\\'t update using  ` r= mid -1 ` and ` l = mid+1 ` and instead use  `r = mid ` and  `l= mid` in the following code:\\n\\n```\\nclass Solution:\\n    def search(self, nums: List[int], target: int) -> int:\\n        l = 0\\n        r = len(nums) -1 \\n        while l<r:\\n            mid =(l+r)//2\\n            if nums[mid] == target:\\n                return mid\\n            elif nums[mid] > target:\\n                r = mid - 1\\n            else:\\n                l = mid + 1\\n        if nums[l] == target: return l\\n        \\n        return -1\\n```\\n"
                    },
                    {
                        "username": "Amir_tkbr",
                        "content": "I think that you can just spend more attempts trying to get target number. Try this code with r = mid n l  = mid:\n```\ndef search(nums: list[int], target: int):\n    attempts = 0\n    l = 0\n    r = len(nums) - 1\n    while l < r:\n        attempts += 1\n        mid = (l + r) // 2\n        if nums[mid] == target:\n            return mid, attempts\n        elif nums[mid] > target:\n            r = mid - 1\n        else:\n            l = mid + 1\n    if nums[l] == target:\n        return l, attempts\n\n    return -1, attempts\n\n\nls = [i for i in range(10000)]\n\nprint(search(ls, 83))\n```"
                    },
                    {
                        "username": "ParthSharma007",
                        "content": "class Solution {\\npublic:\\n    int search(vector<int>& nums, int target) {\\n        int start=0;\\n        int end = nums.size()-1;\\n        \\n        while (start <= end){\\n            int mid = start + (end-start)/2;\\n            if (nums[mid]==target){\\n                return mid;\\n            }\\n            else if (target > nums[mid]){\\n                start = mid + 1;\\n            }\\n            else {\\n                end = mid - 1;\\n            }\\n            \\n        }\\n        return -1;\\n    }        \\n};"
                    }
                ]
            }
        ]
    }
]