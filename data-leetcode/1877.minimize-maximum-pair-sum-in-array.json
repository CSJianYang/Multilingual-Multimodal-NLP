[
    {
        "title": "Substrings of Size Three with Distinct Characters",
        "question_content": "A string is good if there are no repeated characters.\nGiven a string s​​​​​, return the number of good substrings of length three in s​​​​​​.\nNote that if there are multiple occurrences of the same substring, every occurrence should be counted.\nA substring is a contiguous sequence of characters in a string.\n&nbsp;\nExample 1:\n\nInput: s = \"xyzzaz\"\nOutput: 1\nExplanation: There are 4 substrings of size 3: \"xyz\", \"yzz\", \"zza\", and \"zaz\". \nThe only good substring of length 3 is \"xyz\".\n\nExample 2:\n\nInput: s = \"aababcabc\"\nOutput: 4\nExplanation: There are 7 substrings of size 3: \"aab\", \"aba\", \"bab\", \"abc\", \"bca\", \"cab\", and \"abc\".\nThe good substrings are \"abc\", \"bca\", \"cab\", and \"abc\".\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 100\n\ts​​​​​​ consists of lowercase English letters.",
        "solutions": [
            {
                "id": 1238665,
                "title": "easy-solution-o-n-approach",
                "content": "Here we are using sliding window technique with a window size of 3\\nWith every iteration new element is pushed into the window and the last element of window is pushed out.\\nWith in every window we check if there is any repetition of elements using if loop\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3)return 0;\\n        char a=s[0],b=s[1],c=s[2];\\n        int res=0;\\n        for(int i=3;i<=s.size()-1;i++)\\n        {\\n            if(a!=b and b!=c and c!=a)res++;\\n            a=b;\\n            b=c;\\n            c=s[i];\\n        }\\n        if(a!=b and b!=c and c!=a)res++;\\n        return res;\\n    }\\n};\\n```\\n**Do upvote and keep supporting..!**",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3)return 0;\\n        char a=s[0],b=s[1],c=s[2];\\n        int res=0;\\n        for(int i=3;i<=s.size()-1;i++)\\n        {\\n            if(a!=b and b!=c and c!=a)res++;\\n            a=b;\\n            b=c;\\n            c=s[i];\\n        }\\n        if(a!=b and b!=c and c!=a)res++;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1399854,
                "title": "c-never-under-estimate-an-easy-qn-it-can-teach-you-many-things",
                "content": "```\\n//Approach-1 (That comes to your mind in one go)\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count = 0;\\n        if(s.length() < 3) return 0;\\n        for(int i = 0; i<=s.length()-3; i++) {\\n            if(s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2])\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using siding window - It can be used to solve the generalized version of the question ( k sized substring))\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count = 0;\\n        int dup   = 0;\\n        if(s.length() < 3) return 0;\\n        int mp[26] = {0};\\n        \\n        for(int i = 0; i<s.length(); i++) {\\n            mp[s[i]-\\'a\\']++;\\n            \\n            if(mp[s[i]-\\'a\\'] == 2)\\n                dup++;\\n            \\n            if(i < 2) continue;\\n            \\n            if(dup == 0) count++;\\n            \\n            //now shift right (so, (i-2)th character\\'s frequency in current window is decreased)\\n            mp[s[i-2]-\\'a\\']--;\\n            \\n            if(mp[s[i-2]-\\'a\\'] == 1) //it means it had increased dup (dup++)\\n                dup--;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (That comes to your mind in one go)\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count = 0;\\n        if(s.length() < 3) return 0;\\n        for(int i = 0; i<=s.length()-3; i++) {\\n            if(s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2])\\n                count++;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\n//Approach-2 (Using siding window - It can be used to solve the generalized version of the question ( k sized substring))\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count = 0;\\n        int dup   = 0;\\n        if(s.length() < 3) return 0;\\n        int mp[26] = {0};\\n        \\n        for(int i = 0; i<s.length(); i++) {\\n            mp[s[i]-\\'a\\']++;\\n            \\n            if(mp[s[i]-\\'a\\'] == 2)\\n                dup++;\\n            \\n            if(i < 2) continue;\\n            \\n            if(dup == 0) count++;\\n            \\n            //now shift right (so, (i-2)th character\\'s frequency in current window is decreased)\\n            mp[s[i-2]-\\'a\\']--;\\n            \\n            if(mp[s[i-2]-\\'a\\'] == 1) //it means it had increased dup (dup++)\\n                dup--;\\n        }\\n        \\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485329,
                "title": "classic-sliding-window-beats-100-beginner-friendly-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\t/* \\n\\t * This is classic sliding window problem with fixed window length 3 here \\n\\t * we will always maintain the window len 3(fixed length)  by adjusting i and j \\n\\t * in all similar problems\\n\\t */\\n        /* i is LHS of the window */\\n        int i = 0;\\n       /* j is RHS of window */\\n        int j = 0;\\n        int n = s.size();\\n\\t\\t\\n\\t\\t/* Map to keep track of occurance of each char */\\n        unordered_map<char, int>mp;\\n\\t\\t\\n\\t\\t/* Variable keeping track of answer/result */\\n        int ans = 0;\\n        \\n        while (i < n && j < n) {\\n            /* Increment the count in map each time you iterate through any character */\\n            mp[s[j]]++;\\n            \\n           \\n            if (j - i + 1 < 3) {\\n            /* Case 1:\\n             *  Keep incrementing the RHS till you  make substring of exactly length 3(fixed length). \\n             */\\n                j++;\\n            } else if (mp.size() == 3) {\\n              /* Case 2: \\n\\t\\t\\t   * If the map size is exact 3 we have found the sub string with 3 unique \\n               * chars(here window len 3 we are mainting always) ,\\n\\t\\t\\t   * increment the answer, Also shift the LHS and RHS of the current window for which result is calulated\\n\\t\\t\\t   * and remove the entry from map for the LHS(Note the RHS will still be part of new shifted window).\\n\\t\\t\\t   */\\n                ans++;\\n                mp.erase(s[i]);\\n                i++;\\n                j++;\\n            } else {\\n               /*\\n\\t\\t\\t    * Case 3: \\n\\t\\t\\t    * If map size is not equal to 3 (sliding window len here will always be 3)then we surely have some\\n\\t\\t\\t    * repeating chars so we need to slide the window again.\\n\\t\\t\\t    * For LHS Decrement the count from map and if its zero then erase it as we are using \\n\\t\\t\\t    * size of map to calucate number of unique elements present(Note the RHS will  still be part of new shifted window) \\n\\t\\t\\t    */\\n                mp[s[i]]--;\\n                if (mp[s[i]] == 0) {\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n                \\n            }\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\nIts my first post, please upvote if you find this helpful :)",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\t/* \\n\\t * This is classic sliding window problem with fixed window length 3 here \\n\\t * we will always maintain the window len 3(fixed length)  by adjusting i and j \\n\\t * in all similar problems\\n\\t */\\n        /* i is LHS of the window */\\n        int i = 0;\\n       /* j is RHS of window */\\n        int j = 0;\\n        int n = s.size();\\n\\t\\t\\n\\t\\t/* Map to keep track of occurance of each char */\\n        unordered_map<char, int>mp;\\n\\t\\t\\n\\t\\t/* Variable keeping track of answer/result */\\n        int ans = 0;\\n        \\n        while (i < n && j < n) {\\n            /* Increment the count in map each time you iterate through any character */\\n            mp[s[j]]++;\\n            \\n           \\n            if (j - i + 1 < 3) {\\n            /* Case 1:\\n             *  Keep incrementing the RHS till you  make substring of exactly length 3(fixed length). \\n             */\\n                j++;\\n            } else if (mp.size() == 3) {\\n              /* Case 2: \\n\\t\\t\\t   * If the map size is exact 3 we have found the sub string with 3 unique \\n               * chars(here window len 3 we are mainting always) ,\\n\\t\\t\\t   * increment the answer, Also shift the LHS and RHS of the current window for which result is calulated\\n\\t\\t\\t   * and remove the entry from map for the LHS(Note the RHS will still be part of new shifted window).\\n\\t\\t\\t   */\\n                ans++;\\n                mp.erase(s[i]);\\n                i++;\\n                j++;\\n            } else {\\n               /*\\n\\t\\t\\t    * Case 3: \\n\\t\\t\\t    * If map size is not equal to 3 (sliding window len here will always be 3)then we surely have some\\n\\t\\t\\t    * repeating chars so we need to slide the window again.\\n\\t\\t\\t    * For LHS Decrement the count from map and if its zero then erase it as we are using \\n\\t\\t\\t    * size of map to calucate number of unique elements present(Note the RHS will  still be part of new shifted window) \\n\\t\\t\\t    */\\n                mp[s[i]]--;\\n                if (mp[s[i]] == 0) {\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n                \\n            }\\n        }\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238721,
                "title": "java-5-liner-o-n",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n\\tint result = 0;\\n\\tfor(int i=1;i<s.length()-1;i++)\\n\\t\\tif(s.charAt(i-1) != s.charAt(i) && s.charAt(i+1) != s.charAt(i) && s.charAt(i+1) != s.charAt(i-1))\\n\\t\\t\\tresult++;\\n\\treturn result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n\\tint result = 0;\\n\\tfor(int i=1;i<s.length()-1;i++)\\n\\t\\tif(s.charAt(i-1) != s.charAt(i) && s.charAt(i+1) != s.charAt(i) && s.charAt(i+1) != s.charAt(i-1))\\n\\t\\t\\tresult++;\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240095,
                "title": "python-3-simple-and-linear-time",
                "content": "Iterative over string and increase the counter if all characters of length 3 string are different.\\n\\n```\\n def countGoodSubstrings(self, s: str) -> int:\\n        ans=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3:\\n                ans+=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n def countGoodSubstrings(self, s: str) -> int:\\n        ans=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3:\\n                ans+=1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1238687,
                "title": "java-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        for(int i = 0; i < n - 2; i++) {\\n            char c1 = s.charAt(i);\\n            char c2 = s.charAt(i + 1);\\n            char c3 = s.charAt(i + 2);\\n            if(c1 == c2 || c2 == c3 || c1 == c3) continue;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        int n = s.length();\\n        int ans = 0;\\n        for(int i = 0; i < n - 2; i++) {\\n            char c1 = s.charAt(i);\\n            char c2 = s.charAt(i + 1);\\n            char c3 = s.charAt(i + 2);\\n            if(c1 == c2 || c2 == c3 || c1 == c3) continue;\\n            ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1238676,
                "title": "sliding-window",
                "content": "A standard approach to count repeated characters in a sliding window.\\n\\n**C++**\\n```cpp\\nint countGoodSubstrings(string s) {\\n    int cnt[123] = {}, repeat = 0, res = 0;\\n    for(int i = 0; i < s.size(); ++i) {\\n        repeat += cnt[s[i]]++ == 1;\\n        repeat -= i >= 3 && cnt[s[i - 3]]-- == 2;\\n        res += i >= 2 && repeat == 0;\\n    }\\n    return res;\\n}\\n```\\n**Java**\\n```java\\npublic int countGoodSubstrings(String s) {\\n    int cnt[] = new int[123], repeat = 0, res = 0;\\n    for(int i = 0; i < s.length(); ++i) {\\n        repeat += cnt[s.charAt(i)]++ == 1 ? 1 : 0;\\n        repeat -= i >= 3 && cnt[s.charAt(i - 3)]-- == 2 ? 1 : 0;\\n        res += i >= 2 && repeat == 0 ? 1 : 0;\\n    }    \\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint countGoodSubstrings(string s) {\\n    int cnt[123] = {}, repeat = 0, res = 0;\\n    for(int i = 0; i < s.size(); ++i) {\\n        repeat += cnt[s[i]]++ == 1;\\n        repeat -= i >= 3 && cnt[s[i - 3]]-- == 2;\\n        res += i >= 2 && repeat == 0;\\n    }\\n    return res;\\n}\\n```\n```java\\npublic int countGoodSubstrings(String s) {\\n    int cnt[] = new int[123], repeat = 0, res = 0;\\n    for(int i = 0; i < s.length(); ++i) {\\n        repeat += cnt[s.charAt(i)]++ == 1 ? 1 : 0;\\n        repeat -= i >= 3 && cnt[s.charAt(i - 3)]-- == 2 ? 1 : 0;\\n        res += i >= 2 && repeat == 0 ? 1 : 0;\\n    }    \\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1429825,
                "title": "java-simple-o-n-100",
                "content": "if you like it pls upvote\\n\\nJava\\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int res = 0;\\n        \\n        for(int i = 2 ; i< s.length();i++)\\n            if(s.charAt(i) != s.charAt(i-1) && s.charAt(i) != s.charAt(i-2)  && s.charAt(i-1) != s.charAt(i-2))\\n                res++;\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int res = 0;\\n        \\n        for(int i = 2 ; i< s.length();i++)\\n            if(s.charAt(i) != s.charAt(i-1) && s.charAt(i) != s.charAt(i-2)  && s.charAt(i-1) != s.charAt(i-2))\\n                res++;\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904752,
                "title": "sliding-window-simplest-approach-c",
                "content": "**AN UPVOTE WOUULD BE HIGHLY APPERICIATED**\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0;int j=0;\\n        map<char,int> ans;\\n        int a=0;\\n        while(j<s.size()){\\n            ans[s[j]]++;\\n            if(j-i+1<3) {j++;}\\n            else if(j-i+1==3){\\n                if(ans.size()==3) a++;\\n                if(ans[s[i]]==1) ans.erase(s[i]);\\n                else ans[s[i]]--;\\n                i++;j++;}\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0;int j=0;\\n        map<char,int> ans;\\n        int a=0;\\n        while(j<s.size()){\\n            ans[s[j]]++;\\n            if(j-i+1<3) {j++;}\\n            else if(j-i+1==3){\\n                if(ans.size()==3) a++;\\n                if(ans[s[i]]==1) ans.erase(s[i]);\\n                else ans[s[i]]--;\\n                i++;j++;}\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356591,
                "title": "easy-python-solution-98-80",
                "content": "Runtime: 24 ms, faster than 98.80% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\nMemory Usage: 14.3 MB, less than 42.54% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if(s[i]!=s[i+1] and s[i]!=s[i+2] and s[i+1]!=s[i+2]):\\n                count+=1\\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 24 ms, faster than 98.80% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\nMemory Usage: 14.3 MB, less than 42.54% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if(s[i]!=s[i+1] and s[i]!=s[i+2] and s[i+1]!=s[i+2]):\\n                count+=1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1238685,
                "title": "c-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int cnt=0,n=s.size();\\n        unordered_map<char,int> map;\\n        for(int i=0;i<n;i++){\\n            if(i>2 and --map[s[i-3]] == 0) map.erase(s[i-3]);\\n            map[s[i]]++;\\n            if(map.size() == 3) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int cnt=0,n=s.size();\\n        unordered_map<char,int> map;\\n        for(int i=0;i<n;i++){\\n            if(i>2 and --map[s[i-3]] == 0) map.erase(s[i-3]);\\n            map[s[i]]++;\\n            if(map.size() == 3) cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1455895,
                "title": "easy-and-well-explained-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    //we can solve this problem by using sliding window technique\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0; //k is the size of window\\n        int count=0,n = s.length();\\n        map<char,int>mp; //we create map to store the frequency of each character \\n        while(j<n){\\n            mp[s[j]]++; //push the element into map\\n            if(j-i+1 < k){ //since we want length of substring three so till that point we will just add character\\n                j++;\\n            }else{\\n                if(mp.size() == 3){ //we check that all three entries are unique or not..\\n                    count++;\\n                }\\n                mp[s[i]]--; //this is the step where we slide our window\\n                if(mp[s[i]] == 0){ //if at any step our frquency of that character becomes zero then we have to remove it from our map\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++; //to slide our window we move our both pointers\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //we can solve this problem by using sliding window technique\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0; //k is the size of window\\n        int count=0,n = s.length();\\n        map<char,int>mp; //we create map to store the frequency of each character \\n        while(j<n){\\n            mp[s[j]]++; //push the element into map\\n            if(j-i+1 < k){ //since we want length of substring three so till that point we will just add character\\n                j++;\\n            }else{\\n                if(mp.size() == 3){ //we check that all three entries are unique or not..\\n                    count++;\\n                }\\n                mp[s[i]]--; //this is the step where we slide our window\\n                if(mp[s[i]] == 0){ //if at any step our frquency of that character becomes zero then we have to remove it from our map\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++; //to slide our window we move our both pointers\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155417,
                "title": "java-beats-90-sliding-window-with-detailed-explanation",
                "content": "![image.png](https://assets.leetcode.com/users/images/b6852eab-4964-47ac-9e70-d7996cd86176_1675767633.4297187.png)\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis problem is being approached by Sliding Windows Algorithm. We take two pointers for determining the window and then checking our condition of uniqueness.\\n\\n![WhatsApp Image 2023-02-07 at 4.28.52 PM.jpeg](https://assets.leetcode.com/users/images/ed778d99-d6d2-4a5b-9c35-00443b1aebbb_1675767797.020403.jpeg)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0, j=0, count=0;\\n        while(j<s.length()){\\n            if(j-i+1==3){\\n                if(s.charAt(i) != s.charAt(i+1) && s.charAt(i+1) != s.charAt(i+2) \\n                && s.charAt(i+2) != s.charAt(i)){\\n                    count++;\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n# Do give this solution an Upvote if you find it helpful:)\\n![emojipng.com-12080000.png](https://assets.leetcode.com/users/images/8ecfc048-081b-4b5d-8acb-277a9d817b57_1675768050.9240546.png)\\n\\n\\n",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0, j=0, count=0;\\n        while(j<s.length()){\\n            if(j-i+1==3){\\n                if(s.charAt(i) != s.charAt(i+1) && s.charAt(i+1) != s.charAt(i+2) \\n                && s.charAt(i+2) != s.charAt(i)){\\n                    count++;\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458854,
                "title": "easy-to-understand-javascript-solution",
                "content": "\\tvar countGoodSubstrings = function(s) {\\n\\t\\tlet good = 0;\\n\\n\\t\\tfor (let index = 0; index < s.length - 2; index++) {\\n\\t\\t\\tconst subStr = s.slice(index, index + 3);\\n\\t\\t\\tconst set = new Set(subStr);\\n\\n\\t\\t\\tset.size === 3 && (good += 1);\\n\\t\\t}\\n\\t\\treturn good;\\n\\t};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "\\tvar countGoodSubstrings = function(s) {\\n\\t\\tlet good = 0;\\n\\n\\t\\tfor (let index = 0; index < s.length - 2; index++) {\\n\\t\\t\\tconst subStr = s.slice(index, index + 3);\\n\\t\\t\\tconst set = new Set(subStr);\\n\\n\\t\\t\\tset.size === 3 && (good += 1);\\n\\t\\t}\\n\\t\\treturn good;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 3971421,
                "title": "java-10000-beats-0-n-2-solution-hashset-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:0(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n           if(s.length()<=2) return 0;\\n           int ans = 0;   //  Please UPVOTE ME....\\n           for(int i=0; i<s.length()-2; i++){\\n               if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2)) ans++;\\n           }\\n           return ans;\\n\\n\\n//                   Another solution (Using HashSet<>) --> try this one\\n\\n        // char temp[] = s.toCharArray();\\n        // int count = 0 , low = 0 , ans = 0 , i = 0;\\n        // Set<Character> set = new HashSet<>();\\n        // if(temp.length<=2) return 0;\\n        // while(low!=temp.length-2){\\n        //        set.add(temp[i]); i++; count++;\\n        //        if(count==3){\\n        //            if(set.size()==3){\\n        //                ans++; count = 0;\\n        //            }else  count = 0;\\n        //            low++; set.clear(); i = low;\\n        //        }\\n        // }\\n        // return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n           if(s.length()<=2) return 0;\\n           int ans = 0;   //  Please UPVOTE ME....\\n           for(int i=0; i<s.length()-2; i++){\\n               if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2)) ans++;\\n           }\\n           return ans;\\n\\n\\n//                   Another solution (Using HashSet<>) --> try this one\\n\\n        // char temp[] = s.toCharArray();\\n        // int count = 0 , low = 0 , ans = 0 , i = 0;\\n        // Set<Character> set = new HashSet<>();\\n        // if(temp.length<=2) return 0;\\n        // while(low!=temp.length-2){\\n        //        set.add(temp[i]); i++; count++;\\n        //        if(count==3){\\n        //            if(set.size()==3){\\n        //                ans++; count = 0;\\n        //            }else  count = 0;\\n        //            low++; set.clear(); i = low;\\n        //        }\\n        // }\\n        // return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238647,
                "title": "clean-python-3-straightforward",
                "content": "Time: `O(N)`\\nSpace: `O(1)`\\n\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        if len(s) < 3: return 0 # it still can work if we remove this line (credit to @Silvia42)\\n        return sum(s[i] != s[i-1] != s[i-2] != s[i] for i in range(2, len(s)))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        if len(s) < 3: return 0 # it still can work if we remove this line (credit to @Silvia42)\\n        return sum(s[i] != s[i-1] != s[i-2] != s[i] for i in range(2, len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1314718,
                "title": "java-easy-solution-sliding-window",
                "content": "//please ask if have any doubt\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0,j=0,count=0;\\n        HashMap<Character,Integer>map=new HashMap<>();\\n        while(j<s.length())\\n        {\\n            map.put(s.charAt(j),map.getOrDefault(s.charAt(j),0)+1);\\n            if(j-i+1<3)\\n            {\\n                j++;\\n            }else if(j-i+1==3)\\n            {\\n                if(map.size()==3)\\n                {\\n                    count++;\\n                    //System.out.println(map);\\n                }\\n                int val=map.get(s.charAt(i));\\n                val=val-1;\\n                if(val==0){\\n                    map.remove(s.charAt(i));\\n                }else{\\n                    map.put(s.charAt(i),val);\\n                }\\n                \\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0,j=0,count=0;\\n        HashMap<Character,Integer>map=new HashMap<>();\\n        while(j<s.length())\\n        {\\n            map.put(s.charAt(j),map.getOrDefault(s.charAt(j),0)+1);\\n            if(j-i+1<3)\\n            {\\n                j++;\\n            }else if(j-i+1==3)\\n            {\\n                if(map.size()==3)\\n                {\\n                    count++;\\n                    //System.out.println(map);\\n                }\\n                int val=map.get(s.charAt(i));\\n                val=val-1;\\n                if(val==0){\\n                    map.remove(s.charAt(i));\\n                }else{\\n                    map.put(s.charAt(i),val);\\n                }\\n                \\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3108020,
                "title": "aditya-verma-approach-sliding-window-with-fixed-size-window",
                "content": "# Intuition\\nSliding window with fixed size window.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0;\\n        int i=0,j=0,n=s.length(),k=3;\\n        unordered_map<char,int>mp;\\n        while(j<n){\\n            mp[s[j]]++;\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                if(mp.size()==k){\\n                    ans++;\\n                }\\n                mp[s[i]]--;\\n                if(mp[s[i]]==0){\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0;\\n        int i=0,j=0,n=s.length(),k=3;\\n        unordered_map<char,int>mp;\\n        while(j<n){\\n            mp[s[j]]++;\\n            if(j-i+1<k){\\n                j++;\\n            }\\n            else if(j-i+1==k){\\n                if(mp.size()==k){\\n                    ans++;\\n                }\\n                mp[s[i]]--;\\n                if(mp[s[i]]==0){\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803519,
                "title": "java-hashset-easy",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        Set<Character> set;\\n\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            set = new HashSet<>();\\n\\n            set.add(s.charAt(i));\\n            set.add(s.charAt(i + 1));\\n            set.add(s.charAt(i + 2));\\n\\n            if (set.size() == 3) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        Set<Character> set;\\n\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            set = new HashSet<>();\\n\\n            set.add(s.charAt(i));\\n            set.add(s.charAt(i + 1));\\n            set.add(s.charAt(i + 2));\\n\\n            if (set.size() == 3) count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2441121,
                "title": "easy-c-solution-simple-to-understand",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint countGoodSubstrings(string s) {\\n\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\twhile(j < n){\\n\\n\\t\\t\\t\\tif(j-i+1 == 3){\\n\\n\\t\\t\\t\\t\\tstring temp = s.substr(i, 3);\\n\\n\\t\\t\\t\\t\\tmap<int, int> mp;\\n\\t\\t\\t\\t\\tfor(auto i : temp){\\n\\t\\t\\t\\t\\t\\tmp[i]++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tif(mp.size() == 3){\\n\\t\\t\\t\\t\\t\\tans++;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tj++;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\nI hope that you\\'ve found the solution useful.\\nIn that case, please do upvote. Happy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint countGoodSubstrings(string s) {\\n\\n\\t\\t\\tint i = 0, j = 0;\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tint ans = 0;\\n\\n\\t\\t\\twhile(j < n){\\n\\n\\t\\t\\t\\tif(j-i+1 == 3){\\n\\n\\t\\t\\t\\t\\tstring temp = s.substr(i, 3);\\n\\n\\t\\t\\t\\t\\tmap<int, int> mp;\\n\\t\\t\\t\\t\\tfor(auto i : temp){\\n\\t\\t\\t\\t\\t\\tmp[i]++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3560950,
                "title": "easiest-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n- map is of size 3 at once\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i,j,k,c=0;\\n        unordered_map<char,int>map;\\n\\n        for(i=0;i<3;i++)\\n        map[s[i]]++;\\n\\n        for(i=3;i<s.size();i++){\\n            if(map.size()==3)\\n            c++;\\n\\n            if(map[s[i-3]]>1)\\n            map[s[i-3]]--;\\n            else\\n            map.erase(s[i-3]);\\n            map[s[i]]++;\\n        }\\n\\n        if(map.size()==3)\\n            c++;\\n            \\n        return c;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i,j,k,c=0;\\n        unordered_map<char,int>map;\\n\\n        for(i=0;i<3;i++)\\n        map[s[i]]++;\\n\\n        for(i=3;i<s.size();i++){\\n            if(map.size()==3)\\n            c++;\\n\\n            if(map[s[i-3]]>1)\\n            map[s[i-3]]--;\\n            else\\n            map.erase(s[i-3]);\\n            map[s[i]]++;\\n        }\\n\\n        if(map.size()==3)\\n            c++;\\n            \\n        return c;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496933,
                "title": "c-c-javascript-very-easy-solution",
                "content": "# We have to obtain every three character and check whether one of them is the same with other one.If it is not,then we increase total number to 1;\\n\\n```javascript []\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countGoodSubstrings = function(s) {\\n    let res=0;\\n         for(let i=1;i<s.length-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;\\n};\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int res=0;\\n         for(int i=1;i<s.size()-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;\\n    }\\n};\\n```\\n```C# []\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n      int res=0;\\n         for(int i=1;i<s.Length-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;  \\n    }\\n}\\n```\\n\\n![Vote.png](https://assets.leetcode.com/users/images/cfa28b29-b04a-43fc-8262-144616116687_1683465999.863679.png)\\n\\n",
                "solutionTags": [
                    "C++",
                    "C#",
                    "JavaScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countGoodSubstrings = function(s) {\\n    let res=0;\\n         for(let i=1;i<s.length-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;\\n};\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int res=0;\\n         for(int i=1;i<s.size()-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;\\n    }\\n};\\n```\n```C# []\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n      int res=0;\\n         for(int i=1;i<s.Length-1;i++)\\n            if(s[i]!=s[i-1] && s[i]!=s[i+1] && s[i-1]!=s[i+1])\\n            res++;   \\n        return res;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2652821,
                "title": "sliding-window-set-o-n-time-o-1-space",
                "content": "<iframe src=\"https://leetcode.com/playground/hq4zYSic/shared\" frameBorder=\"0\" width=\"100%\" height=\"475\"></iframe>",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/hq4zYSic/shared\" frameBorder=\"0\" width=\"100%\" height=\"475\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 1815788,
                "title": "python-2-lines-solution",
                "content": "**Python:**\\n\\n```\\ndef countGoodSubstrings(self, s: str) -> int:\\n\\tsubstr = [s[x:y] for x, y in itertools.combinations(range(len(s) + 1), r = 2) if len(s[x:y]) == 3 ]\\n\\treturn len([s for s in substr if len(set(s)) == len(s)])\\n```\\n\\n**Like it ? please upvote !**\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef countGoodSubstrings(self, s: str) -> int:\\n\\tsubstr = [s[x:y] for x, y in itertools.combinations(range(len(s) + 1), r = 2) if len(s[x:y]) == 3 ]\\n\\treturn len([s for s in substr if len(set(s)) == len(s)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1581918,
                "title": "python-sliding-window-solution",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        k = 3\\n        if k > len(s):\\n            return 0\\n        \\n        letter_frequency = {}\\n        count, windowStart = 0, 0\\n        for windowEnd in range(len(s)):\\n            if s[windowEnd] not in letter_frequency:\\n                letter_frequency[s[windowEnd]] = 0\\n            letter_frequency[s[windowEnd]] += 1\\n            \\n            if windowEnd >= k - 1:\\n                if len(letter_frequency) == k:\\n                    count+=1\\n                letter_frequency[s[windowStart]] -= 1\\n                if letter_frequency[s[windowStart]] ==0:\\n                    del letter_frequency[s[windowStart]]\\n                windowStart += 1\\n        return count\\n                \\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        k = 3\\n        if k > len(s):\\n            return 0\\n        \\n        letter_frequency = {}\\n        count, windowStart = 0, 0\\n        for windowEnd in range(len(s)):\\n            if s[windowEnd] not in letter_frequency:\\n                letter_frequency[s[windowEnd]] = 0\\n            letter_frequency[s[windowEnd]] += 1\\n            \\n            if windowEnd >= k - 1:\\n                if len(letter_frequency) == k:\\n                    count+=1\\n                letter_frequency[s[windowStart]] -= 1\\n                if letter_frequency[s[windowStart]] ==0:\\n                    del letter_frequency[s[windowStart]]\\n                windowStart += 1\\n        return count\\n                \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434368,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0,j=0,count=0;\\n        while(j<s.size()){\\n            if(j-i+1 < 3)\\n                j++;\\n            else if(j-i+1 == 3){\\n               if((s[i]!=s[i+1] && s[i]!=s[i+2]) && (s[i+1]!=s[i] && s[i+1]!=s[i+2]) && (s[i+2]!=s[i+1] && s[i+2]!=s[i])) \\n                   count++;\\n                i++;j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0,j=0,count=0;\\n        while(j<s.size()){\\n            if(j-i+1 < 3)\\n                j++;\\n            else if(j-i+1 == 3){\\n               if((s[i]!=s[i+1] && s[i]!=s[i+2]) && (s[i+1]!=s[i] && s[i+1]!=s[i+2]) && (s[i+2]!=s[i+1] && s[i+2]!=s[i])) \\n                   count++;\\n                i++;j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697724,
                "title": "beats-100-can-be-extended-to-any-number-of-characters",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncalculate the no of unique characters for first k characters. traverse through the string , if removed character has freq 0 reduce unique by 1, if added character has freq 1 increment unique by 1. if unique is k increment count. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nPlease upvote if you find it helpful \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.length() <3) return 0; \\n        int count = 0; int k = 3; int u = 0; vector<int> t(26, 0); \\n        for(int i=0; i<k; i++) {t[s[i] - \\'a\\']++; if(t[s[i] - \\'a\\'] == 1) u++; }\\n        if(u == k) count++; \\n        for(int i=k; i<s.length(); i++){\\n            t[s[i-k] - \\'a\\']--;  if(t[s[i-k] - \\'a\\'] == 0) u--;   t[s[i] - \\'a\\']++; if(t[s[i] - \\'a\\'] == 1) u++; \\n            if(u == k) count++; \\n        }\\n\\n            return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.length() <3) return 0; \\n        int count = 0; int k = 3; int u = 0; vector<int> t(26, 0); \\n        for(int i=0; i<k; i++) {t[s[i] - \\'a\\']++; if(t[s[i] - \\'a\\'] == 1) u++; }\\n        if(u == k) count++; \\n        for(int i=k; i<s.length(); i++){\\n            t[s[i-k] - \\'a\\']--;  if(t[s[i-k] - \\'a\\'] == 0) u--;   t[s[i] - \\'a\\']++; if(t[s[i] - \\'a\\'] == 1) u++; \\n            if(u == k) count++; \\n        }\\n\\n            return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526377,
                "title": "java-beats-100-oms-easiest-3-liner",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int n = s.length();\\n        if(n<3) return 0;\\n        int c=0;\\n        System.out.print(s.charAt(0));\\n        for(int i =0;i<n-2;i++){\\n            if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2)){\\n                c++;\\n            }  \\n        }\\n        return c;\\n    }\\n} \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int n = s.length();\\n        if(n<3) return 0;\\n        int c=0;\\n        System.out.print(s.charAt(0));\\n        for(int i =0;i<n-2;i++){\\n            if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2)){\\n                c++;\\n            }  \\n        }\\n        return c;\\n    }\\n} \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3142344,
                "title": "python-4-lines-1-liner-beginners-friendly-solution",
                "content": "class Solution:\\n\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3: # taking a window of 3\\n                count+=1\\n        return count\\n# Python One-Liner\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\t\\n        return sum(len(set(s[i:i+3]))==3 for i in range(len(s)-2))\\n                \\n\\t\\t\\n\\t\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "class Solution:\\n\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3: # taking a window of 3\\n                count+=1\\n        return count\\n# Python One-Liner\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\t\\n        return sum(len(set(s[i:i+3]))==3 for i in range(len(s)-2))\\n                \\n\\t\\t\\n\\t\\n\\t\\t\\n\\t\\t",
                "codeTag": "Java"
            },
            {
                "id": 1813742,
                "title": "java-easy-solution-sliding-window",
                "content": "First we will find the Window. So till size we do J++.\\nAfter that we will slide it so i++ and j++. \\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int l=s.length();\\n        int i=0,j=0,k=3,count=0;\\n        while(j<l)\\n        {\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                if(s.charAt(i)!=s.charAt(j) && s.charAt(j)!=s.charAt(i+1) && s.charAt(i)!=s.charAt(i+1))             \\n                    count++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int l=s.length();\\n        int i=0,j=0,k=3,count=0;\\n        while(j<l)\\n        {\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                if(s.charAt(i)!=s.charAt(j) && s.charAt(j)!=s.charAt(i+1) && s.charAt(i)!=s.charAt(i+1))             \\n                    count++;\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1643675,
                "title": "succinct-python-solution-o-n",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        def match(t):\\n            return len(set(t)) == 3\\n        \\n        return sum(map(match, zip(s, s[1:], s[2:])))\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        def match(t):\\n            return len(set(t)) == 3\\n        \\n        return sum(map(match, zip(s, s[1:], s[2:])))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1436379,
                "title": "java-solution-easy-to-understand",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n        Set<Character> set = new HashSet();\\n        int count = 0;\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            String subStr = s.substring(i, i + 3);\\n            for (char ch : subStr.toCharArray()) {\\n                set.add(ch);\\n            }            \\n            if (set.size() == 3) {\\n                count++;\\n            }\\n            set.clear();\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n        Set<Character> set = new HashSet();\\n        int count = 0;\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            String subStr = s.substring(i, i + 3);\\n            for (char ch : subStr.toCharArray()) {\\n                set.add(ch);\\n            }            \\n            if (set.size() == 3) {\\n                count++;\\n            }\\n            set.clear();\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238883,
                "title": "1876-set-sliding-window",
                "content": "---\\n\\nCool, felt good use of programming language construct `Set()`\\nNOTE: This is an easy problem, so I create many `Set()`s knowingly. We could always compare 3 vals directly.\\n\\nAlgo\\n\\n- If <3 chars, we can\\'t make a good string, return 0\\n- Take 1st 3 chars, add them into `Set()`, duplicates will be deleted\\n  - After that if size is 3 then there are 3 distinct chars in this substring, increment count\\n- Delete front char, add next char - repeat above until we reach end of string\\n- Return the count\\n\\nHope it is simple to understand\\n\\n---\\n\\n    var countGoodSubstrings = function (s) {\\n        let n = s.length;\\n        if (n < 3) return 0;          // minimum 3 chars needed for good substring\\n\\n        let count = 0;\\n\\n        let A = [s[0], s[1]];\\n        for (let i = 2; i < n; i++) {\\n            A.push(s[i]);                            // add 1 char to the back\\n            if (new Set(A).size === 3) {\\n                count++;                             // if distinct, set size will be 3, if so increment counter\\n            }\\n            A.shift();                               // remove 1 char from the front\\n        }\\n\\n        return count;\\n    };\\n\\n---\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "---\\n\\nCool, felt good use of programming language construct `Set()`\\nNOTE: This is an easy problem, so I create many `Set()`s knowingly. We could always compare 3 vals directly.\\n\\nAlgo\\n\\n- If <3 chars, we can\\'t make a good string, return 0\\n- Take 1st 3 chars, add them into `Set()`, duplicates will be deleted\\n  - After that if size is 3 then there are 3 distinct chars in this substring, increment count\\n- Delete front char, add next char - repeat above until we reach end of string\\n- Return the count\\n\\nHope it is simple to understand\\n\\n---\\n\\n    var countGoodSubstrings = function (s) {\\n        let n = s.length;\\n        if (n < 3) return 0;          // minimum 3 chars needed for good substring\\n\\n        let count = 0;\\n\\n        let A = [s[0], s[1]];\\n        for (let i = 2; i < n; i++) {\\n            A.push(s[i]);                            // add 1 char to the back\\n            if (new Set(A).size === 3) {\\n                count++;                             // if distinct, set size will be 3, if so increment counter\\n            }\\n            A.shift();                               // remove 1 char from the front\\n        }\\n\\n        return count;\\n    };\\n\\n---\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1238814,
                "title": "c-concise-and-straightforward-solution-beats-100-with-python-1-liner",
                "content": "C++ solution\\n```\\nint countGoodSubstrings(string s) \\n{\\n\\tint result=0,n=s.length();\\n\\tfor(int i=0;i<n-2;i++)\\n\\t\\tif(s[i]!=s[i+1]&&s[i]!=s[i+2]&&s[i+1]!=s[i+2]) result++;\\n\\n\\treturn result;\\n}\\n```\\nPython 1 liner:\\n```\\ndef countGoodSubstrings(self, s):\\n\\treturn sum([s[i]!=s[i+1]!=s[i+2]!=s[i] for i in range(len(s)-2)])\\n```",
                "solutionTags": [],
                "code": "```\\nint countGoodSubstrings(string s) \\n{\\n\\tint result=0,n=s.length();\\n\\tfor(int i=0;i<n-2;i++)\\n\\t\\tif(s[i]!=s[i+1]&&s[i]!=s[i+2]&&s[i+1]!=s[i+2]) result++;\\n\\n\\treturn result;\\n}\\n```\n```\\ndef countGoodSubstrings(self, s):\\n\\treturn sum([s[i]!=s[i+1]!=s[i+2]!=s[i] for i in range(len(s)-2)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4088642,
                "title": "beats-100-easiest-explanation-clean-code-c",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- The idea is so simple.\\n- Have a window of size 3, slide it and increment count if unique elements.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count=0, n = s.size();\\n        for(int i=0; i<=n-3; i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1] != s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int count=0, n = s.size();\\n        for(int i=0; i<=n-3; i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1] != s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930431,
                "title": "slliding-window-o-n-t-c-proper-intuition-explained",
                "content": "# Intuition\\u2705\\nThis Easy question is good.I have solved this question using sliding window O(N) solution. i have used map to store frequency of each window. here window size will be 3 becaue we have to find good substrings of length three.\\n\\n# Approach\\u2705\\u2705\\n1. we will insert element till we hit window size 3. \\n2. After complete 3 size window, we will check all three character of particular window is **unique or not**.\\n3. if we find **all three character unique in window**( **if(mp.size() == 3)**)then increase cnt.\\n\\n4. Now we will slide window to right side for further investigation in right sides all window.\\n5. Important point is, before slide window we will decrease frequency of **s[i]** element in map. then we do i++.\\n6. [ ****if(mp[s[i]] == 0) mp.erase(s[i])**** ]  if we find any mapping of character equal to 0 then we have to erase that key from map other wise map keep it as size 1 . whenever we check condition for **(mp.size() == 3)** it increase size by 1 , which will be wrong.\\n\\n# Complexity\\n- Time complexity:\\n   O(N)\\n\\n- Space complexity:\\n\\n  O(N)\\n              \\n     ****\\uD83D\\uDE80\\uD83D\\uDE80Kindly upvote if you find helpful\\uD83D\\uDE80\\uD83D\\uDE80****\\n\\n---\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n = s.size();\\n        unordered_map<char,int>mp;\\n        int i = 0, j=0;\\n        int cnt=0;\\n        while(j<n){\\n            mp[s[j]]++;\\n            if((j-i+1) < 3) j++;\\n           else{\\n               if(mp.size() == 3){\\n                   cnt++;\\n               }\\n               mp[s[i]]--;\\n               if(mp[s[i]] == 0) mp.erase(s[i]);\\n               i++;\\n               j++;\\n           }   \\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n = s.size();\\n        unordered_map<char,int>mp;\\n        int i = 0, j=0;\\n        int cnt=0;\\n        while(j<n){\\n            mp[s[j]]++;\\n            if((j-i+1) < 3) j++;\\n           else{\\n               if(mp.size() == 3){\\n                   cnt++;\\n               }\\n               mp[s[i]]--;\\n               if(mp[s[i]] == 0) mp.erase(s[i]);\\n               i++;\\n               j++;\\n           }   \\n            \\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3106591,
                "title": "c-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0, j=0;\\n        int cnt=0;\\n        \\n        unordered_map<char,int> mpp;\\n        while(j< s.size()) {\\n            mpp[s[j]]++;\\n            \\n            if(j-i+1==3) {\\n                if(mpp.size()==3) cnt++;\\n                 mpp[s[i]]--;\\n                if(mpp[s[i]]==0) mpp.erase(s[i]);\\n                i++;\\n            }\\n        j++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i=0, j=0;\\n        int cnt=0;\\n        \\n        unordered_map<char,int> mpp;\\n        while(j< s.size()) {\\n            mpp[s[j]]++;\\n            \\n            if(j-i+1==3) {\\n                if(mpp.size()==3) cnt++;\\n                 mpp[s[i]]--;\\n                if(mpp[s[i]]==0) mpp.erase(s[i]);\\n                i++;\\n            }\\n        j++;\\n        }\\n        return cnt;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3070161,
                "title": "idiomatic-kotlin",
                "content": "# Explanation\\nDivide the input by a substrings of three (by default increments of 1). Obtained substrings of size are still the same size after they are added to a set, we can conclude that the characters are unique\\n# Code\\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        return s.windowed(3).count { it.toSet().size == 3}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        return s.windowed(3).count { it.toSet().size == 3}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3053190,
                "title": "c-o-n-solution-beats-100-o-1-space",
                "content": "\\n\\n# Approach : Sliding Window\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i = 0;\\n        int count = 0;\\n        unordered_map<char, int> ump;\\n        for(int j=0;j<s.size();j++) {\\n            ump[s[j]]++;\\n            if(j - i + 1 == 3) {\\n                if(ump.size() == 3) count++;\\n                ump[s[i]]--;\\n                if(ump[s[i]] == 0) ump.erase(s[i]);\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i = 0;\\n        int count = 0;\\n        unordered_map<char, int> ump;\\n        for(int j=0;j<s.size();j++) {\\n            ump[s[j]]++;\\n            if(j - i + 1 == 3) {\\n                if(ump.size() == 3) count++;\\n                ump[s[i]]--;\\n                if(ump[s[i]] == 0) ump.erase(s[i]);\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2810964,
                "title": "python-sliding-window-95-01-faster-5-lines",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        c,n=0,len(s)\\n        for i in range(n-2):\\n            t=set(s[i:i+3])\\n            if len(t)==3:\\n                c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        c,n=0,len(s)\\n        for i in range(n-2):\\n            t=set(s[i:i+3])\\n            if len(t)==3:\\n                c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2677301,
                "title": "java-simple-sol-o-n",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int count=0;\\n\\n        for(int i=0;i<s.length()-2;i++){\\n\\n            char x=s.charAt(i);\\n            char y=s.charAt(i+1);\\n            char z=s.charAt(i+2);\\n\\n            if(x!=y && y!=z && z!=x) count++;\\n\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int count=0;\\n\\n        for(int i=0;i<s.length()-2;i++){\\n\\n            char x=s.charAt(i);\\n            char y=s.charAt(i+1);\\n            char z=s.charAt(i+2);\\n\\n            if(x!=y && y!=z && z!=x) count++;\\n\\n        }\\n        \\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664924,
                "title": "java-easy-solution-single-if-beginner-friendly",
                "content": "class Solution {\\n    public int countGoodSubstrings(String s) \\n    {\\n        //String res = s.substring(0,3);\\n        int c=0;\\n        \\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n                String res = s.substring(i,i+3);\\n                if(res.charAt(0)!=res.charAt(1) && res.charAt(1)!=res.charAt(2)&& res.charAt(0)!=res.charAt(2))\\n                    c++;\\n        }    \\n        return c;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) \\n    {\\n        //String res = s.substring(0,3);\\n        int c=0;\\n        \\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n                String res = s.substring(i,i+3);\\n                if(res.charAt(0)!=res.charAt(1) && res.charAt(1)!=res.charAt(2)&& res.charAt(0)!=res.charAt(2))\\n                    c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2408328,
                "title": "c-solution-using-2-approaches",
                "content": "Approach 1 : This is basically a brute force, which gets accepted here for this question as the s.size() can be 100 at max and size of window is 3.\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0; //store count of GOOD (unique) substrings\\n        for(int i=1; i<s.size()-1; i++)\\n        {\\n            if(s[i]!=s[i+1] && s[i-1]!=s[i] && s[i-1]!=s[i+1]) //check whether the letter at s[i] is equal to its previous and next letter\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nApproach 2 : Classic Sliding Window (thanks to @sk58 for helping me in better understanding of this approach)\\nFor greater window sizes and greater length of string, we can use sliding window.\\nIntuition (how to check, if we can use sliding window here???) (NOTE : This is for general questions)\\n1. The data structure mentioned will be array/string.\\n2. The question asks for maximum or minimum of something, maybe count, sums or uniqueness; as we have here in the question.\\n3. The size of the window is mentioned in the question, here it is 3.\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0;  //stores the count of GOOD substrings\\n        int i=0, j=0; //initialize i as starting position of window & j as ending position of the window\\n        int n = s.size();\\n        unordered_map<char, int>freq; //to map the characters in the string to their frequency\\n        while(i<n && j<n)\\n        {\\n            freq[s[j]]++; //to get the count of characters\\n            if(j-i+1 < 3) // if we haven\\'t reached to the required size of window, just increment ending position\\n                j++;\\n            else if(freq.size()==3) //this means, we have reached the required window size along with GOOD substring\\n            {\\n                ans++;\\n                freq.erase(s[i]); //erase the character&its count, so that we can move forward with the window\\n                i++; //increment starting position\\n                j++; //increment ending position\\n\\t\\t\\t\\t//this maintains the size of the window\\n            }\\n            else // if the size of the freq != 3, this means there\\'s a repetition of characters, though the window size is still 3\\n            {\\n                freq[s[i]]--; //decrement the count of the character as we will be shifting the window\\n                if(freq[s[i]]==0)\\n                    freq.erase(s[i]); //just remove the entry of the character, as it is not needed\\n                i++;\\n                j++;\\n\\t\\t\\t\\t//increment the positions to shift the window\\n            } \\n        }       \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0; //store count of GOOD (unique) substrings\\n        for(int i=1; i<s.size()-1; i++)\\n        {\\n            if(s[i]!=s[i+1] && s[i-1]!=s[i] && s[i-1]!=s[i+1]) //check whether the letter at s[i] is equal to its previous and next letter\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int ans=0;  //stores the count of GOOD substrings\\n        int i=0, j=0; //initialize i as starting position of window & j as ending position of the window\\n        int n = s.size();\\n        unordered_map<char, int>freq; //to map the characters in the string to their frequency\\n        while(i<n && j<n)\\n        {\\n            freq[s[j]]++; //to get the count of characters\\n            if(j-i+1 < 3) // if we haven\\'t reached to the required size of window, just increment ending position\\n                j++;\\n            else if(freq.size()==3) //this means, we have reached the required window size along with GOOD substring\\n            {\\n                ans++;\\n                freq.erase(s[i]); //erase the character&its count, so that we can move forward with the window\\n                i++; //increment starting position\\n                j++; //increment ending position\\n\\t\\t\\t\\t//this maintains the size of the window\\n            }\\n            else // if the size of the freq != 3, this means there\\'s a repetition of characters, though the window size is still 3\\n            {\\n                freq[s[i]]--; //decrement the count of the character as we will be shifting the window\\n                if(freq[s[i]]==0)\\n                    freq.erase(s[i]); //just remove the entry of the character, as it is not needed\\n                i++;\\n                j++;\\n\\t\\t\\t\\t//increment the positions to shift the window\\n            } \\n        }       \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1801123,
                "title": "easy-solution-0ms-solution",
                "content": "class Solution {\\npublic:\\n\\n    int countGoodSubstrings(string s) {\\n        int i=0;\\n        int j=1;\\n        int k=2;\\n        int count=0;\\n        while(k<s.size()){\\n            if(s[i]!=s[j] and s[j]!=s[k] and s[i]!=s[k]){\\n                count++;\\n                // i++;j++;k++;\\n            }\\n            i+=1;\\n            j+=1;\\n            k+=1;\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countGoodSubstrings(string s) {\\n        int i=0;\\n        int j=1;\\n        int k=2;\\n        int count=0;\\n        while(k<s.size()){\\n            if(s[i]!=s[j] and s[j]!=s[k] and s[i]!=s[k]){\\n                count++;\\n                // i++;j++;k++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1797917,
                "title": "java-time-o-n-space-o-n-for-all-windows-size-substrings-of-length",
                "content": "I think it\\'s easy to solve the length three problem just using three variables for monitoring. However, how about the problem becomes checking length four or even a hundred lengths? \\n\\nI wrote an answer that only modifies the size of the window, but works with different lengths.\\n\\n```\\nclass Solution {\\n  /**\\n   * Time O(n)\\n   * Space O(n)\\n   */\\n  public int countGoodSubstrings(String s) {\\n    int sum = 0;\\n    int window = 3;\\n    // Space O(n)\\n    Map<Character, Integer> map = new HashMap<>();\\n    // Space O(n)\\n    Set<Character> dup = new HashSet<>();\\n    // Time O(n)\\n    for (int i = 0; i < s.length(); i++) {\\n      // Time O(1)\\n      int count = map.getOrDefault(s.charAt(i), 0);\\n      count++;\\n      // Time O(1)\\n      map.put(s.charAt(i), count);\\n      // Time O(1)\\n      if (count > 1 && !dup.contains(s.charAt(i))) {\\n        // Time O(1)\\n        dup.add(s.charAt(i));\\n      }\\n      if (i > (window - 1)) {\\n        // Time O(1)\\n        count = map.get(s.charAt(i - window)) - 1;\\n        // Time O(1)\\n        map.put(s.charAt(i - window), count);\\n        if (count < (window - 1)) {\\n          // Time O(1)\\n          dup.remove(s.charAt(i - window));\\n        }\\n      }\\n      // Time O(1)\\n      if (i > (window - 2) && dup.isEmpty()) {\\n        sum++;\\n      }\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  /**\\n   * Time O(n)\\n   * Space O(n)\\n   */\\n  public int countGoodSubstrings(String s) {\\n    int sum = 0;\\n    int window = 3;\\n    // Space O(n)\\n    Map<Character, Integer> map = new HashMap<>();\\n    // Space O(n)\\n    Set<Character> dup = new HashSet<>();\\n    // Time O(n)\\n    for (int i = 0; i < s.length(); i++) {\\n      // Time O(1)\\n      int count = map.getOrDefault(s.charAt(i), 0);\\n      count++;\\n      // Time O(1)\\n      map.put(s.charAt(i), count);\\n      // Time O(1)\\n      if (count > 1 && !dup.contains(s.charAt(i))) {\\n        // Time O(1)\\n        dup.add(s.charAt(i));\\n      }\\n      if (i > (window - 1)) {\\n        // Time O(1)\\n        count = map.get(s.charAt(i - window)) - 1;\\n        // Time O(1)\\n        map.put(s.charAt(i - window), count);\\n        if (count < (window - 1)) {\\n          // Time O(1)\\n          dup.remove(s.charAt(i - window));\\n        }\\n      }\\n      // Time O(1)\\n      if (i > (window - 2) && dup.isEmpty()) {\\n        sum++;\\n      }\\n    }\\n    return sum;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1485706,
                "title": "c-100-faster",
                "content": "```\\nint countGoodSubstrings(string s) {\\n      if(s.size() < 3) return 0;\\n      int i=0, j=0, counter=0, ans=0;\\n      vector<int> map(128, 0);\\n\\t  \\n      while(j < s.size())\\n      {\\n        if(j-i+1 <= 3) {if(map[s[j++]]++ == 0) counter++;}\\n        else {\\n          if(counter == 3) ans++;\\n          if(map[s[i++]]-- == 1) counter--;\\n        }\\n        if(counter == 3 && j == s.size()) ans++;\\n      }\\n      return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint countGoodSubstrings(string s) {\\n      if(s.size() < 3) return 0;\\n      int i=0, j=0, counter=0, ans=0;\\n      vector<int> map(128, 0);\\n\\t  \\n      while(j < s.size())\\n      {\\n        if(j-i+1 <= 3) {if(map[s[j++]]++ == 0) counter++;}\\n        else {\\n          if(counter == 3) ans++;\\n          if(map[s[i++]]-- == 1) counter--;\\n        }\\n        if(counter == 3 && j == s.size()) ans++;\\n      }\\n      return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1299772,
                "title": "easy-java-solution-100-fast",
                "content": "```\\n/* check every substring of size 3, if all the letters in the substring are distinct, increment the count of good strings*/\\n public int countGoodSubstrings(String s) {\\n        int count=0;\\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n            char ch1=s.charAt(i);\\n            char ch2=s.charAt(i+1);\\n            char ch3=s.charAt(i+2);\\n            if(ch1!=ch2 && ch2!=ch3 && ch1!=ch3)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/* check every substring of size 3, if all the letters in the substring are distinct, increment the count of good strings*/\\n public int countGoodSubstrings(String s) {\\n        int count=0;\\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n            char ch1=s.charAt(i);\\n            char ch2=s.charAt(i+1);\\n            char ch3=s.charAt(i+2);\\n            if(ch1!=ch2 && ch2!=ch3 && ch1!=ch3)\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1285693,
                "title": "c-solution-100-faster",
                "content": "```\\nint countGoodSubstrings(string s) {\\n        int i=0;\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count = 0;\\n        while(i<s.size()-2){\\n            if(s[i]!=s[i+1]&&s[i+1]!=s[i+2]&&s[i+2]!=s[i]){\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n\\t\\n\\t```",
                "solutionTags": [],
                "code": "```\\nint countGoodSubstrings(string s) {\\n        int i=0;\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count = 0;\\n        while(i<s.size()-2){\\n            if(s[i]!=s[i+1]&&s[i+1]!=s[i+2]&&s[i+2]!=s[i]){\\n                count++;\\n            }\\n            i++;\\n        }\\n        return count;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238901,
                "title": "easy-sliding-window-approach-in-c",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int countGoodSubstrings(string s) \\n    {\\n        int n=s.length();\\n        if(n<3)\\n        {\\n            return 0;\\n        }\\n        unordered_map<char,int>m;\\n        for(int i=0;i<3;i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        int i=0,j=2,sum=0;\\n        while(j<n)\\n        {\\n            if(m.size()==3)\\n            {\\n                sum++;\\n            }\\n            if(m[s[i]]==1)\\n            {\\n                m.erase(s[i]);\\n            }\\n            else\\n            {\\n                m[s[i]]--;\\n            }\\n            m[s[j+1]]++;\\n            i++;\\n            j++;   \\n        }\\n        return sum;\\n    }\\n};\\n```\\n**Please upvote if you have got any help from my code. Thank you.**",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int countGoodSubstrings(string s) \\n    {\\n        int n=s.length();\\n        if(n<3)\\n        {\\n            return 0;\\n        }\\n        unordered_map<char,int>m;\\n        for(int i=0;i<3;i++)\\n        {\\n            m[s[i]]++;\\n        }\\n        int i=0,j=2,sum=0;\\n        while(j<n)\\n        {\\n            if(m.size()==3)\\n            {\\n                sum++;\\n            }\\n            if(m[s[i]]==1)\\n            {\\n                m.erase(s[i]);\\n            }\\n            else\\n            {\\n                m[s[i]]--;\\n            }\\n            m[s[j+1]]++;\\n            i++;\\n            j++;   \\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238768,
                "title": "java-easy-solution",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String str) {\\n        int count = 0;\\n        int counter;\\n        String s = \"\";\\n        for(int i = 0; i <= str.length() - 3; i++){\\n            Set<Character> set = new HashSet<Character>();\\n            s = str.substring(i, i + 3);\\n            counter = 0;\\n            for(char c : s.toCharArray()){\\n                if(set.add(c))\\n                    counter++;\\n                else\\n                    break;\\n            }\\n            if(counter == 3){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String str) {\\n        int count = 0;\\n        int counter;\\n        String s = \"\";\\n        for(int i = 0; i <= str.length() - 3; i++){\\n            Set<Character> set = new HashSet<Character>();\\n            s = str.substring(i, i + 3);\\n            counter = 0;\\n            for(char c : s.toCharArray()){\\n                if(set.add(c))\\n                    counter++;\\n                else\\n                    break;\\n            }\\n            if(counter == 3){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238638,
                "title": "a-few-solutions",
                "content": "**Brute-Force (Functional)**\\n\\nConsider each substring `t` of length `3` of the input string `s`.  Note: `t` is implied as the substring `s[i..i+3)` (ie. from `i` inclusive to `i + 3` non-inclusive).\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    var countGoodSubstrings = { s: String -> s.toList().mapIndexed{ i, _ -> if (i + 3 <= s.length && s.substring(i, i + 3).toSet().size == 3) 1 else 0 }!!.sum() }\\n}\\n```\\n\\n*Javascript (note: `t` is the accumulator, ie. `t` is the total sum reduced thus far)*\\n```\\nlet countGoodSubstrings = s => s.split(\\'\\').reduce((t, _, i) => i + 3 <= s.length && new Set(s.substring(i, i + 3).split(\\'\\')).size == 3 ? 1 + t : t, 0);\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        return sum(1 if i + 3 <= len(s) and len(set(list(s[i:i + 3]))) == 3 else 0 for i in range(len(s)))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        return count_if(s.begin(), s.end(), [i = -1, &s](auto _) mutable {\\n            ++i;\\n            if (s.size() < i + 3)\\n                return false;\\n            auto t = s.substr(i, 3);\\n            return Set{ t.begin(), t.end() }.size() == 3;\\n        });\\n    }\\n};\\n```\\n\\n---\\n\\n**Brute-Force (Procedural)**\\n\\nConsider each substring `t` of length `3` of the input string `s`.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        for (i in 0 until s.length - 3 + 1)\\n            if (s.substring(i, i + 3).toSet().size == 3)\\n                ++cnt\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countGoodSubstrings = (s, cnt = 0) => {\\n    for (let i = 0; i + 3 <= s.length; ++i) {\\n        let t = s.substring(i, i + 3);\\n        cnt += new Set(t).size == 3;\\n    }\\n    return cnt;\\n}\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        for i in range(0, N - 3 + 1):\\n            t = s[i:i + 3]\\n            cnt += len(set(t)) == 3\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        int N = s.size();\\n        for (auto i{ 0 }; i + 3 <= N; ++i) {\\n            auto t = s.substr(i, 3);\\n            cnt += Set{ t.begin(), t.end() }.size() == 3;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n---\\n\\n**\\uD83D\\uDC48 Sliding Window ( a, b, c )**\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        var N = s.length\\n        if (N < 3)\\n            return 0\\n        var a = s[0]\\n        var b = s[1]\\n        var c = \\'*\\'\\n        for (i in 2 until N) {\\n            c = s[i]\\n            if (a != b && b != c && a != c)  // \\uD83C\\uDFAF 3 unique values\\n                ++cnt\\n            a = b; b = c                     // \\uD83D\\uDC48 slide window\\n        }\\n        return cnt;\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countGoodSubstrings = (s, cnt = 0) => {\\n    let N = s.length;\\n    if (N < 3)\\n        return 0;\\n    let a = s[0],\\n        b = s[1],\\n        c = \\'\\\\0\\';\\n    for (let i = 2; i < N; ++i) {\\n        c = s[i];\\n        cnt += a != b && b != c && a != c;  // \\uD83C\\uDFAF 3 unique values\\n        a = b, b = c;                       // \\uD83D\\uDC48 slide window\\n    }\\n    return cnt;\\n}\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        if N < 3:\\n            return 0\\n        a = s[0]\\n        b = s[1]\\n        c = \\'\\\\0\\'\\n        for i in range(2, N):\\n            c = s[i]; i += 1\\n            cnt += a != b and b != c and a != c  # \\uD83C\\uDFAF 3 unique values\\n            a = b; b = c                         # \\uD83D\\uDC48 slide window\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        int N = s.size();\\n        if (N < 3)\\n            return 0;\\n        auto a = s[0],\\n             b = s[1],\\n             c = \\'\\\\0\\';\\n        for (auto i{ 2 }; i < N; ++i) {\\n            c = s[i];\\n            cnt += c != b && b != a && c != a;  // \\uD83C\\uDFAF 3 unique values\\n            a = b, b = c;                       // \\uD83D\\uDC48 slide window\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n---\\n\\n**\\uD83D\\uDC49 Sliding Window [ i = j -2 .. i ] + \\uD83D\\uDDFA Map**\\n\\nUse a map `m` to track the count of each character in the window of size `3`.  Return the count `cnt` of unique substrings of length `3`.\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        var m = mutableMapOf<Char, Int>()\\n        var N = s.length\\n        var j = 0\\n        while (j < 2 && j < N) {\\n            m[s[j]] = 1 + m.getOrDefault(s[j], 0)\\n            ++j\\n        }\\n        while (j < N) {\\n            m[s[j]] = 1 + m.getOrDefault(s[j], 0)\\n            if (m.size == 3)\\n                ++cnt\\n            m[s[j - 2]] = -1 + m[s[j - 2]]!!\\n            if (m[s[j - 2]]!! == 0)\\n                m.remove(s[j - 2])\\n            ++j\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countGoodSubstrings = (s, m = new Map(), cnt = 0) => {\\n    let N = s.length,\\n        j = 0;\\n    while (j < 2) {\\n        m.set(s[j], 1 + (m.get(s[j]) || 0));\\n        ++j;\\n    }\\n    while (j < N) {\\n        m.set(s[j], 1 + (m.get(s[j]) || 0));\\n        cnt += m.size == 3;\\n        if (!m.set(s[j - 2], -1 + m.get(s[j - 2])).get(s[j - 2]))\\n            m.delete(s[j - 2]);\\n        ++j;\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        j = 2\\n        m = Counter(c for c in s[:2])\\n        while j < N:\\n            m[s[j]] = 1 + (m[s[j]] if s[j] in m else 0)\\n            if len(m) == 3:\\n                cnt += 1\\n            m[s[j - 2]] -= 1\\n            if m[s[j - 2]] == 0:\\n                del m[s[j - 2]]\\n            j += 1\\n        return cnt\\n```\\n        \\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    int countGoodSubstrings(string s, Map m = {}, int cnt = 0) {\\n        int N = s.size(),\\n            j = 0;\\n        while (j < min(2, N))\\n            ++m[s[j++]];\\n        while (j < N) {\\n            ++m[s[j]];\\n            cnt += m.size() == 3;\\n            if (!--m[s[j - 2]])\\n                m.erase(s[j - 2]);\\n            ++j;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n---",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var countGoodSubstrings = { s: String -> s.toList().mapIndexed{ i, _ -> if (i + 3 <= s.length && s.substring(i, i + 3).toSet().size == 3) 1 else 0 }!!.sum() }\\n}\\n```\n```\\nlet countGoodSubstrings = s => s.split(\\'\\').reduce((t, _, i) => i + 3 <= s.length && new Set(s.substring(i, i + 3).split(\\'\\')).size == 3 ? 1 + t : t, 0);\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        return sum(1 if i + 3 <= len(s) and len(set(list(s[i:i + 3]))) == 3 else 0 for i in range(len(s)))\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        return count_if(s.begin(), s.end(), [i = -1, &s](auto _) mutable {\\n            ++i;\\n            if (s.size() < i + 3)\\n                return false;\\n            auto t = s.substr(i, 3);\\n            return Set{ t.begin(), t.end() }.size() == 3;\\n        });\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        for (i in 0 until s.length - 3 + 1)\\n            if (s.substring(i, i + 3).toSet().size == 3)\\n                ++cnt\\n        return cnt\\n    }\\n}\\n```\n```\\nlet countGoodSubstrings = (s, cnt = 0) => {\\n    for (let i = 0; i + 3 <= s.length; ++i) {\\n        let t = s.substring(i, i + 3);\\n        cnt += new Set(t).size == 3;\\n    }\\n    return cnt;\\n}\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        for i in range(0, N - 3 + 1):\\n            t = s[i:i + 3]\\n            cnt += len(set(t)) == 3\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        int N = s.size();\\n        for (auto i{ 0 }; i + 3 <= N; ++i) {\\n            auto t = s.substr(i, 3);\\n            cnt += Set{ t.begin(), t.end() }.size() == 3;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        var N = s.length\\n        if (N < 3)\\n            return 0\\n        var a = s[0]\\n        var b = s[1]\\n        var c = \\'*\\'\\n        for (i in 2 until N) {\\n            c = s[i]\\n            if (a != b && b != c && a != c)  // \\uD83C\\uDFAF 3 unique values\\n                ++cnt\\n            a = b; b = c                     // \\uD83D\\uDC48 slide window\\n        }\\n        return cnt;\\n    }\\n}\\n```\n```\\nlet countGoodSubstrings = (s, cnt = 0) => {\\n    let N = s.length;\\n    if (N < 3)\\n        return 0;\\n    let a = s[0],\\n        b = s[1],\\n        c = \\'\\\\0\\';\\n    for (let i = 2; i < N; ++i) {\\n        c = s[i];\\n        cnt += a != b && b != c && a != c;  // \\uD83C\\uDFAF 3 unique values\\n        a = b, b = c;                       // \\uD83D\\uDC48 slide window\\n    }\\n    return cnt;\\n}\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        if N < 3:\\n            return 0\\n        a = s[0]\\n        b = s[1]\\n        c = \\'\\\\0\\'\\n        for i in range(2, N):\\n            c = s[i]; i += 1\\n            cnt += a != b and b != c and a != c  # \\uD83C\\uDFAF 3 unique values\\n            a = b; b = c                         # \\uD83D\\uDC48 slide window\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    int countGoodSubstrings(string s, int cnt = 0) {\\n        int N = s.size();\\n        if (N < 3)\\n            return 0;\\n        auto a = s[0],\\n             b = s[1],\\n             c = \\'\\\\0\\';\\n        for (auto i{ 2 }; i < N; ++i) {\\n            c = s[i];\\n            cnt += c != b && b != a && c != a;  // \\uD83C\\uDFAF 3 unique values\\n            a = b, b = c;                       // \\uD83D\\uDC48 slide window\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun countGoodSubstrings(s: String): Int {\\n        var cnt = 0\\n        var m = mutableMapOf<Char, Int>()\\n        var N = s.length\\n        var j = 0\\n        while (j < 2 && j < N) {\\n            m[s[j]] = 1 + m.getOrDefault(s[j], 0)\\n            ++j\\n        }\\n        while (j < N) {\\n            m[s[j]] = 1 + m.getOrDefault(s[j], 0)\\n            if (m.size == 3)\\n                ++cnt\\n            m[s[j - 2]] = -1 + m[s[j - 2]]!!\\n            if (m[s[j - 2]]!! == 0)\\n                m.remove(s[j - 2])\\n            ++j\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet countGoodSubstrings = (s, m = new Map(), cnt = 0) => {\\n    let N = s.length,\\n        j = 0;\\n    while (j < 2) {\\n        m.set(s[j], 1 + (m.get(s[j]) || 0));\\n        ++j;\\n    }\\n    while (j < N) {\\n        m.set(s[j], 1 + (m.get(s[j]) || 0));\\n        cnt += m.size == 3;\\n        if (!m.set(s[j - 2], -1 + m.get(s[j - 2])).get(s[j - 2]))\\n            m.delete(s[j - 2]);\\n        ++j;\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str, cnt = 0) -> int:\\n        N = len(s)\\n        j = 2\\n        m = Counter(c for c in s[:2])\\n        while j < N:\\n            m[s[j]] = 1 + (m[s[j]] if s[j] in m else 0)\\n            if len(m) == 3:\\n                cnt += 1\\n            m[s[j - 2]] -= 1\\n            if m[s[j - 2]] == 0:\\n                del m[s[j - 2]]\\n            j += 1\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using Map = unordered_map<char, int>;\\n    int countGoodSubstrings(string s, Map m = {}, int cnt = 0) {\\n        int N = s.size(),\\n            j = 0;\\n        while (j < min(2, N))\\n            ++m[s[j++]];\\n        while (j < N) {\\n            ++m[s[j]];\\n            cnt += m.size() == 3;\\n            if (!--m[s[j - 2]])\\n                m.erase(s[j - 2]);\\n            ++j;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241425,
                "title": "unpredicted-logic-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:(i+3)]))==3:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:(i+3)]))==3:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240610,
                "title": "simple-and-easy-code-to-understand-in-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Consider upvoting if found helpful\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            x=s[i:i+3]\\n            if x.count(x[0])==1 and x.count(x[1])==1 and x.count(x[2])==1:\\n                count+=1\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            x=s[i:i+3]\\n            if x.count(x[0])==1 and x.count(x[1])==1 and x.count(x[2])==1:\\n                count+=1\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585357,
                "title": "sliding-window-python3-easy-undersatnding",
                "content": "This problem can be easily solved using Sliding Window pattern\\n\\n*Time: O(n)\\nSpace: O(1)*\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        windowStart = 0\\n        \\n        c = 0\\n        \\n\\t\\t# O(n)\\n        for windowEnd in range(len(s)):\\n            \\n            if windowEnd - windowStart + 1 == 3:\\n                \\n                valid = True\\n                \\n\\t\\t\\t\\t# Stores at most 3 letters => O(1) \\n                vis = {}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Runs for 3 times at most => O(1) \\n                for i in range(windowStart, windowEnd+1):\\n                    \\n                    if s[i] not in vis:\\n                        vis[s[i]] = 1\\n                    else:\\n                        valid = False\\n                        break\\n                \\n                if valid:\\n                    c += 1\\n                \\n                windowStart += 1\\n        \\n        return c\\n                \\n  \\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        windowStart = 0\\n        \\n        c = 0\\n        \\n\\t\\t# O(n)\\n        for windowEnd in range(len(s)):\\n            \\n            if windowEnd - windowStart + 1 == 3:\\n                \\n                valid = True\\n                \\n\\t\\t\\t\\t# Stores at most 3 letters => O(1) \\n                vis = {}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t# Runs for 3 times at most => O(1) \\n                for i in range(windowStart, windowEnd+1):\\n                    \\n                    if s[i] not in vis:\\n                        vis[s[i]] = 1\\n                    else:\\n                        valid = False\\n                        break\\n                \\n                if valid:\\n                    c += 1\\n                \\n                windowStart += 1\\n        \\n        return c\\n                \\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464237,
                "title": "go-solution",
                "content": "```\\nfunc countGoodSubstrings(s string) int {\\n    charSet, count, left := make([]byte, 26), 0, 0\\n    \\n    for right := 0; right < len(s); right++ {\\n        charSet[s[right] - \\'a\\']++\\n        \\n        for right - left + 1 > 3 {\\n            charSet[s[left] - \\'a\\']--\\n            left++\\n        }\\n        \\n        if right-left+1 == 3 {\\n            charCount := 0\\n            \\n            for i := 0; i < 26; i++ {\\n                if charSet[i] > 0 {\\n                    charCount++\\n                }    \\n            }\\n            \\n            if charCount == 3 {\\n                count++\\n            }\\n        }\\n    }\\n    \\n    return count\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countGoodSubstrings(s string) int {\\n    charSet, count, left := make([]byte, 26), 0, 0\\n    \\n    for right := 0; right < len(s); right++ {\\n        charSet[s[right] - \\'a\\']++\\n        \\n        for right - left + 1 > 3 {\\n            charSet[s[left] - \\'a\\']--\\n            left++\\n        }\\n        \\n        if right-left+1 == 3 {\\n            charCount := 0\\n            \\n            for i := 0; i < 26; i++ {\\n                if charSet[i] > 0 {\\n                    charCount++\\n                }    \\n            }\\n            \\n            if charCount == 3 {\\n                count++\\n            }\\n        }\\n    }\\n    \\n    return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2077347,
                "title": "js-sliding-window-solution-with-explanation",
                "content": "## Explanation\\n\\nPhase one: setup pointers to left and right of sliding window\\n```\\n// index           0 1 2 3 4 5 \\n//                 a b c b c a\\n// step 1:         ^              // map{a: 1},             left: 0, right: 0\\n// step 2:         ^ ^            // map{a: 1, b: 1},       left: 0, right: 1\\n// step 3:         ^   ^          // map{a: 1, b: 1, c: 1}, left: 0, right: 2\\n```\\nOn each step: we store characters to map (key: character; value: frequency).\\n\\nPhase two: moving sliding window until right pointer has reached the end of string.\\n```\\n// index           0 1 2 3 4 5\\n//                 a b c b c a\\n// step 4:           ^   ^            // map{b: 2, c: 1},  left: 1, right: 3\\n// step 5:             ^   ^          // map{b: 1, c: 2},  left: 2, right: 4\\n// etc\\u2026\\n```\\nOn each step:\\n 1) check size of map: if its equal windowSize then answer is updated.\\n 2) drop old left character from map\\n 3) add new right character to map\\n 4) move pointers of left and right of sliding window.\\n\\n\\n## Code:\\n```\\nvar countGoodSubstrings = function(s) {\\n    const lookup = new Map();\\n    const windowSize = 3;\\n    \\n    let answer = 0;\\n    let left = 0;\\n    let right = 0;\\n    \\n    while(right < s.length) {\\n        const rightChar = s[right];\\n        const val = lookup.get(rightChar) || 0;\\n        \\n        lookup.set(rightChar, val + 1);\\n        \\n        if (right - left + 1 < windowSize) {\\n            right += 1;\\n            \\n            continue;\\n        }\\n        \\n        if (lookup.size === windowSize) answer += 1;\\n        \\n        // update map\\n        const leftChar = s[left];\\n        lookup.set(leftChar, lookup.get(leftChar) - 1);\\n        if (lookup.get(leftChar) === 0) {\\n            lookup.delete(leftChar);\\n        }\\n        \\n        // move window\\n        left += 1;\\n        right += 1;\\n    }\\n    \\n    return answer;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n// index           0 1 2 3 4 5 \\n//                 a b c b c a\\n// step 1:         ^              // map{a: 1},             left: 0, right: 0\\n// step 2:         ^ ^            // map{a: 1, b: 1},       left: 0, right: 1\\n// step 3:         ^   ^          // map{a: 1, b: 1, c: 1}, left: 0, right: 2\\n```\n```\\n// index           0 1 2 3 4 5\\n//                 a b c b c a\\n// step 4:           ^   ^            // map{b: 2, c: 1},  left: 1, right: 3\\n// step 5:             ^   ^          // map{b: 1, c: 2},  left: 2, right: 4\\n// etc\\u2026\\n```\n```\\nvar countGoodSubstrings = function(s) {\\n    const lookup = new Map();\\n    const windowSize = 3;\\n    \\n    let answer = 0;\\n    let left = 0;\\n    let right = 0;\\n    \\n    while(right < s.length) {\\n        const rightChar = s[right];\\n        const val = lookup.get(rightChar) || 0;\\n        \\n        lookup.set(rightChar, val + 1);\\n        \\n        if (right - left + 1 < windowSize) {\\n            right += 1;\\n            \\n            continue;\\n        }\\n        \\n        if (lookup.size === windowSize) answer += 1;\\n        \\n        // update map\\n        const leftChar = s[left];\\n        lookup.set(leftChar, lookup.get(leftChar) - 1);\\n        if (lookup.get(leftChar) === 0) {\\n            lookup.delete(leftChar);\\n        }\\n        \\n        // move window\\n        left += 1;\\n        right += 1;\\n    }\\n    \\n    return answer;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1971665,
                "title": "easy-o-n-js-solution",
                "content": "var countGoodSubstrings = function(s) {\\n    let total = 0;\\n    let setArr;\\n    for(let i=0; i<=s.length - 3; i++){\\n        setArr = new Set(s.slice(i, i+3));\\n        \\n        if(setArr.size === 3){\\n            total++;\\n        }\\n    }\\n    \\n    return total;\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var countGoodSubstrings = function(s) {\\n    let total = 0;\\n    let setArr;\\n    for(let i=0; i<=s.length - 3; i++){\\n        setArr = new Set(s.slice(i, i+3));\\n        \\n        if(setArr.size === 3){\\n            total++;\\n        }\\n    }\\n    \\n    return total;\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1755929,
                "title": "java-o-n-solution",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n        int uniqueSubstrings = 0;\\n        int left = 0;\\n        int right = 2;\\n        \\n        for(int i = 1; i<s.length()-1; i++){\\n            \\n            if(s.charAt(i) != s.charAt(left) && s.charAt(i) != s.charAt(right) && s.charAt(right) != s.charAt(left)){\\n                uniqueSubstrings++;\\n            }\\n            left++;\\n            right++;\\n        }\\n        return uniqueSubstrings;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n        int uniqueSubstrings = 0;\\n        int left = 0;\\n        int right = 2;\\n        \\n        for(int i = 1; i<s.length()-1; i++){\\n            \\n            if(s.charAt(i) != s.charAt(left) && s.charAt(i) != s.charAt(right) && s.charAt(right) != s.charAt(left)){\\n                uniqueSubstrings++;\\n            }\\n            left++;\\n            right++;\\n        }\\n        return uniqueSubstrings;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1715117,
                "title": "sliding-window-using-map",
                "content": "\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3)\\n        {\\n            return 0; //edge case\\n        }\\n        map<char,int> mp;\\n        int i=0,j=0,ans=0;\\n\\t\\t\\n        while(j<s.size())\\n        {\\n            mp[s[j]]++;\\n\\t\\t\\t//if the window size is less than 3 slide j only\\n            if(j-i+1<3)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1==3)\\n            {\\n\\t\\t\\t    // when window size is hit check if there are 3 distinct elements or not in the map\\n                if(mp.size()==3)\\n                {\\n                    ans++;\\n                }\\n\\t\\t\\t\\t//after checking, slide the window \\n\\t\\t\\t\\t//decrement the value of the first element in the window in the map\\n                mp[s[i]]--;\\n\\t\\t\\t\\t//if the value becomes zero, remove the element from the map\\n                if(mp[s[i]]==0)\\n                {\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3)\\n        {\\n            return 0; //edge case\\n        }\\n        map<char,int> mp;\\n        int i=0,j=0,ans=0;\\n\\t\\t\\n        while(j<s.size())\\n        {\\n            mp[s[j]]++;\\n\\t\\t\\t//if the window size is less than 3 slide j only\\n            if(j-i+1<3)\\n            {\\n                j++;\\n            }\\n            else if(j-i+1==3)\\n            {\\n\\t\\t\\t    // when window size is hit check if there are 3 distinct elements or not in the map\\n                if(mp.size()==3)\\n                {\\n                    ans++;\\n                }\\n\\t\\t\\t\\t//after checking, slide the window \\n\\t\\t\\t\\t//decrement the value of the first element in the window in the map\\n                mp[s[i]]--;\\n\\t\\t\\t\\t//if the value becomes zero, remove the element from the map\\n                if(mp[s[i]]==0)\\n                {\\n                    mp.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n        return ans;\\n    }\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1544118,
                "title": "c-sliding-window-easy-to-understand",
                "content": "\\nclass Solution {\\npublic:\\n\\n    int countGoodSubstrings(string s) \\n    {\\n        int i=0,j=0;\\n        map<int,int> mp;\\n        int ans=0;\\n        while(j<s.size())\\n        {\\n            while(j-i+1<=3)\\n            {\\n                mp[s[j]]++;\\n                j++;\\n            }\\n            if(mp.size()==3)\\n            {\\n                    ans++;\\n            }\\n            mp[s[i]]--;\\n            if(mp[s[i]]==0)\\n            {\\n                mp.erase(s[i]);\\n            }\\n            i++;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countGoodSubstrings(string s) \\n    {\\n        int i=0,j=0;\\n        map<int,int> mp;\\n        int ans=0;\\n        while(j<s.size())\\n        {\\n            while(j-i+1<=3)\\n            {\\n                mp[s[j]]++;\\n                j++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1313305,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int c=0,n=s.size();\\n        for(int i=0;i<n-2;i++){\\n            if(s[i]!=s[i+1]&& s[i+1]!=s[i+2] && s[i]!=s[i+2])\\n                c++;\\n        } \\n        return c;\\n    }\\n };\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int c=0,n=s.size();\\n        for(int i=0;i<n-2;i++){\\n            if(s[i]!=s[i+1]&& s[i+1]!=s[i+2] && s[i]!=s[i+2])\\n                c++;\\n        } \\n        return c;\\n    }\\n };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1283969,
                "title": "java-simple-sliding-window-and-substrings",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        if(s.length() < 3)\\n            return 0;\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            if(isGoodString(s.substring(i,i+3)))\\n                count++;\\n        }\\n    return count;\\n    }\\n    \\n    private static boolean isGoodString(String substring) {\\n        int[] intArray = new int[26];\\n        for (char c:substring.toCharArray()) {\\n            intArray[c - \\'a\\']++;\\n        }\\n        for (char c:substring.toCharArray()) {\\n            if(intArray[c - \\'a\\'] > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        if(s.length() < 3)\\n            return 0;\\n        for (int i = 0; i < s.length() - 2; i++) {\\n            if(isGoodString(s.substring(i,i+3)))\\n                count++;\\n        }\\n    return count;\\n    }\\n    \\n    private static boolean isGoodString(String substring) {\\n        int[] intArray = new int[26];\\n        for (char c:substring.toCharArray()) {\\n            intArray[c - \\'a\\']++;\\n        }\\n        for (char c:substring.toCharArray()) {\\n            if(intArray[c - \\'a\\'] > 1)\\n                return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269999,
                "title": "python-sliding-window",
                "content": "If you are familiar with the sliding window technique, this problem is pretty straightforward:\\n\\n1. Maintain a dictionary that stores letters you\\'ve seen so far. The letters are the key, and hwo many times you\\'ve seen them is the value.\\n2. Have a static window of size 3 and at each increment, check if the dictionary is of length 3. If so, this means that there are 3 unique characters you\\'ve seen in this substring, so increment your result by 1.\\n3. Remove the character at the leftmost position from the dictionary, by decrementing it\\'s value in the dictionary by 1. If this value reaches 0, pop this element from the dictionary.\\n\\nSpace complexity is O(1) since our dictionary is always at or below size 3, and time complexity is O(n) since we process each character at most twice, once from the window_end, and once from windows_start. \\n\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        seen = {}\\n        window_start = 0\\n        res = 0\\n        for window_end in range(len(s)):\\n            if s[window_end] not in seen:\\n                seen[s[window_end]] = 0\\n            seen[s[window_end]] += 1\\n            if window_end < 2:\\n                continue\\n            elif window_end == 2:\\n                if len(seen) == 3:\\n                    res += 1\\n            else:\\n                seen[s[window_start]] -= 1\\n                if seen[s[window_start]] == 0:\\n                    seen.pop(s[window_start])\\n                if len(seen) == 3:\\n                    res += 1\\n                window_start += 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        seen = {}\\n        window_start = 0\\n        res = 0\\n        for window_end in range(len(s)):\\n            if s[window_end] not in seen:\\n                seen[s[window_end]] = 0\\n            seen[s[window_end]] += 1\\n            if window_end < 2:\\n                continue\\n            elif window_end == 2:\\n                if len(seen) == 3:\\n                    res += 1\\n            else:\\n                seen[s[window_start]] -= 1\\n                if seen[s[window_start]] == 0:\\n                    seen.pop(s[window_start])\\n                if len(seen) == 3:\\n                    res += 1\\n                window_start += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1266224,
                "title": "c-easy-solution-o-n-time-o-1-space-0ms-solution",
                "content": "```\\n//if we observe clearly if a character repeats then they must be either adjacent or they must be at the end of the substring of length 3\\n//we use this to check if characters are repeated and if not we will increment the count\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int res=0;\\n        int i=0;\\n        int j=0;\\n        while(j<s.length())\\n        {\\n            if(j-i+1==3)\\n            {\\n                //check if a char is repeated\\n                if(s[i]==s[i+1] || s[j]==s[j-1] || s[i]==s[j])\\n                {\\n                    //char repeated\\n                }\\n                else{\\n                    res++;\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n**Please upvote if this helps :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n//if we observe clearly if a character repeats then they must be either adjacent or they must be at the end of the substring of length 3\\n//we use this to check if characters are repeated and if not we will increment the count\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int res=0;\\n        int i=0;\\n        int j=0;\\n        while(j<s.length())\\n        {\\n            if(j-i+1==3)\\n            {\\n                //check if a char is repeated\\n                if(s[i]==s[i+1] || s[j]==s[j-1] || s[i]==s[j])\\n                {\\n                    //char repeated\\n                }\\n                else{\\n                    res++;\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1250624,
                "title": "using-queue-approach-in-c-100-beat",
                "content": "\\'\\'\\'class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        queue<int> q;\\n        int ct=0;\\n        for(int i=0;i<s.size();i++){\\n            if(q.empty()){\\n               q.push(s[i]);\\n            }else{\\n               if(q.back()==s[i]){\\n                   while(q.empty()==false) q.pop();\\n                   q.push(s[i]);\\n               }else{\\n                   q.push(s[i]);\\n               }\\n            }\\n            if(q.size()==3){\\n                if(q.front()!=q.back()) ct++;\\n                q.pop();\\n            }\\n        }\\n        return ct;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        queue<int> q;\\n        int ct=0;\\n        for(int i=0;i<s.size();i++){\\n            if(q.empty()){\\n               q.push(s[i]);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1248025,
                "title": "o-n-c-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\t\\n        int n=s.length(); // length of string\\n        bool m[26]={0}; //bool array to mark which letters are present\\n        int i,j,ans=0;\\n        \\n        for(i=0;i<n-2;i++)\\n        {\\n            for(j=0;j<26;j++)// re-initialising all the letters as absent\\n\\t\\t\\t\\tm[j]=false;\\n\\t\\t\\t\\n            for(j=0;j<3;j++)\\n            {\\n                char c=s[i+j]-\\'a\\';\\n                if(m[c])// if c has already occured\\n                    break;\\n                else\\n                    m[c]=1; // mark c as present in the substring s[i...i+2]\\n            }\\n\\t\\t\\tif(j==3)ans++; // if we successfully reach end of substring means no duplicate\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\t\\n        int n=s.length(); // length of string\\n        bool m[26]={0}; //bool array to mark which letters are present\\n        int i,j,ans=0;\\n        \\n        for(i=0;i<n-2;i++)\\n        {\\n            for(j=0;j<26;j++)// re-initialising all the letters as absent\\n\\t\\t\\t\\tm[j]=false;\\n\\t\\t\\t\\n            for(j=0;j<3;j++)\\n            {\\n                char c=s[i+j]-\\'a\\';\\n                if(m[c])// if c has already occured\\n                    break;\\n                else\\n                    m[c]=1; // mark c as present in the substring s[i...i+2]\\n            }\\n\\t\\t\\tif(j==3)ans++; // if we successfully reach end of substring means no duplicate\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245999,
                "title": "python-one-liner",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:            \\n        return sum(s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2] for i in range(2, len(s)))\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:            \\n        return sum(s[i] != s[i-1] and s[i] != s[i-2] and s[i-1] != s[i-2] for i in range(2, len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238755,
                "title": "sliding-window-technique-java-explained-with-comments",
                "content": "\\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int windowStart = 0;\\n        int count = 0;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\\n            char rightChar = s.charAt(windowEnd);\\n\\t\\t\\t// putting each character into map\\n            map.put(rightChar, map.getOrDefault(rightChar, 0) + 1);\\n\\t\\t\\t// if at any point in time, the size of map becomes greater than 3\\n            while(map.size() >= 3) {\\n\\t\\t\\t\\t/* first check, if the current length of our window is 3\\n\\t\\t\\t\\t   length is 3, we are going to increment count and break for the current window. */\\n                if ((windowEnd - windowStart + 1) == 3) {\\n                    count++;\\n                    break;\\n                }\\n                else {\\n\\t\\t\\t\\t\\t/* otherwise, take character from left side of the window and start decrementing its\\n\\t\\t\\t\\t\\tfrequency from the map. Decrementing means, we are not considering this element \\n\\t\\t\\t\\t\\tin our window. And, if its frequency becomes zero, we\\'ll remove it from the map. */\\n                    char leftChar = s.charAt(windowStart);\\n                    map.put(leftChar, map.get(leftChar) - 1);\\n                    if(map.get(leftChar) == 0) {\\n                        map.remove(leftChar);\\n                    }\\n                    windowStart++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        int windowStart = 0;\\n        int count = 0;\\n        Map<Character, Integer> map = new HashMap<>();\\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\\n            char rightChar = s.charAt(windowEnd);\\n\\t\\t\\t// putting each character into map\\n            map.put(rightChar, map.getOrDefault(rightChar, 0) + 1);\\n\\t\\t\\t// if at any point in time, the size of map becomes greater than 3\\n            while(map.size() >= 3) {\\n\\t\\t\\t\\t/* first check, if the current length of our window is 3\\n\\t\\t\\t\\t   length is 3, we are going to increment count and break for the current window. */\\n                if ((windowEnd - windowStart + 1) == 3) {\\n                    count++;\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4041220,
                "title": "java-solution-tc-0ms-beats-100",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n\\nint count = 0;\\n for(int i=2;i<s.length();i++){\\n                char a = s.charAt(i);\\n                char b = s.charAt(i-1);\\n                char c = s.charAt(i-2);\\n                if(a != b && a != c  && b != c)\\n                   count++;\\n }\\n return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n\\nint count = 0;\\n for(int i=2;i<s.length();i++){\\n                char a = s.charAt(i);\\n                char b = s.charAt(i-1);\\n                char c = s.charAt(i-2);\\n                if(a != b && a != c  && b != c)\\n                   count++;\\n }\\n return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3808878,
                "title": "optimal-sliding-window-o-n",
                "content": "# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        if len(s) < 3:\\n            return 0\\n        a = s[0]\\n        b = s[1]\\n        c = s[2]\\n        count = int(a != b and b !=c and c != a)\\n\\n        for i in range(3, len(s)):\\n            a = b\\n            b = c\\n            c = s[i]\\n            count += int(a != b and b !=c and c != a)\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        if len(s) < 3:\\n            return 0\\n        a = s[0]\\n        b = s[1]\\n        c = s[2]\\n        count = int(a != b and b !=c and c != a)\\n\\n        for i in range(3, len(s)):\\n            a = b\\n            b = c\\n            c = s[i]\\n            count += int(a != b and b !=c and c != a)\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3421386,
                "title": "c",
                "content": "# Intuition\\nBecause I don\\'t know which character to remove from set when set length less than 3, so when it is greater than 3, i will re-check whole set \\nex : \"zyyyy\"\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nwhen set length greater than 3, i will re-check whole set \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution\\n        {\\n            public int CountGoodSubstrings(string s)\\n            {\\n                if(s.Length < 3) return 0;\\n                int result = 0;\\n                HashSet<char> record = new HashSet<char>();                \\n\\n                for (int i = 0; i<s.Length ;i++)\\n                {\\n                    record.Add(s[i]);\\n                    if (record.Count >= 3)\\n                    {\\n                        record.Clear();\\n                        for (int j = i-2; j <= i; j++)\\n                            record.Add(s[j]);\\n                    }\\n\\n                    if (record.Count == 3)\\n                        result += 1;\\n                }\\n                return result;\\n            }\\n        }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n        {\\n            public int CountGoodSubstrings(string s)\\n            {\\n                if(s.Length < 3) return 0;\\n                int result = 0;\\n                HashSet<char> record = new HashSet<char>();                \\n\\n                for (int i = 0; i<s.Length ;i++)\\n                {\\n                    record.Add(s[i]);\\n                    if (record.Count >= 3)\\n                    {\\n                        record.Clear();\\n                        for (int j = i-2; j <= i; j++)\\n                            record.Add(s[j]);\\n                    }\\n\\n                    if (record.Count == 3)\\n                        result += 1;\\n                }\\n                return result;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3311957,
                "title": "c-easy-brute-force-approach-for-loop-only-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\njai shree ram\\nupvote if you find it helpfull\\nif any problem ask it in comment section..\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n     int ans = 0;\\n      //check if the length is less than 3...\\n        if(s.length() < 3)\\n         return 0;\\n        //simple for loop check the 1 character with 2 and 1 with 3 and 2 with the 3 ..with if condition if it is true add it to ans..\\n        for(int i = 0; i<=s.length()-3; i++) {\\n            if(s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2])\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n     int ans = 0;\\n      //check if the length is less than 3...\\n        if(s.length() < 3)\\n         return 0;\\n        //simple for loop check the 1 character with 2 and 1 with 3 and 2 with the 3 ..with if condition if it is true add it to ans..\\n        for(int i = 0; i<=s.length()-3; i++) {\\n            if(s[i] != s[i+1] && s[i] != s[i+2] && s[i+1] != s[i+2])\\n                ans++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3034139,
                "title": "easiest-8-lines-beginner-friendly-solution",
                "content": "\\n\\n\\n# Complexity\\n- Time complexity:\\no(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n    int count=0;\\n\\n    for(int i=0;i<s.length()-2;i++){\\n\\n    String temp=s.substring(i,i+3);\\n\\n    if(temp.charAt(0)!=temp.charAt(1)&&temp.charAt(0)!=temp.charAt(2)&&temp.charAt(1)!=temp.charAt(2)){\\n        count++;\\n    }\\n\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n    int count=0;\\n\\n    for(int i=0;i<s.length()-2;i++){\\n\\n    String temp=s.substring(i,i+3);\\n\\n    if(temp.charAt(0)!=temp.charAt(1)&&temp.charAt(0)!=temp.charAt(2)&&temp.charAt(1)!=temp.charAt(2)){\\n        count++;\\n    }\\n\\n    }\\n\\n    return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2744224,
                "title": "python-faster-than-94-of-submissions-simple-solution",
                "content": "```\\nclass Solution(object):\\n    def countGoodSubstrings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(s)-2):\\n            q = s[i:i+4]\\n            if q[0] != q[1] and q[0] != q[2] and q[2] != q[1]:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def countGoodSubstrings(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(s)-2):\\n            q = s[i:i+4]\\n            if q[0] != q[1] and q[0] != q[2] and q[2] != q[1]:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2742324,
                "title": "sliding-window-here-we-count-the-substrings-of-size-3-having-all-unique-characters",
                "content": "```\\nHere we have to calculate the number of substrings of size 3 having all unique characters .\\nSo this question basically uses the concept of sliding window of fixed size which we will slide over the string . \\nWe will use map to store the frequency of characters in the window . \\nAll the characaters are unique in the particular window if current map size is equal to window length (j-i+1) . here i denotes the starting index of window \\nand j denotes the ending index of window . \\n\\nint countGoodSubstrings(string s) \\n    {\\n        int n = s.size(); \\n        int k = 3; // Required window size \\n        \\n        unordered_map<char,int> mp;\\n        int i=0,j=0; // i is starting index of window and j is ending index of window\\n        int count = 0; // Subarrays count\\n        \\n        while(j<n)\\n        {\\n            mp[s[j]]++; // Adding the frequency of jth character in map\\n            \\n            if(j-i+1<3) // If window size of 3 is not achieved\\n                j++;\\n            \\n            else if(j-i+1==3)  // If window size of 3 is achieved\\n            {\\n                if(mp.size()==(j-i+1)) // Checking if all the characters in window are unique\\n                {\\n                    count += 1;\\n                    \\n                    mp[s[i]]--; // Before sliding the window make sure to decrease the count of starting index character of window \\n                    if(mp[s[i]]==0) \\n                        mp.erase(s[i]);\\n                    \\n\\t\\t\\t\\t\\t// Sliding the window\\n                    i++; \\n                    j++;\\n                    \\n                }\\n                \\n                else if(mp.size()<(j-i+1)) // // if all the characters in window are not unique\\n                {\\n                    while(mp.size()<(j-i+1) && i<=j) // Removing the ith character from window until we have removed all the duplicate characters\\n                    {\\n                        mp[s[i]]--;\\n                        if(mp[s[i]]==0)\\n                            mp.erase(s[i]);\\n                        i++;\\n                    }\\n                    j++;\\n                }                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nHere we have to calculate the number of substrings of size 3 having all unique characters .\\nSo this question basically uses the concept of sliding window of fixed size which we will slide over the string . \\nWe will use map to store the frequency of characters in the window . \\nAll the characaters are unique in the particular window if current map size is equal to window length (j-i+1) . here i denotes the starting index of window \\nand j denotes the ending index of window . \\n\\nint countGoodSubstrings(string s) \\n    {\\n        int n = s.size(); \\n        int k = 3; // Required window size \\n        \\n        unordered_map<char,int> mp;\\n        int i=0,j=0; // i is starting index of window and j is ending index of window\\n        int count = 0; // Subarrays count\\n        \\n        while(j<n)\\n        {\\n            mp[s[j]]++; // Adding the frequency of jth character in map\\n            \\n            if(j-i+1<3) // If window size of 3 is not achieved\\n                j++;\\n            \\n            else if(j-i+1==3)  // If window size of 3 is achieved\\n            {\\n                if(mp.size()==(j-i+1)) // Checking if all the characters in window are unique\\n                {\\n                    count += 1;\\n                    \\n                    mp[s[i]]--; // Before sliding the window make sure to decrease the count of starting index character of window \\n                    if(mp[s[i]]==0) \\n                        mp.erase(s[i]);\\n                    \\n\\t\\t\\t\\t\\t// Sliding the window\\n                    i++; \\n                    j++;\\n                    \\n                }\\n                \\n                else if(mp.size()<(j-i+1)) // // if all the characters in window are not unique\\n                {\\n                    while(mp.size()<(j-i+1) && i<=j) // Removing the ith character from window until we have removed all the duplicate characters\\n                    {\\n                        mp[s[i]]--;\\n                        if(mp[s[i]]==0)\\n                            mp.erase(s[i]);\\n                        i++;\\n                    }\\n                    j++;\\n                }                \\n            }\\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2664467,
                "title": "c-100-faster-than-all-easy",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string n) {\\n        int s=n.size();\\n        int a=0;\\n        for(int i=1;i<s-1;i++)\\n        {\\n            if(n[i]!=n[i-1]&&n[i]!=n[i+1]&&n[i-1]!=n[i+1])\\n            {\\n                a++;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string n) {\\n        int s=n.size();\\n        int a=0;\\n        for(int i=1;i<s-1;i++)\\n        {\\n            if(n[i]!=n[i-1]&&n[i]!=n[i+1]&&n[i-1]!=n[i+1])\\n            {\\n                a++;\\n            }\\n        }\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585933,
                "title": "c-sliding-window-approach-works-for-any-value-of-k",
                "content": "**For any value of k : **\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size(),count=0,k=3;\\n        if(n<k) return count;\\n        unordered_map<char,int>m;\\n        for(int i=0;i<k;i++){\\n            m[s[i]]++;\\n        }\\n        if(m.size()==k) count++;\\n        for(int j=k;j<n;j++){\\n            m[s[j-k]]--;\\n            m[s[j]]++;\\n            if(m[s[j-k]]==0) m.erase(s[j-k]);\\n            if(m.size()==k) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\nFor k=3;\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size(),count=0;\\n        if(n<3) return count;\\n        unordered_map<char,int>m;\\n        for(int i=0;i<3;i++){   //in this question k=3;\\n            m[s[i]]++;\\n        }\\n        if(m.size()==3) count++;\\n        for(int j=3;j<n;j++){\\n            m[s[j-3]]--;\\n            m[s[j]]++;\\n            if(m[s[j-3]]==0) m.erase(s[j-3]);\\n            if(m.size()==3) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size(),count=0,k=3;\\n        if(n<k) return count;\\n        unordered_map<char,int>m;\\n        for(int i=0;i<k;i++){\\n            m[s[i]]++;\\n        }\\n        if(m.size()==k) count++;\\n        for(int j=k;j<n;j++){\\n            m[s[j-k]]--;\\n            m[s[j]]++;\\n            if(m[s[j-k]]==0) m.erase(s[j-k]);\\n            if(m.size()==k) count++;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size(),count=0;\\n        if(n<3) return count;\\n        unordered_map<char,int>m;\\n        for(int i=0;i<3;i++){   //in this question k=3;\\n            m[s[i]]++;\\n        }\\n        if(m.size()==3) count++;\\n        for(int j=3;j<n;j++){\\n            m[s[j-3]]--;\\n            m[s[j]]++;\\n            if(m[s[j-3]]==0) m.erase(s[j-3]);\\n            if(m.size()==3) count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357175,
                "title": "short-javascript-solution-using-a-set-object-and-the-sliding-window-technique",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nconst countGoodSubstrings = s => {\\n    let count = 0;\\n\\n    for (let i = 0; i < s.length - 2; i++) {\\n        let window = s.substring(i, 3 + i)\\n        if (new Set(window.split(\\'\\')).size === 3) count++\\n    }\\n\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nconst countGoodSubstrings = s => {\\n    let count = 0;\\n\\n    for (let i = 0; i < s.length - 2; i++) {\\n        let window = s.substring(i, 3 + i)\\n        if (new Set(window.split(\\'\\')).size === 3) count++\\n    }\\n\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2258625,
                "title": "golang-easy-solution-0ms-100",
                "content": "Runtime: 0 ms, faster than 100.00% of Go online submissions for Substrings of Size Three with Distinct Characters.\\nMemory Usage: 1.9 MB, less than 58.82% of Go online submissions for Substrings of Size Three with Distinct Characters.\\n\\n```\\nfunc countGoodSubstrings(s string) int {\\n    if len(s) <= 2 {\\n        return 0\\n    }\\n    ans := 0\\n    for i := 0; i < len(s) - 2; i++ {\\n        tmp := s[i:i+3]\\n        if tmp[0] != tmp[1] && tmp[0] != tmp[2] && tmp[1] != tmp[2] {\\n            ans++\\n        }\\n    } \\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countGoodSubstrings(s string) int {\\n    if len(s) <= 2 {\\n        return 0\\n    }\\n    ans := 0\\n    for i := 0; i < len(s) - 2; i++ {\\n        tmp := s[i:i+3]\\n        if tmp[0] != tmp[1] && tmp[0] != tmp[2] && tmp[1] != tmp[2] {\\n            ans++\\n        }\\n    } \\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2114971,
                "title": "javascript-sliding-window",
                "content": "Sliding Window is a good solution for substring problems. In this solution the window or subset has a maximum length (3) but is dynamic in that it grows and shrinks.\\n\\nTwo pointers are used to define the boundary of the subset (window). The left and right pointers are `left` and `i`, respectively.\\n\\n`Set` is used to store the values of the subset so we can check if a charcater already exists. When a character exists in the `Set`, we remove all the characters from the left (using our left pointer) until the duplicate character has been removed. The left pointer will now be at the start of our new subset.\\n\\nWhen the `Set` reaches a size of 3, the `count` is incremented by one, the starting character in the subset is removed and the left pointer incremented by 1.\\n\\n``` js\\nvar countGoodSubstrings = function (s) {\\n  let left = 0,\\n    count = 0,\\n    set = new Set();\\n\\n  for (let i = 0; i < s.length; i++) {\\n    while (set.has(s[i])) {\\n      set.delete(s[left]);\\n      left++;\\n    }\\n\\n    set.add(s[i]);\\n\\n    if (set.size === 3) {\\n      count++;\\n      set.delete(s[left]);\\n      left++;\\n    }\\n  }\\n\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "``` js\\nvar countGoodSubstrings = function (s) {\\n  let left = 0,\\n    count = 0,\\n    set = new Set();\\n\\n  for (let i = 0; i < s.length; i++) {\\n    while (set.has(s[i])) {\\n      set.delete(s[left]);\\n      left++;\\n    }\\n\\n    set.add(s[i]);\\n\\n    if (set.size === 3) {\\n      count++;\\n      set.delete(s[left]);\\n      left++;\\n    }\\n  }\\n\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2106937,
                "title": "java-two-easy-solutions-with-explanation-o-n-brute-force",
                "content": "**Method 1:** **Brute Force Solution:**\\n1. Find the substring of length = 3\\n2. Store the substring in set -- set will eliminate duplicate characters --meaning 3 distinct characters in substring\\n3. If set.size() == 3, increase the count \\n4.  Return the count \\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n     int k = 3;\\n     int count = 0;   \\n     int kindex = k - 1;   \\n     String sub = new String();  \\n     for(int i = kindex; i < s.length(); i++){\\n        Set<Character> set = new HashSet<>(); \\n        sub = s.substring(i - kindex, i + 1);\\n        for(int j = 0 ; j < sub.length(); j++) \\n            set.add(sub.charAt(j));   \\n        if(set.size() == 3) count = count + 1; \\n     }  \\n       return count;     \\n    }\\n}\\n```\\n\\n**Method 2: O(N) solution using ArrayList - Approach - Sliding Window**\\n1. SlidingWindow length = 3\\n2. Add character in the list. If list size is greater than slidingwindow length, then remove the first element from the list\\n3. If list size is equal to 3, then check if all the elements are distinct, if yes increase the count\\n4. Return the count\\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n      ArrayList<Character> list = new ArrayList<>();\\n      int slidingWindowSize = 3;  \\n      int count = 0;  \\n      for(int i = 0; i < s.length(); i++){\\n          list.add(s.charAt(i));\\n          if(list.size() > slidingWindowSize){ \\n              list.remove(0);\\n          }   \\n          if(list.size() == 3) {\\n              if(list.get(0) != list.get(1) && list.get(0) != list.get(2) && list.get(1) != list.get(2)) \\n                  count = count + 1;\\n          }\\n      }\\n     return count;  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n     int k = 3;\\n     int count = 0;   \\n     int kindex = k - 1;   \\n     String sub = new String();  \\n     for(int i = kindex; i < s.length(); i++){\\n        Set<Character> set = new HashSet<>(); \\n        sub = s.substring(i - kindex, i + 1);\\n        for(int j = 0 ; j < sub.length(); j++) \\n            set.add(sub.charAt(j));   \\n        if(set.size() == 3) count = count + 1; \\n     }  \\n       return count;     \\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n      ArrayList<Character> list = new ArrayList<>();\\n      int slidingWindowSize = 3;  \\n      int count = 0;  \\n      for(int i = 0; i < s.length(); i++){\\n          list.add(s.charAt(i));\\n          if(list.size() > slidingWindowSize){ \\n              list.remove(0);\\n          }   \\n          if(list.size() == 3) {\\n              if(list.get(0) != list.get(1) && list.get(0) != list.get(2) && list.get(1) != list.get(2)) \\n                  count = count + 1;\\n          }\\n      }\\n     return count;  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2041906,
                "title": "1876-substrings-of-size-three-with-distinct-characters",
                "content": "```\\nclass Solution {\\npublic:\\n    int check(int left, int right, string& s){\\n        unordered_set<int> st;\\n        for(int i=left; i<=right; i++){\\n            st.insert(s[i]);\\n        }\\n        if(st.size()==right-left+1)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n    \\n    int countGoodSubstrings(string s) {\\n        if(s.length()<3)\\n            return 0;\\n        int count=0;\\n        int i=0;\\n        int k=3;\\n        int j=k-1;\\n        if(check(i,j,s))\\n            count++;\\n        while(j<s.length()-1)\\n        {\\n            i++;\\n            j++;\\n            if(check(i,j,s))\\n                    count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int check(int left, int right, string& s){\\n        unordered_set<int> st;\\n        for(int i=left; i<=right; i++){\\n            st.insert(s[i]);\\n        }\\n        if(st.size()==right-left+1)\\n            return 1;\\n        else\\n            return 0;\\n    }\\n    \\n    int countGoodSubstrings(string s) {\\n        if(s.length()<3)\\n            return 0;\\n        int count=0;\\n        int i=0;\\n        int k=3;\\n        int j=k-1;\\n        if(check(i,j,s))\\n            count++;\\n        while(j<s.length()-1)\\n        {\\n            i++;\\n            j++;\\n            if(check(i,j,s))\\n                    count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982289,
                "title": "c-solution-0ms",
                "content": "\\n        int goodStrCnt = 0, n = s.size();\\n        for(int i = 0; i < n-2 ; i++){\\n            if((s[i]^s[i+1]) == 0) continue;\\n            if((s[i+2]^s[i+1]) == 0)continue;\\n            if((s[i+2]^s[i]) == 0) continue;\\n            goodStrCnt++;\\n        }\\n        return goodStrCnt;\\n    }",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "\\n        int goodStrCnt = 0, n = s.size();\\n        for(int i = 0; i < n-2 ; i++){\\n            if((s[i]^s[i+1]) == 0) continue;\\n            if((s[i+2]^s[i+1]) == 0)continue;\\n            if((s[i+2]^s[i]) == 0) continue;\\n            goodStrCnt++;\\n        }\\n        return goodStrCnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1913754,
                "title": "c-faster-than-100",
                "content": "```\\n int n = s.size();\\n        int ans = 0 ;\\n        int i  ;\\n        for(i= 0 ; i < n-2 ; i++){\\n            if(s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\\n                continue;\\n            ans++;\\n        }\\n        return ans;",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n int n = s.size();\\n        int ans = 0 ;\\n        int i  ;\\n        for(i= 0 ; i < n-2 ; i++){\\n            if(s[i] == s[i+1] || s[i+1] == s[i+2] || s[i] == s[i+2])\\n                continue;\\n            ans++;\\n        }\\n        return ans;",
                "codeTag": "Unknown"
            },
            {
                "id": 1855886,
                "title": "c-easy-solution-sliding-window-with-comments-explained",
                "content": "\\tint check(int i,int j,string& s)\\n    {\\n        set<int>st;//checking whether the selected part of string is duplicate or not\\n        for(int k=i;k<=j;k++)\\n        {\\n            st.insert(s[k]);\\n        }\\n        if(st.size()==3)\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n    int countGoodSubstrings(string s)\\n    {\\n        int right=0;\\n        int left=0;\\n        int ans=0;\\n        while(right<s.length())\\n        {\\n            if(right-left==2)//taking the selected part of string\\n            {\\n                ans+=check(left,right,s);//sending the index to check\\n                left+=1;\\n            }\\n            right++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "\\tint check(int i,int j,string& s)\\n    {\\n        set<int>st;//checking whether the selected part of string is duplicate or not\\n        for(int k=i;k<=j;k++)\\n        {\\n            st.insert(s[k]);\\n        }\\n        if(st.size()==3)\\n        {\\n            return 1;\\n        }\\n        else\\n        {\\n            return 0;\\n        }\\n    }\\n    int countGoodSubstrings(string s)\\n    {\\n        int right=0;\\n        int left=0;\\n        int ans=0;\\n        while(right<s.length())\\n        {\\n            if(right-left==2)//taking the selected part of string\\n            {\\n                ans+=check(left,right,s);//sending the index to check\\n                left+=1;\\n            }\\n            right++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1815806,
                "title": "c-simple-and-clean-solution-o-n-tc-o-1-sc",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if (s.size() < 3) return 0;\\n        \\n        int res = 0;\\n        for (int i = 0; i < s.size()-2; i++) {\\n            if (s[i] != s[i+1] && s[i+1] != s[i+2] && s[i] != s[i+2]) res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if (s.size() < 3) return 0;\\n        \\n        int res = 0;\\n        for (int i = 0; i < s.size()-2; i++) {\\n            if (s[i] != s[i+1] && s[i+1] != s[i+2] && s[i] != s[i+2]) res++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1742948,
                "title": "c-100-faster-solution",
                "content": "* j-i+1=window size\\n* \\n```\\nint countGoodSubstrings(string s) {\\n        unordered_map<char,int> mp;\\n        \\n        int i=0,j=0;\\n        int count=0;\\n        while(j<s.size())\\n        {\\n            mp[s[j]]++;\\n            \\n            if(j-i+1==3)\\n            {\\n                if(mp.size()==3)\\n                    count++;\\n                \\n                mp[s[i]]--;\\n                if(mp[s[i]]==0)\\n                    mp.erase(s[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nint countGoodSubstrings(string s) {\\n        unordered_map<char,int> mp;\\n        \\n        int i=0,j=0;\\n        int count=0;\\n        while(j<s.size())\\n        {\\n            mp[s[j]]++;\\n            \\n            if(j-i+1==3)\\n            {\\n                if(mp.size()==3)\\n                    count++;\\n                \\n                mp[s[i]]--;\\n                if(mp[s[i]]==0)\\n                    mp.erase(s[i]);\\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1729504,
                "title": "c-sliding-window-with-clear-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int low=0,high=2,count=0;  // create the window size as 3\\n        unordered_set <char> ch;\\n        while(high<s.size())  // iterate till high<=size\\n        {\\n            for(int i=low;i<=high;++i)  //push the characters into set\\n                ch.insert(s[i]);\\n            if(ch.size()==3)    // unique elements only if set size == 3\\n                count++;\\n            ch.clear();    // clear the set\\n            low++; high++;  // change the window\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int low=0,high=2,count=0;  // create the window size as 3\\n        unordered_set <char> ch;\\n        while(high<s.size())  // iterate till high<=size\\n        {\\n            for(int i=low;i<=high;++i)  //push the characters into set\\n                ch.insert(s[i]);\\n            if(ch.size()==3)    // unique elements only if set size == 3\\n                count++;\\n            ch.clear();    // clear the set\\n            low++; high++;  // change the window\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706220,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        start=0\\n        end=start+3\\n        count=0\\n        while(end<=len(s)):\\n            if len(s[start:end])==len(set(s[start:end])):\\n                count+=1\\n            start+=1\\n            end+=1\\n        return count",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        start=0\\n        end=start+3\\n        count=0\\n        while(end<=len(s)):\\n            if len(s[start:end])==len(set(s[start:end])):\\n                count+=1\\n            start+=1\\n            end+=1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1689404,
                "title": "c-o-n-solution-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.length(), ans=0;\\n        for(int i=1;i<n-1;i++){\\n            set<char> st = {s[i],s[i-1],s[i+1]};\\n            if(st.size()==3)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.length(), ans=0;\\n        for(int i=1;i<n-1;i++){\\n            set<char> st = {s[i],s[i-1],s[i+1]};\\n            if(st.size()==3)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1679788,
                "title": "c-simplest-solution-0ms",
                "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int l=s.size();int cnt=0;\\n        for(int i=0;i<l-2;i++)\\n        {\\n         if((s[i]!=s[i+1])&&(s[i+1]!=s[i+2])&&(s[i]!=s[i+2]))\\n             cnt++;\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int l=s.size();int cnt=0;\\n        for(int i=0;i<l-2;i++)\\n        {\\n         if((s[i]!=s[i+1])&&(s[i+1]!=s[i+2])&&(s[i]!=s[i+2]))\\n             cnt++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1615243,
                "title": "100-fast-c-easy-understandable-solution-using-hash-and-sliding-window-technique",
                "content": "```\\nint countGoodSubstrings(string arr) {\\n        int i, j, count = 0,max_count = 0, k = 3;\\n        unordered_map<int, int> m;\\n\\t\\t// first taking an map with first three variable\\n        for (i = 0; i < k; i++)\\n        {\\n            if (m.find(arr[i]) == m.end())\\n                m[arr[i]] = 1;\\n            else\\n                m[arr[i]]++;\\n        }\\n        count = m.size();\\n        // then checking the size of the map if total size is 3 that means all elements are different  in that window\\n\\t\\tif(count == k){\\n            max_count++;\\n        }\\n        // sliding the window one by one removing the last element and its count and adding the very next element and again checking the count if its three then increasing our result .  \\n        for (i = k; i < (int)(arr.size()); i++)\\n        {\\n            if (m.find(arr[i]) == m.end())\\n                m[arr[i]] = 1;\\n            else\\n                m[arr[i]]++;\\n            if (m.find(arr[i - k]) != m.end())\\n            {\\n                if (m[arr[i - k]] == 1)\\n                    m.erase(arr[i - k]);\\n                else\\n                    m[arr[i - k]]--;\\n            }\\n            count = m.size();\\n            if(count == k){\\n                max_count++;\\n            }\\n        }\\n        return max_count;\\n    }\\n\\t// Hope it helps \\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint countGoodSubstrings(string arr) {\\n        int i, j, count = 0,max_count = 0, k = 3;\\n        unordered_map<int, int> m;\\n\\t\\t// first taking an map with first three variable\\n        for (i = 0; i < k; i++)\\n        {\\n            if (m.find(arr[i]) == m.end())\\n                m[arr[i]] = 1;\\n            else\\n                m[arr[i]]++;\\n        }\\n        count = m.size();\\n        // then checking the size of the map if total size is 3 that means all elements are different  in that window\\n\\t\\tif(count == k){\\n            max_count++;\\n        }\\n        // sliding the window one by one removing the last element and its count and adding the very next element and again checking the count if its three then increasing our result .  \\n        for (i = k; i < (int)(arr.size()); i++)\\n        {\\n            if (m.find(arr[i]) == m.end())\\n                m[arr[i]] = 1;\\n            else\\n                m[arr[i]]++;\\n            if (m.find(arr[i - k]) != m.end())\\n            {\\n                if (m[arr[i - k]] == 1)\\n                    m.erase(arr[i - k]);\\n                else\\n                    m[arr[i - k]]--;\\n            }\\n            count = m.size();\\n            if(count == k){\\n                max_count++;\\n            }\\n        }\\n        return max_count;\\n    }\\n\\t// Hope it helps \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1607378,
                "title": "easy-solution-in-c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) \\n    {\\n        int n = s.size();\\n        int result = 0;\\n        for (int i = 0; i < n-2; i++)\\n        {\\n            if (s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2])\\n            {\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) \\n    {\\n        int n = s.size();\\n        int result = 0;\\n        for (int i = 0; i < n-2; i++)\\n        {\\n            if (s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2])\\n            {\\n                result++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1596778,
                "title": "java-sliding-window-o-n",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int windowStart = 0;\\n        int goodSubStrCount = 0;\\n        \\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\\n            char ch = s.charAt(windowEnd);\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n            if((windowEnd - windowStart + 1) == 3) {\\n                if(map.size() == 3)\\n                    goodSubStrCount++;\\n                \\n                char sch = s.charAt(windowStart++);\\n                map.put(sch, map.get(sch) - 1);\\n                if(map.get(sch) == 0)\\n                    map.remove(sch);\\n            }\\n        }\\n        \\n        return goodSubStrCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int windowStart = 0;\\n        int goodSubStrCount = 0;\\n        \\n        for(int windowEnd = 0; windowEnd < s.length(); windowEnd++) {\\n            char ch = s.charAt(windowEnd);\\n            map.put(ch, map.getOrDefault(ch, 0) + 1);\\n            if((windowEnd - windowStart + 1) == 3) {\\n                if(map.size() == 3)\\n                    goodSubStrCount++;\\n                \\n                char sch = s.charAt(windowStart++);\\n                map.put(sch, map.get(sch) - 1);\\n                if(map.get(sch) == 0)\\n                    map.remove(sch);\\n            }\\n        }\\n        \\n        return goodSubStrCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443202,
                "title": "python-o-n-time-just-check-if-all-len-3-substrings-are-unique",
                "content": "Since we are only interested in substrings of length 3, iterate through the string and check if all characters\\nin adjacent substrings of length 3 are unique.\\n\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        ans = 0\\n        for i in range(len(s)-2):\\n            if s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2]:\\n                ans += 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        ans = 0\\n        for i in range(len(s)-2):\\n            if s[i] != s[i+1] and s[i] != s[i+2] and s[i+1] != s[i+2]:\\n                ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1421760,
                "title": "easiest-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size();\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(j<n){\\n            if(j-i+1<3){\\n                j++;\\n            }\\n            else if(j-i+1==3){\\n                if(s[i]==s[i+1] || s[j]==s[j-1] || s[i]==s[j]){\\n                    //char repeated\\n                }\\n                else\\n                    ans++;\\n                j++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.size();\\n        int i=0;\\n        int j=0;\\n        int ans=0;\\n        while(j<n){\\n            if(j-i+1<3){\\n                j++;\\n            }\\n            else if(j-i+1==3){\\n                if(s[i]==s[i+1] || s[j]==s[j-1] || s[i]==s[j]){\\n                    //char repeated\\n                }\\n                else\\n                    ans++;\\n                j++;\\n                i++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391491,
                "title": "simple-c-solution-with-0-ms-runtime",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.length();\\n        if(n<3){\\n            return 0;\\n        }\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        while(j<n-2){\\n            if(s[i]!=s[j+1] && s[i]!=s[j+2] && s[j+1]!=s[j+2]){\\n                count++;\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\nJust simply traverse over the string with window of size 3, let\\'s say you are at index i then check if element at index i-1 and i+1 are not equal or equal to element at index i.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int n=s.length();\\n        if(n<3){\\n            return 0;\\n        }\\n        int count=0;\\n        int i=0;\\n        int j=0;\\n        while(j<n-2){\\n            if(s[i]!=s[j+1] && s[i]!=s[j+2] && s[j+1]!=s[j+2]){\\n                count++;\\n                i++;\\n                j++;\\n            }else{\\n                i++;\\n                j++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1388272,
                "title": "simple-java-solution",
                "content": "class Solution {\\n\\n    public int countGoodSubstrings(String s) {\\n        if(s.length()<=2)\\n            return 0;\\n        int i,c=0;\\n        for(i=0;i<s.length()-2;i++)\\n        {\\n            if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(i+2)&&s.charAt(i)!=s.charAt(i+2))\\n                c++;\\n        }\\n        return c;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int countGoodSubstrings(String s) {\\n        if(s.length()<=2)\\n            return 0;\\n        int i,c=0;\\n        for(i=0;i<s.length()-2;i++)\\n        {\\n            if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(i+2)&&s.charAt(i)!=s.charAt(i+2))\\n                c++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1379241,
                "title": "c-hashset-approach-72ms-23mb-o-n",
                "content": "```\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n        \\n        var strArray = s.ToCharArray(0, s.Length);\\n        var strSet = new HashSet<int>();\\n        var numOfGoodSubstring = 0;\\n        \\n        for (var i = 0; i < strArray.Count(); i++)\\n        {\\n            if (i+2 < strArray.Count())\\n            {\\n                strSet.Add(strArray[i]);\\n                strSet.Add(strArray[i+1]);\\n                strSet.Add(strArray[i+2]);\\n            }            \\n            \\n            if (strSet.Count == 3)\\n            {\\n                numOfGoodSubstring++;\\n            }\\n            strSet.Clear();\\n        }\\n        \\n        return numOfGoodSubstring;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n        \\n        var strArray = s.ToCharArray(0, s.Length);\\n        var strSet = new HashSet<int>();\\n        var numOfGoodSubstring = 0;\\n        \\n        for (var i = 0; i < strArray.Count(); i++)\\n        {\\n            if (i+2 < strArray.Count())\\n            {\\n                strSet.Add(strArray[i]);\\n                strSet.Add(strArray[i+1]);\\n                strSet.Add(strArray[i+2]);\\n            }            \\n            \\n            if (strSet.Count == 3)\\n            {\\n                numOfGoodSubstring++;\\n            }\\n            strSet.Clear();\\n        }\\n        \\n        return numOfGoodSubstring;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366864,
                "title": "easy-to-understand-python3-faster-than-99-83-of-python3",
                "content": "\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        counter = 0\\n        for i in range(len(s)-2):\\n            new = s[i:i+3]\\n            if len(new) == len(set(new)):\\n                counter = counter + 1\\n                \\n        return counter\\n```\\n\\nI know it can be condensed further but it works.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        counter = 0\\n        for i in range(len(s)-2):\\n            new = s[i:i+3]\\n            if len(new) == len(set(new)):\\n                counter = counter + 1\\n                \\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1346771,
                "title": "java-clean-solution-why-people-confusing-with-i-1-i-1-all-the-jazz",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length()<3) return 0;\\n        \\n        int count = 0;\\n        for(int i=0;i+2<s.length();i++){\\n            char a = s.charAt(i);\\n            char b = s.charAt(i+1);\\n            char c = s.charAt(i+2);\\n            \\n            if(a !=b && b!=c && c!=a){\\n                count++; \\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length()<3) return 0;\\n        \\n        int count = 0;\\n        for(int i=0;i+2<s.length();i++){\\n            char a = s.charAt(i);\\n            char b = s.charAt(i+1);\\n            char c = s.charAt(i+2);\\n            \\n            if(a !=b && b!=c && c!=a){\\n                count++; \\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296008,
                "title": "kotlin-1-line",
                "content": "```\\nfun countGoodSubstrings(s: String) = s.windowed(3, 1).count { it.toSet().size == 3 }\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun countGoodSubstrings(s: String) = s.windowed(3, 1).count { it.toSet().size == 3 }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1246820,
                "title": "java-sliding-window-approach-not-so-fast-but-intuitive",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n        int res = 0, start = 0, end = 3;\\n        \\n        if(s.length() < 3){\\n            return 0;\\n        }\\n\\t        \\n\\t    HashMap<Character, Integer> map = new HashMap<>();\\n\\t        \\n\\t    for(int i = 0 ; i < 3; i++) {\\n\\t    \\t char c  = s.charAt(i);\\n\\t    \\t map.put(c, map.getOrDefault(c, 0) + 1);\\n\\t     }\\n        \\n        if(map.size() == 3) {\\n\\t    \\t\\t   res++;\\n\\t    }\\n\\t       \\n\\t    while(end<s.length()) {\\n\\t    \\tchar e = s.charAt(end);\\n\\t    \\tchar st= s.charAt(start);\\n            \\n\\t    \\tmap.put(st, map.get(st) - 1);\\n\\t    \\tif(map.get(st) == 0) {\\n\\t    \\t\\t map.remove(st);\\n\\t    \\t }\\n            \\n\\t    \\tmap.put(e, map.getOrDefault(e ,0) + 1);\\n            \\n            if(map.size() == 3) {\\n\\t    \\t\\t   res++;\\n\\t    \\t   }\\n\\t    \\t   \\n\\t    \\t start++;\\n\\t    \\t end++;\\n\\t    }\\n\\t    return res;  \\n    }",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n        int res = 0, start = 0, end = 3;\\n        \\n        if(s.length() < 3){\\n            return 0;\\n        }\\n\\t        \\n\\t    HashMap<Character, Integer> map = new HashMap<>();\\n\\t        \\n\\t    for(int i = 0 ; i < 3; i++) {\\n\\t    \\t char c  = s.charAt(i);\\n\\t    \\t map.put(c, map.getOrDefault(c, 0) + 1);\\n\\t     }\\n        \\n        if(map.size() == 3) {\\n\\t    \\t\\t   res++;\\n\\t    }\\n\\t       \\n\\t    while(end<s.length()) {\\n\\t    \\tchar e = s.charAt(end);\\n\\t    \\tchar st= s.charAt(start);\\n            \\n\\t    \\tmap.put(st, map.get(st) - 1);\\n\\t    \\tif(map.get(st) == 0) {\\n\\t    \\t\\t map.remove(st);\\n\\t    \\t }\\n            \\n\\t    \\tmap.put(e, map.getOrDefault(e ,0) + 1);\\n            \\n            if(map.size() == 3) {\\n\\t    \\t\\t   res++;\\n\\t    \\t   }\\n\\t    \\t   \\n\\t    \\t start++;\\n\\t    \\t end++;\\n\\t    }\\n\\t    return res;  \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1238826,
                "title": "js-single-loop-solution",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countGoodSubstrings = function(s) {\\n    let count = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (!s[i+1] || !s[i+2]) break;\\n        if (s[i] !== s[i+1] && s[i] !== s[i+2] && s[i+1] !== s[i+2]) count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nvar countGoodSubstrings = function(s) {\\n    let count = 0;\\n    for (let i = 0; i < s.length; i++) {\\n        if (!s[i+1] || !s[i+2]) break;\\n        if (s[i] !== s[i+1] && s[i] !== s[i+2] && s[i+1] !== s[i+2]) count++;\\n    }\\n\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4040602,
                "title": "sliding-window-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int j=0;\\n        int i=0;\\n        int n=s.length();\\n        int ans=0;\\n        unordered_map<char,int> m;\\n\\n        while(j<n){\\n            m[s[j]]++;\\n\\n            if(j-i+1 < 3){\\n                j++;\\n            }else{\\n                if(m.size()==3){\\n                    ans++;\\n                }\\n                m[s[i]]--;\\n                if(m[s[i]]==0){\\n                    m.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int j=0;\\n        int i=0;\\n        int n=s.length();\\n        int ans=0;\\n        unordered_map<char,int> m;\\n\\n        while(j<n){\\n            m[s[j]]++;\\n\\n            if(j-i+1 < 3){\\n                j++;\\n            }else{\\n                if(m.size()==3){\\n                    ans++;\\n                }\\n                m[s[i]]--;\\n                if(m[s[i]]==0){\\n                    m.erase(s[i]);\\n                }\\n                i++;\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3918330,
                "title": "java-easy-solution-using-one-single-condition",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count=0;\\n\\n        for(int i=0;i<s.length()-2;i++){\\n            if((s.charAt(i)!=s.charAt(i+1))&&(s.charAt(i)!=s.charAt(i+2))&&(s.charAt(i+2)!=s.charAt(i+1))){\\n                count++;\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count=0;\\n\\n        for(int i=0;i<s.length()-2;i++){\\n            if((s.charAt(i)!=s.charAt(i+1))&&(s.charAt(i)!=s.charAt(i+2))&&(s.charAt(i+2)!=s.charAt(i+1))){\\n                count++;\\n            }\\n        }\\n        return count;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880268,
                "title": "easy-understandable",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int cnt = 0;\\n        int sz = s.size();\\n        if(sz<3)return 0;\\n        for(int i = 0; i < sz-2; i++){\\n            string sb = s.substr(i,3);\\n            sort(sb.begin(),sb.end());\\n            for(int j = 0; j < 3; j++){\\n                if(j==2)cnt++;\\n                else if(sb[j]==sb[j+1])break;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int cnt = 0;\\n        int sz = s.size();\\n        if(sz<3)return 0;\\n        for(int i = 0; i < sz-2; i++){\\n            string sb = s.substr(i,3);\\n            sort(sb.begin(),sb.end());\\n            for(int j = 0; j < 3; j++){\\n                if(j==2)cnt++;\\n                else if(sb[j]==sb[j+1])break;\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3782904,
                "title": "easy-java-solution-clean-code-sliding-window",
                "content": "# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int start = 0;\\n        int end = 0;\\n        int ans = 0;\\n        int count = 0;\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        while(end < s.length()) {\\n\\n            if(!map.containsKey(s.charAt(end))) {\\n\\n                map.put((s.charAt(end)), 1);\\n                count++;\\n            }\\n\\n            else {\\n\\n                map.put(s.charAt(end), map.get(s.charAt(end)) + 1);\\n\\n                if(map.get(s.charAt(end)) == 1) {\\n                    count++;\\n                }\\n            }\\n\\n            if(end - start + 1 < 3) {\\n                end++;\\n            }\\n\\n            else {\\n                if(count == 3) {\\n                    ans++;\\n                }\\n\\n                if(map.containsKey(s.charAt(start))) {\\n\\n                    map.put((s.charAt(start)), map.get(s.charAt(start)) - 1);\\n\\n                    if(map.get(s.charAt(start)) == 0) {\\n                        count--;\\n                    }\\n                }\\n                \\n                start++;\\n                end++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int start = 0;\\n        int end = 0;\\n        int ans = 0;\\n        int count = 0;\\n        HashMap<Character, Integer> map = new HashMap<>();\\n\\n        while(end < s.length()) {\\n\\n            if(!map.containsKey(s.charAt(end))) {\\n\\n                map.put((s.charAt(end)), 1);\\n                count++;\\n            }\\n\\n            else {\\n\\n                map.put(s.charAt(end), map.get(s.charAt(end)) + 1);\\n\\n                if(map.get(s.charAt(end)) == 1) {\\n                    count++;\\n                }\\n            }\\n\\n            if(end - start + 1 < 3) {\\n                end++;\\n            }\\n\\n            else {\\n                if(count == 3) {\\n                    ans++;\\n                }\\n\\n                if(map.containsKey(s.charAt(start))) {\\n\\n                    map.put((s.charAt(start)), map.get(s.charAt(start)) - 1);\\n\\n                    if(map.get(s.charAt(start)) == 0) {\\n                        count--;\\n                    }\\n                }\\n                \\n                start++;\\n                end++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3706864,
                "title": "very-easy-solution-using-set-and-only-one-loop-and-one-condition",
                "content": "# Code\\n``` Javascript []\\nfunction countGoodSubstrings(s){\\n    let res = 0\\n    for(let i = 0; i < s.length; i++){\\n        if(new Set(s.substring( i, i+3)).size === 3) res++\\n    }\\n    return res\\n};\\n```\\n``` Typescript []\\nfunction countGoodSubstrings(s: string): number {\\n    let res: number = 0\\n    for(let i: number = 0; i < s.length; i++){\\n        if(new Set<string>(s.substring( i, i+3)).size === 3) res++\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "``` Javascript []\\nfunction countGoodSubstrings(s){\\n    let res = 0\\n    for(let i = 0; i < s.length; i++){\\n        if(new Set(s.substring( i, i+3)).size === 3) res++\\n    }\\n    return res\\n};\\n```\n``` Typescript []\\nfunction countGoodSubstrings(s: string): number {\\n    let res: number = 0\\n    for(let i: number = 0; i < s.length; i++){\\n        if(new Set<string>(s.substring( i, i+3)).size === 3) res++\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3573719,
                "title": "o-n-substrings-of-size-three-with-distinct-characters-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i, count=0;\\n        if(s.length()<3)\\n            return 0;\\n        for(i=0 ; i<s.length()-2 ; i++)\\n        {\\n            if(s[i]!=s[i+1] && s[i+1]!=s[i+2] && s[i+2]!=s[i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/972e7951-f10d-45c5-8bcc-abe476d8f044_1685332135.679337.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int i, count=0;\\n        if(s.length()<3)\\n            return 0;\\n        for(i=0 ; i<s.length()-2 ; i++)\\n        {\\n            if(s[i]!=s[i+1] && s[i+1]!=s[i+2] && s[i+2]!=s[i])\\n            {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3510529,
                "title": "big-brian-genuis-solution-beats-100000",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse your brian\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse as many method call as possible\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nSUPER FAST\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nWhat\\'s that?\\n\\n# Code\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        LinkedHashSet<Character> set = new LinkedHashSet<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (set.size() != 3) {\\n                while (!set.add(s.charAt(i))) {\\n                    set.remove(set.iterator().next());\\n                }\\n            }\\n            else {\\n                count++;\\n                set.remove(set.iterator().next());\\n                while (!set.add(s.charAt(i))) {\\n                    set.remove(set.iterator().next());\\n                }\\n            }\\n        }\\n        if (set.size() == 3) {\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        LinkedHashSet<Character> set = new LinkedHashSet<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            if (set.size() != 3) {\\n                while (!set.add(s.charAt(i))) {\\n                    set.remove(set.iterator().next());\\n                }\\n            }\\n            else {\\n                count++;\\n                set.remove(set.iterator().next());\\n                while (!set.add(s.charAt(i))) {\\n                    set.remove(set.iterator().next());\\n                }\\n            }\\n        }\\n        if (set.size() == 3) {\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3433317,
                "title": "python-99-92-faster-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        n = len(s)\\n        if n < 3:\\n            return 0\\n        count = 0\\n        for idx in range((n-3)+1):\\n            subString = s[idx:idx+3]\\n            unique_word_len = len(set(subString))\\n            if unique_word_len == 3:\\n                count+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        n = len(s)\\n        if n < 3:\\n            return 0\\n        count = 0\\n        for idx in range((n-3)+1):\\n            subString = s[idx:idx+3]\\n            unique_word_len = len(set(subString))\\n            if unique_word_len == 3:\\n                count+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3336698,
                "title": "1876-substrings-of-size-three-with-distinct-characters-java",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0,j=0,k=3,cnt=0;\\n        while(j<s.length())\\n        {\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(i+2)&&s.charAt(i)!=s.charAt(i+2))\\n                    cnt++;\\n                  i++;\\n                  j++;  \\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int i=0,j=0,k=3,cnt=0;\\n        while(j<s.length())\\n        {\\n            if(j-i+1<k)\\n                j++;\\n            else if(j-i+1==k)\\n            {\\n                if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(i+2)&&s.charAt(i)!=s.charAt(i+2))\\n                    cnt++;\\n                  i++;\\n                  j++;  \\n            }\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291434,
                "title": "python-one-line-o-n",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        \\n        return sum(s[i] != s[i+1] and s[i]!= s[i+2] and s[i+1] != s[i+2] for i in range(len(s)-2))\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        \\n        return sum(s[i] != s[i+1] and s[i]!= s[i+2] and s[i+1] != s[i+2] for i in range(len(s)-2))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147175,
                "title": "python-easy-beats-80-hashmap",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\n        l = 0\\n        r = 2\\n        count=0\\n\\n        while(r<len(s)):\\n            new = {}\\n            for i in range(l,r+1):\\n                new[s[i]] = 1 + new.get(s[i],0)\\n\\n            flag = True    \\n\\n            for i in new.values():\\n                if i>1:\\n                    flag=False\\n            if flag == True:\\n                count+=1   \\n            l+=1\\n            r+=1\\n\\n        return count             \\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\n        l = 0\\n        r = 2\\n        count=0\\n\\n        while(r<len(s)):\\n            new = {}\\n            for i in range(l,r+1):\\n                new[s[i]] = 1 + new.get(s[i],0)\\n\\n            flag = True    \\n\\n            for i in new.values():\\n                if i>1:\\n                    flag=False\\n            if flag == True:\\n                count+=1   \\n            l+=1\\n            r+=1\\n\\n        return count             \\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3082466,
                "title": "python-solution-o-n-approach-using-sliding-window-beats-92-submissions",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        k=3\\n        i=0 \\n        j=0 \\n        n=len(s)\\n        count=0\\n        while j<n:\\n            if j-i+1<k:\\n                j+=1\\n            elif j-i+1==k:\\n                if s[i]!=s[i+1] and s[i+1]!=s[i+2] and s[i+2]!=s[i]:\\n                    count+=1 \\n                i+=1 \\n                j+=1\\n        return count\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        k=3\\n        i=0 \\n        j=0 \\n        n=len(s)\\n        count=0\\n        while j<n:\\n            if j-i+1<k:\\n                j+=1\\n            elif j-i+1==k:\\n                if s[i]!=s[i+1] and s[i+1]!=s[i+2] and s[i+2]!=s[i]:\\n                    count+=1 \\n                i+=1 \\n                j+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892544,
                "title": "c-simple-o-n-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n        var result = 0;\\n        for(int i=0;i<s.Length-2;i++){\\n            if(s[i] != s[i+1] && s[i+1] != s[i+2] && s[i+2] != s[i]){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int CountGoodSubstrings(string s) {\\n        var result = 0;\\n        for(int i=0;i<s.Length-2;i++){\\n            if(s[i] != s[i+1] && s[i+1] != s[i+2] && s[i+2] != s[i]){\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876553,
                "title": "brute-force-c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\n      //since the minimum length of the substring should be 3 \\n      if(s.length()<3) return 0;\\n      \\n      /* traverse the string and check if a substring of size 3 consists of all distinct characters and increment the ans variable */\\n      int ans = 0;\\n      for(int i=0;i<s.length()-2;++i){\\n         if(s[i]!=s[i+1] && s[i+1]!=s[i+2] && s[i]!=s[i+2]) ans++; \\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n\\n      //since the minimum length of the substring should be 3 \\n      if(s.length()<3) return 0;\\n      \\n      /* traverse the string and check if a substring of size 3 consists of all distinct characters and increment the ans variable */\\n      int ans = 0;\\n      for(int i=0;i<s.length()-2;++i){\\n         if(s[i]!=s[i+1] && s[i+1]!=s[i+2] && s[i]!=s[i+2]) ans++; \\n      }\\n\\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2836229,
                "title": "substrings-of-size-three-with-distinct-characters",
                "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length() == 0){\\n            return 0;\\n        }\\n        \\n        int windowStart = 0;\\n        int wLength = 0;\\n      \\n        \\n        for(int windowEnd = 0;windowEnd < s.length() -2 ;windowEnd++){\\n            if(s.charAt(windowEnd) != s.charAt(windowEnd+1) &&  s.charAt(windowEnd+1) != s.charAt(windowEnd+2) && s.charAt(windowEnd) != s.charAt(windowEnd+2)){\\n                    windowStart += s.charAt(windowEnd);\\n            }\\n            \\n               if(windowStart >= 3){\\n                    wLength++;\\n                    windowStart = windowStart - s.charAt(windowEnd);\\n                }\\n            }\\n        \\n        \\n       return wLength;\\n    }\\n}\\n****\\n// useing the sliding window Technique \\n//Time Complexity: O(n3) = O(n) Solution\\n// where 3 is the size of the window\\n******",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length() == 0){\\n            return 0;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2819908,
                "title": "python3-solution-o-n-time-complexity-using-sliding-window",
                "content": "Approach:\\nSlidding Window Technique:\\n1. At each ith position slice the string from i to i + 3 and count the letters\\n2. If there is a substring with all elements with count one, then the substring will be counted else the substring will be skipped\\n3. Then finally return the number of substrings that are good in the given criteria.\\n\\n```\\ndef countGoodSubstrings(self, s: str) -> int:\\n\\ti = 0\\n\\tnumberOfSubstring = 0\\n\\twhile i + 3 <= len(s):\\n\\t\\tfirst3 = s[i:i+3]\\n\\t\\tcountFirst3 = Counter(first3)\\n\\t\\tisOne = True\\n\\t\\tfor letter in countFirst3:\\n\\t\\t\\tif countFirst3[letter] != 1:\\n\\t\\t\\t\\tisOne = False\\n\\t\\tif isOne:\\n\\t\\t\\tnumberOfSubstring +=1\\n\\t\\ti +=1\\n\\treturn numberOfSubstring",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Approach:\\nSlidding Window Technique:\\n1. At each ith position slice the string from i to i + 3 and count the letters\\n2. If there is a substring with all elements with count one, then the substring will be counted else the substring will be skipped\\n3. Then finally return the number of substrings that are good in the given criteria.\\n\\n```\\ndef countGoodSubstrings(self, s: str) -> int:\\n\\ti = 0\\n\\tnumberOfSubstring = 0\\n\\twhile i + 3 <= len(s):\\n\\t\\tfirst3 = s[i:i+3]\\n\\t\\tcountFirst3 = Counter(first3)\\n\\t\\tisOne = True\\n\\t\\tfor letter in countFirst3:\\n\\t\\t\\tif countFirst3[letter] != 1:\\n\\t\\t\\t\\tisOne = False\\n\\t\\tif isOne:\\n\\t\\t\\tnumberOfSubstring +=1\\n\\t\\ti +=1\\n\\treturn numberOfSubstring",
                "codeTag": "Python3"
            },
            {
                "id": 2596839,
                "title": "easy-understanding-brute-force-using-python",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        substr = []\\n        counter = 0\\n        for i in range(0,len(s)):\\n            if i <= len(s)-3:\\n                substr.append(s[i:i+3])\\n            else:\\n                break\\n        for i in range(len(substr)):\\n            if len(substr[i]) == len(set(substr[i])):\\n                counter += 1\\n        return counter\\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        substr = []\\n        counter = 0\\n        for i in range(0,len(s)):\\n            if i <= len(s)-3:\\n                substr.append(s[i:i+3])\\n            else:\\n                break\\n        for i in range(len(substr)):\\n            if len(substr[i]) == len(set(substr[i])):\\n                counter += 1\\n        return counter\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568306,
                "title": "sliding-window-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        \\n        int i = 0, j = 0;\\n        int count = 0;\\n        while(j < s.length())\\n        {\\n            if(j - i + 1 == 3)\\n            {\\n                char ch1 = s[j];\\n                char ch2 = s[j - 1];\\n                char ch3 = s[j - 2];\\n                if(ch1 != ch2 and ch2 != ch3 and ch1 != ch3)\\n                    count++;\\n                \\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        \\n        int i = 0, j = 0;\\n        int count = 0;\\n        while(j < s.length())\\n        {\\n            if(j - i + 1 == 3)\\n            {\\n                char ch1 = s[j];\\n                char ch2 = s[j - 1];\\n                char ch3 = s[j - 2];\\n                if(ch1 != ch2 and ch2 != ch3 and ch1 != ch3)\\n                    count++;\\n                \\n                i++;\\n            }\\n            j++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2535673,
                "title": "python-3-multiple-solutions-including-one-liner-most-efficient-and-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        return sum(len(set(s[i:i+3]))==3 for i in range(len(s)-2))\\n```\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        res=[]\\n        count=0\\n        for i in range(len(s)-2):\\n            res.append(s[i:i+3])\\n        for sub in res:\\n            if len(set(sub))==3:\\n                count+=1\\n        return count\\n```\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3:\\n                count+=1\\n        return count\\n```\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            sub=s[i]+s[i+1]+s[i+2]\\n            if len(set(sub))==3:\\n                count+=1\\n        return count\\n```\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\t\\tcount=0\\n\\t\\tfor a,b,c in zip(s,s[1:],s[2:]):\\n\\t\\t\\tif len({a,b,c})==3:\\n\\t\\t\\t\\tcount+=1\\n\\t\\treturn count\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        return sum(len(set(s[i:i+3]))==3 for i in range(len(s)-2))\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        res=[]\\n        count=0\\n        for i in range(len(s)-2):\\n            res.append(s[i:i+3])\\n        for sub in res:\\n            if len(set(sub))==3:\\n                count+=1\\n        return count\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3]))==3:\\n                count+=1\\n        return count\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count=0\\n        for i in range(len(s)-2):\\n            sub=s[i]+s[i+1]+s[i+2]\\n            if len(set(sub))==3:\\n                count+=1\\n        return count\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n\\t\\tcount=0\\n\\t\\tfor a,b,c in zip(s,s[1:],s[2:]):\\n\\t\\t\\tif len({a,b,c})==3:\\n\\t\\t\\t\\tcount+=1\\n\\t\\treturn count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507366,
                "title": "simple-and-easy-to-understand-java-solution-in-o-n-time-complexity",
                "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        int ans = 0;\\n        for(int i = 0;i<s.length()-2;i++)\\n        {\\n            if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2))\\n                ans++;\\n        }\\n               return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        int ans = 0;\\n        for(int i = 0;i<s.length()-2;i++)\\n        {\\n            if(s.charAt(i)!=s.charAt(i+1) && s.charAt(i+1)!=s.charAt(i+2) && s.charAt(i)!=s.charAt(i+2))\\n                ans++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2465319,
                "title": "sliding-window-with-size-3",
                "content": "Start at index 2, then check if this char is different from the ones pointed at index-1 and at index-2. If all are different, count +1.\\n\\n```\\nclass Solution {\\n    public int countGoodSubstrings(String s) \\n    {\\n        int i = 2, count = 0;\\n        while(i < s.length())\\n        {\\n            char last = s.charAt(i), middle = s.charAt(i-1), first = s.charAt(i-2);\\n            count += (last != middle && middle != first && first != last) ? 1 : 0;\\n            r++;\\n        }\\n        return count;\\n    }\\n```\\n}",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) \\n    {\\n        int i = 2, count = 0;\\n        while(i < s.length())\\n        {\\n            char last = s.charAt(i), middle = s.charAt(i-1), first = s.charAt(i-2);\\n            count += (last != middle && middle != first && first != last) ? 1 : 0;\\n            r++;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464600,
                "title": "new-one-simple-boolean-trick-applied-aditya-verma-type-modified-solution-sliding-window",
                "content": "**Here u may wonder how boolean works**\\n\\nThe idea is as WINDOW is size 3. Only possibility is either 1st char repeats more than once.\\nOr 2nd Char repeats more than once. \\nSo whenever u slide. If after reduction its 1 then you have eliminated the duplicate from the window\\n\\nDIDNT Get it YET???\\nDont worry\\nLets take cases\\n* aaa  => here after mpp[a]-- you have val as 2 DUPLICATE Not Eliminated if SLIDED\\n* aab => here after mpp[a]-- you have val as 1 DUPLICATE Eliminated if SLIDED\\n* abb => here after mpp[a]-- you have val as 0 DUPLICATE NOT Eliminated if SLIDED. As you removed a element that is unique only.\\n* So if val of map goes to 1 after reduction then char that was repeated is removed is the CRUX of whole Story.\\n\\n\\n```\\n//O(N) time O(1) Space. As always map takes only 3 chars max 26.\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        \\n        unordered_map<char,int> mpp; //char, freq\\n        int i=0;\\n        int j=0;\\n        int N = s.size();\\n        bool flag = true;\\n        int ans_count=0;\\n        \\n        while(j<N){\\n            //calcs\\n            mpp[s[j]]++;\\n            if(mpp[s[j]] >1) flag = false;\\n            \\n            if(j-i+1 < 3){\\n                j++;\\n            }\\n            else if(j-i+1 == 3){\\n                //ans calc\\n                if(flag) ans_count++;\\n                \\n                //slide\\n                char ch = s[i];\\n                mpp[ch]--;\\n                i++;\\n                if(mpp[ch]==1) flag =true;\\n                j++;\\n                \\n            }\\n        }\\n        return ans_count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n//O(N) time O(1) Space. As always map takes only 3 chars max 26.\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        \\n        unordered_map<char,int> mpp; //char, freq\\n        int i=0;\\n        int j=0;\\n        int N = s.size();\\n        bool flag = true;\\n        int ans_count=0;\\n        \\n        while(j<N){\\n            //calcs\\n            mpp[s[j]]++;\\n            if(mpp[s[j]] >1) flag = false;\\n            \\n            if(j-i+1 < 3){\\n                j++;\\n            }\\n            else if(j-i+1 == 3){\\n                //ans calc\\n                if(flag) ans_count++;\\n                \\n                //slide\\n                char ch = s[i];\\n                mpp[ch]--;\\n                i++;\\n                if(mpp[ch]==1) flag =true;\\n                j++;\\n                \\n            }\\n        }\\n        return ans_count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455835,
                "title": "c",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        string res;\\n        vector<string>sk;\\n        vector<int>end;\\n        int c=0;\\n        if(s.length()==1){return 0;}\\n       for(int i=0;i<s.length()-2;i++){\\n           for(int j=i+1;j<s.length();j++){\\n              res+=s[i];\\n               res+=s[j];\\n               res+=s[j+1];\\n               break;\\n           }\\n        sk.push_back(res);\\n           res=\"\";\\n       }\\n        res=\"\";\\n        for(auto i:sk){\\n            res=i;\\n            cout<<res<<\" \";\\n            for(int j=0;j<res.length()-2;j++){\\n                if(res[j]!=res[j+1] && res[j]!=res[j+2] && res[j+1]!=res[j+2]){\\n                    end.push_back(1);\\n                }\\n                else{\\n                    end.push_back(2);\\n                }\\n            }\\n            }\\n        \\n        for(auto i:end){\\n            if(i==1){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        string res;\\n        vector<string>sk;\\n        vector<int>end;\\n        int c=0;\\n        if(s.length()==1){return 0;}\\n       for(int i=0;i<s.length()-2;i++){\\n           for(int j=i+1;j<s.length();j++){\\n              res+=s[i];\\n               res+=s[j];\\n               res+=s[j+1];\\n               break;\\n           }\\n        sk.push_back(res);\\n           res=\"\";\\n       }\\n        res=\"\";\\n        for(auto i:sk){\\n            res=i;\\n            cout<<res<<\" \";\\n            for(int j=0;j<res.length()-2;j++){\\n                if(res[j]!=res[j+1] && res[j]!=res[j+2] && res[j+1]!=res[j+2]){\\n                    end.push_back(1);\\n                }\\n                else{\\n                    end.push_back(2);\\n                }\\n            }\\n            }\\n        \\n        for(auto i:end){\\n            if(i==1){\\n                c++;\\n            }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2446628,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count = 0\\n        l= []\\n        for i in range(0,len(s)-2):\\n            temp = \\'\\'\\n            if s[i] != s[i+1] and s[i+1] != s[i+2] and s[i] != s[i+2]:\\n                temp = s[i]+s[i+1] + s[i+2]\\n                count = count + 1\\n        return count\\nRuntime: 38 ms, faster than 85.92% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        count = 0\\n        l= []\\n        for i in range(0,len(s)-2):\\n            temp = \\'\\'\\n            if s[i] != s[i+1] and s[i+1] != s[i+2] and s[i] != s[i+2]:\\n                temp = s[i]+s[i+1] + s[i+2]\\n                count = count + 1\\n        return count\\nRuntime: 38 ms, faster than 85.92% of Python3 online submissions for Substrings of Size Three with Distinct Characters.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440972,
                "title": "simple-sliding-window-o-n",
                "content": "The solution uses simple dynamic sliding window approach. Instead of matching the characters we are checking their last occurrance using a map and if found we are shifting the \\'start\\' of our window to \\'last_occurrance_index + 1\\' position. If the last occurrance is less than the start of our window then we can keep the start as it is because the last occurrance is not in the scope of our current window. \\n\\nOnce this is done, we are calculating the size of current window by using (end - start + 1) and if the answer is equal to or greater than our N=3 the increamenting the counter by 1 and we are done.\\n\\nNote - The original question is asked for fixed size sub array but here we can change the value of N to tackle the follow up questions :-)\\n\\n```\\nvar countGoodSubstrings = function(s) {\\n    const n = 3;\\n    let count = 0;\\n    const map = {};\\n    let start = 0;\\n    for (let end = 0; end < s.length; end++) {\\n        const item = s[end]\\n        if (item in map) {\\n            start = Math.max(start, map[item] + 1)\\n        }\\n        map[item] = end\\n        const size = end - start + 1\\n        \\n        if (size >= n) {\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar countGoodSubstrings = function(s) {\\n    const n = 3;\\n    let count = 0;\\n    const map = {};\\n    let start = 0;\\n    for (let end = 0; end < s.length; end++) {\\n        const item = s[end]\\n        if (item in map) {\\n            start = Math.max(start, map[item] + 1)\\n        }\\n        map[item] = end\\n        const size = end - start + 1\\n        \\n        if (size >= n) {\\n            count++\\n        }\\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2437224,
                "title": "c-solution-for-a-general-case-using-unordered-map",
                "content": "This solution will work even for a general window size of k (here given 3).\\n\\nFor creating the window have created a unordered_map which will store the elements. If an elements value becomes equal to 2 in the map it means it is duplicate so we will increment the `duplicate`.\\nAfter the iteration we remove the first element of window from map and if it\\'s value becomes 1 in `umap` it means it is no longer a duplicate so decrement duplicate by 1. \\n\\nWe will only increment answer variable only if duplicate is = 0.\\n```\\n  int countGoodSubstrings(string s) {\\n        if(s.length()<3) return 0;\\n        int n = s.length();\\n        unordered_map<char, int> umap;\\n        int duplicate = 0;\\n        int count = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            umap[s[i]]++; // insert in the window\\n            if(umap[s[i]]==2) duplicate++;\\n            if(i<2) continue; // if this satisfies we don\\'t need to remove anything from map neither increment count the first window is being created\\n            if(!duplicate) count++;\\n            umap[s[i-2]]--;  // remove from the window\\n            if(umap[s[i-2]]==1) duplicate--;\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  int countGoodSubstrings(string s) {\\n        if(s.length()<3) return 0;\\n        int n = s.length();\\n        unordered_map<char, int> umap;\\n        int duplicate = 0;\\n        int count = 0;\\n        \\n        for(int i=0;i<n;i++){\\n            umap[s[i]]++; // insert in the window\\n            if(umap[s[i]]==2) duplicate++;\\n            if(i<2) continue; // if this satisfies we don\\'t need to remove anything from map neither increment count the first window is being created\\n            if(!duplicate) count++;\\n            umap[s[i-2]]--;  // remove from the window\\n            if(umap[s[i-2]]==1) duplicate--;\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2393723,
                "title": "python-o-n-sliding-window",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        counter = 0\\n        for i in range(len(s) - 2):\\n            if len(set(s[i:i+3])) == 3:\\n                counter += 1\\n        return counter\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        counter = 0\\n        for i in range(len(s) - 2):\\n            if len(set(s[i:i+3])) == 3:\\n                counter += 1\\n        return counter\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2336890,
                "title": "python-short-simple-set",
                "content": "```\\ndef countGoodSubstrings(self, s: str) -> int:\\n        cnt = 0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3])) == 3:\\n                cnt += 1\\n        return cnt\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\ndef countGoodSubstrings(self, s: str) -> int:\\n        cnt = 0\\n        for i in range(len(s)-2):\\n            if len(set(s[i:i+3])) == 3:\\n                cnt += 1\\n        return cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2327279,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        for(int i=0;i<s.length()-2;i++){\\n            String str = s.substring(i,i+3);\\n            if((str.charAt(0) != str.charAt(1)) && (str.charAt(1) != str.charAt(2)) && (str.charAt(0) != str.charAt(2))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        int count = 0;\\n        for(int i=0;i<s.length()-2;i++){\\n            String str = s.substring(i,i+3);\\n            if((str.charAt(0) != str.charAt(1)) && (str.charAt(1) != str.charAt(2)) && (str.charAt(0) != str.charAt(2))){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2321627,
                "title": "easy-c-3-line-solution-with-o-n-approach",
                "content": "Here we will use sliding window technique by taking the window size as 3 according to the details given.\\nrun a loop till the string length.\\nwith each iteration, check the current 3 variables if they are same and increase count if true;\\n\\n\\t\\n\\t\\tint countGoodSubstrings(string s) {\\n\\t\\t\\tint count=0;\\n\\n\\t\\t\\tfor(int i=0;i+3<=s.length();i++) \\n\\t\\t\\tif((s[i]!=s[i+1]) && (s[i]!=s[i+2]) && (s[i+1]!=s[i+2])) count++;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "Here we will use sliding window technique by taking the window size as 3 according to the details given.\\nrun a loop till the string length.\\nwith each iteration, check the current 3 variables if they are same and increase count if true;\\n\\n\\t\\n\\t\\tint countGoodSubstrings(string s) {\\n\\t\\t\\tint count=0;\\n\\n\\t\\t\\tfor(int i=0;i+3<=s.length();i++) \\n\\t\\t\\tif((s[i]!=s[i+1]) && (s[i]!=s[i+2]) && (s[i+1]!=s[i+2])) count++;\\n\\t\\t\\treturn count;\\n\\t\\t}\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2276337,
                "title": "c-sliding-window-sets-straightforward",
                "content": "![image](https://assets.leetcode.com/users/images/6e09450a-70cc-4736-865e-721641a98f97_1657705720.691491.png)\\n\\n**n==s.size()\\nT->O(n) && S->O(1)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t//  Sliding window of constant length!\\n\\t\\tint countGoodSubstrings(string s) {\\n\\t\\t\\tunordered_set<char>st;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i+2<s.size();i++){\\n\\t\\t\\t\\tfor(int j=i;j<=i+2;j++) st.insert(s[j]);\\n\\t\\t\\t\\tif(st.size()==3)count++;\\n\\t\\t\\t\\tst.clear();\\n\\t\\t\\t}    \\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t//  Sliding window of constant length!\\n\\t\\tint countGoodSubstrings(string s) {\\n\\t\\t\\tunordered_set<char>st;\\n\\t\\t\\tint count=0;\\n\\t\\t\\tfor(int i=0;i+2<s.size();i++){\\n\\t\\t\\t\\tfor(int j=i;j<=i+2;j++) st.insert(s[j]);\\n\\t\\t\\t\\tif(st.size()==3)count++;\\n\\t\\t\\t\\tst.clear();\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2251130,
                "title": "java-sliding-window-1-ms",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if (s.length() < 3) return 0;\\n        int count = 0;\\n        for (int i = 0; i + 2 < s.length(); i++) {\\n            if (s.charAt(i) != s.charAt(i + 1) &&\\n                s.charAt(i + 1) != s.charAt(i + 2) &&\\n                s.charAt(i + 2) != s.charAt(i)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if (s.length() < 3) return 0;\\n        int count = 0;\\n        for (int i = 0; i + 2 < s.length(); i++) {\\n            if (s.charAt(i) != s.charAt(i + 1) &&\\n                s.charAt(i + 1) != s.charAt(i + 2) &&\\n                s.charAt(i + 2) != s.charAt(i)) {\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241562,
                "title": "java-too-easy-solution-using-hashset",
                "content": "```\\nint c=0;\\n        for(int i=0;i<(s.length()-2);i++){\\n            Set<Character> set=new HashSet<>();\\n            set.add(s.charAt(i));\\n            set.add(s.charAt(i+1));\\n            set.add(s.charAt(i+2));\\n            if(set.size()==3)c++;\\n        }\\n        return c;```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint c=0;\\n        for(int i=0;i<(s.length()-2);i++){\\n            Set<Character> set=new HashSet<>();\\n            set.add(s.charAt(i));\\n            set.add(s.charAt(i+1));\\n            set.add(s.charAt(i+2));\\n            if(set.size()==3)c++;\\n        }\\n        return c;```",
                "codeTag": "Unknown"
            },
            {
                "id": 2217193,
                "title": "simple-javascript-solution-using-set-and-for-loop-o-n",
                "content": "\\n\\n\\tvar countGoodSubstrings = function(s) {\\n    let numOfGoodStrings = 0;\\n  \\n    for(let i=1;i<s.length-1;i++) {\\n      numOfGoodStrings += new Set([s[i-1],s[i],s[i+1]]).size===3?1:0;\\n    }\\n    return numOfGoodStrings;\\n\\t};",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "\\n\\n\\tvar countGoodSubstrings = function(s) {\\n    let numOfGoodStrings = 0;\\n  \\n    for(let i=1;i<s.length-1;i++) {\\n      numOfGoodStrings += new Set([s[i-1],s[i],s[i+1]]).size===3?1:0;\\n    }\\n    return numOfGoodStrings;\\n\\t};",
                "codeTag": "Unknown"
            },
            {
                "id": 2195038,
                "title": "java-sliding-window-1-ms-faster-than-96-13-of-java-online-submissions",
                "content": "\\n        int i=0, ct=0;\\n        if(m.length()<3)\\n            return 0;\\n        for(i=1;i<m.length()-1;i++)\\n        {\\n          \\nif(m.charAt(i-1) != m.charAt(i) && m.charAt(i) != m.charAt(i+1) && m.charAt(i+1)!= m.charAt(i-1))\\n                ct++;\\n            \\n        \\n        }\\n        return ct;\\n\\t\\t\\n\\t\\t*** If You like the soution please hit up the like button share any thoughts and other solution  on this question  ****\\n\\t\\tThank You",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "\\n        int i=0, ct=0;\\n        if(m.length()<3)\\n            return 0;\\n        for(i=1;i<m.length()-1;i++)\\n        {\\n          \\nif(m.charAt(i-1) != m.charAt(i) && m.charAt(i) != m.charAt(i+1) && m.charAt(i+1)!= m.charAt(i-1))\\n                ct++;\\n            \\n        \\n        }\\n        return ct;\\n\\t\\t\\n\\t\\t*** If You like the soution please hit up the like button share any thoughts and other solution  on this question  ****\\n\\t\\tThank You",
                "codeTag": "Unknown"
            },
            {
                "id": 2187094,
                "title": "best-solution-and-4-method-in-python",
                "content": "\\tclass Solution:\\n\\t\\tdef countGoodSubstrings(self, s: str) -> int:\\n        \\n        #--------------Method-1---------------------\\n        # ans = 0\\n        # for i in range(3,len(s)+1):\\n        #     if len(set(s[i-3:i])) == 3:\\n        #         ans += 1\\n        # return ans\\n        \\n        #------------Method-2 (sliding window)------------------\\n        # c = 0\\n        # st = list(s[ : 3])\\n        # for i in range(3, len(s)):\\n        #     if len(set(st))==3:\\n        #         c += 1\\n        #     # print(st)\\n        #     st.append(s[i])\\n        #     st.pop(0)\\n        #     # print(st)\\n        # if len(set(st))==3:\\n        #     c += 1\\n        # return c\\n        \\n        #-------------Method-3--------------------\\n        # count=0\\n        # for i in range(len(s)-2):\\n        #     if(s[i]==s[i+1] or s[i+1]==s[i+2] or s[i+2]==s[i]):\\n        #         count+=0\\n        #     else:\\n        #         count+=1\\n        # return count\\n        \\n        #----------Method-4 (Using Map/Counting )----------------------\\n        if len(s) <3:\\n            return 0\\n        mp = {}\\n        c = 0\\n        left_window = 0\\n        right_window = 1\\n        for i in range(2):\\n            if s[i] not in mp:\\n                mp[s[i]] = 0\\n            mp[s[i]] += 1\\n            #--------OR-------\\n            # if s[i] in mp:\\n            #     mp[s[i]] += 1\\n            # else:\\n            #     mp[s[i]] = 1\\n        # print(mp)\\n        while right_window < len(s)-1 :\\n            right_window += 1\\n            if s[right_window] not in mp:\\n                  mp[s[right_window]] = 0\\n            mp[s[right_window]] += 1\\n            # print(mp)\\n            if all([mp[x]<2 for x in mp]):\\n                c += 1\\n                # print(all([mp[x]<2 for x in mp]))\\n            mp[s[left_window]] -=1\\n            left_window += 1\\n            # print(mp)\\n        return c",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\t\\tdef countGoodSubstrings(self, s: str) -> int:\\n        \\n        #--------------Method-1---------------------\\n        # ans = 0\\n        # for i in range(3,len(s)+1):\\n        #     if len(set(s[i-3:i])) == 3:\\n        #         ans += 1\\n        # return ans\\n        \\n        #------------Method-2 (sliding window)------------------\\n        # c = 0\\n        # st = list(s[ : 3])\\n        # for i in range(3, len(s)):\\n        #     if len(set(st))==3:\\n        #         c += 1\\n        #     # print(st)\\n        #     st.append(s[i])\\n        #     st.pop(0)\\n        #     # print(st)\\n        # if len(set(st))==3:\\n        #     c += 1\\n        # return c\\n        \\n        #-------------Method-3--------------------\\n        # count=0\\n        # for i in range(len(s)-2):\\n        #     if(s[i]==s[i+1] or s[i+1]==s[i+2] or s[i+2]==s[i]):\\n        #         count+=0\\n        #     else:\\n        #         count+=1\\n        # return count\\n        \\n        #----------Method-4 (Using Map/Counting )----------------------\\n        if len(s) <3:\\n            return 0\\n        mp = {}",
                "codeTag": "Java"
            },
            {
                "id": 2172777,
                "title": "easy-java-solution-o-n-loop",
                "content": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length() < 3){\\n            return 0;\\n        }\\n        int count = 0;\\n        for(int i = 0; i< s.length() - 2; i++){\\n            if(s.charAt(i) != s.charAt(i+1) && s.charAt(i) != s.charAt(i+2) && s.charAt(i+1) != s.charAt(i+2)){\\n                count++;    \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countGoodSubstrings(String s) {\\n        if(s.length() < 3){\\n            return 0;\\n        }\\n        int count = 0;\\n        for(int i = 0; i< s.length() - 2; i++){\\n            if(s.charAt(i) != s.charAt(i+1) && s.charAt(i) != s.charAt(i+2) && s.charAt(i+1) != s.charAt(i+2)){\\n                count++;    \\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166220,
                "title": "simple-c-sliding-window-approach-o-n",
                "content": "```\\nint countGoodSubstrings(string s) \\n    {\\n        int i=0;\\n        int j=2;\\n        int c=0;\\n        \\n        while(j<s.length())\\n        {\\n            if(s[i+1]!=s[i] && s[i]!=s[j] && s[j-1]!=s[j])\\n                c++;\\n            i++;\\n            j++;\\n        }\\n     return c;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint countGoodSubstrings(string s) \\n    {\\n        int i=0;\\n        int j=2;\\n        int c=0;\\n        \\n        while(j<s.length())\\n        {\\n            if(s[i+1]!=s[i] && s[i]!=s[j] && s[j-1]!=s[j])\\n                c++;\\n            i++;\\n            j++;\\n        }\\n     return c;   \\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2151101,
                "title": "simple-and-best-by-aditya-verma",
                "content": "first, create window size of 3, once created maintain it and check condition.\\n```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        unordered_map<char,int> m;\\n        if(s.length()<3) return 0;\\n        int i=0,count=0,j=0,n=s.length();\\n        while(j<n){\\n            m[s[j]]++;\\n            if(j-i+1<3) j++;\\n            else if(j-i+1==3){\\n                if(m.size()==3) count++;\\n                j++;\\n                m[s[i]]--;\\n                if(m[s[i]]==0) m.erase(s[i]);\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        unordered_map<char,int> m;\\n        if(s.length()<3) return 0;\\n        int i=0,count=0,j=0,n=s.length();\\n        while(j<n){\\n            m[s[j]]++;\\n            if(j-i+1<3) j++;\\n            else if(j-i+1==3){\\n                if(m.size()==3) count++;\\n                j++;\\n                m[s[i]]--;\\n                if(m[s[i]]==0) m.erase(s[i]);\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2147861,
                "title": "c-fast-easy-simple-unique",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int start = 0;\\n        unordered_map<int,int>ump;\\n        int end = 0;\\n        int ans = 0;\\n        for( end = 0 ; end < 3 && end<s.size() ;end++){\\n            ump[s[end]]++;\\n        }\\n        if(end!=3){\\n            return ans;\\n        }\\n        if(ump.size() == end - start){\\n            ans += 1;\\n        }\\n        for(;end<s.size() ; end++){\\n            ump[s[start]]--;\\n            if(ump[s[start]] == 0){\\n                ump.erase(s[start]);\\n            }\\n            start++;\\n            ump[s[end]]++;\\n            if(ump.size() == end - start +1 ){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int start = 0;\\n        unordered_map<int,int>ump;\\n        int end = 0;\\n        int ans = 0;\\n        for( end = 0 ; end < 3 && end<s.size() ;end++){\\n            ump[s[end]]++;\\n        }\\n        if(end!=3){\\n            return ans;\\n        }\\n        if(ump.size() == end - start){\\n            ans += 1;\\n        }\\n        for(;end<s.size() ; end++){\\n            ump[s[start]]--;\\n            if(ump[s[start]] == 0){\\n                ump.erase(s[start]);\\n            }\\n            start++;\\n            ump[s[end]]++;\\n            if(ump.size() == end - start +1 ){\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2121793,
                "title": "easiet-java-solution-100-faster",
                "content": "int count = 0;\\n        for(int i = 0; i < s.length() - 2; i++){\\n            if(s.charAt(i) != s.charAt(i+1) && s.charAt(i) != s.charAt(i+2) && s.charAt(i+1) != s.charAt(i+2)){\\n                count++;\\n            }\\n        }\\n        return count;",
                "solutionTags": [],
                "code": "int count = 0;\\n        for(int i = 0; i < s.length() - 2; i++){\\n            if(s.charAt(i) != s.charAt(i+1) && s.charAt(i) != s.charAt(i+2) && s.charAt(i+1) != s.charAt(i+2)){\\n                count++;\\n            }\\n        }\\n        return count;",
                "codeTag": "Unknown"
            },
            {
                "id": 2089344,
                "title": "java-using-sliding-window",
                "content": "```\\npublic int countGoodSubstrings(String s) {\\n        Set<String>st=new HashSet();\\n        int co=0;\\n        int i=0;\\n        int j=2;\\n        while(j<s.length()){\\n            if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(j)&&s.charAt(j)!=s.charAt(i)){\\n                 co++;\\n        }\\n            i++;\\n            j++;\\n        }\\n        return co;\\n        \\n        \\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int countGoodSubstrings(String s) {\\n        Set<String>st=new HashSet();\\n        int co=0;\\n        int i=0;\\n        int j=2;\\n        while(j<s.length()){\\n            if(s.charAt(i)!=s.charAt(i+1)&&s.charAt(i+1)!=s.charAt(j)&&s.charAt(j)!=s.charAt(i)){\\n                 co++;\\n        }\\n            i++;\\n            j++;\\n        }\\n        return co;\\n        \\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2034244,
                "title": "golang-o-n-sliding-windows",
                "content": "substring is valid if all chars are uniq. So we can check if there\\'s no duplication in the substring (identified by windows of size k)\\n\\n```\\nfunc countGoodSubstrings(s string) int {\\n    // sliding windows of size k\\n    // condition: all uniq chars ~ no duplication\\n    // count the char frequency via freq\\n    freq := make([]int, 128)\\n    ans, dup := 0, 0\\n    for i := 0; i < len(s); i++ {\\n        freq[s[i]]++\\n        if freq[s[i]] == 2 { // duplicate found\\n            dup++\\n        }\\n        \\n\\t\\t// check if window size met\\n        if i < 2 {\\n            continue\\n        }\\n\\n        // is substring valid\\n        if dup == 0 {\\n            ans++\\n        }\\n        // resize windows from left side\\n        freq[s[i - 2]]--\\n        if freq[s[i - 2]] == 1 { // no longer dup, freq decreases from 2 or higher to 1\\n            dup--\\n        }\\n    }\\n    return ans\\n}\\n```\\n\\nComplexity: O(N) time, O(1) space.\\nWe may use `freq := make([]int, 26)` but updating frequency for char would need to change to `freq[s[i] - \\'a\\']`",
                "solutionTags": [
                    "Go",
                    "Sliding Window"
                ],
                "code": "```\\nfunc countGoodSubstrings(s string) int {\\n    // sliding windows of size k\\n    // condition: all uniq chars ~ no duplication\\n    // count the char frequency via freq\\n    freq := make([]int, 128)\\n    ans, dup := 0, 0\\n    for i := 0; i < len(s); i++ {\\n        freq[s[i]]++\\n        if freq[s[i]] == 2 { // duplicate found\\n            dup++\\n        }\\n        \\n\\t\\t// check if window size met\\n        if i < 2 {\\n            continue\\n        }\\n\\n        // is substring valid\\n        if dup == 0 {\\n            ans++\\n        }\\n        // resize windows from left side\\n        freq[s[i - 2]]--\\n        if freq[s[i - 2]] == 1 { // no longer dup, freq decreases from 2 or higher to 1\\n            dup--\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2004084,
                "title": "c-easy-sliding-window-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        unordered_map<char,int>mp;\\n        int winStart=0;\\n        int ans=0;\\n        for(int winEnd=0; winEnd<s.size(); winEnd++){\\n            mp[s[winEnd]]++;\\n            int count=mp.size();\\n            if(winEnd>=3-1){\\n                mp[s[winStart]]--;\\n                if (mp[s[winStart]] == 0) {\\n                    mp.erase(s[winStart]);\\n                }\\n                 if(count==3){\\n                    ans++;\\n                }\\n                winStart++; \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        unordered_map<char,int>mp;\\n        int winStart=0;\\n        int ans=0;\\n        for(int winEnd=0; winEnd<s.size(); winEnd++){\\n            mp[s[winEnd]]++;\\n            int count=mp.size();\\n            if(winEnd>=3-1){\\n                mp[s[winStart]]--;\\n                if (mp[s[winStart]] == 0) {\\n                    mp.erase(s[winStart]);\\n                }\\n                 if(count==3){\\n                    ans++;\\n                }\\n                winStart++; \\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1992350,
                "title": "python-solution-one-liner",
                "content": "**Solution**:\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s):\\n        count = 0\\n        \\n        for i in range(2, len(s)):\\n            if len(set(s[i-2:i+1])) == 3:\\n                count += 1\\n        \\n        return count\\n```\\n\\n**One-Liner**:\\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s):\\n        return sum(len(set(s[i-2:i+1])) == 3 for i in range(2, len(s)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s):\\n        count = 0\\n        \\n        for i in range(2, len(s)):\\n            if len(set(s[i-2:i+1])) == 3:\\n                count += 1\\n        \\n        return count\\n```\n```\\nclass Solution:\\n    def countGoodSubstrings(self, s):\\n        return sum(len(set(s[i-2:i+1])) == 3 for i in range(2, len(s)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1943515,
                "title": "python-concise-solution",
                "content": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        count = 0\\n        currString = \"\"\\n    \\n        for i in range(0, len(s) - 2):\\n            currString = s[i:i+3]\\n\\n            if len(set(currString)) == len(currString):\\n                count += 1\\n\\t\\t\\t\\t\\n            currString = \"\"\\n        \\n        return count",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countGoodSubstrings(self, s: str) -> int:\\n        \\n        count = 0\\n        currString = \"\"\\n    \\n        for i in range(0, len(s) - 2):\\n            currString = s[i:i+3]\\n\\n            if len(set(currString)) == len(currString):\\n                count += 1\\n\\t\\t\\t\\t\\n            currString = \"\"\\n        \\n        return count",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1717329,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1964571,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1733429,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2042625,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2035853,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1992869,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1926601,
                "content": [
                    {
                        "username": "r4ge_101",
                        "content": "This question has wrong rating.\\nFor any beginner or even a moderate student this is AT LEAST!! Medium"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "guy, I don\\'t even know if this is sarcasm anymore.\\nNah but to be fair, given the fact that max length of string is 100 (given in constraints) I think even a brute force nested loop could do the trick."
                    },
                    {
                        "username": "phaedryx",
                        "content": "It probably depends on the language used and if these things are supported by the language, e.g. in Ruby `string.chars.each_cons(3)` give me an array of all size-3 substrings as arrays."
                    },
                    {
                        "username": "ajinkode",
                        "content": "Nope. This is rightly an easy level problem."
                    },
                    {
                        "username": "thatwillchaiguy",
                        "content": "Nope, this can be reduced to checking whether each length-3 substring has duplicate letters."
                    },
                    {
                        "username": "calm27",
                        "content": "i believe even without knowing double-pointers/sliding window it is still possible to approach in regular brute force way for beginners. \nit is far away from medium, frankly. "
                    },
                    {
                        "username": "BatMe",
                        "content": "Do this question after doing the above question ukiuk:\\n \"Longest Substring Without Repeating Characters\"  "
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "thanks for the heads up\\n"
                    },
                    {
                        "username": "Nitish-Devarshi",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        if(s.size()<3){\\n            return 0;\\n        }\\n        int count=0;\\n        for(int i=0;i<s.size()-2;i++){\\n            if(s[i]!=s[i+1] && s[i]!=s[i+2] && s[i+1]!=s[i+2]){\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "omgapollon917",
                        "content": "Hello, here is small quote from Discussion section rules: \"1. Please don\\'t post any solutions in this discussion tab.\""
                    },
                    {
                        "username": "potatopie",
                        "content": "needs to have an array tag too"
                    },
                    {
                        "username": "duttajay19",
                        "content": "class Solution {\\n    public int countGoodSubstrings(String s) {\\n        \\n        int len=0;\\n        int left=0;\\n        int k=3;\\n        int count=0;\\n        int right=0;\\n        HashSet<Character> c = new HashSet<>();\\n     while(right<s.length()){\\n        \\n        if(c.add(s.charAt(right))){\\n            len++;\\n            right++;\\n\\n            }\\n           \\n        else{\\n                len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n          while(len>k){\\n            len--;\\n                c.remove(s.charAt(left));\\n                left++;\\n        }\\n\\n        if(len==k){\\n                count++;\\n            }\\n\\n      \\n       }\\n       return count;\\n\\n    }\\n}\\nquite good ig\\n"
                    },
                    {
                        "username": "samarth-singh-thakur",
                        "content": "If you try trying to implement the sliding window solution, then to make easier on you brain to process the solution increase the length 3 to some arbitrary  length k.\\n\\n\\n"
                    },
                    {
                        "username": "anshkum47",
                        "content": "class Solution {\\npublic:\\n    int countGoodSubstrings(string s) {\\n        int k=3,i=0,j=0,ans=0;\\n        unordered_map<char,int>m;\\n        while(j<s.size()){\\n            m[s[j]]++;\\n             if(j-i+1>k){\\n                 m[s[i]]--;\\n                 if(m[s[i]]==0) m.erase(s[i]);\\n                 i++;\\n             }\\n            if(j-i+1==k){\\n                if(m.size()==3) ans++;\\n            }\\n           j++;\\n    }\\n    return ans;\\n    }\\n};"
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimize Maximum Pair Sum in Array",
        "question_content": "<p>The <strong>pair sum</strong> of a pair <code>(a,b)</code> is equal to <code>a + b</code>. The <strong>maximum pair sum</strong> is the largest <strong>pair sum</strong> in a list of pairs.</p>\r\n\r\n<ul>\r\n\t<li>For example, if we have pairs <code>(1,5)</code>, <code>(2,3)</code>, and <code>(4,4)</code>, the <strong>maximum pair sum</strong> would be <code>max(1+5, 2+3, 4+4) = max(6, 5, 8) = 8</code>.</li>\r\n</ul>\r\n\r\n<p>Given an array <code>nums</code> of <strong>even</strong> length <code>n</code>, pair up the elements of <code>nums</code> into <code>n / 2</code> pairs such that:</p>\r\n\r\n<ul>\r\n\t<li>Each element of <code>nums</code> is in <strong>exactly one</strong> pair, and</li>\r\n\t<li>The <strong>maximum pair sum </strong>is <strong>minimized</strong>.</li>\r\n</ul>\r\n\r\n<p>Return <em>the minimized <strong>maximum pair sum</strong> after optimally pairing up the elements</em>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [3,5,2,3]\r\n<strong>Output:</strong> 7\r\n<strong>Explanation:</strong> The elements can be paired up into pairs (3,3) and (5,2).\r\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [3,5,4,2,4,6]\r\n<strong>Output:</strong> 8\r\n<strong>Explanation:</strong> The elements can be paired up into pairs (3,5), (4,4), and (6,2).\r\nThe maximum pair sum is max(3+5, 4+4, 6+2) = max(8, 8, 8) = 8.\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>n == nums.length</code></li>\r\n\t<li><code>2 &lt;= n &lt;= 10<sup>5</sup></code></li>\r\n\t<li><code>n</code> is <strong>even</strong>.</li>\r\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>5</sup></code></li>\r\n</ul>",
        "solutions": [
            {
                "id": 1238655,
                "title": "java-c-python-min-max",
                "content": "# **Intuition**\\nSort A,\\nmake the pair with the `min + max`,\\nand continue do this.\\n<br>\\n\\n# **Prove**\\nassuming `amin <= ai <= amax`, `amin <= aj <= amax`,\\nthe combination of `(amin + amax, ai + aj)`,\\nis always no worse than\\nthe combination of `(amin + ai, aj + amax)`.\\n\\nSo we can always pair `amin` with `amax`,\\nand we can reach the optimized result.\\n<br>\\n\\n# **Complexity**\\nTime `O(sort)`\\nSpace `O(sort)`\\n<br>\\n\\n**Java**\\n```java\\n    public int minPairSum(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0, n = A.length;\\n        for (int i = 0; i < n / 2; ++i)\\n            res = Math.max(res, A[i] + A[n - i - 1]);\\n        return res;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int minPairSum(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0, n = A.size();\\n        for (int i = 0; i < n / 2; ++i)\\n            res = max(res, A[i] + A[n - i - 1]);\\n        return res;\\n    }\\n```\\n\\n**Python**\\nO(n) space\\n```py\\n    def minPairSum(self, A):\\n        return max(a + b for a, b in zip(sorted(A), sorted(A)[::-1]))\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int minPairSum(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0, n = A.length;\\n        for (int i = 0; i < n / 2; ++i)\\n            res = Math.max(res, A[i] + A[n - i - 1]);\\n        return res;\\n    }\\n```\n```cpp\\n    int minPairSum(vector<int>& A) {\\n        sort(A.begin(), A.end());\\n        int res = 0, n = A.size();\\n        for (int i = 0; i < n / 2; ++i)\\n            res = max(res, A[i] + A[n - i - 1]);\\n        return res;\\n    }\\n```\n```py\\n    def minPairSum(self, A):\\n        return max(a + b for a, b in zip(sorted(A), sorted(A)[::-1]))\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1238790,
                "title": "java-easy-solution-faster-than-100-sorting-two-pointer-algorithm",
                "content": "**Do vote up if you like it :)**\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while(i < j){\\n            max = Math.max(max, (nums[i++] + nums[j--]));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        int i = 0;\\n        int j = nums.length - 1;\\n        while(i < j){\\n            max = Math.max(max, (nums[i++] + nums[j--]));\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238666,
                "title": "sort",
                "content": "The smallest number should be matched with the largest one (easy to prove otherwise).\\n\\nSo we sort the array, match the smallest with largest, next smallest with next largest, and so on.\\n\\n**C++**\\n```cpp\\nint minPairSum(vector<int>& nums) {\\n    int res = INT_MIN;\\n    sort(begin(nums), end(nums));\\n    for (auto i = 0; i < nums.size() / 2; ++i)\\n        res = max(res, nums[i] + nums[nums.size() - i - 1]);\\n    return res;\\n}\\n```\\n**Java**\\n```java\\npublic int minPairSum(int[] nums) {\\n    int res = Integer.MIN_VALUE;\\n    Arrays.sort(nums);\\n    for (int i = 0; i < nums.length / 2; ++i)\\n        res = Math.max(res, nums[i] + nums[nums.length - i - 1]);\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```cpp\\nint minPairSum(vector<int>& nums) {\\n    int res = INT_MIN;\\n    sort(begin(nums), end(nums));\\n    for (auto i = 0; i < nums.size() / 2; ++i)\\n        res = max(res, nums[i] + nums[nums.size() - i - 1]);\\n    return res;\\n}\\n```\n```java\\npublic int minPairSum(int[] nums) {\\n    int res = Integer.MIN_VALUE;\\n    Arrays.sort(nums);\\n    for (int i = 0; i < nums.length / 2; ++i)\\n        res = Math.max(res, nums[i] + nums[nums.length - i - 1]);\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1499532,
                "title": "short-easy-explanation-2-approaches-c-beginner-friendly",
                "content": "**Using sorting**\\n**Time: O(nlogn)**\\n**Space: O(1)**\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums){\\n\\t    //sort the array\\n        sort(nums.begin(),nums.end());\\n        int start=0,end=nums.size()-1,min_max_pair_sum=0;\\n\\t\\t//Observe the pattern of taking the first and last element, second and second last element... and soo onn.. \\n\\t\\t//would help you to minimize the maximum sum.\\n        while(start<end){\\n            min_max_pair_sum=max(min_max_pair_sum,nums[start++]+nums[end--]);\\n        }\\n        return min_max_pair_sum;\\n    }\\n};\\n```\\n**Using freq of elements**\\n**Time: O(n)**\\n**Space: O(100001)**\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int arr[100001]={0};\\n        for(int i:nums){\\n            arr[i]++;\\n        }\\n        int i=0,j=100000,min_max_pair_sum=0;\\n        while(i<=j){\\n            if(arr[i] == 0){\\n                i++;\\n                continue;\\n            }else if(arr[j] == 0){\\n                j--;\\n                continue;\\n            }else{\\n                if(i+j > min_max_pair_sum) min_max_pair_sum = i+j;\\n                arr[i]--;\\n                arr[j]--; \\n            }\\n        }\\n        return min_max_pair_sum;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums){\\n\\t    //sort the array\\n        sort(nums.begin(),nums.end());\\n        int start=0,end=nums.size()-1,min_max_pair_sum=0;\\n\\t\\t//Observe the pattern of taking the first and last element, second and second last element... and soo onn.. \\n\\t\\t//would help you to minimize the maximum sum.\\n        while(start<end){\\n            min_max_pair_sum=max(min_max_pair_sum,nums[start++]+nums[end--]);\\n        }\\n        return min_max_pair_sum;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int arr[100001]={0};\\n        for(int i:nums){\\n            arr[i]++;\\n        }\\n        int i=0,j=100000,min_max_pair_sum=0;\\n        while(i<=j){\\n            if(arr[i] == 0){\\n                i++;\\n                continue;\\n            }else if(arr[j] == 0){\\n                j--;\\n                continue;\\n            }else{\\n                if(i+j > min_max_pair_sum) min_max_pair_sum = i+j;\\n                arr[i]--;\\n                arr[j]--; \\n            }\\n        }\\n        return min_max_pair_sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368963,
                "title": "java-simple-and-elegant-solution-o-n",
                "content": "```\\npublic int minPairSum(int[] nums) {\\n         \\n        int max = 0;\\n        for(int i = 0; i < nums.length ; i++) if(nums[i] > max) max = nums[i];  \\n        \\n        int[] arr = new int[max+1];  \\n        for(int i = 0; i < nums.length ; i++) arr[nums[i]] += 1;\\n        \\n        int temp = 0;        \\n        int i = 0, j = max;\\n         while(i <= j){\\n             \\n            if(arr[i] == 0){\\n                i++;\\n                continue;\\n            } \\n            if(arr[j] == 0){\\n                j--;\\n                continue;\\n            }  \\n            if(arr[i] != 0 && arr[j] != 0){\\n                if(i+j > temp) temp = i+j;\\n                arr[i]--;\\n                arr[j]--;                \\n            }\\n        }        \\n        return temp;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int minPairSum(int[] nums) {\\n         \\n        int max = 0;\\n        for(int i = 0; i < nums.length ; i++) if(nums[i] > max) max = nums[i];  \\n        \\n        int[] arr = new int[max+1];  \\n        for(int i = 0; i < nums.length ; i++) arr[nums[i]] += 1;\\n        \\n        int temp = 0;        \\n        int i = 0, j = max;\\n         while(i <= j){\\n             \\n            if(arr[i] == 0){\\n                i++;\\n                continue;\\n            } \\n            if(arr[j] == 0){\\n                j--;\\n                continue;\\n            }  \\n            if(arr[i] != 0 && arr[j] != 0){\\n                if(i+j > temp) temp = i+j;\\n                arr[i]--;\\n                arr[j]--;                \\n            }\\n        }        \\n        return temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1240098,
                "title": "simple-python-3-using-sorting",
                "content": "Sort the given array and find the maximum sum of (min,max) pairs.\\n\\n```\\ndef minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans=0\\n        c=len(nums)-1\\n        for i in range(len(nums)//2):\\n            ans=max(ans,nums[i]+nums[c])\\n            c-=1\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        ans=0\\n        c=len(nums)-1\\n        for i in range(len(nums)//2):\\n            ans=max(ans,nums[i]+nums[c])\\n            c-=1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1617303,
                "title": "java-binary-search-using-count-array-no-sorting-99-faster-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int[] count = new int[100001];\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        for(int i : nums) {\\n            count[i]++;\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int low = min, high = max;\\n        max = Integer.MIN_VALUE;\\n        while(low <= high) {\\n            if(count[low] == 0) low++; \\n            else if(count[high] == 0) high--;\\n            else {\\n                max = Math.max(low + high, max);\\n                count[low]--;\\n                count[high]--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int[] count = new int[100001];\\n        int max = Integer.MIN_VALUE;\\n        int min = Integer.MAX_VALUE;\\n        for(int i : nums) {\\n            count[i]++;\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int low = min, high = max;\\n        max = Integer.MIN_VALUE;\\n        while(low <= high) {\\n            if(count[low] == 0) low++; \\n            else if(count[high] == 0) high--;\\n            else {\\n                max = Math.max(low + high, max);\\n                count[low]--;\\n                count[high]--;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1243428,
                "title": "python-greedy-with-explanation",
                "content": "A = sorted(nums)\\n\\nAssume there is an optimal solution **S** composed by pairs `P1, P2, P3, P4...`\\nWithout generality assuming that A[0], A[-1] reside in pairs P1, P2 respectively.\\n`P1 = (A[0], A[i]), P2 = (A[j], A[-1]) where A[0] <= A[i], A[j] <= A[-1]`\\n\\nReplace P1, P2 with `P1\\' = (A[0], A[-1]), P2\\' = (A[i], A[j])` and I have **S\\'** = **P1\\', P2\\'**, P3, P4...... which **doesn\\'t generate a worse solution** \\n\\n# Proof:\\n1. Sum(P2) >= Sum(P1) , `A[-1] >= A[i] and A[j] >= A[0] => A[-1] + A[j] >= A[i] + A[0]` \\n2. Sum(P2) >= Sum(P1\\'), `A[j] >= A[0]                              => A[j] + A[-1]  >= A[0] + A[-1]`\\n3. Sum(P2) >= Sum(P2\\'), `A[-1] >= A[i]                             => A[j]  + A[-1] >= A[i] + A[j]`\\n\\n=> Sum(P1) <= Sum(P2) and P1\\' and P2\\' make no bigger sum than P2, such adjustment doesn\\'t generate a worse solution\\n\\n-----------------\\n\\nFollow the procedure, we can adjust the optimal solution S to greedy solution G where G is composed by `(A[0], A[-1]), (A[1], A[-2]), (A[2], A[-3]).....` And G should be no worse than S.\\n\\nSince S is the optimal solution and G is no worse than it, G should be one of the optimal solution, too.\\n\\n```\\nclass Solution(object):\\n    def minPairSum(self, nums):\\n        \"\"\" \\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        return max(nums[i] + nums[-(i + 1)] for i in range(len(nums) // 2))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minPairSum(self, nums):\\n        \"\"\" \\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        return max(nums[i] + nums[-(i + 1)] for i in range(len(nums) // 2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238690,
                "title": "c-o-nlogn-easy-solution",
                "content": "The idea behind the approach is to arrange the array in such a manner that the maximum number is added to the minimum number. Thus the array is sorted so as to easily add the maximum number with minimum one, 2nd max to 2nd min...and so on.\\n\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& arr) \\n    {\\n        sort(arr.begin(), arr.end());\\n        int sum = INT_MIN;\\n        int len = arr.size();\\n        for(int i=0; i<len/2; i++)\\n        {\\n            int sub = arr[i] + arr[len-1-i];\\n            if(sum < sub)\\n                sum = sub;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& arr) \\n    {\\n        sort(arr.begin(), arr.end());\\n        int sum = INT_MIN;\\n        int len = arr.size();\\n        for(int i=0; i<len/2; i++)\\n        {\\n            int sub = arr[i] + arr[len-1-i];\\n            if(sum < sub)\\n                sum = sub;\\n        }\\n        \\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2770711,
                "title": "precise-c-minimized-o-n-logn-time-o-1-space",
                "content": "Sort the array and then add max element with the min element to get minimized pair sum, while doing so you could parallelly check the max of these pairs to reduce the code length.\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int res=INT_MIN;\\n        for(int i=0;i<(nums.size()+1)/2;i++)\\n            res=max(res,nums[i]+nums[nums.size()-1-i]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int res=INT_MIN;\\n        for(int i=0;i<(nums.size()+1)/2;i++)\\n            res=max(res,nums[i]+nums[nums.size()-1-i]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406699,
                "title": "easy-5-line-java-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int output = Integer.MIN_VALUE;\\n        \\n\\t\\t//This is greedy, so n/2 pairs must be from start and end and move inwards\\n        for(int i=0, j=nums.length - 1; i<nums.length/2; i++, j--)\\n        {\\n            output = Math.max(output, nums[i] + nums[j]);\\n        }\\n        \\n        return output;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        \\n        int output = Integer.MIN_VALUE;\\n        \\n\\t\\t//This is greedy, so n/2 pairs must be from start and end and move inwards\\n        for(int i=0, j=nums.length - 1; i<nums.length/2; i++, j--)\\n        {\\n            output = Math.max(output, nums[i] + nums[j]);\\n        }\\n        \\n        return output;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380693,
                "title": "simple-java-o-n-solution-runtime-7ms-beats-100",
                "content": "So to minimize the maximum sum of pair, we need to pair small elements with large elements,\\nfirst step\\n----------\\nstore the occurence of number and find the smallest and larget element.\\n\\nsecond step\\n-----------\\n```\\nint start = min; // indexOfSmallestElement \\nint end = max; // indexOfLargestElement\\nmaxPair = 0;\\nwhile(start < end) {\\n\\tif(count[start] == 0) move to start + 1.\\n\\telse if(count[end] == 0) move to end - 1;\\n\\telse { \\n\\t    we can pair start and end.\\n\\t\\tupdate the maxPair;\\n\\t\\tthen we will update the count. and one with lower occurence will be fully used.\\n\\t}\\n}\\n\\nif(count[start] > 1) { // means we can pair start with start\\n\\tupdate the maxPair\\n}\\nelse if(count[end] > 1) { // we can pair end with end\\n\\tupdate the maxPair\\n}\\n\\nreturn maxPair\\n```\\n\\n\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        // Arrays.sort(nums);\\n        // int max = 0;\\n        // int n = nums.length;\\n        // int temp = n / 2;\\n        // for(int i = 0, j = n - 1; i < temp; i++, j--) {\\n        //     max = Math.max(nums[i] + nums[j], max);\\n        // }\\n        return solution2(nums);\\n    }\\n    \\n    public int solution2(int[] nums) {\\n        int[] arr = new int[100001];\\n        int max = 0;\\n        int min = 100001;\\n        for(int i : nums) {\\n            arr[i]++;\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int start = min; \\n        int end = max;\\n        max = 0;\\n        while(start < end) {\\n            if(arr[start] == 0) start++; \\n            else if(arr[end] == 0) end--;\\n            else {\\n                max = Math.max(start + end, max);\\n                int temp = Math.min(arr[start], arr[end]);\\n                arr[start] -= temp;\\n                arr[end] -= temp;\\n            }\\n        }\\n        \\n        if(arr[start] > 1) {\\n            max = Math.max(max, 2 * start);\\n        }\\n        else if(arr[end] > 1) {\\n            max = Math.max(max, 2 * end);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint start = min; // indexOfSmallestElement \\nint end = max; // indexOfLargestElement\\nmaxPair = 0;\\nwhile(start < end) {\\n\\tif(count[start] == 0) move to start + 1.\\n\\telse if(count[end] == 0) move to end - 1;\\n\\telse { \\n\\t    we can pair start and end.\\n\\t\\tupdate the maxPair;\\n\\t\\tthen we will update the count. and one with lower occurence will be fully used.\\n\\t}\\n}\\n\\nif(count[start] > 1) { // means we can pair start with start\\n\\tupdate the maxPair\\n}\\nelse if(count[end] > 1) { // we can pair end with end\\n\\tupdate the maxPair\\n}\\n\\nreturn maxPair\\n```\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        // Arrays.sort(nums);\\n        // int max = 0;\\n        // int n = nums.length;\\n        // int temp = n / 2;\\n        // for(int i = 0, j = n - 1; i < temp; i++, j--) {\\n        //     max = Math.max(nums[i] + nums[j], max);\\n        // }\\n        return solution2(nums);\\n    }\\n    \\n    public int solution2(int[] nums) {\\n        int[] arr = new int[100001];\\n        int max = 0;\\n        int min = 100001;\\n        for(int i : nums) {\\n            arr[i]++;\\n            max = Math.max(max, i);\\n            min = Math.min(min, i);\\n        }\\n        int start = min; \\n        int end = max;\\n        max = 0;\\n        while(start < end) {\\n            if(arr[start] == 0) start++; \\n            else if(arr[end] == 0) end--;\\n            else {\\n                max = Math.max(start + end, max);\\n                int temp = Math.min(arr[start], arr[end]);\\n                arr[start] -= temp;\\n                arr[end] -= temp;\\n            }\\n        }\\n        \\n        if(arr[start] > 1) {\\n            max = Math.max(max, 2 * start);\\n        }\\n        else if(arr[end] > 1) {\\n            max = Math.max(max, 2 * end);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2371016,
                "title": "2-simple-solutions-using-sorting-and-priority-queue-c-solution",
                "content": "1 - Taking **maxheap** to geting always the maximum element in the array \\n      **minheap** to getting the minimum element in the array.\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        priority_queue<int> maxHeap(nums.begin(),nums.end());\\n        priority_queue<int,vector<int>,greater<int>> minHeap(nums.begin(),nums.end());\\n        int n = nums.size()/2;\\n        int ans = INT_MIN;\\n        while(n--){\\n            int first = maxHeap.top();\\n            maxHeap.pop();\\n            int second = minHeap.top();\\n            minHeap.pop();\\n            ans = max(ans,first+second);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n2 - Simple **sort** the array and always take the **first(minimum)** and **last(maximum)** element from the sorted array.\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = INT_MIN;\\n        int n = nums.size();\\n        int i = 0;\\n        int k = n/2;\\n        while(k--){\\n            ans = max(ans,nums[i] + nums[n-1-i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        priority_queue<int> maxHeap(nums.begin(),nums.end());\\n        priority_queue<int,vector<int>,greater<int>> minHeap(nums.begin(),nums.end());\\n        int n = nums.size()/2;\\n        int ans = INT_MIN;\\n        while(n--){\\n            int first = maxHeap.top();\\n            maxHeap.pop();\\n            int second = minHeap.top();\\n            minHeap.pop();\\n            ans = max(ans,first+second);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans = INT_MIN;\\n        int n = nums.size();\\n        int i = 0;\\n        int k = n/2;\\n        while(k--){\\n            ans = max(ans,nums[i] + nums[n-1-i]);\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087728,
                "title": "python-easy-to-understand-code-beginner-friendly-brute-force",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        pair_sum = []\\n        nums.sort()\\n        for i in range(len(nums)//2):\\n            pair_sum.append(nums[i]+nums[len(nums)-i-1])\\n        return max(pair_sum)\\n```\\nTo minimize the maximum pair sum , first sort the list , then add first and last element of this sorted list (i.e. ,  make pair of highest and lowest element in the list ) as in any other pair of elements the highest element will pair up with an element greater than the lowest element - making the maximum sum greater.\\nTherefore pair the 1st and last element , 2nd and second last element and so on.... , and store the sum in an array ( or list ) .\\nReturn the max(arr) to get the required answer.\\n.\\n.\\n.\\n.\\n.\\nPlease Upvote if you find this post useful...",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        pair_sum = []\\n        nums.sort()\\n        for i in range(len(nums)//2):\\n            pair_sum.append(nums[i]+nums[len(nums)-i-1])\\n        return max(pair_sum)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241257,
                "title": "c-simple-is-this-really-a-medium-question",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int res=0;\\n        for(int i=0,j=nums.size()-1;i<j;++i,--j)\\n            res=max(res,nums[i]+nums[j]);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int res=0;\\n        for(int i=0,j=nums.size()-1;i<j;++i,--j)\\n            res=max(res,nums[i]+nums[j]);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238670,
                "title": "a-few-solutions",
                "content": "Sort the input array `A`, then perform a linear scan of each pair `\\uD83D\\uDC49 i..j \\uD83D\\uDC48`, ie. from the outermost to innermost.\\n\\n* Note: This question is similar to [1874. Minimize Product Sum of Two Arrays](https://leetcode.com/problems/minimize-product-sum-of-two-arrays/discuss/1243346/a-few-solutions).\\n\\n---\\n\\n**Procedural Solutions:**\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minPairSum(A: IntArray): Int {\\n        var best = -(1e9 + 7).toInt()\\n        A.sort()\\n        var N = A.size\\n        var i = 0\\n        var j = N - 1\\n        while (i < j)\\n            best = Math.max(best, A[i++] + A[j--])\\n        return best\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minPairSum = (A, best = -Infinity) => {\\n    A.sort((a, b) => a - b);\\n    let N = A.length,\\n        i = 0,\\n        j = N - 1;\\n    while (i < j)\\n        best = Math.max(best, A[i++] + A[j--]);\\n    return best;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minPairSum(self, A: List[int], best = -int(1e9 + 7)) -> int:\\n        A.sort()\\n        N = len(A)\\n        i = 0\\n        j = N - 1\\n        while i < j:\\n            best = max(best, A[i] + A[j]); i += 1; j -= 1\\n        return best\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn min_pair_sum(A_: VI) -> i32 {\\n        let mut best = -1000000007;\\n        let mut A = A_.clone();\\n        A.sort();\\n        let (mut i, mut j) = (0, A.len() - 1);\\n        while i < j {\\n            best = max(best, A[i] + A[j]); i += 1; j -= 1;\\n        }\\n        return best\\n    }\\n}\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minPairSum(VI& A, int best = -(1e9 + 7)) {\\n        sort(A.begin(), A.end());\\n        int N = A.size(),\\n            i = 0,\\n            j = N - 1;\\n        while (i < j)\\n            best = max(best, A[i++] + A[j--]);\\n        return best;\\n    }\\n};\\n```\\n\\n---\\n\\n**Functional Solutions:** same idea as above to sum pairs; take `A` as sorted left/right halves `L` and `R` correspondingly, then zip `L` with reversed `R` to find the maximum accumulated pair sum.\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun minPairSum(A: IntArray): Int {\\n        A.sort()\\n        var N = A.size\\n        var K = N / 2\\n        var (L, R) = A.toMutableList().chunked(K)\\n        return L.zip(R.asReversed()).map{ (a, b) -> a + b }!!.max()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet minPairSum = A => {\\n    A.sort((a, b) => a - b);\\n    let N = A.length,\\n        K = Math.floor(N / 2);\\n    let L = A.slice(0, K),\\n        R = A.slice(K, N).reverse();\\n    return Math.max(..._.zip(L, R).map(([a, b]) => a + b));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def minPairSum(self, A: List[int], best = -int(1e9 + 7)) -> int:\\n        A.sort()\\n        N = len(A)\\n        K = N // 2\\n        L, R = A[:K], A[K:][::-1]\\n        return max(a + b for a, b in zip(L, R))\\n```\\n\\n*Rust*\\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn min_pair_sum(A_: VI) -> i32 {\\n        let mut A = A_.clone();\\n        A.sort();\\n        let N = A.len();\\n        let K = N / 2;\\n        A[0..K].iter().zip(A[K..N].iter().rev()).map(|(a, b)| a + b).max().unwrap()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun minPairSum(A: IntArray): Int {\\n        var best = -(1e9 + 7).toInt()\\n        A.sort()\\n        var N = A.size\\n        var i = 0\\n        var j = N - 1\\n        while (i < j)\\n            best = Math.max(best, A[i++] + A[j--])\\n        return best\\n    }\\n}\\n```\n```\\nlet minPairSum = (A, best = -Infinity) => {\\n    A.sort((a, b) => a - b);\\n    let N = A.length,\\n        i = 0,\\n        j = N - 1;\\n    while (i < j)\\n        best = Math.max(best, A[i++] + A[j--]);\\n    return best;\\n};\\n```\n```\\nclass Solution:\\n    def minPairSum(self, A: List[int], best = -int(1e9 + 7)) -> int:\\n        A.sort()\\n        N = len(A)\\n        i = 0\\n        j = N - 1\\n        while i < j:\\n            best = max(best, A[i] + A[j]); i += 1; j -= 1\\n        return best\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn min_pair_sum(A_: VI) -> i32 {\\n        let mut best = -1000000007;\\n        let mut A = A_.clone();\\n        A.sort();\\n        let (mut i, mut j) = (0, A.len() - 1);\\n        while i < j {\\n            best = max(best, A[i] + A[j]); i += 1; j -= 1;\\n        }\\n        return best\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    int minPairSum(VI& A, int best = -(1e9 + 7)) {\\n        sort(A.begin(), A.end());\\n        int N = A.size(),\\n            i = 0,\\n            j = N - 1;\\n        while (i < j)\\n            best = max(best, A[i++] + A[j--]);\\n        return best;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    fun minPairSum(A: IntArray): Int {\\n        A.sort()\\n        var N = A.size\\n        var K = N / 2\\n        var (L, R) = A.toMutableList().chunked(K)\\n        return L.zip(R.asReversed()).map{ (a, b) -> a + b }!!.max()!!\\n    }\\n}\\n```\n```\\nlet minPairSum = A => {\\n    A.sort((a, b) => a - b);\\n    let N = A.length,\\n        K = Math.floor(N / 2);\\n    let L = A.slice(0, K),\\n        R = A.slice(K, N).reverse();\\n    return Math.max(..._.zip(L, R).map(([a, b]) => a + b));\\n};\\n```\n```\\nclass Solution:\\n    def minPairSum(self, A: List[int], best = -int(1e9 + 7)) -> int:\\n        A.sort()\\n        N = len(A)\\n        K = N // 2\\n        L, R = A[:K], A[K:][::-1]\\n        return max(a + b for a, b in zip(L, R))\\n```\n```\\ntype VI = Vec<i32>;\\nuse std::cmp::max;\\nimpl Solution {\\n    pub fn min_pair_sum(A_: VI) -> i32 {\\n        let mut A = A_.clone();\\n        A.sort();\\n        let N = A.len();\\n        let K = N / 2;\\n        A[0..K].iter().zip(A[K..N].iter().rev()).map(|(a, b)| a + b).max().unwrap()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3666346,
                "title": "best-o-nlogn-solution",
                "content": "# Approach\\nSort\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort (nums.begin(), nums.end());\\n        int i = 0, j = n - 1;\\n        int ans = 0;\\n        while (i < n && j >= 0) {\\n            ans = max (nums[i] + nums[j], ans);\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n = nums.size();\\n        sort (nums.begin(), nums.end());\\n        int i = 0, j = n - 1;\\n        int ans = 0;\\n        while (i < n && j >= 0) {\\n            ans = max (nums[i] + nums[j], ans);\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872919,
                "title": "easy-c-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        int i=0;int j=nums.size()-1;\\n        while(i<j){\\n            sum=max(nums[i]+nums[j],sum) ;\\n            i++;\\n            j--;\\n                 \\n        }\\n        return sum;\\n    }     \\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int sum=0;\\n        int i=0;int j=nums.size()-1;\\n        while(i<j){\\n            sum=max(nums[i]+nums[j],sum) ;\\n            i++;\\n            j--;\\n                 \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1725067,
                "title": "python-sort-and-two-pointers",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        \\n        nums.sort()\\n        i = 0\\n        j = len(nums) - 1\\n        \\n        res = 0\\n        \\n        while i < j:\\n            res = max(res, nums[i] + nums[j])\\n            i += 1\\n            j -= 1\\n        \\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        \\n        nums.sort()\\n        i = 0\\n        j = len(nums) - 1\\n        \\n        res = 0\\n        \\n        while i < j:\\n            res = max(res, nums[i] + nums[j])\\n            i += 1\\n            j -= 1\\n        \\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1688360,
                "title": "python-two-liner-77-memory-72-faster",
                "content": "```\\ndef minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max([nums[i]+nums[-1-i] for i in range(len(nums)//2)])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\ndef minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max([nums[i]+nums[-1-i] for i in range(len(nums)//2)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1266185,
                "title": "java-solution-plus-proof",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {        \\n        Arrays.sort(nums);\\n\\n        int max = 0;\\n        int n = nums.length;\\n        \\n        for(int i = 0 ; i < n/2 ; i++){\\n            if(nums[i] + nums[n-i-1] > max){\\n                max = nums[i] + nums[n-i-1];\\n            }\\n        }\\n        return max;\\n        \\n\\t\\t//this problem is the Minimize Maximum Pair Sum in Array leetcode problem,\\n\\t\\t//basically, you want to pair up all numbers in an array, such that the largest sum of pairs\\n\\t\\t//made is as small as it could possibly be, and return that smallest maximum pair sum\\n        //the code above works because we can prove the following\\n        \\n        //let a,b,c,d be ints, let a < b < c < d, we must show that\\n        // max(a+d,b+c) < max(a+c,b+d)\\n\\t\\t//what we mean to do by this is show\\n\\t\\t//that the maximum of pairing the smallest and largest integers is strictly\\n\\t\\t//less than pairing in any other way than twin pairing (int at position i \\n\\t\\t// is matched with int at position n-1-i)\\n        \\n\\t\\t//Given: \\n\\t\\t//let a,b,c,d be ints\\n\\t\\t//let a < b < c < d\\n\\t\\t//Prove the following: \\n\\t\\t//max(a+d,b+c) < max(a+c,b+d)\\n        \\n\\t\\t//well b+d > a+c always so this becomes\\n        // max(a+d,b+c) < b+d\\n        \\n        //then a+d < b+d  (because a < b) , \\n        // and b+c < b+d  (because c < d)\\n        \\n        //so  max(a+d,b+c) < b+d must always be true,\\n        // if this is true, then the smallest maximum pairing can only be found by pairing\\n\\t\\t//each int with its \\'twin\\' in order\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {        \\n        Arrays.sort(nums);\\n\\n        int max = 0;\\n        int n = nums.length;\\n        \\n        for(int i = 0 ; i < n/2 ; i++){\\n            if(nums[i] + nums[n-i-1] > max){\\n                max = nums[i] + nums[n-i-1];\\n            }\\n        }\\n        return max;\\n        \\n\\t\\t//this problem is the Minimize Maximum Pair Sum in Array leetcode problem,\\n\\t\\t//basically, you want to pair up all numbers in an array, such that the largest sum of pairs\\n\\t\\t//made is as small as it could possibly be, and return that smallest maximum pair sum\\n        //the code above works because we can prove the following\\n        \\n        //let a,b,c,d be ints, let a < b < c < d, we must show that\\n        // max(a+d,b+c) < max(a+c,b+d)\\n\\t\\t//what we mean to do by this is show\\n\\t\\t//that the maximum of pairing the smallest and largest integers is strictly\\n\\t\\t//less than pairing in any other way than twin pairing (int at position i \\n\\t\\t// is matched with int at position n-1-i)\\n        \\n\\t\\t//Given: \\n\\t\\t//let a,b,c,d be ints\\n\\t\\t//let a < b < c < d\\n\\t\\t//Prove the following: \\n\\t\\t//max(a+d,b+c) < max(a+c,b+d)\\n        \\n\\t\\t//well b+d > a+c always so this becomes\\n        // max(a+d,b+c) < b+d\\n        \\n        //then a+d < b+d  (because a < b) , \\n        // and b+c < b+d  (because c < d)\\n        \\n        //so  max(a+d,b+c) < b+d must always be true,\\n        // if this is true, then the smallest maximum pairing can only be found by pairing\\n\\t\\t//each int with its \\'twin\\' in order\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3468697,
                "title": "easy-to-understand-c-two-pointer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& n) {\\n        int ans=0,l=0,r=n.size()-1;\\n        sort(n.begin(),n.end());\\n        for(int i=0;i<n.size()/2;i++){\\n           int p=(n[l]+n[r]);\\n           l++;\\n           r--;\\n           ans=max(p,ans);\\n        }\\n    return ans;}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& n) {\\n        int ans=0,l=0,r=n.size()-1;\\n        sort(n.begin(),n.end());\\n        for(int i=0;i<n.size()/2;i++){\\n           int p=(n[l]+n[r]);\\n           l++;\\n           r--;\\n           ans=max(p,ans);\\n        }\\n    return ans;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3241450,
                "title": "use-pointers-logic-python3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        list2=[]\\n        left,right=0,len(nums)-1\\n        while left<right:\\n            list2.append(nums[left]+nums[right])\\n            left+=1\\n            right-=1\\n        return max(list2)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        list2=[]\\n        left,right=0,len(nums)-1\\n        while left<right:\\n            list2.append(nums[left]+nums[right])\\n            left+=1\\n            right-=1\\n        return max(list2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3191882,
                "title": "easy-to-understand-two-pointers-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Sort the vector and then pair 1st and last element together and increase the counter till we reach the mid. While traversing also calculate the pair sum and store the maximum in one variable.\\n \\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = INT_MIN;\\n\\n        sort(nums.begin() , nums.end());\\n        for(int i=0; i<n/2; i++)\\n        {\\n            int pair = nums[i] + nums[n-1-i];\\n            ans = max(ans, pair);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n = nums.size();\\n        int ans = INT_MIN;\\n\\n        sort(nums.begin() , nums.end());\\n        for(int i=0; i<n/2; i++)\\n        {\\n            int pair = nums[i] + nums[n-1-i];\\n            ans = max(ans, pair);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3099494,
                "title": "java-solution",
                "content": ">\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int start = 0, sum = 0, maxSum = 0;\\n        int end = nums.length - 1;\\n\\n        Arrays.sort(nums);\\n\\n        while (start < end) {\\n            sum = nums[start] + nums[end];\\n\\n            start++;\\n            end--;\\n\\n            if (sum > maxSum) {\\n                maxSum = sum;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int start = 0, sum = 0, maxSum = 0;\\n        int end = nums.length - 1;\\n\\n        Arrays.sort(nums);\\n\\n        while (start < end) {\\n            sum = nums[start] + nums[end];\\n\\n            start++;\\n            end--;\\n\\n            if (sum > maxSum) {\\n                maxSum = sum;\\n            }\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335735,
                "title": "fast-javascript-solution-explanation",
                "content": "1. Sort the numbers in `nums`.\\n2. Have two pointers `i = 0` and `j = nums.length - 1` so that you pair the next smallest number with the next largest number during each iteration\\n3. Sum the pairs before incrementing the pointer to the small half of `nums` and decrementing the pointer to the large half of `nums`.\\n4. Compare the result to the current maximum value encountered so far.\\n5. Return the max value.\\n\\nExample:\\n[3, 5, 2, 3] after sorting is [2, 3, 3, 5]\\n\\n[2, 3, 3, 5]\\n-i--------j max is -Infinity\\nfirst pair sum is (2 + 5 = 7)\\n7 > -Infinity, so update max to 7\\n\\n[2, 3, 3, 5]\\n----i--j---- max is 7\\nsecond pair sum is (3 + 3 = 6)\\n6 < 7, so we don\\'t update max since its already larger\\n\\n```\\nvar minPairSum = function(nums) {\\n    nums.sort((a, b) => a-b);\\n    let i = 0, j = nums.length - 1;\\n    let max = -Infinity;\\n    while (i < j) {\\n        max = Math.max(max, nums[i++] + nums[j--]);\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar minPairSum = function(nums) {\\n    nums.sort((a, b) => a-b);\\n    let i = 0, j = nums.length - 1;\\n    let max = -Infinity;\\n    while (i < j) {\\n        max = Math.max(max, nums[i++] + nums[j--]);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1245286,
                "title": "c-binary-search-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isSafe(vector<int>& nums,int m,int n){\\n        int temp=0;\\n        int x = 0 , y = n-1;\\n        while(x<y){\\n            if(nums[x]+nums[y] > m) return false;\\n            x++;\\n            y--;\\n        }\\n        return true;\\n    }\\n    \\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l = nums[0]+nums[1]; // Minimum possible value of pair sum\\n        int n = nums.size();\\n        int r = nums[n-1]+nums[n-2]; // // Maximum possible value of pair sum\\n        int res = r;\\n        while(l<=r){\\n            int m = l + (r-l)/2; // To avoid over flow\\n            if(isSafe(nums,m,n)){ // if mid is safe then all elements from [mid.....r] are also safe\\n                res = min(res,m);\\n                r = m-1;\\n            }else{\\n                l = m+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isSafe(vector<int>& nums,int m,int n){\\n        int temp=0;\\n        int x = 0 , y = n-1;\\n        while(x<y){\\n            if(nums[x]+nums[y] > m) return false;\\n            x++;\\n            y--;\\n        }\\n        return true;\\n    }\\n    \\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l = nums[0]+nums[1]; // Minimum possible value of pair sum\\n        int n = nums.size();\\n        int r = nums[n-1]+nums[n-2]; // // Maximum possible value of pair sum\\n        int res = r;\\n        while(l<=r){\\n            int m = l + (r-l)/2; // To avoid over flow\\n            if(isSafe(nums,m,n)){ // if mid is safe then all elements from [mid.....r] are also safe\\n                res = min(res,m);\\n                r = m-1;\\n            }else{\\n                l = m+1;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238797,
                "title": "sorting-two-pointers-technique-java-easy-o-n-log-n",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int left = 0;\\n        int right = nums.length - 1;\\n        int max = Integer.MIN_VALUE;\\n        while(left < right) {\\n            int sum = nums[left] + nums[right];\\n            max = Math.max(sum, max);\\n            left++;\\n            right--;\\n        }\\n        return max;   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int left = 0;\\n        int right = nums.length - 1;\\n        int max = Integer.MIN_VALUE;\\n        while(left < right) {\\n            int sum = nums[left] + nums[right];\\n            max = Math.max(sum, max);\\n            left++;\\n            right--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3832226,
                "title": "c-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    Sorting\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n*log(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n/2; i++) {\\n            ans = max(ans, nums[i] + nums[n-i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n = nums.size(), ans = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i=0; i<n/2; i++) {\\n            ans = max(ans, nums[i] + nums[n-i-1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365706,
                "title": "simple-approach-c",
                "content": "\\n- The main question is In which order we should be make pairs of nums?\\n- You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n\\n---\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n    \\n    sort(nums.begin(),nums.end());\\n\\n    int l=0 , r=nums.size()-1 , res=0;\\n\\n    while(l<r){\\n        \\n        res = max(res,nums[l]+nums[r]);\\n        l++;\\n        r--;\\n\\n    }\\n    return res;\\n    \\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n    \\n    sort(nums.begin(),nums.end());\\n\\n    int l=0 , r=nums.size()-1 , res=0;\\n\\n    while(l<r){\\n        \\n        res = max(res,nums[l]+nums[r]);\\n        l++;\\n        r--;\\n\\n    }\\n    return res;\\n    \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279827,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe best way to find minimize pair sum is to add min no. with maximum number.\\nSo, first sort the array and add first and last element.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        //the best way to find minimize pair sum is to add min no. with maximum number.\\n        int maxSum = 0, sum = 0;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++){\\n            sum = (nums[i] + nums[n - 1 - i]);\\n            maxSum = Math.max(maxSum, sum);\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        //the best way to find minimize pair sum is to add min no. with maximum number.\\n        int maxSum = 0, sum = 0;\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        for(int i = 0; i < n; i++){\\n            sum = (nums[i] + nums[n - 1 - i]);\\n            maxSum = Math.max(maxSum, sum);\\n        }\\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233158,
                "title": "easy-solution-using-sorting",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def minPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        low=0\\n        high=len(nums)-1\\n        mn=0\\n        while low<high:\\n            mn=max(mn,nums[low]+nums[high])\\n            low+=1\\n            high-=1\\n        return mn\\n```",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution(object):\\n    def minPairSum(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: int\\n        \"\"\"\\n        nums.sort()\\n        low=0\\n        high=len(nums)-1\\n        mn=0\\n        while low<high:\\n            mn=max(mn,nums[low]+nums[high])\\n            low+=1\\n            high-=1\\n        return mn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3229755,
                "title": "beats-100-simplest-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n       \\n        sort(nums.begin(),nums.end());\\n        int res = 0  , i = 0, j = nums.size()-1; \\n        while(i<j){\\n            res = max(res,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        return res; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n       \\n        sort(nums.begin(),nums.end());\\n        int res = 0  , i = 0, j = nums.size()-1; \\n        while(i<j){\\n            res = max(res,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        return res; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3214618,
                "title": "easy-sorting-approach-100-acceptance",
                "content": "# Intuition : sorting and finding min,max sum\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,nums[i]+nums[n-i-1]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int maxi=INT_MIN;\\n        for(int i=0;i<n;i++){\\n            maxi=max(maxi,nums[i]+nums[n-i-1]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163868,
                "title": "c-sorting-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i < (nums.size()>>1); i++){\\n            ans = max(ans,nums[i]+nums[nums.size()-1-i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(),nums.end());\\n        for(int i = 0; i < (nums.size()>>1); i++){\\n            ans = max(ans,nums[i]+nums[nums.size()-1-i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3160063,
                "title": "best-c-solution",
                "content": "# Intuition\\nTake the smallest and largest number pair and return the maximum sum out of them.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int lo=0, hi=nums.size()-1,ans=-1;\\n        while(lo<hi){\\n            ans=max(ans,nums[lo++]+nums[hi--]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int lo=0, hi=nums.size()-1,ans=-1;\\n        while(lo<hi){\\n            ans=max(ans,nums[lo++]+nums[hi--]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021212,
                "title": "java-solution-beats-92-of-other-solutions",
                "content": "# Intuition\\nMinimizing max pair is basically sum of starting value and ending values in a sorted array of nums. i.e. if sorted array nums is [a,b,c,d], we need to return Min(a+d, b+c).\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int maxPairSum=0;\\n        for(int i=0;i<=nums.length/2;i++){\\n            maxPairSum=Math.max(maxPairSum, nums[i] + nums[nums.length-1-i] );\\n        }\\n        return maxPairSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int maxPairSum=0;\\n        for(int i=0;i<=nums.length/2;i++){\\n            maxPairSum=Math.max(maxPairSum, nums[i] + nums[nums.length-1-i] );\\n        }\\n        return maxPairSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021200,
                "title": "java-solution-beats-80-easy-to-understand-6-lines-of-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int maxPairSum=0;\\n        for(int i=0;i<nums.length;i++){\\n            maxPairSum=Math.max(maxPairSum, nums[i] + nums[nums.length-1-i] );\\n        }\\n        return maxPairSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int maxPairSum=0;\\n        for(int i=0;i<nums.length;i++){\\n            maxPairSum=Math.max(maxPairSum, nums[i] + nums[nums.length-1-i] );\\n        }\\n        return maxPairSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837059,
                "title": "cpp-simple-solution",
                "content": "# Approach\\nSimply sort the vector use 2 pointers, one pointing the start element and another one at last element of the sorted array then find the maximum sum pair store it in a variable and return it.\\n# Complexity\\n- Time complexity: O(n*logn), 93% faster than Online Cpp Submissions\\n\\n- Space complexity: O(1), 22.20% better than Online Cpp Submissions\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& n) {\\n        int mx=INT_MIN; \\n        sort(n.begin(),n.end());\\n        int i=0,j=n.size()-1;\\n        while(i<j)\\n        {\\n            mx=max(mx,(n[i]+n[j]));\\n            i++;\\n            j--;\\n        }\\n   return mx; }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& n) {\\n        int mx=INT_MIN; \\n        sort(n.begin(),n.end());\\n        int i=0,j=n.size()-1;\\n        while(i<j)\\n        {\\n            mx=max(mx,(n[i]+n[j]));\\n            i++;\\n            j--;\\n        }\\n   return mx; }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2802418,
                "title": "intuitive-and-easy-4-lines-of-code-c-solution",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs we are asked to find the pair whose sum is maximum among all pairs of Nums and the overall sum of that pair must be minimum. So Now, we know that we are required to minimise the Overall sum, for that we will have to first sort(ascending) the array. Then, for minimizing the sum of pairs we will choose one element from starting(minimum) and one from ending(maximum). So that Overall sum of that pair become as minimum as possible..... Then, among all these pairs, we will choose the one which will have maximum sum(among pairs).\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSo, First we will sort the array, then we will make 2 pointers low(from starting index = 0) and high(from ending index = n-1).\\nNow, we will make pairs (nums[low++], nums[high--]).So, the pair having maximum sum among all these pairs will be our answer........\\n# Complexity\\n- Time complexity:  O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ --> \\n\\n- Space complexity:  O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int low = 0, high = nums.size()-1, maxi = INT_MIN;\\n        while(low < high)  maxi = max(maxi, nums[low++] + nums[high--];\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int low = 0, high = nums.size()-1, maxi = INT_MIN;\\n        while(low < high)  maxi = max(maxi, nums[low++] + nums[high--];\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2791629,
                "title": "java-solution",
                "content": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum[]= new int[nums.length/2];\\n        int s=0,max=0,j=nums.length-1;\\n        for(int i=0;i<nums.length/2;i++){\\n            s=nums[i]+nums[j--];\\n            if(s>max)\\n                max=s;\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum[]= new int[nums.length/2];\\n        int s=0,max=0,j=nums.length-1;\\n        for(int i=0;i<nums.length/2;i++){\\n            s=nums[i]+nums[j--];\\n            if(s>max)\\n                max=s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2739587,
                "title": "c-simple-solution",
                "content": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int maxi=INT_MIN;\\n        vector<int>v;\\n        int n=nums.size();\\n        for(int i=0;i<n/2;i++)\\n        {\\n            v.push_back(nums[i]+nums[n-1-i]);\\n            maxi=max(maxi,v[i]);\\n        }\\n        return maxi;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int maxi=INT_MIN;\\n        vector<int>v;\\n        int n=nums.size();\\n        for(int i=0;i<n/2;i++)\\n        {\\n            v.push_back(nums[i]+nums[n-1-i]);\\n            maxi=max(maxi,v[i]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2636906,
                "title": "c-easy-to-understand-detailed",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n      int maxi=0; int n=nums.size(); int i=0; int j=n-1;\\n      sort(nums.begin(),nums.end());\\n       for(;i<j;i++,j--)\\n        maxi = max(maxi, nums[i]+nums[j]);\\n        return maxi;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n      int maxi=0; int n=nums.size(); int i=0; int j=n-1;\\n      sort(nums.begin(),nums.end());\\n       for(;i<j;i++,j--)\\n        maxi = max(maxi, nums[i]+nums[j]);\\n        return maxi;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2600232,
                "title": "c-easy-solution-using-sorting-and-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size()-1;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size()/2;i++,n--){\\n            maxi=max(maxi,nums[i]+nums[n]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size()-1;\\n        int maxi=INT_MIN;\\n        for(int i=0;i<nums.size()/2;i++,n--){\\n            maxi=max(maxi,nums[i]+nums[n]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2526249,
                "title": "2-pointer-approach-simple-java-code",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n     Arrays.sort(nums) ;\\n        int i=0,j=nums.length-1,sum=0;\\n        int max=Integer.MIN_VALUE;\\n        \\n    while(i<j){\\n    sum=nums[i]+nums[j];\\n        j--;\\n        i++;\\n        max=Math.max(max,sum);\\n    \\n    }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n     Arrays.sort(nums) ;\\n        int i=0,j=nums.length-1,sum=0;\\n        int max=Integer.MIN_VALUE;\\n        \\n    while(i<j){\\n    sum=nums[i]+nums[j];\\n        j--;\\n        i++;\\n        max=Math.max(max,sum);\\n    \\n    }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2283977,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0,j=nums.length-1,max=0;\\n        while(i<j)\\n            max = Math.max(nums[i++]+nums[j--],max);\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int i=0,j=nums.length-1,max=0;\\n        while(i<j)\\n            max = Math.max(nums[i++]+nums[j--],max);\\n        return max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1683310,
                "title": "simple-java-solution-o-nlogn",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);        \\n        int i = 0, j = nums.length-1, max = 0;    \\n        while(i < j) {\\n            max = Math.max(nums[i] + nums[j], max);\\n            i++; j--;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);        \\n        int i = 0, j = nums.length-1, max = 0;    \\n        while(i < j) {\\n            max = Math.max(nums[i] + nums[j], max);\\n            i++; j--;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1509768,
                "title": "java-o-nlogn-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int ans =0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length/2;i++)\\n        {\\n            ans = Math.max(ans, nums[i]+nums[nums.length-i-1]);\\n        }\\n        return ans;        \\n    }\\n}\\n```\\n\\nApproach behind the solution is to sort the array, pair max with min, second max with second min and so on...",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int ans =0;\\n        Arrays.sort(nums);\\n        for(int i=0;i<nums.length/2;i++)\\n        {\\n            ans = Math.max(ans, nums[i]+nums[nums.length-i-1]);\\n        }\\n        return ans;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1292471,
                "title": "python-fast-and-pythonic",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max([value+nums[-index] for index, value in enumerate(nums[:len(nums)//2], 1)])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max([value+nums[-index] for index, value in enumerate(nums[:len(nums)//2], 1)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251127,
                "title": "golang-two-pointer-solution-with-quick-explanation",
                "content": "This is solution is pretty simple:\\n\\n* We first sort `nums`\\n* Then we loop through `0` to the mid (From `0` to `len(nums) / 2 - 1`)\\n* Then we check whether `nums[i] + nums[len(nums) - i - 1]` is greater than `res` (Note: `nums[i]` is the left pointer and `nums[len(nums) - i - 1]` is the right).\\n\\n```\\nfunc minPairSum(nums []int) int {\\n\\tsort.Ints(nums)\\n\\tres := 0\\n\\tfor i := 0; i < len(nums)/2; i++ {\\n\\t\\tif nums[i] + nums[len(nums) - i - 1] > res {\\n\\t\\t\\tres = nums[i] + nums[len(nums) - i - 1]\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc minPairSum(nums []int) int {\\n\\tsort.Ints(nums)\\n\\tres := 0\\n\\tfor i := 0; i < len(nums)/2; i++ {\\n\\t\\tif nums[i] + nums[len(nums) - i - 1] > res {\\n\\t\\t\\tres = nums[i] + nums[len(nums) - i - 1]\\n\\t\\t}\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1245692,
                "title": "python-two-lines-sort-and-list-comprehension",
                "content": "```python\\ndef minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max([nums[i]+nums[-i-1] for i in range(len(nums)//2)])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\ndef minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        return max([nums[i]+nums[-i-1] for i in range(len(nums)//2)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1238848,
                "title": "1877-sort-and-sum-from-opposite-ends-till-mid",
                "content": "---\\n\\nCode as-is from contest submission\\n\\nAlgo\\n- Sorting helps in getting minimized sums - when adding from opposite ends\\n- Take the max among them\\n\\nHope it is simple to understand\\n\\n---\\n\\n    var minPairSum = function (A) {\\n        A.sort((a, b) => a - b);\\n\\n        let max = -Infinity;\\n        let n = A.length;\\n        for (let i = 0, j = n - 1; i < j; i++, j--) {\\n            max = Math.max(max, A[i] + A[j]);\\n        }\\n\\n        return max;\\n    };\\n\\n---\\n",
                "solutionTags": [],
                "code": "---\\n\\nCode as-is from contest submission\\n\\nAlgo\\n- Sorting helps in getting minimized sums - when adding from opposite ends\\n- Take the max among them\\n\\nHope it is simple to understand\\n\\n---\\n\\n    var minPairSum = function (A) {\\n        A.sort((a, b) => a - b);\\n\\n        let max = -Infinity;\\n        let n = A.length;\\n        for (let i = 0, j = n - 1; i < j; i++, j--) {\\n            max = Math.max(max, A[i] + A[j]);\\n        }\\n\\n        return max;\\n    };\\n\\n---\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1238722,
                "title": "c-sort-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),mid=n/2,ans=0,j=1;\\n        \\n        for(int i=mid;i<n;i++,j=j+2)\\n            ans = max(ans ,nums[i]+nums[i-j]);\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size(),mid=n/2,ans=0,j=1;\\n        \\n        for(int i=mid;i<n;i++,j=j+2)\\n            ans = max(ans ,nums[i]+nums[i-j]);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238650,
                "title": "c-sort-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < nums.size() / 2; i++) {\\n            ans = max(ans, nums[i] + nums[nums.size() - i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int ans = 0;\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i < nums.size() / 2; i++) {\\n            ans = max(ans, nums[i] + nums[nums.size() - i - 1]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4050767,
                "title": "sort-max-min-max",
                "content": "# Complexity\\n- Time complexity:\\n$$O(nlogn)$$<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(1)$$<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int maxi=-1;\\n        for(int i=0;i<nums.size()/2;i++){\\n            maxi=max(maxi,nums[i]+nums[nums.size()-i-1]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int maxi=-1;\\n        for(int i=0;i<nums.size()/2;i++){\\n            maxi=max(maxi,nums[i]+nums[nums.size()-i-1]);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993535,
                "title": "easy-c-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(NlnN)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int low=0;\\n        int high=nums.size()-1;\\n        int ans=INT_MIN;\\n        while(low<high){\\n            ans=max(ans, nums[low++]+nums[high--]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int low=0;\\n        int high=nums.size()-1;\\n        int ans=INT_MIN;\\n        while(low<high){\\n            ans=max(ans, nums[low++]+nums[high--]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833694,
                "title": "easy-to-understand-java-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for(int i = 0; i < nums.length/2; i++) {\\n            int j = nums.length - 1 - i;\\n            max = Math.max(max, nums[i] + nums[j]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for(int i = 0; i < nums.length/2; i++) {\\n            int j = nums.length - 1 - i;\\n            max = Math.max(max, nums[i] + nums[j]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774465,
                "title": "c-simple-solution-using-vector",
                "content": "# Flow of Code\\n1. Sorting the vector\\n2. Adding the first element and last element, second element and second last element like that so on and pushing to another vector.\\n3. Returning the largest value of vector as answer.\\n# Flow same logic for other programming languages too.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        vector<int> A;\\n        int n=nums.size()/2,B=nums.size()-1;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            A.push_back(nums[i]+nums[B]);\\n            B--;\\n        }\\n        return *max_element(A.begin(),A.end());\\n    }\\n};\\n```\\n# Happy Coding...\\uD83E\\uDD1D",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        vector<int> A;\\n        int n=nums.size()/2,B=nums.size()-1;\\n        sort(nums.begin(),nums.end());\\n        for(int i=0;i<n;i++){\\n            A.push_back(nums[i]+nums[B]);\\n            B--;\\n        }\\n        return *max_element(A.begin(),A.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737808,
                "title": "c-super-rare-o-n-solution-clean-code-beats-100-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        \\n        int freq[100001] = {0};\\n        int maxi = 0;\\n        int l = 0;\\n        int r = nums.size();\\n        for(int i=0; i<r; i++){\\n            freq[nums[i]]++;\\n        }\\n        r = 100000;\\n        while(l <= r){\\n            if(!freq[l]){\\n                l++;\\n                continue;\\n            }\\n            if(!freq[r]){\\n                r--;\\n                continue;\\n            }\\n            maxi = max(maxi,l + r);\\n            freq[l]--;\\n            freq[r]--;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        \\n        int freq[100001] = {0};\\n        int maxi = 0;\\n        int l = 0;\\n        int r = nums.size();\\n        for(int i=0; i<r; i++){\\n            freq[nums[i]]++;\\n        }\\n        r = 100000;\\n        while(l <= r){\\n            if(!freq[l]){\\n                l++;\\n                continue;\\n            }\\n            if(!freq[r]){\\n                r--;\\n                continue;\\n            }\\n            maxi = max(maxi,l + r);\\n            freq[l]--;\\n            freq[r]--;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3690066,
                "title": "3-line-code-97-faster-proper-intuition",
                "content": "# Intuition\\u2705\\u2705\\nSort the vector and then pair 1st and last element together and traverse the vector till size-1. While traversing,  calculate the pair sum and store the maximum in variable(name as mx in below code).\\n\\n# Approach\\u2705\\u2705\\nsince below code is very small.\\n1. Sort the vector \\n2. pair 1st and last element together and increase the counter.\\n3. While traversing also calculate the pair sum and store the maximum in one variable.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\u2705\\n- Space complexity:\\nO(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]+nums[nums.size()-1-i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]+nums[nums.size()-1-i]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3572385,
                "title": "c-sorting-two-pointer-greedy",
                "content": "# Intuition\\nJust to know about window technique or two pointer\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nGet the nums sorted in non-decreasing order. \\nSet the two pointers one at start and one at end.\\nGet the sum of two numbers at the pointers.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N Log-N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\nO(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i = 0, j = nums.size()-1;\\n        int maxi = 0;\\n        while(i<j){\\n            maxi = max(maxi, nums[i]+nums[j]);\\n            ++i, --j;\\n        }\\n        return maxi;\\n    }\\n};\\n\\n// 4,1,5,1,2,5,1,5,5,4\\n// 1,1,1,2,4,4,5,5,5,5\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int i = 0, j = nums.size()-1;\\n        int maxi = 0;\\n        while(i<j){\\n            maxi = max(maxi, nums[i]+nums[j]);\\n            ++i, --j;\\n        }\\n        return maxi;\\n    }\\n};\\n\\n// 4,1,5,1,2,5,1,5,5,4\\n// 1,1,1,2,4,4,5,5,5,5\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3436887,
                "title": "minimize-maximum-pair-sum-in-array-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int i, max=INT_MIN;\\n        sort(nums.begin(), nums.end());\\n        for(i=0 ; i<nums.size()/2 ; i++)\\n        {\\n            if(nums[i]+nums[nums.size()-1-i]>max)\\n            {\\n                max = nums[i]+nums[nums.size()-1-i];\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/1d985ac1-6611-48a2-9d29-846dc01fc081_1682613097.1268463.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int i, max=INT_MIN;\\n        sort(nums.begin(), nums.end());\\n        for(i=0 ; i<nums.size()/2 ; i++)\\n        {\\n            if(nums[i]+nums[nums.size()-1-i]>max)\\n            {\\n                max = nums[i]+nums[nums.size()-1-i];\\n            }\\n        }\\n        return max;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3410854,
                "title": "o-n-log-n-solution-in-cpp",
                "content": "\\n# Complexity\\n- Time complexity: ``O(n)*log(n)``\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: ``O(n)``\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int ans = 0, n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i <= n / 2; i++){\\n          ans = max(ans, nums[i] + nums[n - 1 - i]);\\n      }\\n      return ans;  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int ans = 0, n = nums.size();\\n        sort(nums.begin(), nums.end());\\n        for(int i = 0; i <= n / 2; i++){\\n          ans = max(ans, nums[i] + nums[n - 1 - i]);\\n      }\\n      return ans;  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3347233,
                "title": "c-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n $$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1e9;\\n        int i=0,j=nums.size()-1;\\n        while(i<j){\\n            ans=max(nums[i++]+nums[j--],ans);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int ans=-1e9;\\n        int i=0,j=nums.size()-1;\\n        while(i<j){\\n            ans=max(nums[i++]+nums[j--],ans);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028068,
                "title": "solution-based-on-sorting-and-pairing-javascript",
                "content": "# Intuition\\n1. Sort the array, so that we can have lowest to highest , which will help in pairing\\n2. pair the first and last element and follow this approach for all elements , doing this would help to minimize the pair sum.\\n\\n# Approach\\n1. Sort\\n2. Pair\\n3. keep updating the max sum\\n\\n# Complexity\\n- Time complexity:\\nO(n), since all is done in one loop.\\nO(nlogn),if we inculde the sorting.\\n\\n- Space complexity:\\nO(1), since we do not need any extra array or other memory , just a max variable.\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minPairSum = function(nums) {\\n    nums.sort(function(a,b){return a-b})\\n    let max=0\\n    let j=nums.length-1\\n    for(let i=0;i<nums.length;i++){\\n        max=Math.max(max,nums[i]+nums[j])\\n        j--\\n    }\\n    return max\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minPairSum = function(nums) {\\n    nums.sort(function(a,b){return a-b})\\n    let max=0\\n    let j=nums.length-1\\n    for(let i=0;i<nums.length;i++){\\n        max=Math.max(max,nums[i]+nums[j])\\n        j--\\n    }\\n    return max\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2863236,
                "title": "sort-then-traverse-and-sum-from-front-and-back",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        \\n        \\n        int n = a.size();\\n        int j = n-1;\\n        int i = 0;\\n        int res = 0;\\n        while(i<j)\\n        {\\n            res = max(res,a[i++]+a[j--]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& a) {\\n        sort(a.begin(),a.end());\\n        \\n        \\n        int n = a.size();\\n        int j = n-1;\\n        int i = 0;\\n        int res = 0;\\n        while(i<j)\\n        {\\n            res = max(res,a[i++]+a[j--]);\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2801513,
                "title": "fast-and-memory-efficient-solution",
                "content": "**heap sort** as efficient sorting with max O(nlogn) and then **two-pointers** with for loop that fast O(n). \\n\\n![image](https://assets.leetcode.com/users/images/a659e758-98bc-474f-a747-e7468a58beee_1668118121.382064.jpeg)\\n\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        h = []\\n        heapq.heapify(nums)\\n        for i in range(len(nums)):\\n            h.append(heapq.heappop(nums))\\n            \\n        right = len(h)-1\\n        m = 0\\n        for left in range(len(h)//2):\\n            m = max(m, (h[left]+h[right]))\\n            right -= 1\\n        return m  \\n```\\n\\n```\\nif like this solution:\\n\\treturn \\'Upvote! You\\'re awsome\\'\\nelse:\\n\\treturn \\'Anyway you`re awsome\\'\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        h = []\\n        heapq.heapify(nums)\\n        for i in range(len(nums)):\\n            h.append(heapq.heappop(nums))\\n            \\n        right = len(h)-1\\n        m = 0\\n        for left in range(len(h)//2):\\n            m = max(m, (h[left]+h[right]))\\n            right -= 1\\n        return m  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773617,
                "title": "c-sorting-easy-to-understand",
                "content": "Explanation - Firstly we will sort the Array then we will find the sum of the smallest and largest element of the Array (For example if there are 6 elements in an Array then we will calculate the sum of element at index 0 & 5, 1 & 4, 2 & 3) and will return the max sum of all the pairs.\\n\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n=nums.size();   \\n        sort(nums.begin(), nums.end());\\n        \\n        int minSum=nums[0]+nums[n-1];\\n        \\n        int j=n-2;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            int sum=nums[i]+nums[j];\\n            minSum=max(sum, minSum);\\n            j--;\\n        }\\n        return minSum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n=nums.size();   \\n        sort(nums.begin(), nums.end());\\n        \\n        int minSum=nums[0]+nums[n-1];\\n        \\n        int j=n-2;\\n        for(int i=1;i<n-1;i++)\\n        {\\n            int sum=nums[i]+nums[j];\\n            minSum=max(sum, minSum);\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2664064,
                "title": "simple-nlogn-solution-two-pointers",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l=0,h=nums.size()-1;\\n        int res=INT_MIN;\\n        while(l<h){\\n            res=max(res,nums[l++]+nums[h--]);\\n\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int l=0,h=nums.size()-1;\\n        int res=INT_MIN;\\n        while(l<h){\\n            res=max(res,nums[l++]+nums[h--]);\\n\\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2648216,
                "title": "python-easy-solution-using-two-pointers",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i=0\\n        j=len(nums)-1\\n        m=0\\n        while i<=j:\\n            m=max(m,nums[i]+nums[j])\\n            i+=1\\n            j-=1\\n        return m\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i=0\\n        j=len(nums)-1\\n        m=0\\n        while i<=j:\\n            m=max(m,nums[i]+nums[j])\\n            i+=1\\n            j-=1\\n        return m\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2591035,
                "title": "c-2-ways-to-solve-the-problem",
                "content": "1.  Bucket sort\\n2.  Traditional sort\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        vector<int> bucket(100001,0);\\n        for (auto &n: nums)\\n            bucket[n]++;\\n        int l = 1; int h = 100000;\\n        int result = INT_MIN;\\n        int pairs = nums.size()/2;\\n        while(pairs) {\\n            while(!bucket[l])\\n                l++;\\n            while(!bucket[h])\\n                h--;\\n            result = max(result,l+h);\\n            bucket[l]--; bucket[h]--;\\n            pairs--;\\n        }\\n        return result;\\n    }\\n    \\n    int minPairSum1(vector<int>& nums) {\\n        int result = 0;\\n        int high = nums.size()-1;\\n        int low = 0;\\n        sort(nums.begin(),nums.end());\\n        \\n        while(low < high) {\\n            result = max(result,nums[low]+nums[high]);\\n            low++; high--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        vector<int> bucket(100001,0);\\n        for (auto &n: nums)\\n            bucket[n]++;\\n        int l = 1; int h = 100000;\\n        int result = INT_MIN;\\n        int pairs = nums.size()/2;\\n        while(pairs) {\\n            while(!bucket[l])\\n                l++;\\n            while(!bucket[h])\\n                h--;\\n            result = max(result,l+h);\\n            bucket[l]--; bucket[h]--;\\n            pairs--;\\n        }\\n        return result;\\n    }\\n    \\n    int minPairSum1(vector<int>& nums) {\\n        int result = 0;\\n        int high = nums.size()-1;\\n        int low = 0;\\n        sort(nums.begin(),nums.end());\\n        \\n        while(low < high) {\\n            result = max(result,nums[low]+nums[high]);\\n            low++; high--;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541247,
                "title": "easy-python-solution-o-nlogn-sort-2-pointers",
                "content": "Logic is that ans will be maximum of all the mini possible pairs in all combinations of 2 elements. These min possible pairs will come when we sort the array and chose pairs inwards from the ends.\\n\\nUpvote if you like the solution.\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i = 0\\n        j = len(nums) - 1\\n        ans = -inf\\n        \\n        while i < j:\\n            ans = max(ans, nums[i] + nums[j])\\n            i += 1\\n            j -= 1\\n        \\n        return ans\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i = 0\\n        j = len(nums) - 1\\n        ans = -inf\\n        \\n        while i < j:\\n            ans = max(ans, nums[i] + nums[j])\\n            i += 1\\n            j -= 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2541074,
                "title": "java-easy-two-pointer",
                "content": "```\\n Arrays.sort(nums);\\n        int low = 0;\\n        int high = nums.length-1;\\n        int res = 0;\\n        while(low<= high){\\n            int sum = nums[low]+nums[high];\\n            low++;\\n            high--;\\n            res = Math.max(res, sum);\\n            \\n        }\\n        return res;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n Arrays.sort(nums);\\n        int low = 0;\\n        int high = nums.length-1;\\n        int res = 0;\\n        while(low<= high){\\n            int sum = nums[low]+nums[high];\\n            low++;\\n            high--;\\n            res = Math.max(res, sum);\\n            \\n        }\\n        return res;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2540940,
                "title": "java-easy-two-pointer",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int s=0;\\n        int l=nums.length-1;\\n        int sum=0;\\n        int msum=sum;\\n        \\n        while(s<l){\\n            sum=nums[s]+nums[l];\\n            s++;\\n            l--;\\n            msum=Math.max(msum,sum);\\n        }\\n        return msum;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int s=0;\\n        int l=nums.length-1;\\n        int sum=0;\\n        int msum=sum;\\n        \\n        while(s<l){\\n            sum=nums[s]+nums[l];\\n            s++;\\n            l--;\\n            msum=Math.max(msum,sum);\\n        }\\n        return msum;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2501764,
                "title": "c-solution-3-lines-code-leetcode-must-change-this-questions-category-to-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n      int maxi=0; int n=nums.size(); int i=0; int j=n-1;\\n      sort(nums.begin(),nums.end());\\n       for(;i<j;i++,j--)\\n        maxi = max(maxi, nums[i]+nums[j]);\\n        return maxi;\\n    }\\n};",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n      int maxi=0; int n=nums.size(); int i=0; int j=n-1;\\n      sort(nums.begin(),nums.end());\\n       for(;i<j;i++,j--)\\n        maxi = max(maxi, nums[i]+nums[j]);\\n        return maxi;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2489453,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int mini=0;\\n        int i=0,j=n-1;\\n        while(i<j){\\n            mini=max(mini,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        int mini=0;\\n        int i=0,j=n-1;\\n        while(i<j){\\n            mini=max(mini,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        return mini;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2373516,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<n/2;i++){\\n            ans = Math.max(ans,nums[i]+nums[n-i-1]);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        int ans = 0;\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        for(int i=0;i<n/2;i++){\\n            ans = Math.max(ans,nums[i]+nums[n-i-1]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2334722,
                "title": "c-sort-o-nlog-n-tc-o-1-sc",
                "content": "\\tint minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mx=0;\\n        for(int i=0;i<nums.size()/2;i++){\\n            mx=max(mx,nums[i]+nums[nums.size()-1-i]);\\n        }\\n        return mx;\\n    }",
                "solutionTags": [
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "\\tint minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mx=0;\\n        for(int i=0;i<nums.size()/2;i++){\\n            mx=max(mx,nums[i]+nums[nums.size()-1-i]);\\n        }\\n        return mx;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2327399,
                "title": "python-easy-fast-solution-two-pointer",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        \\n        nums.sort()\\n        \\n        l, r = 0, len(nums)-1\\n        while l<r:\\n            ans = max(ans, nums[l]+nums[r])\\n            l += 1\\n            r -= 1\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        ans = 0\\n        \\n        nums.sort()\\n        \\n        l, r = 0, len(nums)-1\\n        while l<r:\\n            ans = max(ans, nums[l]+nums[r])\\n            l += 1\\n            r -= 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2298875,
                "title": "least-runtime-solution",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        a = nums[:n//2]\\n        b = nums[:n//2 - 1:-1]\\n        maximum = 0\\n        for i, j in zip(a, b):\\n            if i + j > maximum:\\n                maximum = i + j\\n        \\n        return maximum\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        n = len(nums)\\n        nums.sort()\\n        a = nums[:n//2]\\n        b = nums[:n//2 - 1:-1]\\n        maximum = 0\\n        for i, j in zip(a, b):\\n            if i + j > maximum:\\n                maximum = i + j\\n        \\n        return maximum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2259015,
                "title": "easy-cpp-solution",
                "content": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums)\\n    {\\n        int i,j=nums.size()-1,k=-1;\\n        sort(nums.begin(),nums.end());\\n        for(i=0;i<nums.size()/2;i++)\\n        {\\n           k=max(k,nums[i]+nums[j]);\\n            j--;\\n        }\\n        return k;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums)\\n    {\\n        int i,j=nums.size()-1,k=-1;\\n        sort(nums.begin(),nums.end());\\n        for(i=0;i<nums.size()/2;i++)\\n        {\\n           k=max(k,nums[i]+nums[j]);\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2228149,
                "title": "java-easy-solution-100",
                "content": "\\n\\nclass Solution {\\n         public int minPairSum(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0, n = A.length;\\n        for (int i = 0; i < n / 2; ++i)\\n            res = Math.max(res, A[i] + A[n - i - 1]);\\n        return res;\\n   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n         public int minPairSum(int[] A) {\\n        Arrays.sort(A);\\n        int res = 0, n = A.length;\\n        for (int i = 0; i < n / 2; ++i)\\n            res = Math.max(res, A[i] + A[n - i - 1]);\\n        return res;\\n   \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2205394,
                "title": "my-easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        int i = 0;\\n        int j = nums.length-1;\\n        while(i < j)\\n        {\\n            max = Math.max(nums[i]+nums[j], max);\\n            i++;\\n            j--;\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        int i = 0;\\n        int j = nums.length-1;\\n        while(i < j)\\n        {\\n            max = Math.max(nums[i]+nums[j], max);\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2137290,
                "title": "python-2-liner",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, x: List[int]) -> int:\\n        x.sort()\\n        return max(x[i]+x[-i-1] for i in range(len(x)//2))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, x: List[int]) -> int:\\n        x.sort()\\n        return max(x[i]+x[-i-1] for i in range(len(x)//2))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087701,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) \\n    {\\n        vector <int> v;\\n        sort(nums.begin(),nums.end());\\n        int length=nums.size();\\n        for(int i=0;i<=length/2;i++)\\n        {\\n            v.push_back(nums.at(i)+nums.at(length-i-1));\\n        }\\n        return *max_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) \\n    {\\n        vector <int> v;\\n        sort(nums.begin(),nums.end());\\n        int length=nums.size();\\n        for(int i=0;i<=length/2;i++)\\n        {\\n            v.push_back(nums.at(i)+nums.at(length-i-1));\\n        }\\n        return *max_element(v.begin(),v.end());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2086664,
                "title": "scala-one-line-solution",
                "content": "```\\n\\n  def minPairSum(nums: Array[Int]): Int = (nums.sorted.reverse zip nums.sorted).map(n => n._1 + n._2).max\\n\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\n\\n  def minPairSum(nums: Array[Int]): Int = (nums.sorted.reverse zip nums.sorted).map(n => n._1 + n._2).max\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2075670,
                "title": "java-sorting-solution-two-pointers-o-nlogn",
                "content": "Summary: Sort the array. Add the elements from the start and end of the array, and compare the sum with the max sum found so far. Increment the start pointer by 1 and decrement the end pointer by 1 (until start < end).\\n\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        else if(nums.length == 2) return nums[0] + nums[1];\\n        \\n        Arrays.sort(nums);\\n        \\n        int max = 0;\\n        int i = 0;\\n        int j = nums.length - 1;\\n        \\n        for(; i < j; i ++, j--) {\\n            max = Math.max(max, nums[i] + nums[j]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        if(nums.length < 2) return 0;\\n        else if(nums.length == 2) return nums[0] + nums[1];\\n        \\n        Arrays.sort(nums);\\n        \\n        int max = 0;\\n        int i = 0;\\n        int j = nums.length - 1;\\n        \\n        for(; i < j; i ++, j--) {\\n            max = Math.max(max, nums[i] + nums[j]);\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2072009,
                "title": "c-solution-using-sort-two-pointers",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        if(nums.size() == 2) return nums[0] + nums[1];\\n        sort(nums.begin(), nums.end());\\n        int pos1 = nums.size() / 2 - 1, pos2 = nums.size() / 2, maxVal = INT_MIN;\\n        while(pos1 >= 0)\\n            maxVal = max(maxVal, nums[pos1--] + nums[pos2++]);\\n        return maxVal;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        if(nums.size() == 2) return nums[0] + nums[1];\\n        sort(nums.begin(), nums.end());\\n        int pos1 = nums.size() / 2 - 1, pos2 = nums.size() / 2, maxVal = INT_MIN;\\n        while(pos1 >= 0)\\n            maxVal = max(maxVal, nums[pos1--] + nums[pos2++]);\\n        return maxVal;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003573,
                "title": "very-easy-solution-cpp",
                "content": "*  Sort the vector then add the smallest number with largest one then next smalles number to next largest one and so on.\\n\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]+nums[nums.size()-i-1]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int mx=0;\\n        for(int i=0;i<nums.size();i++){\\n            mx=max(mx,nums[i]+nums[nums.size()-i-1]);\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1936210,
                "title": "c-just-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0 ; \\n        int j = nums.size()-1;\\n        int maxPair = 0;\\n        while(i<j){\\n            maxPair=max(nums[i++]+nums[j--],maxPair);\\n        }\\n        return maxPair;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i = 0 ; \\n        int j = nums.size()-1;\\n        int maxPair = 0;\\n        while(i<j){\\n            maxPair=max(nums[i++]+nums[j--],maxPair);\\n        }\\n        return maxPair;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1841067,
                "title": "c-simple-solution",
                "content": "```\\npublic class Solution \\n{\\n    public int MinPairSum(int[] nums) \\n    {\\n        int max = int.MinValue;\\n        Array.Sort(nums);\\n        \\n        int st=0;\\n        int en=nums.Length-1;\\n        \\n        while(st<en)\\n        {\\n            max = Math.Max(max,nums[st++]+nums[en--]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public int MinPairSum(int[] nums) \\n    {\\n        int max = int.MinValue;\\n        Array.Sort(nums);\\n        \\n        int st=0;\\n        int en=nums.Length-1;\\n        \\n        while(st<en)\\n        {\\n            max = Math.Max(max,nums[st++]+nums[en--]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1818157,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0, j = nums.length-1; i <= j; i++, j--){\\n            max = Math.max(max, nums[i] + nums[j]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0, j = nums.length-1; i <= j; i++, j--){\\n            max = Math.max(max, nums[i] + nums[j]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1814831,
                "title": "easy-sorting-two-pointer",
                "content": "\\'\\'\\'class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int l =0; int h =nums.length-1;\\n        \\n        int maxsum = Integer.MIN_VALUE;\\n        while(l< h){\\n            int sum = nums[l]+nums[h];\\n            maxsum=Math.max(maxsum , sum);\\n            l++;\\n            h--;\\n        }return maxsum;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int l =0; int h =nums.length-1;\\n        \\n        int maxsum = Integer.MIN_VALUE;\\n        while(l< h){\\n            int sum = nums[l]+nums[h];\\n            maxsum=Math.max(maxsum , sum);\\n            l++;\\n            h--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1791444,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums)\\n    {\\n        Arrays.sort(nums);\\n        int[] rev = new int[nums.length];    \\n        for(int i=nums.length-1, j=0; i>=0; i--)\\n        {\\n            rev[j++] = nums[i];\\n        }\\n        int max = 0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            int sum = nums[i]+rev[i];\\n            max = Math.max(sum, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums)\\n    {\\n        Arrays.sort(nums);\\n        int[] rev = new int[nums.length];    \\n        for(int i=nums.length-1, j=0; i>=0; i--)\\n        {\\n            rev[j++] = nums[i];\\n        }\\n        int max = 0;\\n        for(int i=0; i<nums.length; i++)\\n        {\\n            int sum = nums[i]+rev[i];\\n            max = Math.max(sum, max);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1788821,
                "title": "rust",
                "content": "```\\nimpl Solution {\\n    pub fn min_pair_sum(mut nums: Vec<i32>) -> i32 {\\n        nums.sort();\\n        let len = nums.len();\\n        (0..len/2)\\n            .map(|n| nums[n] + nums[len-n-1])\\n            .max()\\n            .unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_pair_sum(mut nums: Vec<i32>) -> i32 {\\n        nums.sort();\\n        let len = nums.len();\\n        (0..len/2)\\n            .map(|n| nums[n] + nums[len-n-1])\\n            .max()\\n            .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1787724,
                "title": "java-easy-understanding",
                "content": "public int minPairSum(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int start = 0, end = nums.length - 1;\\n        int maxSum = 0;\\n       while(start < end){\\n           if( nums[start] + nums[end] > maxSum){\\n               maxSum =  nums[start] + nums[end];\\n           }\\n           start++;\\n           end--;\\n       }\\n        return maxSum;\\n    }",
                "solutionTags": [
                    "Java",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "public int minPairSum(int[] nums) {\\n\\n        Arrays.sort(nums);\\n        int start = 0, end = nums.length - 1;\\n        int maxSum = 0;\\n       while(start < end){\\n           if( nums[start] + nums[end] > maxSum){\\n               maxSum =  nums[start] + nums[end];\\n           }\\n           start++;\\n           end--;\\n       }\\n        return maxSum;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1786459,
                "title": "simplest-solution-c",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPERICIATED**\\n1.  SORT THE ARRAY.\\n2. ADD FIRST AND LAST ELEMENT BECAUSE THAT\\'S HOW WE GET MINIMUM FOR TWO ELEMENT SUM.(largest and smallest)\\n3. AND WE WANT THE LARGEST DIFFERENCE BETWEEN 2.\\n4. SO RETURN THE LARGEST DIFFERENCE.\\n**HAPPY CODING.**\\n\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int s=0;\\n        int e=nums.size()-1;\\n        int ma=0;\\n        while(s<e){\\n            int a=nums[s]+nums[e];\\n            ma=max(ma,a);\\n            s++;\\n            e--;\\n        }return ma;\\n        \\n    }\\n};\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int s=0;\\n        int e=nums.size()-1;\\n        int ma=0;\\n        while(s<e){\\n            int a=nums[s]+nums[e];\\n            ma=max(ma,a);\\n            s++;\\n            e--;\\n        }return ma;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1780433,
                "title": "easy-c-solution",
                "content": "\\'\\'\\'\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int m = INT_MIN,sum;\\n        for(int i=0,j=nums.size()-1;i<j;i++,j--)\\n        {\\n            sum = nums[i]+nums[j];\\n            if(sum>m)\\n                m = sum;\\n        }\\n        return m;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "Two Pointers",
                    "String",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) \\n    {\\n        sort(nums.begin(),nums.end());\\n        int m = INT_MIN,sum;\\n        for(int i=0,j=nums.size()-1;i<j;i++,j--)\\n        {\\n            sum = nums[i]+nums[j];\\n            if(sum>m)\\n                m = sum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1763527,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int result = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n           result = Math.max(result, nums[i] + nums[nums.length - i - 1]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int result = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n           result = Math.max(result, nums[i] + nums[nums.length - i - 1]);\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1760881,
                "title": "java-easy-solution",
                "content": "\\n\\t\\t\\t\\t   \\n\\t\\t\\t\\t   \\n\\t\\t\\tclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n       Arrays.sort(nums);\\n        int a=nums.length-1;\\n        int max=0;\\n        for(int i=0;i<nums.length/2;i++)\\n        {\\n           max=Math.max(max,nums[i]+nums[a--]); \\n        }\\n        \\n        return max;\\n     }\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n       Arrays.sort(nums);\\n        int a=nums.length-1;\\n        int max=0;\\n        for(int i=0;i<nums.length/2;i++)\\n        {\\n           max=Math.max(max,nums[i]+nums[a--]); \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1755553,
                "title": "java-easy-clean-and-concise-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int i = 0, j = nums.length - 1;\\n        while(i < j){\\n            int sum = nums[i++] + nums[j--];\\n            if(sum > ans)\\n                ans = sum;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int ans = 0;\\n        int i = 0, j = nums.length - 1;\\n        while(i < j){\\n            int sum = nums[i++] + nums[j--];\\n            if(sum > ans)\\n                ans = sum;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1755196,
                "title": "easy-java",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int ans=Integer.MIN_VALUE;\\n        Arrays.sort(nums);\\n        for(int i=0 ;i< nums.length/2;i++){\\n          ans=Math.macax(nums[i]+nums[nums.length-i-1],ans);   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int ans=Integer.MIN_VALUE;\\n        Arrays.sort(nums);\\n        for(int i=0 ;i< nums.length/2;i++){\\n          ans=Math.macax(nums[i]+nums[nums.length-i-1],ans);   \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1747931,
                "title": "java-100-fast",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n       int left=0;\\n        int right = nums.length-1;\\n        int result = Integer.MIN_VALUE;\\n        while(left < right){\\n         \\n            result = Math.max(result,nums[left] +nums[right] );\\n            left++;\\n            right--;\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n       int left=0;\\n        int right = nums.length-1;\\n        int result = Integer.MIN_VALUE;\\n        while(left < right){\\n         \\n            result = Math.max(result,nums[left] +nums[right] );\\n            left++;\\n            right--;\\n            \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1735982,
                "title": "beginner-friendly-javascript-soltion",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minPairSum = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    let max = 0;\\n    for(let i=0; i<nums.length/2; i++){\\n        max = Math.max(max , nums[i] + nums[nums.length-1-i]);\\n    }\\n    return max;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nvar minPairSum = function(nums) {\\n    nums.sort((a,b) => a-b);\\n    let max = 0;\\n    for(let i=0; i<nums.length/2; i++){\\n        max = Math.max(max , nums[i] + nums[nums.length-1-i]);\\n    }\\n    return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1734770,
                "title": "java-arraylist-easy-solution",
                "content": "public int minPairSum(int[] nums) {\\n        \\n        if(nums.length == 0)\\n            return 0;\\n\\t\\t\\t\\n        List<Integer> list = new ArrayList<Integer>();\\n        Arrays.sort(nums);\\n        \\n        for(int i = 0; i< nums.length/2; i++){    \\n            list.add(nums[i] + nums[nums.length - 1 - i]);          \\n        }      \\n        return Collections.max(list);        \\n    }",
                "solutionTags": [],
                "code": "public int minPairSum(int[] nums) {\\n        \\n        if(nums.length == 0)\\n            return 0;\\n\\t\\t\\t\\n        List<Integer> list = new ArrayList<Integer>();\\n        Arrays.sort(nums);\\n        \\n        for(int i = 0; i< nums.length/2; i++){    \\n            list.add(nums[i] + nums[nums.length - 1 - i]);          \\n        }      \\n        return Collections.max(list);        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1703088,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        \\n        int i =0;\\n        int j = nums.length -1;\\n        \\n        while(i<j){\\n            max = Math.max(max, nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        \\n        int i =0;\\n        int j = nums.length -1;\\n        \\n        while(i<j){\\n            max = Math.max(max, nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699715,
                "title": "two-pointers-sorting-c",
                "content": "```\\nclass Solution {\\npublic:\\n   int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=nums.size()-1;\\n        int ans=0;\\n        while(i<j)\\n        {\\n            ans=max(ans,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n   int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int i=0;\\n        int j=nums.size()-1;\\n        int ans=0;\\n        while(i<j)\\n        {\\n            ans=max(ans,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1653815,
                "title": "python-simple-two-pointers-solution-after-sort",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        res = 0 \\n        l, r = 0, n-1\\n        while l < r:\\n            res = max(res, nums[l] + nums[r])\\n            l += 1\\n            r -= 1\\n        return res \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Two Pointers",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        n = len(nums)\\n        res = 0 \\n        l, r = 0, n-1\\n        while l < r:\\n            res = max(res, nums[l] + nums[r])\\n            l += 1\\n            r -= 1\\n        return res \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631031,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int max=0;\\n        int i=0,j=nums.length-1;\\n        while(i<=j){\\n            \\n            max=Math.max(max,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        Arrays.sort(nums);\\n        int max=0;\\n        int i=0,j=nums.length-1;\\n        while(i<=j){\\n            \\n            max=Math.max(max,nums[i]+nums[j]);\\n            i++;\\n            j--;\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1589452,
                "title": "easy-one-pass-two-indices",
                "content": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums);\\n};\\n\\n\\nint Solution::minPairSum(vector<int>& nums) {\\n    int size = nums.size();\\n    int min_max_pair_sum;\\n    \\n    sort(nums.begin(), nums.end()); // sort ascending\\n    \\n    int low = 0, high = size-1;\\n    while(low < high) {\\n        if(low == 0)\\n            min_max_pair_sum = nums[low] + nums[high];\\n        else\\n            min_max_pair_sum = max(min_max_pair_sum, nums[low]+nums[high]);\\n        low++, high--;\\n    }\\n    return min_max_pair_sum;\\n}",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums);\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1584312,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = 0;\\n        int a = 0;\\n        int b = n - 1;\\n        while(a < b)\\n        {\\n            int temp = nums[a] + nums[b];\\n            a++;\\n            b--;\\n            ans = Math.max(ans, temp);\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int n = nums.length;\\n        int ans = 0;\\n        int a = 0;\\n        int b = n - 1;\\n        while(a < b)\\n        {\\n            int temp = nums[a] + nums[b];\\n            a++;\\n            b--;\\n            ans = Math.max(ans, temp);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1547862,
                "title": "simple-solution-in-java",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int maxSum=0;\\n        Arrays.sort(nums);\\n        \\n        int i =0, j = nums.length-1;\\n        while(i < j){\\n           int sum = nums[i] + nums[j];\\n            if(sum>maxSum){\\n                maxSum = sum;\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int maxSum=0;\\n        Arrays.sort(nums);\\n        \\n        int i =0, j = nums.length-1;\\n        while(i < j){\\n           int sum = nums[i] + nums[j];\\n            if(sum>maxSum){\\n                maxSum = sum;\\n            }\\n            i++;\\n            j--;\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1526182,
                "title": "c-sort-two-pointers",
                "content": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums) \\n    {\\n        if(nums == null || nums.Length == 0) return 0;\\n        \\n        Array.Sort(nums);\\n        \\n        int maxSum = 0;\\n        \\n        int i = 0;\\n        int j = nums.Length-1;\\n        \\n        while(i < j)\\n        {\\n            int sum = nums[i++] + nums[j--];\\n            maxSum = Math.Max(sum,maxSum);\\n        }        \\n        return maxSum;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums) \\n    {\\n        if(nums == null || nums.Length == 0) return 0;\\n        \\n        Array.Sort(nums);\\n        \\n        int maxSum = 0;\\n        \\n        int i = 0;\\n        int j = nums.Length-1;\\n        \\n        while(i < j)\\n        {\\n            int sum = nums[i++] + nums[j--];\\n            maxSum = Math.Max(sum,maxSum);\\n        }        \\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522618,
                "title": "java-solution",
                "content": "\\tclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int i = 0, j = nums.length-1, ans = Integer.MIN_VALUE;\\n        while(i < j)\\n        {\\n            ans = Math.max(nums[i++]+nums[j--],ans);\\n        }\\n        \\n        return ans;\\n    }\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int i = 0, j = nums.length-1, ans = Integer.MIN_VALUE;\\n        while(i < j)\\n        {\\n            ans = Math.max(nums[i++]+nums[j--],ans);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1506956,
                "title": "easy-problem-two-pointer-c-ac",
                "content": "1) sort the array\\n2) two pointer approach\\n3) keep updating the max_sum\\n4) return the max_sum\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int max_sum=0;\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<j){\\n            int sum=nums[i]+nums[j];\\n            max_sum=max(sum,max_sum);\\n            i++;\\n            j--;\\n        }\\n        return max_sum;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int max_sum=0;\\n        int i=0;\\n        int j=nums.size()-1;\\n        while(i<j){\\n            int sum=nums[i]+nums[j];\\n            max_sum=max(sum,max_sum);\\n            i++;\\n            j--;\\n        }\\n        return max_sum;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1443821,
                "title": "java-7-line-ez",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            int y = nums.length-1-i;\\n            max = (nums[i]+nums[y] > max) ? nums[i] + nums[y] : max;\\n        }\\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = Integer.MIN_VALUE;\\n        for(int i = 0; i < nums.length; i++){\\n            int y = nums.length-1-i;\\n            max = (nums[i]+nums[y] > max) ? nums[i] + nums[y] : max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1413885,
                "title": "simple-c-using-2pointer",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int l=0;\\n        int r = nums.size()-1;\\n        int maxx = INT_MIN;\\n        while(l<r) {\\n            maxx = max(maxx, nums[l] + nums[r]);\\n            l++;\\n            r--;\\n        }\\n        return maxx;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int l=0;\\n        int r = nums.size()-1;\\n        int maxx = INT_MIN;\\n        while(l<r) {\\n            maxx = max(maxx, nums[l] + nums[r]);\\n            l++;\\n            r--;\\n        }\\n        return maxx;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1359976,
                "title": "sort-and-zip-98-speed",
                "content": "Runtime: 1108 ms, faster than 97.68%\\nMemory Usage: 28.1 MB, less than 28.84%\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        half_len_nums = len(nums) // 2\\n        return max(a + b for a, b in zip(nums[:half_len_nums:],\\n                                         nums[-1:half_len_nums - 1: -1]))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        half_len_nums = len(nums) // 2\\n        return max(a + b for a, b in zip(nums[:half_len_nums:],\\n                                         nums[-1:half_len_nums - 1: -1]))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1348644,
                "title": "java-very-easy-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n     \\n        Arrays.sort(nums);\\n        int left = 0, right = nums.length-1;\\n        int res=0; \\n        \\n        while(left < right){\\n            res = Math.max(res,nums[left]+nums[right]);  \\n            left++;\\n            right--;  \\n        }\\n        return res;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n     \\n        Arrays.sort(nums);\\n        int left = 0, right = nums.length-1;\\n        int res=0; \\n        \\n        while(left < right){\\n            res = Math.max(res,nums[left]+nums[right]);  \\n            left++;\\n            right--;  \\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339219,
                "title": "simple-c-solution",
                "content": "```\\n   int minPairSum(vector<int>& arr) {\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        int ans=0;\\n        int n=arr.size();\\n        for(int i=0;i<n/2;i++){\\n            ans=max(ans,arr[i]+arr[n-1-i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   int minPairSum(vector<int>& arr) {\\n        \\n        sort(arr.begin(),arr.end());\\n        \\n        int ans=0;\\n        int n=arr.size();\\n        for(int i=0;i<n/2;i++){\\n            ans=max(ans,arr[i]+arr[n-1-i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1328364,
                "title": "easy-c-with-explanation",
                "content": "**Intution** :\\n**Sort** nums,\\nMake the pair with the **min + max,**\\nand continue do this\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums)\\n    {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int max_min = INT_MIN;\\n        int sum = 0;\\n        int i = 0; int j = n-1;\\n        while(i < j)\\n        {\\n            sum = nums[i]+nums[j];\\n            max_min = max(max_min,sum);\\n            i++;\\n            j--;\\n        }    \\n        return max_min;   \\n        }\\n};\\n```\\nImage Description :\\n![image](https://assets.leetcode.com/users/images/b45c4118-d377-48af-812a-5a81a07d0dc2_1625910545.8103118.png)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums)\\n    {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int max_min = INT_MIN;\\n        int sum = 0;\\n        int i = 0; int j = n-1;\\n        while(i < j)\\n        {\\n            sum = nums[i]+nums[j];\\n            max_min = max(max_min,sum);\\n            i++;\\n            j--;\\n        }    \\n        return max_min;   \\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1313363,
                "title": "c-sort-solution",
                "content": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums) {\\n        \\n        Array.Sort(nums);\\n\\n        var max = 0;\\n        for (int i = 0; i < nums.Length / 2; i++) {\\n            max = Math.Max(max, nums[i] + nums[nums.Length - 1 - i]);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums) {\\n        \\n        Array.Sort(nums);\\n\\n        var max = 0;\\n        for (int i = 0; i < nums.Length / 2; i++) {\\n            max = Math.Max(max, nums[i] + nums[nums.Length - 1 - i]);\\n        }\\n\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1307462,
                "title": "javascript-solution-using-sorting-and-two-pointer-technique",
                "content": "```\\nvar minPairSum = function(nums) {\\n    nums.sort((a,b) => a-b)\\n    var i = 0\\n    var j = nums.length-1\\n    var maxx = -(10**9)\\n    while(i<j){\\n        if(nums[i]+nums[j]>maxx){\\n            maxx = nums[i]+nums[j]\\n        }\\n        i++\\n        j--\\n    }\\n    return maxx\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```\\nvar minPairSum = function(nums) {\\n    nums.sort((a,b) => a-b)\\n    var i = 0\\n    var j = nums.length-1\\n    var maxx = -(10**9)\\n    while(i<j){\\n        if(nums[i]+nums[j]>maxx){\\n            maxx = nums[i]+nums[j]\\n        }\\n        i++\\n        j--\\n    }\\n    return maxx\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1302487,
                "title": "c-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        for(int i = 0;i<nums.size()/2;i++) ans=max(ans,nums[i]+nums[nums.size()-1-i]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(), nums.end());\\n        int ans = 0;\\n        for(int i = 0;i<nums.size()/2;i++) ans=max(ans,nums[i]+nums[nums.size()-1-i]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282386,
                "title": "simple-c-solution-using-two-pointers",
                "content": "```\\nint minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int i=0,j=n-1,maxi=0,sum=0;\\n        while(i<j){\\n            sum=nums[i]+nums[j];\\n            maxi=max(maxi,sum);\\n            sum=0;\\n            i++;\\n            j--;\\n        }\\n        return maxi;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int i=0,j=n-1,maxi=0,sum=0;\\n        while(i<j){\\n            sum=nums[i]+nums[j];\\n            maxi=max(maxi,sum);\\n            sum=0;\\n            i++;\\n            j--;\\n        }\\n        return maxi;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1276736,
                "title": "python3-simple-solution-using-sorting-and-single-while-loop-beats-90-users",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i,j = 0, len(nums)-1\\n        res = []\\n        while i < j:\\n            res.append(nums[i]+nums[j])\\n            i += 1\\n            j -= 1\\n        return max(res)\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        i,j = 0, len(nums)-1\\n        res = []\\n        while i < j:\\n            res.append(nums[i]+nums[j])\\n            i += 1\\n            j -= 1\\n        return max(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1275361,
                "title": "java-easy-solution-sort-then-two-pointer-o-nlogn-n-2",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n       Arrays.sort(nums);\\n        \\n        int low=0;\\n        int high=nums.length-1;\\n        int max=0;\\n        while(low<high)\\n        {            \\n            max=Math.max(max,(nums[low]+nums[high]));\\n            low++;\\n            high--;               \\n        }\\n        \\n        return max;\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n       Arrays.sort(nums);\\n        \\n        int low=0;\\n        int high=nums.length-1;\\n        int max=0;\\n        while(low<high)\\n        {            \\n            max=Math.max(max,(nums[low]+nums[high]));\\n            low++;\\n            high--;               \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1263319,
                "title": "javascript-solution-faster-than-80-simple-solutoin",
                "content": "var minPairSum = function(nums) {\\n    nums.sort(function(a,b){return a-b});\\n    let newarr = [];\\n    let j = nums.length-1;\\n    for(let i=0;i<nums.length;i++)\\n        {\\n            let temp = nums[i] + nums[j];\\n            newarr.push(temp);\\n            j--;\\n        }\\n    return Math.max(...newarr);\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var minPairSum = function(nums) {\\n    nums.sort(function(a,b){return a-b});\\n    let newarr = [];\\n    let j = nums.length-1;\\n    for(let i=0;i<nums.length;i++)\\n        {\\n            let temp = nums[i] + nums[j];\\n            newarr.push(temp);\\n            j--;\\n        }\\n    return Math.max(...newarr);\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 1257193,
                "title": "java-easy-greedy",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] arr) {\\n        Arrays.sort(arr);\\n        int ans = 0;\\n       for(int i = 0,j = arr.length-1 ; i<=j ;i++,j--){\\n         \\n         ans = Math.max(ans,arr[i]+arr[j]);\\n         \\n       }\\n      return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] arr) {\\n        Arrays.sort(arr);\\n        int ans = 0;\\n       for(int i = 0,j = arr.length-1 ; i<=j ;i++,j--){\\n         \\n         ans = Math.max(ans,arr[i]+arr[j]);\\n         \\n       }\\n      return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1256494,
                "title": "c-short-crispy-to-the-point",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());  // Sort the array\\n        int ans=0;\\n        int n=nums.size()-1;\\n        \\n        for(int i=0;i<=n/2;i++){        // Sum first and last term , then second and second \\n            int x=nums[i]+nums[n-i];    // last and go on and find the maximum i.e. answer\\n            ans=max(ans,x);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());  // Sort the array\\n        int ans=0;\\n        int n=nums.size()-1;\\n        \\n        for(int i=0;i<=n/2;i++){        // Sum first and last term , then second and second \\n            int x=nums[i]+nums[n-i];    // last and go on and find the maximum i.e. answer\\n            ans=max(ans,x);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1249815,
                "title": "javascript",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst minPairSum = nums => {\\n    nums.sort((a,b) => a - b);\\n    let maxSum = 0;\\n    const middle = nums.length/2;\\n    \\n    for (let i = 0; i < middle; i++) {\\n        maxSum = Math.max(maxSum, nums[i] + nums[nums.length - i - 1])\\n    }\\n    \\n    return maxSum;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number}\\n */\\nconst minPairSum = nums => {\\n    nums.sort((a,b) => a - b);\\n    let maxSum = 0;\\n    const middle = nums.length/2;\\n    \\n    for (let i = 0; i < middle; i++) {\\n        maxSum = Math.max(maxSum, nums[i] + nums[nums.length - i - 1])\\n    }\\n    \\n    return maxSum;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1249217,
                "title": "c-easy-solution-commented-fully",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        //sort the array\\n        sort(nums.begin(),nums.end());\\n        \\n        //the reason behind sorting is we can get the kth largest and kth smallest element from the array\\n        //the sum would be mninimum if we add a small number and a large number\\n        int maxi=0;\\n        int i=0;\\n        int j=nums.size()-1;\\n        int currSum=0;\\n        while(i<j)\\n        {\\n            currSum=nums[i]+nums[j];\\n            maxi=max(maxi,currSum); //get the maximum pair sum\\n            i++;\\n            j--;\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n\\n**Please upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        //sort the array\\n        sort(nums.begin(),nums.end());\\n        \\n        //the reason behind sorting is we can get the kth largest and kth smallest element from the array\\n        //the sum would be mninimum if we add a small number and a large number\\n        int maxi=0;\\n        int i=0;\\n        int j=nums.size()-1;\\n        int currSum=0;\\n        while(i<j)\\n        {\\n            currSum=nums[i]+nums[j];\\n            maxi=max(maxi,currSum); //get the maximum pair sum\\n            i++;\\n            j--;\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1248013,
                "title": "o-nlogn-c-surely-easier-than-medium-level",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int minPairSum(vector<int>& nums) {\\n\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        int ans=0;\\n        for(int i=0;i<n/2;i++)\\n            ans=max(nums[i]+nums[n-1-i],ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int minPairSum(vector<int>& nums) {\\n\\n        int n=nums.size();\\n        sort(nums.begin(),nums.end());\\n        \\n        int ans=0;\\n        for(int i=0;i<n/2;i++)\\n            ans=max(nums[i]+nums[n-1-i],ans);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245842,
                "title": "python3-simple-solution-beats-99-43-of-python3-submissions",
                "content": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()        \\n        return max([nums[x]+nums[-x-1] for x in range(len(nums)//2)])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()        \\n        return max([nums[x]+nums[-x-1] for x in range(len(nums)//2)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1241834,
                "title": "c-sort-2-indices",
                "content": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums) {\\n        Array.Sort(nums);\\n        int r = 0, i = 0, j = nums.Length - 1;\\n        while (i < j) {\\n            r = Math.Max(r, nums[i++] + nums[j--]);\\n        }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums) {\\n        Array.Sort(nums);\\n        int r = 0, i = 0, j = nums.Length - 1;\\n        while (i < j) {\\n            r = Math.Max(r, nums[i++] + nums[j--]);\\n        }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240324,
                "title": "c-0-n-log-n-with-explanations-two-pointer-5-lines",
                "content": "If we want to Minimize Maximum sum , First sort the array ,Now we can pick lowest value[0] with the higest value [n-1],and so on so that every elemet is in pair and Minimize Maximum sum.\\n0 , n-1\\n1, n-2\\n2,n-3\\n|\\n|\\n\\nTwo Pointer types;\\n\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        \\n        size_t n = nums.size();\\n        int pairSum=0,ans=0;\\n        \\n        for(int i=0;i<n/2;i++){\\n            pairSum = nums[i] + nums[n-1-i];\\n            ans = max(ans,pairSum);\\n        } \\n        return ans; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        \\n        size_t n = nums.size();\\n        int pairSum=0,ans=0;\\n        \\n        for(int i=0;i<n/2;i++){\\n            pairSum = nums[i] + nums[n-1-i];\\n            ans = max(ans,pairSum);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1239731,
                "title": "full-explanation-python-solution",
                "content": "**Approach: The idea is to first sort the given array and then iterate over the loop to form pairs (i, j) where i would start from 0 and j would start from end of array correspondingly. Increment i and Decrement j to form the next pair and so on.\\nBelow is the implementation of above approach. **\\n\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        \\n        i=0\\n        j=len(nums)-1\\n        res=0\\n        while(i<j):\\n            res=max(res,nums[i]+nums[j])\\n            i+=1\\n            j-=1\\n            \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        \\n        i=0\\n        j=len(nums)-1\\n        res=0\\n        while(i<j):\\n            res=max(res,nums[i]+nums[j])\\n            i+=1\\n            j-=1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1239179,
                "title": "java-clean-concise-optimal-code-sort-approach-100-faster-solution",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        int maxSum = Integer.MIN_VALUE;\\n        Arrays.sort (nums);\\n        \\n        for (int i = 0, j = nums.length - 1; i < j; i++, j--) {\\n            maxSum = Math.max (maxSum, nums[i] + nums[j]);\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n\\n**LOVE CODING :)\\nHAPPY CODING :)\\nHAPPY LEARNING :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        \\n        int maxSum = Integer.MIN_VALUE;\\n        Arrays.sort (nums);\\n        \\n        for (int i = 0, j = nums.length - 1; i < j; i++, j--) {\\n            maxSum = Math.max (maxSum, nums[i] + nums[j]);\\n        }\\n        \\n        return maxSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238987,
                "title": "faster-then-100-of-solutions-easy-to-understand",
                "content": "```\\npublic int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int pairSum = 0;\\n        for (int i = 0; i < nums.length / 2; ++i)\\n            pairSum = Math.max(pairSum, nums[i] + nums[nums.length - i - 1]);\\n        return pairSum;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\npublic int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int pairSum = 0;\\n        for (int i = 0; i < nums.length / 2; ++i)\\n            pairSum = Math.max(pairSum, nums[i] + nums[nums.length - i - 1]);\\n        return pairSum;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1238932,
                "title": "c-easy-solution",
                "content": "**Approach**: The idea is to first sort the given array and then \\nIterate over the loop to form pairs (i, j) \\n \\nWhere  i would start from 0 and j would start from end of array correspondingly. \\nIncrement i and Decrement j to form the next pair.\\nthen find the maximum sum of the pair.\\n \\n ```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int ans = INT_MIN;\\n        for (int i = 0, j = n - 1; i <= j; i++, j--)\\n        {\\n            nums[i] = nums[i] + nums[j];\\n            if(nums[i]>ans)\\n                ans = nums[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& nums) \\n    {\\n        int n = nums.size();\\n        sort(nums.begin(),nums.end());\\n        int ans = INT_MIN;\\n        for (int i = 0, j = n - 1; i <= j; i++, j--)\\n        {\\n            nums[i] = nums[i] + nums[j];\\n            if(nums[i]>ans)\\n                ans = nums[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238919,
                "title": "python-sort",
                "content": "It can easily be seen that we have to pair the smallest element with largest element and then second smallest element with second largest element and so on.\\n\\nThen we will compute the sum of all pairs and then return the maximum sum.\\n\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        pairs = []\\n        nums = sorted(nums)\\n        n = len(nums)\\n        for i in range(len(nums)//2):\\n            a = [nums[i],nums[n-i-1]]\\n            pairs.append(a)\\n        sum_ = []\\n        for i,j in pairs:\\n            sum_.append(i+j)\\n        return max(sum_)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        pairs = []\\n        nums = sorted(nums)\\n        n = len(nums)\\n        for i in range(len(nums)//2):\\n            a = [nums[i],nums[n-i-1]]\\n            pairs.append(a)\\n        sum_ = []\\n        for i,j in pairs:\\n            sum_.append(i+j)\\n        return max(sum_)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238865,
                "title": "python-python3-solution-in-5-lines-with-explanation",
                "content": "**Explanation:**\\n1. Sort the given list\\n2. Since it is a sorted list it will in the order of lowest to highest simple add kth smallest and kth largest element and append it to the another list or keep a max variable and change the maximum value while traversing itself.\\n3. Finally return the maximum element\\n\\n**Example:**\\nnums : [3,5,4,2,4,6]\\n1. [2,3,4,4,5,6]\\n2. (2+8),(3+5),(4+4) = [8,8,8]\\n3. max([8,8,8]) = 8\\n\\n**Code:**\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort() # sort the numbers\\n        lis = [] # to store the res and it takes O(n) space complexity\\n        for i in range(len(nums)//2): # traverse the loop to length(nums)/2 times\\n            lis.append(nums[i]+nums[~i]) #add the indexes 0+(-1),1+(-2)...goes on till n//2 times\\n        return max(lis) # return the maximum element in the list\\n```\\n\\n**Using max variable**\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()# sort the numbers\\n        maxi = 0 # to store the maximum value and it takes only O(1) space complexity\\n        for i in range(len(nums)//2):# traverse the loop to length(nums)/2 times\\n            maxi = max(maxi,nums[i]+nums[~i])#add the indexes 0+(-1),1+(-2)...goes on till n//2 times and compute the maxi value simultaneously\\n        return maxi\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort() # sort the numbers\\n        lis = [] # to store the res and it takes O(n) space complexity\\n        for i in range(len(nums)//2): # traverse the loop to length(nums)/2 times\\n            lis.append(nums[i]+nums[~i]) #add the indexes 0+(-1),1+(-2)...goes on till n//2 times\\n        return max(lis) # return the maximum element in the list\\n```\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()# sort the numbers\\n        maxi = 0 # to store the maximum value and it takes only O(1) space complexity\\n        for i in range(len(nums)//2):# traverse the loop to length(nums)/2 times\\n            maxi = max(maxi,nums[i]+nums[~i])#add the indexes 0+(-1),1+(-2)...goes on till n//2 times and compute the maxi value simultaneously\\n        return maxi\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238803,
                "title": "simple-sorting-technique-2-pointers-easy-solution",
                "content": "class Solution {\\n\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int lo = 0;\\n        int hi = nums.length - 1;\\n        int max = 0;\\n        while(lo < hi) {\\n            max = Math.max(max,(nums[lo] + nums[hi]));\\n            lo++;\\n            hi--;\\n        } \\n        \\n        return max;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int lo = 0;\\n        int hi = nums.length - 1;\\n        int max = 0;\\n        while(lo < hi) {\\n            max = Math.max(max,(nums[lo] + nums[hi]));\\n            lo++;\\n            hi--;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1238733,
                "title": "simple-c-sort-solution",
                "content": "```\\n// Runtime: 212 ms, faster than 100.00% of C++ online submissions for Minimize Maximum Pair Sum in Array.\\n// Memory Usage: 96.3 MB, less than 50.00% of C++ online submissions for Minimize Maximum Pair Sum in Array.\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        int ans=INT_MIN;\\n        // make pairs with smallest ans largest element and find max sum\\n        for(int i=0;i<A.size()/2;++i)\\n            ans=max(ans,A[i] + A[A.size()-i-1]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// Runtime: 212 ms, faster than 100.00% of C++ online submissions for Minimize Maximum Pair Sum in Array.\\n// Memory Usage: 96.3 MB, less than 50.00% of C++ online submissions for Minimize Maximum Pair Sum in Array.\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& A) {\\n        sort(A.begin(),A.end());\\n        int ans=INT_MIN;\\n        // make pairs with smallest ans largest element and find max sum\\n        for(int i=0;i<A.size()/2;++i)\\n            ans=max(ans,A[i] + A[A.size()-i-1]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238664,
                "title": "java-simple-sorting",
                "content": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for(int i = 0; i < n / 2; i++) sum = Math.max(sum, nums[i] + nums[n - 1 - i]);\\n        return sum;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minPairSum(int[] nums) {\\n        int n = nums.length;\\n        Arrays.sort(nums);\\n        int sum = 0;\\n        for(int i = 0; i < n / 2; i++) sum = Math.max(sum, nums[i] + nums[n - 1 - i]);\\n        return sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1238653,
                "title": "easy-explanation-with-code",
                "content": "**Approach:** \\n1. Maximum pair sum can only be obtained, if we pair up the maximum element with its minimum counterpart.\\n2. This can be done simply by sorting the vector, and adding the maximum to its minimum counterpart, i.e - we sum up the last and the first element, and likewise.\\n3. Below code will make the steps more clear.\\n\\n* C++\\n```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& a)\\n    {\\n        int n = a.size();\\n        sort(a.begin(), a.end());\\n        \\n        int i = 0, j = n-1;\\n        n = n/2;\\n        \\n        int ans = -1;\\n        while(i < n)\\n        {\\n            ans = max(ans, a[i]+a[j]);\\n            i++, j--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n* Java\\n```\\nclass Solution {\\n    public int minPairSum(int[] a)\\n    {\\n        int n = a.length;\\n        Arrays.sort(a);\\n        \\n        int i = 0, j = n-1;\\n        n = n/2;\\n        \\n        int ans = -1;\\n        while(i < n)\\n        {\\n            ans = Math.max(ans, a[i]+a[j]);\\n            i++;\\n            j--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPairSum(vector<int>& a)\\n    {\\n        int n = a.size();\\n        sort(a.begin(), a.end());\\n        \\n        int i = 0, j = n-1;\\n        n = n/2;\\n        \\n        int ans = -1;\\n        while(i < n)\\n        {\\n            ans = max(ans, a[i]+a[j]);\\n            i++, j--;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int minPairSum(int[] a)\\n    {\\n        int n = a.length;\\n        Arrays.sort(a);\\n        \\n        int i = 0, j = n-1;\\n        n = n/2;\\n        \\n        int ans = -1;\\n        while(i < n)\\n        {\\n            ans = Math.max(ans, a[i]+a[j]);\\n            i++;\\n            j--;\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238642,
                "title": "clean-python-3-sort",
                "content": "Sort `nums` first, use larger element to pair with smaller element.\\n\\nTime: `O(sort)`\\nSpace: `O(sort)`\\n\\n```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mx, left, right = 0, 0, len(nums) - 1\\n        while left < right:\\n            mx = max(mx, nums[left] + nums[right])\\n            left += 1\\n            right -= 1\\n        return mx\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPairSum(self, nums: List[int]) -> int:\\n        nums.sort()\\n        mx, left, right = 0, 0, len(nums) - 1\\n        while left < right:\\n            mx = max(mx, nums[left] + nums[right])\\n            left += 1\\n            right -= 1\\n        return mx\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085481,
                "title": "c-linq",
                "content": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums)\\n    {\\n      Array.Sort(nums);\\n      return nums[..(nums.Length/2)]\\n        .Select((n, i) => n + nums[^(i + 1)])\\n        .Max();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinPairSum(int[] nums)\\n    {\\n      Array.Sort(nums);\\n      return nums[..(nums.Length/2)]\\n        .Select((n, i) => n + nums[^(i + 1)])\\n        .Max();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4085047,
                "title": "python-easy-solution",
                "content": "\\n# Code\\n```\\nclass Solution(object):\\n    def minPairSum(self, nums): \\n        output = 0\\n        nums.sort()\\n        for i in range(len(nums)/2):\\n            current = nums[i] + nums[len(nums) - i - 1]\\n            if(current > output):\\n                output = current\\n        return output\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minPairSum(self, nums): \\n        output = 0\\n        nums.sort()\\n        for i in range(len(nums)/2):\\n            current = nums[i] + nums[len(nums) - i - 1]\\n            if(current > output):\\n                output = current\\n        return output\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4083469,
                "title": "1877",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = nums[0] + nums[nums.length-1];\\n        for(int i=1;i<nums.length/2;i++){\\n            sum = Math.max(sum,nums[i]+nums[nums.length-1-i]);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int sum = nums[0] + nums[nums.length-1];\\n        for(int i=1;i<nums.length/2;i++){\\n            sum = Math.max(sum,nums[i]+nums[nums.length-1-i]);\\n        }\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1717331,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1784492,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1753146,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1657272,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1800361,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1670061,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1790493,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1741951,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1732312,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1785186,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1717331,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1784492,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1753146,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1657272,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1800361,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1670061,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1790493,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1741951,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1732312,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 1785186,
                "content": [
                    {
                        "username": "ghost_nayek",
                        "content": "The Pair combination is the missing part in the description of the problem .Leet code should add details about pairing of the elements."
                    },
                    {
                        "username": "District_12",
                        "content": "One of the worst problem descriptions on leetcode so far."
                    },
                    {
                        "username": "abdullahlevin",
                        "content": "It definitely is"
                    },
                    {
                        "username": "ayushluthra62",
                        "content": "Easy . It is just marked as medium because:\\u2B07\\nThe \"medium difficulty\" of this question refers to the difficulty of reading the question. "
                    },
                    {
                        "username": "geekyshark",
                        "content": "[@arshia_ilaty](/arshia_ilaty) we can use one minheap and one maxheap if we want to solve without sorting"
                    },
                    {
                        "username": "arshia_ilaty",
                        "content": "It becomes easy because we use sort. Try to solve this question without sorting it."
                    },
                    {
                        "username": "user5130F",
                        "content": "Did not understand how to pair the element."
                    },
                    {
                        "username": "godshiva",
                        "content": "You split the array into groups of two in any way you see fit, so long as each element appears in only 1 pair and each pair contains 2 distinct elements. \\nHint: The minimized max will never be less than the largest element in the array, which has to be used, paired with the smallest element in the array (the lowest amount you can add to it)"
                    },
                    {
                        "username": "user1678hd",
                        "content": "\"Input: nums = [3,5,2,3]\\nOutput: 7\\nExplanation: The elements can be paired up into pairs (3,3) and (5,2).\\nThe maximum pair sum is max(3+3, 5+2) = max(6, 7) = 7.\"\\nhow are they pairing ,5+3 =8 is max pair value.\\nor i am interpreting it wrong"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "It's because you have to minimize the sums of each pair, and only after that, you return the maximum value of the minimized sums"
                    },
                    {
                        "username": "Pawankuamrmeena_425",
                        "content": "i am unable to final  conculsio. In which order we should be make pairs of nums."
                    },
                    {
                        "username": "mandarin_075",
                        "content": "you need to pair the  largest element with the smallest element , second largest element with the second smallest element and so on and return the max sum formed by adding those pairs."
                    },
                    {
                        "username": "Saumya1915",
                        "content": "You have to find out max pair sum which is minimized. For Example lets take a array [1,2,3,4] we can make a pair (3,4) but this pair won\\'t return sum that is minimized. (3,4) can return the sum that is maximum. Now let\\'s take (1,4) or (2,3). These pair will return minimized sum. Now from all minimized sum of different pairs find out the sum which is maximum among them. So the first thing would be to sort the array.\\n"
                    },
                    {
                        "username": "seifsoliman",
                        "content": "first : sort\\nsecond : find mid and reverse second part \\nthird : sum first value in first mid with first value in second part\\nthen you will find max"
                    },
                    {
                        "username": "myjscoffee",
                        "content": "[@georgezakharov](/georgezakharov) if elements are duplicated adding first and last value wont work\nfor ex: [4,1,5,1,2,5,1,5,5,4] here the max sum would be 8 but not 6. so you need to use 2 pointers"
                    },
                    {
                        "username": "chailattewithcream",
                        "content": "[@georgezakharov](/georgezakharov) Yeah you don't need to reverse it, you can use two pointers. I guess it just makes the code cleaner and shorter because you only need to do [::-1] but it would give similar time complexity."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Could you explain why do we need to find mid and reverse second part?\nCan we just take first and last value after sorting and sum up?"
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: sort the array first."
                    },
                    {
                        "username": "kadaleaniket08",
                        "content": "This problem can be solved using sorting and two pointers.\\n"
                    },
                    {
                        "username": "kmp1084",
                        "content": "sort, next sum the highest with the lowest, 2nd highest with the 2nd lowest and so on. Give max among these sums!"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thanx, you\\'ve made this task simple :))"
                    }
                ]
            },
            {
                "id": 2063463,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 2045193,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 2032625,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 2031671,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 2013820,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 1986232,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 1967097,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 1962042,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 1946858,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            },
            {
                "id": 1936227,
                "content": [
                    {
                        "username": "alexposl89",
                        "content": "Worst description ever. Especially this point \"The maximum pair sum is minimized.\"\\nWhen I tried to find maximum instead of minimum it worked.\\n\\n-------SPOILER-----\\n\\n\\n\\n\\n `class Solution {\\n    public int minPairSum(int[] nums) {\\n        Arrays.sort(nums);\\n        int max = 0;\\n        for (int i = 0; i < nums.length / 2; i++) {\\n            int current = nums[i] + nums[nums.length - i - 1];\\n            if (current > max) {\\n                max = current;\\n            }\\n        }\\n        return max;\\n    }\\n}`"
                    },
                    {
                        "username": "d_anand",
                        "content": "This should be marked as easy. It was a very simple question."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Thank you for this important information"
                    },
                    {
                        "username": "BatMe",
                        "content": "Hint: Sort and traverse two pointers from low end and high end while keep on storing the maximum sum. \\n\\nI wonder, Why google asked this question? Am I missing something here? Please help"
                    },
                    {
                        "username": "z_acc",
                        "content": "it wants the maximum pair where each pair is the the ith max summed with the ith min hopefully that's clarifying sorry if that's confusing"
                    },
                    {
                        "username": "Najmuddin_Ansari",
                        "content": "Intuition:\\n\\nWhen faced with the challenge to minimize the maximum pair sum, the instinctual approach might be to evenly distribute the weight of the numbers across all pairs. The most direct threat to having a small maximum sum would be the largest numbers in the array. If they are paired with other large numbers, the resulting pair sum could be excessively large. By contrast, pairing a large number with a small one could \\'neutralize\\' its impact. Think of it as a balance where you\\'re trying to pair heavy items with light ones to keep both sides as even as possible.\\n\\nFrom this line of reasoning, one might deduce that pairing the largest number with the smallest, the second-largest with the second-smallest, and so on, would produce the most balanced pairs. This ensures that the maximum pair sum is kept as small as possible."
                    },
                    {
                        "username": "umapavan",
                        "content": "hello guys try to elaborate on this question... \\nhere we need to find the maximum pair sum is minimized as it indicates the pair of the maximum element and minimum element gives you the minimized max pair\\n->but in the case of number repetitions  our assumption fails, consider this example \\n[4,1,5,1,2,5,1,5,5,4] In this (5,1) gives 6 but (4,4) gives 8 \\nso pair all the first max with the first min and the second max with the second min and so on and finally find the max of all those pair sums and then done.\\ntry to code this.......\\nhappy coding ^_^"
                    },
                    {
                        "username": "vavasor",
                        "content": "If u think it\\'s too easy, you are correct...."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until got it on an interview (c)"
                    },
                    {
                        "username": "vijay__bhaskar",
                        "content": "This question very much similar to 2491 same concept.\\nhttps://leetcode.com/problems/divide-players-into-teams-of-equal-skill/"
                    },
                    {
                        "username": "JW-You",
                        "content": "Example wrongs... the example in question is given array [1,5,2,3,4,4]. we can make pair like (1,4), (2,5), (3,4).. then, the minimized maximum pair sum can be 7."
                    },
                    {
                        "username": "code_rama",
                        "content": "Everybody seems to sort the array. How to get 100% then?\n"
                    }
                ]
            }
        ]
    }
]