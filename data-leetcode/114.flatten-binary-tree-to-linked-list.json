[
    {
        "title": "Longest Common Prefix",
        "question_content": "Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \"\".\n&nbsp;\nExample 1:\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\n\nExample 2:\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n\n&nbsp;\nConstraints:\n\n\t1 <= strs.length <= 200\n\t0 <= strs[i].length <= 200\n\tstrs[i] consists of only lowercase English letters.",
        "solutions": [
            {
                "id": 3174307,
                "title": "well-explained-code-using-strings-in-java",
                "content": "\\n# Approach\\nThis code is used to find the longest common prefix of an array of strings, which is defined as the longest string that is a prefix of all the strings in the array. By sorting the array and then comparing the first and last elements, the code is able to find the common prefix that would be shared by all strings in the array.\\n\\n1. Sort the elements of an array of strings called \"strs\" in lexicographic (alphabetical) order using the Arrays.sort(strs) method.\\n2. Assign the first element of the sorted array (the lexicographically smallest string) to a string variable s1.\\n3. Assign the last element of the sorted array (the lexicographically largest string) to a string variable s2.\\n4. Initialize an integer variable idx to 0.\\n5. Start a while loop that continues while idx is less than the length of s1 and s2.\\n6. Within the while loop, check if the character at the current index in s1 is equal to the character at the same index in s2. If the characters are equal, increment the value of idx by 1.\\n7. If the characters are not equal, exit the while loop.\\n8. Return the substring of s1 that starts from the first character and ends at the idxth character (exclusive).\\n\\n\\n\\n# Complexity\\n- Time complexity:\\n1. Sorting the array of strings takes O(Nlog(N)) time. This is because most of the common sorting algorithms like quicksort, mergesort, and heapsort have an average time complexity of O(Nlog(N)).\\n2. Iterating over the characters of the first and last strings takes O(M) time. This is because the code compares the characters of the two strings until it finds the first mismatch.\\n\\nTherefore, the total time complexity is O(Nlog(N) + M).\\n\\n\\n\\n\\n- Space complexity:\\nThe space used by the two string variables s1 and s2 is proportional to the length of the longest string in the array. Therefore, the space complexity is O(1) as it does not depend on the size of the input array.\\n\\n# Reason for Sorting \\n\\nThe reason why we sort the input array of strings and compare the first and last strings is that the longest common prefix of all the strings must be a prefix of the first string and a prefix of the last string in the sorted array. This is because strings are ordered based on their alphabetical order (Lexicographical order).\\nFor example, consider the input array of strings {\"flower\", \"flow\", \"flight\"}. After sorting the array, we get {\"flight\", \"flow\", \"flower\"}. The longest common prefix of all the strings is \"fl\", which is located at the beginning of the first string \"flight\" and the second string \"flow\". Therefore, by comparing the first and last strings of the sorted array, we can easily find the longest common prefix.\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        Arrays.sort(strs);\\n        String s1 = strs[0];\\n        String s2 = strs[strs.length-1];\\n        int idx = 0;\\n        while(idx < s1.length() && idx < s2.length()){\\n            if(s1.charAt(idx) == s2.charAt(idx)){\\n                idx++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return s1.substring(0, idx);\\n    }\\n}\\n```\\n![upvote.jpeg](https://assets.leetcode.com/users/images/078cc82b-d80b-4aef-ae08-ce75ef6c698d_1676176908.0916324.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        Arrays.sort(strs);\\n        String s1 = strs[0];\\n        String s2 = strs[strs.length-1];\\n        int idx = 0;\\n        while(idx < s1.length() && idx < s2.length()){\\n            if(s1.charAt(idx) == s2.charAt(idx)){\\n                idx++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return s1.substring(0, idx);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3273176,
                "title": "python3-c-java-19-ms-beats-99-91",
                "content": "# Please UPVOTE\\uD83D\\uDE0A\\n![image.png](https://assets.leetcode.com/users/images/f54185ef-bb76-4c6e-807b-66e506e7fab0_1678294130.6935549.png)\\n\\nThis code implements the longestCommonPrefix function that takes a list of strings v as input and returns the longest common prefix of all the strings. Here is an explanation of how the code works:\\n\\n1. Initialize an empty string ans to store the common prefix.\\n2. Sort the input list v lexicographically. This step is necessary because the common prefix should be common to all the strings, so we need to find the common prefix of the first and last string in the sorted list.\\n3. Iterate through the characters of the first and last string in the sorted list, stopping at the length of the shorter string.\\n4. If the current character of the first string is not equal to the current character of the last string, return the common prefix found so far.\\n5. Otherwise, append the current character to the ans string.\\n6. Return the ans string containing the longest common prefix.\\n\\nNote that the code assumes that the input list v is non-empty, and that all the strings in v have at least one character. If either of these assumptions is not true, the code may fail.\\n# Python3\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, v: List[str]) -> str:\\n        ans=\"\"\\n        v=sorted(v)\\n        first=v[0]\\n        last=v[-1]\\n        for i in range(min(len(first),len(last))):\\n            if(first[i]!=last[i]):\\n                return ans\\n            ans+=first[i]\\n        return ans \\n\\n```\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& v) {\\n        string ans=\"\";\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        string first=v[0],last=v[n-1];\\n        for(int i=0;i<min(first.size(),last.size());i++){\\n            if(first[i]!=last[i]){\\n                return ans;\\n            }\\n            ans+=first[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# Java \\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] v) {\\n        StringBuilder ans = new StringBuilder();\\n        Arrays.sort(v);\\n        String first = v[0];\\n        String last = v[v.length-1];\\n        for (int i=0; i<Math.min(first.length(), last.length()); i++) {\\n            if (first.charAt(i) != last.charAt(i)) {\\n                return ans.toString();\\n            }\\n            ans.append(first.charAt(i));\\n        }\\n        return ans.toString();\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/a6c83c54-1d1a-4f26-8273-b687d119dd5b_1679889261.1494205.png)",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Sort"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, v: List[str]) -> str:\\n        ans=\"\"\\n        v=sorted(v)\\n        first=v[0]\\n        last=v[-1]\\n        for i in range(min(len(first),len(last))):\\n            if(first[i]!=last[i]):\\n                return ans\\n            ans+=first[i]\\n        return ans \\n\\n```\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& v) {\\n        string ans=\"\";\\n        sort(v.begin(),v.end());\\n        int n=v.size();\\n        string first=v[0],last=v[n-1];\\n        for(int i=0;i<min(first.size(),last.size());i++){\\n            if(first[i]!=last[i]){\\n                return ans;\\n            }\\n            ans+=first[i];\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] v) {\\n        StringBuilder ans = new StringBuilder();\\n        Arrays.sort(v);\\n        String first = v[0];\\n        String last = v[v.length-1];\\n        for (int i=0; i<Math.min(first.length(), last.length()); i++) {\\n            if (first.charAt(i) != last.charAt(i)) {\\n                return ans.toString();\\n            }\\n            ans.append(first.charAt(i));\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6918,
                "title": "short-python-solution",
                "content": "```\\n def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "solutionTags": [],
                "code": "```\\n def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 721752,
                "title": "java-100-just-compare-two-strings",
                "content": "```class Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0)\\n            return \"\";\\n        \\n        Arrays.sort(strs);\\n        String first = strs[0];\\n        String last = strs[strs.length - 1];\\n        int c = 0;\\n        while(c < first.length())\\n        {\\n            if (first.charAt(c) == last.charAt(c))\\n                c++;\\n            else\\n                break;\\n        }\\n        return c == 0 ? \"\" : first.substring(0, c);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0)\\n            return \"\";\\n        \\n        Arrays.sort(strs);\\n        String first = strs[0];\\n        String last = strs[strs.length - 1];\\n        int c = 0;\\n        while(c < first.length())\\n        {\\n            if (first.charAt(c) == last.charAt(c))\\n                c++;\\n            else\\n                break;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1405155,
                "title": "java-detailed-solution-0-ms-faster-than-100",
                "content": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String prefix = strs[0];\\n        for(int index=1;index<strs.length;index++){\\n            while(strs[index].indexOf(prefix) != 0){\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n\\n/*\\nPLEASE UPVOTE IF IT HELPS YOU! THANK YOU!\\nRecommend to dry run along with the example.\\n\\nWorking:\\n1)Take the first(index=0) string in the array as prefix.\\n2)Iterate from second(index=1) string till the end.\\n3)Use the indexOf() function to check if the prefix is there in the strs[i] or not.\\nIf the prefix is there the function returns 0 else -1.\\n4)Use the substring function to chop the last letter from prefix each time the function return -1.\\n\\neg:\\nstrs=[\"flower\", \"flow\", \"flight\"]\\nprefix=flower\\nindex=1\\n    while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flower\")!=0)\\n    Since flower as a whole is not in flow, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flowe\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flowe\")!=0)\\n    Since flowe as a whole is not in flow, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flow\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flow\")!=0)\\n    Since flow as a whole is in flow, it returns 0 so now prefix=flow\\nindex=2\\n    while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"flow\")!=0)\\n    Since flow as a whole is not in flight, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flo\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"flo\")!=0)\\n    Since flo as a whole is not in flight, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"fl\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"fl\")!=0)\\n    Since fl as a whole is in flight, it returns 0 so now prefix=fl\\nindex=3, for loop terminates and we return prefix which is equal to fl\\n*/\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String prefix = strs[0];\\n        for(int index=1;index<strs.length;index++){\\n            while(strs[index].indexOf(prefix) != 0){\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n\\n/*\\nPLEASE UPVOTE IF IT HELPS YOU! THANK YOU!\\nRecommend to dry run along with the example.\\n\\nWorking:\\n1)Take the first(index=0) string in the array as prefix.\\n2)Iterate from second(index=1) string till the end.\\n3)Use the indexOf() function to check if the prefix is there in the strs[i] or not.\\nIf the prefix is there the function returns 0 else -1.\\n4)Use the substring function to chop the last letter from prefix each time the function return -1.\\n\\neg:\\nstrs=[\"flower\", \"flow\", \"flight\"]\\nprefix=flower\\nindex=1\\n    while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flower\")!=0)\\n    Since flower as a whole is not in flow, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flowe\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flowe\")!=0)\\n    Since flowe as a whole is not in flow, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flow\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flow\".indexOf(\"flow\")!=0)\\n    Since flow as a whole is in flow, it returns 0 so now prefix=flow\\nindex=2\\n    while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"flow\")!=0)\\n    Since flow as a whole is not in flight, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"flo\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"flo\")!=0)\\n    Since flo as a whole is not in flight, it return -1 and  prefix=prefix.substring(0,prefix.length()-1) reduces prefix to \"fl\"\\n    Again while(strs[index].indexOf(prefix) != 0) means while(\"flight\".indexOf(\"fl\")!=0)\\n    Since fl as a whole is in flight, it returns 0 so now prefix=fl\\nindex=3, for loop terminates and we return prefix which is equal to fl\\n*/\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391089,
                "title": "c-easy-to-understand-solution-using-sort",
                "content": "The code below is very much self explanatory. \\n1. We first sort the array of strings.\\n2. Then, we choose the first and last string in the array. `[They are supposed to be the most different among all the pairs of strings in the sorted array]`\\n3. We just compare how many common characters match from index  `i = 0`  of these two strings.\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        int n = str.size();\\n        if(n==0) return \"\";\\n        \\n        string ans  = \"\";\\n        sort(begin(str), end(str));\\n        string a = str[0];\\n        string b = str[n-1];\\n        \\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]){\\n                ans = ans + a[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        int n = str.size();\\n        if(n==0) return \"\";\\n        \\n        string ans  = \"\";\\n        sort(begin(str), end(str));\\n        string a = str[0];\\n        string b = str[n-1];\\n        \\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]){\\n                ans = ans + a[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6910,
                "title": "java-code-with-13-lines",
                "content": "\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs == null || strs.length == 0)    return \"\";\\n        String pre = strs[0];\\n        int i = 1;\\n        while(i < strs.length){\\n            while(strs[i].indexOf(pre) != 0)\\n                pre = pre.substring(0,pre.length()-1);\\n            i++;\\n        }\\n        return pre;\\n    }",
                "solutionTags": [],
                "code": "\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs == null || strs.length == 0)    return \"\";\\n        String pre = strs[0];\\n        int i = 1;\\n        while(i < strs.length){\\n            while(strs[i].indexOf(pre) != 0)\\n                pre = pre.substring(0,pre.length()-1);\\n            i++;\\n        }\\n        return pre;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 172553,
                "title": "beat-100-python-submission-short-and-clean",
                "content": "**using enumerater**\n```\nclass Solution:\n    def longestCommonPrefix(self, m):\n        if not m: return ''\n\t\t\t\t#since list of string will be sorted and retrieved min max by alphebetic order\n        s1 = min(m)\n        s2 = max(m)\n\n        for i, c in enumerate(s1):\n            if c != s2[i]:\n                return s1[:i] #stop until hit the split index\n        return s1\n```",
                "solutionTags": [],
                "code": "```\nclass Solution:\n    def longestCommonPrefix(self, m):\n        if not m: return ''\n\t\t\t\t#since list of string will be sorted and retrieved min max by alphebetic order\n        s1 = min(m)\n        s2 = max(m)\n\n        for i, c in enumerate(s1):\n            if c != s2[i]:\n                return s1[:i] #stop until hit the split index\n        return s1\n```",
                "codeTag": "Java"
            },
            {
                "id": 2669032,
                "title": "c-very-easy-explained",
                "content": "The longest common prefix is common to all the strings. So, we can fix one string and check the common prefix of this string with other strings. The minimum such length is found and the answer is the substring of the fixed string starting from 0 to the length of the above such minimum.\\nHere, I have fixed 0th string and checked other strings with this. \\n**Full Code:**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& s) {\\n        int ans = s[0].length(), n = s.size();\\n        for(int i=1; i<n; i++){\\n            int j = 0;\\n            while(j<s[i].length() && s[i][j]==s[0][j])j++;\\n            ans = min(ans, j);\\n        }\\n        return s[0].substr(0, ans);\\n    }\\n};\\n```\\n**Incase you found the post useful, please give it an upvote.**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& s) {\\n        int ans = s[0].length(), n = s.size();\\n        for(int i=1; i<n; i++){\\n            int j = 0;\\n            while(j<s[i].length() && s[i][j]==s[0][j])j++;\\n            ans = min(ans, j);\\n        }\\n        return s[0].substr(0, ans);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184623,
                "title": "simplest-c-code-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end());\\n        int a=strs.size();\\n        string n=strs[0],m=strs[a-1],ans=\"\";\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]==m[i]){ans+=n[i];}\\n            else break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\nDo UPVOTE if you like\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end());\\n        int a=strs.size();\\n        string n=strs[0],m=strs[a-1],ans=\"\";\\n        for(int i=0;i<n.size();i++){\\n            if(n[i]==m[i]){ans+=n[i];}\\n            else break;\\n        }\\n        return ans;\\n        \\n    }\\n};\\nDo UPVOTE if you like\\n```",
                "codeTag": "Java"
            },
            {
                "id": 354496,
                "title": "python3-list-zip-str",
                "content": "*  list(zip(*strs))\\nstrs = [\"flower\",\"flow\",\"flight\"]\\n```\\nstrs = [\"flower\",\"flow\",\"flight\"]\\nl = list(zip(*strs))\\n>>> l = [(\\'f\\', \\'f\\', \\'f\\'), (\\'l\\', \\'l\\', \\'l\\'), (\\'o\\', \\'o\\', \\'i\\'), (\\'w\\', \\'w\\', \\'g\\')]\\n```\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        l = list(zip(*strs))\\n        prefix = \"\"\\n        for i in l:\\n            if len(set(i))==1:\\n                prefix += i[0]\\n            else:\\n                break\\n        return prefix\\n```\\n* traditional scan vertically\\n```\\n i      0  1  2  3  4  5\\n 0      f  l  o  w  e  r\\n 1\\t    f  l  o  w\\n 2\\t    f  l  i  g  h  t\\n\\t\\t\\nWe choose the first string in the list as a reference. in this case is str[0] = \"flower\"\\nthe outside for-loop go through each character of the str[0] or \"flower\". f->l->o->w->e->r\\nthe inside for-loop, go through the words, in this case is flow, flight.\\n\\n\\nstrs[j][i] means the the i\\'s character of the j words in the strs.\\n\\nthere are 3 cases when we proceed the scan:\\n\\ncase 1: strs[j][i] = c, strs[1][2] = \\'o\\' and strs[0][2] = \\'o\\';  keep going;\\ncase 2: strs[j][i] != c, strs[2][2] = \\'i\\' and strs[0][2] = \\'o\\';  break the rule, we can return strs[j][:i]. when comes to slicing a string, [:i] won\\'t include the index i;\\ncase 3: i = len(strs[j]) which means current word at strs[j] doesn\\'t have character at index i, since it\\'s 0 based index. the lenght equals i, the index ends at i - 1; break the rule, we can return.\\n\\n \\n```\\n\\n\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if strs == None or len(strs) == 0: return \"\"\\n        for i in range(len(strs[0])): \\n            c = strs[0][i]// \\n            for j in range(1,len(strs)):\\n                if i == len(strs[j]) or strs[j][i] != c:\\n                    return strs[0][:i]\\n        return strs[0] if strs else \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nstrs = [\"flower\",\"flow\",\"flight\"]\\nl = list(zip(*strs))\\n>>> l = [(\\'f\\', \\'f\\', \\'f\\'), (\\'l\\', \\'l\\', \\'l\\'), (\\'o\\', \\'o\\', \\'i\\'), (\\'w\\', \\'w\\', \\'g\\')]\\n```\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        l = list(zip(*strs))\\n        prefix = \"\"\\n        for i in l:\\n            if len(set(i))==1:\\n                prefix += i[0]\\n            else:\\n                break\\n        return prefix\\n```\n```\\n i      0  1  2  3  4  5\\n 0      f  l  o  w  e  r\\n 1\\t    f  l  o  w\\n 2\\t    f  l  i  g  h  t\\n\\t\\t\\nWe choose the first string in the list as a reference. in this case is str[0] = \"flower\"\\nthe outside for-loop go through each character of the str[0] or \"flower\". f->l->o->w->e->r\\nthe inside for-loop, go through the words, in this case is flow, flight.\\n\\n\\nstrs[j][i] means the the i\\'s character of the j words in the strs.\\n\\nthere are 3 cases when we proceed the scan:\\n\\ncase 1: strs[j][i] = c, strs[1][2] = \\'o\\' and strs[0][2] = \\'o\\';  keep going;\\ncase 2: strs[j][i] != c, strs[2][2] = \\'i\\' and strs[0][2] = \\'o\\';  break the rule, we can return strs[j][:i]. when comes to slicing a string, [:i] won\\'t include the index i;\\ncase 3: i = len(strs[j]) which means current word at strs[j] doesn\\'t have character at index i, since it\\'s 0 based index. the lenght equals i, the index ends at i - 1; break the rule, we can return.\\n\\n \\n```\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if strs == None or len(strs) == 0: return \"\"\\n        for i in range(len(strs[0])): \\n            c = strs[0][i]// \\n            for j in range(1,len(strs)):\\n                if i == len(strs[j]) or strs[j][i] != c:\\n                    return strs[0][:i]\\n        return strs[0] if strs else \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6924,
                "title": "sorted-the-array-java-solution-2-ms",
                "content": "Sort the array first, and then you can simply compare the first and last elements in the sorted array.\\n\\n\\n        public String longestCommonPrefix(String[] strs) {\\n            StringBuilder result = new StringBuilder();\\n            \\n            if (strs!= null && strs.length > 0){\\n            \\n                Arrays.sort(strs);\\n                \\n                char [] a = strs[0].toCharArray();\\n                char [] b = strs[strs.length-1].toCharArray();\\n                \\n                for (int i = 0; i < a.length; i ++){\\n                    if (b.length > i && b[i] == a[i]){\\n                        result.append(b[i]);\\n                    }\\n                    else {\\n                        return result.toString();\\n                    }\\n                }\\n            return result.toString();\\n        }",
                "solutionTags": [],
                "code": "Sort the array first, and then you can simply compare the first and last elements in the sorted array.\\n\\n\\n        public String longestCommonPrefix(String[] strs) {\\n            StringBuilder result = new StringBuilder();\\n            \\n            if (strs!= null && strs.length > 0){\\n            \\n                Arrays.sort(strs);\\n                \\n                char [] a = strs[0].toCharArray();\\n                char [] b = strs[strs.length-1].toCharArray();\\n                \\n                for (int i = 0; i < a.length; i ++){\\n                    if (b.length > i && b[i] == a[i]){\\n                        result.append(b[i]);\\n                    }\\n                    else {\\n                        return result.toString();\\n                    }\\n                }\\n            return result.toString();\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 6911,
                "title": "simple-python-solution",
                "content": "Might be a bit slow, but here's my relatively elegant Python solution:\\n\\n    class Solution:\\n        # @return a string\\n        def longestCommonPrefix(self, strs):\\n            if not strs:\\n                return \"\"\\n                \\n            for i, letter_group in enumerate(zip(*strs)):\\n                if len(set(letter_group)) > 1:\\n                    return strs[0][:i]\\n            else:\\n                return min(strs)",
                "solutionTags": [],
                "code": "Might be a bit slow, but here's my relatively elegant Python solution:\\n\\n    class Solution:\\n        # @return a string\\n        def longestCommonPrefix(self, strs):\\n            if not strs:\\n                return \"\"\\n                \\n            for i, letter_group in enumerate(zip(*strs)):\\n                if len(set(letter_group)) > 1:\\n                    return strs[0][:i]\\n            else:\\n                return min(strs)",
                "codeTag": "Java"
            },
            {
                "id": 2748936,
                "title": "simple-java-solution",
                "content": "```\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length==0) return \"\";\\n        String prefix=strs[0];\\n        for(int i=1;i<strs.length;i++){\\n            while(strs[i].indexOf(prefix)!=0){\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n            \\n        }\\n        return prefix;\\n        \\n        \\n    }\\n//Please upvote",
                "solutionTags": [],
                "code": "```\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length==0) return \"\";\\n        String prefix=strs[0];\\n        for(int i=1;i<strs.length;i++){\\n            while(strs[i].indexOf(prefix)!=0){\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n            \\n        }\\n        return prefix;\\n        \\n        \\n    }\\n//Please upvote",
                "codeTag": "Unknown"
            },
            {
                "id": 1351149,
                "title": "python-startswith",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        pre = strs[0]\\n        \\n        for i in strs:\\n            while not i.startswith(pre):\\n                pre = pre[:-1]\\n        \\n        return pre     \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        pre = strs[0]\\n        \\n        for i in strs:\\n            while not i.startswith(pre):\\n                pre = pre[:-1]\\n        \\n        return pre     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 6983,
                "title": "js-higher-order-function-solution-with-concise-and-easy-to-understand-code",
                "content": "reduce is just for this: take a list of strings and reduce them to one string\\n\\n    var longestCommonPrefix = function(strs) {\\n        'use strict';\\n        if (strs === undefined || strs.length === 0) { return ''; }\\n        \\n        return strs.reduce((prev, next) => {\\n            let i = 0;\\n            while (prev[i] && next[i] && prev[i] === next[i]) i++;\\n            return prev.slice(0, i);\\n        });\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "reduce is just for this: take a list of strings and reduce them to one string\\n\\n    var longestCommonPrefix = function(strs) {\\n        'use strict';\\n        if (strs === undefined || strs.length === 0) { return ''; }\\n        \\n        return strs.reduce((prev, next) => {\\n            let i = 0;\\n            while (prev[i] && next[i] && prev[i] === next[i]) i++;\\n            return prev.slice(0, i);\\n        });\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 3031312,
                "title": "longest-common-prefix-in-python",
                "content": "# Intuition\\nCompare each letter of each word to check if they match, and add them to an empty string until you hit a character that doesn\\'t match. Return the string obtained so far.\\n\\n# Approach\\nInitialize an empty string. Zip the list, so you get the first characters of each word together in a tuple, the second letters in another tuple, and so on. Convert each such tuple into a set, and check if the length of the set is 1 - to understand if the elements were same (as sets store only 1 instance of a repeated element). If the length of the set is 1, add the first element of the tuple (any element is fine, as all elements are same but we take the first element just to be cautious) to the empty string. If the length of a set is not 1, return the string as is. Finally, return the string obtained thus far.\\n\\n# Complexity\\n- Time complexity:\\n\\n\\n- Space complexity:\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res = \"\"\\n        for a in zip(*strs):\\n            if len(set(a)) == 1: \\n                res += a[0]\\n            else: \\n                return res\\n        return res\\n                        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res = \"\"\\n        for a in zip(*strs):\\n            if len(set(a)) == 1: \\n                res += a[0]\\n            else: \\n                return res\\n        return res\\n                        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393325,
                "title": "c-solution-100-faster-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs){\\n        int n =strs.size();\\n        string ans; \\n        sort(strs.begin(), strs.end());\\n        string a = strs[0];\\n        string b = strs[n-1];\\n        for(int i =0; i< a.size(); i++){\\n            if(a[i] == b[i]){\\n                ans += a[i];\\n            }else break;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs){\\n        int n =strs.size();\\n        string ans; \\n        sort(strs.begin(), strs.end());\\n        string a = strs[0];\\n        string b = strs[n-1];\\n        for(int i =0; i< a.size(); i++){\\n            if(a[i] == b[i]){\\n                ans += a[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 526694,
                "title": "javascript-simple-solution-using-every-with-explanation",
                "content": "# Approach\\n- First find the shortest string in the array; the length of this string is the maximum length of our prefix \\n\\t- this is because a prefix can\\'t be longer than the word it inhabits\\n- Next we iterate from `index 0` to `maxPrefixLength - 1`\\n- We use this index to check the corresponding character of each string together and compare them\\n- This is easily done using `Array.every`\\n- If all characters at `index i` match, then we add it to our `prefix` result string\\n- As soon as we hit one mismatch, that\\'s the end of the common prefix and we break out of our loop\\n- return prefix at the end, which may be empty\\n\\n# Solution\\n```\\nvar longestCommonPrefix = function(strs) {\\n  if (!strs.length) return \\'\\';\\n  let prefix = \\'\\';\\n  let maxPrefixLength = Math.min(...strs.map(str => str.length));\\n  for (let i = 0; i < maxPrefixLength; i++) {\\n    let char = strs[0][i];\\n    if (strs.every(str => str[i] === char)) {\\n      prefix += char;\\n    } else {\\n      break;\\n    }\\n  };  \\n  return prefix;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n  if (!strs.length) return \\'\\';\\n  let prefix = \\'\\';\\n  let maxPrefixLength = Math.min(...strs.map(str => str.length));\\n  for (let i = 0; i < maxPrefixLength; i++) {\\n    let char = strs[0][i];\\n    if (strs.every(str => str[i] === char)) {\\n      prefix += char;\\n    } else {\\n      break;\\n    }\\n  };  \\n  return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1136361,
                "title": "accepted-solution-for-swift",
                "content": "<blockquote>\\n<b>Disclaimer:</b> By using any content from this post or thread, you release the author(s) from all liability and warranty of any kind. You are free to use the content freely and as you see fit. Any suggestions for improvement are welcome and greatly appreciated! Happy coding!\\n</blockquote>\\n\\n```swift\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        \\n        if strs.isEmpty { return \"\" }\\n        var common = strs[0]\\n        \\n        for ch in strs {\\n            while !ch.hasPrefix(common) {\\n                common = String(common.dropLast())\\n            }\\n        }\\n        return common\\n    }\\n}\\n```\\n\\n---\\n\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.004 (0.006) seconds\\n</pre>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.longestCommonPrefix([\"flower\",\"flow\",\"flight\"])\\n        XCTAssertEqual(value, \"fl\")\\n    }\\n    func test1() {\\n        let value = solution.longestCommonPrefix([\"dog\",\"racecar\",\"car\"])\\n        XCTAssertEqual(value, \"\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n</details>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        \\n        if strs.isEmpty { return \"\" }\\n        var common = strs[0]\\n        \\n        for ch in strs {\\n            while !ch.hasPrefix(common) {\\n                common = String(common.dropLast())\\n            }\\n        }\\n        return common\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    func test0() {\\n        let value = solution.longestCommonPrefix([\"flower\",\"flow\",\"flight\"])\\n        XCTAssertEqual(value, \"fl\")\\n    }\\n    func test1() {\\n        let value = solution.longestCommonPrefix([\"dog\",\"racecar\",\"car\"])\\n        XCTAssertEqual(value, \"\")\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 484683,
                "title": "python-3-beats-97-six-lines",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, S: List[str]) -> str:\\n        if not S: return \\'\\'\\n        m, M, i = min(S), max(S), 0\\n        for i in range(min(len(m),len(M))):\\n            if m[i] != M[i]: break\\n        else: i += 1\\n        return m[:i]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, S: List[str]) -> str:\\n        if not S: return \\'\\'\\n        m, M, i = min(S), max(S), 0\\n        for i in range(min(len(m),len(M))):\\n            if m[i] != M[i]: break\\n        else: i += 1\\n        return m[:i]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 6940,
                "title": "java-we-love-clear-code",
                "content": "    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null) return null;\\n        if (strs.length == 0) return \"\";\\n        \\n        Arrays.sort(strs);\\n        char[] first = strs[0].toCharArray();\\n        char[] last  = strs[strs.length - 1].toCharArray();\\n         \\n        int i = 0, len = Math.min(first.length, last.length);\\n        while (i < len && first[i] == last[i]) i++;\\n        return strs[0].substring(0, i);\\n    }",
                "solutionTags": [],
                "code": "    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null) return null;\\n        if (strs.length == 0) return \"\";\\n        \\n        Arrays.sort(strs);\\n        char[] first = strs[0].toCharArray();\\n        char[] last  = strs[strs.length - 1].toCharArray();\\n         \\n        int i = 0, len = Math.min(first.length, last.length);\\n        while (i < len && first[i] == last[i]) i++;\\n        return strs[0].substring(0, i);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1309953,
                "title": "5-lines-js-solution-beats-99-62-of-js-solutions",
                "content": "The thing is with js we can sort strings and when we sort an array of different strings they will be sorted alphabetically, which means all we left to do is find the common part between the first and the last values in the sorted array. As simple as this:\\n```\\nvar longestCommonPrefix = function(strs) {\\n  strs.sort();\\n  for (let i = 0; i < strs[0].length; i++) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]) return strs[0].substr(0, i);\\n  }\\n  return strs[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n  strs.sort();\\n  for (let i = 0; i < strs[0].length; i++) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]) return strs[0].substr(0, i);\\n  }\\n  return strs[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6926,
                "title": "accepted-c-6-lines-4ms",
                "content": "    class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            string prefix = \"\";\\n            for(int idx=0; strs.size()>0; prefix+=strs[0][idx], idx++)\\n                for(int i=0; i<strs.size(); i++)\\n                    if(idx >= strs[i].size() ||(i > 0 && strs[i][idx] != strs[i-1][idx]))\\n                        return prefix;\\n            return prefix;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            string prefix = \"\";\\n            for(int idx=0; strs.size()>0; prefix+=strs[0][idx], idx++)\\n                for(int i=0; i<strs.size(); i++)\\n                    if(idx >= strs[i].size() ||(i > 0 && strs[i][idx] != strs[i-1][idx]))\\n                        return prefix;\\n            return prefix;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 120133,
                "title": "simple-javascript-solution",
                "content": "```js\\nfunction longestCommonPrefix(strs) {\\n  if (!strs.length) return \\'\\';\\n  \\n  for (let i = 0; i < strs[0].length; i++) {\\n    for (let str of strs) {\\n      if (str[i] !== strs[0][i]) {\\n        return str.slice(0, i);\\n      }\\n    }\\n  }\\n  \\n  return strs[0];\\n}\\n```",
                "solutionTags": [],
                "code": "```js\\nfunction longestCommonPrefix(strs) {\\n  if (!strs.length) return \\'\\';\\n  \\n  for (let i = 0; i < strs[0].length; i++) {\\n    for (let str of strs) {\\n      if (str[i] !== strs[0][i]) {\\n        return str.slice(0, i);\\n      }\\n    }\\n  }\\n  \\n  return strs[0];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2765214,
                "title": "python-prefix",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2683825,
                "title": "js-two-approaches-with-explanation-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/longest-common-prefix.html\\nIt is very useful, and I just wanted to share it with you.\\n\\n\\n\\n```\\nvar longestCommonPrefix = function (strs) {\\n    // Return early on empty input\\n    if (!strs.length) return \\'\\';\\n\\n    // Loop through the letters of the first word\\n    for (let i = 0; i <= strs[0].length; i++) {\\n        // Check if this character is present in the same position of every string\\n        if (!strs.every((string) => string[i] === strs[0][i])) {\\n            // If not, return the string up to and including the previous character\\n            return strs[0].slice(0, i);\\n        }\\n    }\\n\\n    return strs[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function (strs) {\\n    // Return early on empty input\\n    if (!strs.length) return \\'\\';\\n\\n    // Loop through the letters of the first word\\n    for (let i = 0; i <= strs[0].length; i++) {\\n        // Check if this character is present in the same position of every string\\n        if (!strs.every((string) => string[i] === strs[0][i])) {\\n            // If not, return the string up to and including the previous character\\n            return strs[0].slice(0, i);\\n        }\\n    }\\n\\n    return strs[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7139,
                "title": "my-1ms-java-solution",
                "content": "I have read many solutions but I just add couple of lines. I think finding the shortest string first can make the solution more effective.\\n\\n    public class Solution {\\n        public String longestCommonPrefix(String[] strs) {\\n            if (strs.length < 1 || strs == null) {\\n                return \"\";\\n            }\\n            if (strs.length == 1) {\\n                return strs[0];\\n            }\\n            //find the shortest String\\n            int shortest = 0;\\n            int len = strs[0].length();\\n            for (int i = 1; i < strs.length; i++) {\\n                int curLen = strs[i].length();\\n                if (curLen < len) {\\n                    len = curLen;\\n                    shortest = i;\\n                }\\n            }\\n            //find the longest common prefix\\n            String sub = strs[shortest];\\n            for (int i = 0; i < strs.length; i++) {\\n                while (strs[i].indexOf(sub) != 0) {\\n                    sub = sub.substring(0, sub.length()-1);\\n                }\\n            } \\n            return sub;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String longestCommonPrefix(String[] strs) {\\n            if (strs.length < 1 || strs == null) {\\n                return \"\";\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1621297,
                "title": "python-runtime-94-46-and-memory-81-95",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n\\n        str1, str2 = min(strs), max(strs)\\n        i = 0\\n        while i < len(str1):\\n            if str1[i] != str2[i]:\\n                str1 = str1[:i]\\n            i +=1\\n\\n        return str1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n\\n        str1, str2 = min(strs), max(strs)\\n        i = 0\\n        while i < len(str1):\\n            if str1[i] != str2[i]:\\n                str1 = str1[:i]\\n            i +=1\\n\\n        return str1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339122,
                "title": "simple-c-soluton",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        string ans;\\n        for(int i=0;i<strs[0].size();i++)\\n        {\\n            for(int j=1;j<strs.size();j++)\\n            {\\n                if(strs[0][i] != strs[j][i])\\n                {\\n                    return ans;\\n                }\\n            }\\n            ans += strs[0][i];\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        string ans;\\n        for(int i=0;i<strs[0].size();i++)\\n        {\\n            for(int j=1;j<strs.size();j++)\\n            {\\n                if(strs[0][i] != strs[j][i])\\n                {\\n                    return ans;\\n                }\\n            }\\n            ans += strs[0][i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7138,
                "title": "5-line-python-with-zip-and-len-set",
                "content": "Just for fun :)\\n\\n    class Solution(object):\\n        def longestCommonPrefix(self, strs):\\n            \"\"\"\\n            :type strs: List[str]; rtype: str\\n            \"\"\"\\n            sz, ret = zip(*strs), \"\"\\n            # looping corrected based on @StefanPochmann's comment below\\n            for c in sz:\\n                if len(set(c)) > 1: break\\n                ret += c[0]\\n            return ret",
                "solutionTags": [
                    "Python"
                ],
                "code": "Just for fun :)\\n\\n    class Solution(object):\\n        def longestCommonPrefix(self, strs):\\n            \"\"\"\\n            :type strs: List[str]; rtype: str\\n            \"\"\"\\n            sz, ret = zip(*strs), \"\"\\n            # looping corrected based on @StefanPochmann's comment below\\n            for c in sz:\\n                if len(set(c)) > 1: break\\n                ret += c[0]\\n            return ret",
                "codeTag": "Java"
            },
            {
                "id": 6946,
                "title": "fast-and-simple-java-code-231ms",
                "content": "    public class Solution {\\n        public String longestCommonPrefix(List<String> strs) {\\n            if(strs.size()==0) return \"\";\\n            StringBuilder lcp=new StringBuilder();\\n            for(int i=0;i<strs.get(0).length();i++){\\n                char c=strs.get(0).charAt(i);\\n                for(String s:strs){\\n                    if(s.length()<i+1||c!=s.charAt(i)) return lcp.toString();\\n                }\\n                lcp.append(c);\\n            }\\n            return lcp.toString();\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public String longestCommonPrefix(List<String> strs) {\\n            if(strs.size()==0) return \"\";\\n            StringBuilder lcp=new StringBuilder();\\n            for(int i=0;i<strs.get(0).length();i++){\\n                char c=strs.get(0).charAt(i);\\n                for(String s:strs){\\n                    if(s.length()<i+1||c!=s.charAt(i)) return lcp.toString();\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3512602,
                "title": "c-java-python-javascript-fully-explained",
                "content": "# Intuition:\\nThe idea behind this solution is to start with the first string in the vector `strs` and consider it as the initial common prefix. Then, iterate through the remaining strings and continuously update the common prefix by removing characters from the end until the common prefix is found in the current string at the beginning. If the common prefix becomes empty at any point, it means there is no common prefix among the strings, so we return an empty string.\\n\\n# Approach:\\n1. Check if the vector `strs` is empty. If it is, there are no strings to compare, so we return an empty string.\\n2. Initialize a string variable `ans` with the first string in `strs`. This will be our initial common prefix.\\n3. Iterate through the remaining strings starting from the second string.\\n4. Inside the loop, use a while loop to check if the current string does not start with the current `ans`.\\n5. If the current string does not start with `ans`, remove the last character from `ans` by using the `substr` function and updating it to `ans.substr(0, ans.length() - 1)`.\\n6. Check if `ans` becomes empty after removing the character. If it does, it means there is no common prefix among the strings, so we return an empty string.\\n7. Repeat steps 4-6 until the current string starts with `ans`.\\n8. After the loop ends, the value of `ans` will be the longest common prefix among all the strings. Return `ans`.\\n\\n# Complexity:\\n- Time complexity: O(n), where n is the total number of characters in all the strings combined. This is because we iterate through each character of the strings to find the common prefix.\\n- Space complexity: O(1) because we are using a constant amount of space to store the common prefix (`ans`) and the loop variables.\\n\\n---\\n# C++\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.size()==0){\\n            return \"\";\\n        }\\n        string ans=strs[0];\\n        for(int i=1;i<strs.size();i++){\\n            while(strs[i].find(ans) != 0 ){\\n                cout<< ans.substr(0,ans.length() -1)<<endl;\\n                ans  = ans.substr(0,ans.length() -1);\\n                if(ans.empty()){\\n                    return \"\";\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n# JAVA\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs.length == 0) {\\n            return \"\";\\n        }\\n        String ans = strs[0];\\n        for (int i = 1; i < strs.length; i++) {\\n            while (strs[i].indexOf(ans) != 0) {\\n                ans = ans.substring(0, ans.length() - 1);\\n                if (ans.isEmpty()) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\\n\\n---\\n\\n# Python\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \\'\\'\\n        ans = strs[0]\\n        for i in range(1, len(strs)):\\n            while ans != strs[i][:len(ans)]:\\n                ans = ans[:-1]\\n                if ans == \\'\\':\\n                    return \\'\\'\\n        return ans\\n\\n```\\n\\n---\\n# JavaScript\\n```\\nvar longestCommonPrefix = function(strs) {\\n    if (strs.length === 0) {\\n        return \\'\\';\\n    }\\n    let ans = strs[0];\\n    for (let i = 1; i < strs.length; i++) {\\n        while (strs[i].indexOf(ans) !== 0) {\\n            ans = ans.substring(0, ans.length - 1);\\n            if (ans === \\'\\') {\\n                return \\'\\';\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.size()==0){\\n            return \"\";\\n        }\\n        string ans=strs[0];\\n        for(int i=1;i<strs.size();i++){\\n            while(strs[i].find(ans) != 0 ){\\n                cout<< ans.substr(0,ans.length() -1)<<endl;\\n                ans  = ans.substr(0,ans.length() -1);\\n                if(ans.empty()){\\n                    return \"\";\\n                }\\n            }   \\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs.length == 0) {\\n            return \"\";\\n        }\\n        String ans = strs[0];\\n        for (int i = 1; i < strs.length; i++) {\\n            while (strs[i].indexOf(ans) != 0) {\\n                ans = ans.substring(0, ans.length() - 1);\\n                if (ans.isEmpty()) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n\\n```\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \\'\\'\\n        ans = strs[0]\\n        for i in range(1, len(strs)):\\n            while ans != strs[i][:len(ans)]:\\n                ans = ans[:-1]\\n                if ans == \\'\\':\\n                    return \\'\\'\\n        return ans\\n\\n```\n```\\nvar longestCommonPrefix = function(strs) {\\n    if (strs.length === 0) {\\n        return \\'\\';\\n    }\\n    let ans = strs[0];\\n    for (let i = 1; i < strs.length; i++) {\\n        while (strs[i].indexOf(ans) !== 0) {\\n            ans = ans.substring(0, ans.length - 1);\\n            if (ans === \\'\\') {\\n                return \\'\\';\\n            }\\n        }\\n    }\\n    return ans;\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1869031,
                "title": "c-0ms",
                "content": "\\tchar *longestCommonPrefix(char **strs, int strsSize)\\n\\t{\\n\\t\\tfor(int c=0;; ++c)\\n\\t\\t{\\n\\t\\t\\tif(strs[0][c] == \\'\\\\0\\') // the longest common prefix is the first string\\n\\t\\t\\t\\treturn strs[0];\\n\\t\\t\\tfor(int s=1; s<strsSize; ++s)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(strs[s][c] != strs[0][c]) // compare all strings character to the first one\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstrs[0][c] = \\'\\\\0\\'; // replace the current character with \\'\\\\0\\'\\n\\t\\t\\t\\t\\treturn strs[0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tchar *longestCommonPrefix(char **strs, int strsSize)\\n\\t{\\n\\t\\tfor(int c=0;; ++c)\\n\\t\\t{\\n\\t\\t\\tif(strs[0][c] == \\'\\\\0\\') // the longest common prefix is the first string\\n\\t\\t\\t\\treturn strs[0];\\n\\t\\t\\tfor(int s=1; s<strsSize; ++s)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(strs[s][c] != strs[0][c]) // compare all strings character to the first one\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tstrs[0][c] = \\'\\\\0\\'; // replace the current character with \\'\\\\0\\'\\n\\t\\t\\t\\t\\treturn strs[0];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 221978,
                "title": "javascript",
                "content": "```\\nvar longestCommonPrefix = function(strs) {\\n  if (strs.length === 0) return \\'\\';\\n  let r = \\'\\';\\n  for (let i = 0; i < strs[0].length; i++) {\\n    for (let j = 1; j < strs.length; j++) {\\n      if (strs[0][i] !== strs[j][i]) return r;\\n    }\\n    r += strs[0][i];\\n  }\\n  return r;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n  if (strs.length === 0) return \\'\\';\\n  let r = \\'\\';\\n  for (let i = 0; i < strs[0].length; i++) {\\n    for (let j = 1; j < strs.length; j++) {\\n      if (strs[0][i] !== strs[j][i]) return r;\\n    }\\n    r += strs[0][i];\\n  }\\n  return r;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2869179,
                "title": "python-99-faster-easy-solution",
                "content": "# Code\\u2705\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str: #// strs = [\"flower\",\"flow\",\"flight\"]\\n        short = min(strs, key=len) #// short = \"flow\"\\n        for item in strs: #// When item = \"flight\"\\n            while len(short) > 0:\\n                if item.startswith(short): #// during loop 1 condition fails, during loop 2 condition fails, during loop 3 \"flight\" startswith fl is True\\n                    break\\n                else:\\n                    short = short[:-1] #// during loop 1 short = flo, during loop 2 short = fl\\n        return short\\n```\\n![leet.png](https://assets.leetcode.com/users/images/957926b9-2e91-4aca-bda2-0c413ba34ea2_1669969069.6613681.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str: #// strs = [\"flower\",\"flow\",\"flight\"]\\n        short = min(strs, key=len) #// short = \"flow\"\\n        for item in strs: #// When item = \"flight\"\\n            while len(short) > 0:\\n                if item.startswith(short): #// during loop 1 condition fails, during loop 2 condition fails, during loop 3 \"flight\" startswith fl is True\\n                    break\\n                else:\\n                    short = short[:-1] #// during loop 1 short = flo, during loop 2 short = fl\\n        return short\\n```",
                "codeTag": "Java"
            },
            {
                "id": 763488,
                "title": "rust-0ms-solution",
                "content": "Runtime: 0 ms, faster than 100.00% of Rust online submissions for Longest Common Prefix.\\nMemory Usage: 2.2 MB, less than 60.00% of Rust online submissions for Longest Common Prefix.\\n```\\nimpl Solution {\\n    pub fn longest_common_prefix(strs: Vec<String>) -> String { \\n        match strs.is_empty() {\\n            true => \"\".to_string(),\\n            _ => {\\n                strs.iter().skip(1).fold(strs[0].clone(), |acc, x| {\\n                     acc\\n                        .chars()\\n                        .zip(x.chars())\\n                        .take_while(|(x,y)| x == y)\\n                        .map(|(x, _)| x)\\n                        .collect()\\n                })\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_common_prefix(strs: Vec<String>) -> String { \\n        match strs.is_empty() {\\n            true => \"\".to_string(),\\n            _ => {\\n                strs.iter().skip(1).fold(strs[0].clone(), |acc, x| {\\n                     acc\\n                        .chars()\\n                        .zip(x.chars())\\n                        .take_while(|(x,y)| x == y)\\n                        .map(|(x, _)| x)\\n                        .collect()\\n                })\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 801411,
                "title": "javascript-clean-solution",
                "content": "```javascript\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs.length) return \\'\\';\\n    \\n    for(let i = 0; i < strs[0].length; i++) {\\n        for(let s of strs) {\\n            if(s[i] !== strs[0][i]) return s.slice(0, i);\\n        }\\n    }\\n    return strs[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs.length) return \\'\\';\\n    \\n    for(let i = 0; i < strs[0].length; i++) {\\n        for(let s of strs) {\\n            if(s[i] !== strs[0][i]) return s.slice(0, i);\\n        }\\n    }\\n    return strs[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 798212,
                "title": "fastest-python-solution-longest-common-prefix",
                "content": "\\n```\\nstr=[\"flower\",\"flow\",\"flight\"]\\n\\nafter zip(*strs)\\n\\n[(\\'f\\', \\'f\\', \\'f\\'), (\\'l\\', \\'l\\', \\'l\\'), (\\'o\\', \\'o\\', \\'i\\'), (\\'w\\', \\'w\\', \\'g\\')]\\n\\ntaken first set\\n\\nlen(set( \"f\",\"f\",\"f\"))=1\\n\\nand taken 3\\nlen(set(\"o\",\"o\",\"i\"))=2\\n\\n```\\n\\n```\\n\\nprefix=[]\\n        num = len(strs)\\n        for x in zip(*strs):\\n            if len(set(x)) == 1:\\n                prefix.append(x[0])\\n            else:\\n                break\\n        return \"\".join(prefix) \\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Ordered Set"
                ],
                "code": "```\\nstr=[\"flower\",\"flow\",\"flight\"]\\n\\nafter zip(*strs)\\n\\n[(\\'f\\', \\'f\\', \\'f\\'), (\\'l\\', \\'l\\', \\'l\\'), (\\'o\\', \\'o\\', \\'i\\'), (\\'w\\', \\'w\\', \\'g\\')]\\n\\ntaken first set\\n\\nlen(set( \"f\",\"f\",\"f\"))=1\\n\\nand taken 3\\nlen(set(\"o\",\"o\",\"i\"))=2\\n\\n```\n```\\n\\nprefix=[]\\n        num = len(strs)\\n        for x in zip(*strs):\\n            if len(set(x)) == 1:\\n                prefix.append(x[0])\\n            else:\\n                break\\n        return \"\".join(prefix) \\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 323909,
                "title": "python-simple-solution-implementing-vertical-scanning",
                "content": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        result = []\\n\\t\\t# Create one iterator per string using zip, it will stop at the shortest string\\n\\t\\t# s is a tuple of characters at current position for each string\\n\\t\\t# create a set to test unicity\\n        for s in zip(*strs):\\n            if len(set(s)) != 1:\\n                break\\n            result.append(s[0])\\n        return \"\".join(result)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        result = []\\n\\t\\t# Create one iterator per string using zip, it will stop at the shortest string\\n\\t\\t# s is a tuple of characters at current position for each string\\n\\t\\t# create a set to test unicity\\n        for s in zip(*strs):\\n            if len(set(s)) != 1:\\n                break\\n            result.append(s[0])\\n        return \"\".join(result)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3244957,
                "title": "idiomatic-and-elegant-rust-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn longest_common_prefix(input: Vec<String>) -> String {\\n        input.into_iter().reduce(|acc,cur|{\\n            acc.chars()\\n               .zip(cur.chars())\\n               .take_while(|(a,c)| a== c)\\n               .map(|(c,_)|c)\\n               .collect()\\n        }).unwrap()\\n    }\\n}\\n```\\n\\n# Intuition\\nThe longest common prefix (LCP) between `input[i+1]` and `input[i+2]` will always be as short or shorter than between `input[i]` and `input[i+1]`.\\nThis means this problem (taking as example input `[\"flight\",\"flow\",\"flip\"]`) can be solved like: `LCP(\"flat\",LCP(\"flip\",LCP(\"flow\", \"flight\")))`. \\nThe recursive call of an operation on the previous result of that operation is a classic example of [Iterator::reduce](https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.reduce)\\n\\n# Approach\\n1. Apply reduce on the input\\n2. `acc` starts out as the first string in input.\\n3. `cur` starts out as the second string, and will become each string as we iterate through the input\\n4. zip `acc` and `cur`. This will create an iterator over tuples representing pairs of `acc[i]`, `cur[i]`. It will clip the longest one to the size of the shortest.\\n5. take as many chars as possible while they are equal in each zipped string\\n6. forget about one element of the tuple, in order to have an iterator over `char`\\n7. `collect` it into a `String` and return it from the closure. This will be `acc` argument in the next iteration\\n8. after the iteration, the final `acc` value will be returned. `unwrap` is necessary because `reduce` returns an `Option`\\n# Complexity\\n- Time complexity:\\n**O(n*s)**, where s is the shortest LCP so far.\\n- Space complexity:\\n**O(1)**\\n",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn longest_common_prefix(input: Vec<String>) -> String {\\n        input.into_iter().reduce(|acc,cur|{\\n            acc.chars()\\n               .zip(cur.chars())\\n               .take_while(|(a,c)| a== c)\\n               .map(|(c,_)|c)\\n               .collect()\\n        }).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1517792,
                "title": "simple-go-solution",
                "content": "```\\nfunc longestCommonPrefix(strs []string) string {\\n    p := strs[0]\\n    for _, s := range strs {\\n        i := 0\\n        for ; i < len(s) && i < len(p) && p[i] == s[i]; i++ {}\\n        p = p[:i]\\n    }\\n    return p\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestCommonPrefix(strs []string) string {\\n    p := strs[0]\\n    for _, s := range strs {\\n        i := 0\\n        for ; i < len(s) && i < len(p) && p[i] == s[i]; i++ {}\\n        p = p[:i]\\n    }\\n    return p\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3160852,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n\\n\\n# Approach\\nSimple solution using startsWith JavaScript method\\n\\n# Complexity\\n- Time complexity: 60ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: 41.8MB\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(arr) {\\n    let i = 1;\\n    let prf = arr[0];\\n    while(i < arr.length){\\n        if(!arr[i].startsWith(prf)){\\n            prf = prf.slice(0, -1)\\n        }else{\\n            i++\\n        }\\n    }\\n    return prf\\n\\n\\n};\\n\\n// \"\"\\n//\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(arr) {\\n    let i = 1;\\n    let prf = arr[0];\\n    while(i < arr.length){\\n        if(!arr[i].startsWith(prf)){\\n            prf = prf.slice(0, -1)\\n        }else{\\n            i++\\n        }\\n    }\\n    return prf\\n\\n\\n};\\n\\n// \"\"\\n//\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1422342,
                "title": "python-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef longestCommonPrefix(self, lst: List[str]) -> str:\\n\\t\\t\\tans = \"\"\\n\\t\\t\\tfor i in zip(*lst):\\n\\t\\t\\t\\tp = \"\".join(i)\\n\\t\\t\\t\\tif len(set(p)) != 1:\\n\\t\\t\\t\\t\\treturn (ans)\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans += p[0]\\n\\n\\t\\t\\treturn (ans)\\n\\t\\t\\t\\n# if you like the solution, Please upvote!!\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef longestCommonPrefix(self, lst: List[str]) -> str:\\n\\t\\t\\tans = \"\"\\n\\t\\t\\tfor i in zip(*lst):\\n\\t\\t\\t\\tp = \"\".join(i)\\n\\t\\t\\t\\tif len(set(p)) != 1:\\n\\t\\t\\t\\t\\treturn (ans)\\n\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tans += p[0]\\n\\n\\t\\t\\treturn (ans)\\n\\t\\t\\t\\n# if you like the solution, Please upvote!!\\n",
                "codeTag": "Java"
            },
            {
                "id": 1336046,
                "title": "python-horizontal-scanning",
                "content": "I got this question in an interview recently. I solved it using the most voted Python approach. [Link](https://leetcode.com/problems/longest-common-prefix/discuss/6918/Short-Python-Solution)\\nHowever, the interviewer told me that this solution isn\\'t the most optimized because it checks each character once if the two words aren\\'t the same. I told him I can whip a Trie solution, and he said that is an overkill. Finally, I came up with this solution which is scanning it horizontally. Hope it can help someone else out there. \\n\\n```\\nclass Solution: \\n\\tdef longestCommonPrefix(self, words: List[str]) -> str: \\n\\t\\tprefix = words[0]\\n\\t\\tfor word in words[1:]: \\n\\t\\t\\t# keep looping and current word sliced to len of prefix == prefix\\n\\t\\t\\twhile word[:len(prefix)] != prefix: \\n\\t\\t\\t\\tprefix = prefix[:-1]\\n\\t\\t\\t\\t# Covers edge case: if two words don\\'t have any similar characters\\n\\t\\t\\t\\tif not prefix: \\n\\t\\t\\t\\t\\treturn \"\"\\n\\t\\treturn prefix",
                "solutionTags": [
                    "Python"
                ],
                "code": "I got this question in an interview recently. I solved it using the most voted Python approach. [Link](https://leetcode.com/problems/longest-common-prefix/discuss/6918/Short-Python-Solution)\\nHowever, the interviewer told me that this solution isn\\'t the most optimized because it checks each character once if the two words aren\\'t the same. I told him I can whip a Trie solution, and he said that is an overkill. Finally, I came up with this solution which is scanning it horizontally. Hope it can help someone else out there. \\n\\n```\\nclass Solution: \\n\\tdef longestCommonPrefix(self, words: List[str]) -> str: \\n\\t\\tprefix = words[0]\\n\\t\\tfor word in words[1:]: \\n\\t\\t\\t# keep looping and current word sliced to len of prefix == prefix\\n\\t\\t\\twhile word[:len(prefix)] != prefix: \\n\\t\\t\\t\\tprefix = prefix[:-1]\\n\\t\\t\\t\\t# Covers edge case: if two words don\\'t have any similar characters\\n\\t\\t\\t\\tif not prefix: \\n\\t\\t\\t\\t\\treturn \"\"\\n\\t\\treturn prefix",
                "codeTag": "Java"
            },
            {
                "id": 3168831,
                "title": "python-80-simple-find-max-and-min-words",
                "content": "# Approach\\nImagine that all the words are ordered. Similar words will be next to each other (because of the lexicographic order). Then we need to compare the prefixes of the first and last word. So we need the maximum and minimum word.\\n\\nSee comments in the code.\\n\\n\\uD83D\\uDC49 [Explanation with an example in the comments](https://leetcode.com/problems/longest-common-prefix/solutions/3168831/python-80-simple-find-max-and-min-words/comments/1804509)\\n\\n**\\u2764\\uFE0F Please upvote if you liked this approach**\\n\\n# Complexity\\n- Time complexity: $$O(max(n, min(len(minWord), len(maxWord))))$$\\n\\nFinding max and min word: $$O(n)$$\\nLoop with i < N: $$O(min(len(minWord), len(maxWord)))$$\\nThus, we have to take the max from them.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        # this will be an answer\\n        pref = \\'\\'        \\n        # find min and max words among strs\\n        minWord = min(strs)\\n        maxWord = max(strs)\\n\\n        # for iteration\\n        i = 0\\n        N = min(len(minWord), len(maxWord))\\n        \\n        while i < N:\\n            # if chars are equal\\n            if minWord[i] == maxWord[i]:\\n                # add this char to the answer\\n                pref += minWord[i]\\n            else:\\n                # if not, break\\n                break\\n            i += 1\\n\\n        return pref\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        # this will be an answer\\n        pref = \\'\\'        \\n        # find min and max words among strs\\n        minWord = min(strs)\\n        maxWord = max(strs)\\n\\n        # for iteration\\n        i = 0\\n        N = min(len(minWord), len(maxWord))\\n        \\n        while i < N:\\n            # if chars are equal\\n            if minWord[i] == maxWord[i]:\\n                # add this char to the answer\\n                pref += minWord[i]\\n            else:\\n                # if not, break\\n                break\\n            i += 1\\n\\n        return pref\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 204779,
                "title": "python-trie-clean-implementation",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def add_word(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.end = True\\n    \\n    def longest_prefix(self):\\n        res = []\\n        cur = self.root\\n        while cur:\\n            # return when reaches the end of word or when there are more than 1 branches\\n            if cur.end or len(cur.children) > 1:\\n                return \\'\\'.join(res)\\n            c = list(cur.children)[0]\\n            res.append(c)\\n            cur = cur.children[c]\\n        return \\'\\'.join(res)\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        if not strs:\\n            return \\'\\'\\n        T = Trie()\\n        for s in strs:\\n            T.add_word(s)\\n        return T.longest_prefix()\\n```\\n\\nTime complexity:\\n- building Trie: O(N\\\\*len(s)) where N = len(strs) and s is the longest word in strs\\n- finding longest prefix: O(M) where M is the length of LCP (which is in the range of 0 and the length of shortest string)",
                "solutionTags": [],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.end = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def add_word(self, word):\\n        cur = self.root\\n        for c in word:\\n            if c not in cur.children:\\n                cur.children[c] = TrieNode()\\n            cur = cur.children[c]\\n        cur.end = True\\n    \\n    def longest_prefix(self):\\n        res = []\\n        cur = self.root\\n        while cur:\\n            # return when reaches the end of word or when there are more than 1 branches\\n            if cur.end or len(cur.children) > 1:\\n                return \\'\\'.join(res)\\n            c = list(cur.children)[0]\\n            res.append(c)\\n            cur = cur.children[c]\\n        return \\'\\'.join(res)\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        if not strs:\\n            return \\'\\'\\n        T = Trie()\\n        for s in strs:\\n            T.add_word(s)\\n        return T.longest_prefix()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3087422,
                "title": "python-brilliant-approach-taught-by-my-bf-xd",
                "content": "# Intuition\\n**EDIT** - Earlier I used sorting, which took O(M * NLOGN) complexity.Instead we can use min() and max() , which takes O(N*M) time.complexity. (N is no.of elements in the array and M is size of the string)\\n\\nIf you sort the given array (lexicographically), the **first** and **last** word will be the least similar (i.e, they vary the most)\\n- It is enough if you find the common prefix between the **first** and **last** word ( need not consider other words in the array )\\n\\n**Example:** arr = [\"aad\",\"aaf\", \"aaaa\", \"af\"]\\n1) Sorted arr is [\"aaaa\", \"aad\", \"aaf\", \"af\"]\\n2) *first* = \"aaaa\", *last* = \"af\"\\n3) Common prefix of *first* and *last* is ans = \"a\"\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) **Sort** the given array\\n2) Take the **first** and **last** word of the array\\n3) Find the common **prefix** of the first and last word\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N*M) - since use min() and max() in python, where N is no.of elements in the array and M is size of the string\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) -  no extra space is used\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        first, last = min(strs), max(strs)\\n        prefix = \\'\\'\\n        for ind in range(min(len(first), len(last))):\\n            if first[ind] != last[ind]:\\n                break\\n            prefix += first[ind]\\n\\n        return prefix\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        first, last = min(strs), max(strs)\\n        prefix = \\'\\'\\n        for ind in range(min(len(first), len(last))):\\n            if first[ind] != last[ind]:\\n                break\\n            prefix += first[ind]\\n\\n        return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2981733,
                "title": "concise-and-easy-solutions-with-trivial-linq",
                "content": "1. Get the shortest word\\n2. Make sure that each of its characters can be found in every other word in the same place.\\n  a. If not, return what you have checked so far.\\n  b. If yes, go on.\\n\\nShort solution:\\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        for (int i = 0; i < shortest.Length; i++)\\n        {\\n            if (ss.Select(s => s[i]).Distinct().Count() > 1) return shortest[..i];\\n        }\\n\\n        return shortest;\\n    }\\n}\\n```\\n\\nAnother one, with `StringBuilder`:\\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        int i = 0;\\n        StringBuilder sb = new();\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        foreach (char c in shortest)\\n        {\\n            if (ss.Any(s => s[i] != c)) break;\\n            sb.Append(c);\\n            i++;\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```\\n\\nWe can get rid of the explicit declaration of `i` by using LINQ/tuples:\\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        StringBuilder sb = new();\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        foreach (var (c, i) in shortest.Select((c, i) => (c, i)))\\n        {\\n            if (ss.Any(s => s[i] != c)) break;\\n            sb.Append(c);\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        for (int i = 0; i < shortest.Length; i++)\\n        {\\n            if (ss.Select(s => s[i]).Distinct().Count() > 1) return shortest[..i];\\n        }\\n\\n        return shortest;\\n    }\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        int i = 0;\\n        StringBuilder sb = new();\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        foreach (char c in shortest)\\n        {\\n            if (ss.Any(s => s[i] != c)) break;\\n            sb.Append(c);\\n            i++;\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public string LongestCommonPrefix(string[] ss)\\n    {\\n        StringBuilder sb = new();\\n        string shortest = ss.OrderBy(s => s.Length).First();\\n\\n        foreach (var (c, i) in shortest.Select((c, i) => (c, i)))\\n        {\\n            if (ss.Any(s => s[i] != c)) break;\\n            sb.Append(c);\\n        }\\n\\n        return sb.ToString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292303,
                "title": "c-straightforward",
                "content": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs) {\\n        if (strs.Length == 0 || Array.IndexOf(strs, \"\") != -1)\\n            return \"\";\\n        string res = strs[0];\\n        int i = res.Length;\\n        foreach (string word in strs) {\\n            int j = 0;\\n            foreach (char c in word) {\\n                if (j >= i || res[j] != c)\\n                    break;\\n                j += 1;\\n            }\\n            i = Math.Min(i, j);\\n        }\\n        return res.Substring(0, i);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs) {\\n        if (strs.Length == 0 || Array.IndexOf(strs, \"\") != -1)\\n            return \"\";\\n        string res = strs[0];\\n        int i = res.Length;\\n        foreach (string word in strs) {\\n            int j = 0;\\n            foreach (char c in word) {\\n                if (j >= i || res[j] != c)\\n                    break;\\n                j += 1;\\n            }\\n            i = Math.Min(i, j);\\n        }\\n        return res.Substring(0, i);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291991,
                "title": "using-simple-str-sort-method-5-line-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nfind the min length str and or write in the sorting \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst we use str.sort method becuse its sorting by alphabetical order\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nsort method Time Colplexity \\nO(nlog(n))\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1);\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    // sort the array because its rearrange alphabetical order\\n   strs.sort();\\n\\n\\n  for (let i = 0; i < strs[0].length; i++) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]){\\nreturn strs[0].substr(0, i);\\n    } \\n  }\\n\\n  return strs[0];  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    // sort the array because its rearrange alphabetical order\\n   strs.sort();\\n\\n\\n  for (let i = 0; i < strs[0].length; i++) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]){\\nreturn strs[0].substr(0, i);\\n    } \\n  }\\n\\n  return strs[0];  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2516139,
                "title": "simple-python-solution-with-zip-and-set",
                "content": "`zip(*strs)` Iterate over all words in parallel, producing tuples with an letter from each one.  It will stop iteration on the shortest word. \\n\\n```\\n>>> list(zip(*[\"flower\",\"flow\",\"flight\"]))\\n[\\n(\\'f\\', \\'f\\', \\'f\\'),\\n(\\'l\\', \\'l\\', \\'l\\'),\\n(\\'o\\', \\'o\\', \\'i\\'), \\n(\\'w\\', \\'w\\', \\'g\\')\\n]\\n```\\n\\n\\n```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        match = 0\\n        \\n        for vals in zip(*strs):\\n            if len(set(vals)) == 1:\\n                match += 1\\n            else:\\n                break\\n        \\n        return strs[0][:match]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n>>> list(zip(*[\"flower\",\"flow\",\"flight\"]))\\n[\\n(\\'f\\', \\'f\\', \\'f\\'),\\n(\\'l\\', \\'l\\', \\'l\\'),\\n(\\'o\\', \\'o\\', \\'i\\'), \\n(\\'w\\', \\'w\\', \\'g\\')\\n]\\n```\n```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        match = 0\\n        \\n        for vals in zip(*strs):\\n            if len(set(vals)) == 1:\\n                match += 1\\n            else:\\n                break\\n        \\n        return strs[0][:match]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 587345,
                "title": "c-easy-solution-4ms",
                "content": "```\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans=\"\";\\n        int n=strs.size();\\n        if(n==0)\\n            return ans;\\n        int l=strs[0].length();\\n        for(string s:strs)\\n            if(l>s.length())\\n                l=s.length();\\n        int index=0;\\n        for(char c:strs[0])\\n        {\\n            for(int i=1;i<n;i++)\\n            {\\n                if(strs[i][index]!=c||index>l)\\n                    return ans;\\n            }\\n            ans+=c;\\n            index++;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans=\"\";\\n        int n=strs.size();\\n        if(n==0)\\n            return ans;\\n        int l=strs[0].length();\\n        for(string s:strs)\\n            if(l>s.length())\\n                l=s.length();\\n        int index=0;\\n        for(char c:strs[0])\\n        {\\n            for(int i=1;i<n;i++)\\n            {\\n                if(strs[i][index]!=c||index>l)\\n                    return ans;\\n            }\\n            ans+=c;\\n            index++;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 561757,
                "title": "c-memory-and-runtime-efficient-2-solutions-1-greedy-1-trie-implementation",
                "content": "**Greedy**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.size() == 0) return \"\";\\n        if(strs.size() == 1) return strs[0];\\n        \\n        int small = INT_MAX;\\n        bool flag = true;\\n        string retStr;\\n        \\n        for(auto str : strs) if(str.length() < small) small = str.length();\\n        \\n        while(small != 0){\\n            flag = true;\\n            for(int i = 0; i < strs.size() - 1; i++){\\n                if(strs[i].substr(0, small) != strs[i + 1].substr(0, small)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                return strs[0].substr(0, small);\\n            }\\n            small--;\\n        }\\n        \\n        return retStr; \\n    }\\n};\\n```\\n\\n**Trie Implementation**\\n```\\nclass TrieNode{\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    char val;\\n    bool isWord = false;\\n    \\n    TrieNode(){}\\n    \\n    TrieNode(char v){\\n        this->val = v;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    TrieNode* root;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    /* Get TrieNode. */\\n    TrieNode* getTrieNode(){\\n        return root;\\n    }\\n    \\n    /** Inserts a word into the trie. */\\n    void insert(string word) {\\n        TrieNode* temp = root;\\n        \\n        for(auto ch : word){\\n            if(temp->children.find(ch) == temp->children.end()){\\n                temp->children[ch] = new TrieNode(ch);\\n            }     \\n            temp = temp->children[ch];\\n        }\\n        \\n        temp->isWord = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        // insert all keys into trie\\n        Trie* pTrie = new Trie();\\n        \\n        for (string str : strs) { pTrie->insert(str); }\\n\\n        // Traverse the trie and find Longest Common Prefix\\n        string lcp(\"\");\\n        TrieNode* curr = pTrie->getTrieNode();\\n\\n        // Do till we find a leaf node or node has more than 1 children\\n        while (curr && !curr->isWord && (curr->children.size() == 1))\\n        {\\n            auto it = curr->children.begin();\\n            lcp += it->first;\\n            curr = it->second;\\n        }\\n\\n        return lcp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Trie"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.size() == 0) return \"\";\\n        if(strs.size() == 1) return strs[0];\\n        \\n        int small = INT_MAX;\\n        bool flag = true;\\n        string retStr;\\n        \\n        for(auto str : strs) if(str.length() < small) small = str.length();\\n        \\n        while(small != 0){\\n            flag = true;\\n            for(int i = 0; i < strs.size() - 1; i++){\\n                if(strs[i].substr(0, small) != strs[i + 1].substr(0, small)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n            if(flag){\\n                return strs[0].substr(0, small);\\n            }\\n            small--;\\n        }\\n        \\n        return retStr; \\n    }\\n};\\n```\n```\\nclass TrieNode{\\npublic:\\n    unordered_map<char, TrieNode*> children;\\n    char val;\\n    bool isWord = false;\\n    \\n    TrieNode(){}\\n    \\n    TrieNode(char v){\\n        this->val = v;\\n    }\\n};\\n\\nclass Trie {\\nprivate:\\n    TrieNode* root;\\n    \\npublic:\\n    /** Initialize your data structure here. */\\n    Trie() {\\n        root = new TrieNode();\\n    }\\n    \\n    /* Get TrieNode. */\\n    TrieNode* getTrieNode(){\\n        return root;\\n    }\\n    \\n    /** Inserts a word into the trie. */\\n    void insert(string word) {\\n        TrieNode* temp = root;\\n        \\n        for(auto ch : word){\\n            if(temp->children.find(ch) == temp->children.end()){\\n                temp->children[ch] = new TrieNode(ch);\\n            }     \\n            temp = temp->children[ch];\\n        }\\n        \\n        temp->isWord = true;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        // insert all keys into trie\\n        Trie* pTrie = new Trie();\\n        \\n        for (string str : strs) { pTrie->insert(str); }\\n\\n        // Traverse the trie and find Longest Common Prefix\\n        string lcp(\"\");\\n        TrieNode* curr = pTrie->getTrieNode();\\n\\n        // Do till we find a leaf node or node has more than 1 children\\n        while (curr && !curr->isWord && (curr->children.size() == 1))\\n        {\\n            auto it = curr->children.begin();\\n            lcp += it->first;\\n            curr = it->second;\\n        }\\n\\n        return lcp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 397075,
                "title": "java-o-n-log-n",
                "content": "// 1) sort the array. this way if you have [\"hall\", \"hallow\", \"hat\"]\\n// it would sort it so that hat is first and hallow is last\\n// 2) Compare only first and last element. Because the longest posssible prefix will\\n// be at the end and the shorest possible prefix will be in the begining\\n// 3) convert first and last element to char array\\n// 4) loop through first elemnt comparing each value to last element value\\n// 5)Make sure that when looping you do not go-out-of-bounds for the last element\\n// 6) if it is equal then append it to a string builder\\n// if it is not equal immediately return the result\\n\\n```\\nimport  java.util.*;\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n        // 1) string builder\\n        StringBuilder result = new StringBuilder();\\n        \\n        // Sort array\\n        Arrays.sort(strs);\\n        \\n        // split first and last to char\\n        char[] first = strs[0].toCharArray();\\n        char[] last = strs[strs.length - 1 ].toCharArray();\\n        \\n        // loop through\\n        for (int i = 0; i < first.length && i < last.length; i++) {\\n            if (first[i] == last[i]) {\\n                result.append(first[i]);                \\n            }\\n            else\\n                return result.toString();\\n        }\\n        return result.toString();\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport  java.util.*;\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n        // 1) string builder\\n        StringBuilder result = new StringBuilder();\\n        \\n        // Sort array\\n        Arrays.sort(strs);\\n        \\n        // split first and last to char\\n        char[] first = strs[0].toCharArray();\\n        char[] last = strs[strs.length - 1 ].toCharArray();\\n        \\n        // loop through\\n        for (int i = 0; i < first.length && i < last.length; i++) {\\n            if (first[i] == last[i]) {\\n                result.append(first[i]);                \\n            }\\n            else\\n                return result.toString();\\n        }\\n        return result.toString();\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 833959,
                "title": "javascript-solution-14",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nlet longestCommonPrefix = function(strs) {\\n        if(!strs.length) {\\n            return \\'\\';\\n        }\\n        for(let i = 0; i < strs[0].length; i++) {\\n            for(let s of strs) {\\n                if(s[i] !== strs[0][i]) {\\n                    return s.slice(0, i);\\n                }\\n            }\\n        }\\n        return strs[0];\\n    };\\n```\\n**Runtime: 80 ms, faster than 75.49% of JavaScript online submissions for Longest Common Prefix.**\\n\\n**Memory Usage: 39.2 MB, less than 10.70% of JavaScript online submissions for Longest Common Prefix.**\\n\\n**Feedback Appreciated**",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nlet longestCommonPrefix = function(strs) {\\n        if(!strs.length) {\\n            return \\'\\';\\n        }\\n        for(let i = 0; i < strs[0].length; i++) {\\n            for(let s of strs) {\\n                if(s[i] !== strs[0][i]) {\\n                    return s.slice(0, i);\\n                }\\n            }\\n        }\\n        return strs[0];\\n    };\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3405496,
                "title": "python-code-explained-with-approach-and-time-complexity",
                "content": "Intuition:\\nThe problem requires finding the longest common prefix among a list of strings. The approach is to assume that the prefix is the shortest string in the list and then compare it with all the other strings. The length of the prefix is then reduced by one character at a time until a match is found or the prefix becomes empty.\\n\\nApproach:\\n\\nIf the input list is empty, return an empty string.\\nAssume that the prefix is the shortest string in the list.\\nIterate over all the other strings in the list and compare them with the prefix.\\nIf a match is found, continue to the next string in the list.\\nIf a match is not found, reduce the length of the prefix by one character at a time until a match is found or the prefix becomes empty.\\nIf the prefix becomes empty, return an empty string.\\nIf all strings match the prefix, return the prefix.\\n\\nTime complexity:\\nThe time complexity of the given implementation is O(nm), where n is the number of strings in the input list and m is the length of the shortest string. This is because the algorithm iterates over all the strings in the list once, and for each string, it may reduce the length of the prefix by up to m characters. The min() function used to find the shortest string in the list has a time complexity of O(nm), where n is the number of strings in the list and m is the length of the longest string.\\n\\nSpace complexity:\\nThe space complexity of the given implementation is O(1), as it uses only constant extra space to store the prefix variable and the loop variables.\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        prefix = min(strs, key=len)\\n        for s in strs:\\n            while not s.startswith(prefix):\\n                prefix = prefix[:-1]\\n                \\n        return prefix\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        prefix = min(strs, key=len)\\n        for s in strs:\\n            while not s.startswith(prefix):\\n                prefix = prefix[:-1]\\n                \\n        return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1923947,
                "title": "typescript-solution",
                "content": "```typescript\\nfunction longestCommonPrefix(strs: string[]): string {\\n  let prefix = strs[0];\\n\\n  for (let i = 1; i < strs.length; i++) {\\n    while (!strs[i].startsWith(prefix)) {\\n      prefix = prefix.slice(0, -1);\\n    }\\n\\n    if (prefix === \\'\\') {\\n      return prefix;\\n    }\\n  }\\n  \\n  return prefix;\\n};\\n```\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```typescript\\nfunction longestCommonPrefix(strs: string[]): string {\\n  let prefix = strs[0];\\n\\n  for (let i = 1; i < strs.length; i++) {\\n    while (!strs[i].startsWith(prefix)) {\\n      prefix = prefix.slice(0, -1);\\n    }\\n\\n    if (prefix === \\'\\') {\\n      return prefix;\\n    }\\n  }\\n  \\n  return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1214400,
                "title": "kotlin",
                "content": "```\\nfun longestCommonPrefix(ar: Array<String>) = StringBuilder().apply {\\n    ar.minBy { it.length }?.forEachIndexed { i, c -> if (ar.all { it[i] == c }) append(c) else return toString() }\\n}.toString()\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nfun longestCommonPrefix(ar: Array<String>) = StringBuilder().apply {\\n    ar.minBy { it.length }?.forEachIndexed { i, c -> if (ar.all { it[i] == c }) append(c) else return toString() }\\n}.toString()\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2188782,
                "title": "keep-it-simple-and-go",
                "content": "```\\nfunc longestCommonPrefix(strs []string) string {\\n    for i := 0 ;; i++  {\\n        for _, str := range strs {\\n            if i == len(str) || str[i] != strs[0][i] {\\n                return strs[0][:i]\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestCommonPrefix(strs []string) string {\\n    for i := 0 ;; i++  {\\n        for _, str := range strs {\\n            if i == len(str) || str[i] != strs[0][i] {\\n                return strs[0][:i]\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7282,
                "title": "here-is-my-solution-in-c-0-ms",
                "content": "    #include<stdio.h>\\n    #include<string.h>\\n    char* longestCommonPrefix(char** strs, int strsSize) \\n    {\\n        int i=0; int j=0;int index;int tempindex=0;\\n        if(strsSize<1)\\n        return \"\";\\n        index=strlen(strs[0]);\\n        char *a;\\n        a= malloc(sizeof(char)*(index+1));\\n        strcpy(a,strs[0]);\\n        for(i=1;i<strsSize;i++)\\n        {   tempindex=0;\\n            for(j=0;j<index;j++)\\n            { \\n                if(a[j]==strs[i][j])\\n                tempindex++;\\n                else\\n                {a[j]='\\\\0';\\n                 break;\\n                }\\n            } \\n              if (tempindex==0)return (\"\");\\n              if(tempindex<index)index=tempindex;\\n            \\n        }\\n        return a;\\n        \\n    }",
                "solutionTags": [],
                "code": "    #include<stdio.h>\\n    #include<string.h>\\n    char* longestCommonPrefix(char** strs, int strsSize) \\n    {\\n        int i=0; int j=0;int index;int tempindex=0;\\n        if(strsSize<1)\\n        return \"\";\\n        index=strlen(strs[0]);\\n        char *a;\\n        a= malloc(sizeof(char)*(index+1));\\n        strcpy(a,strs[0]);\\n        for(i=1;i<strsSize;i++)\\n        {   tempindex=0;\\n            for(j=0;j<index;j++)\\n            { \\n                if(a[j]==strs[i][j])\\n                tempindex++;\\n                else\\n                {a[j]='\\\\0';\\n                 break;\\n                }\\n            } \\n              if (tempindex==0)return (\"\");\\n              if(tempindex<index)index=tempindex;\\n            \\n        }\\n        return a;\\n        \\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2744518,
                "title": "python3-solution",
                "content": "Simple & fast.\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs) == 0: return \"\"\\n        \\n        longPref = strs[0]\\n        \\n        for string in strs:\\n            for index in range(0, len(longPref)):\\n                if (index >= len(string) or longPref[index] != string[index]):\\n                    longPref = longPref[0:index]\\n                    break\\n                \\n        return longPref\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs) == 0: return \"\"\\n        \\n        longPref = strs[0]\\n        \\n        for string in strs:\\n            for index in range(0, len(longPref)):\\n                if (index >= len(string) or longPref[index] != string[index]):\\n                    longPref = longPref[0:index]\\n                    break\\n                \\n        return longPref\\n```",
                "codeTag": "Java"
            },
            {
                "id": 537447,
                "title": "swift-faster-than-93-78-of-swift-online-submissions",
                "content": "```\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        if strs.isEmpty { return \"\" }\\n        if strs.count == 1 { return strs[0] }\\n\\n        let strs = strs.sorted()\\n        var output = \"\"\\n        for (char1, char2) in zip(strs.first!, strs.last!) {\\n            if char1 == char2 {\\n                output += String(char1)\\n            } else {\\n                break\\n            }\\n        }\\n        return output\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        if strs.isEmpty { return \"\" }\\n        if strs.count == 1 { return strs[0] }\\n\\n        let strs = strs.sorted()\\n        var output = \"\"\\n        for (char1, char2) in zip(strs.first!, strs.last!) {\\n            if char1 == char2 {\\n                output += String(char1)\\n            } else {\\n                break\\n            }\\n        }\\n        return output\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 6944,
                "title": "python-recursive-boring-solution-linear-time-and-constant-space-with-simple-explanation",
                "content": "````\\n# asymptotic O(n*m) (n=number of words, m=number of letters) time, and O(1) space complexity\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if not strs:\\n            return ''\\n        first_word = strs[0]\\n        for i in range(len(first_word)):\\n            for j in range(1,len(strs)):\\n                if i >= len(strs[j]): # first_word larger than current_word\\n                    return first_word[:i]\\n                if strs[j][i] != first_word[i]: # letters don't equal\\n                    return first_word[:i]\\n\\n        return first_word # made it to the end of the first word so this the common prefix\\n````\\nExplanation: No sorting (which adds additional O(nlogn) complexity) needed. The letters of the first word in the `strs` list will be used to compare against the letters of all of the other strings in the list. There are two main comparison cases while iterating over the letters of the first word: 1) The current index of the first word is larger then current index of the word being compared against. 2) The current first word letter does not match the letter in the word being compared against. In both cases, just return the substring of the first word up until this index. If you make it though the entire first word, then the entire first word is the common prefix.",
                "solutionTags": [
                    "Python"
                ],
                "code": "````\\n# asymptotic O(n*m) (n=number of words, m=number of letters) time, and O(1) space complexity\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if not strs:\\n            return ''\\n        first_word = strs[0]\\n        for i in range(len(first_word)):\\n            for j in range(1,len(strs)):\\n                if i >= len(strs[j]): # first_word larger than current_word\\n                    return first_word[:i]\\n                if strs[j][i] != first_word[i]: # letters don't equal\\n                    return first_word[:i]\\n\\n        return first_word # made it to the end of the first word so this the common prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049209,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple Brute Force Solution\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n\\n    // Return early on empty input\\n    if (!strs.length) return \\'\\';\\n\\n    // Loop through the letters of the first string\\n    for (let i = 0; i <= strs[0].length; i++) {\\n        // Loop through the other strings\\n        for (let j = 1; j < strs.length; j++) {\\n            // Check if this character is also present in the same position of each string\\n            if (strs[0][i] !== strs[j][i]) {\\n                // If not, return the string up to and including the previous character\\n                return strs[0].slice(0, i);\\n            }\\n        }\\n    }\\n\\n    return strs[0];\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n\\n    // Return early on empty input\\n    if (!strs.length) return \\'\\';\\n\\n    // Loop through the letters of the first string\\n    for (let i = 0; i <= strs[0].length; i++) {\\n        // Loop through the other strings\\n        for (let j = 1; j < strs.length; j++) {\\n            // Check if this character is also present in the same position of each string\\n            if (strs[0][i] !== strs[j][i]) {\\n                // If not, return the string up to and including the previous character\\n                return strs[0].slice(0, i);\\n            }\\n        }\\n    }\\n\\n    return strs[0];\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2768776,
                "title": "c-prefix",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        \\n        // Sort the vector\\n        sort(strs.begin(), strs.end());\\n        string ans = \"\"; // for storing answer\\n        \\n        string a = strs[0]; // after sorting first element\\n        string b = strs[n-1]; // after sorting last element\\n        \\n        // We can compare for first and last , since they are sorted\\n        // i < a.length() ==> common prefix we can select least word\\n        for(int i = 0; i < a.length(); i++){\\n            if(a[i] == b[i]){\\n                // If same add in answer\\n                ans += a[i];\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        \\n        // Sort the vector\\n        sort(strs.begin(), strs.end());\\n        string ans = \"\"; // for storing answer\\n        \\n        string a = strs[0]; // after sorting first element\\n        string b = strs[n-1]; // after sorting last element\\n        \\n        // We can compare for first and last , since they are sorted\\n        // i < a.length() ==> common prefix we can select least word\\n        for(int i = 0; i < a.length(); i++){\\n            if(a[i] == b[i]){\\n                // If same add in answer\\n                ans += a[i];\\n            }else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 281741,
                "title": "c-100ms-faster-than-96",
                "content": "Could certainly be improved but I didn\\'t see any other C# solutions posted so I wanted to include something\\n\\n\\n```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs) {\\n        if(strs.Length == 1)\\n            return strs[0];\\n        \\n        var prefixString = \"\";\\n        \\n        if (strs == null || strs.Length == 0)\\n            return prefixString;\\n        \\n        // Go through all the letters of the first word\\n        for(int i = 0; i < strs[0].Length; i++){\\n            \\n            // Go through each of the remaining words\\n            foreach(string str in strs){\\n                // If i is higher then the length of the word\\n                // there is no longer a prefix to match\\n                if(i > str.Length - 1)\\n                    return prefixString;\\n                \\n                // If the i-th letter of the string doesn\\'t match the i-th \\n                // letter of the first word we\\'ve reached the end of the\\n                // common prefix\\n                if(strs[0][i] != str[i])\\n                    return prefixString;            \\n            }\\n            \\n            // If we make it through the inner foreach all of the \\n            prefixString += strs[0][i];\\n        }\\n        \\n        \\n        return prefixString;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs) {\\n        if(strs.Length == 1)\\n            return strs[0];\\n        \\n        var prefixString = \"\";\\n        \\n        if (strs == null || strs.Length == 0)\\n            return prefixString;\\n        \\n        // Go through all the letters of the first word\\n        for(int i = 0; i < strs[0].Length; i++){\\n            \\n            // Go through each of the remaining words\\n            foreach(string str in strs){\\n                // If i is higher then the length of the word\\n                // there is no longer a prefix to match\\n                if(i > str.Length - 1)\\n                    return prefixString;\\n                \\n                // If the i-th letter of the string doesn\\'t match the i-th \\n                // letter of the first word we\\'ve reached the end of the\\n                // common prefix\\n                if(strs[0][i] != str[i])\\n                    return prefixString;            \\n            }\\n            \\n            // If we make it through the inner foreach all of the \\n            prefixString += strs[0][i];\\n        }\\n        \\n        \\n        return prefixString;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7224,
                "title": "share-my-java-solution",
                "content": "Scan all the strings with the same pace, once we reach the end of a string or find a mismatch we return the result.\\n\\n    public String longestCommonPrefix(String[] strs) {\\n      if (strs == null || strs.length == 0) {\\n        return \"\";\\n      }\\n      \\n      for (int i = 0; i < strs[0].length(); i++) {\\n        for (int j = 1; j < strs.length; j++) {\\n          if (i >= strs[j].length() || strs[j].charAt(i) != strs[0].charAt(i)) {\\n            return strs[0].substring(0, i);\\n          }\\n        }\\n      }\\n      \\n      return strs[0];\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Scan all the strings with the same pace, once we reach the end of a string or find a mismatch we return the result.\\n\\n    public String longestCommonPrefix(String[] strs) {\\n      if (strs == null || strs.length == 0) {\\n        return \"\";\\n      }\\n      \\n      for (int i = 0; i < strs[0].length(); i++) {\\n        for (int j = 1; j < strs.length; j++) {\\n          if (i >= strs[j].length() || strs[j].charAt(i) != strs[0].charAt(i)) {\\n            return strs[0].substring(0, i);\\n          }\\n        }\\n      }\\n      \\n      return strs[0];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2703310,
                "title": "comparision-of-characters-of-two-strings-java",
                "content": "1. If the ```strs``` array does not contain any element then return ```null``` string OR if it contains only one element then return that string.\\n2. Make a character array ```arr``` of the first element of ```strs``` array. This is done in order to compare the characters with the remaining elements of the ```strs``` array.\\n3. Make a variable ```i``` and assign it a value 0, another variable ```ans``` and assign it the value of Integer.MAX_VALUE\\n3. Place a pointer ```j``` on the 1st position of ```strs``` array and traverse it till the length of the array. Inside this loop, make a pointer ```k``` and traverse it till the **minimum** of the length of **j**th element of ```strs``` array and the length of ```arr``` array. (Minimum length is taken in order to avoid the IndexOutofBoundException)\\n4. Inside this second loop, check if the characters of that **j**th element matches with the **k**th character of ```arr``` array. Increment the value of ```i``` if this condition satisfies. Else break the loop if at any iteration the character doesn\\'t matches.\\n5. If ```i``` is less than ```ans``` then update the value of ```ans = i```. This is done because so as to minimize the length of the common valid prefix.\\n6. Update the value of ```i``` to 0 for the next iteration. This is how here the first loop ends.\\n7. Make an empty string ```res```. Initialize a for loop from 0 to ```ans``` and concatenate the subsequent characters of the ```arr``` array so as to make the final **longest common prefix**.\\n8. Finally, return ```res```.\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        char[] arr = strs[0].toCharArray();\\n        if(strs.length == 0){\\n            return \"\";\\n        }\\n        if(strs.length == 1){\\n            return strs[0];\\n        }\\n        int i = 0,ans = Integer.MAX_VALUE;\\n        for (int j = 1;j < strs.length;j++){\\n            for (int k = 0;k < Math.min(strs[j].length(),arr.length);k++){\\n                if(strs[j].charAt(k) == arr[k]){\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(i < ans){\\n                ans = i;\\n            }\\n            i = 0;\\n        }\\n        String res = \"\";\\n        for (int j = 0;j < ans;j++){\\n            res += arr[j];\\n        }\\n        return res;\\n    }\\n}\\n```\\n**If you got this, please upvote :)**",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```strs```\n```null```\n```arr```\n```strs```\n```strs```\n```i```\n```ans```\n```j```\n```strs```\n```k```\n```strs```\n```arr```\n```arr```\n```i```\n```i```\n```ans```\n```ans = i```\n```i```\n```res```\n```ans```\n```arr```\n```res```\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        char[] arr = strs[0].toCharArray();\\n        if(strs.length == 0){\\n            return \"\";\\n        }\\n        if(strs.length == 1){\\n            return strs[0];\\n        }\\n        int i = 0,ans = Integer.MAX_VALUE;\\n        for (int j = 1;j < strs.length;j++){\\n            for (int k = 0;k < Math.min(strs[j].length(),arr.length);k++){\\n                if(strs[j].charAt(k) == arr[k]){\\n                    i++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            if(i < ans){\\n                ans = i;\\n            }\\n            i = 0;\\n        }\\n        String res = \"\";\\n        for (int j = 0;j < ans;j++){\\n            res += arr[j];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2695808,
                "title": "python-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy first thought was to sort the array according to the length of the strings and then use the shortest string as the base prefix.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAfter sorting and getting the base prefix we simply check if the base prefix is the longest common prefix if that is not the case we check if excluding the last letter of base prefix gives us the longest common prefix, we do this until we run out of letters in base prefix and in this case we return empty string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn)\\nm = min(array, key lambda x:len(x))\\nn = len(array)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort(key = lambda x:len(x))\\n        prefix = strs[0]\\n        for i in range(len(strs[0]),0,-1):\\n            if all([prefix[:i] == strs[j][:i] for j in range(1,len(strs))]):\\n                return(prefix[:i])\\n        return \"\"\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort(key = lambda x:len(x))\\n        prefix = strs[0]\\n        for i in range(len(strs[0]),0,-1):\\n            if all([prefix[:i] == strs[j][:i] for j in range(1,len(strs))]):\\n                return(prefix[:i])\\n        return \"\"\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2587164,
                "title": "c-2-solutions-simple-and-clean",
                "content": "**Time complexity - O(n*m)\\nSpace complexity - O(1)**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans;\\n        \\n        for(int i=0;i<strs[0].size();i++) {\\n            for(int j=1;j<strs.size();j++) {\\n                if(strs[0][i] != strs[j][i]) {\\n                    return ans;\\n                }\\n            }\\n            ans += strs[0][i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Optimized solution.**\\n**Time complexity - O(n logn)\\nSpace complexity - O(1)**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans;\\n        \\n        sort(strs.begin(),strs.end());\\n        for(int i=0;i<strs[0].size();i++) {\\n            if(strs[0][i] != strs[strs.size()-1][i]) {\\n                return ans;\\n            }\\n            ans += strs[0][i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n**Like the solution?\\nPlease upvote \\u30C4**\\n\\nIf you can\\'t understand any step/point, feel free to comment.\\nHappy to help",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans;\\n        \\n        for(int i=0;i<strs[0].size();i++) {\\n            for(int j=1;j<strs.size();j++) {\\n                if(strs[0][i] != strs[j][i]) {\\n                    return ans;\\n                }\\n            }\\n            ans += strs[0][i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string ans;\\n        \\n        sort(strs.begin(),strs.end());\\n        for(int i=0;i<strs[0].size();i++) {\\n            if(strs[0][i] != strs[strs.size()-1][i]) {\\n                return ans;\\n            }\\n            ans += strs[0][i];\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158660,
                "title": "c-java-python3-javascript-solution-explanation",
                "content": "Which have included C#, Java, Python3,JavaScript solutions\\n(JavaScript version have been updated on 2022/06/16 )\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)\\u2B50\\n\\n\\u2B07JavaScript Submission Detail (2022/06/16) \\u2B07\\n![image](https://assets.leetcode.com/users/images/60e91036-09f2-431f-b730-22bcf63a4c8f_1655382611.7401285.png)\\n\\n\\n\\n#### Example : Java Code \\u27A1 Runtime : 1ms\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```\\n**You can find a faster Java solution in the link.**\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2152670,
                "title": "c-easiest-solution-detailed-explanation-short-simple-code",
                "content": "```\\nstring longestCommonPrefix(vector<string>& strs) {\\n       \\n        int n=strs.size();\\n        sort(strs.begin(),strs.end());\\n        string ans;\\n//Since we need to find the longest common prefix, we just need to compare the 0th and the last string in strs after sorting and see which characters are common. Since it\\'s sorted, 0th & last strings\\' common characters will be the ans.\\n        string s1=strs[0];\\n        string s2=strs[n-1];\\n        \\n        for(int i=0; i<s1.size(); i++)\\n        {\\n            if(s1[i]==s2[i])\\n                ans=ans+s1[i];\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n```\\n*If this was helpful, don\\'t forget to upvote!*",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\nstring longestCommonPrefix(vector<string>& strs) {\\n       \\n        int n=strs.size();\\n        sort(strs.begin(),strs.end());\\n        string ans;\\n//Since we need to find the longest common prefix, we just need to compare the 0th and the last string in strs after sorting and see which characters are common. Since it\\'s sorted, 0th & last strings\\' common characters will be the ans.\\n        string s1=strs[0];\\n        string s2=strs[n-1];\\n        \\n        for(int i=0; i<s1.size(); i++)\\n        {\\n            if(s1[i]==s2[i])\\n                ans=ans+s1[i];\\n            else\\n                break;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1545132,
                "title": "java-tc-o-n-minlen-sc-o-1-constant-space-vertical-scanning-solution",
                "content": "**Constant Space Solution - Using String.substring to save on auxillary space**\\n```\\n/**\\n * Vertical Scanning or Column Scanning. Here character at the same index is\\n * compared. If the character at the same index in all input strings is same,\\n * add it to the prefix. Else, return the found prefix.\\n *\\n * Using substring instead of string builder to save on space.\\n *\\n * Time Complexity: O(N * minLen)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Number of strings in strs. minLen = Length of the smallest string.\\n */\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int numStrs = strs.length;\\n        if (numStrs == 0 || \"\".equals(strs[0]) || \"\".equals(strs[numStrs - 1])) {\\n            return \"\";\\n        }\\n\\n        String firstStr = strs[0];\\n        if (numStrs == 1) {\\n            return firstStr;\\n        }\\n\\n        int prefixLen = 0;\\n\\n\\t\\t// No need to find the minLen as this nested loop will exit when we reach the\\n        // end of minLen string.\\n        while (prefixLen < firstStr.length()) {\\n            char c = firstStr.charAt(prefixLen);\\n            for (int i = 1; i < numStrs; i++) {\\n                if (strs[i].length() <= prefixLen || strs[i].charAt(prefixLen) != c) {\\n                    return firstStr.substring(0, prefixLen);\\n                }\\n            }\\n            prefixLen++;\\n        }\\n\\n        return firstStr.substring(0, prefixLen);\\n    }\\n}\\n```\\n\\n---\\n**This solution will take O(minLen) space. Using StringBuilder to keep track of the result**\\n```java\\n/**\\n * Vertical Scanning or Column Scanning. Here character at the same index is\\n * compared. If the character at the same index in all input strings is same,\\n * add it to the prefix. Else, return the found prefix.\\n *\\n * In this solution using StringBuilder to keep track of the result\\n *\\n * Time Complexity: O(N * minLen + N)\\n *\\n * Space Complexity: O(minLen)\\n *\\n * N = Number of strings in strs. minLen = Length of smallest string in strs.\\n */\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n        if (strs.length == 1) {\\n            return strs[0];\\n        }\\n\\n        int minLen = Integer.MAX_VALUE;\\n        for (String s : strs) {\\n            minLen = Math.min(minLen, s.length());\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < minLen; i++) {\\n            char c1 = strs[0].charAt(i);\\n            for (int j = 1; j < strs.length; j++) {\\n                if (c1 != strs[j].charAt(i)) {\\n                    return sb.toString();\\n                }\\n            }\\n            sb.append(c1);\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n/**\\n * Vertical Scanning or Column Scanning. Here character at the same index is\\n * compared. If the character at the same index in all input strings is same,\\n * add it to the prefix. Else, return the found prefix.\\n *\\n * Using substring instead of string builder to save on space.\\n *\\n * Time Complexity: O(N * minLen)\\n *\\n * Space Complexity: O(1)\\n *\\n * N = Number of strings in strs. minLen = Length of the smallest string.\\n */\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null) {\\n            throw new IllegalArgumentException(\"Input array is null\");\\n        }\\n\\n        int numStrs = strs.length;\\n        if (numStrs == 0 || \"\".equals(strs[0]) || \"\".equals(strs[numStrs - 1])) {\\n            return \"\";\\n        }\\n\\n        String firstStr = strs[0];\\n        if (numStrs == 1) {\\n            return firstStr;\\n        }\\n\\n        int prefixLen = 0;\\n\\n\\t\\t// No need to find the minLen as this nested loop will exit when we reach the\\n        // end of minLen string.\\n        while (prefixLen < firstStr.length()) {\\n            char c = firstStr.charAt(prefixLen);\\n            for (int i = 1; i < numStrs; i++) {\\n                if (strs[i].length() <= prefixLen || strs[i].charAt(prefixLen) != c) {\\n                    return firstStr.substring(0, prefixLen);\\n                }\\n            }\\n            prefixLen++;\\n        }\\n\\n        return firstStr.substring(0, prefixLen);\\n    }\\n}\\n```\n```java\\n/**\\n * Vertical Scanning or Column Scanning. Here character at the same index is\\n * compared. If the character at the same index in all input strings is same,\\n * add it to the prefix. Else, return the found prefix.\\n *\\n * In this solution using StringBuilder to keep track of the result\\n *\\n * Time Complexity: O(N * minLen + N)\\n *\\n * Space Complexity: O(minLen)\\n *\\n * N = Number of strings in strs. minLen = Length of smallest string in strs.\\n */\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n        if (strs.length == 1) {\\n            return strs[0];\\n        }\\n\\n        int minLen = Integer.MAX_VALUE;\\n        for (String s : strs) {\\n            minLen = Math.min(minLen, s.length());\\n        }\\n\\n        StringBuilder sb = new StringBuilder();\\n\\n        for (int i = 0; i < minLen; i++) {\\n            char c1 = strs[0].charAt(i);\\n            for (int j = 1; j < strs.length; j++) {\\n                if (c1 != strs[j].charAt(i)) {\\n                    return sb.toString();\\n                }\\n            }\\n            sb.append(c1);\\n        }\\n\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 527474,
                "title": "c-solution",
                "content": "```c\\nchar * longestCommonPrefix(char ** strs, int strsSize){\\n    if (strsSize == 0) return \"\";\\n    if (strsSize == 1) return strs[0];\\n\\n    int len = 0, min = strlen(strs[0]);\\n    for (int i = 1; i < strsSize; ++i) {\\n        min = strlen(strs[i]) < min ? strlen(strs[i]) : min;\\n    }\\n\\n    for (int c = 0; c < min; ++c) {\\n        for (int s = 0; s < strsSize - 1; ++s) {\\n            if (strs[s][c] == strs[s+1][c]) {\\n                if (s == strsSize - 2) {\\n                    ++len;\\n                }\\n            } else {\\n                goto br;\\n            }\\n        }\\n    }\\n    br:\\n\\n    if (len > 0) {\\n        char* ret = malloc(len * sizeof(int));\\n        strs[0][len] = \\'\\\\0\\';\\n        strcpy(ret, strs[0]);\\n        return ret;\\n    }\\n\\n    return \"\";\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```c\\nchar * longestCommonPrefix(char ** strs, int strsSize){\\n    if (strsSize == 0) return \"\";\\n    if (strsSize == 1) return strs[0];\\n\\n    int len = 0, min = strlen(strs[0]);\\n    for (int i = 1; i < strsSize; ++i) {\\n        min = strlen(strs[i]) < min ? strlen(strs[i]) : min;\\n    }\\n\\n    for (int c = 0; c < min; ++c) {\\n        for (int s = 0; s < strsSize - 1; ++s) {\\n            if (strs[s][c] == strs[s+1][c]) {\\n                if (s == strsSize - 2) {\\n                    ++len;\\n                }\\n            } else {\\n                goto br;\\n            }\\n        }\\n    }\\n    br:\\n\\n    if (len > 0) {\\n        char* ret = malloc(len * sizeof(int));\\n        strs[0][len] = \\'\\\\0\\';\\n        strcpy(ret, strs[0]);\\n        return ret;\\n    }\\n\\n    return \"\";\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 293568,
                "title": "python-easy-solution-runtime-95-faster",
                "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        lcp = \"\"\\n        for s in zip(*strs):\\n            if (s[0],) * len(s) == s:\\n                lcp += s[0]\\n            else:\\n                break\\n        return lcp\\n```",
                "solutionTags": [
                    "Python",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        lcp = \"\"\\n        for s in zip(*strs):\\n            if (s[0],) * len(s) == s:\\n                lcp += s[0]\\n            else:\\n                break\\n        return lcp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 160011,
                "title": "simple-and-clear-solution-in-c-java-python",
                "content": "Sort the string array first, then we only need to find out the longest common prefix between the first and last word.\\n#### C++\\n```\\n# include<algorithm>\\n\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        if(n == 0) {\\n            return \"\";\\n        }\\n        string res = \"\";\\n        sort(strs.begin(), strs.end());// sort the array\\n        string first = strs[0]; // first word\\n        string last = strs[n-1];// last word\\n        int limit = min(first.length(), last.length());\\n        for(int i = 0; i < limit; i++) {// find out the longest common prefix between first and last word\\n            if(first[i] == last[i]) {\\n                res += first[i];\\n            }    \\n            else {\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n#### Java\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int n = strs.length;\\n        if(n == 0) {\\n            return \"\";\\n        }\\n        StringBuffer sb = new StringBuffer();\\n        Arrays.sort(strs);// sort string array\\n        String first = strs[0];\\n        String last = strs[n-1];\\n        int limit = Math.min(first.length(), last.length());\\n        for(int i = 0; i < limit; i++) {// find out the longest common prefix between first and last word\\n            if(first.charAt(i) == last.charAt(i)) {\\n                sb.append(first.charAt(i));\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n#### Python\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        n = len(strs)\\n        if n == 0:\\n            return \"\"\\n        \\n        res = \"\"\\n        strs.sort() # sort the string array\\n        first = strs[0]\\n        last = strs[-1]\\n        limit = min(len(first), len(last)) \\n        for i in range(limit): # find out the longest common prefix between first and last word\\n            if first[i] == last[i]:\\n                res += first[i]\\n            else:\\n                break\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n# include<algorithm>\\n\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        if(n == 0) {\\n            return \"\";\\n        }\\n        string res = \"\";\\n        sort(strs.begin(), strs.end());// sort the array\\n        string first = strs[0]; // first word\\n        string last = strs[n-1];// last word\\n        int limit = min(first.length(), last.length());\\n        for(int i = 0; i < limit; i++) {// find out the longest common prefix between first and last word\\n            if(first[i] == last[i]) {\\n                res += first[i];\\n            }    \\n            else {\\n                break;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int n = strs.length;\\n        if(n == 0) {\\n            return \"\";\\n        }\\n        StringBuffer sb = new StringBuffer();\\n        Arrays.sort(strs);// sort string array\\n        String first = strs[0];\\n        String last = strs[n-1];\\n        int limit = Math.min(first.length(), last.length());\\n        for(int i = 0; i < limit; i++) {// find out the longest common prefix between first and last word\\n            if(first.charAt(i) == last.charAt(i)) {\\n                sb.append(first.charAt(i));\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        n = len(strs)\\n        if n == 0:\\n            return \"\"\\n        \\n        res = \"\"\\n        strs.sort() # sort the string array\\n        first = strs[0]\\n        last = strs[-1]\\n        limit = min(len(first), len(last)) \\n        for i in range(limit): # find out the longest common prefix between first and last word\\n            if first[i] == last[i]:\\n                res += first[i]\\n            else:\\n                break\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 129542,
                "title": "swift-16-ms",
                "content": "```\\nfunc longestCommonPrefix(_ strs: [String]) -> String {\\n    \\n   if strs.count == 0 { return \"\" }\\n    \\n    let shortestWord = strs.min{$0.count < $1.count}!\\n    var longestPrefix = shortestWord\\n    \\n        for str in strs {\\n            \\n            while !str.hasPrefix(longestPrefix), longestPrefix.count > 0 {\\n                longestPrefix.removeLast()\\n            }\\n            \\n            if longestPrefix.count == 0 { return longestPrefix }\\n        }\\n    \\n    return longestPrefix\\n}\\n```\\nThere is no need, actually, to use shortestWord. It just stayed there from one of my previous submission. But when I noticed that and removed it:\\n\\n```\\n    var longestPrefix = strs.min{$0.count < $1.count}!\\n```\\n\\nthen time went up to the 22 ms :)",
                "solutionTags": [],
                "code": "```\\nfunc longestCommonPrefix(_ strs: [String]) -> String {\\n    \\n   if strs.count == 0 { return \"\" }\\n    \\n    let shortestWord = strs.min{$0.count < $1.count}!\\n    var longestPrefix = shortestWord\\n    \\n        for str in strs {\\n            \\n            while !str.hasPrefix(longestPrefix), longestPrefix.count > 0 {\\n                longestPrefix.removeLast()\\n            }\\n            \\n            if longestPrefix.count == 0 { return longestPrefix }\\n        }\\n    \\n    return longestPrefix\\n}\\n```\n```\\n    var longestPrefix = strs.min{$0.count < $1.count}!\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6950,
                "title": "clean-7-lines-c",
                "content": "**Solution 1**\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        string res = strs[0];\\n        for(auto s: strs) res = match(res, s);\\n        return res;\\n    }\\n    \\n    string match(const string& pre, const string& s){\\n        int i = 0, len = min(pre.size(), s.size());\\n        for(; i < len; i++) if(s[i] != pre[i]) break;\\n        return pre.substr(0, i);\\n    }\\n};\\n```\\n***\\n**Solution 2**\\n\\nUsing sort and only compare the first string with the last string.\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        sort(strs.begin(), strs.end());\\n        string a = strs[0], b = strs.back();\\n        int i = 0;\\n        for(; i < min(a.size(), b.size()); i++) if(a[i] != b[i]) break;\\n        return a.substr(0, i);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        string res = strs[0];\\n        for(auto s: strs) res = match(res, s);\\n        return res;\\n    }\\n    \\n    string match(const string& pre, const string& s){\\n        int i = 0, len = min(pre.size(), s.size());\\n        for(; i < len; i++) if(s[i] != pre[i]) break;\\n        return pre.substr(0, i);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        sort(strs.begin(), strs.end());\\n        string a = strs[0], b = strs.back();\\n        int i = 0;\\n        for(; i < min(a.size(), b.size()); i++) if(a[i] != b[i]) break;\\n        return a.substr(0, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7258,
                "title": "3-diffrent-c-solutions-each-one-costs-8ms",
                "content": "First one: check from strs[0][0] to strs[i][0]. If matches, check strs[0][1] to strs[i][1].\\n\\nCode:\\n\\n    class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            if(strs.size()==0)\\n            return \"\";\\n            string ans=\"\";\\n            int max=INT_MAX;\\n            for(auto& s:strs)\\n            {\\n                max=(max>s.length())?s.length():max;\\n            }\\n            for(int i=0;i<max;i++)\\n            {\\n                bool flag=true;\\n                char x=strs[0][i];\\n                for(auto& s:strs)\\n                {\\n                    if(s[i]!=x)\\n                    {\\n                        flag=false;\\n                        break;\\n                    }\\n                }\\n                if(flag==false)\\n                return ans;\\n                ans+=x;\\n            }\\n            return ans;\\n        }\\n    };\\n\\nSecond one: assume the prefix is strs[0]. Compair with strs[i], and cut the letters which don't match.\\n\\nCode:\\n\\n    class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            if(strs.size()==0)\\n            return \"\";\\n            string ans=strs[0];\\n            int max=INT_MAX;\\n            for(auto& s:strs)\\n            {\\n                if(s.length()==0)\\n                return \"\";\\n                int i=0;\\n                for(i=0;i<ans.length()&&i<s.length();i++)\\n                {\\n                    if(s[i]!=ans[i])\\n                    break;\\n                }\\n                ans=ans.substr(0,i);\\n            }\\n    \\n            return ans;\\n        }\\n    };\\n\\nThird one:  use a Trie data structure to save the strs. Search the trie, and stops when a TrieNode has more than one son.\\n\\nCode:\\n\\n    class TrieNode{\\n    public:\\n    \\tbool val;\\n    \\tTrieNode* next[52];\\n    \\tint sons;\\n    \\tTrieNode() :val(false), sons(0)\\n    \\t{\\n    \\t\\tfor (int i = 0; i < 52; i++)\\n    \\t\\t\\tnext[i] = nullptr;\\n    \\t}\\n    };\\n    class Trie{\\n    private:\\n    \\tTrieNode* putst(string& s, TrieNode * node, int loc, TrieNode *father)\\n    \\t{\\n    \\t\\tif (s.length() == 0)\\n    \\t\\t{\\n    \\t\\t\\tnode->val = true;\\n    \\t\\t\\tnode->sons++;\\n    \\t\\t\\treturn node;\\n    \\t\\t}\\n    \\t\\tif (node == nullptr)\\n    \\t\\t{\\n    \\t\\t\\tnode = new TrieNode();\\n    \\t\\t\\tif (father != nullptr)\\n    \\t\\t\\t\\tfather->sons++;\\n    \\t\\t}\\n    \\t\\tif (loc == s.length())\\n    \\t\\t{\\n    \\t\\t\\tnode->val = true;\\n    \\t\\t\\treturn node;\\n    \\t\\t}\\n    \\t\\tif (s[loc] >= 'a')\\n    \\t\\t\\tnode->next[s[loc] - 'a'] = putst(s, node->next[s[loc] - 'a'], loc + 1, node);\\n    \\t\\telse\\n    \\t\\t\\tnode->next[s[loc] - 'A' + 26] = putst(s, node->next[s[loc] - 'A' + 26], loc + 1, node);\\n    \\t\\treturn node;\\n    \\t}\\n    public:\\n    \\tTrieNode *root;\\n    \\tvoid insert(string & str){ putst(str, root, 0, nullptr); }\\n    \\tTrie(){ root = new TrieNode(); }\\n    };\\n    class Solution {\\n    private:\\n    \\tstring findPre(TrieNode * node)\\n    \\t{\\n    \\t\\tif (node == nullptr || (node != nullptr&&node->sons > 1))\\n    \\t\\t\\treturn string(\"\");\\n    \\t\\tint i = 0;\\n    \\t\\tfor (i = 0; i < 52; i++)\\n    \\t\\t{\\n    \\t\\t\\tif (node->next[i] != nullptr)\\n    \\t\\t\\t\\tbreak;\\n    \\t\\t}\\n    \\t\\tif (i == 52)\\n    \\t\\t\\treturn string(\"\");\\n    \\t\\tchar temp1 = ((i>25) ? ('A' + i) : ('a' + i));\\n    \\t\\tstring temp;\\n    \\t\\ttemp.insert(temp.begin(), temp1);\\n    \\t\\tif (node->val)\\n    \\t\\t{\\n    \\t\\t\\treturn string(\"\");\\n    \\t\\t}\\n    \\t\\telse\\n    \\t\\t{\\n    \\t\\t\\treturn temp + findPre(node->next[i]);\\n    \\t\\t}\\n    \\t}\\n    public:\\n    \\tstring longestCommonPrefix(vector<string>& strs) {\\n    \\t\\tTrie a;\\n    \\t\\tfor (auto& str : strs)\\n    \\t\\t\\ta.insert(str);\\n    \\t\\treturn findPre(a.root);\\n    \\t}\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        string longestCommonPrefix(vector<string>& strs) {\\n            if(strs.size()==0)\\n            return \"\";\\n            string ans=\"\";\\n            int max=INT_MAX;\\n            for(auto& s:strs)\\n            {\\n                max=(max>s.length())?s.length():max;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3152934,
                "title": "beats-100-c-easy-solution",
                "content": "# Intuition\\n# Approach\\n1.short the string \\n   sort(str.begin(), str.end())\\n   it will short in alphabetically order\\n   such that no need to compair string in between start and last      string so\\n   \\n2.compair first string alphabet with last string alphabet\\n3.store in another string if alphabet gets equall;\\n\\n \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n     string ans=\"\"; //to store result \\n     sort(str.begin(), str.end()); \\n      string firstStr=str[0];\\n      string lastStr=str[str.size()-1]; \\n        for(int i=0; i<firstStr.size(); i++)\\n        {\\n           if(firstStr[i]==lastStr[i])//compair first string alphabet with last string alphabet\\n           {\\n             ans=ans+firstStr[i];\\n           }\\n            else \\n             break;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n     string ans=\"\"; //to store result \\n     sort(str.begin(), str.end()); \\n      string firstStr=str[0];\\n      string lastStr=str[str.size()-1]; \\n        for(int i=0; i<firstStr.size(); i++)\\n        {\\n           if(firstStr[i]==lastStr[i])//compair first string alphabet with last string alphabet\\n           {\\n             ans=ans+firstStr[i];\\n           }\\n            else \\n             break;\\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2928400,
                "title": "easiest-faang-method-ever",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis question uses the beauty of sort() in strings. \\n```\\nWhen Strings are sorted, the possibility of characters to be least\\ncommon is between 1st and last member of the sorted strings.\\n```\\nVery simple beginner friendly question. Yet the idea of sorting stings is what makes it tricky \\uD83D\\uDCA1\\n\\n# Complexity\\n- Time complexity: O(n logn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        string res=\"\";\\n        sort(str.begin(),str.end());\\n        string a=str[0];\\n        string b=str[str.size()-1];\\n        for(int i=0;i<str[0].size();i++){\\n            if(a[i]==b[i])\\n                res+=a[i];\\n            else\\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "C",
                    "String"
                ],
                "code": "```\\nWhen Strings are sorted, the possibility of characters to be least\\ncommon is between 1st and last member of the sorted strings.\\n```\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        string res=\"\";\\n        sort(str.begin(),str.end());\\n        string a=str[0];\\n        string b=str[str.size()-1];\\n        for(int i=0;i<str[0].size();i++){\\n            if(a[i]==b[i])\\n                res+=a[i];\\n            else\\n                break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2175545,
                "title": "python-solution-beats-95-34-brute-force",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort()\\n        lim = min(strs,key=len)\\n        res = \"\"\\n        for i in range(len(lim)):\\n            if strs[0][i] != strs[len(strs)-1][i]:\\n                break\\n            res += strs[0][i]\\n        return res\\n```\\n**.\\n.\\n.\\n.\\n.\\n.\\nPlease Upvote if you find this post useful...**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort()\\n        lim = min(strs,key=len)\\n        res = \"\"\\n        for i in range(len(lim)):\\n            if strs[0][i] != strs[len(strs)-1][i]:\\n                break\\n            res += strs[0][i]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1031242,
                "title": "javascript-simple-solution-faster-than-87",
                "content": "```\\nvar longestCommonPrefix = function (strs) {\\n \\n  let lcp = \\'\\';\\n  if (!strs || !strs.length) return lcp;\\n  \\n  // sorting array alphabetically \\n  strs.sort()\\n  \\n  for (let i = 0; i < strs[0].length; ++i) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]) {    // comparing only first and last item\\n      break;\\n    } else {\\n      lcp += strs[0][i];\\n    }\\n  }\\n  return lcp;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function (strs) {\\n \\n  let lcp = \\'\\';\\n  if (!strs || !strs.length) return lcp;\\n  \\n  // sorting array alphabetically \\n  strs.sort()\\n  \\n  for (let i = 0; i < strs[0].length; ++i) {\\n    if (strs[0][i] !== strs[strs.length - 1][i]) {    // comparing only first and last item\\n      break;\\n    } else {\\n      lcp += strs[0][i];\\n    }\\n  }\\n  return lcp;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 783976,
                "title": "python-simple-solution-beats-100-runtime-12ms",
                "content": "The longest common prefix can be optimally found if we have the alphabetically smallest & largest strings. After that we just need compare them & return the longest common prefix. There is no need of sorting the array as the time complexity would be O(nlogn) for that.\\n\\n**min(an array of strings)** - returns the alphabetically smallest string\\nUse **max()** in a similar way.\\n\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0: \\n\\t\\t\\treturn \"\"\\n        s1, s2 = min(strs), max(strs)\\n        i = 0\\n        while i < len(s1) and i < len(s2) and s1[i] == s2[i]: \\n\\t\\t\\ti += 1\\n        return s1[:i]\\n```\\n\\n**Modular Version** - 16ms\\nThe lcp helper compares two strings & returns the longest common prefix. It can be included within the original function itself, I wrote it this way because in my first solution I was using Brute Force to compare all the pairs of strings. Don\\'t judge me :) \\nThis way I could reuse my pre-written piece of code without having to change anything when optimizing the Brute Force.\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"\\n        return self.lcp_helper(min(strs), max(strs))\\n\\n    def lcp_helper(self, s1, s2):\\n        i = 0\\n        while i<len(s1) and i<len(s2) and s1[i]==s2[i]:\\n            i += 1\\n        return s1[:i]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0: \\n\\t\\t\\treturn \"\"\\n        s1, s2 = min(strs), max(strs)\\n        i = 0\\n        while i < len(s1) and i < len(s2) and s1[i] == s2[i]: \\n\\t\\t\\ti += 1\\n        return s1[:i]\\n```\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"\\n        return self.lcp_helper(min(strs), max(strs))\\n\\n    def lcp_helper(self, s1, s2):\\n        i = 0\\n        while i<len(s1) and i<len(s2) and s1[i]==s2[i]:\\n            i += 1\\n        return s1[:i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 777900,
                "title": "python-3-faster-than-85-less-than-95-memory-with-explanation",
                "content": "Ok, this was a tricky one. I am surprised it\\'s ranked easy. I made my algorithm, ran into an issue, peeked at discussions as I was convinced there should be a trick/easy way of doing it, realized no, went back and completed my solution. \\n\\nIt\\'s not the most elegant, sorry for the nested loops and if\\'s but let me know if you want further explanation.\\n\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        # compares first letter of all words, then moves to next letter\\n        s = \"\"\\n        if len(strs)==0: #edge case, no elements in list\\n            return s\\n        elif len(strs)==1: #edge case, single element in list\\n            return strs[0]\\n\\n        #word length of shortest word to prevent index out of range\\n        for a in range(len(min(strs))): \\n            #loops through each word in list, starting with second word\\n            for b in range(1, len(strs)): \\n                #compares nth character of first word to other words\\n                if strs[0][a]==strs[b][a]: \\n                    #only adds to pattern if nth character same up to the last word\\n                    if b==len(strs)-1: \\n                        s += strs[0][a]\\n                else: #exits when characters don\\'t match\\n                    return s\\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        # compares first letter of all words, then moves to next letter\\n        s = \"\"\\n        if len(strs)==0: #edge case, no elements in list\\n            return s\\n        elif len(strs)==1: #edge case, single element in list\\n            return strs[0]\\n\\n        #word length of shortest word to prevent index out of range\\n        for a in range(len(min(strs))): \\n            #loops through each word in list, starting with second word\\n            for b in range(1, len(strs)): \\n                #compares nth character of first word to other words\\n                if strs[0][a]==strs[b][a]: \\n                    #only adds to pattern if nth character same up to the last word\\n                    if b==len(strs)-1: \\n                        s += strs[0][a]\\n                else: #exits when characters don\\'t match\\n                    return s\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7030,
                "title": "c-6-lines-o-n-len-of-prefix-most-optimal-i-can-think-of",
                "content": "I'm sure there is a more clever way, but this seems like the most optimal I can think of\\n* start at index 0\\n* check each string if they have the same char at the index\\n* if all have the same char increment the index\\n* terminate if any mismatch is found or any string has exceeded it's length\\n* also, avoids any string functions, adding strings, sub string, etc (except in my return)\\n\\nThis seems like it will terminate the quickest, as soon as any string runs out or any character is not a match.  It will do no unnecessary compares.\\n```\\n    public string LongestCommonPrefix(string[] strs) \\n    {\\n        int min = 0;\\n        while (strs.Length > 0)\\n        {\\n            foreach (string s in strs)\\n            {\\n                if (s.Length == min || s[min] != strs[0][min]) return strs[0].Substring(0, min);\\n            }\\n            min++;\\n        }\\n        return \"\";\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public string LongestCommonPrefix(string[] strs) \\n    {\\n        int min = 0;\\n        while (strs.Length > 0)\\n        {\\n            foreach (string s in strs)\\n            {\\n                if (s.Length == min || s[min] != strs[0][min]) return strs[0].Substring(0, min);\\n            }\\n            min++;\\n        }\\n        return \"\";\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2687169,
                "title": "javascript-solution",
                "content": "```\\nvar longestCommonPrefix = function(strs) {\\n    let cur = strs[0]\\n    let temp = \"\"\\n    for(let i = 1; i < strs.length; i++){\\n        for(let j = 0; j < cur.length; j++){\\n            if(cur[j] == strs[i][j]){\\n                temp += cur[j]\\n            } else {\\n                break\\n            }\\n        }\\n        cur = temp\\n        temp = \"\"\\n    }\\n    return cur\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n    let cur = strs[0]\\n    let temp = \"\"\\n    for(let i = 1; i < strs.length; i++){\\n        for(let j = 0; j < cur.length; j++){\\n            if(cur[j] == strs[i][j]){\\n                temp += cur[j]\\n            } else {\\n                break\\n            }\\n        }\\n        cur = temp\\n        temp = \"\"\\n    }\\n    return cur\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2297953,
                "title": "python-91-45-fasters-python-simplest-solution-with-explanation-beg-to-adv-string-o-n",
                "content": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res = \"\" #Taking a empty string for saving the result \\n        for i in zip(*strs): # check out the bottom of this artical for its explanation.\\n            a = \"\".join(i) # joining the result of zip, check out the example\\n            if len(set(a)) != 1: # this will checkout, if the elements of the all the provided string on a same level (i.e a[i][i]) are identical or not.  If its identical then will always be equal to one.\\n                return res\\n            else:\\n                res += a[0] # if we are having identical element in the string will add it to our resulting string.\\n\\n        return res\\n```\\n```python\\nzip(*strs)\\nThis will club each element of the string on the same together \\nIt will club the element till the len of shortest string available in the list.\\nExample:-\\nYour input\\n[\"flower\",\"flow\",\"flight\"]\\nstdout\\n(\\'f\\', \\'f\\', \\'f\\')\\n(\\'l\\', \\'l\\', \\'l\\')\\n(\\'o\\', \\'o\\', \\'i\\')\\n(\\'w\\', \\'w\\', \\'g\\')\\nHere, in the we were having \\'flow\\' as a shortest string and the zip clubed till its length. \\n```\\n\\n***Found helpful, Do upvote !!***\\n![image](https://assets.leetcode.com/users/images/dd2ce5b2-49e1-49be-8855-101c82825214_1658127524.888506.png)\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res = \"\" #Taking a empty string for saving the result \\n        for i in zip(*strs): # check out the bottom of this artical for its explanation.\\n            a = \"\".join(i) # joining the result of zip, check out the example\\n            if len(set(a)) != 1: # this will checkout, if the elements of the all the provided string on a same level (i.e a[i][i]) are identical or not.  If its identical then will always be equal to one.\\n                return res\\n            else:\\n                res += a[0] # if we are having identical element in the string will add it to our resulting string.\\n\\n        return res\\n```\n```python\\nzip(*strs)\\nThis will club each element of the string on the same together \\nIt will club the element till the len of shortest string available in the list.\\nExample:-\\nYour input\\n[\"flower\",\"flow\",\"flight\"]\\nstdout\\n(\\'f\\', \\'f\\', \\'f\\')\\n(\\'l\\', \\'l\\', \\'l\\')\\n(\\'o\\', \\'o\\', \\'i\\')\\n(\\'w\\', \\'w\\', \\'g\\')\\nHere, in the we were having \\'flow\\' as a shortest string and the zip clubed till its length. \\n```",
                "codeTag": "Java"
            },
            {
                "id": 934491,
                "title": "python-trie-solution",
                "content": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        root = self.root\\n        for ch in word:\\n            if ch not in root.children:\\n                root.children[ch] = TrieNode()\\n            root = root.children[ch]\\n        root.endOfWord = True\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \\'\\'\\n        \\n        trie = Trie()\\n        \\n        for word in strs:\\n            trie.insert(word)\\n            \\n        root = trie.root\\n        res = \\'\\'\\n        while root:\\n            if len(root.children) > 1 or root.endOfWord:\\n                return res\\n            \\n            key = list(root.children)[0]\\n            res += key\\n            \\n            root = root.children[key]\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Trie"
                ],
                "code": "```\\nclass TrieNode:\\n    def __init__(self):\\n        self.children = {}\\n        self.endOfWord = False\\n\\nclass Trie:\\n    def __init__(self):\\n        self.root = TrieNode()\\n    \\n    def insert(self, word):\\n        root = self.root\\n        for ch in word:\\n            if ch not in root.children:\\n                root.children[ch] = TrieNode()\\n            root = root.children[ch]\\n        root.endOfWord = True\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \\'\\'\\n        \\n        trie = Trie()\\n        \\n        for word in strs:\\n            trie.insert(word)\\n            \\n        root = trie.root\\n        res = \\'\\'\\n        while root:\\n            if len(root.children) > 1 or root.endOfWord:\\n                return res\\n            \\n            key = list(root.children)[0]\\n            res += key\\n            \\n            root = root.children[key]\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7177,
                "title": "6-line-c-lightening-fast",
                "content": "    string longestCommonPrefix(vector<string>& strs) {\\n            if (strs.size()==0) return \"\";\\n            for (int i=0; i<strs[0].length(); i++)\\n                for (int j=0; j<strs.size(); j++)\\n                    if ( !(i<strs[j].length() && strs[0][i]==strs[j][i]) )\\n                        return strs[0].substr(0, i);\\n            return strs[0];\\n        }",
                "solutionTags": [],
                "code": "    string longestCommonPrefix(vector<string>& strs) {\\n            if (strs.size()==0) return \"\";\\n            for (int i=0; i<strs[0].length(); i++)\\n                for (int j=0; j<strs.size(); j++)\\n                    if ( !(i<strs[j].length() && strs[0][i]==strs[j][i]) )\\n                        return strs[0].substr(0, i);\\n            return strs[0];\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3914585,
                "title": "c-beginner-friendly-beats-100-of-c-users",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWhen you sort an array, it is enough to check for the common characters of the the first & last string of the sorted vector.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) \\n    {\\n        sort(str.begin(), str.end()); //sorting the array\\n        string ans=\"\"; //creating a new empty string to store the common prefixes\\n        for(int i=0;i<str[0].length();i++) // max iterations = length of the first string\\n        {\\n            if(str[0][i]!=str[str.size()-1][i]) // checking the characters of the first and last string\\n                break;\\n            ans+=str[0][i]; // concatinate if the characters are matching\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2745752,
                "title": "python-short-simple",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        shortest = min(strs,key=len)\\n        for i, ch in enumerate(shortest):\\n            for other in strs:\\n                if other[i] != ch:\\n                    return shortest[:i]\\n        return shortest \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330097,
                "title": "c-java-python3-javascript-solution-explanation",
                "content": "**Which have included C#, Java, Python3,JavaScript solutions**\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)\\u2B50**\\n\\n\\n#### Example : Java Code \\u27A1 Runtime : 1ms\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```\\n**You can find a faster Java solution in the link.**\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n**\\uD83E\\uDDE1See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1982614,
                "title": "kotlin-o-s-4-lines",
                "content": "```\\nclass Solution {\\n    fun longestCommonPrefix(strs: Array<String>): String {\\n        val w = strs[0]\\n        w.forEachIndexed { i, c ->\\n            if (strs.any { it.length == i || it[i] != c } ) return w.substring(0, i)\\n        }\\n        return w\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun longestCommonPrefix(strs: Array<String>): String {\\n        val w = strs[0]\\n        w.forEachIndexed { i, c ->\\n            if (strs.any { it.length == i || it[i] != c } ) return w.substring(0, i)\\n        }\\n        return w\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1888715,
                "title": "100-fastest-typescript-solution",
                "content": "```\\nfunction longestCommonPrefix(strings: string[]): string {\\n  if (strings.length === 0) { return \"\" }\\n  if (strings.length === 1) { return strings[0] }\\n  let possiblePrefix = \"\"\\n  \\n  while (strings.every((str) => str.startsWith(possiblePrefix))) {\\n    const newPossiblePrefix = strings[0].substr(0, possiblePrefix.length + 1)\\n\\n    if (newPossiblePrefix.length > possiblePrefix.length) {\\n      possiblePrefix = newPossiblePrefix\\n    } else if (newPossiblePrefix.length === possiblePrefix.length) {\\n      return possiblePrefix\\n    } else { break }\\n  }\\n\\n  return possiblePrefix.slice(0, -1)\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nfunction longestCommonPrefix(strings: string[]): string {\\n  if (strings.length === 0) { return \"\" }\\n  if (strings.length === 1) { return strings[0] }\\n  let possiblePrefix = \"\"\\n  \\n  while (strings.every((str) => str.startsWith(possiblePrefix))) {\\n    const newPossiblePrefix = strings[0].substr(0, possiblePrefix.length + 1)\\n\\n    if (newPossiblePrefix.length > possiblePrefix.length) {\\n      possiblePrefix = newPossiblePrefix\\n    } else if (newPossiblePrefix.length === possiblePrefix.length) {\\n      return possiblePrefix\\n    } else { break }\\n  }\\n\\n  return possiblePrefix.slice(0, -1)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1678669,
                "title": "easy-and-optimized-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        int n = str.size();\\n        string ans  = \"\";\\n        sort(begin(str), end(str));\\n        string a = str[0];\\n        string b = str[n-1];\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]) ans = ans + a[i];\\n            else break;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& str) {\\n        int n = str.size();\\n        string ans  = \"\";\\n        sort(begin(str), end(str));\\n        string a = str[0];\\n        string b = str[n-1];\\n        for(int i=0; i<a.size(); i++){\\n            if(a[i]==b[i]) ans = ans + a[i];\\n            else break;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174581,
                "title": "0ms-faster-than-100-longest-common-prefix-java-soln",
                "content": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0) return \"\";\\n        String prefix = strs[0];\\n        for(int i=1; i< strs.length; i++ ) {\\n            while(strs[i].indexOf(prefix) != 0) {\\n                prefix = prefix.substring(0, prefix.length()-1);\\n            }\\n        }\\n        \\n        return prefix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0) return \"\";\\n        String prefix = strs[0];\\n        for(int i=1; i< strs.length; i++ ) {\\n            while(strs[i].indexOf(prefix) != 0) {\\n                prefix = prefix.substring(0, prefix.length()-1);\\n            }\\n        }\\n        \\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702828,
                "title": "easy-js-solution",
                "content": "```\\nvar longestCommonPrefix = function(arr) {\\n    if (!arr.length) return \"\";\\n    let prefix = \"\";\\n    for (let i = 0; i < arr[0].length; i++) {\\n        for (let j = 0; j < arr.length-1; j++) {\\n            if (arr[j][i] !== arr[j+1][i]) return prefix;\\n        }\\n        prefix += arr[0][i];\\n    }\\n    return prefix;\\n    // Time Complexity: O(M*N), M = length of shortest word, N = length of given array\\n    // Space Complexity: O(1)\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function(arr) {\\n    if (!arr.length) return \"\";\\n    let prefix = \"\";\\n    for (let i = 0; i < arr[0].length; i++) {\\n        for (let j = 0; j < arr.length-1; j++) {\\n            if (arr[j][i] !== arr[j+1][i]) return prefix;\\n        }\\n        prefix += arr[0][i];\\n    }\\n    return prefix;\\n    // Time Complexity: O(M*N), M = length of shortest word, N = length of given array\\n    // Space Complexity: O(1)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 7004,
                "title": "my-2ms-java-solution-may-help-u",
                "content": "    public class Solution {\\n        public String longestCommonPrefix(String[] strs) {\\n            int len = strs.length;\\n    \\t\\tif (len == 0)\\n    \\t\\t\\treturn \"\";\\n    \\t\\tint minlen = 0x7fffffff;\\n    \\t\\tfor (int i = 0; i < len; ++i) \\n    \\t\\t\\tminlen = Math.min(minlen, strs[i].length());\\n    \\t\\tfor (int j = 0; j < minlen; ++j) \\n    \\t\\t\\tfor (int i = 1; i < len; ++i) \\n    \\t\\t\\t\\tif (strs[0].charAt(j) != strs[i].charAt(j)) \\n    \\t\\t\\t\\t\\treturn strs[0].substring(0, j);\\n    \\t\\treturn strs[0].substring(0, minlen);\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public String longestCommonPrefix(String[] strs) {\\n            int len = strs.length;\\n    \\t\\tif (len == 0)\\n    \\t\\t\\treturn \"\";\\n    \\t\\tint minlen = 0x7fffffff;\\n    \\t\\tfor (int i = 0; i < len; ++i) \\n    \\t\\t\\tminlen = Math.min(minlen, strs[i].length());\\n    \\t\\tfor (int j = 0; j < minlen; ++j) \\n    \\t\\t\\tfor (int i = 1; i < len; ++i) \\n    \\t\\t\\t\\tif (strs[0].charAt(j) != strs[i].charAt(j)) \\n    \\t\\t\\t\\t\\treturn strs[0].substring(0, j);\\n    \\t\\treturn strs[0].substring(0, minlen);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 7240,
                "title": "short-accepted-cpp-solution",
                "content": "     string longestCommonPrefix(vector<string> &strs) {\\n            string prefix = \"\";\\n            if(strs.empty()) return prefix;\\n            for(int j = 0; j < strs[0].length(); ++j)\\n            {\\n                for(int i = 1; i < strs.size(); ++i){\\n                    if(j >= strs[i].size() || strs[i][j] != strs[0][j])\\n                       return prefix;\\n                }\\n                prefix += strs[0][j];\\n            }\\n            return prefix;\\n        }",
                "solutionTags": [
                    "C++"
                ],
                "code": "     string longestCommonPrefix(vector<string> &strs) {\\n            string prefix = \"\";\\n            if(strs.empty()) return prefix;\\n            for(int j = 0; j < strs[0].length(); ++j)\\n            {\\n                for(int i = 1; i < strs.size(); ++i){\\n                    if(j >= strs[i].size() || strs[i][j] != strs[0][j])\\n                       return prefix;\\n                }\\n                prefix += strs[0][j];\\n            }\\n            return prefix;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3946986,
                "title": "java-runtime-1-ms-beats-82-61",
                "content": "# Intuition\\nMy initial thoughts on solving this problem involve finding the longest common prefix among a given array of strings. I plan to sort the array first to bring the strings with the common prefix closer to each other. Then, I will compare the first and last strings in the sorted array to find the common prefix.\\n\\n# Approach\\nI will sort the array of strings to ensure that the strings with the longest common prefix are close to each other. After sorting, I will take the first and last strings and compare their characters one by one until I encounter a mismatch. I will keep track of the count of matching characters to determine the length of the common prefix.\\n\\n# Complexity\\n- Time complexity: O(n * m)\\nHere, \\'n\\' is the number of strings in the array and \\'m\\' is the average length of the strings. Sorting the array takes O(n * log n) time, and then comparing the characters in the common prefix takes O(m) time. Thus, the overall time complexity is O(n * log n + m), which can be approximated as O(n * m).\\n\\n- Space complexity: O(1)\\n  The algorithm uses a constant amount of extra space for variables.\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        int count  = 0;\\n\\n        Arrays.sort(strs);\\n\\n        String start = strs[0];\\n\\n        String end  = strs[strs.length-1];\\n\\n        int i = 0 ;\\n        while (i<start.length() && i<end.length()){\\n\\n            if(start.charAt(i) == end.charAt(i)){\\n\\n                count++;\\n                i++;\\n            }\\n            else {\\n                break;\\n            }\\n\\n\\n        }\\n\\n        return start.substring(0,count);\\n        \\n\\n    }\\n}\\n```\\n![c0504eaf-5fb8-4a1d-a769-833262d1b86e_1674433591.3836212.webp](https://assets.leetcode.com/users/images/8a3b41d1-f0ca-472f-a9f7-8346b34a824e_1693297402.2918687.webp)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        int count  = 0;\\n\\n        Arrays.sort(strs);\\n\\n        String start = strs[0];\\n\\n        String end  = strs[strs.length-1];\\n\\n        int i = 0 ;\\n        while (i<start.length() && i<end.length()){\\n\\n            if(start.charAt(i) == end.charAt(i)){\\n\\n                count++;\\n                i++;\\n            }\\n            else {\\n                break;\\n            }\\n\\n\\n        }\\n\\n        return start.substring(0,count);\\n        \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451292,
                "title": "best-solution-by-java-in-runtime-0ms-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n         if (strs.length == 0){\\n                return \"\";\\n            }\\n\\n            String prefix = strs[0];\\n            int length = prefix.length();\\n\\n        for (int i = 1; i < strs.length; i++) {\\n            while (strs[i].indexOf(prefix) != 0){\\n                prefix = prefix.substring(0 , --length);\\n                if (length == 0){\\n                    return \"\";\\n                }\\n            }\\n            \\n        }\\n\\n        return prefix;\\n    }\\n}\\n```\\n\\n![b0e5afaa-48ec-4dcc-bd96-e39aa7a524f8_1681948924.2890832.png](https://assets.leetcode.com/users/images/7e978d3c-4abb-4d64-bb09-e5dfbf33b86d_1682356180.961795.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n         if (strs.length == 0){\\n                return \"\";\\n            }\\n\\n            String prefix = strs[0];\\n            int length = prefix.length();\\n\\n        for (int i = 1; i < strs.length; i++) {\\n            while (strs[i].indexOf(prefix) != 0){\\n                prefix = prefix.substring(0 , --length);\\n                if (length == 0){\\n                    return \"\";\\n                }\\n            }\\n            \\n        }\\n\\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2684788,
                "title": "java-solution-simple-with-explanation-69-faster-then-other-9-line-code",
                "content": "![image](https://assets.leetcode.com/users/images/aafcadf5-cd6a-4bb6-ac77-7b3e89ffd06e_1665384459.5574121.png)\\n\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String r=\"\";\\n        int n=strs.length;\\n        Arrays.sort(strs);//Sorted first\\n        String s=strs[0];//smallest no of char\\n        String h=strs[n-1];//highest no of char\\n        for(int i =0;i<s.length();i++)//taken smallest length so that run time will be less\\n        {\\n            if(s.charAt(i)!=h.charAt(i)) break;\\n            r=r+s.charAt(i);  \\n        }\\n        return r;  \\n    }\\n}\\n\\n//Time complexity would be O(n)\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String r=\"\";\\n        int n=strs.length;\\n        Arrays.sort(strs);//Sorted first\\n        String s=strs[0];//smallest no of char\\n        String h=strs[n-1];//highest no of char\\n        for(int i =0;i<s.length();i++)//taken smallest length so that run time will be less\\n        {\\n            if(s.charAt(i)!=h.charAt(i)) break;\\n            r=r+s.charAt(i);  \\n        }\\n        return r;  \\n    }\\n}\\n\\n//Time complexity would be O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2266870,
                "title": "c-using-sort",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n=strs.size();\\n        string ans=\"\";\\n        sort(strs.begin(),strs.end());\\n        \\n        string a=strs[0];\\n        string b=strs[n-1];\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]==b[i])\\n            {\\n                ans+=a[i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nUpvote if you find it useful. \\uD83D\\uDE4C",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n=strs.size();\\n        string ans=\"\";\\n        sort(strs.begin(),strs.end());\\n        \\n        string a=strs[0];\\n        string b=strs[n-1];\\n        \\n        for(int i=0;i<a.size();i++)\\n        {\\n            if(a[i]==b[i])\\n            {\\n                ans+=a[i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2264602,
                "title": "python-faster-98",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        ans = \\'\\'\\n        for i,val in enumerate(zip(*strs)):\\n            if len(set(val)) == 1:\\n                ans+= val[0]\\n            else:\\n                break\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        \\n        ans = \\'\\'\\n        for i,val in enumerate(zip(*strs)):\\n            if len(set(val)) == 1:\\n                ans+= val[0]\\n            else:\\n                break\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1726743,
                "title": "c-solution-with-easy-explanations",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Here we find the smallest string and store in `str` & it\\u2019s size to `mn`\\n- We use 2 loops to access all the strings, if any point character of every element in a index doesn\\'t match then we\\u2019ll return string till that index.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        int mn = INT_MAX, count = 0;\\n        string str;\\n        \\n        for(int i=0; i<n; i++){\\n            if(mn > strs[i].size()){\\n                mn = strs[i].size();\\n                str = strs[i];\\n            }\\n        }\\n        \\n        for(int i=0; i<mn; i++){\\n            for(int j=0; j<n; j++){\\n                if(strs[j][i] != str[i])\\n                    return str.substr(0, count);\\n            }\\n            count++;\\n        }\\n        return str.substr(0,count);        \\n    }\\n};**\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n**class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int n = strs.size();\\n        int mn = INT_MAX, count = 0;\\n        string str;\\n        \\n        for(int i=0; i<n; i++){\\n            if(mn > strs[i].size()){\\n                mn = strs[i].size();\\n                str = strs[i];\\n            }\\n        }\\n        \\n        for(int i=0; i<mn; i++){\\n            for(int j=0; j<n; j++){\\n                if(strs[j][i] != str[i])\\n                    return str.substr(0, count);\\n            }\\n            count++;\\n        }\\n        return str.substr(0,count);        \\n    }\\n};**\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404383,
                "title": "python3-short-expressive-and-fast-solution-faster-than-99-73",
                "content": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n      prefix = \\'\\'\\n      for cmbn in zip(*strs):\\n        if len(set(cmbn)) > 1:\\n          break\\n        prefix += cmbn[0]\\n      return prefix\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n      prefix = \\'\\'\\n      for cmbn in zip(*strs):\\n        if len(set(cmbn)) > 1:\\n          break\\n        prefix += cmbn[0]\\n      return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389414,
                "title": "easy-c-solution-4ms",
                "content": "Runtime: 4 ms, faster than 94.85% of C++ online submissions for Longest Common Prefix.\\nMemory Usage: 8.8 MB, less than 87.10% of C++ online submissions for Longest Common Prefix.\\n\\n```\\nstring longestCommonPrefix(vector<string>& strs) {\\n        \\n        if(strs.empty()) return \"\";\\n        \\n        for(int i=0; ; i++)\\n        {\\n            for(auto& s : strs)\\n            {\\n                if(i >= s.size() || s[i] != strs[0][i])\\n                    return strs[0].substr(0,i);\\n            }\\n        }\\n        \\n        return \"\";\\n    }",
                "solutionTags": [],
                "code": "Runtime: 4 ms, faster than 94.85% of C++ online submissions for Longest Common Prefix.\\nMemory Usage: 8.8 MB, less than 87.10% of C++ online submissions for Longest Common Prefix.\\n\\n```\\nstring longestCommonPrefix(vector<string>& strs) {\\n        \\n        if(strs.empty()) return \"\";\\n        \\n        for(int i=0; ; i++)\\n        {\\n            for(auto& s : strs)\\n            {\\n                if(i >= s.size() || s[i] != strs[0][i])\\n                    return strs[0].substr(0,i);\\n            }\\n        }\\n        \\n        return \"\";\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 164655,
                "title": "javascript-solution",
                "content": "```\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs[0]) return \"\";\\n    let res = \"\";\\n    let cur = \"\";\\n    let i = 0;\\n    while(i < strs[0].length){\\n        cur = strs[0].substring(0, i + 1);\\n        let flag = strs.every(x => {\\n            return x.startsWith(cur);\\n        })\\n        if(flag === true){\\n            res = cur;\\n        }\\n        else break;\\n        i ++;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs[0]) return \"\";\\n    let res = \"\";\\n    let cur = \"\";\\n    let i = 0;\\n    while(i < strs[0].length){\\n        cur = strs[0].substring(0, i + 1);\\n        let flag = strs.every(x => {\\n            return x.startsWith(cur);\\n        })\\n        if(flag === true){\\n            res = cur;\\n        }\\n        else break;\\n        i ++;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6934,
                "title": "simple-python-sol-32-ms",
                "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        result = \"\"       \\n        for n in zip(*strs):\\n            if len(set(n)) == 1:\\n                result += n[0]\\n            else:\\n                return result\\n        return result  \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        result = \"\"       \\n        for n in zip(*strs):\\n            if len(set(n)) == 1:\\n                result += n[0]\\n            else:\\n                return result\\n        return result  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3825300,
                "title": "most-easy-javascript-solution-beat-96",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs.length) return \\'\\'\\n    let longerstCommonPrefix = \\'\\'\\n    for(let i=0; i< strs[0].length; i++) {\\n        let char = strs[0][i]\\n        if(!char) return \\'\\'\\n        if(strs.every(str => str[i] === char)) {\\n            longerstCommonPrefix+=char\\n        } else break\\n    }\\n    return longerstCommonPrefix\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    if(!strs.length) return \\'\\'\\n    let longerstCommonPrefix = \\'\\'\\n    for(let i=0; i< strs[0].length; i++) {\\n        let char = strs[0][i]\\n        if(!char) return \\'\\'\\n        if(strs.every(str => str[i] === char)) {\\n            longerstCommonPrefix+=char\\n        } else break\\n    }\\n    return longerstCommonPrefix\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3386001,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity: O(S * n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n\\n        String prefix = strs[0];\\n\\n        for (int i = 1; i < strs.length; i++) {\\n            while (!strs[i].startsWith(prefix)) {\\n                prefix = prefix.substring(0, prefix.length() - 1);\\n                if (prefix.isEmpty()) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n\\n        return prefix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if (strs == null || strs.length == 0) {\\n            return \"\";\\n        }\\n\\n        String prefix = strs[0];\\n\\n        for (int i = 1; i < strs.length; i++) {\\n            while (!strs[i].startsWith(prefix)) {\\n                prefix = prefix.substring(0, prefix.length() - 1);\\n                if (prefix.isEmpty()) {\\n                    return \"\";\\n                }\\n            }\\n        }\\n\\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359811,
                "title": "simple-go-solution",
                "content": "# Code\\n```\\nfunc longestCommonPrefix(s []string) string {\\n\\tpref := s[0]\\n\\tfor i := 1; i < len(s); i++ {\\n\\t\\tfor !strings.HasPrefix(s[i], pref) {\\n\\t\\t\\tpref = pref[:len(pref)-1]\\n\\t\\t}\\n\\t\\tfmt.Println(s[i])\\n\\t}\\n\\treturn pref\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc longestCommonPrefix(s []string) string {\\n\\tpref := s[0]\\n\\tfor i := 1; i < len(s); i++ {\\n\\t\\tfor !strings.HasPrefix(s[i], pref) {\\n\\t\\t\\tpref = pref[:len(pref)-1]\\n\\t\\t}\\n\\t\\tfmt.Println(s[i])\\n\\t}\\n\\treturn pref\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2269966,
                "title": "java-better-than-100",
                "content": "An upvote would be appreciated, Thank you!\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0)\\n        {\\n            return \"\";\\n        }\\n        String prefix=strs[0];\\n        for(int i=1;i<strs.length;i++)\\n        {\\n            while(strs[i].indexOf(prefix)!=0)\\n            {\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0)\\n        {\\n            return \"\";\\n        }\\n        String prefix=strs[0];\\n        for(int i=1;i<strs.length;i++)\\n        {\\n            while(strs[i].indexOf(prefix)!=0)\\n            {\\n                prefix=prefix.substring(0,prefix.length()-1);\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141240,
                "title": "c-java-python3-solution-explanation",
                "content": "Here\\'s my blog written on 2022/06/12\\nWhich have include C#, Java, Python3 (JavaScript version will be updated in few days)\\n\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)\\u2B50\\n\\n#### Example : Java Code \\u27A1 Runtime : 1ms\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```\\n**You can find a faster solution in the link.**\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1899592,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        guard strs.count > 0 else { return \"\" }\\n        let chars_array = strs.map({ Array($0) })\\n        var string = \"\"\\n        var i = 0\\n        \\n        while true {\\n            var c: Character? = nil\\n            for chars in chars_array {\\n                if i >= chars.count {\\n                    return string\\n                } else {\\n                    if c == nil {\\n                        c = chars[i]\\n                    } else if chars[i] != c! { return string }\\n                }  \\n            }\\n            string += String(c!)\\n            i += 1\\n        }\\n        \\n        return string\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func longestCommonPrefix(_ strs: [String]) -> String {\\n        guard strs.count > 0 else { return \"\" }\\n        let chars_array = strs.map({ Array($0) })\\n        var string = \"\"\\n        var i = 0\\n        \\n        while true {\\n            var c: Character? = nil\\n            for chars in chars_array {\\n                if i >= chars.count {\\n                    return string\\n                } else {\\n                    if c == nil {\\n                        c = chars[i]\\n                    } else if chars[i] != c! { return string }\\n                }  \\n            }\\n            string += String(c!)\\n            i += 1\\n        }\\n        \\n        return string\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1751555,
                "title": "js-easy-clean-solution",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    let firstStr = strs[0];\\n    for (let i = 0; i < firstStr.length; i++) {\\n        for (let s of strs) {\\n            if (s[i] !== firstStr[i]) return s.slice(0, i);\\n        }\\n    }\\n    return strs[0];\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    let firstStr = strs[0];\\n    for (let i = 0; i < firstStr.length; i++) {\\n        for (let s of strs) {\\n            if (s[i] !== firstStr[i]) return s.slice(0, i);\\n        }\\n    }\\n    return strs[0];\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 773126,
                "title": "python-sol-by-column-wise-slicing-w-comment",
                "content": "Python sol by column-wise slicing\\n\\n---\\n\\n**Implementation**:\\n\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n\\t\\t\\n\\t\\t# generate column-wise slicing\\n        column_slices, common_prefix = zip(*strs), \\'\\'\\n        \\n        for current_column in column_slices:\\n            \\n            if len(set(current_column)) == 1:\\n\\t\\t\\t\\t# current column-wise slice\\'s character is the same\\n\\t\\t\\t\\t# update common prefix\\n                common_prefix += current_column[0]\\n            \\n            else:\\n\\t\\t\\t\\t# current column-wise slice\\'s character is different\\n                break\\n                \\n        return common_prefix\\n```\\n\\n---\\n\\n**Demo of zip(...)**, auto-align on length:\\n\\n![image](https://assets.leetcode.com/users/images/214b59f5-7200-435b-a974-1555668c69d5_1596559716.3218155.png)\\n\\n\\n\\n---\\n\\nReference:\\n\\n[1] [Python official docs about zip( ... )](https://docs.python.org/3.3/library/functions.html#zip)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n\\t\\t\\n\\t\\t# generate column-wise slicing\\n        column_slices, common_prefix = zip(*strs), \\'\\'\\n        \\n        for current_column in column_slices:\\n            \\n            if len(set(current_column)) == 1:\\n\\t\\t\\t\\t# current column-wise slice\\'s character is the same\\n\\t\\t\\t\\t# update common prefix\\n                common_prefix += current_column[0]\\n            \\n            else:\\n\\t\\t\\t\\t# current column-wise slice\\'s character is different\\n                break\\n                \\n        return common_prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291314,
                "title": "ruby-solution",
                "content": "Take a base string (the first element in the array). Go through the the base string, and through each iteration check if the letter at index `i` exists in all the other words in the array. If it does, append it to the string `s`. If you reach a case where the letter at index `i` does not exist in some word in the array, break. \\n```\\ndef longest_common_prefix(strs)\\n    return \"\" if strs.empty? \\n    s = \"\"\\n    base = strs[0]\\n    for i in 0..base.length-1\\n        if strs.all?{|x| x[i] == base[i]}\\n            s += base[i]\\n        else\\n            break\\n        end\\n    end\\n    s\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef longest_common_prefix(strs)\\n    return \"\" if strs.empty? \\n    s = \"\"\\n    base = strs[0]\\n    for i in 0..base.length-1\\n        if strs.all?{|x| x[i] == base[i]}\\n            s += base[i]\\n        else\\n            break\\n        end\\n    end\\n    s\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 229160,
                "title": "python-7-lines-20ms-solution",
                "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        s = \\'\\'\\n        for i in zip(*strs):\\n            if len(set(i)) != 1:\\n                return s\\n            else:\\n                s += i[0]\\n        return s\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        s = \\'\\'\\n        for i in zip(*strs):\\n            if len(set(i)) != 1:\\n                return s\\n            else:\\n                s += i[0]\\n        return s\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 7066,
                "title": "my-simple-and-clean-c-code-solution",
                "content": "```   \\n string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        string res = strs[0];\\n        for(int i=0; i<strs.size();i++)\\n            for(int j=0; j<res.size();j++)\\n                if(strs[i][j]!=res[j]) {res.resize(j); break;}\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```   \\n string longestCommonPrefix(vector<string>& strs) {\\n        if(strs.empty()) return \"\";\\n        string res = strs[0];\\n        for(int i=0; i<strs.size();i++)\\n            for(int j=0; j<res.size();j++)\\n                if(strs[i][j]!=res[j]) {res.resize(j); break;}\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 6968,
                "title": "simple-python-solution-using-min",
                "content": "    class Solution(object):\\n        def longestCommonPrefix(self, strs):\\n            if not strs: return ''\\n            first = min(strs)\\n            for i in range(len(first)):\\n                for s in strs:\\n                    if s[i] != first[i]:\\n                        return first[:i] if i > 0 else ''\\n            return first",
                "solutionTags": [],
                "code": "    class Solution(object):\\n        def longestCommonPrefix(self, strs):\\n            if not strs: return ''\\n            first = min(strs)\\n            for i in range(len(first)):\\n                for s in strs:\\n                    if s[i] != first[i]:\\n                        return first[:i] if i > 0 else ''\\n            return first",
                "codeTag": "Java"
            },
            {
                "id": 4062081,
                "title": "video-step-by-step-visualization-of-vertical-scanning-strategy",
                "content": "https://youtube.com/watch?v=SiNDN2M4dtQ\\n\\nThis solution is the <b>vertical scanning</b> approach that is discussed in the official solution, slightly modified for Python.  The idea is to scan the the first character of every word, then the second character, etc. until a mismatch is found.  At that point, we return a slice of the string which is the longest common prefix.\\n\\nThis is superior to horizontal scanning because even if a very short word is included in the array, the algorithm won\\'t do any extra work scanning the longer words and will still end when the end of the shortest word is reached.\\n\\n# Code\\n```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"\\n\\n        base = strs[0]\\n        for i in range(len(base)):\\n            for word in strs[1:]:\\n                if i == len(word) or word[i] != base[i]:\\n                    return base[0:i]\\n\\n        return base\\n  \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String"
                ],
                "code": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        if len(strs) == 0:\\n            return \"\"\\n\\n        base = strs[0]\\n        for i in range(len(base)):\\n            for word in strs[1:]:\\n                if i == len(word) or word[i] != base[i]:\\n                    return base[0:i]\\n\\n        return base\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010931,
                "title": "5-liner-easy-approach-with-explaination",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Firstly I was very confused about the problem because I have ignored the word \"prefix\". Prefix means the starting letters of the word. \\n- So if the starting letter of any word in the array will not be matched then we will simply return empty string and if first word will be matched in the every array of strings using every method then we will look for the second word ans so on..\\n\\n# Code\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function (strs) {\\n    let output = \"\";\\n    for (let i = 0; i < strs[0].length; i++) {\\n        if(strs.every(str => str[i] === strs[0][i])) output += strs[0][i];\\n        else break;\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function (strs) {\\n    let output = \"\";\\n    for (let i = 0; i < strs[0].length; i++) {\\n        if(strs.every(str => str[i] === strs[0][i])) output += strs[0][i];\\n        else break;\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3302948,
                "title": "c-solution-easy-to-understand-100-fast",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n       string ans=\"\";\\n        vector<int>len;     //To store the length of every string present in the vector;\\n        int row=strs.size();  //size of row;\\n        for(int i=0;i<rows;i++)\\n        {\\n             len.emplace_back(strs[i].length()); \\n        }\\n        sort(len.begin(),len.end());  //Sort the len vector to find the minimum size;\\n        int col=len[0];   //Store the minimum size in column ;\\n        bool flag=true;\\n        for(int i=0;i<col;i++)\\n        { //column wise traversal\\n            for(int j=1;j<row;j++)\\n            {\\n                //Check every element in the column if it is equal to its next element or not\\n            \\n                if(strs[j-1][i]!=strs[j][i]){  \\n                    //If elements are not equal then make flag = false and break the loop   \\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag==true) \\n             count++; //This will store the numbers of column which are equal\\n        }\\n\\n         ans=strs[0].substr(0,count); //take the substring(of size equal to count) from any string present in strs vector;\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n       string ans=\"\";\\n        vector<int>len;     //To store the length of every string present in the vector;\\n        int row=strs.size();  //size of row;\\n        for(int i=0;i<rows;i++)\\n        {\\n             len.emplace_back(strs[i].length()); \\n        }\\n        sort(len.begin(),len.end());  //Sort the len vector to find the minimum size;\\n        int col=len[0];   //Store the minimum size in column ;\\n        bool flag=true;\\n        for(int i=0;i<col;i++)\\n        { //column wise traversal\\n            for(int j=1;j<row;j++)\\n            {\\n                //Check every element in the column if it is equal to its next element or not\\n            \\n                if(strs[j-1][i]!=strs[j][i]){  \\n                    //If elements are not equal then make flag = false and break the loop   \\n                    flag=false;\\n                    break;\\n                }\\n            }\\n            if(flag==true) \\n             count++; //This will store the numbers of column which are equal\\n        }\\n\\n         ans=strs[0].substr(0,count); //take the substring(of size equal to count) from any string present in strs vector;\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459950,
                "title": "python-85-fast-88-less-space-easy-to-understand",
                "content": "Upvote if it helped. Thanks\\n\\n![image](https://assets.leetcode.com/users/images/f1fd820f-92fe-4d2c-8adf-bb3757ca241f_1661100206.6040626.png)\\n\\n\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        prefix = \"\"\\n\\t\\t\\n\\t\\t#here zip function creates tuples of all the characters of the string index wise. \\n\\t\\t# s= ((\\'f\\',\\'f\\',\\'f\\'), (\\'l\\', \\'l\\', \\'l\\') ........)\\n\\t\\t\\n        s = zip(*strs)\\n        for i in s:\\n            if len(set(i)) ==1 :\\n                prefix += i[0]\\n            else:\\n                break\\n        return prefix\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        prefix = \"\"\\n\\t\\t\\n\\t\\t#here zip function creates tuples of all the characters of the string index wise. \\n\\t\\t# s= ((\\'f\\',\\'f\\',\\'f\\'), (\\'l\\', \\'l\\', \\'l\\') ........)\\n\\t\\t\\n        s = zip(*strs)\\n        for i in s:\\n            if len(set(i)) ==1 :\\n                prefix += i[0]\\n            else:\\n                break\\n        return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2344186,
                "title": "most-optimal-solution-in-java",
                "content": "Easy code for all to understand.\\n\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0){\\n            return \"\";\\n        }\\n        String prefix = strs[0];\\n        for(String s : strs){\\n            int len = Math.min(prefix.length(), s.length());\\n            for(int i = len; i >= 0; i--){\\n                if(prefix.indexOf(s.substring(0, i)) == 0){\\n                    prefix = s.substring(0, i);\\n                    break;\\n                }\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        if(strs.length == 0){\\n            return \"\";\\n        }\\n        String prefix = strs[0];\\n        for(String s : strs){\\n            int len = Math.min(prefix.length(), s.length());\\n            for(int i = len; i >= 0; i--){\\n                if(prefix.indexOf(s.substring(0, i)) == 0){\\n                    prefix = s.substring(0, i);\\n                    break;\\n                }\\n            }\\n        }\\n        return prefix;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2244027,
                "title": "c-java-python3-javascript-solution-easy-code",
                "content": "**Which have included C#, Java, Python3,JavaScript solutions**\\n**\\u2B50[https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/](https://zyrastory.com/en/coding-en/leetcode-en/leetcode-14-longest-common-prefix-solution-and-explanation-en/)\\u2B50**\\n\\n\\n#### Example : Java Code \\u27A1 Runtime : 1ms\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```\\n**You can find a faster Java solution in the link.**\\n\\n\\nIf you got any problem about the explanation or you need other programming language solution, please feel free to leave your comment.\\n\\n**See more LeetCode solution : [Zyrastory - LeetCode Solution](https://zyrastory.com/en/category/coding-en/leetcode-en/)**",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        for (int i = 0; i < strs[0].length(); i++) \\n        {\\n            char tmpChar = strs[0].charAt(i); \\n            for (int j = 0; j < strs.length; j++) \\n            {\\n                if (strs[j].length() == i || strs[j].charAt(i) != tmpChar) \\n                {\\n                    return strs[0].substring(0, i);\\n                }\\n            }\\n        }\\n        return strs[0]; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2241147,
                "title": "c-easy-simple-o-n-min-and-max-element",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n                \\n        string min=*min_element(strs.begin(),strs.end());  //smallest string\\n        string mx=*max_element(strs.begin(),strs.end()); //largest one\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(i<min.size() and min[i]==mx[j]) {   //loop until characters are matching\\n            i++;\\n            j++;\\n        }\\n        return mx.substr(0,i);    //return substring till any index i or j answer will be same\\n    }\\n};\\n\\nif(helpful)\\n\\tupVote();",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n                \\n        string min=*min_element(strs.begin(),strs.end());  //smallest string\\n        string mx=*max_element(strs.begin(),strs.end()); //largest one\\n        \\n        int i=0;\\n        int j=0;\\n        \\n        while(i<min.size() and min[i]==mx[j]) {   //loop until characters are matching\\n            i++;\\n            j++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2204347,
                "title": "simple-javascript-solution-97-36-fast-with-95-67-less-memory-usage",
                "content": "![image](https://assets.leetcode.com/users/images/d638b758-4379-497b-a8a5-3b3843d0dcfe_1656320626.4312003.png)\\n\\n```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n  if(strs.length === 1) return strs[0];\\n  \\n  strs.sort();\\n\\n  const strLastIndex = strs.length - 1;\\n  if(strs[0] === strs[strLastIndex]) return strs[0];\\n  \\n  let prefix = \"\";\\n  for(let i=0; i < strs[0].length; i++) {\\n    if(strs[0][i] === strs[strLastIndex][i]) {\\n      prefix += strs[0][i];\\n    } else {\\n      return prefix;\\n    }\\n  }\\n  \\n  return prefix;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n  if(strs.length === 1) return strs[0];\\n  \\n  strs.sort();\\n\\n  const strLastIndex = strs.length - 1;\\n  if(strs[0] === strs[strLastIndex]) return strs[0];\\n  \\n  let prefix = \"\";\\n  for(let i=0; i < strs[0].length; i++) {\\n    if(strs[0][i] === strs[strLastIndex][i]) {\\n      prefix += strs[0][i];\\n    } else {\\n      return prefix;\\n    }\\n  }\\n  \\n  return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2019053,
                "title": "python-simplest-solution-in-o-nlog-n",
                "content": "Time: Avg case: O(nlog(n)) ; Worst case: O(mnlog(n)) [when all strings are of same size]; n: length of array; m: length of smallest string [Do correct me if I am wrong.]\\nSpace: O(1) on average; O(m) in worst case when all strings are same.; m: length of smallest string\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort()\\n        pre = []\\n        \\n        for a,b in zip(strs[0], strs[-1]):\\n            if a == b:\\n                pre.append(a)\\n            else:\\n                break\\n        \\n        return \"\".join(pre)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        strs.sort()\\n        pre = []\\n        \\n        for a,b in zip(strs[0], strs[-1]):\\n            if a == b:\\n                pre.append(a)\\n            else:\\n                break\\n        \\n        return \"\".join(pre)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1995677,
                "title": "c-100-faster-solution-explained",
                "content": "# C++ 100% Faster Solution Explained\\nWrite a function to find the longest common prefix string amongst an array of strings.\\nIf there is no common prefix, return an empty string \"\".\\n## Ex:\\n\\n\\tInput: strs = [\"flower\",\"flow\",\"flight\"]\\n\\tOutput: \"fl\"\\n\\n## Solution Logic:\\nThe coding for this solution is easy using the <b><a href=\"https://www.cplusplus.com/doc/tutorial/control/\">For Loop</a></b> to handle iteration. When we focus on the logic behind this problem, we must remember to account for all possible versions of the intput and how to deal with it:\\n### Iterating through everything - For Loops\\n<li>The <b>given vector has an undefined amount of elements</b>, and we must compare them all - therefore we cannot hardcode x number of comparisions between x number of strings\\n<li>We <b>only need to iterate to the end of one word</b> because <b>all words</b> must be equal - so if one word reaches the end, it cannot possibly be the same as the rest beyond its length\\n<li>Make sure the for-loops incase everything. <b>We must first iterate over the length of a string, then over the size of the vector</b> for desired results. Otherwise, if we swap the loops, the program will stop comparing the characters of the strings at the position equal to the length of the vector. EG: if we receive 3 strings of 10 letters each, the program will only compare the first 3 letters of each string rather than the entire string.\\n<br></br>\\n\\n### How to Tell When We Found the Largest Prefix - If Statement\\n<li>We reach a <b>position where the character</b> at that position in every given string <b>is not the same</b>\\n<li>We <b>reach the end of any string</b> - as anything beyond it does not exist to be the same as other strings\\n<br></br>\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring longestCommonPrefix(vector<string>& strs) {\\n\\t\\t\\t//pos keeps track of the end of the common prefix, starts at 0 since its a prefix\\n\\t\\t\\tfor(int pos = 0; pos < strs[0].length(); ++pos) //iterates over the length of the first word\\n\\t\\t\\t\\tfor(int i = 1; i < strs.size(); ++i) //for all of the strings in the vector\\n\\t\\t\\t\\t\\t//compare each char of the first string to the char at the same pos in each following string\\n\\t\\t\\t\\t\\t//if we reach the end of any string or a pos where the chars do not match, we have the largest prefix\\n\\t\\t\\t\\t\\tif(pos == strs[i].length() || strs[i][pos] != strs[0][pos])\\n\\t\\t\\t\\t\\t\\treturn strs[0].substr(0, pos);\\n\\t\\t\\treturn strs[0];\\n\\t\\t}\\n\\t};\\n\\t\\nIf there\\'s anyway to explain this better please let my pea brain know thanks. If this helped and you have a moment, <b>please upvote so my professor knows I did my homework</b>. Thanks.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring longestCommonPrefix(vector<string>& strs) {\\n\\t\\t\\t//pos keeps track of the end of the common prefix, starts at 0 since its a prefix\\n\\t\\t\\tfor(int pos = 0; pos < strs[0].length(); ++pos) //iterates over the length of the first word\\n\\t\\t\\t\\tfor(int i = 1; i < strs.size(); ++i) //for all of the strings in the vector\\n\\t\\t\\t\\t\\t//compare each char of the first string to the char at the same pos in each following string\\n\\t\\t\\t\\t\\t//if we reach the end of any string or a pos where the chars do not match, we have the largest prefix\\n\\t\\t\\t\\t\\tif(pos == strs[i].length() || strs[i][pos] != strs[0][pos])\\n\\t\\t\\t\\t\\t\\treturn strs[0].substr(0, pos);\\n\\t\\t\\treturn strs[0];\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1663118,
                "title": "javascript-simple-solution-using-every-function",
                "content": "```\\nvar longestCommonPrefix = function(strs) {\\n    let prefix = \\'\\';\\n    \\n    for (let i = 0; i <= strs[0].length; i++) {\\n        const nextPrefix = strs[0].slice(0, i);\\n        \\n        if (strs.every(str => str.slice(0, i) === nextPrefix)) {\\n            prefix = nextPrefix;\\n        } else {\\n            break;\\n        }\\n    }\\n    \\n    return prefix;\\n};\\n```\\n\\nThe idea is to slice strings char by char, and using the `.every()` function to compare if each inputed strings have the same slices.\\n\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar longestCommonPrefix = function(strs) {\\n    let prefix = \\'\\';\\n    \\n    for (let i = 0; i <= strs[0].length; i++) {\\n        const nextPrefix = strs[0].slice(0, i);\\n        \\n        if (strs.every(str => str.slice(0, i) === nextPrefix)) {\\n            prefix = nextPrefix;\\n        } else {\\n            break;\\n        }\\n    }\\n    \\n    return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1585205,
                "title": "c-short-simple-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string prefix = \"\";\\n        for(int i=0;i<strs[0].size();++i){\\n            for(int j=1;j<strs.size();++j){\\n                if(strs[j][i]!=strs[0][i]) return prefix;\\n            }\\n              prefix+=strs[0][i];\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string prefix = \"\";\\n        for(int i=0;i<strs[0].size();++i){\\n            for(int j=1;j<strs.size();++j){\\n                if(strs[j][i]!=strs[0][i]) return prefix;\\n            }\\n              prefix+=strs[0][i];\\n        }\\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410235,
                "title": "javascript-simple-solution",
                "content": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    let prefix = \\'\\';\\n    if (strs.length === 1) return strs[0];\\n    for (let i = 0; i < strs[0].length; i++) {\\n        let currentChar = strs[0][i];\\n        if (currentChar && strs.every((s) => s[i] == currentChar)) {\\n            prefix += currentChar;\\n        } else {\\n            return prefix;\\n        }\\n    }\\n    \\n    return prefix;\\n};\\n```\\n\\nStats:\\nRuntime: 72 ms, faster than 90.42% of JavaScript online submissions for Longest Common Prefix.\\nMemory Usage: 40.4 MB, less than 41.53% of JavaScript online submissions for Longest Common Prefix.",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string[]} strs\\n * @return {string}\\n */\\nvar longestCommonPrefix = function(strs) {\\n    let prefix = \\'\\';\\n    if (strs.length === 1) return strs[0];\\n    for (let i = 0; i < strs[0].length; i++) {\\n        let currentChar = strs[0][i];\\n        if (currentChar && strs.every((s) => s[i] == currentChar)) {\\n            prefix += currentChar;\\n        } else {\\n            return prefix;\\n        }\\n    }\\n    \\n    return prefix;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 936274,
                "title": "c-detailed-explanation-for-longest-common-prefix",
                "content": "```class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.size() == 0) {\\n            return \"\";\\n        }\\n        \\n        // First let\\'s assume that the entire first string\\n        // is the common prefix.\\n        //\\n        std::string prefix = strs[0];\\n        \\n        // Now we iterate through the list of strings, and \\n        // for each string, we see how much of it matches with\\n        // our prefix. The size of the prefix keeps decreasing.\\n        //\\n        for(int i = 1; i < strs.size(); ++i) {\\n            // As long as you don\\'t find the prefix, keep decreasing\\n            // it\\'s size.\\n            //\\n            while(strs[i].find(prefix) != 0) {\\n                prefix = prefix.substr(0, prefix.length() - 1);\\n            }\\n            if(prefix.length() == 0) return \"\";\\n        }\\n        \\n        return prefix;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.size() == 0) {\\n            return \"\";\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 795155,
                "title": "simple-o-nlogn-solution-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int n=strs.size();\\n        string ans=\"\";\\n        if(n==0)\\n            return ans;\\n        vector<string> k=strs;\\n        sort(k.begin(),k.end());\\n        string one=k[0],two=k[n-1];\\n        int i=0,j=0;\\n        int x=one.length();\\n        int y=two.length();\\n        for(;i<x and j<y;i++,j++)\\n        {\\n            if(one[i]!=two[j])\\n                break;\\n            ans+=one[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int n=strs.size();\\n        string ans=\"\";\\n        if(n==0)\\n            return ans;\\n        vector<string> k=strs;\\n        sort(k.begin(),k.end());\\n        string one=k[0],two=k[n-1];\\n        int i=0,j=0;\\n        int x=one.length();\\n        int y=two.length();\\n        for(;i<x and j<y;i++,j++)\\n        {\\n            if(one[i]!=two[j])\\n                break;\\n            ans+=one[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565521,
                "title": "java-trie",
                "content": "This question is the best example to use a Trie. If you are familiar with Trie, then great. All you need is the \"insert\" function and a \"traversal\" function. Else follow the link mentioned below to understand.\\n\\nRefer to Trie : [ https://leetcode.com/problems/implement-trie-prefix-tree/solution/ ] \\n\\n```\\nclass Node {\\n    // Here : used a TreeMap because there is a need to maintain the insertion order\\n    TreeMap<Character, Node> children;\\n    boolean endOfWord;\\n    \\n    Node() {\\n        children = new TreeMap<>();\\n        endOfWord = false;\\n    }\\n}\\n\\nclass Solution {\\n    Node root;\\n    \\n\\t// insert the characters in trie\\n    public void insert(String word) {\\n        Node curr = this.root;\\n        for(int i=0;i<word.length();i++) {\\n            char ch = word.charAt(i);\\n            if( curr.children.get(ch) == null ) {\\n                curr.children.put(ch, new Node());\\n            }\\n            curr = curr.children.get(ch);\\n        }\\n        curr.endOfWord = true;\\n    }\\n    \\n\\t// Function : find the longest common prefix\\n    public String lcp() {\\n        \\n        StringBuilder result = new StringBuilder();\\n        Node curr = this.root;\\n        while(curr!=null && !curr.endOfWord && curr.children.size()==1) {\\n            \\n            // iterate the map and keep on appending the Character with the answer\\n\\t\\t\\t// much simpler iterator below \\n            Iterator<Map.Entry<Character, Node>> treemapItertor = curr.children.entrySet().iterator();\\n            \\n\\t\\t\\tif(treemapItertor.hasNext()) {\\n                Map.Entry<Character, Node> entry = treemapItertor.next();\\n\\t\\t\\t\\tresult.append(entry.getKey());\\n\\t\\t\\t\\tcurr = entry.getValue();\\n            }\\n        }\\n\\n\\t\\t/*  This can also be done like below : \\n\\t\\t\\t\\twhile(curr!=null && !curr.isEndOfWord && curr.children.size() == 1) {\\n\\t\\t\\t\\t\\tfor(Character key : curr.children.keySet()) {\\n\\t\\t\\t\\t\\t\\t result.append(key);\\n\\t\\t\\t\\t\\t\\tcurr = curr.children.get(key);\\n\\t\\t\\t\\t\\t\\tbreak;  // break out this for loop as we want only the single character\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t*/\\n        return result.toString();\\n    }\\n    public String longestCommonPrefix(String[] strs) {\\n        Solution trieObj = new Solution();\\n        trieObj.root = new Node();\\n        \\n        if(strs==null || strs.length==0) {\\n            return new String(\"\");\\n        }\\n\\t\\t// insert the words in Trie\\n        for(String s : strs) {\\n            trieObj.insert(s);\\n        }\\n\\t\\t// find the LCP !\\n        return trieObj.lcp();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Node {\\n    // Here : used a TreeMap because there is a need to maintain the insertion order\\n    TreeMap<Character, Node> children;\\n    boolean endOfWord;\\n    \\n    Node() {\\n        children = new TreeMap<>();\\n        endOfWord = false;\\n    }\\n}\\n\\nclass Solution {\\n    Node root;\\n    \\n\\t// insert the characters in trie\\n    public void insert(String word) {\\n        Node curr = this.root;\\n        for(int i=0;i<word.length();i++) {\\n            char ch = word.charAt(i);\\n            if( curr.children.get(ch) == null ) {\\n                curr.children.put(ch, new Node());\\n            }\\n            curr = curr.children.get(ch);\\n        }\\n        curr.endOfWord = true;\\n    }\\n    \\n\\t// Function : find the longest common prefix\\n    public String lcp() {\\n        \\n        StringBuilder result = new StringBuilder();\\n        Node curr = this.root;\\n        while(curr!=null && !curr.endOfWord && curr.children.size()==1) {\\n            \\n            // iterate the map and keep on appending the Character with the answer\\n\\t\\t\\t// much simpler iterator below \\n            Iterator<Map.Entry<Character, Node>> treemapItertor = curr.children.entrySet().iterator();\\n            \\n\\t\\t\\tif(treemapItertor.hasNext()) {\\n                Map.Entry<Character, Node> entry = treemapItertor.next();\\n\\t\\t\\t\\tresult.append(entry.getKey());\\n\\t\\t\\t\\tcurr = entry.getValue();\\n            }\\n        }\\n\\n\\t\\t/*  This can also be done like below : \\n\\t\\t\\t\\twhile(curr!=null && !curr.isEndOfWord && curr.children.size() == 1) {\\n\\t\\t\\t\\t\\tfor(Character key : curr.children.keySet()) {\\n\\t\\t\\t\\t\\t\\t result.append(key);\\n\\t\\t\\t\\t\\t\\tcurr = curr.children.get(key);\\n\\t\\t\\t\\t\\t\\tbreak;  // break out this for loop as we want only the single character\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t*/\\n        return result.toString();\\n    }\\n    public String longestCommonPrefix(String[] strs) {\\n        Solution trieObj = new Solution();\\n        trieObj.root = new Node();\\n        \\n        if(strs==null || strs.length==0) {\\n            return new String(\"\");\\n        }\\n\\t\\t// insert the words in Trie\\n        for(String s : strs) {\\n            trieObj.insert(s);\\n        }\\n\\t\\t// find the LCP !\\n        return trieObj.lcp();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 331851,
                "title": "python-trie",
                "content": "```python\\nclass TrieNode(object):\\n    \"\"\"Trie Node with a maximum of 26 links (a-z)\"\"\"\\n    ALPHABET = 26\\n\\n    def __init__(self):\\n        self._links = {}\\n        self.is_end = False\\n        self.link_size = 0\\n\\n    def contains_key(self, char):\\n        \"\"\"Check if charater has a child link in node\"\"\"\\n        return char in self._links\\n\\n    def get(self, char):\\n        \"\"\"Get child link for character\"\"\"\\n        return self._links[char]\\n\\n    def put(self, char, node):\\n        \"\"\"Set child link for character\"\"\"\\n        self._links[char] = node\\n        self.link_size += 1\\n        \\nclass Trie(object):\\n    \"\"\"Trie for strings of lower case letter a-z\"\"\"\\n    def __init__(self):\\n        self._root = TrieNode()\\n\\n    def insert(self, word):\\n        \"\"\"Insert word into the Trie\"\"\"\\n        node = self._root\\n        for char in word:\\n            if not node.contains_key(char):\\n                node.put(char, TrieNode())\\n            node = node.get(char)\\n        node.is_end = True\\n\\n    def _search_prefix(self, word):\\n        \"\"\"Search whole key or prefix in the Trie\\n           and return the node where the search ends\"\"\"\\n        node = self._root\\n        for char in word:\\n            if not node.contains_key(char):\\n                return None\\n            node = node.get(char)\\n        return node\\n\\n    def search(self, word):\\n        \"\"\"Search if a word is in the Trie\"\"\"\\n        node = self._search_prefix(word)\\n        return node is not None and node.is_end\\n\\n    def startswith(self, prefix):\\n        \"\"\"Search if prefix exist in Trie\"\"\"\\n        node = self._search_prefix(prefix)\\n        return node is not None\\n    \\n    def search_longest_prefix(self, word):\\n        \"\"\"Search longest prefix in Trie\"\"\"\\n        node = self._root\\n        prefix = \"\"\\n        for char in word:\\n            if (not node.contains_key(char) \\n                or node.link_size != 1\\n                or node.is_end):\\n                return prefix\\n            \\n            prefix += char\\n            node = node.get(char)\\n        \\n        return prefix\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \"\"\\n        \\n        if len(strs) == 1:\\n            return strs[0]\\n        \\n        trie = Trie()\\n        for s in islice(strs, 1, None):\\n            trie.insert(s)\\n        \\n        return trie.search_longest_prefix(strs[0])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass TrieNode(object):\\n    \"\"\"Trie Node with a maximum of 26 links (a-z)\"\"\"\\n    ALPHABET = 26\\n\\n    def __init__(self):\\n        self._links = {}\\n        self.is_end = False\\n        self.link_size = 0\\n\\n    def contains_key(self, char):\\n        \"\"\"Check if charater has a child link in node\"\"\"\\n        return char in self._links\\n\\n    def get(self, char):\\n        \"\"\"Get child link for character\"\"\"\\n        return self._links[char]\\n\\n    def put(self, char, node):\\n        \"\"\"Set child link for character\"\"\"\\n        self._links[char] = node\\n        self.link_size += 1\\n        \\nclass Trie(object):\\n    \"\"\"Trie for strings of lower case letter a-z\"\"\"\\n    def __init__(self):\\n        self._root = TrieNode()\\n\\n    def insert(self, word):\\n        \"\"\"Insert word into the Trie\"\"\"\\n        node = self._root\\n        for char in word:\\n            if not node.contains_key(char):\\n                node.put(char, TrieNode())\\n            node = node.get(char)\\n        node.is_end = True\\n\\n    def _search_prefix(self, word):\\n        \"\"\"Search whole key or prefix in the Trie\\n           and return the node where the search ends\"\"\"\\n        node = self._root\\n        for char in word:\\n            if not node.contains_key(char):\\n                return None\\n            node = node.get(char)\\n        return node\\n\\n    def search(self, word):\\n        \"\"\"Search if a word is in the Trie\"\"\"\\n        node = self._search_prefix(word)\\n        return node is not None and node.is_end\\n\\n    def startswith(self, prefix):\\n        \"\"\"Search if prefix exist in Trie\"\"\"\\n        node = self._search_prefix(prefix)\\n        return node is not None\\n    \\n    def search_longest_prefix(self, word):\\n        \"\"\"Search longest prefix in Trie\"\"\"\\n        node = self._root\\n        prefix = \"\"\\n        for char in word:\\n            if (not node.contains_key(char) \\n                or node.link_size != 1\\n                or node.is_end):\\n                return prefix\\n            \\n            prefix += char\\n            node = node.get(char)\\n        \\n        return prefix\\n        \\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \"\"\\n        \\n        if len(strs) == 1:\\n            return strs[0]\\n        \\n        trie = Trie()\\n        for s in islice(strs, 1, None):\\n            trie.insert(s)\\n        \\n        return trie.search_longest_prefix(strs[0])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 7108,
                "title": "java-solution-using-trie",
                "content": "Trie is a great solution for problems about prefix or string processing. And because of my intuition, I implementing a Trie for this question. May be its slow for this question, but I think it would definitely has advantage when the data set is very large. \\nAnyway, it an interesting method to use and practice. In case any one would want to see it, here is my code. \\n\\n```\\npublic class Solution {\\n    /**\\n     * Use a Trie to store all the strings. And this data structure is naturelly suited to find common prefix since it uses common prefix to store and search the strings. \\n     * All we have to do is print out the TrieNodes with only 1 child, indicating they are the common prefix of all the strings. \\n    **/\\n    \\n    public String longestCommonPrefix(String[] strs) {\\n        Trie trie = new Trie();\\n        for (String str : strs) {\\n            trie.insert(str);\\n        }\\n        TrieNode current = trie.root;\\n        String result = \"\";\\n        while (current.isEnd != true) {\\n            int count = 0;\\n            int index = 0;\\n            for (int i = 0; i < 26; i++) {\\n                if (current.childs[i] != null) {\\n                    count += 1;\\n                    index = i;\\n                }\\n            }\\n            if (count != 1) return result;  //Once we find a node whose childs number is not 1, say, either 0 or more than 1, common prefix have been found\\n            current = current.childs[index];\\n            result += String.valueOf(current.value);\\n        }\\n        return result;\\n        \\n    }\\n    \\n    class TrieNode {\\n        static final int numAlpha = 26;\\n        char value;\\n        int count;\\n        TrieNode[] childs;\\n        boolean isEnd;\\n        public TrieNode(char c) {\\n            value = c;\\n            count = 0;\\n            childs = new TrieNode[numAlpha];\\n            isEnd = false;\\n        }\\n    }\\n    \\n    class Trie {\\n        TrieNode root;\\n        public Trie() {\\n            root = new TrieNode(' ');\\n        }\\n        \\n        public void insert(String word) {\\n            if (this.search(word) == true) return;\\n            \\n            TrieNode current = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if (c >= 'A' && c <= 'Z') {\\n                    c = (char)(c + 'a' - 'A');\\n                }\\n                if (current.childs[c - 'a'] != null) {\\n                    current = current.childs[c - 'a'];\\n                }\\n                else {\\n                    current.childs[c - 'a'] = new TrieNode(c);\\n                    current = current.childs[c - 'a'];\\n                }\\n                current.count++;\\n            }\\n            current.isEnd = true;\\n        }\\n        \\n        public boolean search(String word) {\\n            TrieNode current = root;\\n            \\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                int index = 0;\\n                if (c >= 'A' && c <= 'Z') {\\n                    index = c - 'A';\\n                }\\n                else {\\n                    index = c - 'a';\\n                }\\n                if (current.childs[index] == null) {\\n                    return false;\\n                }\\n                else {\\n                    current = current.childs[index];\\n                }\\n            }\\n            if (current.isEnd == true) {\\n                return true;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    /**\\n     * Use a Trie to store all the strings. And this data structure is naturelly suited to find common prefix since it uses common prefix to store and search the strings. \\n     * All we have to do is print out the TrieNodes with only 1 child, indicating they are the common prefix of all the strings. \\n    **/\\n    \\n    public String longestCommonPrefix(String[] strs) {\\n        Trie trie = new Trie();\\n        for (String str : strs) {\\n            trie.insert(str);\\n        }\\n        TrieNode current = trie.root;\\n        String result = \"\";\\n        while (current.isEnd != true) {\\n            int count = 0;\\n            int index = 0;\\n            for (int i = 0; i < 26; i++) {\\n                if (current.childs[i] != null) {\\n                    count += 1;\\n                    index = i;\\n                }\\n            }\\n            if (count != 1) return result;  //Once we find a node whose childs number is not 1, say, either 0 or more than 1, common prefix have been found\\n            current = current.childs[index];\\n            result += String.valueOf(current.value);\\n        }\\n        return result;\\n        \\n    }\\n    \\n    class TrieNode {\\n        static final int numAlpha = 26;\\n        char value;\\n        int count;\\n        TrieNode[] childs;\\n        boolean isEnd;\\n        public TrieNode(char c) {\\n            value = c;\\n            count = 0;\\n            childs = new TrieNode[numAlpha];\\n            isEnd = false;\\n        }\\n    }\\n    \\n    class Trie {\\n        TrieNode root;\\n        public Trie() {\\n            root = new TrieNode(' ');\\n        }\\n        \\n        public void insert(String word) {\\n            if (this.search(word) == true) return;\\n            \\n            TrieNode current = root;\\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                if (c >= 'A' && c <= 'Z') {\\n                    c = (char)(c + 'a' - 'A');\\n                }\\n                if (current.childs[c - 'a'] != null) {\\n                    current = current.childs[c - 'a'];\\n                }\\n                else {\\n                    current.childs[c - 'a'] = new TrieNode(c);\\n                    current = current.childs[c - 'a'];\\n                }\\n                current.count++;\\n            }\\n            current.isEnd = true;\\n        }\\n        \\n        public boolean search(String word) {\\n            TrieNode current = root;\\n            \\n            for (int i = 0; i < word.length(); i++) {\\n                char c = word.charAt(i);\\n                int index = 0;\\n                if (c >= 'A' && c <= 'Z') {\\n                    index = c - 'A';\\n                }\\n                else {\\n                    index = c - 'a';\\n                }\\n                if (current.childs[index] == null) {\\n                    return false;\\n                }\\n                else {\\n                    current = current.childs[index];\\n                }\\n            }\\n            if (current.isEnd == true) {\\n                return true;\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566649,
                "title": "longest-common-prefix-optimized-code",
                "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty())\\n            return \"\";\\n        \\n        string prefix = strs[0];\\n        \\n        for (int i = 1; i < strs.size(); i++) {\\n            while (strs[i].find(prefix) != 0) {\\n                prefix = prefix.substr(0, prefix.length() - 1);\\n                \\n                if (prefix.empty())\\n                    return \"\";\\n            }\\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```\\n\\nExplanation:\\n\\n1. We define a longestCommonPrefix function that takes a vector of strings strs as input and returns the longest common prefix string.\\n2. If the input vector strs is empty, we immediately return an empty string.\\n3. We initialize the prefix string with the first string in the vector strs.\\n4. We iterate through the remaining strings in the vector, starting from the second string (index 1).\\n5. In each iteration, we check if the prefix is a prefix of the current string strs[i] using the find function. If it is not a prefix, we remove the last character from the prefix by using substr with the starting index 0 and length prefix.length() - 1.\\n6. We continue this process until the prefix becomes a prefix of the current string or until it becomes an empty string. If the prefix becomes empty, it means there is no common prefix among the strings, so we return an empty string.\\n7. Finally, we return the resulting prefix string, which represents the longest common prefix among all the strings in the vector strs.\\n\\nThe time complexity of this solution is O(N * M), where N is the number of strings in the vector strs and M is the length of the shortest string in the vector.\\n\\n**PLEASE UPVOTE :)**\\n\\n",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty())\\n            return \"\";\\n        \\n        string prefix = strs[0];\\n        \\n        for (int i = 1; i < strs.size(); i++) {\\n            while (strs[i].find(prefix) != 0) {\\n                prefix = prefix.substr(0, prefix.length() - 1);\\n                \\n                if (prefix.empty())\\n                    return \"\";\\n            }\\n        }\\n        \\n        return prefix;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3504703,
                "title": "java-solution-easy-to-understand",
                "content": "# Approach\\nThe given code implements the `longestCommonPrefix` method, which takes an array of strings `strs` as input and returns the longest common prefix among the strings. Here is an explanation of the approach used in the code:\\n\\n1. Initialize a variable `ans` with the first string in the array `strs`. This is done assuming that the first string is the initial common prefix.\\n\\n2. Initialize an empty string `sub` to store the temporary common prefix between `ans` and the current string being checked.\\n\\n3. Iterate through the remaining strings in the `strs` array starting from the second string.\\n\\n4. For each string, iterate through its characters and compare them with the characters at the corresponding positions in `ans`. The inner loop runs until either the end of the current string or the end of `ans`, whichever is shorter.\\n\\n5. If the characters at the current position in both `ans` and the current string are the same, append that character to the `sub` string.\\n\\n6. If the characters at the current position are not the same, break out of the inner loop because it means that the common prefix ends at this point.\\n\\n7. Update `ans` to be equal to `sub`, which contains the common prefix found so far.\\n\\n8. Reset `sub` to an empty string for the next iteration.\\n\\n9. After all the strings have been processed, the value of `ans` will be the longest common prefix among all the strings.\\n\\n10. Finally, return the `ans` string as the result.\\n\\nNote: The code assumes that the input `strs` array is not empty and contains at least one string.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of the given code is O(N * M), where N is the length of the input array strs and M is the length of the shortest string in strs\\n\\n- Space complexity:\\nThe space complexity of the code is O(M), where M is the length of the shortest string in strs.\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {     \\n        String ans = strs[0];\\n        String sub = \"\";\\n        \\n        for (int i = 1; i < strs.length; i++) {\\n            \\n            for (int j = 0; j < Math.min(ans.length(), strs[i].length()); j++) {\\n\\n                if (ans.charAt(j) == strs[i].charAt(j)) {\\n                    sub += ans.charAt(j);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            ans = sub;\\n            sub = \"\";\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {     \\n        String ans = strs[0];\\n        String sub = \"\";\\n        \\n        for (int i = 1; i < strs.length; i++) {\\n            \\n            for (int j = 0; j < Math.min(ans.length(), strs[i].length()); j++) {\\n\\n                if (ans.charAt(j) == strs[i].charAt(j)) {\\n                    sub += ans.charAt(j);\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n            ans = sub;\\n            sub = \"\";\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316480,
                "title": "powerful-logic-with-sort-approach-and-prefix-tree-python",
                "content": "# 1.  Sort approach:\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        ans=\"\"\\n        n=len(strs)\\n        strs.sort()\\n        for i in range(len(strs[0])):\\n            if strs[0][i]==strs[n-1][i]:\\n                ans+=strs[0][i]\\n            else:\\n                break\\n        return ans\\n```\\n\\n# Prefix Tree Approach\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \"\"\\n        short=min(strs,key=len)\\n        for i,v in enumerate(short):\\n            for w in strs:\\n                if w[i]!=short[i]:\\n                    return short[:i]\\n        return short \\n        \\n```\\n# please upvote me it would encourage me alot\\n",
                "solutionTags": [
                    "Python3",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        ans=\"\"\\n        n=len(strs)\\n        strs.sort()\\n        for i in range(len(strs[0])):\\n            if strs[0][i]==strs[n-1][i]:\\n                ans+=strs[0][i]\\n            else:\\n                break\\n        return ans\\n```\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if not strs:\\n            return \"\"\\n        short=min(strs,key=len)\\n        for i,v in enumerate(short):\\n            for w in strs:\\n                if w[i]!=short[i]:\\n                    return short[:i]\\n        return short \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194229,
                "title": "easy-approach-without-sorting-brute-force",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ncomparing the characters of the smallest string in the given string array!!\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        StringBuffer ans=new StringBuffer();\\n        if(strs.length==1)\\n        {\\n            return strs[0];\\n        }\\n        // FINDING THE SMALLEST STRING\\n        int min=strs[0].length();\\n  \\n        int index=0;\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            if(strs[i].length()<min)\\n            {\\n                min=strs[i].length();\\n                index=i;\\n            }\\n        }\\n        // COMPARING THE CHARACTERS OF ALL OTHER STRING WITH THE        SMALLEST STRING AND...\\n        String check=strs[index];\\n        <!-- System.out.println(check); -->\\n        for(int i=0;i<check.length();i++)\\n        {\\n            char ch=check.charAt(i);\\n            for(int j=0;j<strs.length;j++)\\n            {\\n                if(strs[j].charAt(i)!=ch)\\n                {\\n                    return ans+\"\";\\n                }\\n                \\n            }\\n            ans.append(ch);\\n        }\\n        return ans+\"\";\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        StringBuffer ans=new StringBuffer();\\n        if(strs.length==1)\\n        {\\n            return strs[0];\\n        }\\n        // FINDING THE SMALLEST STRING\\n        int min=strs[0].length();\\n  \\n        int index=0;\\n        for(int i=0;i<strs.length;i++)\\n        {\\n            if(strs[i].length()<min)\\n            {\\n                min=strs[i].length();\\n                index=i;\\n            }\\n        }\\n        // COMPARING THE CHARACTERS OF ALL OTHER STRING WITH THE        SMALLEST STRING AND...\\n        String check=strs[index];\\n        <!-- System.out.println(check); -->\\n        for(int i=0;i<check.length();i++)\\n        {\\n            char ch=check.charAt(i);\\n            for(int j=0;j<strs.length;j++)\\n            {\\n                if(strs[j].charAt(i)!=ch)\\n                {\\n                    return ans+\"\";\\n                }\\n                \\n            }\\n            ans.append(ch);\\n        }\\n        return ans+\"\";\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2773589,
                "title": "efficient-python-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Start from the first index of strs[0]\\n- Loop through strs (array)\\n- If not same: return prefix\\n- else: add prefix\\n\\n# Complexity\\n- Time complexity: $$O(n*n[0].length)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ *(Not counting result)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        prefix = \\'\\'\\n\\n        for p in range(len(strs[0])):\\n            for m in range(1, len(strs)):\\n                if p > len(strs[m])-1 or strs[m][p] != strs[0][p]:\\n                    return prefix\\n            prefix += strs[0][p]\\n        return prefix\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        prefix = \\'\\'\\n\\n        for p in range(len(strs[0])):\\n            for m in range(1, len(strs)):\\n                if p > len(strs[m])-1 or strs[m][p] != strs[0][p]:\\n                    return prefix\\n            prefix += strs[0][p]\\n        return prefix\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553219,
                "title": "simplest-java-solution-ever-for-the-problem-with-explanation",
                "content": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        //if we see the string in arrays carefully we can say that if \\n        //arreange them in lexicogrphy order and check for the first and last \\n        //string for same prefix we will get the ans\\n        //no need to travels and check all the strings\\n                \\n        Arrays.sort(strs);//sorting the strs array\\n        String start = strs[0];//taking first string in sorted array\\n        String end = strs[strs.length-1];//taking last string in sorted array\\n        String s = \"\";//creating an empty string\\n        for(int i=0; i<start.length(); i++){\\n            if(start.charAt(i)==end.charAt(i)){//checking the elemet in first & last string\\n                s += start.charAt(i);//if same add in string s\\n            }\\n            else{\\n                break;//if letters are not same break the loop \\n            }\\n        }\\n        return s;\\n    }\\n}\\n```\\nIf u like the solution plz upvote",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        //if we see the string in arrays carefully we can say that if \\n        //arreange them in lexicogrphy order and check for the first and last \\n        //string for same prefix we will get the ans\\n        //no need to travels and check all the strings\\n                \\n        Arrays.sort(strs);//sorting the strs array\\n        String start = strs[0];//taking first string in sorted array\\n        String end = strs[strs.length-1];//taking last string in sorted array\\n        String s = \"\";//creating an empty string\\n        for(int i=0; i<start.length(); i++){\\n            if(start.charAt(i)==end.charAt(i)){//checking the elemet in first & last string\\n                s += start.charAt(i);//if same add in string s\\n            }\\n            else{\\n                break;//if letters are not same break the loop \\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2430629,
                "title": "c-linq-solution",
                "content": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs)\\n    {\\n        if (!strs.Any())\\n            return string.Empty;\\n\\n        var shortestWord = strs.MinBy(a => a.Length);\\n        for (var i = shortestWord.Length; i > 0; i--)\\n        {\\n            if (strs.All(a => a.StartsWith(shortestWord[..i])))\\n                return shortestWord[..i];\\n        }\\n\\n        return string.Empty;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LongestCommonPrefix(string[] strs)\\n    {\\n        if (!strs.Any())\\n            return string.Empty;\\n\\n        var shortestWord = strs.MinBy(a => a.Length);\\n        for (var i = shortestWord.Length; i > 0; i--)\\n        {\\n            if (strs.All(a => a.StartsWith(shortestWord[..i])))\\n                return shortestWord[..i];\\n        }\\n\\n        return string.Empty;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2193815,
                "title": "python-3-liner-clean-code-zip-function",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res=\"\"\\n        for i in list(zip(*strs)):\\n            if len(set(i))==1: res+=i[0]\\n            else: break\\n        return res\\n\\n```\\n***Pls upvote the solution if you find it helpful***",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        res=\"\"\\n        for i in list(zip(*strs)):\\n            if len(set(i))==1: res+=i[0]\\n            else: break\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163267,
                "title": "python-beats-99-11-with-full-working-explanation",
                "content": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:  # Time: O(n*n) and Space: O(1)\\n        res=\\'\\'\\n        for i in range(len(strs[0])):           # we take the first string from the list of strings as the base case\\n            for s in strs:                        # taking one string at a time and checking each of the strings\\' character at the same index i\\n                if i==len(s) or s[i]!=strs[0][i]:   # when anyone of the string reaches its end and at index i strings does not match\\n                    return res                      # we cannot go ahead now as per the LCP rules, and we need to return the longest common prefix\\n            res+=strs[0][i]                       # when all the conditions in if fails for every string at index i, that means that character at i is LCP\\n        return res                              # when for loop exit, means the whole base case was the LCP\\n```\\nFor example,\\nstrs = [\"flower\",\"flow\",\"flight\"]\\n{index, s} = {0, flower}, {1, flow}, {2, flight}\\nlen(flower) = 6, len(flow) = 4,  and len(flight) = 6\\nfor i = len(strs[0]) = len(flower) = 6 i.e. 0,1,2,3,4,5\\n1. i=0: \\n* for s=flower --> if 0==6 or s[0]!=strs[0][0] = False \\n* for s=flow   --> if 0==4 or s[0]!=strs[0][0] = False \\n* for s=flight --> if 0==6 or s[0]!=strs[0][0] = False\\n* res = res + strs[0][0] = \\'\\' + \\'f\\' = f \\n2. i=1:\\n* for s=flower --> if 1==6 or s[1]!=strs[0][1] = False \\n* for s=flow   --> if 1==4 or s[1]!=strs[0][1] = False \\n* for s=flight --> if 1==6 or s[1]!=strs[0][1] = False\\n* res = res + strs[0][0] = f + l = fl \\n3. i=2:\\n* for s=flower --> if 2==6 or s[2]!=strs[0][2] = False \\n* for s=flow   --> if 2==4 or s[2]!=strs[0][2] = False \\n* for s=flight --> if 2==6 or s[2]!=strs[0][2] = False\\n* res = res + strs[0][0] = fl + o  = flo \\n4. i=3:\\n* for s=flower --> if 3==6 or s[3]!=strs[0][3] = False \\n* for s=flow   --> if 3==4 or s[3]!=strs[0][3] = False \\n* for s=flight --> if 3==6 or s[3]!=strs[0][3] = False\\n* res = res + strs[0][0] = flow + w = flow \\n5. i=4:\\n* for s=flower --> if 4==6 or s[4]!=strs[0][4] = False \\n* for s=flow   --> if 4==4 or s[4]!=strs[0][4] = True and index out of bounds -->  Return result flow as the longest common prefix",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:  # Time: O(n*n) and Space: O(1)\\n        res=\\'\\'\\n        for i in range(len(strs[0])):           # we take the first string from the list of strings as the base case\\n            for s in strs:                        # taking one string at a time and checking each of the strings\\' character at the same index i\\n                if i==len(s) or s[i]!=strs[0][i]:   # when anyone of the string reaches its end and at index i strings does not match\\n                    return res                      # we cannot go ahead now as per the LCP rules, and we need to return the longest common prefix\\n            res+=strs[0][i]                       # when all the conditions in if fails for every string at index i, that means that character at i is LCP\\n        return res                              # when for loop exit, means the whole base case was the LCP\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564635,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1720944,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1565735,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1575665,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1565289,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1789281,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1573676,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1566468,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1684693,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1566066,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1564635,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1720944,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1565735,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1575665,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1565289,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1789281,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1573676,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1566468,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1684693,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1566066,
                "content": [
                    {
                        "username": "Vgn",
                        "content": "The problem statement is confusing and unclear. Can someone throw light on this ?\\n\\nIs it to find prefix between each pair of strings and return the one which is longest. Or\\nall the strings has to have a common prefix?"
                    },
                    {
                        "username": "HernandezFS6859",
                        "content": "[@moatsmjl](/moatsmjl) based on the testcases when I typed any word that doesnt have a common prefix it shows \"expected : \"\" \" so im guessing it means common between each and every one"
                    },
                    {
                        "username": "moatsmjl",
                        "content": "[@aelshako](/aelshako) does not answer the question. They\\'re correct that the expectation is unclear. if the array is [flower, flow, flood, flan, dummy], is the expectation that there is no common prefix, or that the common prefix is \"fl\"?\\ncommon between each and every one, or any common prefix?"
                    },
                    {
                        "username": "aelshako",
                        "content": "[@juniorwagueu](/juniorwagueu) Often times it is best to do the question on pen and paper to understand the algorithm before you start coding. "
                    },
                    {
                        "username": "abhishekydavsg1",
                        "content": "You have to find longest common prefix in all string element of input array. Want to understand how to work on it you  can go through \"Trie\" data structure."
                    },
                    {
                        "username": "rkroll17",
                        "content": "yeah those problems are way different and the pair problem is way harder"
                    },
                    {
                        "username": "mkohar",
                        "content": "longest prefix that is common to all strings"
                    },
                    {
                        "username": "vaibhavnagwani",
                        "content": "[@juniorwagueu](/juniorwagueu) Check for common prefix for all Strings. You can do it by \n1. Setting the 0th element as the prefix\n2. Loop through all elements from index 1 to length -1\n3. For each element, set another loop with the condition that while strs[i].indexOf(prefix) is not equal to zero, reduce size of prefix by 1 using substring method. This is done to reduce the size of prefix till the common part.\n3. Return the prefix"
                    },
                    {
                        "username": "juniorwagueu",
                        "content": "[@user4114ZG](/user4114ZG) \\n\\nHow did you proceed? I\\'m a little bit confused \\n"
                    },
                    {
                        "username": "user4114ZG",
                        "content": "common prefix"
                    },
                    {
                        "username": "jankoziel",
                        "content": "Not sure about [\"reflower\",\"flow\",\"flight\"] Test Case\\ninput:\\nstrs = [\"reflower\",\"flow\",\"flight\"]\\noutput from my solution: \"fl\"\\nexpected output: \"\"\\n\\nWhy empty string should be outputted here?"
                    },
                    {
                        "username": "varshneygovind114",
                        "content": "because of first one \"reflower\";"
                    },
                    {
                        "username": "amitmaurya0099",
                        "content": "In this question we have to solve for prefixes and prefixes always comes in beginning of the word. "
                    },
                    {
                        "username": "kamallukka219",
                        "content": "because \\'fl\\' is not at same position in all the three strings in list "
                    },
                    {
                        "username": "timothytan010517",
                        "content": "[@HarshDani](/HarshDani) does this question mean every string in the array have to be consist of common prefix? or else it\\'ll output empty string?"
                    },
                    {
                        "username": "chromo4",
                        "content": "it should be the prefix\\n"
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "because they are looking for longest prefix"
                    },
                    {
                        "username": "HarshDani",
                        "content": "First 2 Prefix of the Strings in str are as follows:\\n1. reflower: re\\n2. flow: fl\\n3. flight: fl\\n\\nsince all of them are not the same, expected output is \"\".\\n\\nIn this problem you have to check from the starting char of the string."
                    },
                    {
                        "username": "sivaram001",
                        "content": "it\\'s said prefix...meaning starting letters of word"
                    },
                    {
                        "username": "ABID_NAZEER",
                        "content": "[@mechatron2022](/mechatron2022) yes you are right."
                    },
                    {
                        "username": "mechatron2022",
                        "content": "prefix means from the first letter. From the first letter you have to find longest string that is common between array of string i.e. prefix"
                    },
                    {
                        "username": "Normalniy-nick",
                        "content": "[@louiechenner](/louiechenner) Thank you, not full condition in this problem. I understand now"
                    },
                    {
                        "username": "_____shashwat__",
                        "content": "because, fl is common on 2nd and 3rd string not common in 1st string BRO!\\n"
                    },
                    {
                        "username": "ShubhamShekhar",
                        "content": "the question is asking for common prefix not substring"
                    },
                    {
                        "username": "artem_se_putem",
                        "content": "OMG, i spent 2 hours for understand that thing, bro, thank you for your discuss :3"
                    },
                    {
                        "username": "aiswarya_rema_soman",
                        "content": "we should be searching for common pre-fixes(substring with which the string begins.) It looks like you are searching for a common substring, reflower doesnt begin with \"fl\", it just contains it."
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@sujitandgaurav](/sujitandgaurav) That makes sense for me now. We\\'re checking if ALL the strings have the same prefix, not just a few. So that means in this case, even though \"flow\" and \"flight\" has common prefix of \"fl\", because \"reflower\" doesn\\'t even begin with the letter \"f\", we can just discard the entire list of strings as not having a common prefix. Which... makes this solution a whole lot easier to manage than anticipated"
                    },
                    {
                        "username": "sujitandgaurav",
                        "content": "Understanding that prefix meant the start of each word made me approach it correctly"
                    },
                    {
                        "username": "louiechenner",
                        "content": "[@falgunagohel](/falgunagohel) I'm having problems with this testcase too. Are you saying that we're supposed to be comparing the first item in the list's prefix with every item afterwards? I would expect \"fl\" to be the longest common prefix, since there's 2 items that have it. If we're only looking at the very first item's prefix to compare with the rest, then the solution for this problem feels a lot easier than I expected."
                    },
                    {
                        "username": "falgunagohel",
                        "content": "Here in this problem the common part has to be prefix, \\nPrefix: the first substring of the string,\\nReflower does not start with \"fl\"."
                    },
                    {
                        "username": "dkarampi",
                        "content": "I think there are two (straightforward) solutions:\\n\\n1) \"Horizontal matching (over strings)\". Pick up the first string and compare it with the rest. Return the minimum prefix found among all comparisons.\\n\\n2) \"Vertical matching (over characters)\". Compare the characters between all strings from left to right. Stop whenever a mismatch is found.\\n\\nWhat is the complexity of these two approaches ?\\n\\nIs there a better solution ?"
                    },
                    {
                        "username": "Muliya_Dev",
                        "content": "[@adgrant](/adgrant) yes"
                    },
                    {
                        "username": "caldempsey",
                        "content": "I think the easiest approach is the vertical scan."
                    },
                    {
                        "username": "amanm_2003",
                        "content": "[@Shaik_Aman_Sayer](/Shaik_Aman_Sayer)  if possible share ur approach "
                    },
                    {
                        "username": "Shaik_Aman_Sayer",
                        "content": "dude i am i real ,you did this when i was in 8 th class ..i just did this problem using 1st but i was able to pass only given testcases afterwards i saw a solution of sorting the string and checking the first and last element common characters "
                    },
                    {
                        "username": "lagan_sardana",
                        "content": "I think you swapped the two definitions\\n\\n"
                    },
                    {
                        "username": "adgrant",
                        "content": "[@tejasa82](/tejasa82) I don\\'t think that is true. Both are O(n.k)"
                    },
                    {
                        "username": "deepp",
                        "content": "[@tejasa82](/tejasa82)  both are o(n.k)"
                    },
                    {
                        "username": "ramsingh66",
                        "content": "[@tejasa82](/tejasa82) 2nd is also n*k, you have to stop as soon as a mismatch is found, which will be there after k, since k is longest common prefix"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "tejasa82",
                        "content": "In first approach the time complexity is O(n.k)\\nin second, it\\'s O(n.m) \\n\\nn = no. of substrings\\nk = length of common prefix\\nm = longest substring\\'s length\\n\\nIn best case first one is better but in worst case both are equal."
                    },
                    {
                        "username": "ReemAlattas",
                        "content": "Hello Guys,\\n\\nI wrote this [blog post](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac) about solving **Longest Common Prefix** problem using Python.\\n\\nIt includes [analysis, algorithm, and Python3 code](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac).\\n\\n**Analysis:**\\nA prefix is a collection of characters at the beginning of a string. For instance, \\u201Cmi\\u201D is a prefix of \\u201Cmint\\u201D and the longest common prefix between \\u201Cmint\\u201D, \\u201Cmini\\u201D, and \\u201Cmineral\\u201D is \\u201Cmin\\u201D.\\nIn order to find the longest common prefix, we sort the array of strings alphabetically. Then, we compare the characters in the first and last strings in the array. If the character in first is in last at the corresponding index, the character must be in the remaining words at the corresponding index as well, because the array of strings have already been sorted.\\n\\n[Click here to read the full blog post with the algorithm and code.](https://medium.com/geek-hacker/leetcode-longest-common-prefix-geek-hacker-3cc159207a2d?sk=38e92fe82b1c94abd62a0cfb8b8eb6ac)\\n\\nPlease follow, like, and comment. Thanks!"
                    },
                    {
                        "username": "doom_2",
                        "content": "Thanks a lot! I didn\\'t solve this task myself and was forced to use Google :), but one thing was still unclear to me \\'Why do we compare only the first and last item of a sorted array?\\' And your comment explained it."
                    },
                    {
                        "username": "Errichto",
                        "content": "We\\'re looking for the longest string that is a prefix of every string in the input, right? Then for empty input, every string satisfies that condition (being a prefix of every string in the input) and the answer doesn\\'t exist. There is no longest string that satisfies that. So, the input should have at least one string (possibly empty - that\\'s fine)."
                    },
                    {
                        "username": "2uringTested",
                        "content": "I think you are good at problem solving, you should try competitive programming"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "I guess I have seen this guy in codeforces .... he has fabulous rating in that platform as well."
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "skymastery",
                        "content": "\"strs[i] consists of only lowercase English letters.\"\\nMeanwhile, the test contains an empty string... "
                    },
                    {
                        "username": "mochiball",
                        "content": "Read constraints. Length could be 0"
                    },
                    {
                        "username": "yonixd",
                        "content": "From that constraints: 0 <= strs[i].length <= 200. In that case str.length == 0"
                    },
                    {
                        "username": "pasindumuth",
                        "content": "The test case `[]` should be removed.\\n\\nA common prefix among a set of strings `strs` is a string `prefix` such that for all strings `s` in `strs`, `prefix` is a prefix of `s`. A longest common prefix among a set of strings `strs` is a string `prefix` that is a common prefix of `strs` that has length greater than or equal to all other prefixes.\\n\\nFor the case that `strs` is nonempty, we observe that there is a finite set of common prefixes, and that the longest common prefix must be unique. Thus, it makes sense to talk about *the* longest common prefix in the case that `strs` is not be empty.\\n\\nBy this definition, we observe that `[]` has no answer because every string concievable is a prefix of the `strs = []`. Look at the definition again. Suppose `\"ababababa\"` wasn\\'t a comon prefix of `[]`. That means there exists an `s` in `strs` such that `\"ababababa\"` isn\\'t a prefix. Is that true? No. Thus, by contradition, `\"ababababa\"` is a common prefix of `[]`. Since there is no finite string that we can claim to be the longest possible prefix (since there is always a longer prefix), let alone prove that it\\'s unique, there is no answer to this question.\\n\\nAt the end of the problem statement, it says \"If there is no common prefix, return an empty string\". But notice that statement is irrelevent for the test case `[]` because `[]` has plenty of common prefixes (every string is a common prefix of `[]`).\\n\\nThus, `[]` should be removed because it has no answer, and to suggest `\"\"` is the right answer is incorrect."
                    },
                    {
                        "username": "zduan001",
                        "content": "should answer be \"a\"? since there are 2 \"a\"s in the input, the longest common prefix should be \"a\". did I miss anything?"
                    },
                    {
                        "username": "kyanamaaf",
                        "content": "a \\'prefix\\' is a collection of letters that goes at the beginning of a word. Not placed randomly in the middle or end of a word. e.g., the prefix \\'un\\' in \\'un-happy\\'. "
                    },
                    {
                        "username": "isha_12",
                        "content": "We have to find common prefix. Even though a is there two time but its not present in all other values."
                    },
                    {
                        "username": "NghiaNguyen170192",
                        "content": "Test case and default solution are totally wrong. \\nTest Case: `[\"reflower\",\"flow\",\"flight\"]`. As you can see `fl` is the prefix counts 2 times for `flow` and `flight`, but the test case states none."
                    },
                    {
                        "username": "Noobcodre",
                        "content": "Prefix means the first letters of the string\\n"
                    },
                    {
                        "username": "tuyendt6",
                        "content": "what is prefix ?"
                    },
                    {
                        "username": "goodfishalexander",
                        "content": "[@codejockie](/codejockie) The instructions should be more specific about the requirements for the function. It just says to return the longest common prefix, it doesn\\'t explicitly state that the prefix needs to be common among every element in the array. "
                    },
                    {
                        "username": "tmdwnsyang",
                        "content": "Prefix is an affix placed before the stem of a word. So, although they all have share the same substrings `fl` for the word `reflower`, \"re\" is the prefix, not fl. Thus the final answer is an empty string."
                    },
                    {
                        "username": "codejockie",
                        "content": "It is none because all strings provided in the array must all have the prefix. Anything other than that is none."
                    },
                    {
                        "username": "changkyu7895",
                        "content": "\\n         strs.foldLeft(\"\")((_,_) =>    (strs.min,strs.max).zipped.takeWhile(v => v._1 == v._2).unzip._1.mkString)"
                    },
                    {
                        "username": "AasheeshLikePanner",
                        "content": "[@AdityaBhate](/AdityaBhate)  Bro, why you are spamming. "
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    }
                ]
            },
            {
                "id": 1635874,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1876481,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1881670,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1864054,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1729118,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1736231,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1718796,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1568113,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1853244,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1699911,
                "content": [
                    {
                        "username": "BrajBliss",
                        "content": "This is a medium level question man."
                    },
                    {
                        "username": "AlgoEngine",
                        "content": "Video visualizing the vertical scanning strategy:\n\nhttps://youtube.com/watch?v=SiNDN2M4dtQ"
                    },
                    {
                        "username": "jerryy147",
                        "content": "my 100th problem :D"
                    },
                    {
                        "username": "gurlakshpreetKaur",
                        "content": "congrats :D"
                    },
                    {
                        "username": "Mshashikanth",
                        "content": "i wrote the slowest solution to this problem "
                    },
                    {
                        "username": "iaashu98",
                        "content": "wow, congrats. Please share link, I want to write slowe solution than you."
                    },
                    {
                        "username": "dmytrochyrva",
                        "content": "Hello, I am a bit confused,  I have set of inputs:\\n[\"reflower\",\"flow\",\"flight\"]\\n\\nand it is clear that the longest prefix here is \"fl\"\\nbut test case fails for some reason and says that:\\n\\nExpected: \"\"\\n\\nHas anyone had this issue?\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Its prefix.. meaning the beginning of each string. \"fl\" is not the beginning of \"reflower\" "
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "[@bmagana5](/bmagana5)  The question wasn\\'t worded clearly at all. It asked for the most common prefix amongst an array of strings, not the most common prefix of ALL STRINGS within an array (which is apparently what it actually wanted)"
                    },
                    {
                        "username": "ArbreD",
                        "content": "[@bmagana5](/bmagana5) Thank you so much. Otherwise, I would take a couple of time fighting with it =))"
                    },
                    {
                        "username": "bmagana5",
                        "content": "it's gotta be the longest possible prefix that matches for all of the strings in the list. The substring 'fl' works for both 'flow' and 'flight', but not in 'reflower', as 'reflower' begins with the characters 're', so it stands that the longest prefix that all of the strings in the list share is \"\", or the empty string."
                    },
                    {
                        "username": "wwdj1924",
                        "content": "\"flower\" is not a prefix."
                    },
                    {
                        "username": "alpycelf",
                        "content": "Dear god...\nTurns out I didn't read the question carefully. (It wasn't written clearly though)\nI made it so it finds the longest common prefix inside the array.\nBUT\n\nInput:    [\"reflower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExpected: \"\"\n\nApparently it asks me to find the common prefix shared by ALL of the elements."
                    },
                    {
                        "username": "user7067M",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  It says **prefix** not **contains**. \"fl\" is not a prefix in \"reflower\" but is a prefix in \"flow\" and \"flight\"."
                    },
                    {
                        "username": "Jeetpal",
                        "content": "[@Arson1st_osu](/Arson1st_osu)  For example, the index 0, ie \"reflower\", doesn\\'t have \"fl\" prefix, hence, it contradicts all elements having prefix of \"fl\""
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "I still didn\\'t understand, all elements shares \"fl\"? "
                    },
                    {
                        "username": "ejqgpt",
                        "content": "It says that time complexity of the first provided solution by leetcode itself is O(S) where S is the sum of lengths of all strings. However in the 5th line, **indexOf** method of String is called. So, **indexOf** method must finish execution in O(1) for complexity to be O(S) finally. Does it work in O(1) ?"
                    },
                    {
                        "username": "rajatkumargla19",
                        "content": "no....indexOf() works in O(n) for array\nbut leetcode official solution has O(S) time complexity...observe again"
                    },
                    {
                        "username": "esauceda2725",
                        "content": "The `[\"\",\"\"]` test case is wild. The constraints clearly say that the elements in `strs` will only consist of English letters. NOT SYMBOLS OR PUNCTUATIONS."
                    },
                    {
                        "username": "kanteshkm",
                        "content": "is problem statement is confusing?. i was thinking we need to find max common prefix in any order like {\"spoiler\", \"flower\", \"flow\", \"flight\"}, still output should be \"fl\""
                    },
                    {
                        "username": "LeetCodeMoAb",
                        "content": "I believe when they say common, it means in every single word.  The best way to word this would have been \"find the longest common sequence in all words that begins at index 0\".  Still not a perfect question, but still better than saying \"prefix\". "
                    }
                ]
            },
            {
                "id": 1695930,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1569693,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1860445,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1811602,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1765584,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 2007536,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1996844,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1693397,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1625417,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1576657,
                "content": [
                    {
                        "username": "FakharElyes",
                        "content": "I think there s a problem with the test case [\"flower\",\"fkow\"]\\n\\nOutput\\n\"ow\"\\nExpected\\n\"f\"\\n\\nany 1 can shed some light?"
                    },
                    {
                        "username": "mochiball",
                        "content": "Look up what prefix is"
                    },
                    {
                        "username": "albertomariapepe",
                        "content": "the prefix is the beginning of a word"
                    },
                    {
                        "username": "_shining_star_",
                        "content": "> In the worst case we have n equal strings of length m.\\n> Time complexity is O(S), where S = m \\xB7 n. \\n> [because] T(n) = 2 \\xB7 T(n/2) + O(m). \\n \\nIn my understanding, this means there\\'s log\\u2082(n) calls that are O(m) each, meaning complexity should be O(m \\xB7 log(n)), right?"
                    },
                    {
                        "username": "MangoMat",
                        "content": "lol, I get an error because my output is \"\" but expected output is \"\"? whats the difference??\\n "
                    },
                    {
                        "username": "kartikis26",
                        "content": "This is a good question, one of the condition says \n\"strs[i] consists of only lowercase English letters.\"\n\nbut they have test case to check [\"\"] as input, \nhow can empty string be considered as english letter, this shouldn't be the corner case as per the question description"
                    },
                    {
                        "username": "CT-7567",
                        "content": "LoL while replying to you I could\\'t comment with empty string :)"
                    },
                    {
                        "username": "emma_x",
                        "content": "Have anyone had the same issue? How to solve this test case? Python3. \\nInput\\nstrs =[\"\",\"\"]\\nOutput\\nnull\\nExpected\\n\"\""
                    },
                    {
                        "username": "chypso",
                        "content": "Just change your default answer from None to \"\" "
                    },
                    {
                        "username": "user7734BK",
                        "content": "Hi, send the code so I can try to figure out"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Yea I just got the same error; did you ever find out??"
                    },
                    {
                        "username": "lukarazmadze2001",
                        "content": "So if I get correctly if first letter of the word is not the same as other ones we can already say that output is empty string so for example if words are just and adjustment the answer will be \"\" but if words are list = [answer, abu dhabi, and]  the answer will be a "
                    },
                    {
                        "username": "kevinlhit",
                        "content": "why input [\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...] is expect \"aa\"\\uFF1Fso weird"
                    },
                    {
                        "username": "anurag14200314",
                        "content": "==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x603000000150 at pc 0x000000345a71 bp 0x7ffd66beb470 sp 0x7ffd66beb468\\n\\n\\nwhy this?"
                    },
                    {
                        "username": "anshul_paigwar",
                        "content": "```\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        int i = 0, smallest_len = strs[0].size();\\n        for(auto str: strs){\\n            if(str.size()<smallest_len) smallest_len = str.size();\\n        }\\n        string common_str = \"\";\\n        for(int i=0; i<smallest_len; i++){\\n            bool common = true;\\n            char c = strs[0][i];\\n            for(auto word:strs){\\n                if(word[i]!=c){\\n                    common = false;\\n                    break;\\n                }\\n            }\\n            if(common) common_str.append(1, c);\\n            else break;\\n        }\\n        return common_str;\\n    }\\n};\\n```"
                    },
                    {
                        "username": "_NileshRaut",
                        "content": "Fast Java | Python | C++ | JavaScript | Swift solution :\\nhttps://www.nileshblog.tech/2022/04/22/leet-code-longest-common-prefix-string-c-java-python-solution/"
                    }
                ]
            },
            {
                "id": 1573975,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 1571040,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 1571041,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 1569953,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 1569195,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2075698,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2074749,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2073826,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2068399,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2064571,
                "content": [
                    {
                        "username": "styopa",
                        "content": "I think that [] shouldn\\'t be a test case. Mathematically speaking, there is no defined longest prefix. They suggest that the answer is \"\", but \"randomword\" is also a common prefix because every string that is in the list has it as a prefix. It\\'s kinda like taking the intersection of all sets inside the empty set in set theory."
                    },
                    {
                        "username": "zhangxi1994",
                        "content": "I don't understand the time complexity in editorial solution#3(Divide and conquer). My answer to this approach is somehow O(mn)..."
                    },
                    {
                        "username": "pushen",
                        "content": "It seems that we need to go through every letter in the first string to compare the substring with the rest of string s in the array. So it will take O(n^2).\\nIs there a way of O(nlgn) or O(n)?"
                    },
                    {
                        "username": "john_112",
                        "content": "Good Solution in C++, Java. Python:\\nhttps://www.techiedelight.com/find-longest-common-prefix-lcp-strings/\\nhttps://www.techiedelight.com/longest-common-prefix-given-set-strings-using-trie/"
                    },
                    {
                        "username": "firerex",
                        "content": "Please be more clear when you asking a problem. \\n\\nFor this problem, I was thinking to find out the longest common prefix, NOT FOR ALL string. \\n\\nFor my understanding if the arry like this [\"abc\", \"abcd\", \"aef\"], the result should be \"abc\". But your actually asking to get \"a\". \\n"
                    },
                    {
                        "username": "nilesh_agarwal",
                        "content": "when its written common it indicates you need to compare with all the strings"
                    },
                    {
                        "username": "rajender7",
                        "content": "I know a Trie can be used to solve this problem. But is that an overkill?"
                    },
                    {
                        "username": "raniakhemiri",
                        "content": "test case : strs =\\n[\"flower\",\"fkow\"]\\nisn\\'t the longest common prefix here \"ow\"\\n\\nit says : Expected\\n\"f\" \\n\\nI\\'m confused? "
                    },
                    {
                        "username": "ARA34",
                        "content": "Not sure I completely understand this question. Using testcase and running code on ide [\"dog\", \"flower\", \"flight\"]:\\nI get - \"dog\"\\nExpected - \"\"\\n\\nBut the code passes through the tests and shows I get \"\" for this testcase on leetcode???"
                    },
                    {
                        "username": "AfatDog",
                        "content": "help  :0\\n im struggling im new\\n"
                    },
                    {
                        "username": "ChR_Bharadwaj",
                        "content": "I\\'ve passed all the test cases.... JUST THE LAST FIVE OF THEM ARE DRIVING ME INSANE"
                    }
                ]
            },
            {
                "id": 2063625,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2063560,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2060562,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2050193,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2049154,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2048123,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2035198,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2034579,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2019638,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2017693,
                "content": [
                    {
                        "username": "midhilesh1979",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        if (strs.empty()) {\\n            return \"\";\\n        }\\n        \\n        string s3;\\n        \\n        for (int j = 0; j < strs[0].size(); j++) {\\n            char current_char = strs[0][j];\\n            \\n            for (int i = 1; i < strs.size(); i++) {\\n                if (j >= strs[i].size() || strs[i][j] != current_char) {\\n                    return s3;\\n                }\\n            }\\n            \\n            s3.push_back(current_char);\\n        }\\n        \\n        return s3;\\n    }\\n};\\n"
                    },
                    {
                        "username": "grisoliaemilio0",
                        "content": "The problem is not correctly worded. The prefix should exists in ALL the strings in the array, which can be empty (in this case, \"\" should be returned)"
                    },
                    {
                        "username": "Vithesh",
                        "content": "This was easy but really annoying....\\ni solved it under 10 min though.. ;D"
                    },
                    {
                        "username": "rammuthukumar18",
                        "content": "for this solution it won\\'t give the correct output for the testcase [\"flower\",\"flower\",\"flower\",\"flower\"] it prints \"\" but the correct output is \"flower\" why is that?\\n\\nPassed : 95/124\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        String ans=\"\";\\n        int cnt=0;\\n        if(strs.length==1) {\\n            ans=ans+strs[0];\\n            return ans;\\n        }\\n        for(int i=0;i<strs[0].length();i++){\\n            if(checker((strs[0].charAt(i)),strs,i))\\n                cnt++;\\n            else {\\n                ans=ans+strs[0].substring(0,cnt);\\n                return ans;\\n            }\\n        }\\n        return ans;\\n\\n    }\\n    public boolean checker(char ch,String[] strs,int j){\\n        for(int i=1;i<strs.length;i++){\\n            if(strs[i].length()>j) {\\n                if(ch!=strs[i].charAt(j)) \\n                    return false;\\n            }\\n            else return false;\\n        }\\n        return true;\\n    }\\n}\\n\\n"
                    },
                    {
                        "username": "seventy_two",
                        "content": "The code below is showing the exact output in my IDE but it\\'s not getting done in here Why? \\n\\n\\nchar *longestCommonPrefix(char **strs, int strsSize)\\n{\\n    char *return_string;\\n    int length = 0;\\n    int flag = 0;\\n    for (int i = 0; i < strlen(strs[0]); i++)\\n    {\\n        for (int j = 1; j < strsSize; j++)\\n        {\\n            if (strs[0][i] != strs[j][i])\\n            {\\n                flag = 1;\\n                break;\\n            }\\n        }\\n        if (flag)\\n            break;\\n        else\\n        {\\n            length++;\\n        }\\n    }\\n    return_string = (char *)malloc(sizeof(char) * length);\\n    strncpy(return_string, strs[0], length);\\n    return_string[length] = \\'\\\\0\\';\\n    return return_string;\\n}\\n//"
                    },
                    {
                        "username": "daniel_9650",
                        "content": "Has anyone tried using a Trie? Is that overcomplicating this problem?"
                    },
                    {
                        "username": "anmol1301",
                        "content": "strs[i].size() returns size_t not int\\nyou can\\'t compare int with size_t unless you typecase it to int"
                    },
                    {
                        "username": "Razin87",
                        "content": "For testcase 16, my output was \\'flo\\' and the expected output was \\'flower\\'. The sample for the testcase was strs = [\"flower\",\"flower\",\"flower\",\"flower\"]. Am I not supposed to find the prefix but the whole word in case they\\'re the same word?"
                    },
                    {
                        "username": "HariharPal",
                        "content": "my solution is working on vscode where string [\"flower\",\"flower\",\"flower\",\"flower\"] is passed but when i put this code in leetcode it give output \"\"\\nhere is my crap code\\nclass Program14Try {\\n    public static String longestCommonPrefix(String[] strs) {\\n        String last = strs[strs.length - 1];\\n        String sample = \"\";\\n        String Initial = strs[0];\\n        for (int i = 0; i < strs.length; i++) {\\n            String ithStr = strs[i];\\n            for (int j = 0; j < ithStr.length(); j++) {\\n\\n                if (Initial.length() > 0 && strs[0] != strs[strs.length - 1]) {\\n                    if (Initial.charAt(j) != ithStr.charAt(j)) {\\n                        String Prefix = Initial.substring(0, j);\\n                        return Prefix;\\n                    } else if (strs.length == 1) {\\n                        return Initial;\\n                    } else if (Initial.charAt(j) == ithStr.charAt(j) && strs.length == 2) {\\n                        sample = sample + ithStr.charAt(j);\\n                        return sample;\\n                    }\\n                } else {\\n                    return strs[0];\\n                }\\n            }\\n        }\\n        return \"\";\\n    }\\n\\n    public static void main(String[] args) {\\n        String[] strs = { \"ab\", \"a\" };\\n        System.out.println(longestCommonPrefix(strs));\\n    }\\n}"
                    },
                    {
                        "username": "tribit",
                        "content": "Definition of \"common\" should be stated here. I worked with assumption that \"common\" is prefix found in 2 or more items, when it clearly should be, `prefix found in all items`."
                    }
                ]
            },
            {
                "id": 2007273,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 2005432,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 2000031,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1999258,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1996744,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1990648,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1959953,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1944322,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1941834,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1941758,
                "content": [
                    {
                        "username": "viveknagesh21",
                        "content": "Still giving wrong answer (submission not accepted), These are my testcase run results\n[\"flower\",\"flow\",\"flight\"]\n\"fl\"\n\"fl\"\n\n[\"dog\",\"racecar\",\"car\"]\n\"\"\n\"\"\nmy code is running with time complexity O(n^2), "
                    },
                    {
                        "username": "erenyeager1",
                        "content": " i solved the this ex and checked it in visualize compiler and codeblocks , it works fine with no errors or warnings , but here it shows me theres a problem soo whatts the deal?? if anyone could find out the problem i would be glad !!\nchar * longestCommonPrefix(char ** strs, int strsSize){\n\n\nint i,len=0,j=0,len2=0;\nfor(i=0;strs[0][i]!='\\0';i++) /// i start by finding the len of first str\n    len++;\n\nchar *prefix=malloc((len+1)*(sizeof(char))); //the max size of prefix could by the len of any str in the array\n\nfor(i=0;i<len;i++)\nprefix[i]=strs[0][i]; /// i assume that first str is prefix \n\nprefix[len]='\\0';\n\nfor(i=1;i<strsSize;i++)\n    {\n        for( j=0;j<len;j++)\n\n            {\n                if(prefix[j]!=strs[i][j]) // run a lop in each str if i find a charter thats not common i replace the prefix with \\0; \n                {\n                    prefix[j]='\\0';\n                }\n            }\n            \n    }\n\nreturn prefix;\n}\n\n\nits ready to run , please try it in codeblocks or where ever and tell me what you think!!!"
                    },
                    {
                        "username": "hasan7",
                        "content": "For Input,  [\"c\",\"acc\",\"ccc\"]\\nmy answer is  \"c\" but it is expecting it to be \"\" \\nbut when the input in [\"c\"] , it is expecting \"c\" \\nThis is contradicting with each other and seems wrong??\\n"
                    },
                    {
                        "username": "coronelpoj",
                        "content": "Gonna highlight some of the parts of the problem to help you there buddy\\nWrite a function to find the longest COMMON PREFIX string AMONGST an array of strings.\\n\\nThis means for the [\"c\",\"acc\",\"ccc\"] input the answer is \"\" because \"acc\" did not have a common prefix among the remaining inputs.\\n"
                    },
                    {
                        "username": "AnthonyShuey",
                        "content": "Is this a good enough solution to crack fang on this problem: \\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n        if len(strs)==2:\\n            ans =\"\"\\n            for i in range(0,min(len(strs[0]),len(strs[1]))):\\n                if strs[0][i]!=strs[1][i]:\\n                    return ans\\n                else:\\n                    ans+=strs[0][i]\\n            return ans\\n        ans = list(strs[0])\\n        for i in range(1,len(strs)):\\n            if len(ans)==0:\\n                break\\n            nex = \"\"\\n            for j in range(0,min(len(strs[i]),len(ans))):\\n                if ans[j]!=strs[i][j]:\\n                    break\\n                else:\\n                    nex+=ans[j]\\n            ans = list(nex)\\n        s = \"\"\\n        for i in ans:\\n            s+=i\\n        return s"
                    },
                    {
                        "username": "qwertypushkar123",
                        "content": "class Solution {\\npublic:\\n    // bool cmp(string a,string b){\\n    //     if(a.size()!=b.size()) return a.size()<b.size();\\n    //     else{\\n    //         return a<b;\\n    //     }\\n    // }\\n    string longestCommonPrefix(vector<string>& strs) {\\n        sort(strs.begin(),strs.end(),[&](string a,string b){\\n            if(a.size()!=b.size()) return a.size()<b.size();\\n        else{\\n            return a<b;\\n        }\\n        });\\n        string ans=strs[0];\\n        for(auto val:strs){\\n            for(int i=0;i<min(ans.size(),val.size());i++){\\n                if(ans[i]!=val[i]){\\n                    ans.erase(i);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\nthis solution got accepted but cmp function (marked in comments) was throwing error so i used lambda function. can any one tell the mistake "
                    },
                    {
                        "username": "ankitparashar700",
                        "content": "Understand the problem statement properly. PREFIX means that something that comes before any word.SUFFIX is something that comes in last. Use of string functions make the question easier."
                    },
                    {
                        "username": "dhruvpatidar35",
                        "content": "if there is prefix then there is TRIE"
                    },
                    {
                        "username": "wailmansourouahchia",
                        "content": "why he is showing me this error \\nterminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc"
                    },
                    {
                        "username": "Jyotiprakashchanda",
                        "content": "class Solution {\\n       public String common(String s1,String s2){\\n           //compare bitween two string\\n           StringBuilder b = new StringBuilder();\\n           //find min length betwiin two string it easy to compare\\n           int min=Math.min(s1.length(), s2.length());\\n           for(int i=0;i<min;i++){\\n               if(s1.charAt(i)==s2.charAt(i)){\\n                   b.append(s1.charAt(i));\\n               }else{\\n                   break;\\n               }\\n           }\\n           return b.toString();\\n       }\\n    public String longestCommonPrefix(String[] strs) {\\n     String prefix=strs[0];\\n     for(int i=0;i<strs.length;i++){\\n         prefix= common(prefix,strs[i]);// compare 1st index string with other string one by one\\n     }\\n     return prefix;\\n        \\n    }\\n} "
                    },
                    {
                        "username": "pjain043",
                        "content": "The problem statment means, that starting from the first character in each string. what is the longest common substring/prefix.\\nHence [\"reflower\",\"flow\",\"flight\"] gives \"\"."
                    }
                ]
            },
            {
                "id": 1938741,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1936395,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1929205,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1928877,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1922509,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1921205,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1919733,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1919247,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1918369,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1918128,
                "content": [
                    {
                        "username": "codez93",
                        "content": "loved this question, too many edge cases to handle.\\nIf your are using trie, little modifications are also needed."
                    },
                    {
                        "username": "PodliyRadja",
                        "content": "Why does my solution work with any test in PyCharm, but here it gives a different answer and because of this it does not count? [\"car\", \"cir\"] in PC gives \"cr\", but here gives \"c\", with the same code."
                    },
                    {
                        "username": "nikhilag84",
                        "content": "i have done it using simple iteration but  i have a doubt as this question is considered in trie tags. but i am not getting how can i done it using trie."
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "sorting might help"
                    },
                    {
                        "username": "rohitpandey0151998",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>arr)\\n     {\\n         int N=arr.size();\\n    string ans=\"\";\\n     sort(arr.begin(), arr.end());\\n    for(int i=0;i<arr[N-1].length();i++)\\n    {\\n        if(arr[0][i]==arr[N-1][i])\\n        {\\n            ans=ans+arr[0][i];\\n        }\\n        else\\n        {\\n            break;\\n        }\\n    }\\n    if(ans.length())\\n    return ans;\\n    return \"\";\\n}\\n    \\n};"
                    },
                    {
                        "username": "a098707730135",
                        "content": "I am a beginner in Python, and in this problem, I\\'ve got string index out of range so many times but  the result I ran in my CMD was correct which was: \"fl\". I don\\'t no how can I fix it.\\n\\nmy code is: \\n `res = strs[0]\\n  for s in strs:\\n      if res == s: continue\\n      for char in range(len(s)):\\n          if s[char] == res[char]: \\n              continue\\n          else:\\n              res = res[0:char]\\n              break\\n  return res`\\n\\nI am attempting to compare every character in every word and to keep the same characters, but it shows me that it is out of range in `if s[char] == res[char]:`. \\n\\nWhat\\'s going on? "
                    },
                    {
                        "username": "cubo142",
                        "content": "what determine the \"common\" ?? 5 common prefix word and 1 different word in a same array should return the prefix of the others 5 instead of returning \"\", atleast give a specific and details test case "
                    },
                    {
                        "username": "aadityesh",
                        "content": "sorting the words before comparison simplifies the task of finding the longest common prefix because it brings the potentially common prefix to the beginning of the sorted list."
                    },
                    {
                        "username": "ibnabdeljelil",
                        "content": "I used this first to calculate the minimum:\\nminimum = min(map(lambda x: len(x), strs))\\nthen when i changed to this:\\nminimum = len(strs[0])  \\nfor i in range(1,len(strs)):\\n    if (len(strs[i])< minimum):\\n        minimum = len(strs[i])\\nit\\'s waaaay faster, any reason why ?"
                    },
                    {
                        "username": "singhdushyant2989",
                        "content": "For Javascript people, focus should be on two string function methods :- first one is indexOf() and second one is substring."
                    }
                ]
            },
            {
                "id": 1906633,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1905998,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1905748,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1903337,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1902847,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1901078,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1900758,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1898401,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1898235,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1897386,
                "content": [
                    {
                        "username": "keithdtyler",
                        "content": "Oh, I started attacking this problem all wrong. I was trying to find the longest substring shared by more than one string in the list. So for example the first test would have returned \"flow\" since both \"flow\" and \"flower\" contain that substring.\\nNo, I\\'m supposed to find the common substring that *all* strings in the set have."
                    },
                    {
                        "username": "tadarshtiwari1996",
                        "content": "there is  Use case in this Question \\nuser Case is\\nInput=[\"a\",\"a\",\"b\"]\\nso with this Input Longest Prefix is \"a\"\\nbut in the Expected of this use case Given blank String \" \"\\n\\nWhy it is Expected like that can any one please explain \\n\\n"
                    },
                    {
                        "username": "taolitony",
                        "content": "Help!!!\\n\\nMy code did well for the test cases, but got a Runtime Error when submitted. Can anyone help me understand why the Runtime Error happened? Thanks. See below for the error and the codes:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1513, java.base/java.lang.String.charAt\\n  at line 52, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        String result = \"\";\\n        int preNum = 0;\\n\\n        Arrays.sort(strs);\\n\\n        //check if the strings are legal\\n        for (String word: strs) {\\n            boolean illegal = false;\\n            if (word.length() > 200){\\n                illegal = true;\\n            } else {\\n                for (int i = 0; i < word.length(); i++){\\n                    if (word.charAt(i) >= \\'A\\' && word.charAt(i) <= \\'Z\\'){\\n                        illegal = true;\\n                        break;\\n                    }\\n                }\\n            }\\n            \\n            if (illegal){\\n                return  result;\\n            }\\n        }\\n        \\n        for (int i = 0; i < strs.length; i++) {\\n\\n            boolean flag = true;\\n\\n            for (int j = 1; j < strs.length; j++) {\\n\\n                if (strs[j].charAt(i) != strs[0].charAt(i)){\\n                    flag = false;\\n                    break;\\n                }\\n            }\\n\\n            if (flag){\\n                preNum += 1;\\n            }else {\\n                break;\\n            }\\n\\n        }\\n\\n        if (preNum == 0){//line 48\\n            return result;\\n        }else {\\n            for (int i = 0; i < preNum; i++) {\\n                result += strs[0].charAt(i); //line 52\\n            }\\n            return result;//line 54\\n        }\\n    }\\n}\\n\\n\\n"
                    },
                    {
                        "username": "swadhwa16",
                        "content": "Longest common prefix amongst ALL THE STRING ITEMS present in the array. All the string items in the array should have a common prefix."
                    },
                    {
                        "username": "Antodominic_123",
                        "content": "this solution of the Problem is easy to understand And if it //is easy  give one thumps up bro\\n\\n\\nString find = strs[0];\\n\\t\\tboolean data = false;\\n\\t\\tString result = \"\";\\n\\t\\t\\n\\t\\tfor(int i=0; i<find.length();i++)\\n\\t\\t{\\n\\t\\t\\tString process = find.substring(0,(i+1));\\n\\t\\t\\tfor(String st : strs)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif(st.startsWith(process))\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tdata = false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(data)\\n\\t\\t\\t{\\n\\t\\t\\t\\tresult = process;\\n\\t\\t\\t}\\n\\t\\t\\n\\t\\t\\t\\n\\t\\t}\\nif(result.length()>0)\\n{\\n\\treturn result;\\n}\\nelse\\n{\\n\\treturn \"\";\\n}"
                    },
                    {
                        "username": "TheStarSlayer",
                        "content": " `char * longestCommonPrefix(char ** strs, int strsSize)\\n  {\\n    int i,j,k = 0;\\n    int *count = malloc(1 * sizeof(int));\\n    int *temp1 = malloc(1 * sizeof(int));\\n    *count = 201;\\n\\n    for (i = 0; i < strsSize; i++)\\n    {\\n        for (j = 0; strs[i][j] != \\'\\\\0\\'; j++)\\n        {\\n            continue;\\n        }\\n        *temp1 = j+1;\\n        if (*temp1 < *count)\\n        {\\n            *count = *temp1;\\n        }\\n    }\\n\\n    int size = *count;\\n    free(count);\\n    free(temp1);\\n\\n    char *str = malloc((size+1)*sizeof(char));\\n    char temp;\\n    if (str == NULL)\\n    {\\n        printf(\"foo\");\\n        return NULL;\\n    }\\n    else\\n    {\\n        for (i = 0, j = 0; i < strsSize; i++)\\n        {\\n            temp = strs[0][j];\\n\\n            if (temp == strs[i][j])                     \\n            {\\n                str[k] = strs[i][j];\\n                if (i == strsSize - 1)\\n                {\\n                    j++;\\n                    k++;\\n                    i = -1;\\n                }\\n                continue;\\n            }\\n            else\\n            {\\n                str[k] = \\'\\\\0\\';\\n                break;\\n            }\\n        }\\n        return str;\\n    }\\n}`\\n\\nI was able to solve the testcases but I could not submit it as it throws a heap buffer overflow error. Can someone help me?"
                    },
                    {
                        "username": "rahilsheikh155",
                        "content": "class Solution {\\npublic String longestCommonPrefix(String[] strs) {\\nint size=strs.length;\\nif(size==0)\\n{\\nreturn \"\";\\n}\\nif(size==1)\\n{\\nreturn strs[0];\\n}\\nArrays.sort(strs);\\nint end=Math.min(strs[0].length(),strs[size-1].length());\\nint i=0;\\nwhile(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\ni++;\\nString pre=strs[0].substring(0,i);\\nreturn pre;\\n\\n}\\n}"
                    },
                    {
                        "username": "alexsoyes",
                        "content": "strs =  [\"reflower\",\"flow\",\"flight\"]\\n\\nmy output is \"fl\", but excpeted if \"\"? :O"
                    },
                    {
                        "username": "wowerzero",
                        "content": "The second example is weird: IMHO, [\"flower\",\"flow\",\"dog\"] = \"\" is much better as example"
                    },
                    {
                        "username": "fmv2113",
                        "content": "Hi! When I run this code I get time limit exceeded. Can someone explain why? \\n\\nThought process: if I keep a count of the similarities between the first string and every successive string, then I can take the minimum similarity called min, and make the resulting prefix strs[0].substring(0, min); I guess where I could be being extra is through my use of a binary heap to keep the finding min operation to O(1). Please reply with feedback!\\n\\nimport java.util.*;\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n\\n        if(strs.length==0){\\n            return null;\\n        }\\n\\n\\n        int leftPointer=0;\\n        int rightPointer=0;\\n        int count=0;\\n        PriorityQueue<Integer> minSim = new PriorityQueue<Integer>();\\n\\n        for(int i=1; i<strs.length; i++){ //start from element at index 1 in string array\\n            count=0;\\n            leftPointer=0;\\n            rightPointer=0;\\n            while(leftPointer<strs[0].length() && rightPointer<strs[i].length()){ \\n                if(strs[0].charAt(leftPointer)==strs[i].charAt(rightPointer)){\\n                    count++;\\n                    leftPointer++;\\n                    rightPointer++;\\n                }\\n            }\\n            \\n            minSim.add(count);\\n\\n        }\\n\\n        /*\\n        the minimum similarity count will tell us up to what index we should return\\n        */\\n        int min=0;\\n        if(minSim.peek()!=0){\\n           min = minSim.peek(); \\n        }\\n        String result = strs[0].substring(0,min);\\n\\n        return result;\\n\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1874278,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1873238,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1868675,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1861679,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1859803,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1857632,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1857009,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1856732,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1851865,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1846936,
                "content": [
                    {
                        "username": "satyam__17",
                        "content": "Can anyone explain this. Why is it telling me that its wrong.\n\nInput = [\"flower\",\"flower\",\"flower\",\"flower\"]\noutput = \"flower\"\nexpected = \"flower\"\n"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "try run strlen on it"
                    },
                    {
                        "username": "Amit_Jha",
                        "content": "Below code worked for me,\\n\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size = strs.length;\\n        if (size == 0)\\n            return \"\";\\n \\n        if (size == 1)\\n            return strs[0];\\n \\n        Arrays.sort(strs);\\n\\n        int end = Math.min(strs[0].length(), strs[size-1].length());\\n        int i = 0;\\n        while (i < end && strs[0].charAt(i) == strs[size-1].charAt(i) )\\n            i++;\\n \\n        String pre = strs[0].substring(0, i);\\n        return pre;\\n    }\\n}"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "test case \nstrs = [\"character\",\"scroll\",\"screen\",\"wave\",\"zoo\"]\nwhy the output is \"\" ?\nShould it be \"scr\" ? (longest and common)"
                    },
                    {
                        "username": "sarinya_pa",
                        "content": "[@user1886vS](/user1886vS) thanks! I thought it means the popular one. They should explain more haha"
                    },
                    {
                        "username": "AbdessamadEL",
                        "content": "\"common\" means in all words, in this case only two elements have the prefix \"scr\""
                    },
                    {
                        "username": "amitkr069",
                        "content": "Line 25: Char 5: error: conflicting types for \\u2018main\\u2019 [solution.c]\\n int main(int argc, char *argv[]) {\\n\\nwhat does this mean??"
                    },
                    {
                        "username": "itechman32",
                        "content": "It\\'s asking to find the longest common prefix amongst an array of strings but it doesn\\'t testcases like = [flight, bling, blink, blight, flew]\\ncorrect me if I\\'m wrong but the longest common prefix should be \"bli\" right? but it expects \"\" as result. "
                    },
                    {
                        "username": "DEVELOPER_777M",
                        "content": "```\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        strs.sort()\\n        results = \\'\\'\\n        for i, j in zip(strs[0], strs[-1]):\\n            if i == j:\\n                results += j\\n            else:\\n                break\\n        return results\\n```\\nEasier solution with zip\\uD83D\\uDE09\\u2757\\uFE0F"
                    },
                    {
                        "username": "GreyDay",
                        "content": "The test cases show my program giving the proper output but says the test failed??"
                    },
                    {
                        "username": "omaimaouahline",
                        "content": "Not sure about [\"a\",\"aca\",\"accb\",\"b\"] Test Case\\ninput:\\nstrs = [\"a\",\"aca\",\"accb\",\"b\"]\\noutput from my solution: \"\"\\nexpected output: \"a\"\\n\\nWhy \"a\" should be outputted here?"
                    },
                    {
                        "username": "wild_report",
                        "content": "class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        x = []\\n        for i in range(len(strs)):\\n            y = set(strs[i])\\n            x.append(y)\\n        for k in range(1,len(x)):\\n            z = x[0].intersection(x[k])\\n        z_list = list(z)\\n        y = \\'\\'.join(z)\\n        return y\\n        \\ni think that  idea is correct but the algorithm doesn\\'t work while on colab it works.."
                    },
                    {
                        "username": "neel19",
                        "content": "I think my solution is pretty neat and concise, have a look at it. [link](https://leetcode.com/problems/longest-common-prefix/submissions/924041227/)"
                    }
                ]
            },
            {
                "id": 1845152,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1843167,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1842345,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1840829,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1838850,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1833617,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1832789,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1832339,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1827431,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1827297,
                "content": [
                    {
                        "username": "Loomman1",
                        "content": "Should be \"common prefix for EACH string\" - it gets clearer so"
                    },
                    {
                        "username": "user5378Ua",
                        "content": "Testcase 109 \\n[\"reflower\",\"flow\",\"flight\"]\\nOutput\\n\"fl\"\\nExpected\\n\"\"\\n\\nWhy?"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "\"fl\" is not a prefix for \"reflower\". Apparently, what the question is asking for is a common prefix for ALL strings within the list (even though this isn\\'t explicitly stated)"
                    },
                    {
                        "username": "wanderingcatto",
                        "content": "I was reading through the comments, and it seems like the test case of [\"reflower\",\"flow\",\"flight\"] threw everyone off.\\n\\nThe question is so poorly worded. It asked for the most common prefix amongst an array of strings, and mentioned nothing about the prefix having to be common among **all strings**, which is what it actually wanted. Can\\'t fault someone for coding it wrongly.\\n\\n(Another test case that threw me off was the case of [\\'a\\']. When there\\'s only one item in the list, I don\\'t think you can call it \\'most common\\', but at least this is a bit more open to interpretation)"
                    },
                    {
                        "username": "ankush920",
                        "content": "optimized solution with sort crisp code\\nankush920\\n-1\\nin a few seconds\\nIntuition\\nknow sorting in 2-d matrix in a deepth way\\n\\nApproach\\nuse 2-d matrix soting property\\n\\nComplexity\\nTime complexity:\\n0(nmlog(nm))\\n\\nSpace complexity:\\n0(1)\\n\\nCode\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n\\n        string ans=\"\";\\n        sort( strs.begin() , strs.end());\\n        int n = strs.size();\\n        \\n        for( int i=0 ; i<strs[0].length() ; i++)\\n        { \\n        if(strs[0][i]!=strs[n-1][i])\\n        {\\n             return ans;\\n        }\\n        ans.push_back(strs[0][i]);\\n        }\\n        return ans ;\\n    }\\n};"
                    },
                    {
                        "username": "marina_eremina",
                        "content": ">strs[i] consists of only lowercase English letters.\n\n> Testcase: strs = [\"\",\"b\"]\n\nwtf? "
                    },
                    {
                        "username": "lukkyz",
                        "content": "I have a problem with empty string input :\\nInput :\\n[\"\"]\\nOutput\\n\"\"\\nExpected\\n\"\"\\nI have the good output but it don\\'t validate, can you help me ?"
                    },
                    {
                        "username": "sayli1",
                        "content": "How is the Time Complexity for horizontal scanning method = O(N) where N is sum of all characters in all strings ?"
                    },
                    {
                        "username": "03282013ah",
                        "content": "This is hard\\n"
                    },
                    {
                        "username": "dalvsmerk",
                        "content": "Looks like it is expected that each of the string in an array would have common prefix.\n\nI have run these test cases:\n```\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\",\"dog\"] -> \"\"\n[\"street\",\"stromi\",\"strong\",\"streamer\",\"stream\",\"string\"] -> \"str\"\n```\n"
                    },
                    {
                        "username": "chypso",
                        "content": "Hello. I have question not so much about code but more about logic. \\nif input is \"a\" (ONLY)\\nis correct answer \"a\" or \"\" ?"
                    },
                    {
                        "username": "CT-7567",
                        "content": "\"a\""
                    }
                ]
            },
            {
                "id": 1826740,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1815685,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1813606,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1811316,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1810914,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1810374,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1809618,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1807257,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1807228,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1807146,
                "content": [
                    {
                        "username": "TasneemAyham",
                        "content": "I have a question, please!!\\nI found two ways to solve this. One was to sort the array and use vertical matching(compare characters) between the first string and the last. The other was a normal horizontal matching(taking the string and comparing it to the other strings in the array, returning the longest common string). In a normal situation, horizontal would be faster. But if we are sorting the array, and then using vertical matching between only two words, wouldn\\'t that be faster than horizontal since the latter still compares it to every element in the array? \\nBut the system gives me that the horizontal is still faster. May anyone please explain why? And thank you!!"
                    },
                    {
                        "username": "CT-7567",
                        "content": "compare chars should be more faster instead of strings. think like this:\\nin horizontal you compare string and this process can be used for sorting the array but you are not sorting the array you are just comparing the strings over and over again. I believe this is why."
                    },
                    {
                        "username": "ySIDy",
                        "content": "I ran into a problem, with the same prefixes, my C++ code gives the correct answer, but with an empty symbol at the end, maybe someone knows how to get rid of it ?"
                    },
                    {
                        "username": "swagiuli",
                        "content": "i have the same problem"
                    },
                    {
                        "username": "Gabriel-Barboza-Carvajal",
                        "content": "The testcase [\"\",\"\"] i try it, and the expected output is \"\" and i got the same and it shows up that im wrong! there is a bug there! i got 121 of 124, it will be useful to see all the cases !!"
                    },
                    {
                        "username": "bananacode444",
                        "content": "The description of this problem needs to be written much more explicitly. As of now, it makes it sound as though as long as two or more (not all) elements in the array have a common prefix, then that is a valid output."
                    },
                    {
                        "username": "rugwedk2000",
                        "content": " if(strs.length==0)\\n         return \"\";\\n       String prefix=strs[0];\\n       for(int i=0;i<strs.length;i++){\\n           while(strs[i].indexOf(prefix) !=0){\\n               prefix=prefix.substring(0,prefix.length()-1);\\n               if(prefix.isEmpty())\\n                    return \"\";\\n           }\\n       }\\n       return prefix;"
                    },
                    {
                        "username": "gepcat369",
                        "content": "class Solution(object):\\n    def longestCommonPrefix(self, strs):\\n        \"\"\"\\n        :type strs: List[str]\\n        :rtype: str\\n        \"\"\"\\n        MinW = min(strs)\\n        MaxW = max(strs)\\n        left,right = 0 , len(min(strs))\\n        while left < right:\\n            mid = (left+right)//2\\n            if MaxW[mid]==MinW[mid]:\\n                left = mid+1\\n            else: \\n                right = mid-1\\n        if strs[0][left]==strs[1][left]:\\n            return strs[0][:left]\\n        else:\\n            return \"\"\\n\\nWhy this got a runtime problem?"
                    },
                    {
                        "username": "sajeeva616",
                        "content": "Input: S[] = {\\u201Cabcdefgh\\u201D, \\u201Cabcefgh\\u201D}\\nOutput: \\u201Cabc\\u201D\\n\\nis the outpu for the above question is correct or not ? since we can take efgh also as the answer"
                    },
                    {
                        "username": "BachusPL",
                        "content": "This shouldn\\'t be an easy problem. It\\'s so much harder than the rest."
                    },
                    {
                        "username": "G-lion",
                        "content": "when I return \"\" for the empty string, but my output is a gibberish. i don't know how to fix it. please help me. Thank you.  the following is part of my code. \n        if(strs.empty()){\n            return \"\";\n        }"
                    },
                    {
                        "username": "G-lion",
                        "content": "I use \"substr\" instead for return \"\" , and the answer is correct.  I figured it out, thanks."
                    },
                    {
                        "username": "danielMleetcode",
                        "content": "It would have been an easy task if the inputs were not that messed up."
                    }
                ]
            },
            {
                "id": 1805457,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1804033,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1803861,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1800636,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1800532,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1799998,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1796736,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1794688,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1791785,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1782812,
                "content": [
                    {
                        "username": "ajaykhot561",
                        "content": "For those who are getting confused between why first and last string is getting compared, here is the approach for them,\\nSo here when we sort string array we get sorted it in this form:\\nflight\\nflow\\nflower\\n\\nSo now it is sorted then we will compare first string with last flight with flower where our string character dont match break there and print the substring till that postion\\nc=2\\nsubstring(0,c);\\nans=fl\\n\\n"
                    },
                    {
                        "username": "achadharma334",
                        "content": "when to use  return and console.log( )  statements ?? I really got confused what to use "
                    },
                    {
                        "username": "ajaykhot561",
                        "content": "Coding in javascript?\\n"
                    },
                    {
                        "username": "zoe850610",
                        "content": "strs = [\"flower\",\"flow\",\"fsight\"]"
                    },
                    {
                        "username": "BrijeshSCareer",
                        "content": "Is there any difference between below code in C Programming..??\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) \\n    and \\n    if(strs[0][col] != strs[row][col])\\n\\n    if(*(*strs)+col != *(*(strs+row)+col)) - not working\\n    and \\n    if(strs[0][col] != strs[row][col]) - working\\n\\nWhy???\\n    "
                    },
                    {
                        "username": "ayushkaintura567",
                        "content": "What if the inputted list has a single string only? like x=[\\'single\\']"
                    },
                    {
                        "username": "Dennis_8765",
                        "content": "This would be my Code, it works in Eclipse but does not here it tells me that Line 14 (t=strs[j].charAt(i);\\n) has a mistake:\\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 17, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nDO you know an answer?\\n\\n\\n\\tString in = \"\";\\n\\t\\tchar t=\\' \\';\\n\\t\\tboolean tr=false;\\n\\t\\tchar[] tn = new char[strs.length];\\n        \\t\\tif(strs[0]==\"\") {\\n\\t\\t\\treturn \"\";\\n\\t\\t}\\n\\t\\tfor (int i = 0; i < strs.length; ++i) {\\n\\t\\t\\tfor (int j = 0; j < strs.length; ++j) {\\n                if(strs[j]!=null) {\\n\\t                t=strs[j].charAt(i);\\n\\t                tn[j]=t;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\n\\t\\t\\t}\\n\\t\\t\\tfor(int z=1;z<tn.length;++z) {\\n\\t\\t\\t\\tif(tn[z-1]==tn[z]) {\\n\\t\\t\\t\\t\\ttr=true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\ttr=false;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif(tr==true) {\\n\\t\\t\\t\\tin+=t;\\n\\t\\t\\t}\\n\\t\\t\\telse {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\treturn in;"
                    },
                    {
                        "username": "AmmarAlkhooly98",
                        "content": "**Tip/Hint:**\n\nI was first trying to solve this using KMP Algo, and adding a random special chars and numbers between each str, worked but has many edge cases, so if you are thinking of the same, there are simpler solutions that can be applied, think of looping vertically throughout the strings... \nGood Luck!\nCheck out my solution post [here](https://leetcode.com/problems/longest-common-prefix/solutions/3172147/looping-vertically-js-easy-optimal-solution-explained/)"
                    },
                    {
                        "username": "Ramu_p",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& arr) {\\n        \\n        int N=arr.size();\\n        string ans=\"\";\\n         sort(arr.begin(), arr.end());\\n        for(int i=0;i<arr[N-1].length();i++)\\n        {\\n            if(arr[0][i]==arr[N-1][i])\\n            {\\n                ans=ans+arr[0][i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        if(ans.length())\\n        return ans;\\n        return \"\";\\n    }\\n};"
                    },
                    {
                        "username": "RahulChan",
                        "content": "`String ans=\"\";\\n        String first=\"\";\\n        int min=Integer.MAX_VALUE;\\n        for(int i=0;i<strs.length;i++){\\n            if(strs[i].length()<=min){\\n                min=strs[i].length();\\n                first=strs[i];\\n            }\\n        }\\n        int k=0;\\n        for(int i=0;i<first.length();i++){\\n            int count=0;\\n            char ch=first.charAt(i);\\n            for(int j=0;j<strs.length;j++){\\n                if((ch==strs[j].charAt(k))){\\n                    count++;\\n                }\\n                if(count==0)\\n                    break;\\n            }\\n            k++;\\n            if(count<strs.length){\\n                break;\\n            }\\n            if(count==strs.length)\\n                ans+=ch;\\n        }\\n        return ans;`"
                    },
                    {
                        "username": "sadikhan918",
                        "content": "I threw together a solution really quick without caring for time complexity, and I\\'m getting a runtime error when I shouldn\\'t be?  \\n\\njava.lang.StringIndexOutOfBoundsException: String index out of range: 0\\n  at line 48, java.base/java.lang.StringLatin1.charAt\\n  at line 1512, java.base/java.lang.String.charAt\\n  at line 14, Solution.longestCommonPrefix\\n  at line 54, __DriverSolution__.__helper__\\n  at line 84, __Driver__.main\\n\\nI\\'ve tested the specific use case in my own IDE and it returns the proper response. The test case was [\"\", \"\"] and the response was \"\". I don\\'t know why this error is popping up."
                    }
                ]
            },
            {
                "id": 1782389,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1780299,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1777075,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1776625,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1772751,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1767363,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1758845,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1755558,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1753950,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1743578,
                "content": [
                    {
                        "username": "dracont666",
                        "content": "\\nI changed the order of the elements in the list to [\"flower\",\"flight\",\"flow\"]\\n\\nI then used my solution, which in this case returns \"flow\" not \\'fl\\' and the system accepted that decision in Python 3.\\n\\nThis is mistake?"
                    },
                    {
                        "username": "NazarBestCoder",
                        "content": "is it Normal ? \"c\",\"acc\",\"ccc\" -> \"\" , Why not \"c\" ? \\nCan SomeBody Explain me ?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "It cannot be c because the second strong \"acc\" starts with a. \\nPrefix is the First group of letters common to every string"
                    },
                    {
                        "username": "goodguygoddy",
                        "content": "What is the most optimized time complexity for this question? "
                    },
                    {
                        "username": "user7734BK",
                        "content": "it should be O(s), with s the number of total characters"
                    },
                    {
                        "username": "codebrownie",
                        "content": "The main thing here is we have to match characters of the strings consecutively if first character is matched and next doesn\\'t match then we would break the loop, else it would consider the all matching characters.\\nAnd if any length of  any the string is 0 then simply return empty string."
                    },
                    {
                        "username": "Abed_UK",
                        "content": "there is an issue in testcase 120:\\n[\\'flower\\',\\'fkow\\']\\nit is obvious that the ansr is \\'ow\\' but the concole says \\'f\\'?  could anyone help??"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "[@Abed_UK](/Abed_UK) np man. If u get past test case 106 let me know Im stuck on that one it says answer is \\u201C\\u201D and mine returns \\u201C\\u201D but its wrong? Like what? XD"
                    },
                    {
                        "username": "Abed_UK",
                        "content": "[@MichaelG123](/MichaelG123) Thanks bro I thought he was asking for the longest sequence."
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Prefix means the first letter(s) of a word\nFlower, fkow both start with f\n"
                    },
                    {
                        "username": "MichaelG123",
                        "content": "Passed 106/124 testcases.\\n\\nfailed on [\"\",\"\"]\\n\\noutput\\n\"\"\\n\\nExpected \\n\"\"\\n\\nAm I missing something here...?"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Send the code :)"
                    },
                    {
                        "username": "FaMaSk",
                        "content": "How to fix\\nUnhandled exception. System.IndexOutOfRangeException: Index was outside the bounds of the array.\\nAt Solution.LongestCommonPrefix(String[] strs)\\nAt __Driver__.Main(String[] args)\\n"
                    },
                    {
                        "username": "user7734BK",
                        "content": "Uhm maybe you incremented one of your indexes one way too much. It happened to me too and It was in a very hidden place so It was difficult to figure It out. I suggest you to try changing your indexes (adding -1)in the indicated functions"
                    },
                    {
                        "username": "Amarnath0_o",
                        "content": " `getting the following error\\nterminate called after throwing an instance of \\'std::out_of_range\\'\\n  what():  basic_string::at: __n (which is 4) >= this->size() (which is 4) pls help\\ncode:\\nclass Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string lcp =\"\";\\n        for(int i=0;i<strs.size();i++){\\n            for(int k=0;k<i;k++){\\n                int j=0;\\n                \\n                while(strs[k].at(j)!=\\'\\\\0\\'||strs[i].at(j)!=\\'\\\\0\\'){\\n                    if(strs[k].at(j)==strs[i].at(j)){\\n                        lcp+=strs[k].at(j);\\n                        j++;\\n                    }\\n                    else{\\n                        lcp=\"\";\\n                        break;\\n                    }\\n                }\\n                    \\n                \\n            }\\n        }\\n       return lcp; \\n    }\\n};"
                    },
                    {
                        "username": "sahilsandi07",
                        "content": "You can modify the below code :)\\nclass Solution(object):\\n    def longestCommonPrefix(self, strs):\\n\\n        if not strs:\\n            return \"\"\\n        if len(strs) == 1:\\n            return strs[0]\\n        strs.sort()\\n        first = strs[0]\\n        last = strs[-1]\\n        for i, char in enumerate(first):\\n            if char != last[i]:\\n                return first[:i]\\n        return first"
                    },
                    {
                        "username": "Walzr",
                        "content": "strs = [\"abca\",\"aba\",\"aaab\"]\\n\\nclass Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        i=0\\n        prefix = \"\"\\n        size = len(strs)\\n        if size ==0:\\n            return \"\"\\n        if size ==1:\\n            return strs[0]\\n        if strs[i] == \"\" or strs[i+1] ==\"\" or strs[size-1]==\"\":\\n            return \"\" \\n        else:\\n            strs.sort()\\n        if len(set(strs)) == 1:\\n            return strs[0]\\n        while i < len(strs)-1 and strs[i][i] == strs[i+1][i] and strs[size-1][i] == strs[i][i]:\\n            prefix +=strs[i][i]\\n            i+=1\\n        return prefix\\n\\nI dont understand why my output is \"ab\" instead of \"a\". Can someone explain?"
                    }
                ]
            },
            {
                "id": 1742786,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1742688,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1741875,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1739869,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1737343,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1736735,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1733842,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1733380,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1732191,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1731881,
                "content": [
                    {
                        "username": "doradengxf",
                        "content": "![image info](./Pictures/Screenshot/Screenshot(2).png)\\nI got wrong answer for a case and the expected answer does not make sense.\\nstrs = [\"reflower\",\"flow\",\"flight\" ]\\nOutput = \"fl\" \\nExpectd = \"\"\\n\\nIs there anyone who get it?"
                    },
                    {
                        "username": "Morningstar515",
                        "content": "Kind of poorly worded imo. Spent a great deal of time trying to account for the fact that the first words prefix might not contain the longest prefix. Yet the most common solutions I\\'m finding don\\'t account for this case."
                    },
                    {
                        "username": "VijayPatidar9179",
                        "content": "firstly take the length of FirstElement of string array and compare FirstElement to the last element of string array until the length of FirstElement .if char are matching them append to the Stringbuilder and return String.\\n\\n Arrays.sort(strs);\\n       int len=strs[0].length();\\n       StringBuilder sb=new StringBuilder();\\n       for(int i=0; i<len; i++)\\n       {\\n           if(strs[0].charAt(i)==strs[strs.length-1].charAt(i))\\n                sb.append(strs[0].charAt(i));\\n            else\\n                break;\\n       }\\n       String s=sb.toString();\\n       return s;"
                    },
                    {
                        "username": "Subaranjana",
                        "content": "Getting error as AddressSanitizer: heap-buffer-overflow on address 0x603000000028 at pc 0x5580a623afe2 bp 0x7fff364fa780 sp 0x7fff364fa770...... \\nfor most of the problems i have tried today. Can anyone say the reason behind this and help me to clear this error."
                    },
                    {
                        "username": "user1873di",
                        "content": "This means you are trying to access value from address out of range. For example if your array size is 5(range 0..4) but if you try to access arr[5] you get this type of error. This is also applicable in terms of vector, list, stack, queue etc."
                    },
                    {
                        "username": "YusenPeng",
                        "content": "Hint: startWith() method in String API"
                    },
                    {
                        "username": "plak4",
                        "content": "tests case of this problem reward slower algorithms ! "
                    },
                    {
                        "username": "ec1912",
                        "content": " `class Solution {\\npublic:\\n     string longestCommonPrefix(vector<string>& strs) \\n    {\\n        string prefix = \"\";\\n        \\n        if(strs.size() == 0 || strs[0].length() == 0 ){\\n            return \"\";\\n        }\\n        int CI = 0;\\n        char currnetChar= strs[0][CI];\\n        char ans;\\n        \\n        while(currnetChar != \\'\\\\0\\')\\n        {\\n            bool isCharacterDifferent = false;\\n            for(int i = 0; i < strs.size() ; i++)\\n            {\\n                ans = strs[i][CI];\\n                \\n                if(ans != currnetChar || ans == \\'\\\\0\\')\\n                {\\n                    isCharacterDifferent = true;\\n                    break;\\n                }\\n            }\\n            \\n            if(isCharacterDifferent){\\n                break;\\n            }\\n            prefix.push_back(currnetChar);\\n            currnetChar = strs[0][++CI];\\n        }\\n        \\n        return prefix;\\n    }\\n};`\\n\\n\\n\\nHere is the Clear solution of such code. If you find any changes in this code so please ping a comment reply. "
                    },
                    {
                        "username": "chiragchowdhury51",
                        "content": "For those getting confused on test cases like:\n[\"reflower\",\"flow\",\"flight\"] \nwhere expected output is \"\" but your output is \"fl\"\nread the question carefully.\nIt's asking for longest prefix\nnot longest substring, prefix means substring from the start of the string.\nI too was confused for a day not wanting to look at any solution\nbut then while asking in one of the forums this occurred to me."
                    },
                    {
                        "username": "JCH97",
                        "content": "I think that a good solution for this kind of problems could be by using a Trie. Perphas trie is too much for the problem itself, but is a good skills \\nknow when we can use it.\\n\\nRetrieve w: O( len(w) )\\nInsert w: O( (len(w) )\\nGet longest prefix: O( len(longest prefix) )\\n\\nSo, operations over trie are amazing. \\n\\n"
                    },
                    {
                        "username": "eostling",
                        "content": "Definitely enjoyed this one! I would say this is close to a  medium level tbh. Just goes to show never take someone else\\'s word for it"
                    }
                ]
            },
            {
                "id": 1728419,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1726264,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1725500,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1722955,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1722619,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1722148,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1722111,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1721552,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1721458,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1718667,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "My Simple code in java\\nclass Solution {\\n    public String longestCommonPrefix(String[] strs) {\\n        int size=strs.length;\\n        if(size==0)\\n        {\\n            return \"\";\\n        }\\n        if(size==1)\\n        {\\n            return strs[0];\\n        }\\n        Arrays.sort(strs);\\n        int end=Math.min(strs[0].length(),strs[size-1].length());\\n        int i=0;\\n        while(i<end&&strs[0].charAt(i)==strs[size-1].charAt(i))\\n            i++;\\n            String pre=strs[0].substring(0,i);\\n            return pre;\\n    \\n}\\n}"
                    },
                    {
                        "username": "Raj_MN_Doshi",
                        "content": "tried doing this the code \\na = set(set.intersection(*map(set, strs)))\\n        s=\"\"\\n        \\n        for i in a:\\n            s=s+i\\n        return s\\n\\nso the answer sometimes is coming in reverse randomly can someone explain the reason"
                    },
                    {
                        "username": "AnkushR10",
                        "content": "https://github.com/AnkushRawat10601/Leetcode/blob/main/14_longest_common_prefix.cpp"
                    },
                    {
                        "username": "Arson1st_osu",
                        "content": "strs = [\"c\",\"acc\",\"ccc\"]\\n\\nOutput\\n\"c\"\\n\\nExpected\\n\"\"\\n\\nHow? I can clearly see every string on array has \"c\""
                    },
                    {
                        "username": "bmagana5",
                        "content": "A prefix is always at the start of a word. The longest common prefix between \"c\" and \"ccc\" is \"c\", but not for \"acc\", since \"acc\" starts with \"a\". The longest possible prefix between them is \"\"."
                    },
                    {
                        "username": "Aniketprajapati",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs) {\\n        string s=strs[0];\\n        if(s[0]==0)\\n        {\\n            return s;\\n        }\\n        int j=0;\\n        string s1;\\n        for(int i=1;i<strs.size();i++)\\n        {\\n            if(strs[i]==\"\\\\0\")\\n            {\\n                return \"\\\\0\";\\n            }\\n            while(s[j]==strs[i][j])\\n            {\\n                s1=s1+s[j];\\n                j++;\\n            }\\n            s=s1;\\n            s1.clear();\\n            j=0;\\n\\n        }\\n        string f;\\n        int i=0;\\n        return f;\\n\\n    }\\n};\\n\\nmy code if failing when all the string are same plzzz give me solution of it\\n"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        String common=str[0];\\n        for( int i=0;i<str.length;i++)\\n        while(str[i].indexOf(common)!=0){\\n            common=common.substring(0,common.length()-1);\\n    return common;\\n}\\n}"
                    },
                    {
                        "username": "immortal_2511",
                        "content": "Best solution in java\\n  class Solution {\\n    public String longestCommonPrefix(String[] str) {\\n        if(str.length==0)\\n        return \"\";\\n        String prefix=str[0];\\n        for(String s:str){\\n            int i=0;\\n           int j=0;\\n            while(i<prefix.length() && j<s.length() && prefix.charAt(i)==s.charAt(j)){\\n            i++;\\n            j++;\\n        }\\n        prefix=s.substring(0,j);\\n    }\\n    return prefix;\\n         \\n    }\\n}"
                    },
                    {
                        "username": "WildChildx",
                        "content": "# Intuition\nCheck each combination\n\n# Approach\n- Track character index\n- The check if the index has reached the length of the current string if yes return result\n- Check if characters don't match if no return result.\n- Else add character to the result string.\n\n# Complexity\n- Time complexity:\n O(n)\n\n- Space complexity:\nO(n)\n\n# Code\n```\nclass Solution {\npublic:\n    string longestCommonPrefix(vector<string>& strs) {\n        string res;\n        for(int i = 0;i<strs[0].size();i++){\n            for(int j = 0;j<strs.size();j++){\n                if(i==strs[j].length() or strs[j][i]!=strs[0][i])\n                    return res;\n            res+=strs[0][i];\n        }\n        return res;\n    }\n};\n```"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# \\u2705 Easiest \\uD83D\\uDE0E FAANG Method Ever !!! \\uD83D\\uDCA5\\nhttps://leetcode.com/problems/longest-common-prefix/solutions/2928400/easiest-faang-method-ever/?orderBy=most_votes"
                    },
                    {
                        "username": "egehanyldz7",
                        "content": "flower and fkow is the testcase 120/124 and it should output ow since its the longest common prefix but its expected is \"f\" somehow"
                    }
                ]
            },
            {
                "id": 1718349,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1716871,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1714098,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1713556,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1709875,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1707963,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1707681,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1707579,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1707380,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1704244,
                "content": [
                    {
                        "username": "charanrai",
                        "content": " `string longestCommonPrefix(vector<string>& strs) {\\n        \\n        sort(strs.begin(), strs.end());\\n\\n        string fir_str = strs[0];\\n        string last_str = strs[strs.size() - 1];\\n\\n        int matched = 0;\\n        for (int  i = 0; i < fir_str.size(); i++) {\\n            if (fir_str[i] != last_str[i] ) {\\n                break;\\n            }\\n            ++matched;\\n        } \\n        \\n        if (matched == 0) {\\n            return \"\";\\n        }\\n        return fir_str.substr(0, matched);\\n    }`"
                    },
                    {
                        "username": "jamadade",
                        "content": "Why am I not able to submit this code?\\n\\n\\nvar longestCommonPrefix = function(strs) {\\n\\n    var common = \"\";\\n    var temp = \"\";\\n\\n    for(var i = 0; i < strs.length; i++){\\n        var currInd = 0;\\n        if(i === 0){\\n            common = strs[i];\\n            continue;\\n        }\\n        while(strs[i][currInd] === common[currInd]){\\n            temp = temp + strs[i][currInd];\\n            currInd++;\\n        }\\n        common = temp;\\n        temp=\"\";\\n    }\\n    return common;\\n};\\n\\n\\nRuntime Error\\n `terminate called after throwing an instance of \\'std::bad_alloc\\'\\n  what():  std::bad_alloc`"
                    },
                    {
                        "username": "Matthew910818",
                        "content": "class Solution {\\npublic:\\n    string longestCommonPrefix(vector<string>& strs)\\n    {\\n        int flag = 0;\\n        string ans = \"\";\\n        int len = strs[0].length();\\n        string first = strs[0];\\n        for(int i=0;i<=len;i++)\\n        {\\n            for(auto it=strs.begin();it!=strs.end();it++)\\n            {\\n                string cmp = *it;\\n                if(first[i] != cmp[i])\\n                {\\n                    flag = 1;\\n                    break;\\n                }\\n            }\\n            if(flag == 0)\\n            {\\n                ans+=strs[0][i];\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n\\n\\nHow come the output answer and the expected answer are the same but it still shows wrong answer?"
                    },
                    {
                        "username": "Ritam33",
                        "content": "avc"
                    },
                    {
                        "username": "willymather",
                        "content": "Should say longest substring \"car\" is not a prefix of \"racecar\""
                    },
                    {
                        "username": "urchinz",
                        "content": "I originally want to utilize python's short-circuit evaluation method: \n\nif (letter_pos >= len(current_word)) | (current_word[letter_pos] != letter):\n  -- do evaluation\n\nthe test case [\"ab\", \"a\"] keeps giving me errors. I believe it's because when letter_pos = 1, \"a\"[1] is out of index. However, because of python's or operator short-circuit, the first condition should be evaluation TRUE...\n\nAnyone have any thoughts?\n"
                    },
                    {
                        "username": "yashk1",
                        "content": "why are string questions so hard "
                    },
                    {
                        "username": "venkat50",
                        "content": "jkk"
                    },
                    {
                        "username": "kadyr1901",
                        "content": "Hi Guys, I solved this problem on C#.\\nWhen I run my code on visual studio and debug i can see it works fine, however i get different output in leetcode. \\nCan someone help me?"
                    },
                    {
                        "username": "RafaelCarro",
                        "content": "Why does the problem have a testcase  [\"\",\"\"] when it clearly says it accepts only lowercase English letters?"
                    }
                ]
            },
            {
                "id": 1702173,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1701739,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1691108,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1690959,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1678402,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1673977,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1671252,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1671116,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1662522,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            },
            {
                "id": 1657496,
                "content": [
                    {
                        "username": "mirotvoretts",
                        "content": "How can I improve my code? I dont like my SymbolIsContainedInStringsOnPosition, because it asks for 3 arguments. Suggestions?\n`public class Solution\n{\n    public string FindShortestWord(string[] strs)\n    {\n        var shortestWord = strs[0];\n\n        foreach (var word in strs)\n        {\n            if (word.Length < shortestWord.Length)\n                shortestWord = word;\n        }\n\n        return shortestWord;\n    }\n\n    public bool SymbolIsContainedInStringsOnPosition(char symbol, string[] strings, int position)\n    {\n        for (int i = 0; i < strings.Length; i++)\n        {\n            if (strings[i][position] != symbol)\n                return false;\n        }\n\n        return true;\n    }\n\n    public string LongestCommonPrefix(string[] strs)\n    {\n        var shortestWord = FindShortestWord(strs);\n        var answer = \"\";\n\n        for (int i = 0; i < shortestWord.Length; i++)\n        {\n            if (SymbolIsContainedInStringsOnPosition(shortestWord[i], strs, i))\n                answer += shortestWord[i];\n            else\n                break;\n        }\n\n        return answer;\n    }\n}`"
                    },
                    {
                        "username": "micro9997",
                        "content": "The problem statement is confusing!\\n\\nin C, as input\\n\\nchar strs[][7] = {\"flower\", \"flow\", \"flight\"};    ?\\n\\nor\\n\\nchar strs = \"[\\\\\"flower\\\\\",\\\\\"flow\\\\\",\\\\\"flight\\\\\"]\";    ?\\n"
                    },
                    {
                        "username": "dmartel33",
                        "content": "I saw the vertical scan solution immediately, but struggled with the edge cases. :("
                    },
                    {
                        "username": "acams1803",
                        "content": "guys in one of the test cases the list is [\"cir\",\"car\"] and the PREFIX expected is \"cr\" even though it should be \"c\". I believe I have misunderstood the problem. I would appreciate anyone giving an explanation."
                    },
                    {
                        "username": "Shubham_chauhan981",
                        "content": "Please read carefully the output is your output \\'cr\\' (what your program is producing) and the bottom one is expected \\'c\\' (which leetcode expects from your code)."
                    },
                    {
                        "username": "avishekchakraborty05",
                        "content": "please make the question clear. Here in the question it is asked to find the longest common prefix but not mentioned that whether we have to compare with many prefixes or there will be only one prefix sequence.\\nwhenever I am putting multiple prefixes it is showing me wrong output.\\nThank you\\n"
                    },
                    {
                        "username": "reton2008",
                        "content": "I have confusion here, like it says to find the longest prefix so we need to check each and evey character with corresponding array string. than what woud be the output of this test case\n\n`strs = [\"fllfower\",\"fllfow\",\"fllfight\"]`"
                    },
                    {
                        "username": "user8889vy",
                        "content": "check only the prefix that is from the start the output for this would be -> fllf"
                    },
                    {
                        "username": "yashdeora",
                        "content": "Here is problem solution in Python, Java, C++ and C programming.\\n[https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html](https://www.gyangav.com/2022/11/leetcode-longest-common-prefix-problem-solution.html)"
                    },
                    {
                        "username": "pradeep_skywalker",
                        "content": "Hi Guys, \\n\\nWhat is the TC of this solution. I think it\\'s O(N^3). Can you please check?\\n`class Solution:\\n    def longestCommonPrefix(self, strs: List[str]) -> str:\\n        if len(strs)==1:\\n            return strs[0]\\n\\n        d=collections.defaultdict(list)\\n        for i in range(len(strs[0])):\\n            d[strs[0][i]].append(i)\\n        print(d)\\n\\n        ans=\"\"\\n        L=len(strs[0])\\n        l=0\\n        for i in range(1,len(strs)):\\n            ans=\"\"\\n            l=0\\n            for j in range(len(strs[i])):\\n                if j<L:\\n                    if strs[i][j] not in d.keys():\\n                        break\\n                    elif j not in d[strs[i][j]]:\\n                        break\\n                    else:\\n                        ans+=strs[i][j]\\n                        l+=1\\n                        # d[strs[i][j]].remove(j)\\n            L=l\\n            print(ans,L)\\n        return ans`\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "I think it\\'s just N^2"
                    },
                    {
                        "username": "pradeep_selvaraj",
                        "content": "The problem is not clear.\\n\\nBecause for given input [\"reflower\",\"flow\",\"flight\"], its not accepting the answer \"fl\" as longest common prefix ? \\nDid the question mention that either all strings in array have some common prefix or none ?\\n"
                    },
                    {
                        "username": "mazinho2",
                        "content": "prefix are letters that are added to the begging of the word. So common prefix means the sequence of letters that starts in common. Start, by which means from the beginning. Since the word \\'reflower\\' starts with the letter \\'r\\', those words don\\'t have common prefix.\\nThe question doesn\\'t say that all the elements of an array have common prefix, so we can\\'t suppose that there is neither. \\nWe have to program the function to find whether there is or not, and then, if there is, what is this common prefix."
                    },
                    {
                        "username": "niitk",
                        "content": "my solution is true, but allocation failure, why?"
                    }
                ]
            }
        ]
    },
    {
        "title": "Flatten Binary Tree to Linked List",
        "question_content": "<p>Given the <code>root</code> of a binary tree, flatten the tree into a &quot;linked list&quot;:</p>\n\n<ul>\n\t<li>The &quot;linked list&quot; should use the same <code>TreeNode</code> class where the <code>right</code> child pointer points to the next node in the list and the <code>left</code> child pointer is always <code>null</code>.</li>\n\t<li>The &quot;linked list&quot; should be in the same order as a <a href=\"https://en.wikipedia.org/wiki/Tree_traversal#Pre-order,_NLR\" target=\"_blank\"><strong>pre-order</strong><strong> traversal</strong></a> of the binary tree.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/14/flaten.jpg\" style=\"width: 500px; height: 226px;\" />\n<pre>\n<strong>Input:</strong> root = [1,2,5,3,4,null,6]\n<strong>Output:</strong> [1,null,2,null,3,null,4,null,5,null,6]\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = []\n<strong>Output:</strong> []\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> root = [0]\n<strong>Output:</strong> [0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[0, 2000]</code>.</li>\n\t<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n\n<p>&nbsp;</p>\n<strong>Follow up:</strong> Can you flatten the tree in-place (with <code>O(1)</code> extra space)?",
        "solutions": [
            {
                "id": 36977,
                "title": "my-short-post-order-traversal-java-solution-for-share",
                "content": "    private TreeNode prev = null;\\n\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right = prev;\\n        root.left = null;\\n        prev = root;\\n    }",
                "solutionTags": [],
                "code": "    private TreeNode prev = null;\\n\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right = prev;\\n        root.left = null;\\n        prev = root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37010,
                "title": "share-my-simple-non-recursive-solution-o-1-space-complexity",
                "content": "    class Solution {\\n    public:\\n        void flatten(TreeNode *root) {\\n    \\t\\tTreeNode*now = root;\\n    \\t\\twhile (now)\\n    \\t\\t{\\n    \\t\\t\\tif(now->left)\\n    \\t\\t\\t{\\n                    //Find current node's prenode that links to current node's right subtree\\n    \\t\\t\\t\\tTreeNode* pre = now->left;\\n    \\t\\t\\t\\twhile(pre->right)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tpre = pre->right;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tpre->right = now->right;\\n                    //Use current node's left subtree to replace its right subtree(original right \\n                    //subtree is already linked by current node's prenode\\n    \\t\\t\\t\\tnow->right = now->left;\\n    \\t\\t\\t\\tnow->left = NULL;\\n    \\t\\t\\t}\\n    \\t\\t\\tnow = now->right;\\n    \\t\\t}\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void flatten(TreeNode *root) {\\n    \\t\\tTreeNode*now = root;\\n    \\t\\twhile (now)\\n    \\t\\t{\\n    \\t\\t\\tif(now->left)\\n    \\t\\t\\t{\\n                    //Find current node's prenode that links to current node's right subtree\\n    \\t\\t\\t\\tTreeNode* pre = now->left;\\n    \\t\\t\\t\\twhile(pre->right)\\n    \\t\\t\\t\\t{\\n    \\t\\t\\t\\t\\tpre = pre->right;\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 37154,
                "title": "8-lines-of-python-solution-reverse-preorder-traversal",
                "content": "    def __init__(self):\\n        self.prev = None\\n        \\n    def flatten(self, root):\\n        if not root:\\n            return None\\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        \\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def __init__(self):\\n        self.prev = None\\n        \\n    def flatten(self, root):\\n        if not root:\\n            return None\\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        \\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root",
                "codeTag": "Python3"
            },
            {
                "id": 36987,
                "title": "straightforward-java-solution",
                "content": "    public void flatten(TreeNode root) {\\n            if (root == null) return;\\n            \\n            TreeNode left = root.left;\\n            TreeNode right = root.right;\\n            \\n            root.left = null;\\n            \\n            flatten(left);\\n            flatten(right);\\n            \\n            root.right = left;\\n            TreeNode cur = root;\\n            while (cur.right != null) cur = cur.right;\\n            cur.right = right;\\n        }\\n\\n\\nThis solution is based on recursion. We simply flatten left and right subtree and paste each sublist to the right child of the root. (don't forget to set left child to null)",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void flatten(TreeNode root) {\\n            if (root == null) return;\\n            \\n            TreeNode left = root.left;\\n            TreeNode right = root.right;\\n            \\n            root.left = null;\\n            \\n            flatten(left);\\n            flatten(right);\\n            \\n            root.right = left;\\n            TreeNode cur = root;\\n            while (cur.right != null) cur = cur.right;\\n            cur.right = right;\\n        }\\n\\n\\nThis solution is based on recursion. We simply flatten left and right subtree and paste each sublist to the right child of the root. (don't forget to set left child to null)",
                "codeTag": "Unknown"
            },
            {
                "id": 37000,
                "title": "8ms-non-recursive-no-stack-c-solution",
                "content": "    void flatten(TreeNode *root) {\\n\\t\\twhile (root) {\\n\\t\\t\\tif (root->left && root->right) {\\n\\t\\t\\t\\tTreeNode* t = root->left;\\n\\t\\t\\t\\twhile (t->right)\\n\\t\\t\\t\\t\\tt = t->right;\\n\\t\\t\\t\\tt->right = root->right;\\n\\t\\t\\t}\\n\\n            if(root->left)\\n\\t\\t\\t    root->right = root->left;\\n\\t\\t\\troot->left = NULL;\\n\\t\\t\\troot = root->right;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "    void flatten(TreeNode *root) {\\n\\t\\twhile (root) {\\n\\t\\t\\tif (root->left && root->right) {\\n\\t\\t\\t\\tTreeNode* t = root->left;\\n\\t\\t\\t\\twhile (t->right)\\n\\t\\t\\t\\t\\tt = t->right;\\n\\t\\t\\t\\tt->right = root->right;\\n\\t\\t\\t}\\n\\n            if(root->left)\\n\\t\\t\\t    root->right = root->left;\\n\\t\\t\\troot->left = NULL;\\n\\t\\t\\troot = root->right;\\n\\t\\t}\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 1208004,
                "title": "extremely-intuitive-o-1-space-solution-with-simple-explanation-python",
                "content": "The prospect of solving this problem in O(1) might look tricky in the beginning, but all you need to know is how preorder traversal works. \\nThe key intuition of this solution is to preserve the \"Pre-Order\" order as we go.\\n\\nSo we maintain a pointer `curr` while going down the tree. If `curr` has a left child, we want to shift it to the right while preserving the order. This will be two step process.\\nCreate another pointer `p` to find the right most point in the left subtree. Then we shift the contents of `curr.right` into `p.right`. The tree which we have right now (stage 2 in image) if you notice, still gives the exact same preorder traversal. So now we just shift this to the right of `curr`.\\n\\nMove `curr` to the right and repeat.\\n\\n![image](https://assets.leetcode.com/users/images/1c892c17-ff56-4740-8a81-47f40d38d36e_1620996109.3450835.png)\\n\\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        curr = root\\n        \\n        while curr:\\n            if curr.left != None:\\n                p = curr.left\\n                while p.right != None:\\n                    p = p.right\\n                    \\n                p.right = curr.right\\n                \\n                curr.right = curr.left\\n                curr.left = None\\n            \\n            curr = curr.right\\n ```\\n\\n**PS: This was my first ever solution submission. Please do upvote if you found it helpful and feel free to leave suggestions below.**\\n\\nThanks for stopping by!",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        curr = root\\n        \\n        while curr:\\n            if curr.left != None:\\n                p = curr.left\\n                while p.right != None:\\n                    p = p.right\\n                    \\n                p.right = curr.right\\n                \\n                curr.right = curr.left\\n                curr.left = None\\n            \\n            curr = curr.right\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 36991,
                "title": "accepted-simple-java-solution-iterative",
                "content": "it is DFS so u need a stack. Dont forget to set the left child to null, or u'll get TLE. (tricky!)\\n \\n\\n       public void flatten(TreeNode root) {\\n            if (root == null) return;\\n            Stack<TreeNode> stk = new Stack<TreeNode>();\\n            stk.push(root);\\n            while (!stk.isEmpty()){\\n                TreeNode curr = stk.pop();\\n                if (curr.right!=null)  \\n                     stk.push(curr.right);\\n                if (curr.left!=null)  \\n                     stk.push(curr.left);\\n                if (!stk.isEmpty()) \\n                     curr.right = stk.peek();\\n                curr.left = null;  // dont forget this!! \\n            }\\n        }",
                "solutionTags": [],
                "code": "it is DFS so u need a stack. Dont forget to set the left child to null, or u'll get TLE. (tricky!)\\n \\n\\n       public void flatten(TreeNode root) {\\n            if (root == null) return;\\n            Stack<TreeNode> stk = new Stack<TreeNode>();\\n            stk.push(root);\\n            while (!stk.isEmpty()){\\n                TreeNode curr = stk.pop();\\n                if (curr.right!=null)  \\n                     stk.push(curr.right);\\n                if (curr.left!=null)  \\n                     stk.push(curr.left);\\n                if (!stk.isEmpty()) \\n                     curr.right = stk.peek();\\n                curr.left = null;  // dont forget this!! \\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 1207642,
                "title": "js-python-java-c-simple-o-1-space-recursive-solutions-w-explanation",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n***Morris Traversal (O(1) Space, O(N) Time) Approach:***\\n\\nThere _is_ actually a way to traverse a binary tree with a **space complexity** of **O(1)** while staying at a **time complexity** of **O(N)**, though it does require modifying the tree\\'s structure. In this problem that\\'s specifically being called for, so it\\'s a valid approach, though it won\\'t always be appropriate to modify the source binary tree in other situations.\\n\\nThe approach is called the **Morris traversal**. At its heart, it takes advantage of the basic nature of ordered traversals to iterate through and unwind the tree. In a **pre-order traversal** of a binary tree, each vertex is processed in **(node, left, right)** order. This means that the entire left subtree could be placed between the node and its right subtree.\\n\\nTo do this, however, we\\'ll first have to locate the last node in the left subtree. This is easy enough, since we know that the last node of a pre-order tree can be found by moving right as many times as possible from its root.\\n\\nSo we should be able to move through the binary tree, keeping track of the curent node (**curr**). Whenever we find a left subtree, we can dispatch a **runner** to find its last node, then stitch together both ends of the left subtree into the right path of **curr**, taking heed to sever the left connection at **curr**.\\n\\nOnce that\\'s done, we can continue to move **curr** to the right, looking for the next left subtree. When **curr** can no longer move right, the tree will be successfully flattened.\\n\\n![Morris Traversal Visual](https://i.imgur.com/sqnrz9m.gif)\\n\\n - _**Time Complexity: O(N)** where **N** is the number of **nodes** in the binary tree_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n***O(1) Space Approach:***\\n\\nIn order to properly connect the **linked list**, we\\'ll need to start at the bottom and work up. This means that we\\'ll need to move in _reverse_ **pre-order traversal** order through the **binary tree**. Since pre-order traversal is normally **\"node, left, right\"**, we\\'ll have to move in the reverse order of **\"right, left, node\"**.\\n\\nIn order to complete this solution in **O(1) space**, we won\\'t be able to conveniently backtrack via a **stack**, so the key to this solution will be to retreat all the way back up to the **root** each time we reach a leaf. This will push the **time complexity** to **O(N^2)**.\\n\\nWe\\'ll want to first set up **head** and **curr** to keep track of the head of the linked list we\\'re building and the current node we\\'re visiting. We\\'ll know we\\'re finished once **head = root**.\\n\\nTo follow the reverse pre-order traversal order, we\\'ll first attempt to go right and then left. Since we\\'re backtracking to **root**, however, we\\'ll eventually run back into the same node that we\\'ve set as **head** doing this. To prevent this, we\\'ll stop _before_ moving to the **head** node and sever the connection.\\n\\nNow that we can\\'t run into already-completed territory, we can be confident that any leaf we move to must be the next value for **head**, so we should connect it to the old **head**, update **head**, and reset back to the **root**.\\n\\nAs noted before, once **head = root**, we\\'ve finished our traversal and can exit the function.\\n\\n - _**Time Complexity: O(N^2)** where **N** is the number of **nodes** in the binary tree, due to repeated backtracking to root_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n***Recursive Approach:***\\n\\nIn order to properly connect the **linked list**, we\\'ll need to start at the bottom and work up. This means that we\\'ll need to move in _reverse_ **pre-order traversal** order through the **binary tree**. Since pre-order traversal is normally **\"node, left, right\"**, we\\'ll have to move in the reverse order of **\"right, left, node\"**.\\n\\nBinary tree traversal is prime ground for a **recursive** solution, so let\\'s define a helper (**revPreOrder**) for the purpose. We\\'ll also keep a global variable **head** to keep track of the head of the linked list as we work our way backwards.\\n\\nPer our reverse pre-order traversal approach, we want to recursively work down the right path first then the left path, if they exist. Once we\\'ve flattened the left and right paths recursively, **head** should at this point be equal to the next node after the current one, so we should set it as **node.right**. We shouldn\\'t forget to set **node.left** to **null**, as well.\\n\\nOnce we\\'re done with the current node, we can update **head** to **node** and allow the recursion to complete and move back up to the next layer. Once the recursion stack is exhausted, **head** will be equal to **root** again.\\n\\nLastly, we have to deal with an edge case of an empty **root**, so we can just make sure to only call the initial recursion on **root** if **root** actually is a node. There is no need for a **return** statement, because the test suite will evaluate **root** directly.\\n\\n - _**Time Complexity: O(N)** where **N** is the number of **nodes** in the binary tree_\\n - _**Space Complexity: O(N)** for the **recursion stack**, which is as long as the maximum depth of the binary tree, which can go up to **N**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **84ms / 40.6MB** (beats 96% / 66%).\\n```javascript\\nvar flatten = function(root) {\\n    let curr = root\\n    while (curr) {\\n        if (curr.left) {\\n            let runner = curr.left\\n            while (runner.right) runner = runner.right\\n            runner.right = curr.right, curr.right = curr.left, curr.left = null\\n        }\\n        curr = curr.right\\n    }\\n};\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **80ms / 40.6MB** (beats 98% / 66%).\\n```javascript\\nvar flatten = function(root) {\\n    let head = null, curr = root\\n    while (head != root) {\\n        if (curr.right === head) curr.right = null\\n        if (curr.left === head) curr.left = null\\n        if (curr.right) curr = curr.right\\n        else if (curr.left) curr = curr.left\\n        else curr.right = head, head = curr, curr = root\\n    }\\n};\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **84ms / 40.6MB** (beats 96% / 66%).\\n```javascript\\nvar flatten = function(root) {\\n    let head = null\\n    const revPreOrder = node => {\\n        if (node.right) revPreOrder(node.right)\\n        if (node.left) revPreOrder(node.left)\\n        node.left = null, node.right = head, head = node\\n    }\\n    if (root) revPreOrder(root)\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **32ms / 15.0MB** (beats 92% / 91%).\\n```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        curr = root\\n        while curr:\\n            if curr.left:\\n                runner = curr.left\\n                while runner.right: runner = runner.right\\n                runner.right, curr.right, curr.left = curr.right, curr.left, None\\n            curr = curr.right\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **32ms / 15.0MB** (beats 92% / 91%).\\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        head, curr = None, root\\n        while head != root:\\n            if curr.right == head: curr.right = None\\n            if curr.left == head: curr.left = None\\n            if curr.right: curr = curr.right\\n            elif curr.left: curr = curr.left\\n            else: curr.right, head, curr = head, curr, root\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **28ms / 14.9MB** (beats 98% / 98%).\\n```python\\nclass Solution:\\n    head = None\\n    def flatten(self, root: TreeNode) -> None:\\n        def revPreOrder(node: TreeNode) -> None:\\n            if node.right: revPreOrder(node.right)\\n            if node.left: revPreOrder(node.left)\\n            node.left, node.right, self.head = None, self.head, node\\n        if root: revPreOrder(root)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **0ms / 37.9MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode curr = root;\\n        while (curr != null) {\\n            if (curr.left != null) {\\n                TreeNode runner = curr.left;\\n                while (runner.right != null) runner = runner.right;\\n                runner.right = curr.right;\\n                curr.right = curr.left;\\n                curr.left = null;\\n            }\\n            curr = curr.right;\\n        }\\n    }\\n}\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **0ms / 37.9MB** (beats 100% / 98%).\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode head = null, curr = root;\\n        while (head != root) {\\n            if (curr.right == head) curr.right = null;\\n            if (curr.left == head) curr.left = null;\\n            if (curr.right != null) curr = curr.right;\\n            else if (curr.left != null) curr = curr.left;\\n            else {\\n                curr.right = head;\\n                head = curr;\\n                curr = root;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **0ms / 38.0MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    TreeNode head = null;\\n    public void flatten(TreeNode root) {\\n        if (root != null) revPreOrder(root);\\n    }\\n    private void revPreOrder(TreeNode node) {\\n        if (node.right != null) revPreOrder(node.right);\\n        if (node.left != null) revPreOrder(node.left);\\n        node.left = null;\\n        node.right = head;\\n        head = node;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **0ms / 12.6MB** (beats 100% / 95%).\\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while (curr) {\\n            if (curr->left) {\\n                TreeNode* runner = curr->left;\\n                while (runner->right != nullptr) runner = runner->right;\\n                runner->right = curr->right, curr->right = curr->left, curr->left = nullptr;\\n            }\\n            curr = curr->right;\\n        }\\n    }\\n};\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **0ms / 12.6MB** (beats 100% / 95%).\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode *head = nullptr, *curr = root;\\n        while (head != root) {\\n            if (curr->right == head) curr->right = nullptr;\\n            if (curr->left == head) curr->left = nullptr;\\n            if (curr->right) curr = curr->right;\\n            else if (curr->left) curr = curr->left;\\n            else curr->right = head, head = curr, curr = root;\\n        }\\n    }\\n};\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **0ms / 12.6MB** (beats 100% / 95%).\\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if (root) revPreOrder(root);\\n    }\\nprivate:\\n    TreeNode* head = nullptr;\\n    void revPreOrder(TreeNode* node) {\\n        if (node->right) revPreOrder(node->right);\\n        if (node->left) revPreOrder(node->left);\\n        node->left = nullptr, node->right = head, head = node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "JavaScript"
                ],
                "code": "```javascript\\nvar flatten = function(root) {\\n    let curr = root\\n    while (curr) {\\n        if (curr.left) {\\n            let runner = curr.left\\n            while (runner.right) runner = runner.right\\n            runner.right = curr.right, curr.right = curr.left, curr.left = null\\n        }\\n        curr = curr.right\\n    }\\n};\\n```\n```javascript\\nvar flatten = function(root) {\\n    let head = null, curr = root\\n    while (head != root) {\\n        if (curr.right === head) curr.right = null\\n        if (curr.left === head) curr.left = null\\n        if (curr.right) curr = curr.right\\n        else if (curr.left) curr = curr.left\\n        else curr.right = head, head = curr, curr = root\\n    }\\n};\\n```\n```javascript\\nvar flatten = function(root) {\\n    let head = null\\n    const revPreOrder = node => {\\n        if (node.right) revPreOrder(node.right)\\n        if (node.left) revPreOrder(node.left)\\n        node.left = null, node.right = head, head = node\\n    }\\n    if (root) revPreOrder(root)\\n};\\n```\n```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        curr = root\\n        while curr:\\n            if curr.left:\\n                runner = curr.left\\n                while runner.right: runner = runner.right\\n                runner.right, curr.right, curr.left = curr.right, curr.left, None\\n            curr = curr.right\\n```\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        head, curr = None, root\\n        while head != root:\\n            if curr.right == head: curr.right = None\\n            if curr.left == head: curr.left = None\\n            if curr.right: curr = curr.right\\n            elif curr.left: curr = curr.left\\n            else: curr.right, head, curr = head, curr, root\\n```\n```python\\nclass Solution:\\n    head = None\\n    def flatten(self, root: TreeNode) -> None:\\n        def revPreOrder(node: TreeNode) -> None:\\n            if node.right: revPreOrder(node.right)\\n            if node.left: revPreOrder(node.left)\\n            node.left, node.right, self.head = None, self.head, node\\n        if root: revPreOrder(root)\\n```\n```java\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode curr = root;\\n        while (curr != null) {\\n            if (curr.left != null) {\\n                TreeNode runner = curr.left;\\n                while (runner.right != null) runner = runner.right;\\n                runner.right = curr.right;\\n                curr.right = curr.left;\\n                curr.left = null;\\n            }\\n            curr = curr.right;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode head = null, curr = root;\\n        while (head != root) {\\n            if (curr.right == head) curr.right = null;\\n            if (curr.left == head) curr.left = null;\\n            if (curr.right != null) curr = curr.right;\\n            else if (curr.left != null) curr = curr.left;\\n            else {\\n                curr.right = head;\\n                head = curr;\\n                curr = root;\\n            }\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    TreeNode head = null;\\n    public void flatten(TreeNode root) {\\n        if (root != null) revPreOrder(root);\\n    }\\n    private void revPreOrder(TreeNode node) {\\n        if (node.right != null) revPreOrder(node.right);\\n        if (node.left != null) revPreOrder(node.left);\\n        node.left = null;\\n        node.right = head;\\n        head = node;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while (curr) {\\n            if (curr->left) {\\n                TreeNode* runner = curr->left;\\n                while (runner->right != nullptr) runner = runner->right;\\n                runner->right = curr->right, curr->right = curr->left, curr->left = nullptr;\\n            }\\n            curr = curr->right;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode *head = nullptr, *curr = root;\\n        while (head != root) {\\n            if (curr->right == head) curr->right = nullptr;\\n            if (curr->left == head) curr->left = nullptr;\\n            if (curr->right) curr = curr->right;\\n            else if (curr->left) curr = curr->left;\\n            else curr->right = head, head = curr, curr = root;\\n        }\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if (root) revPreOrder(root);\\n    }\\nprivate:\\n    TreeNode* head = nullptr;\\n    void revPreOrder(TreeNode* node) {\\n        if (node->right) revPreOrder(node->right);\\n        if (node->left) revPreOrder(node->left);\\n        node->left = nullptr, node->right = head, head = node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338791,
                "title": "c-explained",
                "content": "**UPVOTE IF HELPFuuL**\\n\\n**APPROACH -> O ( N ) SPACE**\\nBy using brute force, we can traverse the tree in ```preorder manner``` and store the result in a vector.\\nLater using that vector , we can arrange nodes, such as \\n```\\nvector[i] -> right = vector[i+1];\\nvector[i] -> left = NULL;\\n```\\n\\n**APPROACH -> O ( 1 ) SPACE**\\n\\n* From the diagram given , it can be seen all nodes are present on the right.\\n* All the nodes in ```left subtree``` come before the nodes in ```right subtree```.\\n\\n**For each node ```i```**\\n* IF there is no left node  -> move to next right node.\\n* IF **LEFT IS PRESENT**  ->\\n* * Store the right subtree\\n* * ADD left subtree to right of root,\\n* * Now add the stored right subtree to the rightmost node of current tree.\\n* Also make ```node -> left =NULL```.\\n\\n![image](https://assets.leetcode.com/users/images/e6d4b1fa-b7ec-4056-a6ba-27a8fb5ea60b_1658887502.7798896.png)\\n\\n\\n**UPVOTE IF HELPFuuL**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* rightmost(TreeNode* root){\\n        if (root->right==NULL) return root;\\n        return rightmost(root->right);\\n    }\\n    \\n    void flatten(TreeNode* root) {\\n        if (root==NULL) return;\\n        TreeNode* nextright;\\n        TreeNode* rightMOST;\\n        \\n        while (root){\\n            \\n            if (root->left){\\n                rightMOST = rightmost(root->left);\\n                nextright = root->right;\\n                root->right = root->left;\\n                root->left=NULL;\\n                rightMOST->right=nextright;\\n            }\\n            root=root->right;\\n        }\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/d3c7d6b7-7333-4f6f-8630-54539795ee1f_1658886001.4640927.jpeg)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```preorder manner```\n```\\nvector[i] -> right = vector[i+1];\\nvector[i] -> left = NULL;\\n```\n```left subtree```\n```right subtree```\n```i```\n```node -> left =NULL```\n```\\nclass Solution {\\npublic:\\n    \\n    TreeNode* rightmost(TreeNode* root){\\n        if (root->right==NULL) return root;\\n        return rightmost(root->right);\\n    }\\n    \\n    void flatten(TreeNode* root) {\\n        if (root==NULL) return;\\n        TreeNode* nextright;\\n        TreeNode* rightMOST;\\n        \\n        while (root){\\n            \\n            if (root->left){\\n                rightMOST = rightmost(root->left);\\n                nextright = root->right;\\n                root->right = root->left;\\n                root->left=NULL;\\n                rightMOST->right=nextright;\\n            }\\n            root=root->right;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 288414,
                "title": "c-solution-beats-100",
                "content": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if( root )\\n        {\\n            /*Move the left node to the right node*/\\n            TreeNode* temp = root->right;\\n            root->right = root->left;\\n            root->left = nullptr;\\n            TreeNode* node = root;\\n            \\n            /*Move to the end of the prev left node which is the new right node*/\\n            while( node->right )\\n            {\\n                node = node->right;\\n            }\\n            \\n            /*Append the right node to its end*/\\n            node->right = temp;\\n            flatten( root->right ); \\n        } \\n        return;\\n               \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if( root )\\n        {\\n            /*Move the left node to the right node*/\\n            TreeNode* temp = root->right;\\n            root->right = root->left;\\n            root->left = nullptr;\\n            TreeNode* node = root;\\n            \\n            /*Move to the end of the prev left node which is the new right node*/\\n            while( node->right )\\n            {\\n                node = node->right;\\n            }\\n            \\n            /*Append the right node to its end*/\\n            node->right = temp;\\n            flatten( root->right ); \\n        } \\n        return;\\n               \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37223,
                "title": "share-my-accepted-recursive-solution-with-comments-java",
                "content": "The idea is very simple:\\n\\n1. flatten left subtree\\n\\n2. flatten right subtree\\n\\n3. concatenate root -> left flatten subtree -> right flatten subtree\\n\\n        public void flatten(TreeNode root) {\\n            if(root == null)\\n        \\treturn;\\n        \\t\\n            flatten(root.left);\\n            flatten(root.right);\\n        \\n            // save current right for concatination\\n            TreeNode right = root.right;\\n        \\n            if(root.left != null) {\\n            \\n                // step 1: concatinate root with left flatten subtree\\n            \\troot.right = root.left;\\n            \\troot.left = null; // set left to null\\n        \\t\\n            \\t// step 2: move to the end of new added flatten subtree\\n            \\twhile(root.right != null)\\n            \\t\\troot = root.right;\\n        \\t\\t\\n            \\t// step 3: contatinate left flatten subtree with flatten right subtree\\t\\n            \\troot.right = right;\\n            }\\n        }",
                "solutionTags": [
                    "Java"
                ],
                "code": "The idea is very simple:\\n\\n1. flatten left subtree\\n\\n2. flatten right subtree\\n\\n3. concatenate root -> left flatten subtree -> right flatten subtree\\n\\n        public void flatten(TreeNode root) {\\n            if(root == null)\\n        \\treturn;\\n        \\t\\n            flatten(root.left);\\n            flatten(root.right);\\n        \\n            // save current right for concatination\\n            TreeNode right = root.right;\\n        \\n            if(root.left != null) {\\n            \\n                // step 1: concatinate root with left flatten subtree\\n            \\troot.right = root.left;\\n            \\troot.left = null; // set left to null\\n        \\t\\n            \\t// step 2: move to the end of new added flatten subtree\\n            \\twhile(root.right != null)\\n            \\t\\troot = root.right;\\n        \\t\\t\\n            \\t// step 3: contatinate left flatten subtree with flatten right subtree\\t\\n            \\troot.right = right;\\n            }\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 37182,
                "title": "my-recursive-solution-is-easy-and-clean",
                "content": "    void flatten(TreeNode* root) {\\n        if (!root) return;\\n        flatten(root->left);\\n        flatten(root->right);\\n        TreeNode *tmp = root->right;\\n        root->right = root->left;\\n        root->left = nullptr;\\n        while (root->right)\\n            root = root->right;\\n        root->right = tmp;\\n    }",
                "solutionTags": [],
                "code": "    void flatten(TreeNode* root) {\\n        if (!root) return;\\n        flatten(root->left);\\n        flatten(root->right);\\n        TreeNode *tmp = root->right;\\n        root->right = root->left;\\n        root->left = nullptr;\\n        while (root->right)\\n            root = root->right;\\n        root->right = tmp;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 36984,
                "title": "an-inorder-python-solution",
                "content": "    class Solution:\\n    # @param root, a tree node\\n    # @return nothing, do it in place\\n    prev = None\\n    def flatten(self, root):\\n        if not root:\\n            return\\n        self.prev = root\\n        self.flatten(root.left)\\n\\n        temp = root.right\\n        root.right, root.left = root.left, None\\n        self.prev.right = temp\\n\\n        self.flatten(temp)\\n\\n\\n\\n             *\\n           /\\n          n\\n       /     \\\\\\n     left   right\\n      \\\\ \\n       *\\n        *\\n         \\\\\\n          p\\n\\n\\nThe idea is very simple. Suppose n is the current visiting node, and p is the previous node of preorder traversal to n.right.\\n\\nWe just need to do the inorder replacement:\\n\\nn.left -> NULL\\n\\nn.right - > n.left\\n\\np->right -> n.right",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n    # @param root, a tree node\\n    # @return nothing, do it in place\\n    prev = None\\n    def flatten(self, root):\\n        if not root:\\n            return\\n        self.prev = root\\n        self.flatten(root.left)\\n\\n        temp = root.right\\n        root.right, root.left = root.left, None\\n        self.prev.right = temp\\n\\n        self.flatten(temp)\\n\\n\\n\\n             *\\n           /\\n          n\\n       /     \\\\\\n     left   right\\n      \\\\ \\n       *\\n        *\\n         \\\\\\n          p\\n\\n\\nThe idea is very simple. Suppose n is the current visiting node, and p is the previous node of preorder traversal to n.right.\\n\\nWe just need to do the inorder replacement:\\n\\nn.left -> NULL\\n\\nn.right - > n.left\\n\\np->right -> n.right",
                "codeTag": "Java"
            },
            {
                "id": 2338861,
                "title": "java-easy-solution-with-explanation",
                "content": "PLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n    TreeNode prev=null;\\n    public void flatten(TreeNode root) {\\n         if(root==null)\\n            return;\\n        flatten(root.right);//traverse till right most.\\n        flatten(root.left);//got to left of right most\\n       root.left=null;//set left as null\\n        root.right=prev;//set right to previously traversed node\\n        prev=root;  //set prev to current node.\\n    }\\n    \\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev=null;\\n    public void flatten(TreeNode root) {\\n         if(root==null)\\n            return;\\n        flatten(root.right);//traverse till right most.\\n        flatten(root.left);//got to left of right most\\n       root.left=null;//set left as null\\n        root.right=prev;//set right to previously traversed node\\n        prev=root;  //set prev to current node.\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37065,
                "title": "simple-dfs-python-solution",
                "content": "'''\\n\\n    def flatten(self, root):\\n        last=TreeNode(-1)\\n        qstack=[root]\\n        while qstack:\\n            node=qstack.pop()\\n            last.right=node\\n            last.left=None\\n            if node and node.right:\\n                qstack.append(node.right)\\n            if node and node.left:\\n                qstack.append(node.left)\\n            last=node\\n        '''",
                "solutionTags": [],
                "code": "'''\\n\\n    def flatten(self, root):\\n        last=TreeNode(-1)\\n        qstack=[root]\\n        while qstack:\\n            node=qstack.pop()\\n            last.right=node\\n            last.left=None\\n            if node and node.right:\\n                qstack.append(node.right)\\n            if node and node.left:\\n                qstack.append(node.left)\\n            last=node\\n        '''",
                "codeTag": "Python3"
            },
            {
                "id": 1067000,
                "title": "c-both-recursive-iterative-solution",
                "content": "**Recursive Solution**\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL){\\n            return;\\n        }\\n        flatten(root->left);\\n        flatten(root->right);\\n        if(root->left){\\n            TreeNode *right = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            while(root->right) root = root->right;\\n            root->right = right;\\n        }\\n    }\\n};\\n```\\n**Iterative Solution (Concept of Morris  Treversal)**\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL){\\n            return;\\n        }\\n        TreeNode *curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode *pre = curr->left;\\n                while(pre->right){\\n                    pre = pre->right;\\n                }\\n                pre->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n            }\\n            curr = curr->right;\\n        }\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL){\\n            return;\\n        }\\n        flatten(root->left);\\n        flatten(root->right);\\n        if(root->left){\\n            TreeNode *right = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            while(root->right) root = root->right;\\n            root->right = right;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL){\\n            return;\\n        }\\n        TreeNode *curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode *pre = curr->left;\\n                while(pre->right){\\n                    pre = pre->right;\\n                }\\n                pre->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n            }\\n            curr = curr->right;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37185,
                "title": "c-solution-using-recursion",
                "content": "Recursively add the left subtree to the right subtree.\\n\\n    class Solution {\\n    public:\\n        void flatten(TreeNode* root) {\\n            if (!root) return;\\n            flatten(root->left);\\n            flatten(root->right);\\n            if (root->left) {\\n                TreeNode* right = root->right;\\n                root->right = root->left;\\n                root->left = NULL;\\n                while (root->right) root = root->right;\\n                root->right = right;\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void flatten(TreeNode* root) {\\n            if (!root) return;\\n            flatten(root->left);\\n            flatten(root->right);\\n            if (root->left) {\\n                TreeNode* right = root->right;\\n                root->right = root->left;\\n                root->left = NULL;\\n                while (root->right) root = root->right;\\n                root->right = right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2338948,
                "title": "explanation-so-far",
                "content": "How\\'s going **Ladies-N-Gentlemen** today we are going to solve another super question i.e. **`Flatten Binary Tree to LinkedList`**\\n\\nWell, if you look at the question, you\\'ll see that the **Linked List** has to be in **`preorder Traversal`**\\n\\nSo, if you know what **preorder** is then, you are good to go. A quick recap about preorder is, First we traverse to it\\'s **`root`** then **`left`** and then **`right`** \\n\\n**Let\\'s take an example to understand it.**\\n```\\nInput: root = [1,2,5,3,4,null,6]\\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\\n```\\n![image](https://assets.leetcode.com/users/images/6cfa9324-7354-462a-945b-b56fc7bb1234_1658888844.9633684.png)\\n\\nNow, you have got the idea, let\\'s see how we can solve this problem,\\n```\\nThe first method We gonna use is # RECURSION\\n```\\nSo, let\\'s take a very small example to understand it.\\n![image](https://assets.leetcode.com/users/images/6e1ce458-d168-4612-9633-75d0602fe5e3_1658889692.5058572.png)\\n\\nThis is about the smaller tree of 3 nodes, but what if we are given a **bigger tree??**\\n\\n```\\nSo, for that one what we gonna do is, instead of removing and attaching every single time, we gonna have 2 trees\\n> Left temporary tree\\n> Right temporary tree\\nAnd we gonna flatten these 2 trees and attach to right. \\nTo flatten them we gonna use the help of recursion.\\n```\\nNow let\\'s see what new steps would be.\\n1.  We\\'ll take `temp variable` to store **left** & **right** node.\\n\\n\\n2.  Then, **left** will be point to **null**.\\n3. Now, after this we going to `flatten left & right tree` **(recursively)**\\n4.  After this we attach **left part** to **right** side\\n5.  In the last we gonna traverse the bottom most node in the attached part and attached the right it. \\n\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n        // step-1\\n        TreeNode Left = root.left;\\n        TreeNode Right = root.right;\\n\\t\\t\\n        // step-2\\n        root.left = null;\\n\\t\\t\\n        // step-3\\n        flatten(Left);\\n        flatten(Right);\\n        root.right = Left;\\n        TreeNode curr = root;\\n\\t\\t\\n        // step-4\\n        while(curr.right != null) curr = curr.right;\\n\\t\\t\\n        // step-5\\n        curr.right = Right;\\n    }\\n}\\n```\\nANALYSIS:-\\n* **Time Complexity :-** **`BigO(N^2)`**\\n\\n\\n* **Space Complexity :-** **`BigO(height)`**\\n\\n<hr>\\n<hr>\\n\\nNow, let\\'s talk about how we gonna reduce the space to **`O(1)`** as given in the question. To do that we gonna use,\\n```\\n# Morris Traversal\\n```\\n\\n<hr>\\n<hr>\\n\\n**To, understand this let\\'s take an example,**\\n![image](https://assets.leetcode.com/users/images/eee65480-fea1-4079-85a9-6c6de8dc42eb_1658891178.0858386.png)\\n\\n```\\n> So, in this we start from root.\\n> Then we check if it\\'s left doesn\\'t pointing to null, then go to it\\'s right most node and attach it\\'s right to become the root of my tree\\n> Let\\'s see what I\\'m talking about.\\n```\\n![image](https://assets.leetcode.com/users/images/5c630b01-605f-4bc0-a983-5b6f4d02e23a_1658891493.5801342.png)\\n\\nSo, as you can see now if I traverse the tree from **`1-->2-->3-->4-->5-->6`** as you can see now, after **4** am not going back again to **1** as my **4** node is pointing to **5**, so that\\'s how we are not using any extra space\\n\\n```\\n> After doing that, I\\'ll remove the root pointer and left of my root becomes null & right of my root will become this left tree.\\n> Let\\'s see how\\'s it goes like,\\n```\\n![image](https://assets.leetcode.com/users/images/1e74a472-93bd-49f4-8b2d-ae6e45d8ce29_1658891790.6077545.png)\\n\\n```\\nNow, again we going to repeat the same process,\\n> Check left,\\n> If not null, go to it\\'s right most child\\n> Connect it root to right\\n> Connect the whole left to root->right\\n> Make root->left = null\\n> Update root to root->right\\n```\\n![image](https://assets.leetcode.com/users/images/46b58209-89b5-48c1-a069-3f2b3f3681f0_1658892258.929328.png)\\n\\n**Now as you can see our tree has all the nodes on it\\'s right, now flatten this out and look:**\\n\\n![image](https://assets.leetcode.com/users/images/2078deee-9324-48f6-b0c3-c9ba9bf7bcde_1658892492.4848144.png)\\n```\\nAnd we\\'ll complete the process till the end, although \"3\" doesn\\'t have it\\'s left but we still go to it\\'s right and complete the process till the end. \\n```\\n\\n**Now. let\\'s code it up:-**\\n\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n        while(root != null){\\n            if(root.left != null) {\\n                TreeNode Left = root.left;\\n                TreeNode curr = Left;\\n                while(curr.right != null) curr = curr.right;\\n                curr.right = root.right;  // Morris Traversal main step\\n                root.left =null;\\n                root.right = Left;\\n            }\\n            root = root.right;  \\n        }\\n    }\\n}\\n```\\nANALYSIS :-\\n* **Time Complexity :-** **`BigO(N)`**\\n\\n* **Space Complexity :-** **`BigO(1)`**",
                "solutionTags": [],
                "code": "```\\nInput: root = [1,2,5,3,4,null,6]\\nOutput: [1,null,2,null,3,null,4,null,5,null,6]\\n```\n```\\nThe first method We gonna use is # RECURSION\\n```\n```\\nSo, for that one what we gonna do is, instead of removing and attaching every single time, we gonna have 2 trees\\n> Left temporary tree\\n> Right temporary tree\\nAnd we gonna flatten these 2 trees and attach to right. \\nTo flatten them we gonna use the help of recursion.\\n```\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n        // step-1\\n        TreeNode Left = root.left;\\n        TreeNode Right = root.right;\\n\\t\\t\\n        // step-2\\n        root.left = null;\\n\\t\\t\\n        // step-3\\n        flatten(Left);\\n        flatten(Right);\\n        root.right = Left;\\n        TreeNode curr = root;\\n\\t\\t\\n        // step-4\\n        while(curr.right != null) curr = curr.right;\\n\\t\\t\\n        // step-5\\n        curr.right = Right;\\n    }\\n}\\n```\n```\\n# Morris Traversal\\n```\n```\\n> So, in this we start from root.\\n> Then we check if it\\'s left doesn\\'t pointing to null, then go to it\\'s right most node and attach it\\'s right to become the root of my tree\\n> Let\\'s see what I\\'m talking about.\\n```\n```\\n> After doing that, I\\'ll remove the root pointer and left of my root becomes null & right of my root will become this left tree.\\n> Let\\'s see how\\'s it goes like,\\n```\n```\\nNow, again we going to repeat the same process,\\n> Check left,\\n> If not null, go to it\\'s right most child\\n> Connect it root to right\\n> Connect the whole left to root->right\\n> Make root->left = null\\n> Update root to root->right\\n```\n```\\nAnd we\\'ll complete the process till the end, although \"3\" doesn\\'t have it\\'s left but we still go to it\\'s right and complete the process till the end. \\n```\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n        while(root != null){\\n            if(root.left != null) {\\n                TreeNode Left = root.left;\\n                TreeNode curr = Left;\\n                while(curr.right != null) curr = curr.right;\\n                curr.right = root.right;  // Morris Traversal main step\\n                root.left =null;\\n                root.right = Left;\\n            }\\n            root = root.right;  \\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37181,
                "title": "easy-1ms-java-dfs-solution",
                "content": "     public class Solution {\\n        public void flatten(TreeNode root) {\\n            if(root==null)\\n                return;\\n            flatten(root.left);\\n            flatten(root.right);\\n            TreeNode left  = root.left;\\n            TreeNode right = root.right;\\n            root.left  = null;\\n            root.right = left; \\n            while(root.right!=null)\\n                root = root.right;\\n            root.right = right;\\n        }\\n    \\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public void flatten(TreeNode root) {\\n            if(root==null)\\n                return;\\n            flatten(root.left);\\n            flatten(root.right);\\n            TreeNode left  = root.left;\\n            TreeNode right = root.right;\\n            root.left  = null;\\n            root.right = left; \\n            while(root.right!=null)\\n                root = root.right;\\n            root.right = right;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 37227,
                "title": "python-easy-to-understand-recursive-solution-with-explaination",
                "content": "We can solve this problem recursively, suppose we already flattened the left part of the root, then we need set it as the right child of the root (the previous right child of the root should be preserved first by using a temp variable before this operation), after that, the previous right child is connected to the right most of the flattened left child. Don't forget to set the left child of root to None after these operations.\\n\\n    def flatten(self, root):\\n        while root:\\n            if root.left:\\n                self.flatten(root.left)\\n                node1 = root.left\\n                while node1.right:\\n                    node1 = node1.right\\n                node2 = root.right\\n                root.right = root.left\\n                root.left = None\\n                node1.right = node2\\n            root = root.right",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "We can solve this problem recursively, suppose we already flattened the left part of the root, then we need set it as the right child of the root (the previous right child of the root should be preserved first by using a temp variable before this operation), after that, the previous right child is connected to the right most of the flattened left child. Don't forget to set the left child of root to None after these operations.\\n\\n    def flatten(self, root):\\n        while root:\\n            if root.left:\\n                self.flatten(root.left)\\n                node1 = root.left\\n                while node1.right:\\n                    node1 = node1.right\\n                node2 = root.right\\n                root.right = root.left\\n                root.left = None\\n                node1.right = node2\\n            root = root.right",
                "codeTag": "Python3"
            },
            {
                "id": 2340103,
                "title": "two-different-approaches-faster-than-100-with-detailed-explanation-java",
                "content": "**Approach 1 - Intuition** \\n\\nIf we look at the flattened binary tree closely, we\\'ll notice that if we traverse it in the reverse way `[6 -> 5 -> 4 -> 3 -> 2 -> 1]`, it\\'s actually in `(right -> left -> root)` order.\\nThus, we\\'ll traverse the tree in the above order and set each node\\'s right pointer to the previous node we encountered and set the left pointer to null. \\n\\nFor keeping track of the previous node during recursion, rather than having a global variable we\\'ll create a helper function `flattenHelper` and keep an extra argument `prev`.\\n\\n**Pro interview tip: Try to avoid global variables as much as possible!**\\n\\nNow, let\\'s look at the code.\\n\\n```\\n/*\\n    Recursive Solution\\n    ------------------\\n    Time complexity: O(N)\\n    Space complexity: O(N) -> Stack space\\n*/\\n\\nclass Solution {\\n    public TreeNode flattenHelper(TreeNode root, TreeNode prev) {\\n        // base case\\n        if (root == null)\\n            return prev;\\n        \\n        // hypothesis step\\n        TreeNode right = flattenHelper(root.right, prev);\\n\\t\\t// for left subtree prev would be the node that we get from the right subtree recursion\\n        TreeNode left = flattenHelper(root.left, right);\\n        \\n        // induction step\\n        root.right = left;\\n        root.left = null;\\n        \\n        return root;\\n    }\\n    \\n    public void flatten(TreeNode root) {\\n        flattenHelper(root, null);\\n    }\\n}\\n```\\n\\n`Now, while doing a dry run of the above solution, I noticed we\\'re actually connecting the rightmost child of left subtree to root.right.\\nThis led me to my next solution which takes O(1) space i.e it\\'s truly inplace.\\n`\\n\\n**Approach 2 - Intuition**\\n\\nThe essence of this solution is that we somehow need to make sure that we keep the preorder traversal intact. To achieve this we\\'ll do the following things:\\n1. If the *left child* exists, we\\'ll find the *rightmost* node in the *left subtree*\\n2. We\\'ll connect this *rightmost* node to *root.right* \\n3. Now, move the *left subtree* to the *right* and set *root.left = null*\\n\\nCheck out the below image for better understanding.\\n![image](https://assets.leetcode.com/users/images/754eb32a-60b8-4621-a10e-8baf46c5a035_1658904185.3068984.jpeg)\\n\\n```\\n/*\\n    Iterative Solution - Inplace\\n    ----------------------------\\n    Time complexity: O(N)\\n    Space complexity: O(1)\\n*/\\n\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        while (root != null) {\\n            if (root.left != null) {\\n                TreeNode prev = root.left;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Find the rightmost node in left subtree\\n                while (prev.right != null)\\n                    prev = prev.right;\\n                \\n                prev.right = root.right;\\n                root.right = root.left;\\n                root.left = null;\\n            }\\n            \\n            root = root.right;\\n        }\\n    }\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/d79c690d-c55e-45f1-9da9-8b94e0481ba2_1658909740.5143886.png)\\n\\n\\n**Thank you for reading, do UPVOTE if you like ~(^-^)~.\\nIf you have any questions, feel free to ask.**",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n/*\\n    Recursive Solution\\n    ------------------\\n    Time complexity: O(N)\\n    Space complexity: O(N) -> Stack space\\n*/\\n\\nclass Solution {\\n    public TreeNode flattenHelper(TreeNode root, TreeNode prev) {\\n        // base case\\n        if (root == null)\\n            return prev;\\n        \\n        // hypothesis step\\n        TreeNode right = flattenHelper(root.right, prev);\\n\\t\\t// for left subtree prev would be the node that we get from the right subtree recursion\\n        TreeNode left = flattenHelper(root.left, right);\\n        \\n        // induction step\\n        root.right = left;\\n        root.left = null;\\n        \\n        return root;\\n    }\\n    \\n    public void flatten(TreeNode root) {\\n        flattenHelper(root, null);\\n    }\\n}\\n```\n```\\n/*\\n    Iterative Solution - Inplace\\n    ----------------------------\\n    Time complexity: O(N)\\n    Space complexity: O(1)\\n*/\\n\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        while (root != null) {\\n            if (root.left != null) {\\n                TreeNode prev = root.left;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Find the rightmost node in left subtree\\n                while (prev.right != null)\\n                    prev = prev.right;\\n                \\n                prev.right = root.right;\\n                root.right = root.left;\\n                root.left = null;\\n            }\\n            \\n            root = root.right;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207708,
                "title": "flatten-binary-tree-to-linked-list-c-protip-for-beginners-explained",
                "content": "**PROTIP(for beginners):** *To solve any problem recursively just imagine we get the solution for our subproblem through recursion.We don\\'t need to worry about how that works,just focus on the base case and the operations that we gonna apply on the solutions of subproblem what we get through recursion.*\\n\\n**Explanation:**\\nAs we can see the resultant linked list is the preorder traversal of the tree.\\nSo, we simply get flatten linked list for our left sub tree by calling recursion and store it in **l**( please see in code).\\nAnd similarly for right sub-tree,we will store it in **r**(please see in code).\\n\\nNow we have flatten linked list for our left and right subtrees and we know we want our linked list to look like preorder.\\nSo now we have two cases:\\n1. **l is NULL**(means we get NULL from our left subtree): we simply put **r in the right of tree**.\\n2. **l is not NULL**: In this case we first put **l in the right of tree** and then **r at the tail of left**(because we want it to be preordered).\\n  **Final step:** Assighn NULL to the left of the root and return root.\\n  **BaseCase:** If we have nothing means we get `root==NULL` so we can\\'t do anything simply return `NULL`l\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode* helper(TreeNode* root){\\n        if(!root) return NULL;\\n        TreeNode* l= helper(root->left);\\n        TreeNode* r = helper(root->right);\\n        if(l!=NULL){\\n            TreeNode* temp=l;\\n            while(temp->right){\\n                temp=temp->right;\\n            }\\n            temp->right=r;\\n            root->right=l;\\n        }else\\n        root->right=r;\\n        root->left=NULL;\\n        return root;\\n    }\\n    void flatten(TreeNode* root) {\\n        if(!root) return;\\n          root=helper(root);\\n    }\\n};\\n```\\n\\n**NOTE:** *IF anyone have any doubts,you  can freely ask in comment section.*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* helper(TreeNode* root){\\n        if(!root) return NULL;\\n        TreeNode* l= helper(root->left);\\n        TreeNode* r = helper(root->right);\\n        if(l!=NULL){\\n            TreeNode* temp=l;\\n            while(temp->right){\\n                temp=temp->right;\\n            }\\n            temp->right=r;\\n            root->right=l;\\n        }else\\n        root->right=r;\\n        root->left=NULL;\\n        return root;\\n    }\\n    void flatten(TreeNode* root) {\\n        if(!root) return;\\n          root=helper(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 502553,
                "title": "python-js-java-go-c-o-n-sol-by-dfs-w-visualization",
                "content": "Python/JS/Java/Go/C++ O( n ) sol. by DFS approach.\\n\\n---\\n\\nGoal: \\n**Convert binary tree** into a **right-skewed linked list**.\\n\\n---\\n\\nAlgorithm:\\n\\nMaintain a global node, called **previous traversal node**, initialized to None, and update as current node on each DFS traversal.\\n\\nDFS traversal with the ordering: ( Right node, Left node, Current node )\\n\\n1. Change current node\\'s **right child** as **previous traversal node**.\\n2. Change current node\\'s **left child** as **None**(i.e., NULL)\\n3. **Update previous traversal node** as current node\\n\\nObservation:\\nFor Left node, Right node is its previous traversal node.\\nFor Current node, Left node is its previous traversal node.\\n\\n---\\n\\nAbstract Model:\\n\\nBefore flatten operation: ( binary tree )\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1581161300.png)\\n\\nAfter flatten operation: ( right-skewed linked list )\\n![image](https://assets.leetcode.com/users/brianchiang_tw/image_1581161348.png)\\n\\n\\t \\n---\\n\\n**Implementation**:\\n\\nPython:\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n      \\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Input: root node of binary tree\\n        Output: convert binary tree to right-skewed linked list\\n        \"\"\"\\n        \\n        # record of node of previous traversal\\n        previous_traversal = None\\n        \\n        def helper( node):\\n        \\n            if node:\\n\\n                # DFS travesal to next level\\n                \\n                helper( node.right )\\n                helper( node.left )\\n\\n                # flattern binary tree to right skewed linked list\\n                \\n                nonlocal previous_traversal\\n                node.right = previous_traversal\\n                node.left = None\\n                previous_traversal = node\\n                \\n        # ---------------------\\n        \\n        helper(root)\\n```\\n\\n---\\n\\nJava:\\n\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        \\n        if( root != null ){\\n\\n            // DFS travesal to next level\\n            flatten( root.right );\\n            flatten( root.left );\\n\\n            // flattern binary tree to right skewed linked list\\n            root.right = prev;\\n            root.left = null;\\n            prev = root;\\n        }\\n        \\n        return;        \\n    }\\n    \\n    // record of node of previous traversal\\n    private TreeNode prev = null;\\n}\\n```\\n\\n---\\n\\nJavascript:\\n\\n```\\nvar flatten = function(root) {\\n    \\n    let prev = null;\\n    \\n    var helper = function( node ){\\n        \\n        if( node != null){\\n            \\n            // DFS travesal to next level\\n            helper(node.right);\\n            helper(node.left);\\n            \\n            // flattern binary tree to right skewed linked list\\n            node.right = prev;\\n            node.left = null\\n            prev = node\\n        }\\n        return;\\n    }\\n    // ------------------------------------\\n    \\n    helper( root );\\n};\\n```\\n\\n---\\n\\nGo:\\n\\n```\\nfunc flatten(root *TreeNode)  {\\n\\n    //  record of node of previous traversal\\n    var prev *TreeNode = nil\\n    \\n    var helper func( *TreeNode )\\n    \\n    helper = func( node *TreeNode){\\n        \\n        if node != nil{\\n            \\n            // DFS travesal to next level\\n            helper( node.Right )\\n            helper( node.Left )\\n\\n            // flattern binary tree to right skewed linked list\\n            node.Right = prev\\n            node.Left = nil\\n            prev = node\\n        }\\n        return\\n\\n    }\\n    // ------------------------------\\n    helper( root )\\n}\\n```\\n\\n---\\n\\nC++\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        \\n        // record of node of previous traversal\\n        TreeNode* prev = nullptr;\\n        \\n        std::function< void(TreeNode*) > helper;\\n        helper = [&](TreeNode* node) -> void {\\n            \\n            if( node != nullptr ){\\n                \\n                // DFS travesal to next level\\n                helper( node->right );\\n                helper( node->left );\\n                \\n                // flattern binary tree to right skewed linked list\\n                node->right = prev;\\n                node->left = nullptr;\\n                prev = node;\\n            }\\n            return;\\n        };\\n        \\n        // ----------------------\\n        helper( root );\\n        \\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution:\\n      \\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Input: root node of binary tree\\n        Output: convert binary tree to right-skewed linked list\\n        \"\"\"\\n        \\n        # record of node of previous traversal\\n        previous_traversal = None\\n        \\n        def helper( node):\\n        \\n            if node:\\n\\n                # DFS travesal to next level\\n                \\n                helper( node.right )\\n                helper( node.left )\\n\\n                # flattern binary tree to right skewed linked list\\n                \\n                nonlocal previous_traversal\\n                node.right = previous_traversal\\n                node.left = None\\n                previous_traversal = node\\n                \\n        # ---------------------\\n        \\n        helper(root)\\n```\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        \\n        if( root != null ){\\n\\n            // DFS travesal to next level\\n            flatten( root.right );\\n            flatten( root.left );\\n\\n            // flattern binary tree to right skewed linked list\\n            root.right = prev;\\n            root.left = null;\\n            prev = root;\\n        }\\n        \\n        return;        \\n    }\\n    \\n    // record of node of previous traversal\\n    private TreeNode prev = null;\\n}\\n```\n```\\nvar flatten = function(root) {\\n    \\n    let prev = null;\\n    \\n    var helper = function( node ){\\n        \\n        if( node != null){\\n            \\n            // DFS travesal to next level\\n            helper(node.right);\\n            helper(node.left);\\n            \\n            // flattern binary tree to right skewed linked list\\n            node.right = prev;\\n            node.left = null\\n            prev = node\\n        }\\n        return;\\n    }\\n    // ------------------------------------\\n    \\n    helper( root );\\n};\\n```\n```\\nfunc flatten(root *TreeNode)  {\\n\\n    //  record of node of previous traversal\\n    var prev *TreeNode = nil\\n    \\n    var helper func( *TreeNode )\\n    \\n    helper = func( node *TreeNode){\\n        \\n        if node != nil{\\n            \\n            // DFS travesal to next level\\n            helper( node.Right )\\n            helper( node.Left )\\n\\n            // flattern binary tree to right skewed linked list\\n            node.Right = prev\\n            node.Left = nil\\n            prev = node\\n        }\\n        return\\n\\n    }\\n    // ------------------------------\\n    helper( root )\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        \\n        // record of node of previous traversal\\n        TreeNode* prev = nullptr;\\n        \\n        std::function< void(TreeNode*) > helper;\\n        helper = [&](TreeNode* node) -> void {\\n            \\n            if( node != nullptr ){\\n                \\n                // DFS travesal to next level\\n                helper( node->right );\\n                helper( node->left );\\n                \\n                // flattern binary tree to right skewed linked list\\n                node->right = prev;\\n                node->left = nullptr;\\n                prev = node;\\n            }\\n            return;\\n        };\\n        \\n        // ----------------------\\n        helper( root );\\n        \\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 940394,
                "title": "python3-iterative-solution-with-explanation",
                "content": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        cur = root\\n        while cur:\\n            if cur.left:\\n                prev = cur.left\\n                while prev.right:\\n\\t\\t\\t\\t\\tprev = prev.right    # We go to left Subtree\\'s rightMost Node\\n                \\n                prev.right = cur.right   #We make current Node\\'s right Subtree prev\\'s right Subtree\\n                cur.right = cur.left    # We make it right Subtree\\n                cur.left = None   # Removing left \\n            \\n            cur = cur.right\\n```\\n\\nInitial Tree:    \\t\\n\\n\\t\\t\\t\\t\\t\\t\\t1\\n\\t\\t\\t\\t\\t\\t   / \\\\\\n\\t\\t\\t\\t\\t\\t  2   5\\n\\t\\t\\t\\t\\t\\t / \\\\   \\\\\\n\\t\\t\\t\\t\\t\\t3   4   6\\n\\t\\t\\t\\t\\t\\t\\nThen:  Since cur.left is True, we move to cur.left\\'s right most child ...ie.... here 4\\n          Then we make  Node (4).right, Node(1).right ...ie...\\n\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t 1\\n\\t\\t\\t\\t\\t\\t   / \\n\\t\\t\\t\\t\\t\\t  2   \\n\\t\\t\\t\\t\\t\\t / \\\\   \\n\\t\\t\\t\\t\\t\\t3   4   \\n\\t\\t\\t\\t\\t\\t\\t   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t 5\\n\\t\\t\\t\\t\\t\\t\\t\\t   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t     6\\n\\nThen: we make current Node(1).right = Node(1).left....ie........\\n\\n\\t\\t\\t\\t\\t\\t\\t1\\n\\t\\t\\t\\t\\t\\t\\t  \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t2   \\n\\t\\t\\t\\t\\t\\t\\t   /  \\\\   \\n\\t\\t\\t\\t\\t\\t\\t  3    4   \\n\\t\\t\\t\\t\\t\\t\\t     \\t   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 6\\n\\t\\t\\t\\t\\t\\t   \\n\\t\\t\\t\\t\\t\\t \\nThen:\\n\\n\\t\\t\\t\\t\\t\\t\\t1\\n\\t\\t\\t\\t\\t\\t\\t  \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t2   \\n\\t\\t\\t\\t\\t\\t\\t   /     \\n\\t\\t\\t\\t\\t\\t\\t  3    \\n\\t\\t\\t\\t\\t\\t        \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t  4   \\n\\t\\t\\t\\t\\t\\t\\t\\t    \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t  5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t    \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  6\\n\\t\\t\\t\\t\\t\\t\\t\\t\\n\\t\\t\\nThen:\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\t\\t1\\n\\t\\t\\t\\t\\t\\t\\t  \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t2\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t    3    \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t   \\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  4   \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  5\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\\\\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  6\\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t\\t  \\n\\t\\t\\t\\t\\t\\t\\t  \\nIf any Doubts plz fell free to ask\\n\\n\\n",
                "solutionTags": [
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        cur = root\\n        while cur:\\n            if cur.left:\\n                prev = cur.left\\n                while prev.right:\\n\\t\\t\\t\\t\\tprev = prev.right    # We go to left Subtree\\'s rightMost Node\\n                \\n                prev.right = cur.right   #We make current Node\\'s right Subtree prev\\'s right Subtree\\n                cur.right = cur.left    # We make it right Subtree\\n                cur.left = None   # Removing left \\n            \\n            cur = cur.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37124,
                "title": "java-solution-refer-to-mirris-traversal-using-constant-place",
                "content": "    public void flatten(TreeNode root) {\\n        TreeNode cur = root;\\n        TreeNode prev = null;\\n        while(cur != null){\\n            if(cur.left == null) cur = cur.right;\\n            else {\\n                prev = cur.left;\\n                while(prev.right != null) prev = prev.right;\\n                prev.right = cur.right;\\n                cur.right = cur.left;\\n                cur.left = null;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public void flatten(TreeNode root) {\\n        TreeNode cur = root;\\n        TreeNode prev = null;\\n        while(cur != null){\\n            if(cur.left == null) cur = cur.right;\\n            else {\\n                prev = cur.left;\\n                while(prev.right != null) prev = prev.right;\\n                prev.right = cur.right;\\n                cur.right = cur.left;\\n                cur.left = null;\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 483444,
                "title": "python-iterative-preorder",
                "content": "```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        if not root: \\n            return None\\n        \\n        stack = [root]\\n        while len(stack):\\n            root = stack.pop()\\n            \\n            if root.right: \\n                stack.append(root.right)\\n            if root.left: \\n                stack.append(root.left)\\n                \\n            root.left = None\\n            root.right = stack[-1] if len(stack) else None\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        if not root: \\n            return None\\n        \\n        stack = [root]\\n        while len(stack):\\n            root = stack.pop()\\n            \\n            if root.right: \\n                stack.append(root.right)\\n            if root.left: \\n                stack.append(root.left)\\n                \\n            root.left = None\\n            root.right = stack[-1] if len(stack) else None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 523446,
                "title": "c-solution-using-stack",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        //empty tree\\n        if(root == NULL)\\n            return;\\n        \\n        //use stack to keep storing elements \\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        \\n        //somewhat similar to level order\\n        //pop each element from the stack (starting from root)\\n        //add its right and left child to the stack\\n\\t\\t//(explained below why right child is added before left)\\n        //repeat till stack is empty.\\n        while(!stack.empty())\\n        {\\n            TreeNode* currentNode = stack.top();\\n            stack.pop();\\n            \\n            //push the right node first, because when we pop\\n            //left child will be on top and we want left child first.\\n            if(currentNode->right != NULL)\\n                stack.push(currentNode->right);\\n            \\n            //push left child, this will be on top of stack now.\\n            if(currentNode->left != NULL)\\n                stack.push(currentNode->left);\\n            \\n            //assign the top most(left child) as right. \\n            if(!stack.empty())\\n                currentNode->right = stack.top();\\n            \\n            //make all left children NULL. \\n            currentNode->left = NULL;\\n        }\\n    }    \\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        //empty tree\\n        if(root == NULL)\\n            return;\\n        \\n        //use stack to keep storing elements \\n        stack<TreeNode*> stack;\\n        stack.push(root);\\n        \\n        //somewhat similar to level order\\n        //pop each element from the stack (starting from root)\\n        //add its right and left child to the stack\\n\\t\\t//(explained below why right child is added before left)\\n        //repeat till stack is empty.\\n        while(!stack.empty())\\n        {\\n            TreeNode* currentNode = stack.top();\\n            stack.pop();\\n            \\n            //push the right node first, because when we pop\\n            //left child will be on top and we want left child first.\\n            if(currentNode->right != NULL)\\n                stack.push(currentNode->right);\\n            \\n            //push left child, this will be on top of stack now.\\n            if(currentNode->left != NULL)\\n                stack.push(currentNode->left);\\n            \\n            //assign the top most(left child) as right. \\n            if(!stack.empty())\\n                currentNode->right = stack.top();\\n            \\n            //make all left children NULL. \\n            currentNode->left = NULL;\\n        }\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37074,
                "title": "preorder-vs-postorder",
                "content": "1. let's try Preorder first. First we save left child and right child. Then we can safely flatten this node. Then left and right.\\n\\n```\\npublic class Solution {\\n    TreeNode pre=null;\\n    public void flatten(TreeNode root) {\\n        if(root==null) return;\\n        TreeNode left = root.left;\\n        TreeNode right = root.right;\\n        if(pre == null) {\\n            pre = root;\\n        }else {\\n            pre.right = root;\\n            pre.left = null;\\n            pre = root;\\n        }\\n        flatten(left);\\n        flatten(right);\\n    }\\n}\\n\\n````\\n\\n2. Postorder is a little tricky and not easy to come up. Because the order we flatten will not change the relationship of remaining nodes we do not extra pointers.\\n\\n```\\npublic class Solution {\\n    TreeNode pre=null;\\n    public void flatten(TreeNode root) {\\n        if(root==null) return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right=pre;\\n        root.left=null;\\n        pre = root;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    TreeNode pre=null;\\n    public void flatten(TreeNode root) {\\n        if(root==null) return;\\n        TreeNode left = root.left;\\n        TreeNode right = root.right;\\n        if(pre == null) {\\n            pre = root;\\n        }else {\\n            pre.right = root;\\n            pre.left = null;\\n            pre = root;\\n        }\\n        flatten(left);\\n        flatten(right);\\n    }\\n}\\n\\n```\n```\\npublic class Solution {\\n    TreeNode pre=null;\\n    public void flatten(TreeNode root) {\\n        if(root==null) return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right=pre;\\n        root.left=null;\\n        pre = root;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37039,
                "title": "my-8ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        void flatten(TreeNode* root) {\\n            TreeNode *head = nullptr;\\n            flattenWorker(root, head);\\n        }\\n    private:\\n        void flattenWorker(TreeNode* root, TreeNode*& head) {\\n            if (root == nullptr) {\\n                return;\\n            }\\n            flattenWorker(root->right, head);\\n            flattenWorker(root->left, head);\\n            root->left = nullptr;\\n            root->right = head;\\n            head = root;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void flatten(TreeNode* root) {\\n            TreeNode *head = nullptr;\\n            flattenWorker(root, head);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 37047,
                "title": "16-lines-iterative-c-solution",
                "content": "    void flatten(TreeNode *root) {\\n        while(root){\\n            if(root->left == NULL)\\n                root = root->right;\\n            else {\\n                if(root->right){\\n                    TreeNode *l = root->left;\\n                    while(l->right) l = l->right;\\n                    l->right = root->right;\\n                }\\n                root->right = root->left;\\n                root->left = NULL;\\n                root = root->right;\\n            }\\n        }\\n    }\\n\\nInspired by Morris traversal.",
                "solutionTags": [],
                "code": "    void flatten(TreeNode *root) {\\n        while(root){\\n            if(root->left == NULL)\\n                root = root->right;\\n            else {\\n                if(root->right){\\n                    TreeNode *l = root->left;\\n                    while(l->right) l = l->right;\\n                    l->right = root->right;\\n                }\\n                root->right = root->left;\\n                root->left = NULL;\\n                root = root->right;\\n            }\\n        }\\n    }\\n\\nInspired by Morris traversal.",
                "codeTag": "Unknown"
            },
            {
                "id": 1207644,
                "title": "flatten-binary-tree-to-linked-list-js-python-java-c-simple-o-1-space-solution-w-expl",
                "content": "*(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful,* ***please upvote*** *this post.)*\\n\\n---\\n\\n#### ***Idea:***\\n\\n***Morris Traversal (O(1) Space, O(N) Time) Approach:***\\n\\nThere _is_ actually a way to traverse a binary tree with a **space complexity** of **O(1)** while staying at a **time complexity** of **O(N)**, though it does require modifying the tree\\'s structure. In this problem that\\'s specifically being called for, so it\\'s a valid approach, though it won\\'t always be appropriate to modify the source binary tree in other situations.\\n\\nThe approach is called the **Morris traversal**. At its heart, it takes advantage of the basic nature of ordered traversals to iterate through and unwind the tree. In a **pre-order traversal** of a binary tree, each vertex is processed in **(node, left, right)** order. This means that the entire left subtree could be placed between the node and its right subtree.\\n\\nTo do this, however, we\\'ll first have to locate the last node in the left subtree. This is easy enough, since we know that the last node of a pre-order tree can be found by moving right as many times as possible from its root.\\n\\nSo we should be able to move through the binary tree, keeping track of the curent node (**curr**). Whenever we find a left subtree, we can dispatch a **runner** to find its last node, then stitch together both ends of the left subtree into the right path of **curr**, taking heed to sever the left connection at **curr**.\\n\\nOnce that\\'s done, we can continue to move **curr** to the right, looking for the next left subtree. When **curr** can no longer move right, the tree will be successfully flattened.\\n\\n![Morris Traversal Visual](https://i.imgur.com/sqnrz9m.gif)\\n\\n - _**Time Complexity: O(N)** where **N** is the number of **nodes** in the binary tree_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n***O(1) Space Approach:***\\n\\nIn order to properly connect the **linked list**, we\\'ll need to start at the bottom and work up. This means that we\\'ll need to move in _reverse_ **pre-order traversal** order through the **binary tree**. Since pre-order traversal is normally **\"node, left, right\"**, we\\'ll have to move in the reverse order of **\"right, left, node\"**.\\n\\nIn order to complete this solution in **O(1) space**, we won\\'t be able to conveniently backtrack via a **stack**, so the key to this solution will be to retreat all the way back up to the **root** each time we reach a leaf. This will push the **time complexity** to **O(N^2)**.\\n\\nWe\\'ll want to first set up **head** and **curr** to keep track of the head of the linked list we\\'re building and the current node we\\'re visiting. We\\'ll know we\\'re finished once **head = root**.\\n\\nTo follow the reverse pre-order traversal order, we\\'ll first attempt to go right and then left. Since we\\'re backtracking to **root**, however, we\\'ll eventually run back into the same node that we\\'ve set as **head** doing this. To prevent this, we\\'ll stop _before_ moving to the **head** node and sever the connection.\\n\\nNow that we can\\'t run into already-completed territory, we can be confident that any leaf we move to must be the next value for **head**, so we should connect it to the old **head**, update **head**, and reset back to the **root**.\\n\\nAs noted before, once **head = root**, we\\'ve finished our traversal and can exit the function.\\n\\n - _**Time Complexity: O(N^2)** where **N** is the number of **nodes** in the binary tree, due to repeated backtracking to root_\\n - _**Space Complexity: O(1)**_\\n\\n---\\n\\n***Recursive Approach:***\\n\\nIn order to properly connect the **linked list**, we\\'ll need to start at the bottom and work up. This means that we\\'ll need to move in _reverse_ **pre-order traversal** order through the **binary tree**. Since pre-order traversal is normally **\"node, left, right\"**, we\\'ll have to move in the reverse order of **\"right, left, node\"**.\\n\\nBinary tree traversal is prime ground for a **recursive** solution, so let\\'s define a helper (**revPreOrder**) for the purpose. We\\'ll also keep a global variable **head** to keep track of the head of the linked list as we work our way backwards.\\n\\nPer our reverse pre-order traversal approach, we want to recursively work down the right path first then the left path, if they exist. Once we\\'ve flattened the left and right paths recursively, **head** should at this point be equal to the next node after the current one, so we should set it as **node.right**. We shouldn\\'t forget to set **node.left** to **null**, as well.\\n\\nOnce we\\'re done with the current node, we can update **head** to **node** and allow the recursion to complete and move back up to the next layer. Once the recursion stack is exhausted, **head** will be equal to **root** again.\\n\\nLastly, we have to deal with an edge case of an empty **root**, so we can just make sure to only call the initial recursion on **root** if **root** actually is a node. There is no need for a **return** statement, because the test suite will evaluate **root** directly.\\n\\n - _**Time Complexity: O(N)** where **N** is the number of **nodes** in the binary tree_\\n - _**Space Complexity: O(N)** for the **recursion stack**, which is as long as the maximum depth of the binary tree, which can go up to **N**_\\n\\n---\\n\\n#### ***Javascript Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **84ms / 40.6MB** (beats 96% / 66%).\\n```javascript\\nvar flatten = function(root) {\\n    let curr = root\\n    while (curr) {\\n        if (curr.left) {\\n            let runner = curr.left\\n            while (runner.right) runner = runner.right\\n            runner.right = curr.right, curr.right = curr.left, curr.left = null\\n        }\\n        curr = curr.right\\n    }\\n};\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **80ms / 40.6MB** (beats 98% / 66%).\\n```javascript\\nvar flatten = function(root) {\\n    let head = null, curr = root\\n    while (head != root) {\\n        if (curr.right === head) curr.right = null\\n        if (curr.left === head) curr.left = null\\n        if (curr.right) curr = curr.right\\n        else if (curr.left) curr = curr.left\\n        else curr.right = head, head = curr, curr = root\\n    }\\n};\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **84ms / 40.6MB** (beats 96% / 66%).\\n```javascript\\nvar flatten = function(root) {\\n    let head = null\\n    const revPreOrder = node => {\\n        if (node.right) revPreOrder(node.right)\\n        if (node.left) revPreOrder(node.left)\\n        node.left = null, node.right = head, head = node\\n    }\\n    if (root) revPreOrder(root)\\n};\\n```\\n\\n---\\n\\n#### ***Python Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **32ms / 15.0MB** (beats 92% / 91%).\\n```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        curr = root\\n        while curr:\\n            if curr.left:\\n                runner = curr.left\\n                while runner.right: runner = runner.right\\n                runner.right, curr.right, curr.left = curr.right, curr.left, None\\n            curr = curr.right\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **32ms / 15.0MB** (beats 92% / 91%).\\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        head, curr = None, root\\n        while head != root:\\n            if curr.right == head: curr.right = None\\n            if curr.left == head: curr.left = None\\n            if curr.right: curr = curr.right\\n            elif curr.left: curr = curr.left\\n            else: curr.right, head, curr = head, curr, root\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **28ms / 14.9MB** (beats 98% / 98%).\\n```python\\nclass Solution:\\n    head = None\\n    def flatten(self, root: TreeNode) -> None:\\n        def revPreOrder(node: TreeNode) -> None:\\n            if node.right: revPreOrder(node.right)\\n            if node.left: revPreOrder(node.left)\\n            node.left, node.right, self.head = None, self.head, node\\n        if root: revPreOrder(root)\\n```\\n\\n---\\n\\n#### ***Java Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **0ms / 37.9MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode curr = root;\\n        while (curr != null) {\\n            if (curr.left != null) {\\n                TreeNode runner = curr.left;\\n                while (runner.right != null) runner = runner.right;\\n                runner.right = curr.right;\\n                curr.right = curr.left;\\n                curr.left = null;\\n            }\\n            curr = curr.right;\\n        }\\n    }\\n}\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **0ms / 37.9MB** (beats 100% / 98%).\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode head = null, curr = root;\\n        while (head != root) {\\n            if (curr.right == head) curr.right = null;\\n            if (curr.left == head) curr.left = null;\\n            if (curr.right != null) curr = curr.right;\\n            else if (curr.left != null) curr = curr.left;\\n            else {\\n                curr.right = head;\\n                head = curr;\\n                curr = root;\\n            }\\n        }\\n    }\\n}\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **0ms / 38.0MB** (beats 100% / 98%).\\n```java\\nclass Solution {\\n    TreeNode head = null;\\n    public void flatten(TreeNode root) {\\n        if (root != null) revPreOrder(root);\\n    }\\n    private void revPreOrder(TreeNode node) {\\n        if (node.right != null) revPreOrder(node.right);\\n        if (node.left != null) revPreOrder(node.left);\\n        node.left = null;\\n        node.right = head;\\n        head = node;\\n    }\\n}\\n```\\n\\n---\\n\\n#### ***C++ Code:***\\n\\n##### ***w/ Morris Traversal:***\\n\\nThe best result for the code below is **0ms / 12.6MB** (beats 100% / 95%).\\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while (curr) {\\n            if (curr->left) {\\n                TreeNode* runner = curr->left;\\n                while (runner->right != nullptr) runner = runner->right;\\n                runner->right = curr->right, curr->right = curr->left, curr->left = nullptr;\\n            }\\n            curr = curr->right;\\n        }\\n    }\\n};\\n```\\n\\n##### ***w/ O(1) Space:***\\n\\nThe best result for the code below is **0ms / 12.6MB** (beats 100% / 95%).\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode *head = nullptr, *curr = root;\\n        while (head != root) {\\n            if (curr->right == head) curr->right = nullptr;\\n            if (curr->left == head) curr->left = nullptr;\\n            if (curr->right) curr = curr->right;\\n            else if (curr->left) curr = curr->left;\\n            else curr->right = head, head = curr, curr = root;\\n        }\\n    }\\n};\\n```\\n\\n##### ***w/ Recursion:***\\n\\nThe best result for the code below is **0ms / 12.6MB** (beats 100% / 95%).\\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if (root) revPreOrder(root);\\n    }\\nprivate:\\n    TreeNode* head = nullptr;\\n    void revPreOrder(TreeNode* node) {\\n        if (node->right) revPreOrder(node->right);\\n        if (node->left) revPreOrder(node->left);\\n        node->left = nullptr, node->right = head, head = node;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\nvar flatten = function(root) {\\n    let curr = root\\n    while (curr) {\\n        if (curr.left) {\\n            let runner = curr.left\\n            while (runner.right) runner = runner.right\\n            runner.right = curr.right, curr.right = curr.left, curr.left = null\\n        }\\n        curr = curr.right\\n    }\\n};\\n```\n```javascript\\nvar flatten = function(root) {\\n    let head = null, curr = root\\n    while (head != root) {\\n        if (curr.right === head) curr.right = null\\n        if (curr.left === head) curr.left = null\\n        if (curr.right) curr = curr.right\\n        else if (curr.left) curr = curr.left\\n        else curr.right = head, head = curr, curr = root\\n    }\\n};\\n```\n```javascript\\nvar flatten = function(root) {\\n    let head = null\\n    const revPreOrder = node => {\\n        if (node.right) revPreOrder(node.right)\\n        if (node.left) revPreOrder(node.left)\\n        node.left = null, node.right = head, head = node\\n    }\\n    if (root) revPreOrder(root)\\n};\\n```\n```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        curr = root\\n        while curr:\\n            if curr.left:\\n                runner = curr.left\\n                while runner.right: runner = runner.right\\n                runner.right, curr.right, curr.left = curr.right, curr.left, None\\n            curr = curr.right\\n```\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        head, curr = None, root\\n        while head != root:\\n            if curr.right == head: curr.right = None\\n            if curr.left == head: curr.left = None\\n            if curr.right: curr = curr.right\\n            elif curr.left: curr = curr.left\\n            else: curr.right, head, curr = head, curr, root\\n```\n```python\\nclass Solution:\\n    head = None\\n    def flatten(self, root: TreeNode) -> None:\\n        def revPreOrder(node: TreeNode) -> None:\\n            if node.right: revPreOrder(node.right)\\n            if node.left: revPreOrder(node.left)\\n            node.left, node.right, self.head = None, self.head, node\\n        if root: revPreOrder(root)\\n```\n```java\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode curr = root;\\n        while (curr != null) {\\n            if (curr.left != null) {\\n                TreeNode runner = curr.left;\\n                while (runner.right != null) runner = runner.right;\\n                runner.right = curr.right;\\n                curr.right = curr.left;\\n                curr.left = null;\\n            }\\n            curr = curr.right;\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode head = null, curr = root;\\n        while (head != root) {\\n            if (curr.right == head) curr.right = null;\\n            if (curr.left == head) curr.left = null;\\n            if (curr.right != null) curr = curr.right;\\n            else if (curr.left != null) curr = curr.left;\\n            else {\\n                curr.right = head;\\n                head = curr;\\n                curr = root;\\n            }\\n        }\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    TreeNode head = null;\\n    public void flatten(TreeNode root) {\\n        if (root != null) revPreOrder(root);\\n    }\\n    private void revPreOrder(TreeNode node) {\\n        if (node.right != null) revPreOrder(node.right);\\n        if (node.left != null) revPreOrder(node.left);\\n        node.left = null;\\n        node.right = head;\\n        head = node;\\n    }\\n}\\n```\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while (curr) {\\n            if (curr->left) {\\n                TreeNode* runner = curr->left;\\n                while (runner->right != nullptr) runner = runner->right;\\n                runner->right = curr->right, curr->right = curr->left, curr->left = nullptr;\\n            }\\n            curr = curr->right;\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode *head = nullptr, *curr = root;\\n        while (head != root) {\\n            if (curr->right == head) curr->right = nullptr;\\n            if (curr->left == head) curr->left = nullptr;\\n            if (curr->right) curr = curr->right;\\n            else if (curr->left) curr = curr->left;\\n            else curr->right = head, head = curr, curr = root;\\n        }\\n    }\\n};\\n```\n```c++\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if (root) revPreOrder(root);\\n    }\\nprivate:\\n    TreeNode* head = nullptr;\\n    void revPreOrder(TreeNode* node) {\\n        if (node->right) revPreOrder(node->right);\\n        if (node->left) revPreOrder(node->left);\\n        node->left = nullptr, node->right = head, head = node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325530,
                "title": "cpp-concise-solution-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* cur = root;\\n        while(cur) {\\n            if(cur->left) {\\n                TreeNode* tmp = cur->left;\\n                while(tmp->right) tmp = tmp->right;\\n                tmp->right = cur->right;\\n                cur->right = cur->left;\\n                cur->left = nullptr;\\n            }\\n            cur = cur->right;\\n        }\\n    }\\n};\\n```\\nTime: O(N) - each node would be visited at most twice\\nSpace: O(1)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* cur = root;\\n        while(cur) {\\n            if(cur->left) {\\n                TreeNode* tmp = cur->left;\\n                while(tmp->right) tmp = tmp->right;\\n                tmp->right = cur->right;\\n                cur->right = cur->left;\\n                cur->left = nullptr;\\n            }\\n            cur = cur->right;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 291995,
                "title": "simple-javascript-recursion-solution-beats-99-for-now",
                "content": "Logic is simple. If the current node is null, we will return and stop here. \\nIf the current node has a left child node\\n\\t1. find the most right leaf of current left node\\n\\t2. keep current right node in a tmp var\\n\\t3. we move the left child to our right.\\n\\t4. connect previous right node(tmp) to the right of the most right leaf we found\\n\\t5. make current left null\\nThen we call ourself and pass the right node in.\\n```\\nvar flatten = function(root) {\\n    if (root === null) return;\\n    if (root.left) {\\n\\t\\t// step 1\\n        var last = root.left;\\n        while (last.right !== null) last = last.right;\\n        // step 2\\n        var tmp = root.right;\\n\\t\\t// step 3\\n        root.right = root.left;\\n\\t\\t// step 4\\n        last.right = tmp;\\n\\t\\t// step 5\\n        root.left = null;\\n    }\\n    \\n    flatten(root.right);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar flatten = function(root) {\\n    if (root === null) return;\\n    if (root.left) {\\n\\t\\t// step 1\\n        var last = root.left;\\n        while (last.right !== null) last = last.right;\\n        // step 2\\n        var tmp = root.right;\\n\\t\\t// step 3\\n        root.right = root.left;\\n\\t\\t// step 4\\n        last.right = tmp;\\n\\t\\t// step 5\\n        root.left = null;\\n    }\\n    \\n    flatten(root.right);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37244,
                "title": "can-you-improve-upon-my-recursive-approach",
                "content": "I am basically storing the last visited pre-order traversal node in a static \"lastVisited\" TreeNode, and re-assigning its children.\\nCan my algorithm be improved so that we don't need that static variable, and all is handled by the recursive algorithm.\\n\\n    private static TreeNode lastVisited = null;\\n    \\n    public static void flattenHelper(TreeNode root) {\\n        if(root == null)\\n            return;\\n    \\n        TreeNode savedRight = root.right;\\n        if(lastVisited != null) {\\n            lastVisited.left = null;\\n            lastVisited.right = root;\\n        }\\n        lastVisited = root;\\n        \\n        flattenHelper(root.left);\\n        flattenHelper(savedRight);\\n    }",
                "solutionTags": [],
                "code": "I am basically storing the last visited pre-order traversal node in a static \"lastVisited\" TreeNode, and re-assigning its children.\\nCan my algorithm be improved so that we don't need that static variable, and all is handled by the recursive algorithm.\\n\\n    private static TreeNode lastVisited = null;\\n    \\n    public static void flattenHelper(TreeNode root) {\\n        if(root == null)\\n            return;\\n    \\n        TreeNode savedRight = root.right;\\n        if(lastVisited != null) {\\n            lastVisited.left = null;\\n            lastVisited.right = root;\\n        }\\n        lastVisited = root;\\n        \\n        flattenHelper(root.left);\\n        flattenHelper(savedRight);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3194497,
                "title": "beats-93-12-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIn this solution, we start by initializing a prev variable to None. This variable will keep track of the previously flattened node as we recursively flatten the binary tree.\\n\\nWe then define a recursive function flatten that takes in the root node of the binary tree. This function does not return anything, but instead modifies the tree in-place.\\n\\nThe first thing we do in the flatten function is to check if the root node is None. If it is, we simply return.\\n\\nNext, we recursively flatten the right subtree of the root node by calling self.flatten(root.right). This will flatten the right subtree and set self.prev to the rightmost node in the right subtree.\\n\\nWe then recursively flatten the left subtree of the root node by calling self.flatten(root.left). This will flatten the left subtree and update self.prev to the rightmost node in the flattened left subtree.\\n\\nOnce we have flattened both the left and right subtrees, we update the root.right pointer to be the previously flattened node (self.prev). We also set the root.left pointer to None to remove the left child.\\n\\nFinally, we update self.prev to be the current node (root). This is important because it allows us to keep track of the previously flattened node as we continue to recursively flatten the tree.\\n\\nThis algorithm flattens the binary tree in pre-order traversal, so the resulting \"linked list\" will be in the same order as a pre-order traversal of the tree.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.prev = None\\n\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        if not root:\\n            return\\n        self.flatten(root.right)  # Recursively flatten the right subtree\\n        self.flatten(root.left)  # Recursively flatten the left subtree\\n        root.right = self.prev  # Set the right child to the previously flattened node\\n        root.left = None  # Set the left child to None\\n        self.prev = root  # Update the previously flattened node to be the current node\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Linked List",
                    "Stack",
                    "Tree"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.prev = None\\n\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        if not root:\\n            return\\n        self.flatten(root.right)  # Recursively flatten the right subtree\\n        self.flatten(root.left)  # Recursively flatten the left subtree\\n        root.right = self.prev  # Set the right child to the previously flattened node\\n        root.left = None  # Set the left child to None\\n        self.prev = root  # Update the previously flattened node to be the current node\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 567285,
                "title": "recursive-python-solution-short-and-elegant",
                "content": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.previous_right = None\\n        def helper(root = root):\\n            if root:\\n                helper(root.right)\\n                helper(root.left)\\n                root.right, self.previous_right = self.previous_right, root\\n                root.left = None\\n        helper()\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        self.previous_right = None\\n        def helper(root = root):\\n            if root:\\n                helper(root.right)\\n                helper(root.left)\\n                root.right, self.previous_right = self.previous_right, root\\n                root.left = None\\n        helper()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3535781,
                "title": "python-iterative-solution-without-stack",
                "content": "```\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        curr=root\\n        while curr:\\n            if curr.left!=None:\\n                prev=curr.left\\n                while prev.right:\\n                    prev=prev.right\\n                prev.right=curr.right\\n                curr.right=curr.left\\n                curr.left=None\\n            curr=curr.right\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        curr=root\\n        while curr:\\n            if curr.left!=None:\\n                prev=curr.left\\n                while prev.right:\\n                    prev=prev.right\\n                prev.right=curr.right\\n                curr.right=curr.left\\n                curr.left=None\\n            curr=curr.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207839,
                "title": "python-intuitive-solution-explained",
                "content": "I saw several really nice and short solutions for this problem, howerer sometimes it is a quite difficult to digest them. Here I tried to find the solution, which can be easily reproduced during real-time interview. The idea as in other solutions is to use recursion.\\n\\nLet use `helper(node)` function which return the first and the last elements of linked lists, constucted from subtree of `node`. Then we can have several cases:\\n\\n1. If there is no `left` and no `right` children, then we just return `(node, node)`, because in this case the list for `node` has only one element.  `node ->`\\n2. If there is no `left` children but there is `right` children,  we have a case `node -> b2 -> ... -> e2 ->`. Then we need to create new connection `node -> b2`.\\n3. If there is `left` children and there is no `right` children, we have a case `node -> b1 -> ... -> e1 ->`, and we need to create connection `node -> b1`.\\n4. If there is `left` and `right` children, we have a case `node -> b1 -> ... -> e1 -> b2 -> ... -> e2 ->`.  Then we need to create two more connections: `node -> b1` and `e1 -> b2`.\\n\\n#### Complexity\\nTime complexity is `O(n)` to traverse our tree once. Space complexity we can say `O(h)`, because we reuse existing nodes with recursion stack.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def flatten(self, root):\\n        def helper(node):\\n            if not node: return (None, None)\\n            b1, e1 = helper(node.left)\\n            b2, e2 = helper(node.right)\\n            node.left = None\\n            \\n            if not e1 and not e2:\\n                return (node, node)\\n            if not e1 and e2: \\n                node.right = b2\\n                return (node, e2)\\n            if e1 and not e2:\\n                node.right = b1\\n                return (node, e1)\\n            else:\\n                node.right = b1\\n                e1.right = b2\\n                return (node, e2)\\n\\n        helper(root)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def flatten(self, root):\\n        def helper(node):\\n            if not node: return (None, None)\\n            b1, e1 = helper(node.left)\\n            b2, e2 = helper(node.right)\\n            node.left = None\\n            \\n            if not e1 and not e2:\\n                return (node, node)\\n            if not e1 and e2: \\n                node.right = b2\\n                return (node, e2)\\n            if e1 and not e2:\\n                node.right = b1\\n                return (node, e1)\\n            else:\\n                node.right = b1\\n                e1.right = b2\\n                return (node, e2)\\n\\n        helper(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340445,
                "title": "python-intuitive-explained-o-1-space-ignoring-recursion-stack-o-n-time",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.prev = None\\n        \\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \\n        if not root: return \\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root        \\n```\\nplease upvote if you found it helpful :)\\n\\nExplanation : \\nWe have to make the pre order traversal which is of the format :\\n\\t\\n\\tif not root: return                                   4\\n\\t#visit                                           2         3\\n\\trecur(root.left)                              1      7\\n\\trecur(root.right)\\nPre-order for the tree mentioned above : 4,2,1,7,3\\nNow since we want to do it in place without wasting extra space, we can not start from the first, since if we do that and change its children how will we traverse further?\\nThus we start from the very end, because chaning that would not cause problems. \\nWe store the last visited node in a variable prev, thus when we visit another node we change its left child to None and right child to prev.\\n\\nHow do we traverse this way? just do the oppiste of preorder \\nwe first go right (which takes us towards the end) since preorder first goes left \\nwe then go left\\nand we visit in the end since pre order visits first so we do the opposite.\\n\\t\\n\\tif not root: return       \\n\\trecur(root.right)\\n\\trecur(root.left)                   \\n\\t#visit                                      \\n\\nto explain further - think of it this way we want to visit/ do the changing operations when we do not have to use the current node to traverse any further, meaning its safe to change the children. And that only happens when both travsering to right and left has happened\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.prev = None\\n        \\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \\n        if not root: return \\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1892707,
                "title": "flatten-a-binary-tree-to-linked-list-3-approaches-c",
                "content": "# Recursion\\n```\\nclass Solution {\\npublic:\\n      TreeNode* prev=0;\\n    void flatten(TreeNode* root) {\\n       // TreeNode* prev=0;\\n        if(!root) return ;\\n        \\n        flatten(root->right);\\n        flatten(root->left);\\n        \\n        root->right=prev;\\n        root->left=0;\\n        prev=root;\\n    }\\n};\\n```\\n# Stack\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return; \\n        stack<TreeNode*> st; \\n        st.push(root); \\n        while(!st.empty()) {\\n            TreeNode* cur = st.top(); \\n            st.pop(); \\n            \\n            if(cur->right != NULL) {\\n                st.push(cur->right); \\n            }\\n            if(cur->left != NULL) {\\n                st.push(cur->left); \\n            }\\n            if(!st.empty()) {\\n                cur->right = st.top(); \\n            }\\n            cur->left = NULL;\\n        }\\n        \\n    }\\n};\\n```\\n# Moriss Travesal \\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* cur = root;\\n\\t\\twhile (cur)\\n\\t\\t{\\n\\t\\t\\tif(cur->left)\\n\\t\\t\\t{\\n\\t\\t\\t\\tTreeNode* pre = cur->left;\\n\\t\\t\\t\\twhile(pre->right)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpre = pre->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpre->right = cur->right;\\n\\t\\t\\t\\tcur->right = cur->left;\\n\\t\\t\\t\\tcur->left = NULL;\\n\\t\\t\\t}\\n\\t\\t\\tcur = cur->right;\\n\\t\\t}\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n      TreeNode* prev=0;\\n    void flatten(TreeNode* root) {\\n       // TreeNode* prev=0;\\n        if(!root) return ;\\n        \\n        flatten(root->right);\\n        flatten(root->left);\\n        \\n        root->right=prev;\\n        root->left=0;\\n        prev=root;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return; \\n        stack<TreeNode*> st; \\n        st.push(root); \\n        while(!st.empty()) {\\n            TreeNode* cur = st.top(); \\n            st.pop(); \\n            \\n            if(cur->right != NULL) {\\n                st.push(cur->right); \\n            }\\n            if(cur->left != NULL) {\\n                st.push(cur->left); \\n            }\\n            if(!st.empty()) {\\n                cur->right = st.top(); \\n            }\\n            cur->left = NULL;\\n        }\\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* cur = root;\\n\\t\\twhile (cur)\\n\\t\\t{\\n\\t\\t\\tif(cur->left)\\n\\t\\t\\t{\\n\\t\\t\\t\\tTreeNode* pre = cur->left;\\n\\t\\t\\t\\twhile(pre->right)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tpre = pre->right;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tpre->right = cur->right;\\n\\t\\t\\t\\tcur->right = cur->left;\\n\\t\\t\\t\\tcur->left = NULL;\\n\\t\\t\\t}\\n\\t\\t\\tcur = cur->right;\\n\\t\\t}\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37050,
                "title": "java-solution-recursive-non-recursive",
                "content": "I am ambiguous about if \"recursive\" is qualified for \"in place\", as sb in discussion says it's NOT.\\nHere I have Java solution in recursive and non-recursive.\\n\\n\\n\\n    /**\\n     * Move from root down,\\n     * for each node, \\n     *  attach original right as the right child of the rigthmost node of left subtree,\\n     *  set original left as new right child.\\n     * repeat with next right child.\\n     */\\n    /// SOLUTION II: non-recursive ///\\n    public void flatten(TreeNode root) {\\n        TreeNode node = root;\\n        while (node != null) {\\n            TreeNode left = node.left;\\n            TreeNode right = node.right;\\n            if (left != null) {\\n                TreeNode temp = left;\\n                while (temp.right != null)\\n                    temp = temp.right;\\n                temp.right = right;\\n                node.right = left;\\n                node.left = null;\\n            }\\n            node = node.right;\\n        }\\n    }\\n    \\n    /// SOLUTION I: accepted, recursion ///\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        TreeNode left = root.left;\\n        TreeNode right = root.right;\\n        if (left != null) {\\n            TreeNode rightmost = getRightmost(left);\\n            rightmost.right = right;\\n            root.left = null; // CATCH: must set left to null explicitly\\n            root.right = left;\\n        }\\n        flatten(root.right);\\n    }\\n    \\n    // return the rightmost node of a subtree;\\n    // node must not be null.\\n    private TreeNode getRightmost(TreeNode node) {\\n        while (node.right != null)\\n            node = node.right;\\n        return node;\\n    }",
                "solutionTags": [],
                "code": "I am ambiguous about if \"recursive\" is qualified for \"in place\", as sb in discussion says it's NOT.\\nHere I have Java solution in recursive and non-recursive.\\n\\n\\n\\n    /**\\n     * Move from root down,\\n     * for each node, \\n     *  attach original right as the right child of the rigthmost node of left subtree,\\n     *  set original left as new right child.\\n     * repeat with next right child.\\n     */\\n    /// SOLUTION II: non-recursive ///\\n    public void flatten(TreeNode root) {\\n        TreeNode node = root;\\n        while (node != null) {\\n            TreeNode left = node.left;\\n            TreeNode right = node.right;\\n            if (left != null) {\\n                TreeNode temp = left;\\n                while (temp.right != null)\\n                    temp = temp.right;\\n                temp.right = right;\\n                node.right = left;\\n                node.left = null;\\n            }\\n            node = node.right;\\n        }\\n    }\\n    \\n    /// SOLUTION I: accepted, recursion ///\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        TreeNode left = root.left;\\n        TreeNode right = root.right;\\n        if (left != null) {\\n            TreeNode rightmost = getRightmost(left);\\n            rightmost.right = right;\\n            root.left = null; // CATCH: must set left to null explicitly\\n            root.right = left;\\n        }\\n        flatten(root.right);\\n    }\\n    \\n    // return the rightmost node of a subtree;\\n    // node must not be null.\\n    private TreeNode getRightmost(TreeNode node) {\\n        while (node.right != null)\\n            node = node.right;\\n        return node;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 333469,
                "title": "java-3-methods-explained",
                "content": "**Method 1: Iterative**\\n* Find current node\\'s prenode that links to current node\\'s right subtree. \\n* Use current node\\'s left subtree to replace its right subtree (original right subtree is already linked by current node\\'s prenode)\\n> **T/S:** O(n)/O(1), where n = number of nodes in tree\\n```\\n/**\\n * Algo:\\n * start with N = root\\n * while N is not null:\\n * 1. Find right most node (RMN) of the left subtree.\\n * 2. do RMN\\'s right child = N\\'s right child\\n * 3. N\\'s right child = N\\'s left child\\n * 4. N\\'s left child = null\\n * 5. N = N.right\\n */\\npublic void flatten(TreeNode root) {\\n\\tfor (; root != null; root = root.right) \\n\\t\\tif (root.left != null) {\\n\\t\\t\\tvar pre = root.left; // right most node in left-sub-tree\\n\\t\\t\\tfor (; pre.right != null; pre = pre.right);             \\n\\t\\t\\tpre.right = root.right;\\n\\t\\t\\troot.right = root.left;\\n\\t\\t\\troot.left = null;    \\n\\t\\t}  \\n}\\n```\\n\\n**Method 2:** Recursive with global variable. Post order traversal: Right-Left-Node (Root/self/parent)\\n> **T/S:** O(n)/O(n)\\n```\\nTreeNode prev;\\n\\npublic void flatten(TreeNode root) {\\n\\tif (root == null)\\n\\t\\treturn;\\n\\tflatten(root.right);\\n\\tflatten(root.left);\\n\\troot.right = prev;\\n\\troot.left = null;\\n\\tprev = root;\\n}\\n```\\n\\n**Method 3:** Recursive without global variable\\n> **T/S:** O(n)/O(n)\\n```\\npublic void flatten(TreeNode root) {\\n\\tflatten(root, null);\\n}\\n\\nprivate TreeNode flatten(TreeNode root, TreeNode prev) {\\n\\tif (root == null)\\n\\t\\treturn prev;\\n\\troot.right = flatten(root.left, flatten(root.right, prev));\\n\\troot.left = null;\\n\\treturn root;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Algo:\\n * start with N = root\\n * while N is not null:\\n * 1. Find right most node (RMN) of the left subtree.\\n * 2. do RMN\\'s right child = N\\'s right child\\n * 3. N\\'s right child = N\\'s left child\\n * 4. N\\'s left child = null\\n * 5. N = N.right\\n */\\npublic void flatten(TreeNode root) {\\n\\tfor (; root != null; root = root.right) \\n\\t\\tif (root.left != null) {\\n\\t\\t\\tvar pre = root.left; // right most node in left-sub-tree\\n\\t\\t\\tfor (; pre.right != null; pre = pre.right);             \\n\\t\\t\\tpre.right = root.right;\\n\\t\\t\\troot.right = root.left;\\n\\t\\t\\troot.left = null;    \\n\\t\\t}  \\n}\\n```\n```\\nTreeNode prev;\\n\\npublic void flatten(TreeNode root) {\\n\\tif (root == null)\\n\\t\\treturn;\\n\\tflatten(root.right);\\n\\tflatten(root.left);\\n\\troot.right = prev;\\n\\troot.left = null;\\n\\tprev = root;\\n}\\n```\n```\\npublic void flatten(TreeNode root) {\\n\\tflatten(root, null);\\n}\\n\\nprivate TreeNode flatten(TreeNode root, TreeNode prev) {\\n\\tif (root == null)\\n\\t\\treturn prev;\\n\\troot.right = flatten(root.left, flatten(root.right, prev));\\n\\troot.left = null;\\n\\treturn root;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1932080,
                "title": "100-fastest-swift-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func flatten(_ root: TreeNode?) {\\n        var tail: TreeNode?\\n        \\n        func preOrder(_ root: TreeNode?) {\\n            guard let root = root else { return }\\n            \\n            let left = root.left\\n            let right = root.right\\n            \\n            if tail == nil {\\n                tail = root\\n            } else {\\n                tail?.right = root\\n            }\\n            \\n            tail?.left = nil\\n            tail = root\\n            preOrder(left)\\n            preOrder(right)\\n        }\\n        \\n        preOrder(root)\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public var val: Int\\n *     public var left: TreeNode?\\n *     public var right: TreeNode?\\n *     public init() { self.val = 0; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int) { self.val = val; self.left = nil; self.right = nil; }\\n *     public init(_ val: Int, _ left: TreeNode?, _ right: TreeNode?) {\\n *         self.val = val\\n *         self.left = left\\n *         self.right = right\\n *     }\\n * }\\n */\\nclass Solution {\\n    func flatten(_ root: TreeNode?) {\\n        var tail: TreeNode?\\n        \\n        func preOrder(_ root: TreeNode?) {\\n            guard let root = root else { return }\\n            \\n            let left = root.left\\n            let right = root.right\\n            \\n            if tail == nil {\\n                tail = root\\n            } else {\\n                tail?.right = root\\n            }\\n            \\n            tail?.left = nil\\n            tail = root\\n            preOrder(left)\\n            preOrder(right)\\n        }\\n        \\n        preOrder(root)\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1884701,
                "title": "image-explanation-to-understand-the-recursion-solution",
                "content": "[Leetcode](https://leetcode.com/) [114. Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list).\\n\\n\\n***By Frank Luo***\\n\\nThe Binary Tree Traversal Algorithms can be find here [Tree Traversals All In One: PreOrder, InOrder and PostOrder](https://leetcode.com/problems/binary-tree-inorder-traversal/solutions/1860290/tree-traversal-algorithms-preorder-inorder-and-postorder-traverse-algorithms-all-in-one/).\\n\\nWe can use **DFS** to traversal the binary tree.\\n\\nTo **Flatten Binary Tree to Linked List**, there are **3** steps as the picture shows.\\n\\n![DFS](https://assets.leetcode.com/users/images/3dcbb9c1-5c2d-4d9c-930b-bbccf3f7bbe2_1648283800.2439668.png)\\n\\n1. Flatten the left subtree of the root node into a linked list;\\n2. Flatten the right subtree of the root node into a linked list;\\n3. Let the right subtree of the **step 2** be the **right child** of **the farest right node** of the left subtree of **step 1**.\\n\\nObiously, that\\'s a **recursion** process.\\n\\nLet\\'s coding it.\\n\\n```java\\n    public static void flatten_rec(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n\\n\\t\\t// left subtree\\n        flatten_rec(root.left);\\n\\t\\t// right subtree\\n        flatten_rec(root.right);\\n\\n        TreeNode temp = root.right;\\n        root.right = root.left;\\n        root.left = null;\\n\\n        // find the farest right node.\\n        while (root.right != null) {\\n            root = root.right;\\n        }\\n\\n        root.right = temp;\\n    }\\n```\\n\\n## Analysis\\n\\n- **Time Complexity**: $O(n)$.\\n- **Space Complexity**: $O(n)$.\\n\\n\\n------------\\n\\nAll suggestions are welcome. \\nIf you have any query or suggestion please comment below.\\nPlease upvote\\uD83D\\uDC4D if you like\\uD83D\\uDC97 it. Thank you:-)\\n\\nExplore More [Leetcode Solutions](https://leetcode.com/discuss/general-discussion/1868912/My-Leetcode-Solutions-All-In-One). \\uD83D\\uDE09\\uD83D\\uDE03\\uD83D\\uDC97\\n\\n",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```java\\n    public static void flatten_rec(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n\\n\\t\\t// left subtree\\n        flatten_rec(root.left);\\n\\t\\t// right subtree\\n        flatten_rec(root.right);\\n\\n        TreeNode temp = root.right;\\n        root.right = root.left;\\n        root.left = null;\\n\\n        // find the farest right node.\\n        while (root.right != null) {\\n            root = root.right;\\n        }\\n\\n        root.right = temp;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1815655,
                "title": "c-using-recursion-iteration-morris-traversal",
                "content": "Flatten Binary Tree to Linked List -\\n\\n**1) Recursion :**\\nT.C. - O(n)\\nS.C. - O(n)\\n```\\nclass Solution {\\n    TreeNode* prev=NULL;\\npublic:\\n    void flatten(TreeNode* root) {\\n         if(root==NULL){return ;}\\n         flatten(root->right);\\n         flatten(root->left);\\n         \\n         root->right=prev;\\n         root->left=NULL;\\n         prev=root;\\n    }    \\n};\\n```\\n\\n**2) Iteration :**\\nT.C. - O(n)\\nS.C. - O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root==NULL){return ;}\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n            TreeNode* curr=st.top();\\n            st.pop();\\n            if(curr->right!=NULL)\\n            {\\n                st.push(curr->right);\\n            }\\n            if(curr->left!=NULL)\\n            {\\n                st.push(curr->left);\\n            }\\n            if(!st.empty())\\n            {\\n                curr->right=st.top();\\n            }\\n           curr->left=NULL; \\n        }\\n    }    \\n};\\n```\\n\\n**3) Morris Traversal :**\\nT.C. - O(n)\\nS.C. - O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n         if(root==NULL){return ;}\\n         TreeNode* curr=root;\\n         while(curr!=NULL)\\n         {\\n             if(curr->left!=NULL)\\n             {\\n                 TreeNode* next=curr->left;\\n                 while(next->right!=NULL)\\n                 {\\n                     next=next->right;\\n                 }\\n                 next->right=curr->right;\\n                 curr->right=curr->left;\\n                 curr->left=NULL;\\n             }\\n            curr=curr->right; \\n         }\\n    }    \\n};\\n```\\n\\nPlease comment if you have any doubt.\\nWill get back to you as soon as possible.\\n**UPVOTE if you find it useful!**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode* prev=NULL;\\npublic:\\n    void flatten(TreeNode* root) {\\n         if(root==NULL){return ;}\\n         flatten(root->right);\\n         flatten(root->left);\\n         \\n         root->right=prev;\\n         root->left=NULL;\\n         prev=root;\\n    }    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root==NULL){return ;}\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty())\\n        {\\n            TreeNode* curr=st.top();\\n            st.pop();\\n            if(curr->right!=NULL)\\n            {\\n                st.push(curr->right);\\n            }\\n            if(curr->left!=NULL)\\n            {\\n                st.push(curr->left);\\n            }\\n            if(!st.empty())\\n            {\\n                curr->right=st.top();\\n            }\\n           curr->left=NULL; \\n        }\\n    }    \\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n         if(root==NULL){return ;}\\n         TreeNode* curr=root;\\n         while(curr!=NULL)\\n         {\\n             if(curr->left!=NULL)\\n             {\\n                 TreeNode* next=curr->left;\\n                 while(next->right!=NULL)\\n                 {\\n                     next=next->right;\\n                 }\\n                 next->right=curr->right;\\n                 curr->right=curr->left;\\n                 curr->left=NULL;\\n             }\\n            curr=curr->right; \\n         }\\n    }    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37242,
                "title": "my-simple-c-solution-with-4-ms",
                "content": "//4 ms\\n\\n    void flatten(struct TreeNode* root) {\\n        struct TreeNode* left_r;\\n        while(root!=NULL){\\n            if(root->left != NULL) {\\n            left_r = root->left;\\n            while(left_r->right != NULL) left_r = left_r->right;\\n            left_r->right = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            }\\n            root = root->right;\\n        }\\n    }",
                "solutionTags": [],
                "code": "//4 ms\\n\\n    void flatten(struct TreeNode* root) {\\n        struct TreeNode* left_r;\\n        while(root!=NULL){\\n            if(root->left != NULL) {\\n            left_r = root->left;\\n            while(left_r->right != NULL) left_r = left_r->right;\\n            left_r->right = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            }\\n            root = root->right;\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2338673,
                "title": "o-1-morris-traversal-approach-o-n-recursive-o-n-stack",
                "content": "We\\'ll see all the possible approaches for this solution.\\n### **Using Morris Traversal Approach**\\nTime complexity for Morris Traversal approach : O(n)\\nSpace complexity for Morris Traversal approach : O(1)\\n##### *Working of Morris Traversal*\\n1. Move in a tree till you find it\\'s right last node\\n2. Attach that node\\'s left last right node to node\\'s right\\n3. Attach node\\'s left node as it right\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n\\t    //Base condition\\n        if(root==nullptr) return;\\n\\t\\t//temporary node to traverse\\n        TreeNode* cur=root;\\n        while(cur!=nullptr)\\n        {\\n\\t\\t   //if you left child, move in it\\'s subtree till you find it\\'s last right child\\n            if(cur->left!=nullptr)\\n            {\\n                TreeNode* prev=cur->left;\\n                while(prev->right)\\n                    prev=prev->right;\\n\\t\\t\\t\\t//add it\\'s last right node to root right\\n                prev->right=cur->right;\\n\\t\\t\\t\\t//add it\\'s root left to root right. To make it flatten\\n                cur->right=cur->left;\\n\\t\\t\\t\\t//make left node as null\\n                cur->left=nullptr;\\n            }\\n\\t\\t\\t//change temporary node to it\\'s right for next traversal\\n            cur=cur->right;\\n        }\\n        root=cur;\\n    }\\n};\\n```\\n### **Using Recursion**\\nTime complexity for recursive approach : O(n)\\nSpace complexity for recursive approach : O(n)\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* prev=nullptr;\\n    void flatten(TreeNode* node) {\\n        if(node==nullptr)\\n            return;\\n        flatten(node->right);\\n        flatten(node->left);\\n        node->right=prev;\\n        node->left=nullptr;\\n        prev=node;\\n    }\\n};\\n```\\n### **Using Stack**\\nTime complexity for stack approach : O(n)\\nSpace complexity for stack approach : O(n)\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root==nullptr) return;\\n        stack<TreeNode*> s;\\n        s.push(root);  \\n        TreeNode* cur;\\n        while(!s.empty())\\n        {\\n            cur=s.top();\\n            s.pop(); \\n            if(cur->right)\\n                s.push(cur->right);\\n            if(cur->left)\\n                s.push(cur->left);\\n            if(!s.empty())\\n                cur->right=s.top();\\n            cur->left=nullptr;\\n        }\\n        root=cur;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n\\t    //Base condition\\n        if(root==nullptr) return;\\n\\t\\t//temporary node to traverse\\n        TreeNode* cur=root;\\n        while(cur!=nullptr)\\n        {\\n\\t\\t   //if you left child, move in it\\'s subtree till you find it\\'s last right child\\n            if(cur->left!=nullptr)\\n            {\\n                TreeNode* prev=cur->left;\\n                while(prev->right)\\n                    prev=prev->right;\\n\\t\\t\\t\\t//add it\\'s last right node to root right\\n                prev->right=cur->right;\\n\\t\\t\\t\\t//add it\\'s root left to root right. To make it flatten\\n                cur->right=cur->left;\\n\\t\\t\\t\\t//make left node as null\\n                cur->left=nullptr;\\n            }\\n\\t\\t\\t//change temporary node to it\\'s right for next traversal\\n            cur=cur->right;\\n        }\\n        root=cur;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* prev=nullptr;\\n    void flatten(TreeNode* node) {\\n        if(node==nullptr)\\n            return;\\n        flatten(node->right);\\n        flatten(node->left);\\n        node->right=prev;\\n        node->left=nullptr;\\n        prev=node;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root==nullptr) return;\\n        stack<TreeNode*> s;\\n        s.push(root);  \\n        TreeNode* cur;\\n        while(!s.empty())\\n        {\\n            cur=s.top();\\n            s.pop(); \\n            if(cur->right)\\n                s.push(cur->right);\\n            if(cur->left)\\n                s.push(cur->left);\\n            if(!s.empty())\\n                cur->right=s.top();\\n            cur->left=nullptr;\\n        }\\n        root=cur;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1207552,
                "title": "c-simple-recursive-clean-code",
                "content": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(nullptr == root)\\n            return;\\n        \\n        TreeNode *right_node = root->right;\\n        \\n        //Recursive call on left subtree\\n        flatten(root->left);        \\n        \\n        //Adjust left and right child pointers\\n        root->right = root->left; \\n        root->left = nullptr;\\n        \\n        \\n        while(root->right)\\n            root = root->right;\\n        \\n        //Recursive call on right subtree\\n        flatten(right_node);        \\n        \\n        //Adjust right child pointer node\\n        root->right = right_node;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(nullptr == root)\\n            return;\\n        \\n        TreeNode *right_node = root->right;\\n        \\n        //Recursive call on left subtree\\n        flatten(root->left);        \\n        \\n        //Adjust left and right child pointers\\n        root->right = root->left; \\n        root->left = nullptr;\\n        \\n        \\n        while(root->right)\\n            root = root->right;\\n        \\n        //Recursive call on right subtree\\n        flatten(right_node);        \\n        \\n        //Adjust right child pointer node\\n        root->right = right_node;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1096456,
                "title": "python-3-solutions-iteration-and-recursion",
                "content": "iteration:\\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        #\\n        ## iteration\\n        # For each node cur, if it has a left subtree, we put it on the right\\n        # subtree of the node cur, and we put the right subtree of the node cur\\n        # at the right bottom of the left subtree. \\n        cur = root\\n        while cur:\\n            if cur.left:\\n                left = cur.left        # get the left subtree of cur\\n                right = cur.right      # get the right subtree of cur\\n                cur.left = None        # cur\\'s left subtree set to be None\\n                cur.right = left       # switch the left subtree to the right subtree\\n                while left.right:      # get the far-rigth leaf of the left subtree\\n                    left = left.right  \\n                left.right = right     # put the right subtree of cur as the right subtree of the far-right leaf\\n            cur = cur.right            # go down the right direction\\n```\\nrecursion\\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.prev = None\\n    \\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        #\\n        ## recursion\\n        if not root:\\n            pass\\n        else:\\n            self.flatten(root.right)\\n            self.flatten(root.left)\\n            root.right = self.prev\\n            root.left = None\\n            self.prev = root\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        #\\n        ## iteration\\n        # For each node cur, if it has a left subtree, we put it on the right\\n        # subtree of the node cur, and we put the right subtree of the node cur\\n        # at the right bottom of the left subtree. \\n        cur = root\\n        while cur:\\n            if cur.left:\\n                left = cur.left        # get the left subtree of cur\\n                right = cur.right      # get the right subtree of cur\\n                cur.left = None        # cur\\'s left subtree set to be None\\n                cur.right = left       # switch the left subtree to the right subtree\\n                while left.right:      # get the far-rigth leaf of the left subtree\\n                    left = left.right  \\n                left.right = right     # put the right subtree of cur as the right subtree of the far-right leaf\\n            cur = cur.right            # go down the right direction\\n```\n```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.prev = None\\n    \\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        #\\n        ## recursion\\n        if not root:\\n            pass\\n        else:\\n            self.flatten(root.right)\\n            self.flatten(root.left)\\n            root.right = self.prev\\n            root.left = None\\n            self.prev = root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1023755,
                "title": "c-pre-order-solution-explained-100-time-97-space",
                "content": "My first approach was to store all the nodes using a pre-order traversal and then re-\"align\" them as requested.\\n\\nTo do so, we will need 2 class variables:\\n* `q`, an array of `2000` `TreeNode` pointers;\\n* `pos`, an index to be used on said array, initialised to `0`.\\n\\nIn our main function, we will first of all call `dfs` passing `root`.\\n\\nIn `dfs` we will:\\n* just `return` when `root` is `NULL`;\\n* add `root` to `q` and increase `pos` accordingly;\\n* call `dfs` recursively on both the `left` and `right` branch - handbook pre-order here.\\n\\nOnce done, back to our main function, we will just loop through all the elements stored in `q` and put them all one on the right of the other, removing every `left` child they might have, and we are done :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    TreeNode* q[2000];\\n    int pos = 0;\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n        q[pos++] = root;\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        dfs(root);\\n        for (int i = 1; i < pos; i++) {\\n            q[i - 1]->right = q[i];\\n            q[i - 1]->left = NULL;\\n        }\\n    }\\n};\\n```\\n\\nWas I satisfied? Nah!\\n\\nI wanted to do something cooler, without (explicitly) storing the nodes and then I went to create another solution.\\n\\nIn this version all the magic will be in `dfs`, that we will call only when have `root` (our recursion invariant is that `root` has to always be a non-`NULL` node).\\n\\nOur `dfs` function now has a return value and, more specifically, will always return the last node of the transformation.\\n\\nIn its body, will:\\n* check if the current `root` is childless, in which case we return it (since it is also the last node);\\n* otherwise, we:\\n\\t*  declare a `TreeNode` pointer `res`;\\n\\t*  check if we have a `right` branch and in case give it the value of `dfs(root->right)`;\\n\\t*  check if we have a `left` branch and in case:\\n\\t\\t*  assign the value of `dfss(root->left)` to `tmp`;\\n\\t\\t*  check if we have `root->right` and in case:\\n\\t\\t\\t*  set `tmp->right` to be `root->right`\\n\\t\\t\\t*  set `res` to be `tmp` otherwise;\\n\\t\\t*  attach the now flattend `root->left` to the `right` of `root`;\\n\\t\\t*  remove the `left` branch.\\n\\nFinally, we return `res` :)\\n\\nThe code (which seems a bit faster, but overall pretty comparable in terms of performance):\\n\\n```cpp\\nclass Solution {\\npublic:  \\n    TreeNode* dfs(TreeNode* root) {\\n        // edge case: childless node\\n        if (!root->left && !root->right) return root;\\n        TreeNode* res;\\n        if (root->right) {\\n            // res set to be the last node of the right branch\\n            res = dfs(root->right);\\n        }\\n        if (root->left) {\\n            // tmp is the last node on the flattened left branch\\n            TreeNode* tmp = dfs(root->left);\\n            // attaching the right branch at the end of it, if any\\n            if (root->right) tmp->right = root->right;\\n            // otherwise, tmp->second is our last node\\n            else res = tmp;\\n            // attaching the flattened left branch directly to the right of root\\n            root->right = root->left;\\n            // removing the left branch\\n            root->left = NULL;\\n        }\\n        return res;\\n    }\\n    void flatten(TreeNode* root) {\\n        if (root) dfs(root);\\n    }\\n};\\n```\\n\\nWas I satisfied?\\n\\nNope: I gave myself the challenge of doing without extra variables (no `res` and no `temp`) and I did it!\\n\\nThe code is a refactoring of the previous and it turns consistently faster:\\n\\n```cpp\\nclass Solution {\\npublic:  \\n    TreeNode* dfs(TreeNode* root) {\\n        // edge case: childless node\\n        if (!root->left && !root->right) return root;\\n        if (root->left) {\\n            // first case: only the left branch\\n            if (!root->right) {\\n                // attaching the flattened left branch directly to the right of root\\n                root->right = root->left;\\n                // removing the left branch\\n                root->left = NULL;\\n                // returning the last node of the new right branch (previous left)\\n                return dfs(root->right);\\n            }\\n            // attaching right to the end of the flatened left branch\\n            dfs(root->left)->right = root->right;\\n            // attaching the flattened left branch directly to the right of root\\n            root->right = root->left;\\n            // removing the left branch\\n            root->left = NULL;\\n        }\\n        // if we do not have a left branch, we can just return the flattened right\\n        return dfs(root->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        if (root) dfs(root);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Graph"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    TreeNode* q[2000];\\n    int pos = 0;\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n        q[pos++] = root;\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        dfs(root);\\n        for (int i = 1; i < pos; i++) {\\n            q[i - 1]->right = q[i];\\n            q[i - 1]->left = NULL;\\n        }\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:  \\n    TreeNode* dfs(TreeNode* root) {\\n        // edge case: childless node\\n        if (!root->left && !root->right) return root;\\n        TreeNode* res;\\n        if (root->right) {\\n            // res set to be the last node of the right branch\\n            res = dfs(root->right);\\n        }\\n        if (root->left) {\\n            // tmp is the last node on the flattened left branch\\n            TreeNode* tmp = dfs(root->left);\\n            // attaching the right branch at the end of it, if any\\n            if (root->right) tmp->right = root->right;\\n            // otherwise, tmp->second is our last node\\n            else res = tmp;\\n            // attaching the flattened left branch directly to the right of root\\n            root->right = root->left;\\n            // removing the left branch\\n            root->left = NULL;\\n        }\\n        return res;\\n    }\\n    void flatten(TreeNode* root) {\\n        if (root) dfs(root);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:  \\n    TreeNode* dfs(TreeNode* root) {\\n        // edge case: childless node\\n        if (!root->left && !root->right) return root;\\n        if (root->left) {\\n            // first case: only the left branch\\n            if (!root->right) {\\n                // attaching the flattened left branch directly to the right of root\\n                root->right = root->left;\\n                // removing the left branch\\n                root->left = NULL;\\n                // returning the last node of the new right branch (previous left)\\n                return dfs(root->right);\\n            }\\n            // attaching right to the end of the flatened left branch\\n            dfs(root->left)->right = root->right;\\n            // attaching the flattened left branch directly to the right of root\\n            root->right = root->left;\\n            // removing the left branch\\n            root->left = NULL;\\n        }\\n        // if we do not have a left branch, we can just return the flattened right\\n        return dfs(root->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        if (root) dfs(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1008188,
                "title": "cpp-solution-using-preorder-vector",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void preorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return ;\\n        v.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n   \\n \\n    \\n    TreeNode* tree(vector<int> v)\\n    {\\n        if(v.size()==0)\\n            return NULL;\\n        TreeNode* r=new TreeNode(v[0]);\\n        TreeNode* temp=r;\\n        for(int i=1;i<v.size();i++){\\n            temp->left=NULL;\\n            temp->right=new TreeNode(v[i]);\\n            temp=temp->right;}\\n        return r ;\\n    }\\n    \\n    \\n    void flatten(TreeNode* root) {\\n        if(root==NULL){\\n            return ;\\n        }\\n        //vector preorder transveral\\n         preorder(root);\\n        //make a new tree using vector\\n        TreeNode* r= tree(v);\\n        root->right=r->right;\\n        root->left=NULL;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> v;\\n    void preorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return ;\\n        v.push_back(root->val);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n   \\n \\n    \\n    TreeNode* tree(vector<int> v)\\n    {\\n        if(v.size()==0)\\n            return NULL;\\n        TreeNode* r=new TreeNode(v[0]);\\n        TreeNode* temp=r;\\n        for(int i=1;i<v.size();i++){\\n            temp->left=NULL;\\n            temp->right=new TreeNode(v[i]);\\n            temp=temp->right;}\\n        return r ;\\n    }\\n    \\n    \\n    void flatten(TreeNode* root) {\\n        if(root==NULL){\\n            return ;\\n        }\\n        //vector preorder transveral\\n         preorder(root);\\n        //make a new tree using vector\\n        TreeNode* r= tree(v);\\n        root->right=r->right;\\n        root->left=NULL;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 482065,
                "title": "intuitive-javascript-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar flatten = function(root) {\\n    // right, left, root -> postorder dfs\\n    // set left child to null & set right child to the previous node\\n    let prev = null;\\n    const traverse = node => {\\n        if (node === null) {\\n            return;\\n        }\\n        \\n        traverse(node.right);\\n        traverse(node.left);\\n        \\n        // task\\n        node.left = null;\\n        node.right = prev;\\n        prev = node;\\n        \\n    } \\n    \\n    traverse(root);\\n      \\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar flatten = function(root) {\\n    // right, left, root -> postorder dfs\\n    // set left child to null & set right child to the previous node\\n    let prev = null;\\n    const traverse = node => {\\n        if (node === null) {\\n            return;\\n        }\\n        \\n        traverse(node.right);\\n        traverse(node.left);\\n        \\n        // task\\n        node.left = null;\\n        node.right = prev;\\n        prev = node;\\n        \\n    } \\n    \\n    traverse(root);\\n      \\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 268085,
                "title": "divide-and-conquer-postorder-solution",
                "content": "The idea is \\n1. convert left subtree into a list; \\n2. convert right into a list; \\n3. connect root with leftList.head and then leftList.tail to rightList.head. \\n\\nThe key is to find the head and tail of each converted list. Good news is that head is always root, we only to figure out how to get the tail. The idea is that if the tail of right subtree is not null, we\\'ve got the answer, otherwise, tail of left subtree, or root.\\n```\\npublic void flatten(TreeNode root) {\\n        flattenAndGetTail(root);    \\n    }\\n    public TreeNode flattenAndGetTail(TreeNode root)\\n    {\\n        if(root==null) return null;\\n        \\n        TreeNode leftTail = flattenAndGetTail(root.left);\\n        TreeNode rightTail = flattenAndGetTail(root.right);\\n        \\n        if(leftTail!=null)\\n        {\\n            leftTail.right = root.right;\\n            root.right = root.left;\\n            root.left = null;\\n        }\\n        \\n        if(rightTail!=null) return rightTail;\\n        if(leftTail!=null) return leftTail;\\n        return root;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic void flatten(TreeNode root) {\\n        flattenAndGetTail(root);    \\n    }\\n    public TreeNode flattenAndGetTail(TreeNode root)\\n    {\\n        if(root==null) return null;\\n        \\n        TreeNode leftTail = flattenAndGetTail(root.left);\\n        TreeNode rightTail = flattenAndGetTail(root.right);\\n        \\n        if(leftTail!=null)\\n        {\\n            leftTail.right = root.right;\\n            root.right = root.left;\\n            root.left = null;\\n        }\\n        \\n        if(rightTail!=null) return rightTail;\\n        if(leftTail!=null) return leftTail;\\n        return root;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 36980,
                "title": "clean-straight-forward-postorder-solution-easy-to-understand",
                "content": "I came up with another postorder solution, the idea is simple:\\n(1) flatten left subtree, return its tail node 'leftTail'\\n(2) flatten right subtree, return its tail node 'rightTail'\\n(3) if left subtree exists and has been flattened, we need to move it to the right:\\nset flattened right subtree as leftTail.right\\nset flattened left subtree to be the new right subtree(root.right)\\nset root.left=null\\n(4) return the tail node of this flattened tree (return rightTail if it isn't null, else return leftTail if it isn't null, else return root)\\n![0_1507853437658_Screen Shot 2017-10-12 at 5.10.04 PM.png](/assets/uploads/files/1507853438122-screen-shot-2017-10-12-at-5.10.04-pm.png) \\nI change the return type in order to keep only one recursive fuction, it works for leetcode:)\\n\\n    public TreeNode flatten(TreeNode root) {\\n        if(root==null) return null;\\n        TreeNode leftTail = flatten(root.left);\\n        TreeNode rightTail = flatten(root.right);        \\n        if(root.left!=null) {\\n            leftTail.right = root.right;\\n            root.right=root.left;\\n            root.left=null;\\n        }        \\n        return rightTail!=null?rightTail:(leftTail!=null?leftTail:root);\\n    }",
                "solutionTags": [],
                "code": "I came up with another postorder solution, the idea is simple:\\n(1) flatten left subtree, return its tail node 'leftTail'\\n(2) flatten right subtree, return its tail node 'rightTail'\\n(3) if left subtree exists and has been flattened, we need to move it to the right:\\nset flattened right subtree as leftTail.right\\nset flattened left subtree to be the new right subtree(root.right)\\nset root.left=null\\n(4) return the tail node of this flattened tree (return rightTail if it isn't null, else return leftTail if it isn't null, else return root)\\n![0_1507853437658_Screen Shot 2017-10-12 at 5.10.04 PM.png](/assets/uploads/files/1507853438122-screen-shot-2017-10-12-at-5.10.04-pm.png) \\nI change the return type in order to keep only one recursive fuction, it works for leetcode:)\\n\\n    public TreeNode flatten(TreeNode root) {\\n        if(root==null) return null;\\n        TreeNode leftTail = flatten(root.left);\\n        TreeNode rightTail = flatten(root.right);        \\n        if(root.left!=null) {\\n            leftTail.right = root.right;\\n            root.right=root.left;\\n            root.left=null;\\n        }        \\n        return rightTail!=null?rightTail:(leftTail!=null?leftTail:root);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2338726,
                "title": "python3-recursive-approach",
                "content": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.prev = None\\n    \\n    def flatten(self, root):\\n        if not root:\\n            return None\\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n\\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root\\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def __init__(self):\\n        self.prev = None\\n    \\n    def flatten(self, root):\\n        if not root:\\n            return None\\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n\\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 325131,
                "title": "python-dfs",
                "content": "* Python DFS solution 1 with run time O(T), space O(T)\\n\\n```\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        dfs = []\\n        dfs.append(root)\\n        while root and dfs:\\n            root = dfs.pop()\\n            if root.right:\\n                dfs.append(root.right)\\n            if root.left:\\n                dfs.append(root.left)\\n                root.right = root.left\\n                root.left = None\\n            else:\\n                if dfs:\\n                    root.right = dfs[-1]\\n                    root.left = None\\n```\\n* Python DFS solution 2 with run time O(T), space O(1) (O(maxDepth) including calling stack by recursion)\\n```\\nclass Solution:\\n    dummy = TreeNode(None)\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        ans = self.dummy\\n        self.MFS(root)\\n    \\n    def MFS(self,root):\\n        if not root:\\n            return\\n        # print(root.val)\\n        self.dummy.left = None\\n        self.dummy.right = root\\n        self.dummy = root\\n        l, r = root.left, root.right\\n        self.MFS(l)\\n        self.MFS(r)\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        dfs = []\\n        dfs.append(root)\\n        while root and dfs:\\n            root = dfs.pop()\\n            if root.right:\\n                dfs.append(root.right)\\n            if root.left:\\n                dfs.append(root.left)\\n                root.right = root.left\\n                root.left = None\\n            else:\\n                if dfs:\\n                    root.right = dfs[-1]\\n                    root.left = None\\n```\n```\\nclass Solution:\\n    dummy = TreeNode(None)\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        ans = self.dummy\\n        self.MFS(root)\\n    \\n    def MFS(self,root):\\n        if not root:\\n            return\\n        # print(root.val)\\n        self.dummy.left = None\\n        self.dummy.right = root\\n        self.dummy = root\\n        l, r = root.left, root.right\\n        self.MFS(l)\\n        self.MFS(r)\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 37280,
                "title": "an-standard-recursive-dfs-solution",
                "content": "    void flatten(TreeNode *root) {\\n        dfs(root);\\n    }\\n    \\n    TreeNode *dfs(TreeNode *root) {\\n        if (!root) return root;\\n        \\n        TreeNode *cur = root;\\n        TreeNode *left = dfs(root->left);\\n        TreeNode *right = dfs(root->right);\\n        \\n        if (left) {\\n            cur->left = NULL;\\n            cur->right = left; // set right pointer of the root node\\n            while (cur->right) cur = cur->right; // get the last node of the left side\\n        }\\n        \\n        cur->right = right; // right pointer of the last node of the left side\\n        return root;\\n    }",
                "solutionTags": [],
                "code": "    void flatten(TreeNode *root) {\\n        dfs(root);\\n    }\\n    \\n    TreeNode *dfs(TreeNode *root) {\\n        if (!root) return root;\\n        \\n        TreeNode *cur = root;\\n        TreeNode *left = dfs(root->left);\\n        TreeNode *right = dfs(root->right);\\n        \\n        if (left) {\\n            cur->left = NULL;\\n            cur->right = left; // set right pointer of the root node\\n            while (cur->right) cur = cur->right; // get the last node of the left side\\n        }\\n        \\n        cur->right = right; // right pointer of the last node of the left side\\n        return root;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3030571,
                "title": "c-beginner-friendly-two-solutions-o-n-o-1-space-complexity",
                "content": "**If You Helped, Please Upvote**\\n#### Brute Force\\n* Time Complexity = `O(N)`\\n* Space Complexity = `O(N)`\\n\\n```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> order;\\n    void preorder(TreeNode* root) {\\n        if(!root) return;\\n        order.push_back(root);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        preorder(root);\\n        for(int i = 1; i < order.size(); i++) {\\n            order[i-1] -> left = nullptr;\\n            order[i-1] -> right = order[i];\\n        }\\n    }\\n};\\n```\\n\\n#### Better Solution\\n* Time Complexity = `O(N)`\\n* Space Complexity = `O(1)`\\n\\n```\\nclass Solution {\\npublic:\\n     void flatten(TreeNode* root) {\\n        auto now = root;\\n\\n        while(now) {\\n            if(now -> left) {\\n                auto prev = now -> left;\\n                while(prev -> right) prev = prev -> right;\\n                prev -> right = now -> right;\\n                now -> right = now -> left;\\n                now -> left = nullptr;\\n            }\\n            now = now -> right;\\n        }\\n     }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<TreeNode*> order;\\n    void preorder(TreeNode* root) {\\n        if(!root) return;\\n        order.push_back(root);\\n        preorder(root->left);\\n        preorder(root->right);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        preorder(root);\\n        for(int i = 1; i < order.size(); i++) {\\n            order[i-1] -> left = nullptr;\\n            order[i-1] -> right = order[i];\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n     void flatten(TreeNode* root) {\\n        auto now = root;\\n\\n        while(now) {\\n            if(now -> left) {\\n                auto prev = now -> left;\\n                while(prev -> right) prev = prev -> right;\\n                prev -> right = now -> right;\\n                now -> right = now -> left;\\n                now -> left = nullptr;\\n            }\\n            now = now -> right;\\n        }\\n     }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362469,
                "title": "python-explained-recursion-faster-than-99-simple-solution",
                "content": "![image](https://assets.leetcode.com/users/images/cb226ebe-d627-43a3-8d8f-86a1b2402d84_1659325499.174214.png)\\n\\n```\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n\\n        # check if root exists\\n        if root:\\n            \\n            temp = root.right # store the right part of root\\n            \\n            root.right = root.left  # move the left part to the right\\n            root.left = None        # clear left part\\n            \\n            curr = root\\n            while curr.right:       # use while loop to find the bottom right side\\n                curr = curr.right\\n            curr.right = temp       # attach temp back\\n            \\n            #recursion\\n            self.flatten(root.right)\\n```\\nPlease UPVOTE if you like !!",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n\\n        # check if root exists\\n        if root:\\n            \\n            temp = root.right # store the right part of root\\n            \\n            root.right = root.left  # move the left part to the right\\n            root.left = None        # clear left part\\n            \\n            curr = root\\n            while curr.right:       # use while loop to find the bottom right side\\n                curr = curr.right\\n            curr.right = temp       # attach temp back\\n            \\n            #recursion\\n            self.flatten(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2341115,
                "title": "c-fastest-and-easy-to-understand-solution-with-line-by-line-explanation",
                "content": "Just do the preorder traversal and make the neccsary changes in the links\\nSee the C++ solution below\\n\\n```\\nclass Solution {\\npublic:\\n    void pre(TreeNode* root,TreeNode* &prev)\\n    {\\n        if(root==NULL)\\n            return;\\n        TreeNode* left = root->left; // store the values of left and right childs\\n        TreeNode* right = root->right;// as we are changing the links afterwards any may loose our original links\\n        if(prev == NULL) // if prev is NULL this means it is our head of the linked list\\n        {\\n            prev = root;\\n        }\\n        else // if not NULL then we need to make the required changes\\n        {\\n            prev->left = NULL;  // we make the left of prev as NULL\\n            prev->right = root; // and right of prev as current element\\n            prev = root; // Now make the current element as prev for further iterations\\n        }\\n        pre(left,prev); // simply do calls on left \\n        pre(right,prev);// and right child \\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode *prev = NULL; // prev stores the previous element in the preorder traversal\\n        pre(root,prev);\\n        \\n    }\\n};\\n```\\n\\nPlease upvote if you liked the solution. It really motivates me to post more solutions.",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void pre(TreeNode* root,TreeNode* &prev)\\n    {\\n        if(root==NULL)\\n            return;\\n        TreeNode* left = root->left; // store the values of left and right childs\\n        TreeNode* right = root->right;// as we are changing the links afterwards any may loose our original links\\n        if(prev == NULL) // if prev is NULL this means it is our head of the linked list\\n        {\\n            prev = root;\\n        }\\n        else // if not NULL then we need to make the required changes\\n        {\\n            prev->left = NULL;  // we make the left of prev as NULL\\n            prev->right = root; // and right of prev as current element\\n            prev = root; // Now make the current element as prev for further iterations\\n        }\\n        pre(left,prev); // simply do calls on left \\n        pre(right,prev);// and right child \\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode *prev = NULL; // prev stores the previous element in the preorder traversal\\n        pre(root,prev);\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1556044,
                "title": "c-recursive-and-morris-traversal-code-o-1-space",
                "content": "**Recursive solution space:O(n)**\\n```\\n void flatten(TreeNode* root) {\\n        if(!root){\\n            return ;\\n        }\\n        if(root->left){\\n            TreeNode* pred = root->left;\\n            while(pred->right){\\n                pred = pred->right;\\n            }\\n            pred->right = root->right;\\n            root->right = root->left;\\n            root->left = nullptr;\\n        }\\n        flatten(root->right);\\n    }\\n```\\n\\n**Constant space O(1) - Morris traversal implementation**\\n\\t\\n```\\n\\t void flatten(TreeNode* root) {\\n     if(!root){\\n         return;\\n     }   \\n        \\n     while(root){\\n         if(root->left){\\n         TreeNode* iter = root->left;\\n         while(iter->right){\\n             iter = iter->right;\\n         }\\n          iter->right = root->right;\\n          root->right = root->left;\\n          root->left = nullptr;\\n         }\\n         root  = root->right;\\n     }\\n    }",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n void flatten(TreeNode* root) {\\n        if(!root){\\n            return ;\\n        }\\n        if(root->left){\\n            TreeNode* pred = root->left;\\n            while(pred->right){\\n                pred = pred->right;\\n            }\\n            pred->right = root->right;\\n            root->right = root->left;\\n            root->left = nullptr;\\n        }\\n        flatten(root->right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1538893,
                "title": "easy-and-clean-c-code-o-1-space-just-do-reverse-preorder-traversal",
                "content": "```\\nclass Solution {\\n    \\n    void solve(TreeNode* root , TreeNode* &prev)\\n    {\\n          if(root == NULL) return ;\\n        \\n          solve(root->right , prev ) ;\\n          solve(root->left , prev ) ;\\n        \\n          root->right = prev ;\\n          root->left = NULL ;\\n        \\n          prev = root ;\\n          \\n    }\\n    \\npublic:\\n    void flatten(TreeNode* root) {\\n        \\n        TreeNode* prev = NULL ;\\n        solve(root , prev) ;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    void solve(TreeNode* root , TreeNode* &prev)\\n    {\\n          if(root == NULL) return ;\\n        \\n          solve(root->right , prev ) ;\\n          solve(root->left , prev ) ;\\n        \\n          root->right = prev ;\\n          root->left = NULL ;\\n        \\n          prev = root ;\\n          \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 870784,
                "title": "python-very-easy-to-understand-pre-order-traversal",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        if not root:\\n            return\\n\\n        nodes = []\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if not node:\\n                continue\\n            nodes.append(node)\\n            stack.append(node.right)\\n            stack.append(node.left)\\n\\n        root = nodes.pop(0)\\n        for node in nodes:\\n            root.right = node\\n            root.left = None\\n            root = node\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        if not root:\\n            return\\n\\n        nodes = []\\n        stack = [root]\\n        while stack:\\n            node = stack.pop()\\n            if not node:\\n                continue\\n            nodes.append(node)\\n            stack.append(node.right)\\n            stack.append(node.left)\\n\\n        root = nodes.pop(0)\\n        for node in nodes:\\n            root.right = node\\n            root.left = None\\n            root = node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307669,
                "title": "javascript-recursive-reverse-traversal",
                "content": "Inspired by this solution https://leetcode.com/problems/convert-bst-to-greater-tree/discuss/197556/Javascript-very-fast-solution\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar flatten = function(root) {\\n    let nextOne = null;\\n    \\n    const update = node => {\\n        if (!node) return node;\\n        \\n        update(node.right);\\n        update(node.left);\\n        node.right = nextOne;\\n        node.left = null;\\n        nextOne = node;   \\n    }\\n    \\n    update(root);\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar flatten = function(root) {\\n    let nextOne = null;\\n    \\n    const update = node => {\\n        if (!node) return node;\\n        \\n        update(node.right);\\n        update(node.left);\\n        node.right = nextOne;\\n        node.left = null;\\n        nextOne = node;   \\n    }\\n    \\n    update(root);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37195,
                "title": "concise-java-recursive-solution",
                "content": "    \\tpublic void flatten(TreeNode root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn;\\n\\n\\t\\tflatten(root.left);\\n\\t\\tflatten(root.right);\\n\\t\\tTreeNode left = root.left;\\n\\t\\tTreeNode right = root.right;\\n\\t\\troot.left = null;\\n\\t\\troot.right = left;\\n\\t\\twhile (root.right != null)\\n\\t\\t\\troot = root.right;\\n\\t\\troot.right = right;\\n\\t}",
                "solutionTags": [],
                "code": "    \\tpublic void flatten(TreeNode root) {\\n\\t\\tif (root == null)\\n\\t\\t\\treturn;\\n\\n\\t\\tflatten(root.left);\\n\\t\\tflatten(root.right);\\n\\t\\tTreeNode left = root.left;\\n\\t\\tTreeNode right = root.right;\\n\\t\\troot.left = null;\\n\\t\\troot.right = left;\\n\\t\\twhile (root.right != null)\\n\\t\\t\\troot = root.right;\\n\\t\\troot.right = right;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 37214,
                "title": "python-recursive-solution-with-comments",
                "content": "        \\n    # recusively       \\n    def flatten1(self, root):\\n        self.helper(root)\\n        \\n    def helper(self, root):\\n        if not root:\\n            return\\n        l = self.helper(root.left)\\n        r = self.helper(root.right)\\n        if l:\\n            root.right = l\\n            while l and l.right:\\n                l = l.right\\n            l.right = r\\n            root.left = None # take care here\\n        return root\\n        \\n    # recusively\\n    def flatten(self, root):\\n        if not root:\\n            return \\n        # flatten left child \\n        self.flatten(root.left)\\n        # flatten right child\\n        self.flatten(root.right)\\n        # insert left child to the middle of \\n        # root and right child\\n        tail = root.left\\n        if tail:\\n            while tail and tail.right:\\n                tail = tail.right\\n            tail.right = root.right\\n            root.right = root.left\\n            root.left = None",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "        \\n    # recusively       \\n    def flatten1(self, root):\\n        self.helper(root)\\n        \\n    def helper(self, root):\\n        if not root:\\n            return\\n        l = self.helper(root.left)\\n        r = self.helper(root.right)\\n        if l:\\n            root.right = l\\n            while l and l.right:\\n                l = l.right\\n            l.right = r\\n            root.left = None # take care here\\n        return root\\n        \\n    # recusively\\n    def flatten(self, root):\\n        if not root:\\n            return \\n        # flatten left child \\n        self.flatten(root.left)\\n        # flatten right child\\n        self.flatten(root.right)\\n        # insert left child to the middle of \\n        # root and right child\\n        tail = root.left\\n        if tail:\\n            while tail and tail.right:\\n                tail = tail.right\\n            tail.right = root.right\\n            root.right = root.left\\n            root.left = None",
                "codeTag": "Python3"
            },
            {
                "id": 37238,
                "title": "pre-order-solution",
                "content": "use a pointer \"pre\", then  pre order the tree.\\n\\n    void flatten(TreeNode* root) {\\n        if (!root) return;\\n        TreeNode dummy(-1), *pre = &dummy;\\n        flatten(root, pre);\\n    }\\n    \\n    void flatten(TreeNode* root, TreeNode* &pre) {\\n        if (!root) return;\\n        TreeNode *rightChild = root->right;\\n        pre->right = root;\\n        pre->left = NULL;\\n        pre = root;\\n        flatten(root->left, pre);\\n        flatten(rightChild, pre);\\n    }",
                "solutionTags": [],
                "code": "use a pointer \"pre\", then  pre order the tree.\\n\\n    void flatten(TreeNode* root) {\\n        if (!root) return;\\n        TreeNode dummy(-1), *pre = &dummy;\\n        flatten(root, pre);\\n    }\\n    \\n    void flatten(TreeNode* root, TreeNode* &pre) {\\n        if (!root) return;\\n        TreeNode *rightChild = root->right;\\n        pre->right = root;\\n        pre->left = NULL;\\n        pre = root;\\n        flatten(root->left, pre);\\n        flatten(rightChild, pre);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3820585,
                "title": "2-methods-explained-easy-code-c-beats-100",
                "content": "# Method #1: \\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Make a helper function to do all tasks neatly \\uD83D\\uDE01\\n- Let\\'s say the root is **NULL** return (nothing to do \\uD83E\\uDD73)\\n- And if a single node present (nothing to do)\\n- Otherwise we need to make cases and understand.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- We can create a function for handling the cases and it will return pair of treeNode.\\n- Store the result from the left and right using recursion.\\n- Cases\\n    - Let\\'s say the left is NULL:\\n        - Now the right of root should connects from right-head.\\n        - Return root, tail-right\\n        \\n- Make root->left = NULL\\n    - Else:\\n        - Root right will be the head-left, and if right-head is NULL:\\n            - Return root, tail-left\\n        - else \\n            - Root right should connect with left-head\\n            - And in right of left-tail there should be right-head.\\n            - Return root, right-tail \\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1) or stack space = O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        go(root);\\n    }\\n\\n    pair<TreeNode*, TreeNode*> go(TreeNode* root){\\n        if(!root){\\n            return {root, root};\\n        }\\n        if(!root->left && !root->right){\\n            return {root, root};\\n        }\\n\\n        pair<TreeNode*, TreeNode*> left = go(root->left);\\n        pair<TreeNode*, TreeNode*> right = go(root->right);\\n        \\n        TreeNode *headl = left.first;\\n        TreeNode *headr = right.first;\\n        TreeNode *taill = left.second;\\n        TreeNode *tailr = right.second;\\n\\n        if(!root->left){\\n            root->right = headr;\\n            return {root, tailr};\\n        }\\n        root->left = NULL;\\n\\n        if(!headr){\\n            root->right = headl;\\n            return {root, taill};\\n        }else{\\n            root->right = headl;\\n            taill->right = headr;\\n            return {root, tailr};\\n        }    \\n    }\\n};\\n```\\n\\n\\n\\n# Method #2: \\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- Use **Morris Traversal**\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode *findPredicate(TreeNode *curr){\\n        curr=curr->left;\\n        while(curr->right!=NULL){\\n            curr=curr->right;\\n        }\\n        return curr;\\n    }\\n\\n    void flatten(TreeNode *root){\\n        TreeNode *curr=root;\\n        while(curr!=NULL){\\n            if(curr->left){\\n                TreeNode *pred=findPredicate(curr);\\n                pred->right=curr->right;\\n                curr->right=curr->left;\\n                curr->left=NULL;\\n            }\\n            \\n        curr=curr->right;\\n        }\\n    \\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Linked List",
                    "Stack",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        go(root);\\n    }\\n\\n    pair<TreeNode*, TreeNode*> go(TreeNode* root){\\n        if(!root){\\n            return {root, root};\\n        }\\n        if(!root->left && !root->right){\\n            return {root, root};\\n        }\\n\\n        pair<TreeNode*, TreeNode*> left = go(root->left);\\n        pair<TreeNode*, TreeNode*> right = go(root->right);\\n        \\n        TreeNode *headl = left.first;\\n        TreeNode *headr = right.first;\\n        TreeNode *taill = left.second;\\n        TreeNode *tailr = right.second;\\n\\n        if(!root->left){\\n            root->right = headr;\\n            return {root, tailr};\\n        }\\n        root->left = NULL;\\n\\n        if(!headr){\\n            root->right = headl;\\n            return {root, taill};\\n        }else{\\n            root->right = headl;\\n            taill->right = headr;\\n            return {root, tailr};\\n        }    \\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    TreeNode *findPredicate(TreeNode *curr){\\n        curr=curr->left;\\n        while(curr->right!=NULL){\\n            curr=curr->right;\\n        }\\n        return curr;\\n    }\\n\\n    void flatten(TreeNode *root){\\n        TreeNode *curr=root;\\n        while(curr!=NULL){\\n            if(curr->left){\\n                TreeNode *pred=findPredicate(curr);\\n                pred->right=curr->right;\\n                curr->right=curr->left;\\n                curr->left=NULL;\\n            }\\n            \\n        curr=curr->right;\\n        }\\n    \\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605325,
                "title": "short-easy-c-solution-faster-than-100",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nTreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root==NULL)\\n        return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->right = prev;\\n        root->left = NULL;\\n        prev = root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nTreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root==NULL)\\n        return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->right = prev;\\n        root->left = NULL;\\n        prev = root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3169579,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        std::ios_base::sync_with_stdio(false);\\n        std::cin.tie(nullptr);\\n        std::cout.tie(nullptr);\\n        if(!root)   return;\\n        if(!root->left && !root->right) return;\\n\\n        flatten(root->left);\\n        if(root->left){\\n            TreeNode* save= root->right;\\n            root->right= root->left;\\n            root->left= NULL;\\n            TreeNode* temp= root;\\n            while(temp->right){\\n                temp= temp->right;\\n            }\\n            temp->right= save;\\n        }\\n        flatten(root->right);\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \\n        self.cur = None\\n        \\n        def dfs(node):\\n            if not node:\\n                return\\n            left, right = node.left, node.right\\n            node.left = None\\n            if self.cur:\\n                self.cur.right = node\\n                self.cur = self.cur.right\\n            else:\\n                self.cur = node\\n            dfs(left)\\n            dfs(right)\\n        \\n        dfs(root)\\n```\\n\\n```Java []\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode node = root;\\n        while(node != null)\\n        {\\n            if(node.left != null)\\n            {\\n                TreeNode left = node.left;\\n                while(left.right != null)\\n                    left = left.right;\\n                left.right = node.right;\\n                node.right = node.left;\\n                node.left = null;\\n            }\\n            node = node.right;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        std::ios_base::sync_with_stdio(false);\\n        std::cin.tie(nullptr);\\n        std::cout.tie(nullptr);\\n        if(!root)   return;\\n        if(!root->left && !root->right) return;\\n\\n        flatten(root->left);\\n        if(root->left){\\n            TreeNode* save= root->right;\\n            root->right= root->left;\\n            root->left= NULL;\\n            TreeNode* temp= root;\\n            while(temp->right){\\n                temp= temp->right;\\n            }\\n            temp->right= save;\\n        }\\n        flatten(root->right);\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \\n        self.cur = None\\n        \\n        def dfs(node):\\n            if not node:\\n                return\\n            left, right = node.left, node.right\\n            node.left = None\\n            if self.cur:\\n                self.cur.right = node\\n                self.cur = self.cur.right\\n            else:\\n                self.cur = node\\n            dfs(left)\\n            dfs(right)\\n        \\n        dfs(root)\\n```\n```Java []\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode node = root;\\n        while(node != null)\\n        {\\n            if(node.left != null)\\n            {\\n                TreeNode left = node.left;\\n                while(left.right != null)\\n                    left = left.right;\\n                left.right = node.right;\\n                node.right = node.left;\\n                node.left = null;\\n            }\\n            node = node.right;\\n        }\\n    }\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2338633,
                "title": "daily-leetcoding-challenge-july-day-27",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 27.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 3 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursion\n\n  \n**Approach 2:** Iterative Solution using Stack \n\n  \n**Approach 3:** O(1) Iterative Solution\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n**Approach 3:** O(1) Iterative Solution\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1403249,
                "title": "python-simple-dfs-solution-no-helper-method",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        if root is None:\\n            return\\n        \\n        self.flatten(root.left)\\n        self.flatten(root.right)\\n        \\n        right = root.right\\n        root.right = root.left\\n        root.left = None\\n        \\n        while root.right:\\n            root = root.right\\n        \\n        root.right = right\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        if root is None:\\n            return\\n        \\n        self.flatten(root.left)\\n        self.flatten(root.right)\\n        \\n        right = root.right\\n        root.right = root.left\\n        root.left = None\\n        \\n        while root.right:\\n            root = root.right\\n        \\n        root.right = right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1240099,
                "title": "easy-in-place-c-solution-recursive-and-iterative-approach",
                "content": "**Recursive solution**\\n```\\nclass Solution \\n{\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        if(!root || (!root->left && !root->right))\\n        {\\n            return;\\n        }\\n        if(root->left)\\n        {\\n            flatten(root->left);\\n            TreeNode *tmp=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            TreeNode *t=root->right;\\n            while(t->right)\\n            {\\n                t=t->right;\\n            }\\n            t->right=tmp;\\n        }\\n        flatten(root->right);\\n    }\\n};\\n```\\n\\n**Iterative solution**\\n```\\nclass Solution \\n{\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        while(root)\\n        {\\n            if(root->left)\\n            {\\n                TreeNode *tmp=root->left;\\n                while(tmp->right)\\n                {\\n                    tmp=tmp->right;\\n                }\\n                tmp->right=root->right;\\n                root->right=root->left;\\n                root->left=NULL;\\n            }\\n            root=root->right;\\n        }\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        if(!root || (!root->left && !root->right))\\n        {\\n            return;\\n        }\\n        if(root->left)\\n        {\\n            flatten(root->left);\\n            TreeNode *tmp=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            TreeNode *t=root->right;\\n            while(t->right)\\n            {\\n                t=t->right;\\n            }\\n            t->right=tmp;\\n        }\\n        flatten(root->right);\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        while(root)\\n        {\\n            if(root->left)\\n            {\\n                TreeNode *tmp=root->left;\\n                while(tmp->right)\\n                {\\n                    tmp=tmp->right;\\n                }\\n                tmp->right=root->right;\\n                root->right=root->left;\\n                root->left=NULL;\\n            }\\n            root=root->right;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778647,
                "title": "simple-and-clean-iterative-space-o-1-solution-java",
                "content": "## Summary\\nIterative, O(1) space, O(n) time, Morris Traversal\\n\\n## Thinking Process\\nThe thinking process is inspired by the \"rotation\" operations in red-black trees, i.e. find some operations that can simplify the tree structure.\\n\\n* 0. For root without left subtree, there doesn\\'t need any operation on root and its links.\\n\\nThe following operations do not change the order in flattened list since the tree is flattened in preorder (root-left-right):\\n* 1. For root with both non-empty left and right subtrees, move right subtree to the right child of the last node in preorder in left subtree, i.e. the right tail of left subtree. **(\"shift left\")**\\n* 2. For root with only left subtree, move left subtree to right **(\"shift right\")**\\n\\nBy repeating operation 1 and 2, we can always turn the tree into one that satisfies observation 0 and simply move on to root.right.\\n\\n## Complexity\\n* Space complexity is O(1)\\n* Time complexity is O(n), each node is visited at most twice, once in the main for loop, once in finding rightTail while loop.\\n\\nThe final code is very similar to Morris Traversal, but much much easier to understand.\\n\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        for (TreeNode curr = root; curr != null; curr = curr.right) {\\n            shiftLeft(curr);\\n            shiftRight(curr);\\n        }\\n    }\\n    \\n    // move right subtree to the right child of rightTail of left subtree\\n    private void shiftLeft(TreeNode node) {\\n        if (node.left != null && node.right != null) {\\n            TreeNode rightMost = node.left;\\n            while (rightMost.right != null) {\\n                rightMost = rightMost.right;\\n            }\\n            rightMost.right = node.right;\\n            node.right = null;\\n        }\\n    }\\n\\n    // move left subtree to right when right subtree is empty\\n    private void shiftRight(TreeNode node) {\\n        if (node.left != null && node.right == null) {\\n            node.right = node.left;\\n            node.left = null;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        for (TreeNode curr = root; curr != null; curr = curr.right) {\\n            shiftLeft(curr);\\n            shiftRight(curr);\\n        }\\n    }\\n    \\n    // move right subtree to the right child of rightTail of left subtree\\n    private void shiftLeft(TreeNode node) {\\n        if (node.left != null && node.right != null) {\\n            TreeNode rightMost = node.left;\\n            while (rightMost.right != null) {\\n                rightMost = rightMost.right;\\n            }\\n            rightMost.right = node.right;\\n            node.right = null;\\n        }\\n    }\\n\\n    // move left subtree to right when right subtree is empty\\n    private void shiftRight(TreeNode node) {\\n        if (node.left != null && node.right == null) {\\n            node.right = node.left;\\n            node.left = null;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 716185,
                "title": "0ms-beats-100-morris-traversal-approach",
                "content": "```\\nclass Solution { //using Morris Approach\\n    public void flatten(TreeNode root) {\\n        \\n        TreeNode pre;\\n        if (root==null || (root.left==null && root.right==null)) return;\\n        while(root!=null){\\n            if(root.left==null){\\n                root=root.right;\\n            }\\n            else{\\n                pre=root.left;\\n                while(pre.right!=null){\\n                    pre=pred.right;\\n                }\\n\\t\\t\\t\\t\\n                pre.right=root.right;\\n                root.right=root.left;\\n                root.left=null;\\n                root=root.right;\\n                \\n            }\\n        }\\n            \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution { //using Morris Approach\\n    public void flatten(TreeNode root) {\\n        \\n        TreeNode pre;\\n        if (root==null || (root.left==null && root.right==null)) return;\\n        while(root!=null){\\n            if(root.left==null){\\n                root=root.right;\\n            }\\n            else{\\n                pre=root.left;\\n                while(pre.right!=null){\\n                    pre=pred.right;\\n                }\\n\\t\\t\\t\\t\\n                pre.right=root.right;\\n                root.right=root.left;\\n                root.left=null;\\n                root=root.right;\\n                \\n            }\\n        }\\n            \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 689298,
                "title": "c-short-solution",
                "content": "I just put the right node (if exist) to stack.\\nReconnect left subtree to right\\nIf it occurs that there is nothing to right - take from stack\\nAnd just go right till null and empty stack.\\n\\n```\\n    public void Flatten(TreeNode root) {\\n        var stack = new Stack<TreeNode>();\\n        while(root != null) {\\n            if(root.right != null)\\n                stack.Push(root.right);\\n\\n            root.right = root.left;\\n            root.left = null;\\n            if(root.right == null && stack.Count > 0)\\n                root.right = stack.Pop();\\n            root = root.right;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "Stack",
                    "Iterator"
                ],
                "code": "```\\n    public void Flatten(TreeNode root) {\\n        var stack = new Stack<TreeNode>();\\n        while(root != null) {\\n            if(root.right != null)\\n                stack.Push(root.right);\\n\\n            root.right = root.left;\\n            root.left = null;\\n            if(root.right == null && stack.Count > 0)\\n                root.right = stack.Pop();\\n            root = root.right;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 426976,
                "title": "kotlin-5-lines",
                "content": "```\\nfun flatten(root: TreeNode?, right: TreeNode? = null): Unit {\\n\\troot ?: return\\n\\n\\tflatten(root.left, root.right ?: right)\\n\\tflatten(root.right, right)\\n\\troot.right = root.left ?: root.right ?: right\\n\\troot.left = null\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\nfun flatten(root: TreeNode?, right: TreeNode? = null): Unit {\\n\\troot ?: return\\n\\n\\tflatten(root.left, root.right ?: right)\\n\\tflatten(root.right, right)\\n\\troot.right = root.left ?: root.right ?: right\\n\\troot.left = null\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 331804,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    private TreeNode prev = null;\\n\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right = prev;\\n        root.left = null;\\n        prev = root;\\n    }\\n}\\n```\\n\\nRuntime: 1 ms, faster than 40.73% of Java online submissions for Flatten Binary Tree to Linked List.\\nMemory Usage: 35.8 MB, less than 99.96% of Java online submissions for Flatten Binary Tree to Linked List.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private TreeNode prev = null;\\n\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right = prev;\\n        root.left = null;\\n        prev = root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 320662,
                "title": "c-o-n-linear-speed-solution-using-stored-node-from-right-subtree",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode *mTail = NULL;\\n    void flatten(TreeNode* root) {\\n        if (root == NULL) return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->left = NULL;\\n        root->right = mTail;\\n        TreeNode *aPrev = root;\\n        mTail = aPrev;\\n    }\\n    \\n};\\n```\\n\\nThis makes sense if you draw it out on paper and run through a few examples..... Makes some sense to me.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    TreeNode *mTail = NULL;\\n    void flatten(TreeNode* root) {\\n        if (root == NULL) return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->left = NULL;\\n        root->right = mTail;\\n        TreeNode *aPrev = root;\\n        mTail = aPrev;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 292424,
                "title": "python-very-simple-iterative-solution-o-1-space-16ms",
                "content": "1. Set root\\'s right as root\\'s left. \\n2. Set right most node as root\\'s right\\n3. Continue until end \\n\\nO(1) space. Avoids recursive stack present in many other solutions.\\n\\nEdit: Had no idea, but I guess this is somehow related to a \"Morris Traversal?\"\\n\\n```\\nclass Solution(object):\\n    def flatten(self, root):\\n        while root != None:\\n            if root.left == None:\\n                root = root.right \\n            else:\\n                temp = root.right\\n                root.right = root.left\\n                root.left = None\\n                root = root.right\\n                right = root\\n                while right.right != None:\\n                    right = right.right\\n                right.right = temp\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution(object):\\n    def flatten(self, root):\\n        while root != None:\\n            if root.left == None:\\n                root = root.right \\n            else:\\n                temp = root.right\\n                root.right = root.left\\n                root.left = None\\n                root = root.right\\n                right = root\\n                while right.right != None:\\n                    right = right.right\\n                right.right = temp\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416547,
                "title": "java-100-faster-2-approaches-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/855a5ff3-27d1-45e6-bd71-ee635493ad87_1681479710.8322535.png)\\n\\n# First Approach\\n```\\n\\n\\n// Initialize a global variable \"prev\" as null to keep track of the previous node in the flattened tree\\n    TreeNode prev = null;\\n\\n    // A method to flatten the given binary tree into a singly linked list in-place\\n    public void flatten(TreeNode root) {\\n        // If the root node is null, return\\n        if(root == null){\\n            return;\\n        }\\n\\n        // Recursively flatten the right subtree first\\n        flatten(root.right);\\n        // Recursively flatten the left subtree second\\n        flatten(root.left);\\n\\n        // Set the right child of the current node to the previous node in the flattened tree\\n        root.right = prev;\\n        // Set the left child of the current node to null\\n        root.left = null;\\n        // Update the previous node to be the current node\\n        prev = root;\\n    }\\n```\\n---\\n\\n\\n\\n\\n\\n# Second Approach\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public void flatten(TreeNode root) {\\n        \\n        // Call flattenHelper to recursively flatten the binary tree.\\n        flattenHelper(root);\\n    }\\n\\n    private TreeNode flattenHelper(TreeNode root) {\\n\\n        if (root == null) {\\n            // Base case: Return null if the current node is null.\\n            return null;\\n        }\\n\\n        // Recursively flatten the left and right subtrees of the current node.\\n        TreeNode leftTail = flattenHelper(root.left);\\n        TreeNode rightTail = flattenHelper(root.right);\\n\\n        if (leftTail != null) {\\n            // If the left subtree is not null, append it to the right subtree of the current node.\\n            // Set the right child of the left subtree\\'s tail to the right subtree of the current node.\\n            // Set the right child of the current node to the left subtree.\\n            // Set the left child of the current node to null.\\n            leftTail.right = root.right;\\n            root.right = root.left;\\n            root.left = null;\\n        }\\n\\n        if (rightTail != null) {\\n            // If the right subtree is not null, return its tail.\\n            return rightTail;\\n        }\\n\\n        if (leftTail != null) {\\n            // If the right subtree is null but the left subtree is not null, return the tail of the left subtree.\\n            return leftTail;\\n        }\\n\\n        // If both the left and right subtrees are null, return the current node as the tail.\\n        return root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Linked List",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n\\n\\n// Initialize a global variable \"prev\" as null to keep track of the previous node in the flattened tree\\n    TreeNode prev = null;\\n\\n    // A method to flatten the given binary tree into a singly linked list in-place\\n    public void flatten(TreeNode root) {\\n        // If the root node is null, return\\n        if(root == null){\\n            return;\\n        }\\n\\n        // Recursively flatten the right subtree first\\n        flatten(root.right);\\n        // Recursively flatten the left subtree second\\n        flatten(root.left);\\n\\n        // Set the right child of the current node to the previous node in the flattened tree\\n        root.right = prev;\\n        // Set the left child of the current node to null\\n        root.left = null;\\n        // Update the previous node to be the current node\\n        prev = root;\\n    }\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public void flatten(TreeNode root) {\\n        \\n        // Call flattenHelper to recursively flatten the binary tree.\\n        flattenHelper(root);\\n    }\\n\\n    private TreeNode flattenHelper(TreeNode root) {\\n\\n        if (root == null) {\\n            // Base case: Return null if the current node is null.\\n            return null;\\n        }\\n\\n        // Recursively flatten the left and right subtrees of the current node.\\n        TreeNode leftTail = flattenHelper(root.left);\\n        TreeNode rightTail = flattenHelper(root.right);\\n\\n        if (leftTail != null) {\\n            // If the left subtree is not null, append it to the right subtree of the current node.\\n            // Set the right child of the left subtree\\'s tail to the right subtree of the current node.\\n            // Set the right child of the current node to the left subtree.\\n            // Set the left child of the current node to null.\\n            leftTail.right = root.right;\\n            root.right = root.left;\\n            root.left = null;\\n        }\\n\\n        if (rightTail != null) {\\n            // If the right subtree is not null, return its tail.\\n            return rightTail;\\n        }\\n\\n        if (leftTail != null) {\\n            // If the right subtree is null but the left subtree is not null, return the tail of the left subtree.\\n            return leftTail;\\n        }\\n\\n        // If both the left and right subtrees are null, return the current node as the tail.\\n        return root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3295513,
                "title": "recursive-and-iterative-java-solution",
                "content": "\\n# Complexity\\n- Time complexity: \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n# Recursive Code\\n```\\n\\nclass Solution {\\n   \\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n\\n        flatten(root.left);\\n        flatten(root.right);\\n\\n        TreeNode left = root.left;\\n        TreeNode right = root.right;\\n\\n        root.left = null;\\n        root.right = left;\\n\\n        TreeNode temp = root;\\n        while(temp != null && temp.right != null) temp =temp.right;\\n\\n        temp.right = right;\\n    }\\n   \\n}\\n```\\n# Complexity\\n- Time Complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N)\\n- Space Complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(N)\\n\\n# Iterative Code Using Stack\\n```\\n\\nclass Solution {\\n   \\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n\\n        f(stack,root);\\n    }\\n    void f(Stack<TreeNode> stack , TreeNode root) {\\n\\n        while(!stack.isEmpty()) {\\n\\n            TreeNode curr = stack.peek();\\n            stack.pop();\\n\\n            if(curr.right != null) stack.push(curr.right);\\n            if(curr.left != null) stack.push(curr.left);\\n\\n            if(!stack.isEmpty()) {\\n                curr.right = stack.peek();\\n            }\\n\\n            curr.left = null;\\n\\n        }\\n    }\\n   \\n}\\n\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n   \\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n\\n        flatten(root.left);\\n        flatten(root.right);\\n\\n        TreeNode left = root.left;\\n        TreeNode right = root.right;\\n\\n        root.left = null;\\n        root.right = left;\\n\\n        TreeNode temp = root;\\n        while(temp != null && temp.right != null) temp =temp.right;\\n\\n        temp.right = right;\\n    }\\n   \\n}\\n```\n```\\n\\nclass Solution {\\n   \\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n\\n        Stack<TreeNode> stack = new Stack<>();\\n        stack.push(root);\\n\\n        f(stack,root);\\n    }\\n    void f(Stack<TreeNode> stack , TreeNode root) {\\n\\n        while(!stack.isEmpty()) {\\n\\n            TreeNode curr = stack.peek();\\n            stack.pop();\\n\\n            if(curr.right != null) stack.push(curr.right);\\n            if(curr.left != null) stack.push(curr.left);\\n\\n            if(!stack.isEmpty()) {\\n                curr.right = stack.peek();\\n            }\\n\\n            curr.left = null;\\n\\n        }\\n    }\\n   \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2340398,
                "title": "beats-100-other-s-solutions",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        \\n        # flatten the root tree and return the list tail\\n        def dfs(root):\\n            if not root: return None\\n            \\n            leftTail= dfs(root.left)\\n            rightTail = dfs(root.right)\\n            \\n            if leftTail: #can also be written as root.left\\n                leftTail.right = root.right\\n                root.right = root.left\\n                root.left = None\\n                \\n            # python trick, if rightTail is not null then it will be returned before computing entire expression\\n            return rightTail or leftTail or root\\n        \\n        return dfs(root)\\n```",
                "solutionTags": [
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        \\n        # flatten the root tree and return the list tail\\n        def dfs(root):\\n            if not root: return None\\n            \\n            leftTail= dfs(root.left)\\n            rightTail = dfs(root.right)\\n            \\n            if leftTail: #can also be written as root.left\\n                leftTail.right = root.right\\n                root.right = root.left\\n                root.left = None\\n                \\n            # python trick, if rightTail is not null then it will be returned before computing entire expression\\n            return rightTail or leftTail or root\\n        \\n        return dfs(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339815,
                "title": "java-short-sweet-solution",
                "content": "```\\nclass Solution {\\n  private TreeNode prev = null;\\n    public void flatten(TreeNode root) {\\n      if(root == null) return;\\n      \\n      flatten(root.right);\\n      flatten(root.left);\\n      root.right = prev;\\n      root.left = null;\\n     prev = root; \\n    }\\n}\\n```\\n\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n  private TreeNode prev = null;\\n    public void flatten(TreeNode root) {\\n      if(root == null) return;\\n      \\n      flatten(root.right);\\n      flatten(root.left);\\n      root.right = prev;\\n      root.left = null;\\n     prev = root; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2339813,
                "title": "c-without-with-preorder-traversal-easy-fastest",
                "content": "------------------------------Without preorder traversal------------------------------\\n```\\nvoid flatten(TreeNode* root){\\n\\tTreeNode* curr = root;\\n\\tTreeNode* now;\\n\\twhile(curr!=NULL){\\n\\t\\tif(curr->left!=NULL){\\n\\t\\t\\tnow = curr->left;\\n\\t\\t\\twhile(now->right!=NULL)\\n\\t\\t\\t\\t  now = now->right;\\n\\t\\t\\tnow->right = curr->right;\\n\\t\\t\\tcurr->right = curr->left;\\n\\t\\t\\tcurr->left = nullptr;\\n\\t\\t}\\n\\t\\tcurr = curr->right;\\n\\t}\\n}\\n```\\n\\n------------------------------With preorder traversal------------------------------\\n```\\nvector<int> vec;\\nvoid preorder(TreeNode* root){\\n\\tif(root==NULL)\\n\\t\\treturn;\\n\\tvec.push_back(root->val);\\n\\tpreorder(root->left);\\n\\tpreorder(root->right);\\n}\\n\\nvoid flatten(TreeNode* root) {\\n\\tif(root==NULL)\\n\\t\\treturn;\\n\\tpreorder(root);\\n\\tTreeNode* temp = root;\\n\\tfor(auto i: vec){\\n\\t\\ttemp->val = i;\\n\\t\\ttemp->left = NULL;\\n\\t\\ttemp->right = new TreeNode();\\n\\t\\ttemp = temp->right;\\n\\t}\\n\\ttemp = root;\\n\\twhile(temp->right->right!=nullptr){\\n\\t\\ttemp = temp->right;\\n\\t}\\n\\ttemp->right = NULL;\\n\\troot = temp;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nvoid flatten(TreeNode* root){\\n\\tTreeNode* curr = root;\\n\\tTreeNode* now;\\n\\twhile(curr!=NULL){\\n\\t\\tif(curr->left!=NULL){\\n\\t\\t\\tnow = curr->left;\\n\\t\\t\\twhile(now->right!=NULL)\\n\\t\\t\\t\\t  now = now->right;\\n\\t\\t\\tnow->right = curr->right;\\n\\t\\t\\tcurr->right = curr->left;\\n\\t\\t\\tcurr->left = nullptr;\\n\\t\\t}\\n\\t\\tcurr = curr->right;\\n\\t}\\n}\\n```\n```\\nvector<int> vec;\\nvoid preorder(TreeNode* root){\\n\\tif(root==NULL)\\n\\t\\treturn;\\n\\tvec.push_back(root->val);\\n\\tpreorder(root->left);\\n\\tpreorder(root->right);\\n}\\n\\nvoid flatten(TreeNode* root) {\\n\\tif(root==NULL)\\n\\t\\treturn;\\n\\tpreorder(root);\\n\\tTreeNode* temp = root;\\n\\tfor(auto i: vec){\\n\\t\\ttemp->val = i;\\n\\t\\ttemp->left = NULL;\\n\\t\\ttemp->right = new TreeNode();\\n\\t\\ttemp = temp->right;\\n\\t}\\n\\ttemp = root;\\n\\twhile(temp->right->right!=nullptr){\\n\\t\\ttemp = temp->right;\\n\\t}\\n\\ttemp->right = NULL;\\n\\troot = temp;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2339174,
                "title": "easy-c-sol-naive-efficient-approaches-time-o-n",
                "content": "```\\nAuthor : https://github.com/RajaKunalPandit1\\n\\n\\n// Recursive Sol : Time : O(N) :: Aux_Space : O(N)\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode *prev = NULL;\\n\\n    void flatten(TreeNode* root) {\\n\\n        if(root == NULL) return;\\n\\n        flatten(root->right);\\n        flatten(root->left);\\n\\n        root->right = prev;\\n        root->left = NULL;\\n        prev = root;\\n\\n    }\\n};\\n\\n// Iterative Solution Using Stack :: Time : O(N) :: Aux_Space : O(N)\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:    \\n    void flatten(TreeNode* root) {\\n\\n        if(root == NULL) return;\\n\\n        stack<TreeNode *> st;\\n\\n        st.push(root);\\n\\n        while(!st.empty()){\\n\\n            TreeNode *curr = st.top();\\n            st.pop();\\n\\n            if(curr->right != NULL)\\n                st.push(curr->right);\\n            if(curr->left != NULL)\\n                st.push(curr->left);\\n\\n            if(!st.empty()){\\n                curr->right = st.top();\\n            }\\n            curr->left = NULL;\\n        }\\n\\n    }\\n};\\n\\n// Efficient Solution :: Time : O(N) :: Aux_Space : O(1)\\n\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n\\n        TreeNode *curr = root;\\n        TreeNode *prev;\\n\\n        while(curr!= NULL){\\n\\n            if(curr->left != NULL){\\n\\n                prev = curr->left;\\n\\n                while(prev->right != NULL)\\n                    prev = prev->right;\\n\\n                prev->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n            }\\n            curr = curr->right;\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Stack",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n    TreeNode *prev = NULL;\\n\\n    void flatten(TreeNode* root) {\\n\\n        if(root == NULL) return;\\n\\n        flatten(root->right);\\n        flatten(root->left);\\n\\n        root->right = prev;\\n        root->left = NULL;\\n        prev = root;\\n\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2153770,
                "title": "recursive-o-n-time-o-1-extra-space-changed-links",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid link(TreeNode* root,TreeNode* &end){\\n\\t\\t\\tif(!root) return;\\n\\t\\t\\tTreeNode* temp = root->right;\\n\\t\\t\\tend = root;\\n\\t\\t\\tif(root->left){\\n\\t\\t\\t\\troot->right = root->left;\\n\\t\\t\\t\\troot->left = NULL;\\n\\t\\t\\t\\tlink(root->right,end);  // end will change once it goes inside the function\\n\\t\\t\\t\\tend->right = temp;      \\n\\t\\t\\t\\t// end contains the last element of preorder traversal of \\n\\t\\t\\t\\t// left subtree(which is now on right of root)\\n\\t\\t\\t}\\n\\t\\t\\tlink(temp,end); // end will change once it goes inside the function\\n\\n\\t\\t}\\n\\n\\t\\tvoid flatten(TreeNode* root) {\\n\\t\\t\\tTreeNode* end=NULL;\\n\\t\\t\\tlink(root,end);\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid link(TreeNode* root,TreeNode* &end){\\n\\t\\t\\tif(!root) return;\\n\\t\\t\\tTreeNode* temp = root->right;\\n\\t\\t\\tend = root;\\n\\t\\t\\tif(root->left){\\n\\t\\t\\t\\troot->right = root->left;\\n\\t\\t\\t\\troot->left = NULL;\\n\\t\\t\\t\\tlink(root->right,end);  // end will change once it goes inside the function\\n\\t\\t\\t\\tend->right = temp;      \\n\\t\\t\\t\\t// end contains the last element of preorder traversal of \\n\\t\\t\\t\\t// left subtree(which is now on right of root)\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1331782,
                "title": "easy-java-code-using-o-1-space-and-1ms-time",
                "content": "```\\n   public  TreeNode rightMost(TreeNode root) {\\n        while(root.right != null) {\\n            root = root.right;\\n        }\\n        return root;\\n    }\\n    public  void flatten(TreeNode root)\\n    {\\n        TreeNode curr = root;\\n        while(curr != null) {\\n            TreeNode left = curr.left;\\n                if(left != null) {\\n                    TreeNode rightMost = rightMost(left);\\n                    rightMost.right = curr.right;\\n                    curr.right = left;\\n                    curr.left = null;    \\n            }\\n            curr = curr.right;\\n        }\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n   public  TreeNode rightMost(TreeNode root) {\\n        while(root.right != null) {\\n            root = root.right;\\n        }\\n        return root;\\n    }\\n    public  void flatten(TreeNode root)\\n    {\\n        TreeNode curr = root;\\n        while(curr != null) {\\n            TreeNode left = curr.left;\\n                if(left != null) {\\n                    TreeNode rightMost = rightMost(left);\\n                    rightMost.right = curr.right;\\n                    curr.right = left;\\n                    curr.left = null;    \\n            }\\n            curr = curr.right;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1291042,
                "title": "c-recursive-solution-with-comments",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        //if root is null or it is a leaf node then return\\n        if(root==NULL)\\n            return;\\n        if(root->left == NULL && root->right==NULL)return ;\\n        \\n        // flattening process\\n        if(root->left != NULL){\\n            // get the left node\\n            flatten(root->left);\\n            \\n            // store the right node and make left node as right\\n            TreeNode* temp = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            \\n            TreeNode* current = root->right;\\n            // get the rightmost node\\n            while(current->right != NULL)current = current->right;\\n            \\n            // store the earlier right node as the rightmost node\\'s child\\n            current->right = temp;\\n        }\\n        // recurr the same process with the right child\\n        flatten(root->right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        //if root is null or it is a leaf node then return\\n        if(root==NULL)\\n            return;\\n        if(root->left == NULL && root->right==NULL)return ;\\n        \\n        // flattening process\\n        if(root->left != NULL){\\n            // get the left node\\n            flatten(root->left);\\n            \\n            // store the right node and make left node as right\\n            TreeNode* temp = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            \\n            TreeNode* current = root->right;\\n            // get the rightmost node\\n            while(current->right != NULL)current = current->right;\\n            \\n            // store the earlier right node as the rightmost node\\'s child\\n            current->right = temp;\\n        }\\n        // recurr the same process with the right child\\n        flatten(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279918,
                "title": "runtime-0-ms-faster-than-100-00-of-c-online-submissions-for-flatten-binary-tree-to-linked-list",
                "content": "```\\nvoid flatten(TreeNode* root) {\\n        if(!root){\\n            return;\\n        }\\n        if(root->left==NULL&&root->right==NULL){\\n            return;\\n        }\\n        if(root->left==NULL){\\n            flatten(root->right);\\n        }\\n        if(root->right==NULL){\\n            swap(root->left,root->right);\\n            flatten(root->right);\\n        }\\n        if(root->right&&root->left){\\n            flatten(root->left);\\n            flatten(root->right);\\n            swap(root->left,root->right);\\n          \\n            \\n           TreeNode* left = root->left;\\n            TreeNode* right = root->right;\\n            \\n            \\n            while(right->right!=NULL){\\n                right = right->right;\\n            }\\n            \\n                right->right = left;\\n           root->left = NULL;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid flatten(TreeNode* root) {\\n        if(!root){\\n            return;\\n        }\\n        if(root->left==NULL&&root->right==NULL){\\n            return;\\n        }\\n        if(root->left==NULL){\\n            flatten(root->right);\\n        }\\n        if(root->right==NULL){\\n            swap(root->left,root->right);\\n            flatten(root->right);\\n        }\\n        if(root->right&&root->left){\\n            flatten(root->left);\\n            flatten(root->right);\\n            swap(root->left,root->right);\\n          \\n            \\n           TreeNode* left = root->left;\\n            TreeNode* right = root->right;\\n            \\n            \\n            while(right->right!=NULL){\\n                right = right->right;\\n            }\\n            \\n                right->right = left;\\n           root->left = NULL;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1194995,
                "title": "java-two-solutions-recursion-in-order-traversal-o-n-and-iterative-0-ms",
                "content": "Time complexity:  `O(N)`.\\nSpace complexity: `O(H)`, for recursion stack, where `H` is the tree\\'s height.\\n\\n```\\nclass Solution {\\n    private TreeNode tail = new TreeNode(-1);\\n    \\n    public void flatten(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        tail.right = root;\\n        tail = root;\\n\\t\\t\\n        var left = root.left;\\n        var right = root.right;\\n        root.left = null;\\n        root.right = null;\\n\\t\\t\\n        flatten(left);\\n        flatten(right);\\n    }\\n}\\n```\\n\\n\\nTime complexity:  `O(N)`.\\nSpace complexity: `O(1)`.\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode node = root;\\n        while (node != null) {\\n            TreeNode left = node.left;\\n            node.left = null;\\n            TreeNode right = node.right;\\n            \\n            if (left == null) {\\n                node = right;\\n                continue;\\n            }\\n            \\n            TreeNode leftRight = left;\\n            while (leftRight.right != null) {\\n                leftRight = leftRight.right;\\n            }\\n            \\n            leftRight.right = right;\\n            node.right = left;\\n            node = node.right;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    private TreeNode tail = new TreeNode(-1);\\n    \\n    public void flatten(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        \\n        tail.right = root;\\n        tail = root;\\n\\t\\t\\n        var left = root.left;\\n        var right = root.right;\\n        root.left = null;\\n        root.right = null;\\n\\t\\t\\n        flatten(left);\\n        flatten(right);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode node = root;\\n        while (node != null) {\\n            TreeNode left = node.left;\\n            node.left = null;\\n            TreeNode right = node.right;\\n            \\n            if (left == null) {\\n                node = right;\\n                continue;\\n            }\\n            \\n            TreeNode leftRight = left;\\n            while (leftRight.right != null) {\\n                leftRight = leftRight.right;\\n            }\\n            \\n            leftRight.right = right;\\n            node.right = left;\\n            node = node.right;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138528,
                "title": "c-simple-code-100-faster",
                "content": "Approach:\\n1)Recursively flatten left and right subtree\\n2)Store right subtree in a Temp variable and then assign right subtree as left subtree and make left subtree as null\\n3)Now store the tail of right subtree (i.e is our left subtree) and assign that tail to temp variable\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL||(root->right == NULL && root->left == NULL)){\\n            return;\\n        }\\n        if(root->left != NULL){\\n            flatten(root->left);\\n            TreeNode* temp = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            \\n            TreeNode* t = root->right;\\n            while(t->right!=NULL){\\n                t = t->right;\\n            }\\n            t->right = temp;\\n        }\\n```\\n        flatten(root->right);\\n    }\\n};",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL||(root->right == NULL && root->left == NULL)){\\n            return;\\n        }\\n        if(root->left != NULL){\\n            flatten(root->left);\\n            TreeNode* temp = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            \\n            TreeNode* t = root->right;\\n            while(t->right!=NULL){\\n                t = t->right;\\n            }\\n            t->right = temp;\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1107010,
                "title": "solution-without-recursion-or-stack-true-o-1",
                "content": "Guys, the problem statement states O(1). That means we cannot use a stack or resursion. Yet, I see most people in the discussions are using either a stack or recursion. Those solutions wont get accepted in an interview!\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)\\n            return;\\n        \\n        TreeNode* curr = root;\\n        \\n        // Left subtree\\n        while(curr != NULL)\\n        {\\n            if(curr->left != NULL)\\n            {\\n                TreeNode* left = curr->left;\\n                TreeNode* right = curr->right;\\n                \\n                curr->left = NULL;\\n                curr->right = left;\\n                \\n                while(left->right != NULL)\\n                {\\n                    left = left->right;\\n                }\\n                left->right = right;\\n            }\\n            curr = curr->right;\\n           \\n        }\\n        \\n       \\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)\\n            return;\\n        \\n        TreeNode* curr = root;\\n        \\n        // Left subtree\\n        while(curr != NULL)\\n        {\\n            if(curr->left != NULL)\\n            {\\n                TreeNode* left = curr->left;\\n                TreeNode* right = curr->right;\\n                \\n                curr->left = NULL;\\n                curr->right = left;\\n                \\n                while(left->right != NULL)\\n                {\\n                    left = left->right;\\n                }\\n                left->right = right;\\n            }\\n            curr = curr->right;\\n           \\n        }\\n        \\n       \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978184,
                "title": "java-using-stack",
                "content": "\\tclass Solution {\\n    public void flatten(TreeNode root) {\\n         if (root == null)   return;\\n         Deque<TreeNode> stack = new LinkedList<>();\\n         stack.offer(root);\\n         while (!stack.isEmpty()) {             \\n             TreeNode cur = stack.pollLast();\\n            if(cur.right!=null) stack.offer(cur.right);\\n            if(cur.left!=null) stack.offer(cur.left);\\n             if (!stack.isEmpty()) cur.right = stack.peekLast();\\n             cur.left = null; \\n         }\\n    }\\n\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public void flatten(TreeNode root) {\\n         if (root == null)   return;\\n         Deque<TreeNode> stack = new LinkedList<>();\\n         stack.offer(root);\\n         while (!stack.isEmpty()) {             \\n             TreeNode cur = stack.pollLast();\\n            if(cur.right!=null) stack.offer(cur.right);\\n            if(cur.left!=null) stack.offer(cur.left);\\n             if (!stack.isEmpty()) cur.right = stack.peekLast();\\n             cur.left = null; \\n         }",
                "codeTag": "Java"
            },
            {
                "id": 841606,
                "title": "simple-9-line-cpp-solution-without-stack-and-recursion",
                "content": "```\\n void flatten(TreeNode* root) {\\n        while(root)\\n        {   TreeNode* temp=root;\\n            TreeNode* t=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            while(temp->right)\\n                temp=temp->right;\\n            temp->right=t;\\n            root=root->right;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Tree",
                    "Iterator"
                ],
                "code": "```\\n void flatten(TreeNode* root) {\\n        while(root)\\n        {   TreeNode* temp=root;\\n            TreeNode* t=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            while(temp->right)\\n                temp=temp->right;\\n            temp->right=t;\\n            root=root->right;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 750312,
                "title": "python3-solution-with-a-detailed-explanation-flatten-binary-tree-to-linkedlist",
                "content": "First note: most of the people on this website missed the first session of coding 101 class when instructor told them to comment your code so that others can read :D \\n\\nTry first to fully understand the problem. The tree is a binary tree but not binary search tree. Binary trees are structured in a way to be traversed recursively, and we\\'ll be using this properties of them in this solution. \\n\\nThe big picture is you need to flatten left subtree, replace right subtree with the flattened left subtree, and then flatten right subtree, and finally add it to the end of previously flatten (and now on right side of the root) left subtree. \\n```\\n\\t          root\\nleft subtree        right subtree\\n```\\n\\nshould change to \\n\\n```\\nroot\\n\\tleft subtree flattened\\n\\t\\t\\t\\t\\t\\tright subtree flattened\\n```\\n\\nYou would follow the same logic for every subtree using recursion. The recursion stops when you get to a node with a children (leaf) and no grand children. Basically, a node and one or two children. Let\\'s call node `a`, left child `b`, and right child `c`. \\n\\n```\\n\\t\\ta\\n\\tb\\t\\tc\\n```\\nOnce you have such a scenario, it will be changed to the following. Note that left children are `null`. \\n```\\n\\t\\t  a\\n\\t\\t/\\t  \\\\\\n\\tNone\\t     b\\t\\n\\t\\t\\t   /\\t\\\\\\n\\t\\t    None\\t c \\n```\\nMakes sense? Once you `flatten` the left bottom subtree, you move up from left side until you reach to `root`. Once you get to `root`, you do the same with `root.right`, and add it to the tail of `flatten`ed left subtree. Check the video link below for some numeric examples.\\n\\n\\nI didn\\'t come up with this solution and got it from the discussion posts (combination of a bunch of them). Mostly I used the idea and code from [here](https://www.youtube.com/watch?v=598gdjE6Quo).  I changed it to Python3. \\n\\n\\nThe code as follows: \\nIn line `#1`, we check whether root exists, otherwise, `return` nothing. In addition to the case when tree is empty, it also happens when you get to a leaf node and run line `#3` and there is not left child (because it\\'s leaf). \\n\\nLine `#2`: We first try to `flatten` left subtree. You can do it first for right subtree with some changes in the code. As mentioned above, we do it recursively. Check this image from the link above: \\n![image](https://assets.leetcode.com/users/images/5a277ea6-4d3e-40ad-962a-03c1d68f84b9_1595534726.875856.png)\\n\\n\\nYou focus on the left bottom first. Let\\'s say we\\'re on node `2`, we first make `3` the right subtree of `2` (line `#5`) while saving `4` to a temporary variable (line `#4`, `temp`). Next we add `4` to the tail of `2` (line `#10`) to get the middle blue graph. Next, we move left subtree (which is flattened) to the right side of root (line `#5`), while saving right subtree to a temporary variable (line `#5`). Later on after replacing right subtree with left one, we first flatten initial right subtree (line `#11`) and add it to the tail of new right subtree (previously left) to get the last tree (line `#10`). Note the recursion here, line `#11` gets activated and then we end up doing to line `10` at some points for some nodes.   \\n\\nLine `#3` is trying to recursively get to the bottom left of tree, when there, it saves the right subtree to `temp` (line `#4`). Replace the right subtree with left one (line `#5`). Note than in the base case of line `#5`, we\\'re dealing with one node as left subtree and one node as right subtree (check the `a`, `b`, `c` example above). We set the left subtree to `None` as instructed (line `#6`), and finally save the current right subtree (which was left subtree initially) to the `curr` variable (line `#7`). The reason is that we want to get to the tail of initially left subtree (currently right) so that we could add initially right subtree there. \\n\\nLine `#8` and `#9` do the traversal to get to the tail of current right subtree. When we get there, we attached the saved right subtree (`temp` variable) to the `curr` (which is the tail now) to get the final results. Now, so far everything is done for left side of `root`. However, similar approach can be done for the right side of the `root` as shown in line `#11`. You just need to pass the `root.right` to the `flatten` function and it\\'ll do the rest for you. Note that we don\\'t need to do all the work we\\'ve done between lines `#2` and `10` because once you pass the `root.right`, it\\'s similar to passing `root.left` in line `#3`. \\n\\n\\n```\\nclass Solution:\\n    def flatten(self, root):\\n        if not root: #1\\n            return\\n        \\n        if root.left: #2\\n            self.flatten(root.left) #3\\n            temp = root.right #4\\n            root.right = root.left #5\\n            root.left = None #6\\n            curr = root.right #7\\n            \\n            while curr.right: #8\\n                curr = curr.right #9\\n            \\n            curr.right = temp #10\\n        \\n        if root.right: #11\\n            self.flatten(root.right)\\n```\\n\\nThat\\'s it. I hope it\\'s clear. \\n\\n\\n=======================================================\\nFinal note: please let me know if you found any typo/error/etc. I\\'ll try to fix it. \\n\\nFinal note 2: I think explaninng something in a simple way would be instructive for myself. That\\'s why I\\'m doing this kind of writing. If you\\'d like to read more of my posts, check `peymannp` tag. \\n\\n\\n\\n\\n\\n\\n\\n```\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n\\t          root\\nleft subtree        right subtree\\n```\n```\\nroot\\n\\tleft subtree flattened\\n\\t\\t\\t\\t\\t\\tright subtree flattened\\n```\n```\\n\\t\\ta\\n\\tb\\t\\tc\\n```\n```\\n\\t\\t  a\\n\\t\\t/\\t  \\\\\\n\\tNone\\t     b\\t\\n\\t\\t\\t   /\\t\\\\\\n\\t\\t    None\\t c \\n```\n```\\nclass Solution:\\n    def flatten(self, root):\\n        if not root: #1\\n            return\\n        \\n        if root.left: #2\\n            self.flatten(root.left) #3\\n            temp = root.right #4\\n            root.right = root.left #5\\n            root.left = None #6\\n            curr = root.right #7\\n            \\n            while curr.right: #8\\n                curr = curr.right #9\\n            \\n            curr.right = temp #10\\n        \\n        if root.right: #11\\n            self.flatten(root.right)\\n```\n```\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 681774,
                "title": "python3-solution-using-postorder-traversal-o-1-space-complexity",
                "content": "```\\nclass Solution:\\n    \\n    def get_result(self,root):\\n        if root==None:\\n            return None\\n        left = self.get_result(root.left)\\n        right = self.get_result(root.right)\\n        x = left\\n        if left!=None:\\n            while left.right:\\n                left = left.right\\n            left.right = right\\n            root.left = None\\n            root.right = x\\n        return root\\n    \\n    def flatten(self, root: TreeNode) -> None:\\n        return self.get_result(root)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    \\n    def get_result(self,root):\\n        if root==None:\\n            return None\\n        left = self.get_result(root.left)\\n        right = self.get_result(root.right)\\n        x = left\\n        if left!=None:\\n            while left.right:\\n                left = left.right\\n            left.right = right\\n            root.left = None\\n            root.right = x\\n        return root\\n    \\n    def flatten(self, root: TreeNode) -> None:\\n        return self.get_result(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 272929,
                "title": "golang-edition-of-the-most-voted-resolution-in-java",
                "content": "```\\nfunc flatten(root *TreeNode) {\\n\\tvar handler func(node *TreeNode)\\n\\n\\tvar next *TreeNode\\n\\thandler = func (node *TreeNode) {\\n\\t\\tif node == nil {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\thandler(node.Right)\\n\\t\\thandler(node.Left)\\n\\t\\tnode.Right = next\\n\\t\\tnode.Left = nil\\n\\t\\tnext = node\\n\\t}\\n\\thandler(root)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc flatten(root *TreeNode) {\\n\\tvar handler func(node *TreeNode)\\n\\n\\tvar next *TreeNode\\n\\thandler = func (node *TreeNode) {\\n\\t\\tif node == nil {\\n\\t\\t\\treturn\\n\\t\\t}\\n\\t\\thandler(node.Right)\\n\\t\\thandler(node.Left)\\n\\t\\tnode.Right = next\\n\\t\\tnode.Left = nil\\n\\t\\tnext = node\\n\\t}\\n\\thandler(root)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172710,
                "title": "4ms-o-1-space-o-n-time-10-lines-c-solution-inspired-by-morris-traversal",
                "content": "This question asks in-place so most of the recursive methods are not what expected.\\n\\nThere is a hint telling us it is looking for a preOrder traversal. Therefore we can translate the steps:\\n1, visit the root;\\n2, visit the left children\\n3, visit the right children\\n\\nIn step 2 we need to preserve the context for step 3. Instead of saving it in a stack, either by yourself or system by recursion, we can save it to the root\\'s immediate left children\\'s farest right children.\\nBut you can see as the code, it has a inner while loop. Then why claim it as O(N) time complexity?\\nThe reason is although we have a inner loop, we will visit at most all the left children 1 time when looking for the place to preserve the context. Therefore the worst case is visiting every node in the tree twice which is O(2N) ~ O(N).\\n\\nHere is my solution:\\n\\n```\\n    void flatten(TreeNode* root) {\\n        for(auto it = root; root; root = root->right) {\\n            if (!root->right) swap(root->right, root->left);\\n            else if (root->left) {\\n                swap(root->left, root->right);\\n                for(it = root; it->right; it = it->right);\\n                swap(it->right, root->left);\\n            }\\n        }\\n    }\\n```\\n\\nAnd after more than 1 year, I came across this q again and I have a more straight forward solution:\\n```\\nvoid flatten(TreeNode* root) {\\n        while (root) {\\n            if (root->left && root->right) {\\n                auto it = root->left;\\n                for (; it->right; it = it->right);\\n                swap(it->right, root->right);\\n            }\\n            root->right = root->left ? root->left : root->right;\\n            root->left = NULL;            \\n            root = root->right;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    void flatten(TreeNode* root) {\\n        for(auto it = root; root; root = root->right) {\\n            if (!root->right) swap(root->right, root->left);\\n            else if (root->left) {\\n                swap(root->left, root->right);\\n                for(it = root; it->right; it = it->right);\\n                swap(it->right, root->left);\\n            }\\n        }\\n    }\\n```\n```\\nvoid flatten(TreeNode* root) {\\n        while (root) {\\n            if (root->left && root->right) {\\n                auto it = root->left;\\n                for (; it->right; it = it->right);\\n                swap(it->right, root->right);\\n            }\\n            root->right = root->left ? root->left : root->right;\\n            root->left = NULL;            \\n            root = root->right;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 172385,
                "title": "python-recursive-solution",
                "content": "This solution is adapted from [this](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/discuss/36977/My-short-post-order-traversal-Java-solution-for-share) Java solution. You basically maintain a global variable `prev` which stores the last node that was flattened. First you flatten `root.right`, after which `prev` is `root.right`. Then you flatten `root.left`, which gets called recursively until you hit the \\'end\\', at which point the flattened `root.right` is attached to the right of the \\'end\\', and finally `prev` gets set to `root.left`. After the recursive calls, `root.right` get set to `root.left`, which already has the `root.right` attached to its end.\\n\\n```python\\nclass Solution(object):\\n    prev = None\\n\\n    def flatten(self, root):\\n        if not root:\\n            return\\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution(object):\\n    prev = None\\n\\n    def flatten(self, root):\\n        if not root:\\n            return\\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37134,
                "title": "two-easy-to-understand-c-pre-order-traversal-solution-recursive-and-iterative-with-demo",
                "content": "Recursive solution\\n\\n    class Solution {\\n    private:\\n        TreeNode* pre = NULL;\\n        \\n    public:\\n        void flatten(TreeNode* root) {\\n            if(!root) return;\\n            pre = root;\\n            \\n            TreeNode* right = root->right;\\n            if(root->left) root->right = root->left;\\n            flatten(root->left);\\n            pre->right = right;\\n            flatten(root->right);\\n            \\n            root->left = NULL;\\n        }\\n    };\\n\\n\\nIterative solution: Starting from parent node `runner`,  keep a copy of right child, let it be `right` first since we are going to reset `runner->right`: if runner has `left child`(`runner->left`), it will become the new right child of runner, and then we set `left child` to `nullptr`. How to deal the old right child `right`? We need to find it a new parent, which should be the rightmost node in the subtree rooted at the old left child, which we just set as the new right child(`runner->right`), so rRunner is doing this work to find the new parent for right. After all of this, we continue with runner's right child.\\n\\n\\n    current runner: 1\\n\\n    before update:\\n         1\\n        / \\\\\\n       2   5\\n      / \\\\   \\\\\\n     3   4   6\\n\\n    update:\\n    right = 1->right = 5\\n    1->right = 2\\n    rRunner = 4\\n    4->right = right = 5\\n\\n    after update:   \\n         1\\n          \\\\\\n           2   \\n          / \\\\   \\n         3   4   \\n              \\\\\\n               5\\n                \\\\\\n                 6\\n\\n    next runner: 2\\n\\nCode\\n\\n    class Solution {\\n    public:\\n        void flatten(TreeNode* root) {\\n            TreeNode* runner = root;\\n            \\n            while(runner){\\n                if(runner->left){\\n                    TreeNode* right = runner->right;\\n                    runner->right = runner->left;\\n                    runner->left = nullptr;\\n                    runner = runner->right;\\n                    \\n                    TreeNode* rRunner = runner;             \\n                    while(rRunner->right){\\n                        rRunner = rRunner->right;\\n                    }                   \\n                    rRunner->right = right;  /*rRunner is the new parent of `right`*/\\n                }else{\\n                    runner = runner->right;    \\n                }         \\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    private:\\n        TreeNode* pre = NULL;\\n        \\n    public:\\n        void flatten(TreeNode* root) {\\n            if(!root) return;\\n            pre = root;\\n            \\n            TreeNode* right = root->right;\\n            if(root->left) root->right = root->left;\\n            flatten(root->left);\\n            pre->right = right;\\n            flatten(root->right);\\n            \\n            root->left = NULL;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 37171,
                "title": "concise-c-recursion-solution",
                "content": "    class Solution {\\n    public:\\n        void flatten(TreeNode* root) {\\n            if (!root) return;\\n            if (root->left){\\n                flatten(root->left);\\n                ptr->right = root->right;\\n                root->right = root->left;\\n                root->left = NULL;\\n            }\\n            ptr = root;\\n            flatten(root->right);\\n        }\\n    private:\\n        TreeNode* ptr;\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void flatten(TreeNode* root) {\\n            if (!root) return;\\n            if (root->left){\\n                flatten(root->left);\\n                ptr->right = root->right;\\n                root->right = root->left;\\n                root->left = NULL;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 37067,
                "title": "12-line-python-in-place-solution",
                "content": "    class Solution:\\n        def flatten(self, root):\\n            if not root:\\n                return\\n            self.flatten(root.right)\\n            if not root.left:\\n                return\\n            self.flatten(root.left)\\n            tail = root.left\\n            while tail.right:\\n                tail = tail.right\\n            tail.right = root.right\\n            root.right = root.left\\n            root.left = None",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        def flatten(self, root):\\n            if not root:\\n                return\\n            self.flatten(root.right)\\n            if not root.left:\\n                return\\n            self.flatten(root.left)\\n            tail = root.left\\n            while tail.right:\\n                tail = tail.right\\n            tail.right = root.right\\n            root.right = root.left\\n            root.left = None",
                "codeTag": "Java"
            },
            {
                "id": 37289,
                "title": "perhaps-the-most-simple-code-c",
                "content": "    class Solution {\\n    public:\\n        TreeNode *sidend = NULL;// this record the left most node;\\n        void flatten(TreeNode *root) {\\n            if (root == NULL) return;\\n            sidend = root;\\n            TreeNode *r = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            flatten(root->right);\\n            sidend->right = r;\\n            flatten(r);\\n            return ;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        TreeNode *sidend = NULL;// this record the left most node;\\n        void flatten(TreeNode *root) {\\n            if (root == NULL) return;\\n            sidend = root;\\n            TreeNode *r = root->right;\\n            root->right = root->left;\\n            root->left = NULL;\\n            flatten(root->right);\\n            sidend->right = r;\\n            flatten(r);\\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 37310,
                "title": "a-solution-with-python-generators",
                "content": "I split the problem into two parts:\\n\\n - A generator that create a sequence of nodes from a pre-order traversal.\\n - The flatten method uses the generator to fix the tree, just link prev.right with curr.\\n\\nIs recursive, but nice, and the code is reusable, easy to understand and maintain.\\n\\nComplessity: O(n)?\\n\\n    class Solution:\\n    \\n        # @param root, a tree node\\n        # @return nothing, do it in place\\n        def flatten(self, root):\\n            \\n            if not root: return\\n            \\n            prev = None\\n            for node in self.preOrder(root):\\n                \\n                node.left = None\\n                if prev: prev.right = node\\n                prev = node\\n        \\n        \\n        def preOrder(self, node):\\n            \\n            left = node.left\\n            right = node.right\\n            \\n            yield node\\n            if left:\\n                for node in self.preOrder(left):\\n                    yield node\\n            \\n            if right:\\n                for node in self.preOrder(right):\\n                    yield node",
                "solutionTags": [],
                "code": "I split the problem into two parts:\\n\\n - A generator that create a sequence of nodes from a pre-order traversal.\\n - The flatten method uses the generator to fix the tree, just link prev.right with curr.\\n\\nIs recursive, but nice, and the code is reusable, easy to understand and maintain.\\n\\nComplessity: O(n)?\\n\\n    class Solution:\\n    \\n        # @param root, a tree node\\n        # @return nothing, do it in place\\n        def flatten(self, root):\\n            \\n            if not root: return\\n            \\n            prev = None\\n            for node in self.preOrder(root):\\n                \\n                node.left = None\\n                if prev: prev.right = node\\n                prev = node\\n        \\n        \\n        def preOrder(self, node):\\n            \\n            left = node.left\\n            right = node.right\\n            \\n            yield node\\n            if left:\\n                for node in self.preOrder(left):\\n                    yield node\\n            \\n            if right:\\n                for node in self.preOrder(right):\\n                    yield node",
                "codeTag": "Java"
            },
            {
                "id": 3987618,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nRecursive\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* dummy = NULL;    \\npublic:\\n    void flatten(TreeNode* root) {\\n        if (!root)\\n            return;\\n        flatten(root->right);    \\n        flatten(root->left); \\n        root->right = dummy;\\n        root->left = NULL;\\n        dummy = root;\\n    }\\n};\\n```\\n\\n# Approach 2\\nIterative\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\npublic:\\n    void flatten(TreeNode* root) {\\n        if (!root)\\n            return;\\n        stack <TreeNode*> st;\\n        st.push(root);\\n        TreeNode* dummy = new TreeNode(); \\n        while (!st.empty()) {\\n            TreeNode* cur = st.top();\\n            st.pop();\\n            if (cur->right)\\n                st.push(cur->right);\\n            if (cur->left)\\n                st.push(cur->left);\\n            cur->left = NULL;    \\n            dummy->right = cur;\\n            dummy = cur;     \\n        }    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    TreeNode* dummy = NULL;    \\npublic:\\n    void flatten(TreeNode* root) {\\n        if (!root)\\n            return;\\n        flatten(root->right);    \\n        flatten(root->left); \\n        root->right = dummy;\\n        root->left = NULL;\\n        dummy = root;\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution { \\npublic:\\n    void flatten(TreeNode* root) {\\n        if (!root)\\n            return;\\n        stack <TreeNode*> st;\\n        st.push(root);\\n        TreeNode* dummy = new TreeNode(); \\n        while (!st.empty()) {\\n            TreeNode* cur = st.top();\\n            st.pop();\\n            if (cur->right)\\n                st.push(cur->right);\\n            if (cur->left)\\n                st.push(cur->left);\\n            cur->left = NULL;    \\n            dummy->right = cur;\\n            dummy = cur;     \\n        }    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534363,
                "title": "python-easy-iterative-recursive-both-solution",
                "content": "**Iterative Solution:**\\n```\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        if root==None:\\n            return None\\n        st=[root]\\n        while st:\\n            node=st.pop()\\n            if node.right:\\n                st.append(node.right)\\n            if node.left:\\n                st.append(node.left)\\n            if len(st)>0:\\n                node.right=st[-1]\\n            node.left=None\\n```\\n**Recursive Solution:**\\n```\\nclass Solution:\\n    prev=None\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        if root==None:\\n            return \\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        root.left=None\\n        root.right=self.prev\\n        self.prev=root\\n```\\n**An upvote will be encouraging**\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack",
                    "Depth-First Search",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        if root==None:\\n            return None\\n        st=[root]\\n        while st:\\n            node=st.pop()\\n            if node.right:\\n                st.append(node.right)\\n            if node.left:\\n                st.append(node.left)\\n            if len(st)>0:\\n                node.right=st[-1]\\n            node.left=None\\n```\n```\\nclass Solution:\\n    prev=None\\n    def flatten(self, root: Optional[TreeNode]) -> None:\\n        if root==None:\\n            return \\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        root.left=None\\n        root.right=self.prev\\n        self.prev=root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3437731,
                "title": "easy-java-solution-for-beginners-explained",
                "content": "# Approach\\n- Create a helper function that is basically a pre-ordered traversal recursive function and collect all the nodes and store them in an global data structure ( ArrayList ) named arr.\\n- pass root node into the helper function.\\n- Once the pre-ordered traversal is done through the tree, traverse through all the n nodes stored sequentially in the arr.\\n- connect all the nodes to their sucessive nodes using right pointers and set their left pointers as null.\\n- return the first node of the arraylist.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode flatten(TreeNode root) {\\n\\n        helper(root);\\n\\n        System.out.println(arr);\\n\\n        for(int i = 0;i<arr.size()-1;i++){\\n            arr.get(i).right = arr.get(i+1);\\n            arr.get(i).left = null;\\n        }\\n\\n        arr.get(arr.size()-1).right = null;\\n\\n        return arr.get(0);\\n    }\\n\\n    public static List<TreeNode> arr = new ArrayList<>();\\n\\n    public static void helper(TreeNode node){\\n        \\n        if(node == null){\\n            return;\\n        }\\n \\n        System.out.print(node.val+\" \");\\n        arr.add(node);\\n        helper(node.left);        \\n        helper(node.right);\\n\\n    }\\n}\\n```\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/54f0dd79-e727-449e-89d6-511412597ae0_1681987648.1056275.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public TreeNode flatten(TreeNode root) {\\n\\n        helper(root);\\n\\n        System.out.println(arr);\\n\\n        for(int i = 0;i<arr.size()-1;i++){\\n            arr.get(i).right = arr.get(i+1);\\n            arr.get(i).left = null;\\n        }\\n\\n        arr.get(arr.size()-1).right = null;\\n\\n        return arr.get(0);\\n    }\\n\\n    public static List<TreeNode> arr = new ArrayList<>();\\n\\n    public static void helper(TreeNode node){\\n        \\n        if(node == null){\\n            return;\\n        }\\n \\n        System.out.print(node.val+\" \");\\n        arr.add(node);\\n        helper(node.left);        \\n        helper(node.right);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3282445,
                "title": "recursive-easy-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    TreeNode prev=null;\\n    public void flatten(TreeNode root) {\\n        if(root==null) return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right=prev;\\n        root.left=null;\\n        prev=root;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    TreeNode prev=null;\\n    public void flatten(TreeNode root) {\\n        if(root==null) return;\\n        flatten(root.right);\\n        flatten(root.left);\\n        root.right=prev;\\n        root.left=null;\\n        prev=root;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2362513,
                "title": "c-0ms-explained-recursion-faster-than-100",
                "content": "![image](https://assets.leetcode.com/users/images/757d4eee-ddd7-4bb7-9f91-d8989d1af257_1659326327.549598.png)\\n\\n```\\nvoid flatten(struct TreeNode* root){\\n    \\n    // check if root exists\\n    if (root){\\n        \\n        struct TreeNode* temp = root->right;    // store the right part of root\\n        \\n        root->right = root->left;           // move the left part to the right\\n        root->left = NULL;                  // clear left part\\n        \\n        struct TreeNode* curr = root;\\n        while(curr->right){                 // use while loop to find the bottom right side\\n            curr = curr->right;\\n        }\\n        curr->right = temp;                 // attach temp back\\n        \\n        // recursion\\n        flatten(root->right);\\n    }\\n\\n}\\n```\\nPlease UPVOTE if you Like !!\\n![image](https://assets.leetcode.com/users/images/67cea45c-243b-48eb-915d-996cd2c35f4d_1659326258.096931.png)\\n",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nvoid flatten(struct TreeNode* root){\\n    \\n    // check if root exists\\n    if (root){\\n        \\n        struct TreeNode* temp = root->right;    // store the right part of root\\n        \\n        root->right = root->left;           // move the left part to the right\\n        root->left = NULL;                  // clear left part\\n        \\n        struct TreeNode* curr = root;\\n        while(curr->right){                 // use while loop to find the bottom right side\\n            curr = curr->right;\\n        }\\n        curr->right = temp;                 // attach temp back\\n        \\n        // recursion\\n        flatten(root->right);\\n    }\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2340817,
                "title": "success-details-runtime-35-ms-faster-than-97-02-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/bf4d326f-9a82-41d5-835c-3e7014f4306c_1658921383.316379.png)\\n```\\n def flatten(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        def dfs(root):\\n            if not root: return None\\n            \\n            leftTail= dfs(root.left)\\n            rightTail = dfs(root.right)\\n            \\n            if leftTail: #can also be written as root.left\\n                leftTail.right = root.right\\n                root.right = root.left\\n                root.left = None\\n                \\n            # python trick, if rightTail is not null then it will be returned before computing entire expression\\n            return rightTail or leftTail or root\\n        \\n        return dfs(root)\\n```\\nupvote if my post helps you out",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n def flatten(self, root: Optional[TreeNode]) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        def dfs(root):\\n            if not root: return None\\n            \\n            leftTail= dfs(root.left)\\n            rightTail = dfs(root.right)\\n            \\n            if leftTail: #can also be written as root.left\\n                leftTail.right = root.right\\n                root.right = root.left\\n                root.left = None\\n                \\n            # python trick, if rightTail is not null then it will be returned before computing entire expression\\n            return rightTail or leftTail or root\\n        \\n        return dfs(root)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2339141,
                "title": "recursive-preorder-c",
                "content": "This can be divided into 2  subproblems  i.e. left subtree as a linklist and right subtree as a linklist . After we get both left and right as a linklist by doing recursive calls , we attach the left list to right of root and then at the end of the left list we attached , we will attach the right subtree to form the preOrder traversal.\\n\\n**Time Complexity : O (n x n)** ( *as we are reaching every node and for each node after attaching left list we have to traverse the list to find the end*)\\n\\n**Space Complexity : O( height of tree )**\\n\\n```\\n       if(!root)return ;\\n       \\n       TreeNode* rootLeft = root->left;\\n        root->left = NULL;\\n       TreeNode* rootRight = root->right;\\n        root->right = NULL;\\n        \\n        flatten(rootLeft);\\n        flatten(rootRight);\\n        \\n       \\n        root->right = rootLeft;\\n        TreeNode* cur = root;\\n        while(cur->right){\\n            cur= cur->right;\\n        }\\n        cur->right = rootRight;\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n       if(!root)return ;\\n       \\n       TreeNode* rootLeft = root->left;\\n        root->left = NULL;\\n       TreeNode* rootRight = root->right;\\n        root->right = NULL;\\n        \\n        flatten(rootLeft);\\n        flatten(rootRight);\\n        \\n       \\n        root->right = rootLeft;\\n        TreeNode* cur = root;\\n        while(cur->right){\\n            cur= cur->right;\\n        }\\n        cur->right = rootRight;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2127152,
                "title": "java-solution-w-o-n-time-o-n-space-for-beginners",
                "content": "Here\\'s my Java solution w/ O(n) time | O(n) space. It might not be meaningful to people who have mastered the problem already. But if you are struggling w/ the problem, I hope it helps. Basically, I just use preorder Traversal helper method and then make the new connection. Once you understand the concept, I believe it would be easier to understand how to achieve O(1) space complexity as a follow-up question.\\n\\n  Also, anyone is welcomed to reach out to me if my solution is not clear to you. I\\'m very willing to help.\\n\\n```\\nclass Solution \\n{\\n    Queue<TreeNode> Q = new LinkedList<>();\\n    \\n    public void flatten(TreeNode root) \\n    {\\n        // O(n) time | O(n) space\\n        preorderTraversal(root);\\n        \\n        // do nothing when it\\'s null or only 1 node\\n        if(root == null || Q.size() == 1)   return;\\n        \\n        if(!Q.isEmpty())\\n        {\\n            root = Q.poll();\\n            root.left = null;\\n            TreeNode tmp = root;\\n            \\n            while(!Q.isEmpty())\\n            {\\n                TreeNode node = Q.poll();\\n                node.left = null;\\n                tmp.right = node;\\n                tmp = tmp.right;\\n            }\\n        }\\n    }\\n    \\n    public void preorderTraversal(TreeNode root)\\n    {\\n        if(root == null)    return;\\n        \\n        Q.offer(root);\\n        preorderTraversal(root.left);\\n        preorderTraversal(root.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Queue",
                    "Iterator"
                ],
                "code": "```\\nclass Solution \\n{\\n    Queue<TreeNode> Q = new LinkedList<>();\\n    \\n    public void flatten(TreeNode root) \\n    {\\n        // O(n) time | O(n) space\\n        preorderTraversal(root);\\n        \\n        // do nothing when it\\'s null or only 1 node\\n        if(root == null || Q.size() == 1)   return;\\n        \\n        if(!Q.isEmpty())\\n        {\\n            root = Q.poll();\\n            root.left = null;\\n            TreeNode tmp = root;\\n            \\n            while(!Q.isEmpty())\\n            {\\n                TreeNode node = Q.poll();\\n                node.left = null;\\n                tmp.right = node;\\n                tmp = tmp.right;\\n            }\\n        }\\n    }\\n    \\n    public void preorderTraversal(TreeNode root)\\n    {\\n        if(root == null)    return;\\n        \\n        Q.offer(root);\\n        preorderTraversal(root.left);\\n        preorderTraversal(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2101154,
                "title": "java-solution-easy-to-understand-100-faster",
                "content": "easy to understand\\n![image](https://assets.leetcode.com/users/images/abbe1809-abfe-460c-a77f-89833903aa5a_1654150623.2005098.png)\\n\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if(root == null)\\n            return ;\\n        if(root.left != null){\\n            TreeNode leftRightMost = root.left;\\n            while(leftRightMost.right != null)   // find left right most node\\n                leftRightMost = leftRightMost.right;\\n            TreeNode rootRight = root.right;\\n            root.right = root.left;\\n            leftRightMost.right = rootRight;\\n            root.left = null; \\n        }\\n        flatten(root.right);\\n    }\\n}\\n\\n```\\nIf this explanation is really helpful please upvote \\uD83D\\uDC4D \\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if(root == null)\\n            return ;\\n        if(root.left != null){\\n            TreeNode leftRightMost = root.left;\\n            while(leftRightMost.right != null)   // find left right most node\\n                leftRightMost = leftRightMost.right;\\n            TreeNode rootRight = root.right;\\n            root.right = root.left;\\n            leftRightMost.right = rootRight;\\n            root.left = null; \\n        }\\n        flatten(root.right);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902175,
                "title": "all-3-approach-with-notes",
                "content": "**1st approach -> Recursive Approach** \\n\\n```\\nclass Solution {\\n    TreeNode prev = null;\\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n        \\n        flatten(root.right);\\n        flatten(root.left);\\n        \\n        root.right = prev;\\n        root.left = null;\\n        \\n        prev = root;\\n    }\\n}\\n\\nT.C -> O(N)\\nS.C -> O(N)\\n```\\n\\n**2nd approach -> Iterative  Approach**\\n```\\nclass Solution {\\n\\n    public void flatten(TreeNode root) {\\n        if(root == null) return; \\n        \\n        Deque<TreeNode> st = new ArrayDeque<>(); \\n        st.push(root); \\n        while(!st.isEmpty()) {\\n            TreeNode cur = st.peek();\\n            st.pop();\\n            \\n            if(cur.right != null) {\\n                st.push(cur.right); \\n            }\\n            if(cur.left != null) {\\n                st.push(cur.left); \\n            }\\n            if(!st.isEmpty()) {\\n                cur.right = st.peek(); \\n            }\\n            cur.left = null;\\n        }\\n        \\n    }\\n}\\n\\nT.C -> O(N)\\nS.C -> O(N)\\n```\\n\\n**3rd approach -> Morris Traversal**\\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode cur = root;\\n        while (cur != null)\\n        {\\n            if(cur.left != null)\\n            {\\n                TreeNode pre = cur.left;\\n                while(pre.right != null)\\n                {\\n                    pre = pre.right;\\n                }\\n                pre.right = cur.right;\\n                cur.right = cur.left;\\n                cur.left = null;\\n            }\\n            cur = cur.right;\\n        }\\n    }\\n}\\n\\nT.C -> O(N)\\nS.C -> O(1)\\n```\\n\\n**Notes Link** : https://github.com/rizonkumar/LeetCode-Notes/blob/main/114.pdf\\n\\nIf you find it useful **do upvote**",
                "solutionTags": [
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev = null;\\n    public void flatten(TreeNode root) {\\n        if(root == null) return;\\n        \\n        flatten(root.right);\\n        flatten(root.left);\\n        \\n        root.right = prev;\\n        root.left = null;\\n        \\n        prev = root;\\n    }\\n}\\n\\nT.C -> O(N)\\nS.C -> O(N)\\n```\n```\\nclass Solution {\\n\\n    public void flatten(TreeNode root) {\\n        if(root == null) return; \\n        \\n        Deque<TreeNode> st = new ArrayDeque<>(); \\n        st.push(root); \\n        while(!st.isEmpty()) {\\n            TreeNode cur = st.peek();\\n            st.pop();\\n            \\n            if(cur.right != null) {\\n                st.push(cur.right); \\n            }\\n            if(cur.left != null) {\\n                st.push(cur.left); \\n            }\\n            if(!st.isEmpty()) {\\n                cur.right = st.peek(); \\n            }\\n            cur.left = null;\\n        }\\n        \\n    }\\n}\\n\\nT.C -> O(N)\\nS.C -> O(N)\\n```\n```\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        TreeNode cur = root;\\n        while (cur != null)\\n        {\\n            if(cur.left != null)\\n            {\\n                TreeNode pre = cur.left;\\n                while(pre.right != null)\\n                {\\n                    pre = pre.right;\\n                }\\n                pre.right = cur.right;\\n                cur.right = cur.left;\\n                cur.left = null;\\n            }\\n            cur = cur.right;\\n        }\\n    }\\n}\\n\\nT.C -> O(N)\\nS.C -> O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1832740,
                "title": "c-faster-reverse-postorder-short-precise-easy-to-understand",
                "content": "Please Upvote if you like the solution.\\n```\\nclass Solution {\\npublic:\\n    TreeNode* prev=nullptr;\\n    void flatten(TreeNode* root) {\\n        if(root==nullptr)\\n            return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->left=nullptr;\\n        root->right=prev;\\n        prev=root;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* prev=nullptr;\\n    void flatten(TreeNode* root) {\\n        if(root==nullptr)\\n            return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->left=nullptr;\\n        root->right=prev;\\n        prev=root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1775956,
                "title": "easiest-solution-with-o-1-space",
                "content": "Approch:\\n1.Add node->right to end of node->left side .\\n2.Then add node->left side to the node->right side .\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root)\\n\\t{\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        while(root!=NULL)\\n        {\\n            \\n            if(root->left)\\n            {\\n                TreeNode *LEFT=root->left;\\n                TreeNode *curr=LEFT;\\n                while(curr->right)\\n                {\\n                    curr=curr->right;\\n                }\\n                curr->right=root->right;\\n                root->right=LEFT;\\n                root->left=NULL;\\n            }\\n            root=root->right;\\n            \\n        }\\n    }\\n};\\n```\\n\\nMorris traversal is used for the solution.",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root)\\n\\t{\\n        if(root==NULL)\\n        {\\n            return ;\\n        }\\n        while(root!=NULL)\\n        {\\n            \\n            if(root->left)\\n            {\\n                TreeNode *LEFT=root->left;\\n                TreeNode *curr=LEFT;\\n                while(curr->right)\\n                {\\n                    curr=curr->right;\\n                }\\n                curr->right=root->right;\\n                root->right=LEFT;\\n                root->left=NULL;\\n            }\\n            root=root->right;\\n            \\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1543162,
                "title": "c-simple-approach-using-recursion-o-1-space-complexity",
                "content": "class Solution {\\npublic:\\n    \\n    TreeNode* prev=NULL;\\n    \\n    void flatten(TreeNode* root) {\\n        //Do Reverse Postorder (Right Left Root)\\n        //Attach the current node\\'s right to the immediate previous node whose reverse postorder just finished (prev node).\\n    \\n        if(!root) return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        \\n        root->right=prev;\\n        root->left=NULL;\\n        \\n        prev=root;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    TreeNode* prev=NULL;\\n    \\n    void flatten(TreeNode* root) {\\n        //Do Reverse Postorder (Right Left Root)\\n        //Attach the current node\\'s right to the immediate previous node whose reverse postorder just finished (prev node).\\n    \\n        if(!root) return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        \\n        root->right=prev;\\n        root->left=NULL;\\n        \\n        prev=root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1536670,
                "title": "java-easy-understanding-100-0ms",
                "content": "class Solution {\\n\\n\\n    public void flatten(TreeNode root) {\\n        helper(root);\\n    }\\n    \\n    public static TreeNode helper(TreeNode root){\\n        if(root==null){\\n            return null;\\n        }\\n        \\n       \\n        TreeNode lf=helper(root.left);\\n        TreeNode rt=helper(root.right);\\n        \\n        \\n        \\n        if(lf==null && rt==null){\\n            root.left=null;\\n            root.right=null;\\n            return root;\\n        }\\n        else if(lf!=null && rt==null){\\n            root.left=null;\\n            root.right=lf;\\n            return root;\\n        }\\n        \\n        else if (lf==null && rt!=null){\\n            root.left=null;\\n            root.right=rt;\\n            return root;\\n        }\\n        else{\\n        root.left=null;\\n        TreeNode a =lf;\\n        while(a.right!=null){\\n            a=a.right;\\n        }\\n        a.right=rt;\\n            \\n        root.right=lf;\\n           TreeNode t=root;\\n            // while(t!=null){-->for debugging\\n            //     System.out.println(t.val);\\n            //     t=t.right;\\n            // }\\n         \\n        \\n            \\n              return root;\\n        }\\n      \\n        \\n    }\\n        \\n}\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n\\n    public void flatten(TreeNode root) {\\n        helper(root);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1443503,
                "title": "o-1-space-solution-in-java-with-detailed-expalanation-and-dry-run",
                "content": "**PLEASE UPVOTE IF YOU LIKED THE POST**\\n```\\n//APPROACH TIME COMPLEXITY : O(N), SPACE COMPLEXITY: O(1)\\n\\n/*\\n    Code is very very Easy just see the given example 1 and trace the code, what \\n    we are doing here is that as we require preoder traversal and in preorder traversal\\n    we do Root Left Right for every subtree that is what we are doing here\\n    we see if there is left child of root , go to its extreme right child. The question\\n    is why ? and the ans is we know that in preorder of root\\'s left subtree last node\\n    traversed will be this node only (root\\'s left and then the extreme right). so after\\n    preorder traversal completion from root and its left subtree we should go to root\\'s\\n    right , that is why we go to it and attach its right to root\\'s right , and change\\n    root\\'s right to point on root\\'s left. At the end move to root\\'s right in this \\n    modified tree which means we move one node downward and do the same thing again.\\n    \\n    We are making connection here so that we don\\'t have to use the recursion call \\n    stack for memorizing our traversal , we just are tweaking our preorder recursive\\n    traversal so that our space complextiy become o(1)\\n*/\\nclass Solution {\\n    public void flatten(TreeNode cur) {\\n        TreeNode prev = null;\\n        while(cur != null){\\n            if(cur.left != null){\\n                prev = cur.left;    //mark this node\\n                while(prev.right != null)\\n                    prev = prev.right; //it is cur\\'s left subtree\\'s extreme right child\\n                \\n                prev.right = cur.right; //join it to right of cur\\n                cur.right = cur.left;   //change cur\\'s right to cur\\'s left\\n            }\\n            cur = cur.right; //get ready for next iteration (i.e move one node down)\\n        }\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/1546f8f6-0bd8-4301-92d1-196a06f2ace7_1630741600.0964684.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\n//APPROACH TIME COMPLEXITY : O(N), SPACE COMPLEXITY: O(1)\\n\\n/*\\n    Code is very very Easy just see the given example 1 and trace the code, what \\n    we are doing here is that as we require preoder traversal and in preorder traversal\\n    we do Root Left Right for every subtree that is what we are doing here\\n    we see if there is left child of root , go to its extreme right child. The question\\n    is why ? and the ans is we know that in preorder of root\\'s left subtree last node\\n    traversed will be this node only (root\\'s left and then the extreme right). so after\\n    preorder traversal completion from root and its left subtree we should go to root\\'s\\n    right , that is why we go to it and attach its right to root\\'s right , and change\\n    root\\'s right to point on root\\'s left. At the end move to root\\'s right in this \\n    modified tree which means we move one node downward and do the same thing again.\\n    \\n    We are making connection here so that we don\\'t have to use the recursion call \\n    stack for memorizing our traversal , we just are tweaking our preorder recursive\\n    traversal so that our space complextiy become o(1)\\n*/\\nclass Solution {\\n    public void flatten(TreeNode cur) {\\n        TreeNode prev = null;\\n        while(cur != null){\\n            if(cur.left != null){\\n                prev = cur.left;    //mark this node\\n                while(prev.right != null)\\n                    prev = prev.right; //it is cur\\'s left subtree\\'s extreme right child\\n                \\n                prev.right = cur.right; //join it to right of cur\\n                cur.right = cur.left;   //change cur\\'s right to cur\\'s left\\n            }\\n            cur = cur.right; //get ready for next iteration (i.e move one node down)\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1385401,
                "title": "c-recusion-easy",
                "content": "\\nclass Solution {\\npublic: \\n\\n     TreeNode* prev = NULL;\\n     void flatten(TreeNode* root) {\\n        \\n       if(!root) return;\\n        \\n        flatten(root->right);\\n        flatten(root->left);\\n\\n        root->right = prev;\\n        root->left = NULL;  \\n        prev = root;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic: \\n\\n     TreeNode* prev = NULL;\\n     void flatten(TreeNode* root) {\\n        \\n       if(!root) return;\\n        \\n        flatten(root->right);\\n        flatten(root->left);\\n\\n        root->right = prev;\\n        root->left = NULL;  \\n        prev = root;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1353396,
                "title": "java-easy-approach-with-explanation-o-n-arraydeque-bfs",
                "content": "```\\nclass Solution \\n{\\n    public void flatten(TreeNode root)\\n    {//preorder iterative(Root Left Right)\\n        if(root == null)//base case for null graph \\n            return;\\n        \\n        ArrayDeque<TreeNode> stack= new ArrayDeque<>();//Faster than Stack \\n        \\n        stack.addLast(root);//adding the root node \\n        while(!stack.isEmpty())//terminating condition \\n        {\\n            TreeNode temp= stack.removeLast();//popping the top of the stack, the inorder root//Root\\n            \\n            if(temp.right != null)\\n                stack.addLast(temp.right);//we are pushing the right first to access the the left fast //Right\\n            if(temp.left != null)\\n                stack.addLast(temp.left);//we are pushing the left at last to access it faster as it is the next preorder element //Left\\n            \\n            if(!stack.isEmpty())\\n               temp.right= stack.peekLast();//only item left on the top of the stack is the next inorder root, so creating a dependency linking each other \\n            temp.left= null;//destroying the left link and pointing to the null\\n        }\\n        return;//returning to the main  method \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Breadth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution \\n{\\n    public void flatten(TreeNode root)\\n    {//preorder iterative(Root Left Right)\\n        if(root == null)//base case for null graph \\n            return;\\n        \\n        ArrayDeque<TreeNode> stack= new ArrayDeque<>();//Faster than Stack \\n        \\n        stack.addLast(root);//adding the root node \\n        while(!stack.isEmpty())//terminating condition \\n        {\\n            TreeNode temp= stack.removeLast();//popping the top of the stack, the inorder root//Root\\n            \\n            if(temp.right != null)\\n                stack.addLast(temp.right);//we are pushing the right first to access the the left fast //Right\\n            if(temp.left != null)\\n                stack.addLast(temp.left);//we are pushing the left at last to access it faster as it is the next preorder element //Left\\n            \\n            if(!stack.isEmpty())\\n               temp.right= stack.peekLast();//only item left on the top of the stack is the next inorder root, so creating a dependency linking each other \\n            temp.left= null;//destroying the left link and pointing to the null\\n        }\\n        return;//returning to the main  method \\n    }\\n}//please do Upvote, it helps a lot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280482,
                "title": "c-o-1-space",
                "content": "...\\n\\n    void flatten(TreeNode* root) {\\n        if(root==NULL)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n             flatten(root->left);\\n            TreeNode *tmp=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            TreeNode *curr=root;\\n            while(curr->right!=NULL)\\n            {\\n                curr=curr->right;\\n            }\\n            curr->right=tmp;\\n              \\n        }\\n       flatten(root->right);\\n        \\n    }\\n...",
                "solutionTags": [],
                "code": "...\\n\\n    void flatten(TreeNode* root) {\\n        if(root==NULL)\\n            return;\\n        if(root->left!=NULL)\\n        {\\n             flatten(root->left);\\n            TreeNode *tmp=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            TreeNode *curr=root;\\n            while(curr->right!=NULL)\\n            {\\n                curr=curr->right;\\n            }\\n            curr->right=tmp;\\n              \\n        }\\n       flatten(root->right);\\n        \\n    }\\n...",
                "codeTag": "Unknown"
            },
            {
                "id": 1266669,
                "title": "clean-python-solution-with-explanation",
                "content": "The idea is pretty simple, let us first discuss the base cases. \\n1. If the current node is None, we return None as there is not anything for us to do. \\n2. If the left of current node is None, we return the node. \\n(Note that in the final output, we want that each Node only has a right subtree and not a left Subtree)\\nNow for the solving part, What to do when out node has a left subtree. \\n1. We define a temp pointer that points to the rightmost node of the left subtree.\\n2. We then set temp.right as node.right\\n3. We then set node.right to node.left\\n4. We finally delete node.left or set it to None\\nThe logic behind these steps is quite simple. Our aim is to remove the left subtrees and we want to ensure that for each node, the right subtree comes after the left subtree, hence we add the right subtree to the rightmost occurence of the left subtree and delete the left subtree after declaring it as the right subtree. This also covers the case when the right subtree is None, the proposed algorithm would simply set the right subtree as the left subtree and the left subtree to None.\\nHope this helps.\\n\\n\\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        def travel(node):\\n            if node==None:\\n                return\\n            travel(node.left)\\n            travel(node.right)\\n            if not node.left:\\n                return node\\n            temp = node.left\\n            while temp.right:\\n                temp=temp.right\\n            temp.right = node.right\\n            node.right = node.left\\n            node.left = None\\n            return node\\n        \\n        return travel(root)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        def travel(node):\\n            if node==None:\\n                return\\n            travel(node.left)\\n            travel(node.right)\\n            if not node.left:\\n                return node\\n            temp = node.left\\n            while temp.right:\\n                temp=temp.right\\n            temp.right = node.right\\n            node.right = node.left\\n            node.left = None\\n            return node\\n        \\n        return travel(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1206208,
                "title": "c-intuitive-solution-3-steps-explanation",
                "content": "1. **Base Condition:** If root is NULL no need to flatten just return.\\n2. **Hypothesis:** flatten(root->left) , flatten(root->right) . Recursive function will do this work, no need to think how it\\'s doing. Now left subtree is flattened, right subtree is flattened we just need to do work for root.\\n3. **Induction:** \\n\\t* \\tStore right subtree in a temp node. \\n\\t* \\tMake root->right = root->left.\\n\\t* \\tMake root->left = NULL\\n\\tNow we just need to attach temp (old right subtree ) to tail node of new right subtree.\\n\\t* Find tail node and make tail->right = temp.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        flatten(root->left);\\n        flatten(root->right);\\n        \\n        TreeNode *temp = root->right;\\n        root->right = root->left;\\n        root->left = NULL;\\n        \\n        TreeNode *tail = root;\\n        while(tail->right != NULL)\\n            tail = tail -> right;\\n        \\n        tail->right = temp;\\n        return;    \\n    }\\n};\\n```\\n\\n***Happy Coding! :)***\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) \\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        flatten(root->left);\\n        flatten(root->right);\\n        \\n        TreeNode *temp = root->right;\\n        root->right = root->left;\\n        root->left = NULL;\\n        \\n        TreeNode *tail = root;\\n        while(tail->right != NULL)\\n            tail = tail -> right;\\n        \\n        tail->right = temp;\\n        return;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1001228,
                "title": "preorder-c-solution-with-exapmle",
                "content": "The problem can be solved using preOrder traversal. If the problem would have asked to make a BST then we should have used InOrder.\\n\\nSo lets say, left of tree is LeftRoot and right of tree is RightRoot.\\nour solution would be:\\nroot->left = NULL;\\nroot->right = LeftRoot (recursively PreOrder LeftRoot too now)\\nright most child of root = RightRoot (recursively PreOrder LeftRoot too now)\\n\\nExample.,\\n![image](https://assets.leetcode.com/users/images/3de0a9d8-23f6-4e96-a237-849d20acd53c_1609744619.630561.png)\\nHere LeftRoot would be:\\n![image](https://assets.leetcode.com/users/images/ab2a3b49-3a33-4b89-a003-6ab015efe7e0_1609744694.64367.png)\\nand RightRoot would be:\\n![image](https://assets.leetcode.com/users/images/db4e28e0-d217-42ba-9bc4-7a5124858930_1609744732.7645311.png)\\n\\nNow step 1 : \\nroot->left = NULL;\\nroot->right = LeftRoot\\nthis would make Root as following:\\n![image](https://assets.leetcode.com/users/images/804f17c9-ae91-4d9c-8557-88d6fedcb116_1609744826.659586.png)\\nNow step 2 :\\nRecursively do the same to root->right\\nThis would make Root as following:\\n![image](https://assets.leetcode.com/users/images/68987bba-9381-4e93-b65d-1a278b439bd2_1609744940.7608232.png)\\nNow step 3:\\nright most child of root5 = RightRootOf5 (which is 6)\\nThis would make Root as following:\\n![image](https://assets.leetcode.com/users/images/98398610-9166-4b61-be83-eeabe4e7c389_1609745101.191471.png)\\nNow step 4:\\nAs we are donw with RootLeft, hence, let us move to RootRight.\\nright most child of root = RightRoot.\\nThis would make the root as following:\\n![image](https://assets.leetcode.com/users/images/03526e95-4668-4d8a-b157-f010b17c7c53_1609745222.3897603.png)\\nNow step 5:\\nRecursively do the same to RootRight (it is already in the requested form, not required for this example)\\n\\n```\\nclass Solution {\\npublic:\\n    void preOrder(TreeNode* root){\\n        if(!root)\\n            return;\\n        TreeNode* leftRoot = root->left;\\n        TreeNode* rightRoot = root->right;\\n        \\n        TreeNode * temp = root;\\n        \\n        root->left = NULL;\\n        root->right = leftRoot;\\n        preOrder(root->right);\\n        while(temp->right)\\n            temp = temp->right;\\n        temp->right = rightRoot;\\n        preOrder(temp->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        preOrder(root);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void preOrder(TreeNode* root){\\n        if(!root)\\n            return;\\n        TreeNode* leftRoot = root->left;\\n        TreeNode* rightRoot = root->right;\\n        \\n        TreeNode * temp = root;\\n        \\n        root->left = NULL;\\n        root->right = leftRoot;\\n        preOrder(root->right);\\n        while(temp->right)\\n            temp = temp->right;\\n        temp->right = rightRoot;\\n        preOrder(temp->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        preOrder(root);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997037,
                "title": "flatten-binary-tree-to-linked-list-dfs-pictorial-view-simple-solution",
                "content": "**Time: O(n)**\\n(**Please upVote If you found it Useful ;)**)\\n![image](https://assets.leetcode.com/users/images/e951ac22-ff6c-4632-b125-941ef96d7c17_1609527703.9131186.png)\\n![image](https://assets.leetcode.com/users/images/8d8302ba-cb53-4759-82a6-8daabed80ea3_1609528369.1178982.png)\\n![image](https://assets.leetcode.com/users/images/304131e2-9d2d-410f-b8e9-23c30362ae0b_1609528910.195043.png)\\n![image](https://assets.leetcode.com/users/images/ccb9cca2-e160-41b9-86cf-1cc2ee45c910_1609529746.1924458.png)\\n!![image](https://assets.leetcode.com/users/images/8245e571-de46-42a2-a579-73dc087b694e_1609530229.6895788.png)\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    void flattenUtil(TreeNode* root)\\n    {\\n        if(root==NULL || (root->left==NULL && root->right==NULL))\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            flattenUtil(root->left);\\n            TreeNode *temp=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            TreeNode *curr=root->right;\\n            while(curr->right!=NULL)\\n                curr=curr->right;    \\n            curr->right=temp;\\n            \\n        }\\n        if(root->right!=NULL)\\n            flattenUtil(root->right);\\n        return;\\n    }\\n    void flatten(TreeNode* root) {\\n        flattenUtil(root);\\n         \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void flattenUtil(TreeNode* root)\\n    {\\n        if(root==NULL || (root->left==NULL && root->right==NULL))\\n            return;\\n        if(root->left!=NULL)\\n        {\\n            flattenUtil(root->left);\\n            TreeNode *temp=root->right;\\n            root->right=root->left;\\n            root->left=NULL;\\n            TreeNode *curr=root->right;\\n            while(curr->right!=NULL)\\n                curr=curr->right;    \\n            curr->right=temp;\\n            \\n        }\\n        if(root->right!=NULL)\\n            flattenUtil(root->right);\\n        return;\\n    }\\n    void flatten(TreeNode* root) {\\n        flattenUtil(root);\\n         \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 953667,
                "title": "two-js-solutions",
                "content": "```\\n/*\\nSolution: Recursion\\nWe should turn the entire tree into a right-most skewed tree.\\n1. We traverse nodes in post-order because we need to turn every subtree into a right-most skewed tree\\n2. We keep track of right-most node (tail of right subtree) for every tree because we will put our left subtree\\nbetween root node and right subtree. We will do this at each tree: root receives left subtree\\'s right-most node, set its right pointer to current root\\'s right subtree, make left subtree null and return right-most node again.\\n*/\\nvar flatten = function(root) {\\n    dfs(root);\\n    return root;\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nfunction dfs(root) {\\n    if (!root) {\\n        return null;\\n    }\\n    if (!root.left && !root.right) {\\n        return root;\\n    }\\n    let leftTail = dfs(root.left);\\n    let rightTail = dfs(root.right);\\n    // we put left subtree between root and right subtree\\n    if (leftTail) {\\n        leftTail.right = root.right;\\n        root.right = root.left;\\n        root.left = null;\\n    }\\n    // if right subtree is empty, right subtree\\'s tail is actually left subtree\\'s tail\\n    if (!rightTail) {\\n        rightTail = leftTail;\\n    }\\n    return rightTail;\\n}\\n```\\n\\n```\\n/*\\nWe need to turn given tree into a right-most skewed tree.\\n\\nAt each root, if it has a left child, we do the following operation:\\nleft subtree\\'s right-most node = root\\'s right subtree\\nright subtree = left leftsubtree\\nleft subtree = null\\n\\nThen, we traverse right because left node will be null at this point\\n*/\\nvar flatten = function(root) {\\n    let cur = root;\\n    // every time root has a left child\\n    // we rearrange so that left subtree gets placed in the correct position of right subtree\\n    while (cur !== null) {\\n        // ensure that left subtree is moved to the right subtree\\n        // and hence left subtree is null\\n        if (cur.left) {\\n            rightMost = findRightMost(cur.left);\\n            rightMost.right = cur.right;\\n            cur.right = cur.left;\\n            cur.left = null;\\n        }\\n        // left subtree is null so there is no need to traverse left\\n        cur = cur.right;\\n    }\\n    return root;\\n    // T.C: O(N), we traverse each node twice at most\\n    // S.C: O(1)\\n};\\n\\nfunction findRightMost(root) {\\n    let cur = root;\\n    while (cur.right) {\\n        cur = cur.right;\\n    }\\n    return cur;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\nSolution: Recursion\\nWe should turn the entire tree into a right-most skewed tree.\\n1. We traverse nodes in post-order because we need to turn every subtree into a right-most skewed tree\\n2. We keep track of right-most node (tail of right subtree) for every tree because we will put our left subtree\\nbetween root node and right subtree. We will do this at each tree: root receives left subtree\\'s right-most node, set its right pointer to current root\\'s right subtree, make left subtree null and return right-most node again.\\n*/\\nvar flatten = function(root) {\\n    dfs(root);\\n    return root;\\n    // T.C: O(N)\\n    // S.C: O(H)\\n};\\n\\nfunction dfs(root) {\\n    if (!root) {\\n        return null;\\n    }\\n    if (!root.left && !root.right) {\\n        return root;\\n    }\\n    let leftTail = dfs(root.left);\\n    let rightTail = dfs(root.right);\\n    // we put left subtree between root and right subtree\\n    if (leftTail) {\\n        leftTail.right = root.right;\\n        root.right = root.left;\\n        root.left = null;\\n    }\\n    // if right subtree is empty, right subtree\\'s tail is actually left subtree\\'s tail\\n    if (!rightTail) {\\n        rightTail = leftTail;\\n    }\\n    return rightTail;\\n}\\n```\n```\\n/*\\nWe need to turn given tree into a right-most skewed tree.\\n\\nAt each root, if it has a left child, we do the following operation:\\nleft subtree\\'s right-most node = root\\'s right subtree\\nright subtree = left leftsubtree\\nleft subtree = null\\n\\nThen, we traverse right because left node will be null at this point\\n*/\\nvar flatten = function(root) {\\n    let cur = root;\\n    // every time root has a left child\\n    // we rearrange so that left subtree gets placed in the correct position of right subtree\\n    while (cur !== null) {\\n        // ensure that left subtree is moved to the right subtree\\n        // and hence left subtree is null\\n        if (cur.left) {\\n            rightMost = findRightMost(cur.left);\\n            rightMost.right = cur.right;\\n            cur.right = cur.left;\\n            cur.left = null;\\n        }\\n        // left subtree is null so there is no need to traverse left\\n        cur = cur.right;\\n    }\\n    return root;\\n    // T.C: O(N), we traverse each node twice at most\\n    // S.C: O(1)\\n};\\n\\nfunction findRightMost(root) {\\n    let cur = root;\\n    while (cur.right) {\\n        cur = cur.right;\\n    }\\n    return cur;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 854857,
                "title": "python-dfs-recursive-easy-to-understand-with-great-details",
                "content": "I used the helper function to help organize the left and right subtree and there are four situations:\\n1. left O right X : \\n\\t\\tReorganize the left subtree and put it to the right subtree\\n\\t\\tReset the left subtree\\n\\t\\t\\n2. left O right O:\\n\\t   1.  Reorganize the right subtree and store it to a temporary pointer\\n\\t   2.  Reorganize the left subtree and store it to the right\\n\\t   3.  Create a current pointer point to the head of right subtree (already be replace by left subtree)\\n\\t   4.  Use current pointer to loop through the right subtree till the end and connect it with temporary pointer\\n\\t       (so the left and right subtree are organized and connected together)\\n\\t   5. Reset the left subtree\\n\\n3. left X right O\\n\\t\\tReorganize the right subtree and put it back to the right subtree\\n\\n4. left X right X\\n       Just return current node\\n\\n```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        # call helper function to reorganize the subtree\\n        self.helper(root)\\n    \\n    # reorganize function\\n    def helper(self, node):\\n        if node:\\n            if node.left:\\n                \\n                # helper function helps me reorganize the left subtree\\n                node.left = self.helper(node.left)\\n                \\n                # if there is a right subtree \\n                if node.right:\\n                    \\n                    # reorganize the right subtree and store it in temporary pointer\\n                    tmp = self.helper(node.right)\\n                    \\n                    # replace the right subtree with the organized left subtree\\n                    node.right = node.left\\n                    \\n                    # create a current pointer point to the head of right subtree\\n                    cur = node.right\\n                    \\n                    # loop till the end of the organized right subtreee\\n                    while cur.right:\\n                        cur = cur.right\\n                    \\n                    # reconnect back the temporary pointer(previous organized right subtree) \\n                    # to the end of current right subtree\\n                    cur.right = tmp\\n                    \\n                    # reset the left subtree since I already organized it and put it to the right subtree \\n                    node.left = None\\n                    \\n                else:\\n                    # if there is no right subtree, then just organize the \\n                    # left sutree and put it to the right subtree \\n                    node.right = self.helper(node.left)\\n                    \\n                    # reset the left subtree\\n                    node.left = None\\n            else:\\n                # if there is no left subtree, then just reorganize the right subtree\\n                # and put it to the right\\n                node.right = self.helper(node.right)\\n                \\n        return node\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        \"\"\"\\n        Do not return anything, modify root in-place instead.\\n        \"\"\"\\n        # call helper function to reorganize the subtree\\n        self.helper(root)\\n    \\n    # reorganize function\\n    def helper(self, node):\\n        if node:\\n            if node.left:\\n                \\n                # helper function helps me reorganize the left subtree\\n                node.left = self.helper(node.left)\\n                \\n                # if there is a right subtree \\n                if node.right:\\n                    \\n                    # reorganize the right subtree and store it in temporary pointer\\n                    tmp = self.helper(node.right)\\n                    \\n                    # replace the right subtree with the organized left subtree\\n                    node.right = node.left\\n                    \\n                    # create a current pointer point to the head of right subtree\\n                    cur = node.right\\n                    \\n                    # loop till the end of the organized right subtreee\\n                    while cur.right:\\n                        cur = cur.right\\n                    \\n                    # reconnect back the temporary pointer(previous organized right subtree) \\n                    # to the end of current right subtree\\n                    cur.right = tmp\\n                    \\n                    # reset the left subtree since I already organized it and put it to the right subtree \\n                    node.left = None\\n                    \\n                else:\\n                    # if there is no right subtree, then just organize the \\n                    # left sutree and put it to the right subtree \\n                    node.right = self.helper(node.left)\\n                    \\n                    # reset the left subtree\\n                    node.left = None\\n            else:\\n                # if there is no left subtree, then just reorganize the right subtree\\n                # and put it to the right\\n                node.right = self.helper(node.right)\\n                \\n        return node\\n```",
                "codeTag": "Java"
            },
            {
                "id": 846468,
                "title": "javascript-solution-preorder-traversal-approach",
                "content": "```\\nvar flatten = function(root) {\\n    let last = null;\\n    \\n    preOrderTraversal(root);\\n    return root;\\n    \\n    function preOrderTraversal(node) {\\n        if (node) {\\n            if (last) {\\n                last.left = null;\\n                last.right = node;\\n            }\\n            \\n            last = node;\\n            const right = node.right;  // (1)\\n            \\n            preOrderTraversal(node.left);\\n            preOrderTraversal(right);\\n        }\\n    }\\n};\\n\\n/*\\n\\nComments:\\n\\n(1) The reason we need this is because when we first recursively traverse the left subtree and hit the \"if(last)\" conditional and \\n\\twe set the last.right = node, we don\\'t have the correct reference to node.right by the time we hit the right subtree.\\n\\t\\n*/\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```\\nvar flatten = function(root) {\\n    let last = null;\\n    \\n    preOrderTraversal(root);\\n    return root;\\n    \\n    function preOrderTraversal(node) {\\n        if (node) {\\n            if (last) {\\n                last.left = null;\\n                last.right = node;\\n            }\\n            \\n            last = node;\\n            const right = node.right;  // (1)\\n            \\n            preOrderTraversal(node.left);\\n            preOrderTraversal(right);\\n        }\\n    }\\n};\\n\\n/*\\n\\nComments:\\n\\n(1) The reason we need this is because when we first recursively traverse the left subtree and hit the \"if(last)\" conditional and \\n\\twe set the last.right = node, we don\\'t have the correct reference to node.right by the time we hit the right subtree.\\n\\t\\n*/\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 768317,
                "title": "my-100-faster-c-solution",
                "content": "The approach is to recursively construct preorder traversal.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode *A, TreeNode *&prev)\\n    {\\n        if(A==NULL) return;        \\n        inorder(A->right,prev);\\n        inorder(A->left,prev);\\n        // if(prev) cout << prev->val << \" -> \";\\n        // cout << A->val << \"\\\\n \";\\n        A->left= NULL;\\n        A->right= prev;\\n        prev= A;\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode *A= root, *prev= NULL;\\n        inorder(A, prev);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void inorder(TreeNode *A, TreeNode *&prev)\\n    {\\n        if(A==NULL) return;        \\n        inorder(A->right,prev);\\n        inorder(A->left,prev);\\n        // if(prev) cout << prev->val << \" -> \";\\n        // cout << A->val << \"\\\\n \";\\n        A->left= NULL;\\n        A->right= prev;\\n        prev= A;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 762856,
                "title": "c-update-in-place-using-inorder-predecessor",
                "content": "```csharp\\npublic void Flatten(TreeNode root) \\n{\\n\\tTreeNode tree = root;\\n\\n\\twhile(tree != null)\\n\\t{\\n\\t\\tif(tree.left != null)\\n\\t\\t{            \\n\\t\\t\\tvar predecessor = tree.left;\\n\\n\\t\\t\\twhile(predecessor.right != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpredecessor = predecessor.right;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpredecessor.right = tree.right;\\n\\t\\t\\ttree.right = tree.left;\\n\\t\\t\\ttree.left = null;\\n\\t\\t}\\n\\n\\t\\ttree = tree.right;\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```csharp\\npublic void Flatten(TreeNode root) \\n{\\n\\tTreeNode tree = root;\\n\\n\\twhile(tree != null)\\n\\t{\\n\\t\\tif(tree.left != null)\\n\\t\\t{            \\n\\t\\t\\tvar predecessor = tree.left;\\n\\n\\t\\t\\twhile(predecessor.right != null)\\n\\t\\t\\t{\\n\\t\\t\\t\\tpredecessor = predecessor.right;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpredecessor.right = tree.right;\\n\\t\\t\\ttree.right = tree.left;\\n\\t\\t\\ttree.left = null;\\n\\t\\t}\\n\\n\\t\\ttree = tree.right;\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683792,
                "title": "java-beats-100",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        while (root != null){\\n            if (root.left == null){\\n                root = root.right;\\n            } else {\\n                TreeNode pred = root.left;\\n                while (pred.right != null){\\n                    pred = pred.right;\\n                }\\n                pred.right = root.right;\\n                root.right = root.left;\\n                root.left = null;\\n                root = root.right;\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        while (root != null){\\n            if (root.left == null){\\n                root = root.right;\\n            } else {\\n                TreeNode pred = root.left;\\n                while (pred.right != null){\\n                    pred = pred.right;\\n                }\\n                pred.right = root.right;\\n                root.right = root.left;\\n                root.left = null;\\n                root = root.right;\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674898,
                "title": "c-8-lines-of-code-o-1-space-probably-best-solution-so-far-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* prev = nullptr;\\n    void flatten(TreeNode* root) {\\n        if (root == nullptr)\\n            return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->right = prev;\\n        root->left = nullptr;\\n        prev = root;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* prev = nullptr;\\n    void flatten(TreeNode* root) {\\n        if (root == nullptr)\\n            return;\\n        flatten(root->right);\\n        flatten(root->left);\\n        root->right = prev;\\n        root->left = nullptr;\\n        prev = root;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578596,
                "title": "c-with-queue",
                "content": "```\\npublic class Solution {\\n     Queue<TreeNode> q=new  Queue<TreeNode>();\\n    public void Flatten(TreeNode root) {\\n        if(root==null) return;\\n     PreOrder(root);\\n    root=q.Dequeue();\\n        \\n     while(q.Count>0)\\n     {\\n         root.right=q.Dequeue();\\n         root.left=null;\\n         root=root.right;\\n     }\\n        \\n    }\\n    public void PreOrder(TreeNode root)\\n    {\\n        if(root==null) return;\\n        q.Enqueue(root);\\n        PreOrder( root.left);\\n        PreOrder( root.right);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n     Queue<TreeNode> q=new  Queue<TreeNode>();\\n    public void Flatten(TreeNode root) {\\n        if(root==null) return;\\n     PreOrder(root);\\n    root=q.Dequeue();\\n        \\n     while(q.Count>0)\\n     {\\n         root.right=q.Dequeue();\\n         root.left=null;\\n         root=root.right;\\n     }",
                "codeTag": "Java"
            },
            {
                "id": 519647,
                "title": "javascript-simple-pre-order-list",
                "content": "* build a pre-order list of nodes\\n* iterate list one at a time (from first to one before last), and re-wire nodes\\n* handle last node\\n\\n```javascript\\nconst flatten = (root) => {\\n    const list = [];\\n    helper(root, list);\\n    \\n    if(list.length === 0 ) return;\\n    \\n    for(let i = 0; i < list.length - 1; i++) {\\n        const node = list[i];\\n        node.left = null;\\n        node.right = list[i + 1];\\n    }\\n    \\n    const lastNode = list[list.length -1];\\n    lastNode.left = null;\\n    lastNode.right = null;\\n};\\n\\nconst helper = (node, list) => {\\n    if(!node) return;\\n    \\n    list.push(node);\\n    helper(node.left, list);\\n    helper(node.right, list);\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nconst flatten = (root) => {\\n    const list = [];\\n    helper(root, list);\\n    \\n    if(list.length === 0 ) return;\\n    \\n    for(let i = 0; i < list.length - 1; i++) {\\n        const node = list[i];\\n        node.left = null;\\n        node.right = list[i + 1];\\n    }\\n    \\n    const lastNode = list[list.length -1];\\n    lastNode.left = null;\\n    lastNode.right = null;\\n};\\n\\nconst helper = (node, list) => {\\n    if(!node) return;\\n    \\n    list.push(node);\\n    helper(node.left, list);\\n    helper(node.right, list);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375312,
                "title": "easy-python-solution",
                "content": "```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        # put right subtree to the left subtree\\'s right-most\\n        # put left subtrees to the right\\n        # go to right subtrees and repeat\\n        if not root:\\n            return\\n        node = root.left\\n        if node:\\n            while node.right:\\n                node = node.right\\n            node.right = root.right\\n            root.right = root.left\\n            root.left = None\\n        self.flatten(root.right)\\n```\\nAssume there are `N` nodes, the function recurs `N` times, the `while` loops at most costs `N - 1` totally, so it is `O(N)`.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def flatten(self, root: TreeNode) -> None:\\n        # put right subtree to the left subtree\\'s right-most\\n        # put left subtrees to the right\\n        # go to right subtrees and repeat\\n        if not root:\\n            return\\n        node = root.left\\n        if node:\\n            while node.right:\\n                node = node.right\\n            node.right = root.right\\n            root.right = root.left\\n            root.left = None\\n        self.flatten(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 319149,
                "title": "simple-python-solution-straightforward-recursion",
                "content": "```\\n    def flatten(self, root: TreeNode) -> None:\\n        if not root:\\n            return\\n        self.flatten(root.left)\\n        self.flatten(root.right)\\n        if root.left:\\n            node = root.left\\n            while node.right:\\n                node = node.right\\n            node.right = root.right\\n            root.right = root.left\\n            root.left = None\\n```",
                "solutionTags": [],
                "code": "```\\n    def flatten(self, root: TreeNode) -> None:\\n        if not root:\\n            return\\n        self.flatten(root.left)\\n        self.flatten(root.right)\\n        if root.left:\\n            node = root.left\\n            while node.right:\\n                node = node.right\\n            node.right = root.right\\n            root.right = root.left\\n            root.left = None\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 314001,
                "title": "very-easy-to-understand-java-solution",
                "content": "```\\npublic void flatten(TreeNode root) {\\n        if(root == null) return;\\n        TreeNode left = root.left, right = root.right;\\n        flatten(left);\\n        flatten(right);\\n        TreeNode tailleft = tail(left);\\n        root.left = null;\\n\\t\\n\\t\\t//if the tree does not have left subtree, connect right subtree directly\\n        if(tailleft == null) root.right = right;\\n        else {\\n            root.right = left;\\n            tailleft.right = right;\\n        }\\n    }\\n\\t//find the tail of left subtree\\n    private TreeNode tail(TreeNode root){\\n        if(root == null) return root;\\n        while(root.right != null)\\n            root = root.right;\\n        return root;\\n\\t}",
                "solutionTags": [],
                "code": "```\\npublic void flatten(TreeNode root) {\\n        if(root == null) return;\\n        TreeNode left = root.left, right = root.right;\\n        flatten(left);\\n        flatten(right);\\n        TreeNode tailleft = tail(left);\\n        root.left = null;\\n\\t\\n\\t\\t//if the tree does not have left subtree, connect right subtree directly\\n        if(tailleft == null) root.right = right;\\n        else {\\n            root.right = left;\\n            tailleft.right = right;\\n        }\\n    }\\n\\t//find the tail of left subtree\\n    private TreeNode tail(TreeNode root){\\n        if(root == null) return root;\\n        while(root.right != null)\\n            root = root.right;\\n        return root;\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 212981,
                "title": "beats-100-swift-solution-o-n-time",
                "content": "```\\nclass Solution {\\n    var cur: TreeNode?\\n    \\n    func function(_ root: TreeNode?) {\\n        if var node = root {\\n            var left = node.left\\n            var right = node.right\\n            node.left = nil\\n            node.right = nil\\n            if cur != nil {\\n                cur!.right = node    \\n            }\\n            cur = node\\n            function(left)\\n            function(right)\\n        }\\n    }\\n    func flatten(_ root: TreeNode?) {\\n        function(root)\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    var cur: TreeNode?\\n    \\n    func function(_ root: TreeNode?) {\\n        if var node = root {\\n            var left = node.left\\n            var right = node.right\\n            node.left = nil\\n            node.right = nil\\n            if cur != nil {\\n                cur!.right = node    \\n            }\\n            cur = node\\n            function(left)\\n            function(right)\\n        }\\n    }\\n    func flatten(_ root: TreeNode?) {\\n        function(root)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 184711,
                "title": "java-solution-iterative-using-queue",
                "content": "```java\\n\\t/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        \\n        Queue<TreeNode> q = new LinkedList();\\n        populateQueue(q, root);\\n        \\n        TreeNode curr = q.poll();\\n        while (q.size() > 0){\\n            curr.right = q.poll();\\n            curr.left = null;\\n            curr = curr.right;\\n        }\\n    }\\n    \\n    private void populateQueue(Queue q, TreeNode node){\\n        if (node == null)\\n            return;\\n        \\n        q.add(node);\\n        populateQueue(q, node.left);\\n        populateQueue(q, node.right);\\n    }\\n}\\n\\t```",
                "solutionTags": [],
                "code": "```java\\n\\t/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode(int x) { val = x; }\\n * }\\n */\\nclass Solution {\\n    public void flatten(TreeNode root) {\\n        if (root == null)\\n            return;\\n        \\n        Queue<TreeNode> q = new LinkedList();\\n        populateQueue(q, root);\\n        \\n        TreeNode curr = q.poll();\\n        while (q.size() > 0){\\n            curr.right = q.poll();\\n            curr.left = null;\\n            curr = curr.right;\\n        }\\n    }\\n    \\n    private void populateQueue(Queue q, TreeNode node){\\n        if (node == null)\\n            return;\\n        \\n        q.add(node);\\n        populateQueue(q, node.left);\\n        populateQueue(q, node.right);\\n    }\\n}\\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 158025,
                "title": "python-dfs",
                "content": "###  114. Flatten the Binary Tree to Linked List\\n```\\n> \\u7C7B\\u578B\\uFF1ADFS\\u904D\\u5386\\n> Time Complexity O(n)\\n> Space Complexity O(h)\\n```\\n\\n\\u901A\\u8FC7\\u50A8\\u5B58\\u4E00\\u4E2A\\u5168\\u7403\\u53D8\\u91CF\\uFF0C\\u4ECE\\u6700\\u53F3\\u8FB9\\u6700\\u4E0B\\u9762\\u7684Node\\u5F00\\u59CB\\u8FD4\\u56DE\\uFF0C\\u6BCF\\u6B21\\u8FD4\\u56DE\\u7684\\u65F6\\u5019\\u66F4\\u65B0\\u5F53\\u524D\\u8282\\u70B9\\u548C\\u5168\\u7403\\u53D8\\u91CF\\u7684\\u5173\\u7CFB\\uFF0C\\u5177\\u4F53\\u53EF\\u4EE5\\u770B\\u4EE5\\u4E0B\\u89C6\\u9891\\n\\n[\\u516C\\u747E\\u8BB2\\u89E3](https://www.youtube.com/watch?v=LfKRZ_qCmYQ)\\n\\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.prev = None\\n        \\n    def flatten(self, root):\\n        if not root: \\n            return None\\n        \\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        \\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root\\n```",
                "solutionTags": [],
                "code": "```\\n> \\u7C7B\\u578B\\uFF1ADFS\\u904D\\u5386\\n> Time Complexity O(n)\\n> Space Complexity O(h)\\n```\n```\\nclass Solution(object):\\n    def __init__(self):\\n        self.prev = None\\n        \\n    def flatten(self, root):\\n        if not root: \\n            return None\\n        \\n        self.flatten(root.right)\\n        self.flatten(root.left)\\n        \\n        root.right = self.prev\\n        root.left = None\\n        self.prev = root\\n```",
                "codeTag": "Java"
            },
            {
                "id": 37033,
                "title": "javascript-solution-using-recursion",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar flatten = function(root) {\\n  if (!root) { return; }\\n  \\n  let left = root.left;\\n  let right = root.right;\\n  \\n  flatten(left);\\n  flatten(right);\\n  \\n  root.left = null;\\n  root.right = left;\\n  let cur = root;\\n  while (cur.right !== null) { cur = cur.right; }\\n  cur.right = right;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {void} Do not return anything, modify root in-place instead.\\n */\\nvar flatten = function(root) {\\n  if (!root) { return; }\\n  \\n  let left = root.left;\\n  let right = root.right;\\n  \\n  flatten(left);\\n  flatten(right);\\n  \\n  root.left = null;\\n  root.right = left;\\n  let cur = root;\\n  while (cur.right !== null) { cur = cur.right; }\\n  cur.right = right;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 37108,
                "title": "easy-solution-in-c",
                "content": "    class Solution {\\n    public:\\n       \\tvoid flatten(TreeNode* root) {\\n    \\t\\tif (root != NULL)\\n    \\t\\t\\tflat(root);\\n    \\t}\\n    \\n    \\tTreeNode* flat(TreeNode* root) {\\n    \\t\\tTreeNode *left = root->left;\\n    \\t\\tTreeNode *right = root->right;\\n    \\t\\tTreeNode *tail = root;\\n    \\t\\tif (left != NULL) {\\n     \\t\\t\\ttail->right = left;\\n    \\t\\t\\ttail->left = NULL;\\n    \\t\\t\\ttail =flat(left);\\n    \\t\\t}\\n    \\t\\tif (right != NULL) {\\n     \\t\\t\\ttail->right = right;\\n    \\t\\t\\ttail->left = NULL;\\n    \\t\\t\\ttail =flat(right);\\n    \\t\\t}\\n    \\t\\treturn tail;\\n    \\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n       \\tvoid flatten(TreeNode* root) {\\n    \\t\\tif (root != NULL)\\n    \\t\\t\\tflat(root);\\n    \\t}",
                "codeTag": "Java"
            },
            {
                "id": 37113,
                "title": "java-preorder-1ms-solution",
                "content": "    public class Solution {\\n        TreeNode current;\\n        public void flatten(TreeNode root) {\\n            //if we've been given a null root, just return\\n            if(root == null){ return; }\\n            flattenTree(root);\\n            \\n        }\\n        \\n        private void flattenTree(TreeNode root)\\n        {\\n            if(root == null){ return; }\\n            //set local variables for left and right\\n            TreeNode left = root.left, right = root.right;\\n            //set root.left and root.right to null since we don't want to add them to our resulting linked list\\n            root.left = null;\\n            root.right = null;\\n            //if it's the first run of this function set current to root (the start of the linked list)\\n            if( current == null ){ current = root; }\\n            else\\n            {\\n                //add current TreeNode to the end of the list\\n                current.right = root;\\n                current = current.right;\\n            }\\n            \\n            //DFS, so go left and then right\\n            flattenTree(left);\\n            flattenTree(right);\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        TreeNode current;\\n        public void flatten(TreeNode root) {\\n            //if we've been given a null root, just return\\n            if(root == null){ return; }",
                "codeTag": "Java"
            },
            {
                "id": 37081,
                "title": "share-my-7-line-o-1-space-java-code-with-explanations",
                "content": "    /*\\n        \\u628apre-order\\u904d\\u5386\\u5230\\u7684\\u8282\\u70b9\\u6309\\u987a\\u5e8f\\u63a5\\u8d77\\u6765\\u5373\\u53ef.\\n        \\u8981\\u6c42in-place... pre-order\\u5c31\\u662f\\u5148\\u5904\\u7406\\u6839, \\u518d\\u5904\\u7406\\u5de6\\u5b50\\u6811, \\u518d\\u5904\\u7406\\u53f3\\u5b50\\u6811.\\n        \\u6240\\u4ee5\\u53ea\\u8981\\n        -- root.left\\u63a5\\u5728root.right\\u7684\\u4f4d\\u7f6e\\u4e0a\\n        -- \\u539f\\u5148\\u7684root.right\\u63a5\\u5728left subtree\\u7684\"\\u6700\\u53f3\\u8fb9\"\\n    */\\n    public class Solution {\\n        public void flatten(TreeNode root) {\\n            for (; root!=null; root=root.right) {\\n                if (root.left == null) { continue; }\\n                TreeNode p = root.left;  // p != null guaranteed\\n                while (p.right != null) { p = p.right; }\\n                p.right = root.right;\\n                root.right = root.left;\\n                root.left = null;\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void flatten(TreeNode root) {\\n            for (; root!=null; root=root.right) {\\n                if (root.left == null) { continue; }",
                "codeTag": "Java"
            },
            {
                "id": 37184,
                "title": "ac-solution-based-on-morris-traversal",
                "content": "Flattening in this question is actually PRE-ORDER traversal. For each NODE, the sequence after flattening is:\\n\\n    NODE's previous element: the right-most leaf of the root's left branch     \\n    NODE's next     element: NODE's left\\n\\n**Morris traversal algorithm** takes use of the leaf's left and right nodes, so that there's no extra space needed for the traversal. The steps are as the following: \\n\\n1) Find the right-most leaf of the root's left branch:  set leaf's right = root's right; \\n\\n2) Set root's right = root's left if root's left exists; \\n\\n3) Move to root's left branch, if no left branch exists, then move to root's right branch. \\n\\nKeep the above steps until no nodes left, as the following: O(1) extra space\\n\\n    void flatten(TreeNode root) {\\n        while (root != null) {\\n            if (root.left != null && root.right != null) {\\n                TreeNode node = root.left;\\n                while (node.right != null) \\n                    node = node.right; \\n                node.right = root.right;// 1) Find the right-most leaf of the root's left branch:  set leaf's right = root's right; \\n            }  \\n            \\n            if(root.left != null) // 2) Set root's right = root's left if root's left exists; \\n                root.right = root.left; \\n            root.left = null;  \\n            root = root.right;// 3) Move to root's left branch, if no left branch exists, then move to root's right branch.\\n        }\\n    }",
                "solutionTags": [],
                "code": "Flattening in this question is actually PRE-ORDER traversal. For each NODE, the sequence after flattening is:\\n\\n    NODE's previous element: the right-most leaf of the root's left branch     \\n    NODE's next     element: NODE's left\\n\\n**Morris traversal algorithm** takes use of the leaf's left and right nodes, so that there's no extra space needed for the traversal. The steps are as the following: \\n\\n1) Find the right-most leaf of the root's left branch:  set leaf's right = root's right; \\n\\n2) Set root's right = root's left if root's left exists; \\n\\n3) Move to root's left branch, if no left branch exists, then move to root's right branch. \\n\\nKeep the above steps until no nodes left, as the following: O(1) extra space\\n\\n    void flatten(TreeNode root) {\\n        while (root != null) {\\n            if (root.left != null && root.right != null) {\\n                TreeNode node = root.left;\\n                while (node.right != null) \\n                    node = node.right; \\n                node.right = root.right;// 1) Find the right-most leaf of the root's left branch:  set leaf's right = root's right; \\n            }  \\n            \\n            if(root.left != null) // 2) Set root's right = root's left if root's left exists; \\n                root.right = root.left; \\n            root.left = null;  \\n            root = root.right;// 3) Move to root's left branch, if no left branch exists, then move to root's right branch.\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 37259,
                "title": "a-relative-concise-python-code",
                "content": "    class Solution:\\n        # @param root, a tree node\\n        # @return nothing, do it in place\\n        def flatten1(self, root):\\n            if not root:\\n                return\\n            self.flatten(root.left)\\n            self.flatten(root.right)\\n            if root.left:\\n                temp = root.right\\n                root.right = root.left\\n                root.left = None\\n                while root.right:\\n                    root = root.right\\n                root.right = temp",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution:\\n        # @param root, a tree node\\n        # @return nothing, do it in place\\n        def flatten1(self, root):\\n            if not root:\\n                return\\n            self.flatten(root.left)\\n            self.flatten(root.right)\\n            if root.left:\\n                temp = root.right\\n                root.right = root.left\\n                root.left = None\\n                while root.right:\\n                    root = root.right\\n                root.right = temp",
                "codeTag": "Java"
            },
            {
                "id": 4026232,
                "title": "6",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#include<vector>\\nclass Solution {\\npublic:\\n    vector<int> x;\\n    void helper(TreeNode* root){\\n        if(root==NULL){return;}\\n        x.push_back(root->val);\\n        helper(root->left);\\n        helper(root->right);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        helper(root);\\n        for(int i=1;i<x.size();i++){\\n            if(root->right!=NULL && root->left!=NULL){\\n            root->right->val=x[i];\\n            root->left=NULL;}\\n            else if(root->right!=NULL){\\n                root->right->val=x[i];}\\n            else if(root->right==NULL && root->left!=NULL){\\n                TreeNode* p = new TreeNode(x[i]);\\n                root->right=p;\\n                root->left=NULL;\\n            }\\n            else{TreeNode* p = new TreeNode(x[i]);\\n                root->right=p;}\\n            root=root->right;\\n        }    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n#include<vector>\\nclass Solution {\\npublic:\\n    vector<int> x;\\n    void helper(TreeNode* root){\\n        if(root==NULL){return;}\\n        x.push_back(root->val);\\n        helper(root->left);\\n        helper(root->right);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        helper(root);\\n        for(int i=1;i<x.size();i++){\\n            if(root->right!=NULL && root->left!=NULL){\\n            root->right->val=x[i];\\n            root->left=NULL;}\\n            else if(root->right!=NULL){\\n                root->right->val=x[i];}\\n            else if(root->right==NULL && root->left!=NULL){\\n                TreeNode* p = new TreeNode(x[i]);\\n                root->right=p;\\n                root->left=NULL;\\n            }\\n            else{TreeNode* p = new TreeNode(x[i]);\\n                root->right=p;}\\n            root=root->right;\\n        }    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3990488,
                "title": "3-approaches-explanation",
                "content": "# APPROACH - 1 (Using Recursion)\\n\\n\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm steps can be stated as: \\n\\n1. If we observe, we are moving in a reverse postorder way : i.e  right, left, root. \\n2. We take a reference variable (say prev) to store the previous node( initialized to NULL).\\n3. Whenever we visit a node, we set the right child to the prev and left child to NULL. \\n4. Next we assign this current node to prev.\\n5. We perform the above two operations on all the nodes in the traversal.\\n\\n## Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n## Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root,TreeNode*& prev) {\\n        if(root == NULL)\\n            return;\\n\\n        flatten(root->right,prev);\\n        flatten(root->left,prev);\\n\\n        root->right = prev;\\n        root->left = NULL;\\n        prev = root;\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)\\n            return;\\n\\n        TreeNode* prev = NULL;\\n\\n        flatten(root,prev);\\n\\n    }\\n};\\n```\\n\\n# APPROACH - 2 (Using Stack)\\n\\n## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn a binary tree, generally, we need to set the right child of the node to the left and the left child to NULL. If the given tree is a left-skewed tree, this action alone will flatten the binary tree.\\n\\nNow the main question arises is what if the current node doesn\\u2019t have a left child? In that case, we don\\u2019t want to assign its right child to NULL( its left child), rather we want it to assign to itself so that our preorder sequence is maintained. In case the right child is also not present(a leaf node) we would want to assign the right child to some parent node\\u2019s right child.\\n\\nTo get to this parent\\u2019s right node we will use a stack. Whenever we are at a node we want to prioritize its left child if it is present. If it is not present we want to look at the right child. A stack is a LIFO data structure, we first push the right child and then the left child. Then we set the right child of the node to the stack\\u2019s top and left child as NULL. This way the stack always provides the correct next node.\\n\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe algorithm approach can be stated as:\\n\\n1. Take a stack and push the root node to it.\\n2. Set a while loop till the stack is non-empty.\\n3. In every iteration, take the node at the top of the stack( say cur) and pop the stack.\\n4. If cur has a right child, push it to the stack.\\n5. If cur has a left child, push it to the stack.\\n5. Set the right child of cur to node at stack\\u2019s top.\\n6. Set the left child of cur as NULL.\\n\\n## Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n## Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)    \\n        return;\\n\\n        stack<TreeNode*> st;\\n\\n        st.push(root);\\n\\n        while(!st.empty()) {\\n            TreeNode* curr = st.top();\\n            st.pop();\\n\\n            if(curr->right)\\n                st.push(curr->right);\\n\\n            if(curr->left)\\n                st.push(curr->left);\\n\\n            if(!st.empty()) {\\n                curr->right = st.top();\\n            }\\n            curr->left = NULL;\\n        }\\n    }\\n};\\n```\\n\\n# APPROACH - 3 (Using Morris Traversal)\\n\\n## Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe will use the intuition behind morris\\u2019s traversal. In Morris Traversal we use the concept of a threaded binary tree.\\n\\nIf we set the right child of every node like this(marked in red) and the left child as NULL, our job will be done.\\n\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. At a node(say cur) if there exists a left child, we will find the rightmost node in the left subtree(say prev).\\n2. We will set prev\\u2019s right child to cur\\u2019s right child,\\n3. We will then set cur\\u2019s right child to it\\u2019s left child.\\n4. We will then move cur to the next node by assigning cur it to its right child\\n5. We will stop the execution when cur points to NULL.\\n\\n## Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n## Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)\\n            return;\\n\\n        TreeNode* curr = root;\\n\\n        while(curr) {\\n\\n            if(curr->left) {\\n                TreeNode* prev = curr->left;\\n\\n                while(prev->right) {\\n                    prev = prev->right;\\n                }\\n\\n                prev->right = curr->right;\\n                curr->right = curr->left;\\n\\n\\n            }\\n            curr->left = NULL;\\n            curr = curr->right;\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root,TreeNode*& prev) {\\n        if(root == NULL)\\n            return;\\n\\n        flatten(root->right,prev);\\n        flatten(root->left,prev);\\n\\n        root->right = prev;\\n        root->left = NULL;\\n        prev = root;\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)\\n            return;\\n\\n        TreeNode* prev = NULL;\\n\\n        flatten(root,prev);\\n\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)    \\n        return;\\n\\n        stack<TreeNode*> st;\\n\\n        st.push(root);\\n\\n        while(!st.empty()) {\\n            TreeNode* curr = st.top();\\n            st.pop();\\n\\n            if(curr->right)\\n                st.push(curr->right);\\n\\n            if(curr->left)\\n                st.push(curr->left);\\n\\n            if(!st.empty()) {\\n                curr->right = st.top();\\n            }\\n            curr->left = NULL;\\n        }\\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        if(root == NULL)\\n            return;\\n\\n        TreeNode* curr = root;\\n\\n        while(curr) {\\n\\n            if(curr->left) {\\n                TreeNode* prev = curr->left;\\n\\n                while(prev->right) {\\n                    prev = prev->right;\\n                }\\n\\n                prev->right = curr->right;\\n                curr->right = curr->left;\\n\\n\\n            }\\n            curr->left = NULL;\\n            curr = curr->right;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1568936,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1803547,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1569861,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1568126,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1568935,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1567860,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1728214,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1576171,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1575264,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1571237,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1568936,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1803547,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1569861,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1568126,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1568935,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1567860,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1728214,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1576171,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1575264,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 1571237,
                "content": [
                    {
                        "username": "dkarampi",
                        "content": "I'm writing my solution in Java using recursion and I don't understand the result appearing after a wrong submission.\\nThe given method is a void one. Do I have to print the values ? Comma separated ?\\n\\nPlease explain me the output format."
                    },
                    {
                        "username": "Vipul_Chaudhary",
                        "content": "You have to just modify the given root node (not need to print or return something).  \nI'm too late to answer this.  "
                    },
                    {
                        "username": "poojith_kumar",
                        "content": "change difficulty to hard"
                    },
                    {
                        "username": "dianzipaopao",
                        "content": "public void flatten(TreeNode root) {\\n        root = null;\\n    }\\n\\t\\n\\tOutput :    [1,2,5,3,4,null,6]\\n\\t\\n\\tI am confused that why it does not return null?"
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "well this is the output of the first test case well see have a look at the tree structure \\njudging from the structure its printing null if the parent node has its right child but no left child so its prints null\\n\\nmore than that we are not writing another structure but rather editing the current tree so in the given tree assuming it\\'s a complete binary tree it needs to maintain its properties and hence need to have two children per node and i think that explains why the program is even reading null as a valid answer.\\n"
                    },
                    {
                        "username": "sans_sehgal",
                        "content": "[@godshiva](/godshiva) So how do you give the output? "
                    },
                    {
                        "username": "godshiva",
                        "content": "Because they maintain the original head value.  All you have is a copy of the pointer."
                    },
                    {
                        "username": "izackwu",
                        "content": "Given the same input, my golang program gives totally different results, just as the screenshot shows.\\n![image](https://assets.leetcode.com/users/keithnull/image_1554898601.png)\\nI can\\'t figure out what\\'s wrong with my program and I assume this is a bug of Leetcode.\\n\\nOh, forget to point out that the only successful golang submission is code copied from someone\\'s solution in the forum, not mine.\\n"
                    },
                    {
                        "username": "forainychen",
                        "content": "For preorder traversal of the tree, you cannot avoid using a stack, either iterative or recursive. So if I use a stack in the problem, is it still considered as in place algorithm?"
                    },
                    {
                        "username": "jainsuyash2003",
                        "content": "You can avoid using a Stack, read about Morris Traversal ;)"
                    },
                    {
                        "username": "2uringTested",
                        "content": "well you dont have to use any stack here nor recursion:\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "s29962590",
                        "content": "[@Crispy_coffee](/Crispy_coffee) No bro u aren\\'t late , he asked too earlier."
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "There is nothing we can't avoid, here is the answer of your question, I know i am too late but atleast I am here\n\n```\nclass Solution {\npublic:\n    void invector(TreeNode* root, vector<TreeNode*> &in){\n        if(!root) return;\n        in.push_back(root);\n        invector(root->left, in);\n        invector(root->right, in);\n    }\n    void flatten(TreeNode* root) {\n        vector<TreeNode*> in;\n        invector(root, in);\n        int i;\n        for(i=1; i<in.size(); i++){\n            in[i-1]->right = in[i];\n            in[i-1]->left = NULL;\n            if(i==in.size()-1){\n                in[i]->right = NULL;\n                in[i]->left = NULL;\n            }\n        }\n        \n    }\n};"
                    },
                    {
                        "username": "epicure",
                        "content": "I saw most solutions here use recursion. But I'm not sure recursion is a in-place algorithm or not. Because recursion maintains call stacks while it's running."
                    },
                    {
                        "username": "shrmabhishek2012",
                        "content": "In place means mutating existing data structure. As in this problem, call stacks will only store the left and right node pointers as we traverse tree. As long as you are not dumping the entire tree into a new one and playing with the pointers to update the existing tree you are Good To Go.\\nSo recursion seems fine to me for this problem.\\nI may be wrong also. Any other input will be appreciated. Thanks"
                    },
                    {
                        "username": "tatertotfreak",
                        "content": "[@godshiva](/godshiva) Do you know why maintaining a call stack would change whether or not it\\'s an in-place algorithm? I don\\'t understand the question asked by epicure. "
                    },
                    {
                        "username": "godshiva",
                        "content": "In place only meant you have to re-use the existing nodes"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "Best DFS explanation:\\nhttps://youtu.be/YjkorNm9sJA"
                    },
                    {
                        "username": "WilmerKrisp",
                        "content": "<-- please vote\\n\\n![image](https://assets.leetcode.com/users/images/837ed1da-beca-4775-8b92-b045d227c3e2_1641293709.6760304.png)\\n\\n![image](https://assets.leetcode.com/users/images/439377f4-fb72-4431-a8f4-3c40628140ab_1641293726.2384436.png)\\n\\n![image](https://assets.leetcode.com/users/images/e6d6735d-a7ee-4acd-8c40-63916a892573_1641293743.806385.png)\\n\\n![image](https://assets.leetcode.com/users/images/b6bf9a3d-0358-4def-b6e7-ff2a991b6d43_1641293747.2967207.png)\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Great!\\nNow lets read the rules together.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "rajsyt",
                        "content": "https://ccodingclub.blogspot.com/2021/05/flatten-binary-tree-to-linked-list.html\\n\\nExplained in detail both approach with time complexity analysis.\\n\\nFor more coding question practice and interview preparation [visit here](https://ccodingclub.blogspot.com/p/questions-dynamic-programming-dynamic.html)\\n\\nAnd For Reading Interview Experience [visit here](https://ccodingclub.blogspot.com/p/interview-experience.html)"
                    },
                    {
                        "username": "bwv988",
                        "content": "It's so weird the error was TLE, since my original solution passed the failure case in 1 ms. Costed me quite some time debugging...\\nAfter reset every left child to NULL, the solution got AC."
                    }
                ]
            },
            {
                "id": 2075284,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 2057731,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 2031192,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 2012121,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1995358,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1982411,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1966908,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1957155,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1950765,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1949217,
                "content": [
                    {
                        "username": "user8104ko",
                        "content": "Can anyone tell me how to solve problem  ?  I wrote some code  \\nclass Solution { \\n    static ArrayList<Integer> arr = new ArrayList<>();\\n    public void flatten(TreeNode root) {\\n        \\n        if(root == null)\\n        {\\n            return;\\n        }  \\n        arr.add(root.val); \\n        arr.add(null);\\n        flatten(root.left); \\n        flatten(root.right);\\n    }\\n}"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "That\\'s not the right solution. why are you adding null to your array list. just check on youtube many good videos"
                    },
                    {
                        "username": "PoorPanda",
                        "content": "Question should be convert binary tree to skewed binary tree"
                    },
                    {
                        "username": "parthdharmale008",
                        "content": "i might take a lot of time to find logic behind this in an actual interview if i haven\\'t done this earlier"
                    },
                    {
                        "username": "sn82990eha",
                        "content": "Morris Traversal method\n\nClass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        TreeNode * curr=root;\n        while(curr!=NULL){\n            if(curr->left!=NULL){\n                TreeNode *prev=curr->left;\n                while(prev->right){\n                    prev=prev->right;\n                }\n                prev->right=curr->right;\n                curr->right=curr->left;\n                curr->left=NULL;\n            }\n            curr=curr->right;\n        }\n    }\n};"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "Leetcode Rules Method.\\n\\n\\uD83D\\uDCA1 Discussion Rules\\n1. Please don\\'t post any solutions in this discussion.\\n\\n2. The problem discussion is for asking questions about the problem or for sharing tips - anything except for solutions.\\n\\n3. If you\\'d like to share your solution for feedback and ideas, please head to the solutions tab and post it there."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "-_-\\n"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "#### WHY THERE IS NULL IN THE OUTPUT ?\\nBecause essentially we are returning a ***Skewed Binary Tree***, and not a ***Linear Linked List***.\\n\\n- The \"linked list\" should use the same `TreeNode` class where the `right child pointer` points to the ***NEXT NODE*** in the list and the `left child pointer` is always ***NULL***."
                    },
                    {
                        "username": "Lokadithya_M",
                        "content": "You said it yourself left child is always NULL and thats the main factor for defining a Skewed Binary tree so i dont see it ? \nwhat is your question \n"
                    },
                    {
                        "username": "pravesh_252505",
                        "content": "/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void recursion(TreeNode *root,TreeNode *&tail,TreeNode *&head){\\n        if(!root)return  ;\\n        cout<<root->val<<endl;\\n        if(!head){\\n            tail=new TreeNode (root->val);\\n            head=tail;\\n             recursion(root->left,tail,head);\\n             recursion(root->right,tail,head);\\n        }\\n        else{ \\n            tail->right=new TreeNode(root->val);\\n            tail->left=NULL;\\n            tail=tail->right;\\n            recursion(root->left,tail,head);\\n            recursion(root->right,tail,head);\\n        }\\n       \\n    }\\n    void flatten(TreeNode* &root) {\\n        TreeNode *tail=NULL,*head=NULL;\\n        recursion(root,tail,head);\\n        root=head;\\n    }\\n};\\nokay so this code is working fine ,wait I mean, after completion of recursion function I\\'m assigning head to root  and on printing root I\\'m getting correct answer but on submitting ,it shows that root is not changed why is it so ?"
                    },
                    {
                        "username": "ayushjha1",
                        "content": "what is the error in this code pls reply\\ngive runtime error\\n\\nclass Solution {\\npublic:\\n    TreeNode* p;\\n    void solve(TreeNode* t){\\n        if(!t)\\n            return;\\n        TreeNode* a=t->right;\\n        p->right=t;\\n        p=p->right;\\n        cout<<p->val<<endl;\\n        TreeNode* b=t->left;\\n        p->left=0;\\n        solve(b);\\n        solve(a);\\n    }\\n\\n    void flatten(TreeNode* root) {\\n        p=root;\\n        solve(root);\\n        root=root->right;\\n    }\\n};"
                    },
                    {
                        "username": "PercyJia95",
                        "content": "The question implicitly frees all memory on every node\\'s left leaf, that is why I got \"use-after-free bug\" because I had left and right pointing to the same node when building the linked list.\\n\\n This caused me hours to debug.\\n"
                    },
                    {
                        "username": "akash_vannam",
                        "content": "Why is this solution giving me wrong answer?\\nI checked in vs code. It gives correct output. Somebody please help pe with this, I\\'m loosing my mind!!!!\\n\\n\\n\\nTreeNode* help(TreeNode *root, TreeNode* &cur)\\n    {\\n        if(root == NULL) return root;\\n        cur = root;\\n        TreeNode *left = root->left, *right = root->right;\\n        root->left = NULL;\\n        cur->right = help(left, cur);\\n        cur->right = help(right, cur);\\n        return root;\\n    }\\n        \\n    void flatten(TreeNode* &root) {\\n        TreeNode *cur = NULL;\\n        root = help(root,cur);\\n    }"
                    },
                    {
                        "username": "AthenaCodes2605",
                        "content": "it is a super easy question, just tests basic linkedlist knowledge "
                    },
                    {
                        "username": "2uringTested",
                        "content": "ohh, it's easy if you do it with recursion, but that taken O(n) stack space. Do it without using that stack space, in O(1) space complexity"
                    }
                ]
            },
            {
                "id": 1946730,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1944429,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1934432,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1919035,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1917937,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1841391,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1835651,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1828005,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1803532,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            },
            {
                "id": 1761006,
                "content": [
                    {
                        "username": "shrish-nitb",
                        "content": "Is is possible without using stack?"
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) \\uD83D\\uDE4F\\uD83D\\uDE04 nice catch buddy compelling to change my mind"
                    },
                    {
                        "username": "2uringTested",
                        "content": "[@shrish-nitb](/shrish-nitb) Great work but the thing is, recursive approach itself takes an internal stack to implement. "
                    },
                    {
                        "username": "shrish-nitb",
                        "content": "[@2uringTested](/2uringTested) thanks for help\\nI\\'ve figured out a recursive approach\\nclass Solution {\\npublic:\\n    TreeNode* head; \\n    TreeNode* prev = NULL;\\n    void flatten(TreeNode* root) {\\n        if(root == NULL) return;\\n        TreeNode* left = root->left;\\n        TreeNode* right = root->right;\\n        root->left = NULL;\\n        if(prev != NULL) {\\n            prev->right = root;\\n        }\\n        prev = root;\\n        flatten(left);\\n        flatten(right);\\n    }\\n};"
                    },
                    {
                        "username": "2uringTested",
                        "content": "Yes it is.\\n\\n```\\nclass Solution {\\npublic:\\n    void flatten(TreeNode* root) {\\n        TreeNode* curr = root;\\n        while(curr){\\n            if(curr->left){\\n                TreeNode* pred = curr->left;\\n                while(pred->right) pred=pred->right;\\n                pred->right = curr->right;\\n                curr->right = curr->left;\\n                curr->left = NULL;\\n                curr = curr->right;\\n            }else{\\n                curr=curr->right;\\n            }\\n        }\\n    }\\n};\\n```"
                    },
                    {
                        "username": "Anup292001",
                        "content": "please someone tell me what is issue in this solution\\n\\nclass Solution {\\npublic:\\n    void fun(TreeNode* root,TreeNode* list){\\n        if(root==NULL){\\n            return ;\\n        }\\n        list->right = new TreeNode(root->val);\\n        list->left = NULL;\\n        fun(root->left,list->right);\\n        fun(root->right,list->right);\\n    }\\n    void flatten(TreeNode* root) {\\n        TreeNode* list=new TreeNode();\\n        fun(root,list);\\n        root = list->right;\\n        \\n    }\\n};"
                    },
                    {
                        "username": "dondublon",
                        "content": "I failed with the case:\\n[1,null,2,3]\\n\\nHow could it be? The node at index 3, value 3 - seems decsend from the \\'null\\' node? Null node, index==1, 2*1+1=3.  "
                    },
                    {
                        "username": "gauravbharti",
                        "content": "So all what question asks is - Traverse and solve using Morris Traversal. It solves in O(n) time and O(1) space and its the only way to solve it in-place. Recursion and stack iterative vise is neither O(1) space nor inplace. "
                    },
                    {
                        "username": "masterbaiter",
                        "content": "Can someone helps me to debug\\n```\\nvoid flatten(TreeNode* root) {\\n        if (root == NULL) {\\n            return;\\n        }\\n\\n        flatten(root->left);\\n        flatten(root->right);\\n\\n        if (root->left == NULL) \\n            return;\\n        \\n\\n        TreeNode* p = root->left;\\n\\n        while (p != NULL && p->right != NULL) {\\n            p = p->right;\\n        }\\n\\n        p->right = root->right;\\n        root->right = root->left;\\n    \\n    }\\n```\\nI got ==22==ERROR: AddressSanitizer: heap-use-after-free on address error, running the default test cases"
                    },
                    {
                        "username": "aman3091",
                        "content": "kindly guide where i am wrong in this code or what changes i need to make to resolve error\\n\\nvoid flatten(TreeNode* root) {\\n        queue<TreeNode*> q;\\n        stack<TreeNode*> st;\\n        st.push(root);\\n        while(!st.empty()){\\n            TreeNode* temp=st.top();\\n            st.pop();\\n           if(temp->right!=NULL){\\n               st.push(temp->right);\\n           }\\n            if(temp->left!=NULL){\\n               st.push(temp->left);\\n           }\\n             q.push(temp);\\n        }\\nwhile(!q.empty()){\\n    TreeNode* temp=q.front();\\n q.pop();\\n temp->left=NULL;\\n if(!q.empty()){\\n temp->right=q.front();\\n }\\n}\\n    \\n    }"
                    },
                    {
                        "username": "cOde_Ranvir25",
                        "content": "Here is my straightforward approach:-\\n\\n1. Perform a preorder traversal of the binary tree, storing the node values in the preorder list.\\n2. Set the root node as node.\\n3. For each value in preorder starting from index 1 (the second value), create a new TreeNode object with the value and set it as the right child of node. Also, set the left child of node to null.\\n4. Update node to point to the newly created right child.\\n5. Return the modified tree."
                    },
                    {
                        "username": "Vaibhav_Singhania",
                        "content": "can someone help me find out as to what is wrong in my code. It seems fine to me but not giving results. @ @ `class Solution {\\n    TreeNode preptr = new TreeNode(0);\\n    TreeNode thead = preptr;\\n    public void flatten(TreeNode root) {\\n        if(root==null)\\n        return ;\\n        else{\\n            thead.right=new TreeNode(root.val);\\n            thead=thead.right;\\n            flatten(root.left);\\n            flatten(root.right);\\n        }root=preptr.right;\\n    }\\n}`"
                    },
                    {
                        "username": "pattharock",
                        "content": "I have simply stored the ROOT -> LEFT -> RIGHT traversal in an array and then once we have the desired nodes in an array - we can rewire the connections in one more pass of the array to achieve desired result. What is wrong with this method compared to the conventional method. Both are using O(N) space time"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/8N_L_c71avU"
                    }
                ]
            }
        ]
    }
]