[
    {
        "title": "Beautiful Array",
        "question_content": "An array nums of length n is beautiful if:\n\n\tnums is a permutation of the integers in the range [1, n].\n\tFor every 0 <= i < j < n, there is no index k with i < k < j where 2 * nums[k] == nums[i] + nums[j].\n\nGiven the integer n, return any beautiful array nums of length n. There will be at least one valid answer for the given n.\n&nbsp;\nExample 1:\nInput: n = 4\nOutput: [2,1,4,3]\nExample 2:\nInput: n = 5\nOutput: [3,1,2,5,4]\n&nbsp;\nConstraints:\n\n\t1 <= n <= 1000",
        "solutions": [
            {
                "id": 186679,
                "title": "odd-even-pattern-o-n",
                "content": "# **Intuition**:\\nTry to divide and conquer,\\nso we have left part, right part.\\n\\nOne way is to divide into [1, N / 2] and [N / 2 + 1, N].\\nBut it will cause problems when we merge them.\\n\\nAnother way is to divide into odds part and evens part.\\nSo there is no `k` with `A[k] * 2 = odd + even`\\n\\nI brute force all permutations when N = 5:\\n20 beautiful array found,\\nonly 4 don\\'t fit odd + even pattern:\\n`[2, 1, 4, 5, 3]`\\n`[3, 1, 2, 5, 4]`\\n`[3, 5, 4, 1, 2]`\\n`[4, 5, 2, 1, 3]`\\n</br>\\n\\n# **Beautiful Array Properties**\\n\\nSaying that an array is beautiful,\\nthere is no `i < k < j`,\\nsuch that `A[k] * 2 = A[i] + A[j]`\\n\\nApply these 3 following changes a beautiful array,\\nwe can get a new beautiful array\\n</br>\\n\\n**1. Deletion**\\nEasy to prove.\\n\\n**2. Addition**\\nIf we have `A[k] * 2 != A[i] + A[j]`,\\n`(A[k] + x) * 2 = A[k] * 2 + 2x != A[i] + A[j] + 2x = (A[i] + x) + (A[j] + x)`\\n\\nE.g: `[1,3,2] + 1  = [2,4,3]`.\\n\\n\\n**3. Multiplication**\\nIf we have `A[k] * 2 != A[i] + A[j]`,\\nfor any `x != 0`,\\n`(A[k] * x) * 2 = A[k] * 2 * x != (A[i] + A[j]) * x = (A[i] * x) + (A[j] * x)`\\n\\nE.g: `[1,3,2] * 2  = [2,6,4]`\\n</br>\\n\\n# **Explanation**\\nWith the observations above, we can easily construct any beautiful array.\\nAssume we have a beautiful array `A` with length `N`\\n\\n`A1 = A * 2 - 1` is beautiful with only odds from `1` to `N * 2 -1`\\n`A2 = A * 2` is beautiful with only even from `2` to `N * 2`\\n`B = A1 + A2` beautiful array with length `N * 2`\\n\\nE.g:\\n```\\nA = [2, 1, 4, 5, 3]\\nA1 = [3, 1, 7, 9, 5]\\nA2 = [4, 2, 8, 10, 6]\\nB = A1 + A2 = [3, 1, 7, 9, 5, 4, 2, 8, 10, 6]\\n```\\n</br>\\n\\n# **Time Complexity**:\\nI have iteration version here `O(N)`\\nNaive recursion is `O(NlogN)`\\nRecursion with one call or with cache is `O(N)`\\n</br>\\n# **Solution**:\\n**C++:**\\n```\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) {\\n            vector<int> tmp;\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n```\\n\\n**Java:**\\n```\\n    public int[] beautifulArray(int N) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        res.add(1);\\n        while (res.size() < N) {\\n            ArrayList<Integer> tmp = new ArrayList<>();\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.add(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.add(i * 2);\\n            res = tmp;\\n        }\\n        return res.stream().mapToInt(i -> i).toArray();\\n    }\\n```\\n\\n**Python:**\\n```\\n    def beautifulArray(self, N):\\n        res = [1]\\n        while len(res) < N:\\n            res = [i * 2 - 1 for i in res] + [i * 2 for i in res]\\n        return [i for i in res if i <= N]\\n```\\n</br>\\n\\n## **Advanced**:\\nSome other ideas: https://leetcode.com/problems/beautiful-array/discuss/186680\\nAuthor: lee215\\n",
                "solutionTags": [],
                "code": "```\\nA = [2, 1, 4, 5, 3]\\nA1 = [3, 1, 7, 9, 5]\\nA2 = [4, 2, 8, 10, 6]\\nB = A1 + A2 = [3, 1, 7, 9, 5, 4, 2, 8, 10, 6]\\n```\n```\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) {\\n            vector<int> tmp;\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n```\n```\\n    public int[] beautifulArray(int N) {\\n        ArrayList<Integer> res = new ArrayList<>();\\n        res.add(1);\\n        while (res.size() < N) {\\n            ArrayList<Integer> tmp = new ArrayList<>();\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.add(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.add(i * 2);\\n            res = tmp;\\n        }\\n        return res.stream().mapToInt(i -> i).toArray();\\n    }\\n```\n```\\n    def beautifulArray(self, N):\\n        res = [1]\\n        while len(res) < N:\\n            res = [i * 2 - 1 for i in res] + [i * 2 for i in res]\\n        return [i for i in res if i <= N]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 187669,
                "title": "share-my-o-nlogn-c-solution-with-proof-and-explanation",
                "content": "---\\n## 1. Problem\\n\\n---\\nFor some fixed ```N```, an array ```A``` is *beautiful* if it is a permutation of the integers ```1, 2, ..., N```, such that:\\n\\nFor every ```i < j```, there is **no** ```k``` with ```i < k < j``` such that ```A[k] * 2 = A[i] + A[j]```.\\n\\nGiven ```N```, return **any** beautiful array ```A```.  (It is guaranteed that one exists.)\\n\\n**Example 1:**\\n```\\nInput: 4\\nOutput: [2,1,4,3]\\n```\\n**Example 2:**\\n```\\nInput: 5\\nOutput: [3,1,2,5,4]\\n```\\nNote:\\n\\n* ```1 <= N <= 1000```\\n\\n---\\n## 2. Thinking process\\n\\n---\\n#### 2.1 Analysis\\n\\n---\\nThe problem is to make a permutation of integers 1 to N in an array A. For every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j].\\n\\n**A[k]** here is the **average number of A[i] and A[j]**, which means the rule here can be expressed as\\n\\n>#### There is **no average number of A[i] and A[j] between A[i] and A[j]** (i < j).\\n\\nAt first glance, the rule is a little bit complicated, but we can find an **interesting fact**.\\n\\nThe **fact** is\\n\\n>#### **The average number of an odd number and an even one is not an integer.**\\n\\n---\\n#### 2.2 First level partition\\n\\n---\\n\\nIn order to explain the problem easily, here we take **N = 10** as an example.\\n\\nThe numbers to be processed are\\n\\n**Universal set:**\\n>#### **S = [1,2,3,4,5,6,7,8,9,10]**.\\n\\nNow it is divided into 2 subsets **S1** and **S2**:\\n\\n**Subset 1 (odd):**\\n>#### **S1 = [1,3,5,7,9]**.\\n\\nIn **S1**, \\n>#### the **0-th binary digit(LSB) of all elements** are **same (equals 1)**.\\nwhich means for **all A[i] \\u2208 S1**\\n>#### **A[i] & 1 \\u2260 0**.\\n\\n**Subset 2 (even):**\\n>#### **S2 = [2,4,6,8,10]**.\\n\\nIn **S2**, \\n>#### the **0-th binary digit(LSB) of all elements** are **same (equals 0)**.\\nwhich means for **all A[i] \\u2208 S2**\\n>#### **A[i] & 1 = 0**.\\n\\nNow think about the average of **all A[i]-A[j] pairs** (i < j) in the **universal set**, there are **3 situations**:\\n1. **one** from **S1**, **the other** also from **S1**. **The average** may be\\n    * in **S1** (for example: 1 and 5, the average is 3).\\n    * in **S2** (for example: 1 and 3, the average is 2).\\n2. **one** from **S2**, **the other** also from **S2**. **The average** may be\\n    * in **S1** (for example: 2 and 4, the average is 3).\\n    * in **S2** (for example: 2 and 6, the average is 4).\\n3. **one** from **S1**, **the other** from **S2**. **The average** is **NOT** in **both S1 and S2**.\\n\\nIf we put all numbers of **S1** **before** all numbers of **S2**, we will get a permutation\\n>#### [**1**,**3**,**5**,**7**,**9**,*2*,*4*,*6*,*8*,*10*].\\n\\nIn this case, there are no need for us to worry about situation 3.\\n>#### **S1** and **S2** may be processed **separately**.\\n\\nBut how?\\n\\n---\\n#### 2.3 Second level partition\\n\\n---\\nIn section 2.2, although the position of a certain element in S hasn\\'t been determined yet, the relative position of all S1 elements and S2 elements has been determined.\\n\\nThe **Exclusion Rule** is\\n>#### After **dividing the universal set S into 2 subsets S1 and S2**, it should be **guaranteed** that\\n>#### For **any A[i] \\u2208 S1, A[j] \\u2208 S2**, **the average of A[i] and A[j] will NOT appear in BOTH S1 and S2.**\\n\\nIf the **universal set** is **S1 in section 2.2**, can it be divided into **2 new Subsets** following the **Exclusion Rule**?\\n\\nSince **S1 is an odd set**, all its elements p can be expressed as\\n>#### **p = 2k + 1**.\\n\\nChoosing 2 elements **m, n \\u2208 S1**, if\\n\\n>#### **m = 2x + 1, n = 2y + 1**.\\n\\nthe average will be\\n\\n>#### **(m + n)/2 = x + y + 1**.\\n\\nAs the rule says, if S1 can be divided into 2 subsets, the average\\n\\n>#### **x + y + 1** is **not in S1**.\\n\\nwhich means\\n\\n>#### **x + y + 1** is **even**, **x + y** is **odd**.\\n>#### **x** and **y** have **different parity**.\\n\\nNow S1 can be divided into 2 subsets according to k = (A[i] - 1) / 2.\\n**Subset 1.1 (odd k):**\\n>#### **S11 = [3,7]**.\\n\\nIn **S11**, \\n>#### **the 1-st, 0-th binary digits of all elements** are **same (equals 11)**.\\nwhich means for **all A[i] \\u2208 S11**\\n>#### **A[i] & 2 \\u2260 0**.\\n\\n**Subset 1.2 (even k):**\\n>#### **S12 = [1,5,9]**.\\n\\nIn **S12**, \\n>#### **the 1-st, 0-th binary digits of all elements** are **same (equals 01)**.\\nwhich means for **all A[i] \\u2208 S12**\\n>#### **A[i] & 2 = 0**.\\n\\n---\\n\\nNow we focus on S2.\\n\\nIf the **universal set** is **S2 in section 2.2**, can it be divided into **2 new Subsets** following the **Exclusion Rule**?\\n\\nSince **S2 is an even set**, all its elements p can be expressed as\\n>#### **p = 2k**.\\n\\nChoosing 2 elements **m, n \\u2208 S2**, if\\n\\n>#### **m = 2x, n = 2y**.\\n\\nthe average will be\\n\\n>#### **(m + n)/2 = x + y**.\\n\\nAs the rule says, if S2 can be divided into 2 subsets, the average\\n\\n>#### **x + y** is **not in S2**.\\n\\nwhich means\\n\\n>#### **x + y** is **odd**.\\n>#### **x** and **y** have **different parity**.\\n\\nNow S2 can be divided into 2 subsets according to k = A[i] / 2.\\n**Subset 2.1 (odd k):**\\n>#### **S21 = [2,6,10]**.\\n\\nIn **S21**, \\n>#### **the 1-st, 0-th binary digits of all elements** are **same (equals 10)**.\\nwhich means for **all A[i] \\u2208 S21**\\n>#### **A[i] & 2 \\u2260 0**.\\n\\n**Subset 2.2 (even k):**\\n>#### **S22 = [4,8]**.\\n\\nIn **S22**, \\n>#### **the 1-st, 0-th binary digits of all elements** are **same (equals 00)**.\\nwhich means for **all A[i] \\u2208 S22**\\n>#### **A[i] & 2 = 0**.\\n\\nAfter first and second level partition, the permutation becomes\\n>#### [**3**,**7**,*1*,*5*,*9*,***2***,***6***,***10***,4,8].\\n\\n---\\n#### 2.4 Two guesses\\n\\n---\\nIf A[i]\\'s binary representation is\\n\\n>#### **A[i] = M(r)M(r-1)M(r-2)...M(0), M(i) = 0 or 1, 0 \\u2264 i \\u2264 r, r > 0**.\\n\\nThe **first level partition** focuses on **A[i] & 1 - in other words, the 1st LSB M(0)**.\\n\\n* If M(0) = 1, A[i] \\u2208 S1. If M(0) = 0, A[i] \\u2208 S2.\\n\\nThe **second level partition** focuses on **A[i] & 2 - in other words, the 2nd LSB M(1)**.\\n\\n* If M(0) = 1,\\n  * If M(1) = 1, A[i] \\u2208 S11.\\n  * If M(1) = 0, A[i] \\u2208 S12.\\n* If M(0) = 0,\\n  * If M(1) = 1, A[i] \\u2208 S21.\\n  * If M(1) = 0, A[i] \\u2208 S22.\\n\\n**......**\\n\\nwe can infer that the **Partition Rule** is\\n>#### The k-th (k > 0) level partition is based on A[i] & 2^(k - 1) - in other words, the k-th LSB M(k-1) is 1 or 0.\\n\\nAs shown in section 2.2 and 2.3,\\n\\nAfter **first level partition**,\\n\\n>#### The **0-th binary digit (1 least significant bit, LSB)** of all elements in S1 (or S2) are **same**. \\n\\nAfter **second level partition**,\\n\\n>#### The **1-st, 0-th binary digits (2 LSBs)** of all elements in S11 (or S12, S21, S22) are same.\\n\\n**......**\\n\\nwe guess\\n\\n**Guess A:**\\nIf we follow the **Partition Rule**,\\n\\n>#### **after k-th (k > 0) level partition, the k LSBs of all elements in each generated subsets are same.**\\n\\n**Guess B:**\\nIf we follow the **Partition Rule**,\\n\\n>#### **the generated subsets will ALWAYS satisfy the Exclusion Rule in section 2.3.**\\n\\n---\\n#### 2.5 Proof\\n\\n---\\nIn order to prove Guess A and B, the mathematical Induction is applied.\\n\\n**Guess A:**\\n\\nif we follow the **Partition Rule**\\n\\n**Base case:**\\n\\nWhen k = 1, as shown in section 2.2,\\n\\nafter first level partition, the LSB of all elements in each generated subsets (S1 or S2) are same.\\n\\n**Step case:**\\n\\nAfter k-th level partition, the k LSBs of all elements in each generated subsets are same.\\n\\nChoosing any subset U generated after k-th level partition,\\n\\nsupposing the k+1 LSBs of one element x \\u2208 U is M(k)M(k-1)...M(0).\\n\\nwhen doing the k+1-th partition, the binary digit M(k) will be checked,\\n\\n* If M(k) = 1, x \\u2208 U1.\\n* If M(k) = 0, x \\u2208 U2.\\n\\nBefore k+1-th partition, all elements in U have same M(k-1)...M(0).\\n\\nAfter k+1-th partition, all elements with same M(k) are put into one subset, which means\\n\\n>#### **all elements in U1 (or U2) have same M(k)M(k-1)... M(0) (k + 1 LSBs). Proved.**\\n\\n---\\n**Guess B:**\\n\\nFor any elements A[i] \\u2208 S1, A[j] \\u2208 S2, if we follow the **Partition Rule**,\\n\\n**Base case:**\\n\\nWhen k = 1, as shown in section 2.2,\\n\\nif we follows the **Partition Rule**, the average of any A[i]-A[j] pair is not an integer. (not in both S1 and S2).\\n\\n**Step case:**\\n\\nAs proved Guess A, after k-th level partition, the k LSBs of all elements in each generated subsets are same.\\n\\nChoosing any subset U generated after k-th level partition,\\n\\nsupposing the k+1 LSBs of one element x \\u2208 U is M(k)M(k-1)...M(0).\\n\\nwhen doing the k+1-th partition, the binary digit M(k) will be checked,\\n\\n- If M(k) = 1, x \\u2208 U1.\\n- If M(k) = 0, x \\u2208 U2.\\n\\nChoosing any A[i] \\u2208 U1, A[j] \\u2208 U2\\n\\nif P is odd, Q is even (P,Q \\u2265 0), and\\n\\n>#### **res = M(k-1)...M(0).**\\n\\nA[i] and A[j] can be represented as\\n\\n>#### **A[i] = P \\xD7 2^k + res.**\\n\\n>#### **A[j] = Q \\xD7 2^k + res.**\\n\\nThe average\\n\\n>#### **(A[i] + A[j])/2 = (P + Q) \\xD7 2^(k - 1) + res.**\\n\\nSince P is odd, Q is even, P + Q is odd, which means\\n\\n>#### **1 will be added to M(k-1) - the most significant bit (MSB) of res.**\\n\\nwhich means\\n\\n>#### **The k LSBs of the average is different from those of both A[i] and A[j].**\\n\\nThat is to say,\\n\\n>#### **The average is not in both U1 and U2. Proved.**\\n\\n---\\n## 3. Algorithm\\n\\n---\\n\\nAs been discussed above, this is a divide and conquer problem, which is suitable for recursion.\\n\\n**Stop situation:**\\n\\nWhen the generated subset\\'s size is small enough (contains **0** or **1** element), the recursion should stop.\\n\\n**Recursion logic:**\\n\\nAs the problem can be treated as a special sorting problem, \\n\\nthe whole logic can be divided into patition part and sorting part .\\n\\nWhen sorting, there are 4 inputs,\\n\\n* vector **v**.\\n* start index **start**.\\n* end index **end**.\\n* **mask** for judging elements and put them into subsets.\\n\\nAfter the inputs are introduced to partition part,\\n\\nthe elements in **v** from **start** to **end** are swapped like doing quicksort, the border index **mid** is returned.\\n\\nAfter doing partition\\n\\n* all elements from index **start** to index **mid - 1** belongs to Subset **1**.\\n\\n* all elements from index **mid** to index **end** belongs to Subset **2**.\\n\\nWhen the partition finished, we can sort on **start** to **mid - 1** and **mid** to **end** recursively, \\n\\nAccoring to the **Partition Rule**, the **mask** should be **doubled**.\\n\\n**Initial values:**\\n\\n* v = [1,2,3,4,...,N].\\n* start = 0.\\n* end = N-1.\\n* mask = 1.\\n\\n---\\n## 4. Complexity Analysis\\n\\n---\\n\\n#### 4.1 Time complexity\\n\\n---\\nOn each level, the recursion branch will iterate over all elements.\\n\\nOn k-th level, the k-th LSB will be checked. \\n\\nThe number of iteration will be **AT MOST log2N**.\\n\\n>#### The time complexity is **O(NlogN)**.\\n\\n---\\n\\n#### 4.2 Space complexity\\n\\n---\\n\\nThe algorithm is an **in-place implementation**. \\nAs it\\'s a recursion algorithm, and the depth of the recursion tree is AT MOST log2N.\\n\\n>#### The space complexity is **O(N)**.\\n\\n---\\n## 5. Code\\n\\n---\\n```\\nclass Solution {\\npublic:\\n    int partition(vector<int> &v, int start, int end, int mask)\\n    {\\n        int j = start;\\n        for(int i = start; i <= end; i++)\\n        {\\n            if((v[i] & mask) != 0)\\n            {\\n                swap(v[i], v[j]);\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n    \\n    void sort(vector<int> & v, int start, int end, int mask)\\n    {\\n        if(start >= end) return;\\n        int mid = partition(v, start, end, mask);\\n        sort(v, start, mid - 1, mask << 1);\\n        sort(v, mid, end, mask << 1);\\n    }\\n    \\n    vector<int> beautifulArray(int N) {\\n        vector<int> ans;\\n        for(int i = 0; i < N; i++) ans.push_back(i + 1);\\n        sort(ans, 0, N - 1, 1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Math",
                    "Divide and Conquer"
                ],
                "code": "```N```\n```A```\n```1, 2, ..., N```\n```i < j```\n```k```\n```i < k < j```\n```A[k] * 2 = A[i] + A[j]```\n```N```\n```A```\n```\\nInput: 4\\nOutput: [2,1,4,3]\\n```\n```\\nInput: 5\\nOutput: [3,1,2,5,4]\\n```\n```1 <= N <= 1000```\n```\\nclass Solution {\\npublic:\\n    int partition(vector<int> &v, int start, int end, int mask)\\n    {\\n        int j = start;\\n        for(int i = start; i <= end; i++)\\n        {\\n            if((v[i] & mask) != 0)\\n            {\\n                swap(v[i], v[j]);\\n                j++;\\n            }\\n        }\\n        return j;\\n    }\\n    \\n    void sort(vector<int> & v, int start, int end, int mask)\\n    {\\n        if(start >= end) return;\\n        int mid = partition(v, start, end, mask);\\n        sort(v, start, mid - 1, mask << 1);\\n        sort(v, mid, end, mask << 1);\\n    }\\n    \\n    vector<int> beautifulArray(int N) {\\n        vector<int> ans;\\n        for(int i = 0; i < N; i++) ans.push_back(i + 1);\\n        sort(ans, 0, N - 1, 1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186680,
                "title": "python-three-1-line-solutions",
                "content": "Sort by reversed binary\\n```\\n    def beautifulArray(self, N):\\n        return sorted(range(1, N + 1), key=lambda x: bin(x)[:1:-1])\\n```\\n\\nNaive recursion\\n```\\n    def beautifulArray(self, N):\\n        return [i * 2 for i in self.beautifulArray(N / 2)] + [i * 2 - 1 for i in self.beautifulArray((N + 1) / 2)] if N > 1 else [1]\\n```\\n\\nBinary Reverse\\n```\\n    def beautifulArray(self, N):\\n        return [i for i in [int(\\'{:010b}\\'.format(i)[::-1], 2) for i in range(1, 1 << 10)] if i <= N]\\n```",
                "solutionTags": [],
                "code": "```\\n    def beautifulArray(self, N):\\n        return sorted(range(1, N + 1), key=lambda x: bin(x)[:1:-1])\\n```\n```\\n    def beautifulArray(self, N):\\n        return [i * 2 for i in self.beautifulArray(N / 2)] + [i * 2 - 1 for i in self.beautifulArray((N + 1) / 2)] if N > 1 else [1]\\n```\n```\\n    def beautifulArray(self, N):\\n        return [i for i in [int(\\'{:010b}\\'.format(i)[::-1], 2) for i in range(1, 1 << 10)] if i <= N]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 583910,
                "title": "easy-explanation-of-concept-concise-c",
                "content": "Credit : i_love_xiaoshagua_cpp for code.\\nUPVOTE will be highly appreciated!\\n\\nFirstly we must understand that :PROPERTY 1: given a series of beautiful-array if we\\n* multiply each element by 2 OR\\n* multiply each element by 2 and subtract one from it\\n\\nthe resulting series is also beautiful (just take them a,b,c and try out, the twos get cancelled in A[k] * 2 = A[i] + A[j].)\\n\\nPROPERTY 2 : Now second thing is combining two beautiful arrays:\\n RESULT  = {ARRAY ONE} {ARRAY TWO}\\n If array one & array two are beautiful then\\n if array one is made up of all odd nos. and array 2 is made up of all even nos.\\n And let a1 & a2 be elements from array1 and array2 respectively.\\n (a1+a2)/2 is fraction and is not present in resulting array thus by 3 reasons:\\n \\n*array1 is beautiful  \\n*array2 is beautiful  \\n*(a1+a2)/2 is fraction and is not present in resulting array\\n\\nresulting array is also beautiful.\\n\\nNow lastly to make a beautiful array of N.\\n* make beautiful array of all even nos. till N \\n* make beautiful array of all odd nos. till N \\nJOIN them up !\\n\\nTo make beautiful arrays of all even and odd smaller than N will use property 1.\\n\\nEx: For N = 5        beautiful( { 2 , 4 } ) +  beautiful( { 1 , 3 , 5} )\\n\\nTo get beautiful of { 2 , 4 } get beautiful of N = 2 and multiply by 2\\nTo get beautiful of { 1 , 3 , 5}  get beautiful of N = 3 and multiply by 2 and subtract by 1.\\nThen JOIN them !\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n==1)\\n            return {1};\\n        vector<int> even = beautifulArray(n/2);\\n        vector<int> odd = beautifulArray(n-(n/2));\\n        vector<int>ans;\\n        for(auto e:even)\\n            ans.push_back(2*e);\\n        for(auto e:odd)\\n            ans.push_back((2*e)-1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n==1)\\n            return {1};\\n        vector<int> even = beautifulArray(n/2);\\n        vector<int> odd = beautifulArray(n-(n/2));\\n        vector<int>ans;\\n        for(auto e:even)\\n            ans.push_back(2*e);\\n        for(auto e:odd)\\n            ans.push_back((2*e)-1);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368125,
                "title": "detailed-explanation-with-diagrams-a-collection-of-ideas-from-multiple-posts-python3",
                "content": "## 0. Introduction\\nThis post is a collection of all the posts, comments and discussions of the LeetCode community. References mentioned at the bottom! I\\'ve attempted to explain things in detail, with diagrams to help understand the intuitions as well.\\n\\n## 1. Naive Solution\\nThe first thing anyone can think of is using `permutations(array)` to enumerate all the permutations in `O(N!)` time. This is bad in itself, but it gets worse. We still need to check the validity of the resultant array. We can do this in `O(N^3)` time, iterative over every possible combination of `i`, `j` and `k`.\\n\\nBelow is the code for it.\\n```\\nfrom itertools import permutations\\nclass Solution:\\n    def invalid(self, x):\\n        n = len(x)\\n        flag = False\\n        for i in range(n):\\n            if flag: break\\n            for j in range(i+2, n):\\n                if flag: break\\n                for k in range(i+1, j):\\n                    if 2*x[k] == x[i]+x[j]: flag = True; break\\n        return flag\\n        \\n    def beautifulArray(self, n: int) -> List[int]:\\n        for perm in permutations(range(1, n+1)):\\n            if not self.invalid(perm):\\n                return perm\\n```\\n\\nThis is clearly a dead end. The time complexity is enormous and impractical. But, what to do?\\n\\n## 2. Thinking in Terms of Bits\\n**Whenever stuck, think in terms of bits.**\\n\\nIt always helps to think in terms of bits, so let\\'s do that. Reformulating the problem, `nums[i]+nums[j] = 2*nums[k]` is not allowed.\\n\\nIn terms of bits, we can start with thinking what would happen if `nums[i]` or `nums[j]` is odd or even.\\n\\n\\n| nums[i] | nums[j] |   nums[k]    |\\n| ------- | ------- |:------------:|\\n| even    | even    |   even/odd   |\\n| odd     | odd     |   even/odd   |\\n| even    | odd     | non-existent |\\n| odd     | even    | non-existent |\\n\\n**Clearly, it looks like we want to focus on the last two cases. Ensuring that will ensure the validity of the solution.**\\n\\n## 3. Finding Recursion\\nWe know splitting the array into odds and evens is beneficial. The trivial case is `[odd numbers here] [even numbers here]`, or the opposite `[even numbers here] [odd numbers here]`. Both will work. For convenience, I\\'ll take the first one.\\n\\nexample: `n = 7`\\n`1 2 3 4 5 6 7` -> `1 3 5 7 | 2 4 6`\\n\\nThis clearly won\\'t work since `1 3 5 7` and `2 4 6` are troublesome in themselves, but if `i` is pointing to `1 3 5 7` and `j` to `2 4 6`, we can stay safe.\\n\\nNow, what if ... we break the `1 3 5 7` into two again? How? Just do a right-shift operation. (this is one of those problems whose solutions make sense once you know them lmao)\\n\\nThis makes the problem: `0 1 2 3`. Doesn\\'t this look eerily similar to the orignial problem? We can break this down as `1 3 | 0 2`. This will work for `evens` as well (think why). **We have found a recursion!** \\n\\nThe below diagram should explain it better.\\n\\n![](https://i.imgur.com/sxoCWG0.png)\\n\\nNote that the right shifting is done for explaination reasons, the goal is to actually just consider alternate elements. \\n\\n## 4. Code for Recursive Solution\\n```\\nclass Solution:\\n    def recurse(self, nums):\\n        if len(nums) <= 2: return nums\\n        return self.recurse(nums[::2]) + self.recurse(nums[1::2])\\n    \\n    def beautifulArray(self, n: int) -> List[int]:\\n        return self.recurse([i for i in range(1, n+1)])\\n```\\n\\n## 5. One-liner Solution\\nThe final one-liner solution is based on a very interesting observation. Recall how we worked with the trees, where each following height involved right-shifting the binary representation by one. Alternatively, think like this: What happened in the grand scheme? We considered the 0th bit first, then the 1st, then the 2nd and so on.\\n\\n![](https://i.imgur.com/r2w55ie.png)\\n\\nIf you note, this is equivalent to a sorting problem! The only difference is that we are considering the number in reverse, in binary. This brings us to the godly one liner solution by lee215.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return sorted(range(1, n+1), key=lambda x: bin(x)[:1:-1])\\n```\\n\\n## 6. References\\n- https://leetcode.com/r0bertz/ \\'s post https://leetcode.com/problems/beautiful-array/discuss/644612/Python3-solution-with-detailed-explanation-Beautiful-Array\\n- https://leetcode.com/lee215/ \\'s post https://leetcode.com/problems/beautiful-array/discuss/186680/Python-Three-1-line-Solutions\\n- https://leetcode.com/lee215/ \\'s post https://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N)\\n\\n\\nIf you want another look at the problem in a different format, here\\'s my video explanation.\\nhttps://www.youtube.com/watch?v=jHHdiMIJcr0.\\n\\nFeel free to ask any questions! Criticisms and comments are most welcome. If this helps you, upvote! It gives me motivation to be better :D",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nfrom itertools import permutations\\nclass Solution:\\n    def invalid(self, x):\\n        n = len(x)\\n        flag = False\\n        for i in range(n):\\n            if flag: break\\n            for j in range(i+2, n):\\n                if flag: break\\n                for k in range(i+1, j):\\n                    if 2*x[k] == x[i]+x[j]: flag = True; break\\n        return flag\\n        \\n    def beautifulArray(self, n: int) -> List[int]:\\n        for perm in permutations(range(1, n+1)):\\n            if not self.invalid(perm):\\n                return perm\\n```\n```\\nclass Solution:\\n    def recurse(self, nums):\\n        if len(nums) <= 2: return nums\\n        return self.recurse(nums[::2]) + self.recurse(nums[1::2])\\n    \\n    def beautifulArray(self, n: int) -> List[int]:\\n        return self.recurse([i for i in range(1, n+1)])\\n```\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return sorted(range(1, n+1), key=lambda x: bin(x)[:1:-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367891,
                "title": "python-o-n-solution-with-proof-explained",
                "content": "In this problem we have `n = 1000`, which is too big to use dfs/backtracking, so we need to find some pattern. We need to avoid structures like `i < k < j` with `nums[i] + nums[j] = 2 * nums[k]`, which means that `nums[i]` and `nums[j]` has the same parity: they are both odd or even. This lead us to the following idea: let us split all numbers into `2` groups: all **odd** numbers and then all **even** numbers.\\n\\n`[ odd numbers ] [ even numbers ]`\\n\\nThen if `i, j, k` lies in two different groups, we are OK, we will hever have forbidden pattern. Also, if we look at odd numbers, imagine `n = 12`, then we have `[1, 3, 5, 7, 9, 11]` and if we subtract `1` to each number and divide each number by `2` then we have  `[0, 1, 2, 3, 4, 5]`. Note, that is **linear** transform: when we did this transformation, if we did not have forbidden pattern, we still do not have it! So, what we need to do is to run function recursively for `odd` and `even` numbers and concatenate them.\\n\\n#### Complexity\\nFrom the first sight, time complexity is `O(n log n)`, because we have recursion `C(n) = C(n//2) + C((n+1)//2)`, which lead to `O(n log n)`. However it can be shown that it is `O(n)`. Imagine case `n = 105`, then we have `105 -> (52, 53) -> (26, 26, 27, 27) -> (13, 13, 13, 13, 14, 14, 14, 14)` and if we use memoisation, no need to solve problem each time for `13`, we can do it only once. On each level we will have at most **two** values in our recursion tree. Space complexity is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def beautifulArray(self, N):\\n        @lru_cache(None)\\n        def dfs(N):\\n            if N == 1: return (1,)\\n            t1 = dfs((N+1)//2)\\n            t2 = dfs(N//2)\\n            return [i*2-1 for i in t1] + [i*2 for i in t2]\\n        \\n        return dfs(N)\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```python\\nclass Solution:\\n    def beautifulArray(self, N):\\n        @lru_cache(None)\\n        def dfs(N):\\n            if N == 1: return (1,)\\n            t1 = dfs((N+1)//2)\\n            t2 = dfs(N//2)\\n            return [i*2-1 for i in t1] + [i*2 for i in t2]\\n        \\n        return dfs(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186901,
                "title": "javascript-how-i-understand-the-solution-with-verification-of-the-solution",
                "content": "### How I got the pattern by analysing the answer of input 100\\nI didn\\'t know how to solve this problem but I got the answer right by submitting and checking the right answer of input `100`. \\nYes I got lucky and got it right.\\nThe feedback answer was\\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61,3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63,2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62,4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\\nAnd after I analysed it, I find that it can be divided into two parts:\\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61,3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63]\\n[2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62,4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\\nAnd each part can be divided into two parts, and so on......\\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61]\\n[3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63]\\n[2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62]\\n[4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\\n```\\n......\\n```\\nAnd as you can see the pattern is pretty clear here. So I came up with the code below.\\n\\n### The Code\\n```\\nvar beautifulArray = function(N) {\\n    let arr=Array.from({length:N}, (x,i)=>i+1);\\n    return helper(arr);\\n\\n    function helper(arr){\\n    \\tif(arr.length===1) return arr;\\n    \\tlet o=[], e=[]; //odd index and even index\\n    \\tfor(let i=0; i<arr.length; i++){\\n    \\t\\tif(i%2===0) e.push(arr[i]);\\n    \\t\\telse o.push(arr[i]);\\n    \\t}\\n    \\treturn helper(e).concat(helper(o));\\n    }\\n};\\n```\\n\\n### The Why\\nWhy can this solution come up with a beautiful array? I tried to figure it out.\\nThe rule of a beautiful array is : `for every i < j, there is no k with i < k < j such that A[k] * 2 = A[i] + A[j].`\\nMeaning the **difference** between any `i` and `k` and `k` and `j` **can not be the same**.\\nSo how the above solution guarantees this?\\nFirst, by dividing the array into **odd** part and **even** part:\\n```\\n1,3,5,7,9..... | 2,4,6,8,10.....\\n```\\nIt guarantees that there is no such `j` for `i` and `k`:\\n```\\ni      k                j\\n-------------------------\\n1      2,4,6,8,10...\\n3      2,4,6,8,10...\\n5      2,4,6,8,10...\\n7      2,4,6,8,10...\\n9      2,4,6,8,10...\\n......\\n```\\nThen let\\'s see the first part (the second part will be similar):\\n```\\n1,3,5,7,9......\\n```\\nIt will be divided into two parts:\\n```\\n1,5,9,... | 3,7,11,...\\n```\\nAnd this time it guarantees that there is no such `j` for `i` and `k`:\\n```\\ni      k                j\\n--------------------------\\n1      3,7,11,...\\n5      3,7,11,...\\n9      3,7,11,...\\n......\\n```\\nAnd we continue this process until the length of the odd and even array reach 1, which means that there will be no `j` for any `i` and `k` ( for input 100):\\n```\\ni      k      j\\n----------------\\n1      65\\n......\\n```\\n### Conclusion\\nBecause by doing so we can always guarantee that:\\n1. there is no `j` in the **second part** for any `i` `k` in the **first part**, (this pattern I didn\\'t point it out above but it\\'s pretty clear)\\n2. there is no `j` for `i` in the **first part** and `k` in the **second part**, (this pattern is pointed out above)\\n3. the **second part** can always be transformed from the first part ( by adding one to all elements in the first part, which influence nothing), which means that it holds the same rule as the **first part**,\\n4. the **first part** is a beautiful array.\\n\\nwe can safely conclude that in this way we can always come up with a beautiful array.\\n\\n### PS\\nIt may be a little tricky to follow the thought.\\nIf you are still confused, try analysing the array of input 100.\\nBy dividing the array until its length reach 1, you\\'ll know why.",
                "solutionTags": [],
                "code": "```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61,3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63,2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62,4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61,3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63]\\n[2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62,4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\n```\\n[1,65,33,97,17,81,49,9,73,41,25,89,57,5,69,37,21,85,53,13,77,45,29,93,61]\\n[3,67,35,99,19,83,51,11,75,43,27,91,59,7,71,39,23,87,55,15,79,47,31,95,63]\\n[2,66,34,98,18,82,50,10,74,42,26,90,58,6,70,38,22,86,54,14,78,46,30,94,62]\\n[4,68,36,100,20,84,52,12,76,44,28,92,60,8,72,40,24,88,56,16,80,48,32,96,64]\\n```\n```\\n......\\n```\n```\\nvar beautifulArray = function(N) {\\n    let arr=Array.from({length:N}, (x,i)=>i+1);\\n    return helper(arr);\\n\\n    function helper(arr){\\n    \\tif(arr.length===1) return arr;\\n    \\tlet o=[], e=[]; //odd index and even index\\n    \\tfor(let i=0; i<arr.length; i++){\\n    \\t\\tif(i%2===0) e.push(arr[i]);\\n    \\t\\telse o.push(arr[i]);\\n    \\t}\\n    \\treturn helper(e).concat(helper(o));\\n    }\\n};\\n```\n```\\n1,3,5,7,9..... | 2,4,6,8,10.....\\n```\n```\\ni      k                j\\n-------------------------\\n1      2,4,6,8,10...\\n3      2,4,6,8,10...\\n5      2,4,6,8,10...\\n7      2,4,6,8,10...\\n9      2,4,6,8,10...\\n......\\n```\n```\\n1,3,5,7,9......\\n```\n```\\n1,5,9,... | 3,7,11,...\\n```\n```\\ni      k                j\\n--------------------------\\n1      3,7,11,...\\n5      3,7,11,...\\n9      3,7,11,...\\n......\\n```\n```\\ni      k      j\\n----------------\\n1      65\\n......\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1370870,
                "title": "java-break-up-every-arithmetic-sequence-with-visual-intuition",
                "content": "**Short algorithm:**\\n* On every step, split array in half by taking all odd-indexed elements in one half and even-indexed in another half. \\n* recursively repeat it with already split parts\\n* return any array of size 2 or less, because it is already beautifully arranged by definition\\n* combine the results of the recursive calls into one array and return it.\\n\\n**Some visual intuition:**\\n\\nWe\\'re basically splitting all possible arithmetic sequences of the original sequence. Arithmetic sequence is a sequence of numbers such that the difference between the consecutive terms is constant.\\n\\nLet\\'s take an example of `n = 15`:\\n![image](https://assets.leetcode.com/users/images/17363ba3-3bdb-4f08-9bb9-de4e4dc081cf_1627578554.3805828.png)\\n\\nNumbers in the original array form an arithmetic sequence with distance between elements equal to 1.\\n\\nIf you pick any start number, and then start counting from it at regular intervals, you will get yourself another arithmetic sequence with bigger intervals between elements.\\n\\nHere\\'s a bunch of arithmetic subsequences with distance 2:\\n![image](https://assets.leetcode.com/users/images/24f56eeb-680d-4471-aa4e-a8fba8fcda15_1627578918.2668414.png)\\n\\nHere\\'s arithmetic subsequences with distance 3:\\n![image](https://assets.leetcode.com/users/images/f008b8c8-f0c8-4e6e-a1d0-420fe85c5cc3_1627583177.4423501.png)\\n\\nAny arithmetic sequence in our output will be problematic. Here\\'s why. In the original arithmetic sequence, if you take any consequent three numbers, the beautiful condition will always be violated, and the doubled middle element will always be equal to the sum of its neighbours:\\n\\n![image](https://assets.leetcode.com/users/images/a5ba7916-6dad-4db4-931d-b61223d59761_1627579282.14404.png)\\nIt\\'s very easy to prove, take three elements: `n - 1`, `n`, `n + 1`\\nAnd you can see that the sum of the neighbours is `n - 1 + n + 1 = 2n` \\n\\nThe same holds on the larger scale:\\n![image](https://assets.leetcode.com/users/images/a7076ad8-f082-4116-89fd-eccdb3779bf3_1627579651.9805753.png)\\n\\nSimilarly easy to prove, take three elements: `n - a`, `n`, `n + a`\\nSum of the neighbours is `n - a + n + a = 2n`\\n\\nSo in case of `1`, `2,` `3`, it\\'s important that in our output 2 is never between `1` and `3`, so you can split these numbers into two groups, grouping up `1` and `3`:\\n![image](https://assets.leetcode.com/users/images/cbaec3c3-f872-4696-9e51-ebe73318bcd2_1627580260.6508982.png)\\n\\nSimilarly for bigger numbers, you never want the middle to be between two numbers that are at the same distance from it, so in case of 3 elements, you can group the equidistant elements up:\\n\\n![image](https://assets.leetcode.com/users/images/5b3e8e03-ccc8-427e-b2be-e6bfdf768bc8_1627580424.684246.png)\\n\\n**Visual example of how algorithm works:**\\n\\nNow let\\'s apply the algorithm described above to earlier example of `n = 15` and let\\'s look what happenes when we split array in half on each step by taking every other element:\\n\\n**Step 1:**\\n\\n![image](https://assets.leetcode.com/users/images/f8392c5d-ca94-425f-9b62-bd5ef5e89b4c_1627582766.3520532.png)\\n\\nWe split array into two subarrays, taking every other element.\\nNotice how left subarray is still forming an arithmetic subsequence, and right one is forming another one.\\n\\n**Step 2:**\\n![image](https://assets.leetcode.com/users/images/1b3b1b8d-6444-44f9-9875-6b8adc0f95c6_1627582818.6821275.png)\\nWe repeat the process for subarrays formed on the previous step.\\nSimilarly, each subarray is still anarithmetic subsequence with bigger distance than on the previous step, so those need to be split up.\\n\\n**Step 3:**\\n![image](https://assets.leetcode.com/users/images/18c228da-50ab-46cb-8763-a8568fa7483c_1627582851.741937.png)\\n\\nHere, each smaller array is of size 2 or less, so we can stop, since two elements are arranged beautifully by definition.\\nSo `1`, `9`, `5,` `13`, `3`, `11`, `7`, `15`, `2`, `10`, `6`, `14`, `4`, `12`, `8` is our final answer.\\n\\nIf you trace these formed groups back in the original array, you\\'ll have this picture:\\n![image](https://assets.leetcode.com/users/images/4406f5f6-890a-45f1-b6a5-c876e0c18a79_1627583022.382805.png)\\n\\nNotice how each pair has the same distance between each other, `9 - 1 = 8`, `10-2 = 8`, and so on. We\\'re basically splitting array into (n / 2) pairs of grouped elements, with equal distance between them.\\n\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n      \\n    public int[] beautifulArray(int n) {\\n        List<Integer> ordered = IntStream.rangeClosed(1, n).boxed().collect(Collectors.toList());\\n        return arrangeBeautifully(ordered).stream().mapToInt(it -> it).toArray();\\n    }\\n   \\n    private List<Integer> arrangeBeautifully(List<Integer> numbers) {\\n        // two numbers or less are already arranged\\n        if (numbers.size() <= 2) {\\n            return numbers;\\n        }\\n        \\n        // split into two lists by taking every other number. all odds indexes go left, all even indexes go right\\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        for (int i = 0; i < numbers.size(); ++i) {\\n            if (i % 2 == 0) {\\n                left.add(numbers.get(i));\\n            } else {\\n                right.add(numbers.get(i));\\n            }            \\n        }\\n        \\n        // arrange both halves recursively\\n        List<Integer> arrangedLeft = arrangeBeautifully(left);\\n        List<Integer> arrangedRight = arrangeBeautifully(right);\\n        \\n        // combine arranged halves into one list\\n        arrangedLeft.addAll(arrangedRight);\\n        return arrangedLeft;        \\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n      \\n    public int[] beautifulArray(int n) {\\n        List<Integer> ordered = IntStream.rangeClosed(1, n).boxed().collect(Collectors.toList());\\n        return arrangeBeautifully(ordered).stream().mapToInt(it -> it).toArray();\\n    }\\n   \\n    private List<Integer> arrangeBeautifully(List<Integer> numbers) {\\n        // two numbers or less are already arranged\\n        if (numbers.size() <= 2) {\\n            return numbers;\\n        }\\n        \\n        // split into two lists by taking every other number. all odds indexes go left, all even indexes go right\\n        List<Integer> left = new ArrayList<>();\\n        List<Integer> right = new ArrayList<>();\\n        for (int i = 0; i < numbers.size(); ++i) {\\n            if (i % 2 == 0) {\\n                left.add(numbers.get(i));\\n            } else {\\n                right.add(numbers.get(i));\\n            }            \\n        }\\n        \\n        // arrange both halves recursively\\n        List<Integer> arrangedLeft = arrangeBeautifully(left);\\n        List<Integer> arrangedRight = arrangeBeautifully(right);\\n        \\n        // combine arranged halves into one list\\n        arrangedLeft.addAll(arrangedRight);\\n        return arrangedLeft;        \\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367982,
                "title": "c-0ms-100-bit-sorting-with-comments",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Beautiful Array.\\nMemory Usage: 6.8 MB, less than 97.21% of C++ online submissions for Beautiful Array.\\n![image](https://assets.leetcode.com/users/images/bd208253-2d55-46f9-b7e3-0a2fd16665f5_1627465447.185023.png)\\n**note** we will have other right answer = {7, 11, 3, 13, 5, 9, 1, 6, 10, 2, 12, 4, 8}, because we sort strictly (for not equal bit position we give preference for bit \\'1\\'). We also can change condition in sorting comparator and we will have in answer firstly numbers with \\'0\\' in bit position. \\n\\n```\\nclass Solution {\\npublic:\\n  static bool comp(const int &a, const int &b){\\n    int mask = 1;\\n    while(true)\\n      if((a&mask) == (b&mask)) mask = mask<<1;\\n      else return (a&mask) > (b&mask); \\n  }\\n  \\n  vector<int> beautifulArray(int n) {\\n    vector<int> answer;\\n    while(n) answer.push_back(n--);\\n    \\n    sort(answer.begin(), answer.end(), comp);\\n    \\n    return answer;\\n  }\\n};\\n```\\n**p.s.** I think we also can find out \"sorting condition\" in bit operation for this bit problem.\\n\\n**and I done it :**\\nRuntime: 0 ms, faster than 100.00% of C++ online submissions for Beautiful Array.\\nMemory Usage: 6.8 MB, less than 93.03% of C++ online submissions for Beautiful Array.\\n```\\nclass Solution {\\npublic:\\n  static bool comp(const int &a, const int &b){\\n \\xA0 \\xA0int mask = (a^b); \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  //xOr for transform the same right most positions into \\'0\\'\\n    mask = mask & (-mask);             //fetch the most right \\'1\\'\\n    return a & mask;                     //check if the right most \\'1\\' is belonged a or b   \\n  }\\n  \\n  \\n  vector<int> beautifulArray(int n) {\\n    vector<int> answer;\\n    while(n) answer.push_back(n--);\\n    \\n    sort(answer.begin(), answer.end(), comp);\\n    \\n    return answer;\\n  }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  static bool comp(const int &a, const int &b){\\n    int mask = 1;\\n    while(true)\\n      if((a&mask) == (b&mask)) mask = mask<<1;\\n      else return (a&mask) > (b&mask); \\n  }\\n  \\n  vector<int> beautifulArray(int n) {\\n    vector<int> answer;\\n    while(n) answer.push_back(n--);\\n    \\n    sort(answer.begin(), answer.end(), comp);\\n    \\n    return answer;\\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  static bool comp(const int &a, const int &b){\\n \\xA0 \\xA0int mask = (a^b); \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0  //xOr for transform the same right most positions into \\'0\\'\\n    mask = mask & (-mask);             //fetch the most right \\'1\\'\\n    return a & mask;                     //check if the right most \\'1\\' is belonged a or b   \\n  }\\n  \\n  \\n  vector<int> beautifulArray(int n) {\\n    vector<int> answer;\\n    while(n) answer.push_back(n--);\\n    \\n    sort(answer.begin(), answer.end(), comp);\\n    \\n    return answer;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186727,
                "title": "leetcode-weekly-contest-108-screencast-only-record-10-mins",
                "content": "I record the screencast on Windows with a trial version of Bandicam, didn't realize only the first 10 mins is recorded...\n\nHope next time, I won't screw it up.\n\nhttps://www.youtube.com/watch?v=X3sYZBBviY8",
                "solutionTags": [],
                "code": "https://www.youtube.com/watch?v=X3sYZBBviY8",
                "codeTag": "Unknown"
            },
            {
                "id": 186661,
                "title": "3-solutions-4-lines-in-python-divide-conquer-dp-top-down-and-bottom-up",
                "content": "**Divide and Conquer:**\\n\\nDivide and conquer strategy:\\n  l gives beautiful array of even numbers\\n\\tr gives beautiful array of odd numbers\\n```\\ndef beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N==1: return [1]\\n\\tl=self.beautifulArray(N//2)\\n\\tr=self.beautifulArray(N-N//2)\\n\\treturn [x*2 for x in l]+[x*2-1 for x in r]\\n```\\nYou can optimize this by having only 1 recrusive call :\\n```\\ndef beautifulArray(self, N):\\n        if N == 1: return [1]\\n        half = self.beautifulArray(N - N / 2)\\n        return [i * 2 - 1 for i in half] + [i * 2 for i in half if i * 2 <= N]\\n```\\nThanks [@lee215](https://leetcode.com/lee215/) for suggesting this.\\n\\n**Top-Down DP (memoization):**\\n\\nYou can see overallping subproblems if you draw recursion tree, hence you can use memoization:\\n```\\n\\nclass Solution:\\n    memo = {}\\n    def beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N==1: return [1]\\n        if N in self.memo: return self.memo[N]\\n        l=self.beautifulArray(N//2)\\n        r=self.beautifulArray(N-N//2)\\n        self.memo[N] = [x*2 for x in l]+[x*2-1 for x in r]\\n        return self.memo[N]\\n```\\n\\n**DP (bottom up):**\\nYou construct the tree in bottom up manner:\\n\\n```\\ndef beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dp = {}\\n        dp[1] = [1]\\n        for i in range(2,N+1):\\n            dp[i] = [x*2 for x in dp[i//2]] + [x*2-1 for x in dp[i-i//2]]\\n        \\n        return dp[N]\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N==1: return [1]\\n\\tl=self.beautifulArray(N//2)\\n\\tr=self.beautifulArray(N-N//2)\\n\\treturn [x*2 for x in l]+[x*2-1 for x in r]\\n```\n```\\ndef beautifulArray(self, N):\\n        if N == 1: return [1]\\n        half = self.beautifulArray(N - N / 2)\\n        return [i * 2 - 1 for i in half] + [i * 2 for i in half if i * 2 <= N]\\n```\n```\\n\\nclass Solution:\\n    memo = {}\\n    def beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N==1: return [1]\\n        if N in self.memo: return self.memo[N]\\n        l=self.beautifulArray(N//2)\\n        r=self.beautifulArray(N-N//2)\\n        self.memo[N] = [x*2 for x in l]+[x*2-1 for x in r]\\n        return self.memo[N]\\n```\n```\\ndef beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        dp = {}\\n        dp[1] = [1]\\n        for i in range(2,N+1):\\n            dp[i] = [x*2 for x in dp[i//2]] + [x*2-1 for x in dp[i-i//2]]\\n        \\n        return dp[N]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367779,
                "title": "beautiful-array-easy-clean-w-2-approach",
                "content": "# **APPROACH 1:**\\n* **Iterative/sorting-**\\n![Meaning Of Using Bits](https://assets.leetcode.com/users/images/8a56cda7-5496-49b8-89be-2eae3e4ad95b_1627456380.537388.png)\\n\\n\\n```\\nvector<int> beautifulArray(int n) \\n{\\n\\tvector<int> ans(n);\\n\\tiota(begin(out), end(out), 1);\\n\\tsort(begin(out), end(out), [](auto & x, auto & y){ return -(x^y)&x&~y; });\\n\\treturn ans;  \\n}\\n```\\n**Time Complexity: O(NlogN)\\nSpace Complexity: O(1)**\\n\\n\\n\\n# **APPROACH 2:**\\n**ALGORITHM:**\\n* Create a vector called ans, insert 1 into ans\\n* While size of ans < N\\n\\t* create a vector temp\\n\\t* for i in range 0 to size of ans \\u2013 1 \\n\\t\\t* if ans[i] * 2 \\u2013 1 <= N, then insert ans[i] * 2 \\u2013 1 into temp array \\n\\t* for i in range 0 to size of ans \\u2013 1\\n\\t\\t* if ans[i] * 2 <= N, then insert ans[i] * 2 into temp array\\n\\t* set ans := temp\\n* return ans\\n\\n**SOLUTION:**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans ;\\n        ans.push_back(1) ;\\n        while(ans.size() < n)\\n        {\\n            vector<int> temp ;\\n            for(auto i:ans)\\n            {\\n                if(i*2 - 1 <= n)\\n                {\\n                    temp.push_back(i*2 - 1) ;\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(i*2 <= n)\\n                {\\n                    temp.push_back(i*2) ;\\n                }\\n            }\\n            ans = temp ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nvector<int> beautifulArray(int n) \\n{\\n\\tvector<int> ans(n);\\n\\tiota(begin(out), end(out), 1);\\n\\tsort(begin(out), end(out), [](auto & x, auto & y){ return -(x^y)&x&~y; });\\n\\treturn ans;  \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans ;\\n        ans.push_back(1) ;\\n        while(ans.size() < n)\\n        {\\n            vector<int> temp ;\\n            for(auto i:ans)\\n            {\\n                if(i*2 - 1 <= n)\\n                {\\n                    temp.push_back(i*2 - 1) ;\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(i*2 <= n)\\n                {\\n                    temp.push_back(i*2) ;\\n                }\\n            }\\n            ans = temp ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186660,
                "title": "python-recursion",
                "content": "\\n\\nExample:\\n1,2,3,4,5,6,7,8,9\\n-->\\n1,3,5,7,9,2,4,6,8\\n-->\\n1,5,9,3,7,2,6,4,8\\n-->\\n1,9,5,3,7,2,6,4,8\\n```\\nclass Solution(object):\\n    def beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        return self.helper(range(1,N+1))\\n        \\n    def helper(self, lst):\\n        if len(lst)<=2:         return lst\\n        return self.helper(lst[::2]) + self.helper(lst[1::2])\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def beautifulArray(self, N):\\n        \"\"\"\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        return self.helper(range(1,N+1))\\n        \\n    def helper(self, lst):\\n        if len(lst)<=2:         return lst\\n        return self.helper(lst[::2]) + self.helper(lst[1::2])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 644612,
                "title": "python3-solution-with-detailed-explanation-beautiful-array",
                "content": "First, divide the array into even numbers and odd numbers so that we only need to further arrange numbers within even or odd numbers themselves because nums[i] and nums[j] must be both even or odd and can\\'t be one even and one old. \\n\\nThen, further divide each division into numbers at even indices and odd indices till the division length is either 1 or 2 at which time just return the division. This works the same way as the first step, because if you divide all even numbers by 2, you will have even and odd number again, e.g. `[2,4,6,8,10] -> [1,2,3,4,5]`. If you add odd numbers by 1 and divide by 2, you will also have even and odd numbers, e.g. `[1,3,5,7,9] -> [2,4,6,8,10] -> [1,2,3,4,5]`.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        nums = list(range(1, N+1))\\n        \\n        def helper(nums) -> List[int]:\\n            if len(nums) < 3:\\n                return nums\\n            even = nums[::2]\\n            odd = nums[1::2]\\n            return helper(even) + helper(old)\\n        return helper(nums)   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        nums = list(range(1, N+1))\\n        \\n        def helper(nums) -> List[int]:\\n            if len(nums) < 3:\\n                return nums\\n            even = nums[::2]\\n            odd = nums[1::2]\\n            return helper(even) + helper(old)\\n        return helper(nums)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 371380,
                "title": "c-separate-odd-index-with-even-index",
                "content": "Different with the most voted solution, I generate the permutaion in the begining. \\n```\\nint S* = {1,2,3,4,5,6,7,8}\\n```\\nObviously, it\\'s not a beautiful array, let\\'s make it a beautiful one.\\nMy intuition is: sifting all possible  A[k] out until it\\'s beautiful.\\n\\nI extract the elements with even index(i.e. 0,2,4...) to the front of subarray while the odd to the back of subarray. Like\\n```\\nint A* = {1,3,5,7};\\nint B* = {2,4,6,8};\\n//update S\\nS= {1,3,5,7,2,4,6,8};\\n```\\nBut in subarray itself, it\\'s still not beautiful, let\\'s look at left subarray.\\n```\\nint * A = {1,3,5,7} \\n2*A[1] = A[0] * A[2]; //broke the rule\\n```\\nSo let\\'s do the same thing for this subarray, move elements with even index forward, while the odd backward.\\n```\\n//update A\\nA = {1,5,3,7}\\n```\\nKeep dividing until the array size <= 2,  then all the possible A[k] are separted with A[i], A[j].\\n//Talk is cheap, here is the code:)\\n```\\n    vector<int> beautifulArray(int N) {\\n        vector<int> S;\\n        for (int i = 1; i <= N; ++i) {\\n            S.push_back(i);\\n        }\\n        divide(S, 0, N - 1);\\n        return S;\\n    }\\n    \\n    void divide(vector<int>& S, int l, int r) {\\n        if (r - l <= 1) return;\\n        vector<int> odd, even;\\n        for (int i = l; i <= r; ++i) {\\n            if ((i + 1 - l) & 1) { //using relative index\\n                odd.push_back(S[i]);\\n            } else {\\n                even.push_back(S[i]);\\n            }\\n        }\\n        std::copy(odd.begin(), odd.end(), S.begin() + l);\\n        std::copy(even.begin(), even.end(), S.begin() + l + odd.size());\\n        int m = (r - l) / 2 + l;\\n        divide(S, l, m);\\n        divide(S, m + 1, r);\\n    }\\n```\\nT(N) = 2(T/2) + O(N)\\naccording to master theorem\\uFF0C T(N) = O(NlogN)",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\nint S* = {1,2,3,4,5,6,7,8}\\n```\n```\\nint A* = {1,3,5,7};\\nint B* = {2,4,6,8};\\n//update S\\nS= {1,3,5,7,2,4,6,8};\\n```\n```\\nint * A = {1,3,5,7} \\n2*A[1] = A[0] * A[2]; //broke the rule\\n```\n```\\n//update A\\nA = {1,5,3,7}\\n```\n```\\n    vector<int> beautifulArray(int N) {\\n        vector<int> S;\\n        for (int i = 1; i <= N; ++i) {\\n            S.push_back(i);\\n        }\\n        divide(S, 0, N - 1);\\n        return S;\\n    }\\n    \\n    void divide(vector<int>& S, int l, int r) {\\n        if (r - l <= 1) return;\\n        vector<int> odd, even;\\n        for (int i = l; i <= r; ++i) {\\n            if ((i + 1 - l) & 1) { //using relative index\\n                odd.push_back(S[i]);\\n            } else {\\n                even.push_back(S[i]);\\n            }\\n        }\\n        std::copy(odd.begin(), odd.end(), S.begin() + l);\\n        std::copy(even.begin(), even.end(), S.begin() + l + odd.size());\\n        int m = (r - l) / 2 + l;\\n        divide(S, l, m);\\n        divide(S, m + 1, r);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1373064,
                "title": "java-clear-thinking-process-divide-and-conquer",
                "content": "I did not solve the problem first. And I was also confused by looking at the official solutions. Here are my thinking process of how I finally got to understand it.\\n\\nBefore getting into the algorithmn, there are some observations we can make on a normal array with elements {1, 2, ... n}:\\n1. \\tThe only condition here is `2*nums[k] = nums[i] + nums[j] (i < k < j)`. If we know what nums[k] is, how can we make this equation true? The only way to achieve this equation is when nums[k] is the midpoint of the nums[i] and nums[j]. With math, it is simple to prove: 2*nums[k] = nums[i] + nums[j] --> nums[k] - nums[i] = nums[j] - nums[k] (nums[i] < nums[k] < nums[j] since we are on the normal array right now) Therefore, **to avoid making this equation true, we have to choose two values that each has a different distance from the other to nums[k], from each of the two sides of nums[k].**\\n2. \\t Based on observation 1, if we think further, if nums[i] and nums[j] both have equal distance to nums[k], nums[i] and nums[j] must be both odd or both even numbers, in a normal array (This is the start of the approach).\\n\\nTo conclude, in order to find a beautiful array, we need to rearrange each element so that whenever we choose an element as nums[k], **we cannot find any two elements nums[i] and nums[j] from each side with equal distance**. How are we going to do this? \\n\\nObservation 2 already gives part of the answer. We know for sure that nums[i] and nums[j] must have same distance from nums[k]. In this normal array, the interval between each element is 1. (1+1* 0, 1+1* 1, 1+1* 2, ... ) Therefore, the difference bewteen nums[k] to nums[i] and nums[j] has to be 1 * \"something\" (1 is the interval here). The only two results will be: it suffices the equation--the difference is the same; or it doesn\\'t fit--the difference is different. Now, what is one thing or the **property of natural numbers** that can categorize the \"something\" part of the interval into 2 groups so that we immediately know the number (nums[i]) we pick in that group will not have the same distance as the other number (nums[j]) we pick in the other part? \\n\\nEven and Odd! Since even numbers are always different, or to be speficic, 1 unit (This is the interval right now in the array, This is important for explanation later!) different from odd numbers. (Keep in mind that the even and odd here is the \"something\" part mentioned above, not the values in the array) So if we pick nums[i] from a bunch of odd numbers, we know for sure that if nums[j] is even (or different from nums[i], to be general), it is never going to fit the condition. \\n\\nHowever, if nums[i], and nums[j] are both odd or even, it still suffices the equation. How can we prevent this from happening?\\nRemember, there is another constraint hidden in the statement, that is i and j (the indices) has to be on the two sides of k. If we can put all odd numbers on one side and all even numbers on the other side of the array, we can make sure that if k (the index) is on the even side, if nums[i] or nums[j] is chosen among the odd numbers, it will not work because in that case nums[i] and nums[j] has both to be in the odd side, which is both on the left side of nums[k]. (If we put odd nums on the left and even nums on the right, see example below later)\\n\\nBut think about the statement above, \"if k (the index) is on the even side, nums[i] or nums[j] chosen among the odd numbers won\\'t work\", there is an extra case we didn\\'t address, that is if nums[i], nums[j] and nums[k] are all on the odd side or even side, it will still work. However, that leads us to a smaller version of the original problem on the normal array, where elements are no longer `1, 2, ... n` , but `1, 3, 5, 7...` or `2, 4, 6, 8 ...`.\\n\\nNow, which algorithmn allows us to break a large problem into smaller solvable problems while we need to keep cactegorizing and dividing the 2 groups of numbers?\\n\\n### **Divide and Conquer**\\n\\nThe algorithmn is already quite clear now:\\n1. construct a normal array\\n2. divide the array into 2 groups\\n3. put the one group of numbers all on the left and the other on the right\\n4. repeat steps 2 and 3\\n\\nWe only need to specify step 2 here. In above, we stopped after having the array with `1, 3, 5, 7... 2, 4, 6, 8...`. And now we need to make the equation wrong even when nums[i] and nums[j]  and nums[k] are all on one side. \\n\\nThe idea of interval becomes clear now. if we only look at the subarray on the left, which is `1, 3, 5, 7...`, we notice that every number still maintain equal distance with adjacent one, that is, (1+2* 0, 1+2* 1, 1+2* 2 ...). Same for the even numbers.\\nHere, the interval turns into 2 instead of 1. But the key doesn\\'t change, if have nums[i] even number of units away from nums[k], nums[j] has also to be an even number of units away from nums[k]. \"Units\" here is exactly the interval, which is 2 now, and 1 before. Similarly we can categorize these odd numbers into two groups, one contains numbers that have even number of intervals from each adjacent element, the other has numbers with odd number of intervals from each adjacent one.  Now whenever we choose nums[k] in one the two groups, nums[i] and nums[j] has to be at least both from one of the groups, which comes back to the same situation above, never gonna fit in the equation!\\n\\nHere is an example with `n=10`:\\n1. Creating original array \\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\\n2. First grouping\\n[1, 3, 5, 7, 9, 2, 4, 6, 8, 10]\\nLeft:\\n3. Group the left\\n[1, 5, 9, 3, 7...\\n4. Group the left from step 3\\n[1. 9, 5...\\n5. Group the right from step 3\\n[... 3, 7...\\nRight:\\n6. Group the right\\n... 2, 6, 10, 4, 8]\\n7. Group the left from step 6\\n... 2, 10, 6 ...]\\n8. Group the right from step 6\\n... 4, 8]\\n\\nFinal result:\\n[1, 9, 5, 3, 7, 2, 10, 6, 4, 8]\\n\\nThe steps above are described in a recursive structure. The implementation is below:\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int[] ans = new int[n];\\n        for(int i = 0; i  < n; i++){\\n            ans[i] = i+1;\\n        }\\n        recursion(ans, 0, n-1);\\n        return ans;\\n    }\\n    \\n    public void recursion(int[] arr, int left, int right){\\n        if(left >= right)\\n            return;\\n        ArrayList<Integer> l = new ArrayList<>();\\n        ArrayList<Integer> r = new ArrayList<>();\\n\\t\\t\\n        boolean alt = true;// Not worry about whether the factor of the interval is even or odd too much, they can be grouped by \\n\\t\\t\\t\\t\\t\\t\\t// just picking one and skip one\\n\\t\\t\\t\\t\\t\\t\\t\\n        for(int i = left; i <= right; i++){ // picking the elements and put them into the two groups\\n            if(alt)\\n                l.add(arr[i]);\\n            else\\n                r.add(arr[i]);\\n            alt = !alt;\\n        }\\n\\n        for(int i = left; i <= right; i++){ // merging them into the final array\\n            if(!l.isEmpty())\\n                arr[i] = l.remove(0);\\n            else\\n                arr[i] = r.remove(0);\\n        }\\n        recursion(arr, left, (right+left)/2);\\n        recursion(arr, (left+right)/2+1, right);\\n    }\\n}\\n```\\n\\nMay not be the fastest, but hope to be the easiest to understand!\\nAnd this is my first time posting, please tell me if anything didn\\'t explain well!",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int[] ans = new int[n];\\n        for(int i = 0; i  < n; i++){\\n            ans[i] = i+1;\\n        }\\n        recursion(ans, 0, n-1);\\n        return ans;\\n    }\\n    \\n    public void recursion(int[] arr, int left, int right){\\n        if(left >= right)\\n            return;\\n        ArrayList<Integer> l = new ArrayList<>();\\n        ArrayList<Integer> r = new ArrayList<>();\\n\\t\\t\\n        boolean alt = true;// Not worry about whether the factor of the interval is even or odd too much, they can be grouped by \\n\\t\\t\\t\\t\\t\\t\\t// just picking one and skip one\\n\\t\\t\\t\\t\\t\\t\\t\\n        for(int i = left; i <= right; i++){ // picking the elements and put them into the two groups\\n            if(alt)\\n                l.add(arr[i]);\\n            else\\n                r.add(arr[i]);\\n            alt = !alt;\\n        }\\n\\n        for(int i = left; i <= right; i++){ // merging them into the final array\\n            if(!l.isEmpty())\\n                arr[i] = l.remove(0);\\n            else\\n                arr[i] = r.remove(0);\\n        }\\n        recursion(arr, left, (right+left)/2);\\n        recursion(arr, (left+right)/2+1, right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189066,
                "title": "a-concise-python-recursive-solution-with-explanation-o-n",
                "content": "```python\\nclass Solution:\\n\\t def beautifulArray(self, N):\\n        \"\"\"\\n        If we have a beautiful array A, then it means for any i < k < j. A[k] * 2 != A[i] + A[j]. Let\\'s add x to all\\n        elements of beautiful array. In that case (A[k] + x) * 2 != A[i] + x + A[j] + x => A[k] * 2 + 2x != A[i] + A[j] + 2x =>\\n        A[k] * 2 != A[i] + A[j]. Which proves that, adding same number to beatiful array doesn\\'t make it ugly.\\n        \\n        Now let\\'s multiply x with all numbers in beautiful array. (A[k] * 2) * x != A[i] * x + A[j] * x =>\\n        (A[k] * 2) * x != (A[i] + A[j]) * x => A[k] * 2 != A[i] + A[j]. Which proves that multiplying some number to \\n        beautiful array doesn\\'t make it ugly. If we delete some number from beautiful array, it\\'ll not make it ugly\\n        i.e. A[k] * 2 != A[i] + A[j] we can prove it by intuition.\\n        \\n        So If we want to know the beautiful array with element [1, N] and we already known the beautiful array for [1, N/2],\\n        We can multiply all elements of that array by 2, and we\\'ll get a new beautiful array with all even numbers from b/w\\n        [1, N] and if we subtract 1 from each element of this new even beauiful array, we get a new beautiful array with\\n        all odd elements b/w [1, N]. Now we got two beautiful arrays one has all odd elements and other has all even elements.\\n        Now we know that for beautiful array A[k] * 2 != A[i] + A[j]. If A[i] and A[j] have different partiy (one is odd and\\n        other is even) then their sum would be odd always and A[k] * 2 != A[i] + A[j] condition will always met as left side of\\n        the condition is even so for right side of the condition to be even both A[i] and A[j] shoud have same parity. It means\\n        that if we simply concatenate two beautiful arrays with even and odd elements, the new aray would still be beautiful.\\n        \\n        One Last observation is what if N is odd then it\\'s not divisible by 2. We can simply add 1 to it and make it even\\n        to find beautiful array for [1, N + 1] and once we find it, we can simply remove N + 1 from answer. \\n        \\n        In each function call, we are taking half of the elements so depth of recursion or total funcion calls would be O(LogN)\\n        and in each execution, O(N / k) process would be done. So in first call, O(N) work would be done in pre-processing\\n        and concatenation, in second, call O(N / 2), in third O(N / 4) and so on. If we add all these processing times then\\n        using geometric series Sum would be O(2N) = O(N) so runtime is O(N) and Memory complexity is O(N).\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N == 1: return [1]\\n        b_array = self.beautifulArray((N if N % 2 == 0 else N + 1) // 2)\\n        return filter(lambda x: x != N + 1, map(lambda x: 2 * x, b_array) + map(lambda x: 2 * x - 1, b_array))\\n\\t\\t\\t\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n\\t def beautifulArray(self, N):\\n        \"\"\"\\n        If we have a beautiful array A, then it means for any i < k < j. A[k] * 2 != A[i] + A[j]. Let\\'s add x to all\\n        elements of beautiful array. In that case (A[k] + x) * 2 != A[i] + x + A[j] + x => A[k] * 2 + 2x != A[i] + A[j] + 2x =>\\n        A[k] * 2 != A[i] + A[j]. Which proves that, adding same number to beatiful array doesn\\'t make it ugly.\\n        \\n        Now let\\'s multiply x with all numbers in beautiful array. (A[k] * 2) * x != A[i] * x + A[j] * x =>\\n        (A[k] * 2) * x != (A[i] + A[j]) * x => A[k] * 2 != A[i] + A[j]. Which proves that multiplying some number to \\n        beautiful array doesn\\'t make it ugly. If we delete some number from beautiful array, it\\'ll not make it ugly\\n        i.e. A[k] * 2 != A[i] + A[j] we can prove it by intuition.\\n        \\n        So If we want to know the beautiful array with element [1, N] and we already known the beautiful array for [1, N/2],\\n        We can multiply all elements of that array by 2, and we\\'ll get a new beautiful array with all even numbers from b/w\\n        [1, N] and if we subtract 1 from each element of this new even beauiful array, we get a new beautiful array with\\n        all odd elements b/w [1, N]. Now we got two beautiful arrays one has all odd elements and other has all even elements.\\n        Now we know that for beautiful array A[k] * 2 != A[i] + A[j]. If A[i] and A[j] have different partiy (one is odd and\\n        other is even) then their sum would be odd always and A[k] * 2 != A[i] + A[j] condition will always met as left side of\\n        the condition is even so for right side of the condition to be even both A[i] and A[j] shoud have same parity. It means\\n        that if we simply concatenate two beautiful arrays with even and odd elements, the new aray would still be beautiful.\\n        \\n        One Last observation is what if N is odd then it\\'s not divisible by 2. We can simply add 1 to it and make it even\\n        to find beautiful array for [1, N + 1] and once we find it, we can simply remove N + 1 from answer. \\n        \\n        In each function call, we are taking half of the elements so depth of recursion or total funcion calls would be O(LogN)\\n        and in each execution, O(N / k) process would be done. So in first call, O(N) work would be done in pre-processing\\n        and concatenation, in second, call O(N / 2), in third O(N / 4) and so on. If we add all these processing times then\\n        using geometric series Sum would be O(2N) = O(N) so runtime is O(N) and Memory complexity is O(N).\\n        :type N: int\\n        :rtype: List[int]\\n        \"\"\"\\n        if N == 1: return [1]\\n        b_array = self.beautifulArray((N if N % 2 == 0 else N + 1) // 2)\\n        return filter(lambda x: x != N + 1, map(lambda x: 2 * x, b_array) + map(lambda x: 2 * x - 1, b_array))\\n\\t\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1192798,
                "title": "4-liner",
                "content": "**Iterative/sorting**\\n**time: `O(NlogN)`, space: `O(1)`**\\n```\\nvector<int> beautifulArray(int n) \\n{\\n\\tvector<int> out(n);\\n\\tiota(begin(out), end(out), 1);\\n\\tsort(begin(out), end(out), [](auto & x, auto & y){ return -(x^y)&x&~y; });\\n\\treturn out;  \\n}\\n```\\n**Divide and conquer**\\n\\nFirst populate the array with numbers `1...N`. Now we need to rearrange the numbers in the array to make it beautiful.\\nThe logic is simple: in order `A[k]*2=A[i]+A[j] i<k<j` to hold we need `A[i]` and `A[j]` to have the same parity. So if you place all odd elements prior to all even elements you *divide* your problem *\"reposition elements in the array so that `A[k]*2\\u2260A[i]+A[j]`\"* into two \"nonoverlapping\" subproblems: \\n* *reposition elements in the contiguous \"odd subarray\" so that `A[k]*2\\u2260A[i]+A[j]`*;\\n* *reposition elements in the contiguous \"even subarray\" so that `A[k]*2\\u2260A[i]+A[j]`*.\\n\\n![image](https://assets.leetcode.com/users/images/6c2524a0-a463-4f6f-867a-0e166a34ccd7_1620233440.041865.png)\\n<br>\\n\\nNote that you\\'ve segregated the numbers based on the question *\"Do elements have the same remainder modulo `2`?\"*\\nYou can do the same using custom sorting so that odd elements are less than even. \\nThe next question will be `\"Do even/odd elements have the same remainder modulo `4`?\" etc...\\n\\n**Sorting**\\n\\nYou can do all segregating of the elements via sorting procedure.\\nComparison of elements should be based on their remainder modulo `1/2^i` \\u2014 binary digits of numbers `1..N`.\\nThe comparison lambda could be written in few ways and its work is equivalent to the following.\\n\\n> Travese binary digits from **right** to **left** untill `x` and `y` have **different** digits. \\nIf this digit is `1` for `x` and `0` for `y` then `x` is smaller, otherwise `y` is smaller.\\n\\n> Here\\'s another explanation. Let `x` has binary representation `\"00010101001000\"` and `y` - `\"00001011011000\"`.\\nYou can get the lambda\\'s result if you reverse these strings and `return` `reverse(\"00010101001000\") > reverse(\"00001011011000\")` \\n(**lexicographical order** of reversed strings that represent binary representation of numbers).\\n\\nMy lambda does exactly this but using bitwise magic. `-(x^y)` finds the first mismatching digit from the right (leaving some \"garbage\" to the left of it). Then you `&` it with `x` and `~y`. This deletes the \"gardage\" and returns `true` if `x` has `1` on the `first_from_the_right_mismatching_spot` and `y` has `0` on the same spot (and return `false` otherwise).\\n<br>\\n\\n![image](https://assets.leetcode.com/users/images/26ad4531-fa92-4553-9935-6aa0518cdaa0_1620226589.684505.png)\\n\\n<br>\\n\\n**Final note**: There exists a more efficient linear time solution based on the same idea. Check out the [post](https://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N)) by Lee for this solution.\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> beautifulArray(int n) \\n{\\n\\tvector<int> out(n);\\n\\tiota(begin(out), end(out), 1);\\n\\tsort(begin(out), end(out), [](auto & x, auto & y){ return -(x^y)&x&~y; });\\n\\treturn out;  \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368347,
                "title": "recursive-java-solution-with-explanation",
                "content": "First of all, I want to explane why it works:\\n- the formula that defines a \"beautiful\" array is arr[k]***2** != arr[i]+arr[j] and it contains a doubling. It means that if arr[i] is odd and arr[j] is even, or vice versa, the formula won\\'t work. It means that if we put all odd elements in the left part of an array and all the even elements in the right, we should only be sure that an odd part is \"beautiful\" and an even part is \"beautiful\". If so, together they also are \"beautiful\".\\n- an array with n elements contains (n+1)/2 odd elements and n/2 even elements.\\n - If there is a \"beautiful\" array and we multiply every element of this array, it will still be \"beautiful\" because the formula above is linear. What I want to say is that\\n ```\\n [1,3,2] is \"beautiful\".\\n ```\\n If we double it, it still will be \"beautiful\" and all the elements will be **even**\\n ```\\n [1,3,2]*2 => [2,6,4]\\n ```\\n If we after doubling decrease 1, the array will also be \"beautiful\", but all the elements will be **odd**\\n \\n ```\\n  ([1,3,2]*2)-1 => [1,5,3]\\n ```\\n \\n Using the ideas above, it\\'s possible to conclude that it\\'s enough to break recursively the base array[n]. Than turn a \"beautiful\" subarray into the array of odd numbers and concatenate a \"beautiful\" subarray that was turned into an array of even numbers. And that\\'s it.\\n \\n The solution in Java:\\n\\n```\\n\\nclass Solution {\\n    Map<Integer,int[]> cache;\\n    public int[] beautifulArray(int n) {\\n        if (cache==null) cache = new HashMap();\\n        if (cache.containsKey(n)) return cache.get(n); //Beautiful array of this length already was created. Just get it from cache.\\n        \\n        int[] arr = new int[n];\\n        if (n==1){\\n            arr[0]=1;\\n        }else{\\n            int[] oddArr = beautifulArray((n+1)/2); //Beautiful subarray with a length as a number of odd elements in the current array;\\n            int[] evenArr = beautifulArray((n)/2);//The same for even numbers\\n            int j=0;\\n            for (int i=0; i<oddArr.length; i++){\\n                arr[j]=oddArr[i]*2-1;\\n                j++;\\n            }\\n            for (int i=0; i<evenArr.length; i++){\\n                arr[j]=evenArr[i]*2;\\n                j++;\\n            }\\n        }\\n        cache.put(n,arr);\\n        return arr;\\n    }    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n [1,3,2] is \"beautiful\".\\n ```\n```\\n [1,3,2]*2 => [2,6,4]\\n ```\n```\\n  ([1,3,2]*2)-1 => [1,5,3]\\n ```\n```\\n\\nclass Solution {\\n    Map<Integer,int[]> cache;\\n    public int[] beautifulArray(int n) {\\n        if (cache==null) cache = new HashMap();\\n        if (cache.containsKey(n)) return cache.get(n); //Beautiful array of this length already was created. Just get it from cache.\\n        \\n        int[] arr = new int[n];\\n        if (n==1){\\n            arr[0]=1;\\n        }else{\\n            int[] oddArr = beautifulArray((n+1)/2); //Beautiful subarray with a length as a number of odd elements in the current array;\\n            int[] evenArr = beautifulArray((n)/2);//The same for even numbers\\n            int j=0;\\n            for (int i=0; i<oddArr.length; i++){\\n                arr[j]=oddArr[i]*2-1;\\n                j++;\\n            }\\n            for (int i=0; i<evenArr.length; i++){\\n                arr[j]=evenArr[i]*2;\\n                j++;\\n            }\\n        }\\n        cache.put(n,arr);\\n        return arr;\\n    }    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 905426,
                "title": "python3-o-nlogn-solution-without-mathematical-skills",
                "content": "Seriously, this question should be categorized as hard to those who have no experience of ACM, such like me.\\nhowever, there still is a way to come across the solution **without mathematical intuition and reasoning skills**, which needs a pen and  a paper, of coz, and a little bit observation.\\n\\nFirst, it is not hard to figure out that,\\n**odd + even = odd != 2 * x**\\nso devide the array from 1 to N into two parts (take N=10 as example),\\n*1 3 5 7 9 | 2 4 6 8 10*\\nthen the question becomes how to make the left or the right be \"beautiful array\". \\nlook at the right part that includes even numbers, here the pen and paper are in need.\\nsay we have *2 ,4*, where should we put 6? apprently not the right most position, while the left most slot is ok, so we get *6, 2, 4*.\\nlikewisely, we get *6, 2, 4, 8*, and it is beautiful too. Given this, it seems that we can rebuild the left part spirally, but can it work always?\\nUnfortunately, the answer is no. *10, 6, 2, 4, 8* is not beautiful. \\nhere comes the **KEY** -- if we splitted the spiral array into two parts and rebuild each part spirally again, we got two beautiful arrays,\\n*10 2 6 | 4 8*, **AND**, any number in the sub left plus any number in the sub right is a double of **odd**, while all numbers in this array are **even**.\\nbut are we to the end? *18 10 2 6 14* is not beautiful once more. so split and rebuild, *18 2 10 | 6 14*, **(left x + right y) / 2 is not in the array itself**.\\nit can be easily verified that all the above steps are also feasible on original odd subarrays.\\nhaving gone so far, it is not difficult to think of **devide and conquer** and **recursion**, and **TRY**.\\nso here comes the naive recursion solution,\\n```\\ndef beautifulArray(self, N: int) -> List[int]:\\n        def _split(arr):\\n            if len(arr) <= 2:\\n                return arr\\n            odd, even = [], []\\n            for i, n in enumerate(arr):\\n                if i % 2: even.append(n)\\n                else: odd.append(n)\\n            return _split(odd) + _split(even)\\n\\n        return _split([i for i in range(1, N + 1)])\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautifulArray(self, N: int) -> List[int]:\\n        def _split(arr):\\n            if len(arr) <= 2:\\n                return arr\\n            odd, even = [], []\\n            for i, n in enumerate(arr):\\n                if i % 2: even.append(n)\\n                else: odd.append(n)\\n            return _split(odd) + _split(even)\\n\\n        return _split([i for i in range(1, N + 1)])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 762659,
                "title": "java-divide-and-conquer",
                "content": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        List<Integer> pass = new ArrayList<>();\\n        for(int i=1; i<N+1; i++) pass.add(i);\\n        \\n        List<Integer> ans = dfs(pass);\\n        \\n        return ans.stream().mapToInt(i -> i).toArray();\\n    }\\n    \\n    private List<Integer> dfs(List<Integer> arr){\\n        if(arr.size() < 3) return arr;\\n        \\n        List<Integer> odd = new ArrayList<>();\\n        List<Integer> even = new ArrayList<>();\\n        \\n        for(int i=0; i<arr.size(); i++){\\n            if(i%2 == 0) even.add(arr.get(i));\\n            else odd.add(arr.get(i));\\n        }\\n        \\n        odd = dfs(odd);\\n        even = dfs(even);\\n        List<Integer> tmp = new ArrayList<>();\\n        tmp.addAll(odd);\\n        tmp.addAll(even);\\n        \\n        return tmp;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        List<Integer> pass = new ArrayList<>();\\n        for(int i=1; i<N+1; i++) pass.add(i);\\n        \\n        List<Integer> ans = dfs(pass);\\n        \\n        return ans.stream().mapToInt(i -> i).toArray();\\n    }\\n    \\n    private List<Integer> dfs(List<Integer> arr){\\n        if(arr.size() < 3) return arr;\\n        \\n        List<Integer> odd = new ArrayList<>();\\n        List<Integer> even = new ArrayList<>();\\n        \\n        for(int i=0; i<arr.size(); i++){\\n            if(i%2 == 0) even.add(arr.get(i));\\n            else odd.add(arr.get(i));\\n        }\\n        \\n        odd = dfs(odd);\\n        even = dfs(even);\\n        List<Integer> tmp = new ArrayList<>();\\n        tmp.addAll(odd);\\n        tmp.addAll(even);\\n        \\n        return tmp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315467,
                "title": "python3-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef beautifulArray(self, N: int) -> List[int]:\\n\\t\\t\\tres=[1]\\n\\t\\t\\twhile len(res)<N:\\n\\t\\t\\t\\todd=[2*i-1 for i in res]\\n\\t\\t\\t\\teven=[2*i for i in res]\\n\\t\\t\\t\\tres=odd+even\\n\\t\\t\\treturn [i for i in res if i<=N]",
                "solutionTags": [
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef beautifulArray(self, N: int) -> List[int]:\\n\\t\\t\\tres=[1]\\n\\t\\t\\twhile len(res)<N:\\n\\t\\t\\t\\todd=[2*i-1 for i in res]\\n\\t\\t\\t\\teven=[2*i for i in res]\\n\\t\\t\\t\\tres=odd+even\\n\\t\\t\\treturn [i for i in res if i<=N]",
                "codeTag": "Java"
            },
            {
                "id": 1367962,
                "title": "explained-recursion-fast-easy-c",
                "content": "Example 123456 -> 135 246 -> 15 3 26 4 -> 153264\\n\\n2. Use Divide n Conquer Algorithm\\n2. Take the odd alteranate numbers in t1 and even alternate in t2\\n3. Join them back if the size of t1 or t2 is less than 3\\n4. return final answer \\n\\n```\\nvector<int> fun(vector<int> v){\\n\\n\\tif(v.size()<3)\\n\\t\\treturn v;\\n\\n\\tvector<int> t1;\\n\\tvector<int> t2;\\n\\n\\tfor(int i=0;i<v.size();i++){\\n\\t\\tif(i%2==0)\\n\\t\\t\\tt1.push_back(v[i]);\\n\\t\\telse\\n\\t\\t\\tt2.push_back(v[i]);\\n\\t}\\n\\n\\tt1=fun(t1);\\n\\tt2=fun(t2);\\n\\n\\tvector<int> t3;\\n\\tfor(int i=0;i<t1.size();i++)\\n\\t\\tt3.push_back(t1[i]);\\n\\tfor(int i=0;i<t2.size();i++)\\n\\t\\tt3.push_back(t2[i]);\\n\\n\\treturn t3;\\n}\\nvector<int> beautifulArray(int n) {\\n\\n\\tvector<int> t(n);\\n\\tfor(int i=1;i<=n;i++)\\n\\t\\tt[i-1]=i;\\n\\n\\treturn fun(t);\\n}\\n```\\n\\nIf it helps. Do Upvote !",
                "solutionTags": [],
                "code": "```\\nvector<int> fun(vector<int> v){\\n\\n\\tif(v.size()<3)\\n\\t\\treturn v;\\n\\n\\tvector<int> t1;\\n\\tvector<int> t2;\\n\\n\\tfor(int i=0;i<v.size();i++){\\n\\t\\tif(i%2==0)\\n\\t\\t\\tt1.push_back(v[i]);\\n\\t\\telse\\n\\t\\t\\tt2.push_back(v[i]);\\n\\t}\\n\\n\\tt1=fun(t1);\\n\\tt2=fun(t2);\\n\\n\\tvector<int> t3;\\n\\tfor(int i=0;i<t1.size();i++)\\n\\t\\tt3.push_back(t1[i]);\\n\\tfor(int i=0;i<t2.size();i++)\\n\\t\\tt3.push_back(t2[i]);\\n\\n\\treturn t3;\\n}\\nvector<int> beautifulArray(int n) {\\n\\n\\tvector<int> t(n);\\n\\tfor(int i=1;i<=n;i++)\\n\\t\\tt[i-1]=i;\\n\\n\\treturn fun(t);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1367878,
                "title": "beautiful-array-recursion-with-short-explanation-c",
                "content": "Approach:\\n\\t\\n\\tRecursion: At first, we can put all even numbers on the left, and all odd numbers on the right.\\n\\t\\n    1. In this case, we only need to make left subarray beautiful, and right subarray beautiful,\\n    because any number on the left + any number on the right is odd, which cannot be divided by 2.\\n    2.Then we can recursively get the beautiful subarray on the left and on the right, then map them\\n    to the actual number from 1 to N.\\n    3.For even numbers, aka left subarray, left[i] *= 2. E.g. if N = 4, the left subarray will be (1, 2),\\n    and we need to multiply 2 for each number.\\n    we need to make them as (1, 5, 3).\\n\\t\\n\\t\\n\\t\\nCode:\\n\\n\\tclass Solution\\n\\t{\\n\\tpublic:\\n    vector<int> beautifulArray(int n)\\n    {\\n\\n        if(n==1)\\n        {\\n            return {1};\\n        }\\n        int even=n/2;\\n        int odd=(n+1)/2;\\n        vector<int>right=beautifulArray(odd);\\n        vector<int>left=beautifulArray(even);\\n\\n        for(int i=0; i<left.size(); i++)\\n        {\\n            left[i]=left[i]*2;\\n        }\\n        for(int i=0; i<right.size(); i++)\\n        {\\n            right[i]=right[i]*2-1;\\n        }\\n\\n        left.insert(left.end(),right.begin(),right.end());\\n\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\t};\\n\\n",
                "solutionTags": [],
                "code": "class Solution\\n\\t{\\n\\tpublic:\\n    vector<int> beautifulArray(int n)\\n    {\\n\\n        if(n==1)\\n        {\\n            return {1}",
                "codeTag": "Java"
            },
            {
                "id": 552796,
                "title": "concise-c-solution",
                "content": "Very concise solution:\\n\\n```C++\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        if (N == 1) return {1};\\n        vector<int> even = beautifulArray(N / 2);\\n        vector<int> odd = beautifulArray(N - N / 2);\\n        vector<int> rtn;\\n        for (int x : even) rtn.push_back(x * 2);\\n        for (int x : odd) rtn.push_back(x * 2 - 1);\\n        return rtn;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```C++\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        if (N == 1) return {1};\\n        vector<int> even = beautifulArray(N / 2);\\n        vector<int> odd = beautifulArray(N - N / 2);\\n        vector<int> rtn;\\n        for (int x : even) rtn.push_back(x * 2);\\n        for (int x : odd) rtn.push_back(x * 2 - 1);\\n        return rtn;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368607,
                "title": "java-0-ms-100-00-fast-explained-2-solutions",
                "content": "**# Approach 1** \\uD83D\\uDE80\\n```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Beautiful Array.\\n// Memory Usage: 38.5 MB, less than 85.53% of Java online submissions for Beautiful Array.\\n```\\n **- Using recursion**\\n\\nTake case of n=4 and n=8\\nfor n=4, we will get [1,3,2,4]\\n- which is derived when there are 2 array of size 2\\n- left = [1,2] and right = [1,2]\\n- we run 1st loop and it fills all even elements to result array\\nso array become [ _ , _ , 2 , 4 ]\\n- because every new element is calculated as right[i-left.length] * 2\\n- we run 2nd loop and it fills all odd elements to result array\\nso array become [ 1 , 3 , 2 , 4 ]\\n- because every new element is calculated as left[i] * 2 - 1\\n\\nnow if we observe the array it follows the key principle of magic array i.e.\\nAn array nums of length n is beautiful if:\\n- nums is a permutation of the integers in the range [1, n].\\n- For every 0 <= i < j < n, there is no index k with i < k < j where 2 * nums[k] == nums[i] + nums[j]\\n\\nfor n=8, we will get [1,5,3,7,2,6,4,8]\\n- this is because 2 subarray were left==right==[1,3,2,4]\\n\\n\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n       int[] answer = new int[n]; \\n        if(n == 1) {\\n            answer[0] = 1;\\n            return answer;\\n        }\\n            int[] right =beautifulArray(n/2);\\n            int[] left = beautifulArray((n+1)/2);\\n\\t\\t\\t\\n            for(int i=left.length; i<n; i++) {      //This loop adds all even elements at end\\n                answer[i] = right[i-left.length] * 2; \\n            }\\n            for(int i=0; i<left.length; i++) {      //This loop adds all odd elements at start\\n                answer[i] = left[i] * 2 - 1;     \\n            }\\n        return answer;\\n    }\\n}\\n```\\n\\n**# Approach 2** \\uD83D\\uDE80\\n```\\n// Runtime: 4 ms, faster than 27.04% of Java online submissions for Beautiful Array.\\n// Memory Usage: 38.6 MB, less than 85.53% of Java online submissions for Beautiful Array.\\n```\\n\\n - **Using loop to calculate next element**\\n\\nIdea is simple ->\\n* generate 2 sub array \\n  1st array calculate  elements as  -> 2 * element-1\\n  2nd array calculate elements as -> 2 * element\\n* add element in arrays only if new element is less than or equal to current length\\n* merge these array\\n\\n```\\n\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> answer=new ArrayList<>();\\n        answer.add(1);\\n        while(answer.size()<n){\\n            ArrayList<Integer> temp=new ArrayList<>();\\n                    for(int element:answer)\\n                        if(2*element-1<=n)\\n                            temp.add(element*2-1);\\n            \\n                    for(int element:answer)\\n                        if(2*element<=n)\\n                            temp.add(element*2);\\n                    \\n\\t\\t\\t\\t\\t//in different loops because we want to maintain order\\n            answer=temp;\\n        }\\n        return answer.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```\\n\\n \\nPlease upvote to motivate me \\uD83D\\uDE80\\uD83D\\uDE80\\uD83D\\uDE80",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n// Runtime: 0 ms, faster than 100.00% of Java online submissions for Beautiful Array.\\n// Memory Usage: 38.5 MB, less than 85.53% of Java online submissions for Beautiful Array.\\n```\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n       int[] answer = new int[n]; \\n        if(n == 1) {\\n            answer[0] = 1;\\n            return answer;\\n        }\\n            int[] right =beautifulArray(n/2);\\n            int[] left = beautifulArray((n+1)/2);\\n\\t\\t\\t\\n            for(int i=left.length; i<n; i++) {      //This loop adds all even elements at end\\n                answer[i] = right[i-left.length] * 2; \\n            }\\n            for(int i=0; i<left.length; i++) {      //This loop adds all odd elements at start\\n                answer[i] = left[i] * 2 - 1;     \\n            }\\n        return answer;\\n    }\\n}\\n```\n```\\n// Runtime: 4 ms, faster than 27.04% of Java online submissions for Beautiful Array.\\n// Memory Usage: 38.6 MB, less than 85.53% of Java online submissions for Beautiful Array.\\n```\n```\\n\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> answer=new ArrayList<>();\\n        answer.add(1);\\n        while(answer.size()<n){\\n            ArrayList<Integer> temp=new ArrayList<>();\\n                    for(int element:answer)\\n                        if(2*element-1<=n)\\n                            temp.add(element*2-1);\\n            \\n                    for(int element:answer)\\n                        if(2*element<=n)\\n                            temp.add(element*2);\\n                    \\n\\t\\t\\t\\t\\t//in different loops because we want to maintain order\\n            answer=temp;\\n        }\\n        return answer.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367966,
                "title": "beautiful-array-cpp-simple-iterative-solution-explained",
                "content": "As per the the question if nums[k] multiply with 2 == nums[i]+nums[j] where i<k<j then the array is not beautiful . so we will use some basic maths now to solve this question .\\nnow as we know that (2 multiply with even number ) == even and also (odd*2) == even. so we can clearly say that in order to achieve desired result we have to make right hand side of following equation odd because left hand side be always even.\\nso in order to do that we will seperate both odd elements and even elements and place odd elements in left side of array and even in right side . hence making array beautiful.\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) {\\n            vector<int> tmp;\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Please upvote if you like the solution**",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) {\\n            vector<int> tmp;\\n            for (int i : res) if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            for (int i : res) if (i * 2 <= N) tmp.push_back(i * 2);\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1072005,
                "title": "c-recursion-with-short-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        // Recursion: first, we can put all even numbers on the left, and all odd numbers on the right.\\n        // In this case, we only need to make left subarray beautiful, and right subarray beautiful,\\n        // because any number on the left + any number on the right is odd, which cannot be divided by 2.\\n        // Then we can recursively get the beautiful subarray on the left and on the right, then map them\\n        // to the actual number from 1 to N.\\n        // For even numbers, aka left subarray, left[i] *= 2. E.g. if N = 4, the left subarray will be (1, 2),\\n        // and we need to multiply 2 for each number.\\n        // For odd numbers, right[i] = right[i] * 2 - 1. E.g. if N = 5, the right subarray is (1, 3, 2), and \\n        // we need to make them as (1, 5, 3).\\n        if (N == 1)\\n        {\\n            return {1};\\n        }\\n        \\n        int evens = N / 2, odds = (N + 1) / 2;\\n        vector<int> left = beautifulArray(evens);\\n        vector<int> right = beautifulArray(odds);\\n        \\n        for (int i = 0; i < left.size(); ++i)\\n        {\\n            left[i] *= 2;\\n        }\\n        \\n        for (int i = 0; i < right.size(); ++i)\\n        {\\n            right[i] = right[i] * 2 - 1;\\n        }\\n        \\n        left.insert(left.end(), right.begin(), right.end());\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        // Recursion: first, we can put all even numbers on the left, and all odd numbers on the right.\\n        // In this case, we only need to make left subarray beautiful, and right subarray beautiful,\\n        // because any number on the left + any number on the right is odd, which cannot be divided by 2.\\n        // Then we can recursively get the beautiful subarray on the left and on the right, then map them\\n        // to the actual number from 1 to N.\\n        // For even numbers, aka left subarray, left[i] *= 2. E.g. if N = 4, the left subarray will be (1, 2),\\n        // and we need to multiply 2 for each number.\\n        // For odd numbers, right[i] = right[i] * 2 - 1. E.g. if N = 5, the right subarray is (1, 3, 2), and \\n        // we need to make them as (1, 5, 3).\\n        if (N == 1)\\n        {\\n            return {1};\\n        }\\n        \\n        int evens = N / 2, odds = (N + 1) / 2;\\n        vector<int> left = beautifulArray(evens);\\n        vector<int> right = beautifulArray(odds);\\n        \\n        for (int i = 0; i < left.size(); ++i)\\n        {\\n            left[i] *= 2;\\n        }\\n        \\n        for (int i = 0; i < right.size(); ++i)\\n        {\\n            right[i] = right[i] * 2 - 1;\\n        }\\n        \\n        left.insert(left.end(), right.begin(), right.end());\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2687713,
                "title": "c-solution-beautiful-array",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        return solve(n);\\n    }\\n    \\n    vector<int> solve(int n){\\n        //base case\\n        if(n==1) {\\n            vector<int> k = {1};\\n            return k;\\n        }\\n        \\n        vector<int> ans = solve(n-1);\\n        vector<int> temp;\\n        for(int i = 0; i < ans.size(); i++){\\n            if(2*ans[i]-1 <= n) temp.push_back(2*ans[i]-1);\\n        }\\n        for(int i = 0; i < ans.size(); i++){\\n            if(2*ans[i] <= n) temp.push_back(2*ans[i]);\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Divide and Conquer",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        return solve(n);\\n    }\\n    \\n    vector<int> solve(int n){\\n        //base case\\n        if(n==1) {\\n            vector<int> k = {1};\\n            return k;\\n        }\\n        \\n        vector<int> ans = solve(n-1);\\n        vector<int> temp;\\n        for(int i = 0; i < ans.size(); i++){\\n            if(2*ans[i]-1 <= n) temp.push_back(2*ans[i]-1);\\n        }\\n        for(int i = 0; i < ans.size(); i++){\\n            if(2*ans[i] <= n) temp.push_back(2*ans[i]);\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401361,
                "title": "easy-solution-c-without-recursion",
                "content": "the key observation here is we can make beautiful arr from a beautiful arr by multiplying 2i and 2i-1 to all element of arr and taking value which is <=n\\n\\nlet me explain..\\n\\nlets just start with smallest beautiful array \\nwhen n=1\\narr->{1} now this is a beautiful array \\n\\nnow coming on equation 2*arr[k]!=arr[i]+arr[j]\\nif we multiply 2*i on both side equation remain same  //here i is any element of beautiful array\\n->2i*(2*arr[k])!=2i*(arr[i]+arr[j])\\n->this means that if i multiply 2 with all element of array then new array will also be beautiful\\n\\nfor ex:when n=1 arr={1}\\n->now multiplying 2 to every element arr become :{2} you can see that this also a beautiful arr\\n\\nnow again if we multiply (2i-1) to both side the equation remain same \\n->2i-1*(2*nums[k])!=(2i-1)*(nums[i]+nums[j])\\n->this means that if we multiply 2i-1 to arr element than new arr is also beautiful arr\\n\\nfor ex: n=1 arr={1}\\n->now multiply 2i-1 to every element : arr={1} you can see that rhis is beautiful array \\n\\n->now if we concatenate to beautiful arr we get a beautiful arr\\n\\nso concatenating {1}+{2}={1,2} is also a beautiful array \\n->now we got arr of size 2 from 1 \\n->for n=3 we have arr={1,2}\\nmultiply 2 to every element\\narr={2,4} //beautiful\\n\\nmultiply 2*i-1 to every element     // here i is element like when i=2 =2*2-1=3\\narr={1,3}\\n\\nnow add to arr={2,4}+{1,3}={2,4,1,3} //beautiful arr\\nbut here 4>3 so we delete it \\nnow arr become ->{2,1,3} // beautiful arr\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n      vector<int>ans;\\n        ans.push_back(1); //smallest beautiful arr\\n        \\n        int val=2; \\n        while(val<=n)\\n        {\\n            vector<int>temp;\\n            for(int it:ans)\\n                if(2*it-1<=val) //checking the element in bound of arr size\\n                    temp.push_back(2*it-1);\\n            \\n            for(int it:ans)\\n                if(2*it<=val)\\n                    temp.push_back(2*it);\\n            \\n            ans=temp;\\n            val++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n      vector<int>ans;\\n        ans.push_back(1); //smallest beautiful arr\\n        \\n        int val=2; \\n        while(val<=n)\\n        {\\n            vector<int>temp;\\n            for(int it:ans)\\n                if(2*it-1<=val) //checking the element in bound of arr size\\n                    temp.push_back(2*it-1);\\n            \\n            for(int it:ans)\\n                if(2*it<=val)\\n                    temp.push_back(2*it);\\n            \\n            ans=temp;\\n            val++;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368108,
                "title": "java-easy-to-understand-even-odd-pattern-divide-and-conquer",
                "content": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {            \\n        int[] res = new int[n];     //odd,even \\n        if(n == 1) {\\n            res[0] = 1;\\n            return res;\\n        }\\n            int[] right =beautifulArray(n/2);\\n            int[] left = beautifulArray((n+1)/2);\\n            //Adding The Even nos.\\n            for(int i=left.length; i<n; i++) {\\n                res[i] = right[i-left.length] * 2; \\n            }\\n            // Adding the  odd nos.\\n            for(int i=0; i<left.length; i++) {\\n                res[i] = left[i] * 2 - 1;     \\n            }\\n        return res;\\n}\\n}\\n```\\n**Please Upvote If You Liked The Soln**",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {            \\n        int[] res = new int[n];     //odd,even \\n        if(n == 1) {\\n            res[0] = 1;\\n            return res;\\n        }\\n            int[] right =beautifulArray(n/2);\\n            int[] left = beautifulArray((n+1)/2);\\n            //Adding The Even nos.\\n            for(int i=left.length; i<n; i++) {\\n                res[i] = right[i-left.length] * 2; \\n            }\\n            // Adding the  odd nos.\\n            for(int i=0; i<left.length; i++) {\\n                res[i] = left[i] * 2 - 1;     \\n            }\\n        return res;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1184882,
                "title": "python3-divide-conquer",
                "content": "\\n```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        \\n        def fn(nums): \\n            \"\"\"Return beautiful array by rearraning elements in nums.\"\"\"\\n            if len(nums) <= 1: return nums\\n            return fn(nums[::2]) + fn(nums[1::2])\\n        \\n        return fn(list(range(1, N+1)))\\n```\\n\\nEdited on 7/28/2021\\nAlternative bottom-up implementation\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        ans = [1]\\n        while len(ans) < n: \\n            ans = [2*x-1 for x in ans] + [2*x for x in ans]\\n        return [x for x in ans if x <= n]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        \\n        def fn(nums): \\n            \"\"\"Return beautiful array by rearraning elements in nums.\"\"\"\\n            if len(nums) <= 1: return nums\\n            return fn(nums[::2]) + fn(nums[1::2])\\n        \\n        return fn(list(range(1, N+1)))\\n```\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        ans = [1]\\n        while len(ans) < n: \\n            ans = [2*x-1 for x in ans] + [2*x for x in ans]\\n        return [x for x in ans if x <= n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 798542,
                "title": "simple-iterative-solution-c-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res{1};\\n        if(n==1) return res ; \\n        \\n        while(res.size()<n){\\n            vector<int> tmp;\\n            for(int i  :res){\\n                if(2*i <= n){\\n                    tmp.push_back(2*i);\\n                }\\n            }\\n             for(int i  :res){\\n                if(2*i -1 <= n){\\n                    tmp.push_back(2*i-1);\\n                }\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\ngo through solution and observe output for n = 1,2,3,....\\n```\\nn=1\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 1\\nn=2\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2 1\\nn=3\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   2 1 3\\nn=4\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  4 2 3 1\\nn=5\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 4 2 3 5 1\\nn=6\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t4 6 2 3 5 1\\nn=7\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   4 6 2 7 3 5 1\\nn=8\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  8 4 6 2 7 3 5 1\\n```\\nstart from 1 an at each step take the previous beautiful array and insrt even elements less than n in the same order as the previous arr by multiplying each element by 2 (insert 2*\\\\i in array )\\nthen add all odd elements into the array by taking previous array (beautiful(n-1)) multipying by 2 and suntract 1 ( insert 2\\\\*n -1 in array if 2\\\\*n-1 <n)\\nif u can\\'t understand read leetcode soln and if u want try generating the above pattern by hand. using  above code.\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res{1};\\n        if(n==1) return res ; \\n        \\n        while(res.size()<n){\\n            vector<int> tmp;\\n            for(int i  :res){\\n                if(2*i <= n){\\n                    tmp.push_back(2*i);\\n                }\\n            }\\n             for(int i  :res){\\n                if(2*i -1 <= n){\\n                    tmp.push_back(2*i-1);\\n                }\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nn=1\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 1\\nn=2\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t2 1\\nn=3\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   2 1 3\\nn=4\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  4 2 3 1\\nn=5\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t 4 2 3 5 1\\nn=6\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t4 6 2 3 5 1\\nn=7\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t   4 6 2 7 3 5 1\\nn=8\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  8 4 6 2 7 3 5 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 694087,
                "title": "divide-and-conquer",
                "content": "I would like to walk through my path to the final solution.\\n\\nFirstly I observed that the condition `2 * A[k]` is an even, so naturally I think of splitting the array into 2 parts: odds + evens, then any number in odd part + any number in even part will result in an odd, which will satisfy the condition.\\n\\nThen we need to make sure numbers in each part satisfies the condition as well. Let\\'s take a look at the odd part first. Each number in this array could be denoted using the form `2ni + 1`, where i is the index of this number.\\n\\nWe need to make sure\\n```\\n2ni + 1 + 2nj + 1 != 2 * (2nk + 1), which simplifies to\\ni + j != 2k, where i, j, k are index of each number\\n```\\n\\nWe are seeing this form again :D So we can apply the same strategy as we apply earlier: split the array into 2 parts based on their index, odd index into 1 array and even index into another, and doing this recursively for each array:\\n\\n```\\nfunc split(s []int) []int {\\n    if len(s) <= 1 {\\n\\t\\treturn s\\n\\t}\\n\\t\\n\\todd, even := []int{}, []int{}\\n\\tfor i := 0; i < len(s); i ++ {\\n\\t\\tif i % 2 ==.0 {\\n\\t\\t\\teven = append(even, s[i])\\n\\t\\t} else {\\n\\t\\t\\todd = append(odd, s[i])\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn append(split(odd), split(even)...)\\n}\\n```",
                "solutionTags": [
                    "Divide and Conquer"
                ],
                "code": "```\\n2ni + 1 + 2nj + 1 != 2 * (2nk + 1), which simplifies to\\ni + j != 2k, where i, j, k are index of each number\\n```\n```\\nfunc split(s []int) []int {\\n    if len(s) <= 1 {\\n\\t\\treturn s\\n\\t}\\n\\t\\n\\todd, even := []int{}, []int{}\\n\\tfor i := 0; i < len(s); i ++ {\\n\\t\\tif i % 2 ==.0 {\\n\\t\\t\\teven = append(even, s[i])\\n\\t\\t} else {\\n\\t\\t\\todd = append(odd, s[i])\\n\\t\\t}\\n\\t}\\n\\t\\n\\treturn append(split(odd), split(even)...)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186944,
                "title": "python-solution-with-chinese-explanation-showing-my-thinking-process",
                "content": "https://buptwc.github.io/2018/10/28/Leetcode-932-Beautiful-Array/\\nI can\\'t express my thoughts very well in English. Sorry for my poor English.\\nThe final idea is the same as others.\\n```python\\n# 28ms\\nclass Solution(object):\\n    def beautifulArray(self, N):\\n        cache = {}\\n        def solve(N):\\n            if N == 1: return [1]\\n            if N in cache: return cache[N]\\n            \\n            even_index = N // 2\\n            odd_index = N - even_index\\n            even = solve(even_index)\\n            odd = solve(odd_index)\\n            even = [2*val for val in even]\\n            odd = [2*val-1 for val in odd]\\n            cache[N] = even + odd\\n            return cache[N]\\n        return solve(N)\\n```",
                "solutionTags": [],
                "code": "```python\\n# 28ms\\nclass Solution(object):\\n    def beautifulArray(self, N):\\n        cache = {}\\n        def solve(N):\\n            if N == 1: return [1]\\n            if N in cache: return cache[N]\\n            \\n            even_index = N // 2\\n            odd_index = N - even_index\\n            even = solve(even_index)\\n            odd = solve(odd_index)\\n            even = [2*val for val in even]\\n            odd = [2*val-1 for val in odd]\\n            cache[N] = even + odd\\n            return cache[N]\\n        return solve(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1676288,
                "title": "python-easy-solution",
                "content": "```\\ndef beautifulArray(self, n: int) -> List[int]:\\n\\tans = [1]\\n\\twhile len(ans) < n:\\n\\t\\tres = []\\n\\t\\tfor el in ans:\\n\\t\\t\\tif 2 * el - 1 <= n:\\n\\t\\t\\t\\tres.append(el * 2 - 1)\\n\\n\\t\\tfor el in ans: \\n\\t\\t\\tif 2 * el <= n:\\n\\t\\t\\t\\tres.append(el * 2)\\n\\n\\t\\tans = res\\n\\treturn ans\\n\\n# odd ele -> 2 * el - 1\\n# even ele -> 2 * el\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef beautifulArray(self, n: int) -> List[int]:\\n\\tans = [1]\\n\\twhile len(ans) < n:\\n\\t\\tres = []\\n\\t\\tfor el in ans:\\n\\t\\t\\tif 2 * el - 1 <= n:\\n\\t\\t\\t\\tres.append(el * 2 - 1)\\n\\n\\t\\tfor el in ans: \\n\\t\\t\\tif 2 * el <= n:\\n\\t\\t\\t\\tres.append(el * 2)\\n\\n\\t\\tans = res\\n\\treturn ans\\n\\n# odd ele -> 2 * el - 1\\n# even ele -> 2 * el\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1483741,
                "title": "a-simple-solution-c-0ms-o-n-time-o-1-space-explanation",
                "content": "A very simple fast solution  (C++)  O(N) time O(1) space\\n\\nIt generates one specific beautiful array for each N. \\n\\n**The inspiration:**\\nIt comes from the 4 observations\\n\\n1  The binary tree shown naturally sorts 2^N numbers into beautiful arrays.\\n\\n![image](https://assets.leetcode.com/users/images/93eb1233-a128-49d4-927e-b9823dfa2b08_1632560687.4727483.jpeg)\\n\\n\\n2.  The binary is sorting numbers in reverse bit order\\n\\n3.  Every ordered subset of N items in such a 2^M array, where 1 <= N <= M and where elements > N are removed, is also a beautiful array. \\nNote: I have not bothered to prove that, but I tested it up to N = 1000 which is the problem limit. \\n\\n4.  The 1..N array is a specialisation of 0..N\\n\\n**The implementation:**\\nTake a group of  1 - N integers,   say 1,2,3,4,5,6,7,8 ,9\\nCalculate the smallest power of two greater than N, in this case is 16. \\nAll the numbers up to 16 can be represented by 4 bits. \\nReverse the order of the bits of each of the 4 bit numbers, from 1 to 15  \\n\\t1  = 0001   becomes   8  = 1000\\n\\t2  = 0010   becomes   4  = 0100\\n    etc.\\n\\t\\nHere is the conversion of each number from 1 to 15 \\n\\n    Numbers       1  2  3  4  5   6   7  8  9 10 11 12 13 14 15   \\n\\tBit reversed  8 4 12  2 10  6 14  1  9   5 13   3  11  7 15\\n\\t\\nIf you increase the depth of the binary tree to 4 bits, those numbers will be in that order along the bottom. \\n\\nThe 15 values give you a beautiful array for any N from 1 to 15  by selecting the values in order that are <= N.\\nFor example where N = 9  the number <= 9 in order\\n\\t8  4 12  2 10  6 14  1  9   5 13   3 11   7 15. \\n\\t8  4       2       6       1  9   5        3        7\\nThat is a beautiful array for N = 9 \\n\\nNote: The algorithm is O(1) as it doesn\\'t store  the 2^N - 1 array.\\n\\nFrom point 4 above, the 1 to N soultions are a specialisation of 0 to N \\nIf you change the code to work from 0 to N you get\\n[ 0 2 1 ] is beautiful\\n[ 0 2 1 3 ] is beautiful\\n[ 0 4 2 1 3 ] is beautiful\\n[ 0 4 2 1 5 3 ] is beautiful\\n[ 0 4 2 6 1 5 3 ] is beautiful\\n[ 0 4 2 6 1 5 3 7 ] is beautiful\\n[ 0 8 4 2 6 1 5 3 7 ] is beautiful\\n[ 0 8 4 2 6 1 9 5 3 7 ] is beautiful\\n[ 0 8 4 2 10 6 1 9 5 3 7 ] is beautiful\\n[ 0 8 4 2 10 6 1 9 5 3 11 7 ] is beautiful\\n[ 0 8 4 12 2 10 6 1 9 5 3 11 7 ] is beautiful\\n[ 0 8 4 12 2 10 6 1 9 5 13 3 11 7 ] is beautiful\\n[ 0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 ] is beautiful\\n[ 0 8 4 12 2 10 6 14 1 9 5 13 3 11 7 15 ] is beautiful\\n\\n\\n\\nTo calculate where  N  = 1000,  you make the table for 2^10 (1024) and use 10 bit numbers which you reverse in the same way. \\n\\nThe beautifull array it generates for N =1000 array is below (after the code) \\nFrom that you can extract a beautiful array for every N from 1 to 1000 from it.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\tvector<int> beautifulArray(int n)\\n\\t\\t{\\t\\t\\t\\n    \\t    int maxbit; // max n is 1000\\n\\t\\t\\tfor (int i = 9; i >= 0; --i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (n & (1 << i)) { maxbit = i;\\tbreak;\\t}\\n\\t\\t\\t}\\t\\n\\t\\t\\tint powerOfTwo = (1 << maxbit + 1);\\n\\t    \\tauto array = vector<int>(n); \\n\\t\\t\\tfor (int i = 1, a = 0; i < powerOfTwo; ++i)\\n\\t    \\t{\\n\\t    \\t    int x = invertBits(i, maxbit + 1);\\n\\t    \\t\\tif (x > 0 && x <= n)\\n\\t    \\t\\t{\\n\\t    \\t\\t \\tarray[a++] = x;\\n\\t\\t\\t\\t}\\t    \\t\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\treturn array;\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t    uint16_t invertBits(uint16_t b, int maxbits = 16) {\\n\\t\\t   uint16_t mask = 0b1111111100000000;\\n\\t\\t   b = (b & mask) >> 8 | (b & ~mask) << 8;\\n\\t\\t   mask = 0b1111000011110000;\\n\\t\\t   b = (b & mask) >> 4 | (b & ~mask) << 4;\\n\\t\\t   mask = 0b1100110011001100;\\n\\t\\t   b = (b & mask) >> 2 | (b & ~mask) << 2;\\n\\t\\t   mask = 0b1010101010101010;\\n\\t\\t   b = (b & mask) >> 1 | (b & ~mask) << 1;\\n\\t\\t   return b >> (16 - maxbits);\\n\\t\\t}\\n```\\n\\n\\n\\n```\\nvector<int> beautiful1000 = \\n{ 512, 256, 768, 128, 640, 384, 896, 64, 576, 320, 832, 192, 704, 448,\\n960, 32, 544, 288, 800, 160, 672, 416, 928, 96, 608, 352, 864, 224, \\n736, 480, 992, 16, 528, 272, 784, 144, 656, 400, 912, 80, 592, 336, \\n848, 208, 720, 464, 976, 48, 560, 304, 816, 176, 688, 432, 944, 112, \\n624, 368, 880, 240, 752, 496, 8, 520, 264, 776, 136, 648, 392, 904, \\n72, 584, 328, 840, 200, 712, 456, 968, 40, 552, 296, 808, 168, 680, \\n424, 936, 104, 616, 360, 872, 232, 744, 488, 1000, 24, 536, 280, 792, \\n152, 664, 408, 920, 88, 600, 344, 856, 216, 728, 472, 984, 56, 568, \\n312, 824, 184, 696, 440, 952, 120, 632, 376, 888, 248, 760, 504, 4, \\n516, 260, 772, 132, 644, 388, 900, 68, 580, 324, 836, 196, 708, 452, \\n964, 36, 548, 292, 804, 164, 676, 420, 932, 100, 612, 356, 868, 228, \\n740, 484, 996, 20, 532, 276, 788, 148, 660, 404, 916, 84, 596, 340, \\n852, 212, 724, 468, 980, 52, 564, 308, 820, 180, 692, 436, 948, 116, \\n628, 372, 884, 244, 756, 500, 12, 524, 268, 780, 140, 652, 396, 908, \\n76, 588, 332, 844, 204, 716, 460, 972, 44, 556, 300, 812, 172, 684, \\n428, 940, 108, 620, 364, 876, 236, 748, 492, 28, 540, 284, 796, 156, \\n668, 412, 924, 92, 604, 348, 860, 220, 732, 476, 988, 60, 572, 316, \\n828, 188, 700, 444, 956, 124, 636, 380, 892, 252, 764, 508, 2, 514, \\n258, 770, 130, 642, 386, 898, 66, 578, 322, 834, 194, 706, 450, 962, \\n34, 546, 290, 802, 162, 674, 418, 930, 98, 610, 354, 866, 226, 738, \\n482, 994, 18, 530, 274, 786, 146, 658, 402, 914, 82, 594, 338, 850, \\n210, 722, 466, 978, 50, 562, 306, 818, 178, 690, 434, 946, 114, 626, \\n370, 882, 242, 754, 498, 10, 522, 266, 778, 138, 650, 394, 906, 74, \\n586, 330, 842, 202, 714, 458, 970, 42, 554, 298, 810, 170, 682, 426,\\n938, 106, 618, 362, 874, 234, 746, 490, 26, 538, 282, 794, 154, 666, \\n410, 922, 90, 602, 346, 858, 218, 730, 474, 986, 58, 570, 314, 826, \\n186, 698, 442, 954, 122, 634, 378, 890, 250, 762, 506, 6, 518, 262, \\n774, 134, 646, 390, 902, 70, 582, 326, 838, 198, 710, 454, 966, 38, \\n550, 294, 806, 166, 678, 422, 934, 102, 614, 358, 870, 230, 742, 486, \\n998, 22, 534, 278, 790, 150, 662, 406, 918, 86, 598, 342, 854, 214, \\n726, 470, 982, 54, 566, 310, 822, 182, 694, 438, 950, 118, 630, 374, \\n886, 246, 758, 502, 14, 526, 270, 782, 142, 654, 398, 910, 78, 590, \\n334, 846, 206, 718, 462, 974, 46, 558, 302, 814, 174, 686, 430, 942, \\n110, 622, 366, 878, 238, 750, 494, 30, 542, 286, 798, 158, 670, 414, \\n926, 94, 606, 350, 862, 222, 734, 478, 990, 62, 574, 318, 830, 190, \\n702, 446, 958, 126, 638, 382, 894, 254, 766, 510, 1, 513, 257, 769, \\n129, 641, 385, 897, 65, 577, 321, 833, 193, 705, 449, 961, 33, 545, \\n289, 801, 161, 673, 417, 929, 97, 609, 353, 865, 225, 737, 481, 993, \\n17, 529, 273, 785, 145, 657, 401, 913, 81, 593, 337, 849, 209, 721, \\n465, 977, 49, 561, 305, 817, 177, 689, 433, 945, 113, 625, 369, 881, \\n241, 753, 497, 9, 521, 265, 777, 137, 649, 393, 905, 73, 585, 329, \\n841, 201, 713, 457, 969, 41, 553, 297, 809, 169, 681, 425, 937, 105, \\n617, 361, 873, 233, 745, 489, 25, 537, 281, 793, 153, 665, 409, 921, \\n89, 601, 345, 857, 217, 729, 473, 985, 57, 569, 313, 825, 185, 697, \\n441, 953, 121, 633, 377, 889, 249, 761, 505, 5, 517, 261, 773, 133, \\n645, 389, 901, 69, 581, 325, 837, 197, 709, 453, 965, 37, 549, 293, \\n805, 165, 677, 421, 933, 101, 613, 357, 869, 229, 741, 485, 997, 21, \\n533, 277, 789, 149, 661, 405, 917, 85, 597, 341, 853, 213, 725, 469, \\n981, 53, 565, 309, 821, 181, 693, 437, 949, 117, 629, 373, 885, 245, \\n757, 501, 13, 525, 269, 781, 141, 653, 397, 909, 77, 589, 333, 845, \\n205, 717, 461, 973, 45, 557, 301, 813, 173, 685, 429, 941, 109, 621, \\n365, 877, 237, 749, 493, 29, 541, 285, 797, 157, 669, 413, 925, 93, \\n605, 349, 861, 221, 733, 477, 989, 61, 573, 317, 829, 189, 701, 445, \\n957, 125, 637, 381, 893, 253, 765, 509, 3, 515, 259, 771, 131, 643, \\n387, 899, 67, 579, 323, 835, 195, 707, 451, 963, 35, 547, 291, 803, \\n163, 675, 419, 931, 99, 611, 355, 867, 227, 739, 483, 995, 19, 531, \\n275, 787, 147, 659, 403, 915, 83, 595, 339, 851, 211, 723, 467, 979, \\n51, 563, 307, 819, 179, 691, 435, 947, 115, 627, 371, 883, 243, 755, \\n499, 11, 523, 267, 779, 139, 651, 395, 907, 75, 587, 331, 843, 203, \\n715, 459, 971, 43, 555, 299, 811, 171, 683, 427, 939, 107, 619, 363, \\n875, 235, 747, 491, 27, 539, 283, 795, 155, 667, 411, 923, 91, 603, \\n347, 859, 219, 731, 475, 987, 59, 571, 315, 827, 187, 699, 443, 955, \\n123, 635, 379, 891, 251, 763, 507, 7, 519, 263, 775, 135, 647, 391, \\n903, 71, 583, 327, 839, 199, 711, 455, 967, 39, 551, 295, 807, 167, \\n679, 423, 935, 103, 615, 359, 871, 231, 743, 487, 999, 23, 535, 279, \\n791, 151, 663, 407, 919, 87, 599, 343, 855, 215, 727, 471, 983, 55, \\n567, 311, 823, 183, 695, 439, 951, 119, 631, 375, 887, 247, 759, 503, \\n15, 527, 271, 783, 143, 655, 399, 911, 79, 591, 335, 847, 207, 719, \\n463, 975, 47, 559, 303, 815, 175, 687, 431, 943, 111, 623, 367, 879, \\n239, 751, 495, 31, 543, 287, 799, 159, 671, 415, 927, 95, 607, 351, \\n863, 223, 735, 479, 991, 63, 575, 319, 831, 191, 703, 447, 959, 127, \\n639, 383, 895, 255, 767, 511 }; // beautiful\\n\\n```\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\tvector<int> beautifulArray(int n)\\n\\t\\t{\\t\\t\\t\\n    \\t    int maxbit; // max n is 1000\\n\\t\\t\\tfor (int i = 9; i >= 0; --i)\\n\\t\\t\\t{\\n\\t\\t\\t\\tif (n & (1 << i)) { maxbit = i;\\tbreak;\\t}\\n\\t\\t\\t}\\t\\n\\t\\t\\tint powerOfTwo = (1 << maxbit + 1);\\n\\t    \\tauto array = vector<int>(n); \\n\\t\\t\\tfor (int i = 1, a = 0; i < powerOfTwo; ++i)\\n\\t    \\t{\\n\\t    \\t    int x = invertBits(i, maxbit + 1);\\n\\t    \\t\\tif (x > 0 && x <= n)\\n\\t    \\t\\t{\\n\\t    \\t\\t \\tarray[a++] = x;\\n\\t\\t\\t\\t}\\t    \\t\\t\\n\\t\\t\\t}\\t\\n\\t\\t\\treturn array;\\t\\t\\n\\t\\t}\\n\\t\\t\\n\\t    uint16_t invertBits(uint16_t b, int maxbits = 16) {\\n\\t\\t   uint16_t mask = 0b1111111100000000;\\n\\t\\t   b = (b & mask) >> 8 | (b & ~mask) << 8;\\n\\t\\t   mask = 0b1111000011110000;\\n\\t\\t   b = (b & mask) >> 4 | (b & ~mask) << 4;\\n\\t\\t   mask = 0b1100110011001100;\\n\\t\\t   b = (b & mask) >> 2 | (b & ~mask) << 2;\\n\\t\\t   mask = 0b1010101010101010;\\n\\t\\t   b = (b & mask) >> 1 | (b & ~mask) << 1;\\n\\t\\t   return b >> (16 - maxbits);\\n\\t\\t}\\n```\n```\\nvector<int> beautiful1000 = \\n{ 512, 256, 768, 128, 640, 384, 896, 64, 576, 320, 832, 192, 704, 448,\\n960, 32, 544, 288, 800, 160, 672, 416, 928, 96, 608, 352, 864, 224, \\n736, 480, 992, 16, 528, 272, 784, 144, 656, 400, 912, 80, 592, 336, \\n848, 208, 720, 464, 976, 48, 560, 304, 816, 176, 688, 432, 944, 112, \\n624, 368, 880, 240, 752, 496, 8, 520, 264, 776, 136, 648, 392, 904, \\n72, 584, 328, 840, 200, 712, 456, 968, 40, 552, 296, 808, 168, 680, \\n424, 936, 104, 616, 360, 872, 232, 744, 488, 1000, 24, 536, 280, 792, \\n152, 664, 408, 920, 88, 600, 344, 856, 216, 728, 472, 984, 56, 568, \\n312, 824, 184, 696, 440, 952, 120, 632, 376, 888, 248, 760, 504, 4, \\n516, 260, 772, 132, 644, 388, 900, 68, 580, 324, 836, 196, 708, 452, \\n964, 36, 548, 292, 804, 164, 676, 420, 932, 100, 612, 356, 868, 228, \\n740, 484, 996, 20, 532, 276, 788, 148, 660, 404, 916, 84, 596, 340, \\n852, 212, 724, 468, 980, 52, 564, 308, 820, 180, 692, 436, 948, 116, \\n628, 372, 884, 244, 756, 500, 12, 524, 268, 780, 140, 652, 396, 908, \\n76, 588, 332, 844, 204, 716, 460, 972, 44, 556, 300, 812, 172, 684, \\n428, 940, 108, 620, 364, 876, 236, 748, 492, 28, 540, 284, 796, 156, \\n668, 412, 924, 92, 604, 348, 860, 220, 732, 476, 988, 60, 572, 316, \\n828, 188, 700, 444, 956, 124, 636, 380, 892, 252, 764, 508, 2, 514, \\n258, 770, 130, 642, 386, 898, 66, 578, 322, 834, 194, 706, 450, 962, \\n34, 546, 290, 802, 162, 674, 418, 930, 98, 610, 354, 866, 226, 738, \\n482, 994, 18, 530, 274, 786, 146, 658, 402, 914, 82, 594, 338, 850, \\n210, 722, 466, 978, 50, 562, 306, 818, 178, 690, 434, 946, 114, 626, \\n370, 882, 242, 754, 498, 10, 522, 266, 778, 138, 650, 394, 906, 74, \\n586, 330, 842, 202, 714, 458, 970, 42, 554, 298, 810, 170, 682, 426,\\n938, 106, 618, 362, 874, 234, 746, 490, 26, 538, 282, 794, 154, 666, \\n410, 922, 90, 602, 346, 858, 218, 730, 474, 986, 58, 570, 314, 826, \\n186, 698, 442, 954, 122, 634, 378, 890, 250, 762, 506, 6, 518, 262, \\n774, 134, 646, 390, 902, 70, 582, 326, 838, 198, 710, 454, 966, 38, \\n550, 294, 806, 166, 678, 422, 934, 102, 614, 358, 870, 230, 742, 486, \\n998, 22, 534, 278, 790, 150, 662, 406, 918, 86, 598, 342, 854, 214, \\n726, 470, 982, 54, 566, 310, 822, 182, 694, 438, 950, 118, 630, 374, \\n886, 246, 758, 502, 14, 526, 270, 782, 142, 654, 398, 910, 78, 590, \\n334, 846, 206, 718, 462, 974, 46, 558, 302, 814, 174, 686, 430, 942, \\n110, 622, 366, 878, 238, 750, 494, 30, 542, 286, 798, 158, 670, 414, \\n926, 94, 606, 350, 862, 222, 734, 478, 990, 62, 574, 318, 830, 190, \\n702, 446, 958, 126, 638, 382, 894, 254, 766, 510, 1, 513, 257, 769, \\n129, 641, 385, 897, 65, 577, 321, 833, 193, 705, 449, 961, 33, 545, \\n289, 801, 161, 673, 417, 929, 97, 609, 353, 865, 225, 737, 481, 993, \\n17, 529, 273, 785, 145, 657, 401, 913, 81, 593, 337, 849, 209, 721, \\n465, 977, 49, 561, 305, 817, 177, 689, 433, 945, 113, 625, 369, 881, \\n241, 753, 497, 9, 521, 265, 777, 137, 649, 393, 905, 73, 585, 329, \\n841, 201, 713, 457, 969, 41, 553, 297, 809, 169, 681, 425, 937, 105, \\n617, 361, 873, 233, 745, 489, 25, 537, 281, 793, 153, 665, 409, 921, \\n89, 601, 345, 857, 217, 729, 473, 985, 57, 569, 313, 825, 185, 697, \\n441, 953, 121, 633, 377, 889, 249, 761, 505, 5, 517, 261, 773, 133, \\n645, 389, 901, 69, 581, 325, 837, 197, 709, 453, 965, 37, 549, 293, \\n805, 165, 677, 421, 933, 101, 613, 357, 869, 229, 741, 485, 997, 21, \\n533, 277, 789, 149, 661, 405, 917, 85, 597, 341, 853, 213, 725, 469, \\n981, 53, 565, 309, 821, 181, 693, 437, 949, 117, 629, 373, 885, 245, \\n757, 501, 13, 525, 269, 781, 141, 653, 397, 909, 77, 589, 333, 845, \\n205, 717, 461, 973, 45, 557, 301, 813, 173, 685, 429, 941, 109, 621, \\n365, 877, 237, 749, 493, 29, 541, 285, 797, 157, 669, 413, 925, 93, \\n605, 349, 861, 221, 733, 477, 989, 61, 573, 317, 829, 189, 701, 445, \\n957, 125, 637, 381, 893, 253, 765, 509, 3, 515, 259, 771, 131, 643, \\n387, 899, 67, 579, 323, 835, 195, 707, 451, 963, 35, 547, 291, 803, \\n163, 675, 419, 931, 99, 611, 355, 867, 227, 739, 483, 995, 19, 531, \\n275, 787, 147, 659, 403, 915, 83, 595, 339, 851, 211, 723, 467, 979, \\n51, 563, 307, 819, 179, 691, 435, 947, 115, 627, 371, 883, 243, 755, \\n499, 11, 523, 267, 779, 139, 651, 395, 907, 75, 587, 331, 843, 203, \\n715, 459, 971, 43, 555, 299, 811, 171, 683, 427, 939, 107, 619, 363, \\n875, 235, 747, 491, 27, 539, 283, 795, 155, 667, 411, 923, 91, 603, \\n347, 859, 219, 731, 475, 987, 59, 571, 315, 827, 187, 699, 443, 955, \\n123, 635, 379, 891, 251, 763, 507, 7, 519, 263, 775, 135, 647, 391, \\n903, 71, 583, 327, 839, 199, 711, 455, 967, 39, 551, 295, 807, 167, \\n679, 423, 935, 103, 615, 359, 871, 231, 743, 487, 999, 23, 535, 279, \\n791, 151, 663, 407, 919, 87, 599, 343, 855, 215, 727, 471, 983, 55, \\n567, 311, 823, 183, 695, 439, 951, 119, 631, 375, 887, 247, 759, 503, \\n15, 527, 271, 783, 143, 655, 399, 911, 79, 591, 335, 847, 207, 719, \\n463, 975, 47, 559, 303, 815, 175, 687, 431, 943, 111, 623, 367, 879, \\n239, 751, 495, 31, 543, 287, 799, 159, 671, 415, 927, 95, 607, 351, \\n863, 223, 735, 479, 991, 63, 575, 319, 831, 191, 703, 447, 959, 127, \\n639, 383, 895, 255, 767, 511 }; // beautiful\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368251,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ff = {1};\\n        int n1 = 2;\\n        while((int)(ff.size()) < n){\\n            vector<int> odd;\\n            vector<int> even;\\n            // compute odd\\n            for(int i=0;i<(int)ff.size();i++){\\n                if((2*ff[i]) - 1 <= n1){\\n                    odd.push_back(2*(ff[i])-1);  \\n                }\\n            }\\n            // compute even\\n            for(int i=0;i<(int)ff.size();i++){\\n                if((2*ff[i]) <= n1){\\n                    even.push_back(2*(ff[i]));  \\n                }\\n            }\\n            // add both\\n            ff.clear();\\n            for(auto it : odd){\\n                ff.push_back(it);\\n            }\\n            for(auto it : even){\\n                ff.push_back(it);\\n            }\\n            n1+=1;\\n        }\\n        return ff;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ff = {1};\\n        int n1 = 2;\\n        while((int)(ff.size()) < n){\\n            vector<int> odd;\\n            vector<int> even;\\n            // compute odd\\n            for(int i=0;i<(int)ff.size();i++){\\n                if((2*ff[i]) - 1 <= n1){\\n                    odd.push_back(2*(ff[i])-1);  \\n                }\\n            }\\n            // compute even\\n            for(int i=0;i<(int)ff.size();i++){\\n                if((2*ff[i]) <= n1){\\n                    even.push_back(2*(ff[i]));  \\n                }\\n            }\\n            // add both\\n            ff.clear();\\n            for(auto it : odd){\\n                ff.push_back(it);\\n            }\\n            for(auto it : even){\\n                ff.push_back(it);\\n            }\\n            n1+=1;\\n        }\\n        return ff;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 507089,
                "title": "c-6-line-code-100-100",
                "content": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> ans = {1};\\n        while (ans.size() < N) {\\n            vector<int> temp;\\n            for (int i : ans) if (i * 2 - 1 <= N) temp.push_back(i * 2 - 1);\\n            for (int i : ans) if (i * 2 <= N) temp.push_back(i * 2);\\n            ans = temp;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> ans = {1}",
                "codeTag": "Java"
            },
            {
                "id": 3768579,
                "title": "easy-code-for-beginner-with-one-line",
                "content": "# Intuition\\nfirst i done it on 20 lines but now it is one line\\n\\n# Approach\\ndone through simple reccurrsion\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return [1] if n<2 else [i*2-1 for i in self.beautifulArray((n+1)//2)]+[i*2 for i in self.beautifulArray(n//2)]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return [1] if n<2 else [i*2-1 for i in self.beautifulArray((n+1)//2)]+[i*2 for i in self.beautifulArray(n//2)]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3692187,
                "title": "recursive-code",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if (n==1) return {1};\\n        \\n        vector<int> arr = beautifulArray(n-1);\\n\\n        vector<int> res;\\n        for (auto i: arr)\\n            if (2*i - 1 <= n) \\n                res.push_back(2*i-1);\\n\\n        for (auto i: arr)\\n            if (2*i <= n) \\n                res.push_back(2*i);\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if (n==1) return {1};\\n        \\n        vector<int> arr = beautifulArray(n-1);\\n\\n        vector<int> res;\\n        for (auto i: arr)\\n            if (2*i - 1 <= n) \\n                res.push_back(2*i-1);\\n\\n        for (auto i: arr)\\n            if (2*i <= n) \\n                res.push_back(2*i);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1826859,
                "title": "beautiful-array",
                "content": "//weird question no logic responded \\n//just you guys have seen the pattern \\n//**even odd type sequence after running few n=5,6,7 etc  you will understand the pattern..**\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n        vector<int>ans={1};\\n        while(ans.size()<n)\\n        {\\n            vector<int>temp;\\n            //storing the even values \\n            for(auto x : ans)\\n                if(x*2<=n)\\n                    temp.push_back(x*2);\\n            // storing the odd values\\n            for(auto x : ans)\\n                if(x*2-1<=n)\\n                    temp.push_back(x*2-1);\\n            \\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n        vector<int>ans={1}",
                "codeTag": "Java"
            },
            {
                "id": 1506453,
                "title": "c-short-and-simple-explanation",
                "content": "1. If the most left element is even and the most right element is odd, then arr[left] * arr[right] != 2 * arr[i] (it is any number, even or odd, in-between), because expression on the left is always odd and expression on the right is always even.\\n2. Let\\'s think about divide and conquer and get beautiful array for left and right part or array.\\n3. Then make all elements for left part even (multiply all of them to 2 and all elements of right odd (multiply all of them to 2 and substract 1).\\n4. So left and right parts are still beautiful (multiplication and substraction, which we did, will not affect its beauty) and left and right parts become odd and even as well. So concatenation of them will result into beautiful array.\\n\\n```\\nvector<int> beautifulArray(int n) { \\n\\tif (n == 1) return { 1 };\\n\\n\\tauto left = beautifulArray(n / 2);\\n\\tauto right = beautifulArray(n - (n / 2));\\n\\n\\tvector<int> res;\\n\\n\\tfor (auto l : left)\\n\\t\\tres.push_back(l * 2);\\n\\n\\tfor (auto r : right)\\n\\t\\tres.push_back(r * 2 - 1);\\n\\n\\treturn res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> beautifulArray(int n) { \\n\\tif (n == 1) return { 1 };\\n\\n\\tauto left = beautifulArray(n / 2);\\n\\tauto right = beautifulArray(n - (n / 2));\\n\\n\\tvector<int> res;\\n\\n\\tfor (auto l : left)\\n\\t\\tres.push_back(l * 2);\\n\\n\\tfor (auto r : right)\\n\\t\\tres.push_back(r * 2 - 1);\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369666,
                "title": "python-different-o-n-solution-proof",
                "content": "My solution is completely different from what I\\'ve seen a bunch of other people do. Instead of divide and conquer, I build a sequence using repeated interleaving (the `double()` function below).\\n\\nProving that the interleaving works was pretty tricky to do; however, we can easily test that it works for N <= 1000 by making use of the fact that this code works for N = 1000. As we can see that the way the construction works gives the same output as if we just took the output for N=1000 and deleted the elements of the array that are too large. Since it\\'s fairly easy to see that if you take a beautiful array and delete some elements, then the resulting array is still beautiful.\\n\\nA proof, however, that this works for all N is below.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        # We can partition the array into an odd half \\n        # and an even half. This is because the only way \\n        # 2 * nums[k] == nums[i] + nums[j] \\n        # is if nums[i] and nums[j] are the same parity.\\n        \\n        odds = [1, 3]\\n        evens = [2, 4]\\n        \\n        def double(arr):\\n            ans = []\\n            for i in range(len(arr)):\\n                ans.append(arr[i])\\n                ans.append(arr[i] + len(arr) * 2)\\n            return ans\\n        \\n        while len(odds) + len(evens) < n:\\n            odds = double(odds)\\n            evens = double(evens)\\n        \\n\\t\\t# Deleting elements from an array doesn\\'t change whether it\\'s \\n\\t\\t# still beautiful or not.\\n        odds = [v for v in odds if v <= n]\\n        evens = [v for v in evens if v <= n]\\n        return odds + evens\\n```\\n\\nThe space usage is O(N) and the time is also O(N), but this is a bit harder to see. However, we know that `1/2 + 1/4 + 1/8 + ... = 1`, so the `while`-loop in total only takes O(N) time.\\n\\n# **Proof**\\n\\nWe will only prove that our double operation works for the `odds`. Since the `evens` array is just the `odds` array multiplied by 2 and multiplying every number by 2 doesn\\'t affect the beautifulness of an array. **Note that when I say beautiful, I\\'m only refering to the second property.**\\n\\nAssume we have numbers `1, 3, 5, ..., 2(n - 1) + 1`\\n \\nWe can shuffle them into a sequence:\\n \\n`a_1, a_2, ..., a_n`  (sequence 1)\\n \\nRunning `double()` on the above sequence we get:\\n \\n`a_1, a_1 + 2n, a_2, a_2 + 2n, ..., a_n, a_n + 2n` (sequence 2)\\n \\nRunning `double()` a second time we get\\n \\n`a_1, a_1 + 4n, a_1 + 2n, a_1 + 6n, a_2, a_2 + 4n, a_2 + 2n, a_2 + 6n, ..., a_n, a_n + 4n, a_n + 2n, a_n + 6n` (sequence 3)\\n\\n#### Theorem\\n\\nGiven that sequence 1 and 2 are beautiful, we can show that sequence 3 is beautiful too.\\n\\nIf we use [1, 3] and [1, 5, 3, 7] as sequences 1 and 2, respective, then this theorem means that the algorithm works for all N.\\n\\n#### Proof\\nUsing a proof by contraction: Let\\'s assume that sequence 3 isn\\'t beautiful. Then we have,\\n`a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)` where `i <= k <= j`\\n\\nNote that `{0,2,4,6}_i` means that we choose one value from 0, 2, 4 or 6. This is to account for the `+ 0`, `+ 2n`, `+ 4n` and `+ 6n` factors in sequence 3.\\n\\nNow we have 4 cases for `i <= k <= j` to consider.\\n \\n**Case 1**: If `a_i = a_k = a_j`:\\n```\\n   a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> a_i + {0,2,4,6}_i*n + a_i + {0,2,4,6}_j*n = 2(a_i + {0,2,4,6}_k*n)\\n=> {0,2,4,6}_i*n + {0,2,4,6}_j*n = 2{0,2,4,6}_k*n\\n```\\n\\nThis is a contradiction as `{0,2,4,6}_i, {0,2,4,6}_k, {0,2,4,6}_j` is some subsequence of [0, 4, 2, 6], but subsequences of beautiful arrays are beautiful.\\n \\n**Case 2**: If `a_i = a_k` and `a_i != a_j`:\\n```\\n   a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_i + {0,2,4,6}_k*n)\\n=> {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = a_i + {0,2,4,6}_k*n\\n=> a_j - a_i = {0,2,4,6}_k*n - {0,2,4,6}_i*n - {0,2,4,6}_j*n\\n```\\n \\nThe LHS is non-zero as `a_i != a_j`. So the RHS must be non-zero too.\\n \\nThe largest *absolute* (i.e., non-negative) value of the LHS is `(2(n - 1) + 1) - 1 = 2n - 2` as we maximize the difference between `a_j` and `a_i` by choosing the smallest and largest possible values.\\n\\nThe smallest non-zero *absolute* value of the RHS is `2n`.\\n \\nTherefore, the equality can never hold and we have a contradiction as the largest absolute value of the LHS is strictly less than the smallest absolute value of the RHS.\\n \\n**Case 3**: If `a_j = a_k` and `a_i != a_j`:\\nSame as argument as case 2.\\n \\n**Case 4**: if `i < k < j`:\\n```\\n    a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> 2a_k - a_i - a_j = 2{0,2,4,6}_k*n - {0,2,4,6}_i*n - {0,2,4,6}_j*n\\n ```\\n \\nThe LHS should be non-zero or sequence 1 would be not beautiful. As `2a_k - a_i - a_j = 0` implies `a_i + a_j  = 2a_k`\\n \\nThe greatest the LHS\\'s absolute value can be is `|1 - (2(n-1) - 1) - (2(n-1) - 3)| = |1 - 2n + 3 - 2n + 5| = 4n - 9`. We maximize this by chosing the 2 largest values (for `a_i` and `a_j`) and the smallest value (for `a_k`).\\nThe absolute value of the RHS is at least `2n`. \\n \\nTherefore, RHS absolute value is `2n` and, thus, either `a_i + a_j = 2a_k + 2n` (case 4a) holds or `a_i + a_j = 2a_k - 2n` (case 4b) holds\\n \\n**Case 4a**: `a_i + a_j = 2a_k + 2n`\\n```\\n   a_i + a_j = 2a_k + 2n\\n=> a_i + a_j + 2n = 2a_k + 4n = 2(a_k + 2n)\\n```\\n\\nHowever, if this is true then sequence 2 isn\\'t beautiful, which is a contradiction. This is because we can use the numbers `a_i` and `a_j + 2n` and `a_k + 2n` in sequence 2 and we know from i < k < j, that `a_k + 2n`  lies between `a_i` and `a_j + 2n`. \\n \\n**Case 4b**: `a_i + a_j = 2a_k - 2n`\\n```\\n   a_i + a_j = 2a_k - 2n\\n=> a_i + a_j + 2n = 2a_k\\n```\\n\\nHowever, if this is true then sequence 2 isn\\'t beautiful. Again, like in case 4a, this is because we can use the numbers `a_i` and `a_j + 2n` and `a_k` in sequence 2.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        # We can partition the array into an odd half \\n        # and an even half. This is because the only way \\n        # 2 * nums[k] == nums[i] + nums[j] \\n        # is if nums[i] and nums[j] are the same parity.\\n        \\n        odds = [1, 3]\\n        evens = [2, 4]\\n        \\n        def double(arr):\\n            ans = []\\n            for i in range(len(arr)):\\n                ans.append(arr[i])\\n                ans.append(arr[i] + len(arr) * 2)\\n            return ans\\n        \\n        while len(odds) + len(evens) < n:\\n            odds = double(odds)\\n            evens = double(evens)\\n        \\n\\t\\t# Deleting elements from an array doesn\\'t change whether it\\'s \\n\\t\\t# still beautiful or not.\\n        odds = [v for v in odds if v <= n]\\n        evens = [v for v in evens if v <= n]\\n        return odds + evens\\n```\n```\\n   a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> a_i + {0,2,4,6}_i*n + a_i + {0,2,4,6}_j*n = 2(a_i + {0,2,4,6}_k*n)\\n=> {0,2,4,6}_i*n + {0,2,4,6}_j*n = 2{0,2,4,6}_k*n\\n```\n```\\n   a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_i + {0,2,4,6}_k*n)\\n=> {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = a_i + {0,2,4,6}_k*n\\n=> a_j - a_i = {0,2,4,6}_k*n - {0,2,4,6}_i*n - {0,2,4,6}_j*n\\n```\n```\\n    a_i + {0,2,4,6}_i*n + a_j + {0,2,4,6}_j*n = 2(a_k + {0,2,4,6}_k*n)\\n=> 2a_k - a_i - a_j = 2{0,2,4,6}_k*n - {0,2,4,6}_i*n - {0,2,4,6}_j*n\\n ```\n```\\n   a_i + a_j = 2a_k + 2n\\n=> a_i + a_j + 2n = 2a_k + 4n = 2(a_k + 2n)\\n```\n```\\n   a_i + a_j = 2a_k - 2n\\n=> a_i + a_j + 2n = 2a_k\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368199,
                "title": "python3-recursive-one-liner",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return (\\n            [1, 2][:n]\\n            if n < 3\\n            else [x * 2 - 1 for x in self.beautifulArray((n + 1) // 2)]\\n            + [x * 2 for x in self.beautifulArray(n // 2)]\\n        )\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        return (\\n            [1, 2][:n]\\n            if n < 3\\n            else [x * 2 - 1 for x in self.beautifulArray((n + 1) // 2)]\\n            + [x * 2 for x in self.beautifulArray(n // 2)]\\n        )\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367890,
                "title": "932-beautiful-array-python-24ms",
                "content": "```\\nimport functools\\n\\nfdict = {}\\nfdict[1] = [1]\\nfdict[2] = [1,2]\\nfdict[3] = [1,3,2]\\nfdict[4] = [2,1,4,3]\\nfdict[5] = [3,1,2,5,4]\\n\\n@functools.cache\\ndef f(n):\\n    if n < 6:\\n        return fdict[n]\\n    return [2*x-1 for x in f(n//2+n%2)] + [2*x for x in f(n//2)] \\n```\\n\\nNote that an even and odd number always sum to an odd number, which will not interfere with any numbers in between. So we can split the array into [odd numbers, even numbers] which will be beautiful as long as the odd and even sections are individually beautiful. \\n\\nNote that \"beauty\" does not change when numbers are scaled linearly. \\n```(a*i + b) + (a*j + b) = a*(i+j) + 2b ?= a*(2k) + 2b = 2(a*k+b)```\\nFor i+j = 2k, scaled i + scaled j = 2*(scaled k). So the odd and even sections can be made beautiful by using our beautiful array function recursively. \\n\\nThe cache is used to save time when using this function multiple times, and some (more than necessary) base cases are included to aid with the recursion.",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nimport functools\\n\\nfdict = {}\\nfdict[1] = [1]\\nfdict[2] = [1,2]\\nfdict[3] = [1,3,2]\\nfdict[4] = [2,1,4,3]\\nfdict[5] = [3,1,2,5,4]\\n\\n@functools.cache\\ndef f(n):\\n    if n < 6:\\n        return fdict[n]\\n    return [2*x-1 for x in f(n//2+n%2)] + [2*x for x in f(n//2)] \\n```\n```(a*i + b) + (a*j + b) = a*(i+j) + 2b ?= a*(2k) + 2b = 2(a*k+b)```",
                "codeTag": "Python3"
            },
            {
                "id": 1004873,
                "title": "simplest-and-fastest-c-code-with-explanation",
                "content": "```\\n//EXPLANATION\\n/*\\nstart with 1 size array called result= [1]\\nwhile(size<=N){\\n    make a temp array for this iteration\\n    PUSH ODD NUMBERS from result array\\n    for(extract numbers from result array){\\n        let i = extracted number,say 1 and 2*i-1<N\\n        push(2*1-1)into temp array, temp = {1}\\n    }\\n    PUSH EVEN NUMBERS from result array\\n    for(extract numbers from result array){\\n        let i = extracted number,say 1 and 2*i-1<N\\n        push(2*1)into temp array, temp = {1,2}\\n    }\\n    new result array = temp \\n}\\nNEXT ITERATIONS\\n[1,2]=>Enter while loop =>first for loop, push 2*i-1=1(i=1),then 2*i-1=2*2-1=3 =>{1,3}\\n    Enter second while loop => (2*1=2),(2*2=4)={1,3,2,4}\\n[1,3,2,4] => {2*1-1,2*3-1,2*2-1,2*4-1}={1,5,3,7} and even=>{2*1,2*2,2*2,2*4}=>{2,6,4,8}\\n            => {1,5,3,7,2,6,4,8}\\n[1,5,3,7,2,4,6,8]......................and so on\\n\\n\\n\\n*/\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> result = {1};\\n        while(result.size()<N){\\n            vector<int> temp;\\n            for(int i : result)\\n                if(i*2-1 <= N)\\n                    temp.push_back(i*2-1);\\n            for(int i:result)\\n                if(i*2 <= N)\\n                    temp.push_back(i*2);\\n            \\n            result = temp;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n//EXPLANATION\\n/*\\nstart with 1 size array called result= [1]\\nwhile(size<=N){\\n    make a temp array for this iteration\\n    PUSH ODD NUMBERS from result array\\n    for(extract numbers from result array){\\n        let i = extracted number,say 1 and 2*i-1<N\\n        push(2*1-1)into temp array, temp = {1}\\n    }\\n    PUSH EVEN NUMBERS from result array\\n    for(extract numbers from result array){\\n        let i = extracted number,say 1 and 2*i-1<N\\n        push(2*1)into temp array, temp = {1,2}\\n    }\\n    new result array = temp \\n}\\nNEXT ITERATIONS\\n[1,2]=>Enter while loop =>first for loop, push 2*i-1=1(i=1),then 2*i-1=2*2-1=3 =>{1,3}\\n    Enter second while loop => (2*1=2),(2*2=4)={1,3,2,4}\\n[1,3,2,4] => {2*1-1,2*3-1,2*2-1,2*4-1}={1,5,3,7} and even=>{2*1,2*2,2*2,2*4}=>{2,6,4,8}\\n            => {1,5,3,7,2,6,4,8}\\n[1,5,3,7,2,4,6,8]......................and so on\\n\\n\\n\\n*/\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> result = {1};\\n        while(result.size()<N){\\n            vector<int> temp;\\n            for(int i : result)\\n                if(i*2-1 <= N)\\n                    temp.push_back(i*2-1);\\n            for(int i:result)\\n                if(i*2 <= N)\\n                    temp.push_back(i*2);\\n            \\n            result = temp;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 812831,
                "title": "beautiful-array-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> result = {1};\\n        while(result.size()<N){\\n            vector<int> temp;\\n            for(int i : result)\\n                if(i*2-1 <= N)\\n                    temp.push_back(i*2-1);\\n            for(int i:result)\\n                if(i*2 <= N)\\n                    temp.push_back(i*2);\\n            \\n            result = temp;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> result = {1};\\n        while(result.size()<N){\\n            vector<int> temp;\\n            for(int i : result)\\n                if(i*2-1 <= N)\\n                    temp.push_back(i*2-1);\\n            for(int i:result)\\n                if(i*2 <= N)\\n                    temp.push_back(i*2);\\n            \\n            result = temp;\\n            \\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233410,
                "title": "c-recursive-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res,v;\\n        for(int i=1;i<=N;i++)v.push_back(i);\\n        helper(res,v);\\n        return res;   \\n    }\\n    void helper(vector<int>&res,vector<int> v)\\n    {\\n        int size=v.size();\\n        if(size==1)res.push_back(v[0]);\\n        else\\n        {\\n            vector<int> odd,even;\\n            for(int i=0;i<size;i++)i%2?odd.push_back(v[i]):even.push_back(v[i]);\\n            helper(res,even);\\n            helper(res,odd);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res,v;\\n        for(int i=1;i<=N;i++)v.push_back(i);\\n        helper(res,v);\\n        return res;   \\n    }\\n    void helper(vector<int>&res,vector<int> v)\\n    {\\n        int size=v.size();\\n        if(size==1)res.push_back(v[0]);\\n        else\\n        {\\n            vector<int> odd,even;\\n            for(int i=0;i<size;i++)i%2?odd.push_back(v[i]):even.push_back(v[i]);\\n            helper(res,even);\\n            helper(res,odd);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186819,
                "title": "short-java-solution",
                "content": "\\nCredit goes to: https://leetcode.com/problems/beautiful-array/discuss/186679/C++JavaPython-Odd-+-Even-Pattern-O(N)\\n```\\n    public int[] beautifulArray(int N) {\\n        int[] cache = new int[2*N], ret = new int[N];\\n        cache[0] = 1;\\n        \\n        int l = 1;\\n        while(l < N) {\\n            for(int i = 0; i < l; i++) cache[i] *= 2;\\n            for(int i = l; i < l * 2; i++) cache[i] = cache[i-l] - 1;\\n            l *= 2;\\n        }\\n        \\n        int j = 0;\\n        for(int i = 0; i < l; i++) if(cache[i] <= N) ret[j++] = cache[i];\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] beautifulArray(int N) {\\n        int[] cache = new int[2*N], ret = new int[N];\\n        cache[0] = 1;\\n        \\n        int l = 1;\\n        while(l < N) {\\n            for(int i = 0; i < l; i++) cache[i] *= 2;\\n            for(int i = l; i < l * 2; i++) cache[i] = cache[i-l] - 1;\\n            l *= 2;\\n        }\\n        \\n        int j = 0;\\n        for(int i = 0; i < l; i++) if(cache[i] <= N) ret[j++] = cache[i];\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 186724,
                "title": "python-solution",
                "content": "# solution\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, N):\\n        a = list(range(1, N + 1))\\n        return self.r_fun(a)\\n        pass\\n\\n    def r_fun(self, a):\\n        if len(a) <= 1:\\n            return a\\n        odd = [v for idx, v in enumerate(a) if idx % 2 == 1]\\n        even = [v for idx, v, in enumerate(a) if idx % 2 == 0]\\n        odd = self.r_fun(odd)\\n        even = self.r_fun(even)\\n        return odd + even\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N):\\n        a = list(range(1, N + 1))\\n        return self.r_fun(a)\\n        pass\\n\\n    def r_fun(self, a):\\n        if len(a) <= 1:\\n            return a\\n        odd = [v for idx, v in enumerate(a) if idx % 2 == 1]\\n        even = [v for idx, v, in enumerate(a) if idx % 2 == 0]\\n        odd = self.r_fun(odd)\\n        even = self.r_fun(even)\\n        return odd + even\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3521764,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res = {1};\\n        while(res.size() != n){\\n            vector<int> temp;\\n            for(auto &ele : res) if(ele*2-1<=n) temp.push_back(ele*2-1);\\n            for(auto &ele : res) if(ele*2<=n) temp.push_back(ele*2);\\n            res = temp;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        res=[1]\\n        while len(res)<n :\\n            odd=[2*i-1 for i in res]\\n            even=[2*i for i in res]\\n            res=odd+even\\n        return [i for i in res if i<=n]\\n```\\n\\n```Java []\\nclass Solution {\\n    Map<Integer, int[]> memo;\\n    public int[] beautifulArray(int N) {\\n        memo = new HashMap();\\n        return f(N);\\n    }\\n    public int[] f(int N) {\\n        if (memo.containsKey(N))\\n            return memo.get(N);\\n\\n        int[] ans = new int[N];\\n        if (N == 1) {\\n            ans[0] = 1;\\n        } else {\\n            int t = 0;\\n            for (int x: f((N+1)/2))\\n                ans[t++] = 2*x - 1;\\n            for (int x: f(N/2))\\n                ans[t++] = 2*x;\\n        }\\n        memo.put(N, ans);\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res = {1};\\n        while(res.size() != n){\\n            vector<int> temp;\\n            for(auto &ele : res) if(ele*2-1<=n) temp.push_back(ele*2-1);\\n            for(auto &ele : res) if(ele*2<=n) temp.push_back(ele*2);\\n            res = temp;\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        res=[1]\\n        while len(res)<n :\\n            odd=[2*i-1 for i in res]\\n            even=[2*i for i in res]\\n            res=odd+even\\n        return [i for i in res if i<=n]\\n```\n```Java []\\nclass Solution {\\n    Map<Integer, int[]> memo;\\n    public int[] beautifulArray(int N) {\\n        memo = new HashMap();\\n        return f(N);\\n    }\\n    public int[] f(int N) {\\n        if (memo.containsKey(N))\\n            return memo.get(N);\\n\\n        int[] ans = new int[N];\\n        if (N == 1) {\\n            ans[0] = 1;\\n        } else {\\n            int t = 0;\\n            for (int x: f((N+1)/2))\\n                ans[t++] = 2*x - 1;\\n            for (int x: f(N/2))\\n                ans[t++] = 2*x;\\n        }\\n        memo.put(N, ans);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3259787,
                "title": "c-code-easy-to-understand",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n == 1) return {1};\\n        vector<int> ans = {1};\\n\\n        while(ans.size()<n){\\n            vector< int> temp;\\n\\n            for(int it: ans){\\n                if((it*2)-1 <= n) temp.push_back(it*2-1);\\n            }\\n\\n            for(int it: ans){\\n                if((it*2) <= n) temp.push_back(it*2);\\n            }\\n\\n            for(int it: ans){\\n                cout<<it<<\" \";\\n            }\\n            cout<<endl;\\n\\n            ans = temp;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n == 1) return {1};\\n        vector<int> ans = {1};\\n\\n        while(ans.size()<n){\\n            vector< int> temp;\\n\\n            for(int it: ans){\\n                if((it*2)-1 <= n) temp.push_back(it*2-1);\\n            }\\n\\n            for(int it: ans){\\n                if((it*2) <= n) temp.push_back(it*2);\\n            }\\n\\n            for(int it: ans){\\n                cout<<it<<\" \";\\n            }\\n            cout<<endl;\\n\\n            ans = temp;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2587160,
                "title": "java-solution-ugly-array-oops-it-s-beautiful-need-help-with-the-time-space-complexity",
                "content": "### Please Upvote !!!\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(1);\\n\\n        while (list.size() < n) {\\n            List<Integer> temp = new ArrayList<>();\\n\\n            for (int i : list) {\\n                if (2*i -1 <= n) temp.add(2*i - 1);\\n            }\\n\\n            for (int i : list) {\\n                if (2*i <= n) temp.add(2 * i);\\n            }\\n\\n            list = temp;\\n        }\\n\\n        return list.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        List<Integer> list = new ArrayList<>();\\n        list.add(1);\\n\\n        while (list.size() < n) {\\n            List<Integer> temp = new ArrayList<>();\\n\\n            for (int i : list) {\\n                if (2*i -1 <= n) temp.add(2*i - 1);\\n            }\\n\\n            for (int i : list) {\\n                if (2*i <= n) temp.add(2 * i);\\n            }\\n\\n            list = temp;\\n        }\\n\\n        return list.stream().mapToInt(i -> i).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2158740,
                "title": "java-understandable-solution",
                "content": "We can see that if we seperate odd and even number then there is no possibility that even numbers will voilate rule with odd number and vice versa. Now we have to arrange even and odd numbers is such a way that they do not voilate rule with themselves. For doing so first let say we have a beautiful array of length n and we want to make n+1 size of array so what we do is first put all odd number that lie within 1 to n+1 and then even(WE can do even then odd also) . Beautiful array has property that if we multiply any number with array then it still remains beautiful or if we add or subtract any number from array then it still remains beautiful. For for only obtaining even number from n size array we do 2* num and for obtaining odd size array we do 2 * n-1 .\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer>ans=new ArrayList<>();\\n        ans.add(1);\\n        \\n        for(int i=2;i<=n;i++){\\n            ArrayList<Integer>temp=new ArrayList<>();\\n            for(Integer e:ans){\\n                if(2*e<=n)temp.add(e*2);\\n            }\\n            for(Integer e:ans){\\n                if(2*e-1<=n)temp.add(e*2-1);\\n            }\\n            \\n            ans=temp;\\n        }\\n        \\n        int []arr=new int[n];\\n        int k=0;\\n        for(Integer i:ans){\\n            arr[k++]=i;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer>ans=new ArrayList<>();\\n        ans.add(1);\\n        \\n        for(int i=2;i<=n;i++){\\n            ArrayList<Integer>temp=new ArrayList<>();\\n            for(Integer e:ans){\\n                if(2*e<=n)temp.add(e*2);\\n            }\\n            for(Integer e:ans){\\n                if(2*e-1<=n)temp.add(e*2-1);\\n            }\\n            \\n            ans=temp;\\n        }\\n        \\n        int []arr=new int[n];\\n        int k=0;\\n        for(Integer i:ans){\\n            arr[k++]=i;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891168,
                "title": "c-solution-divide-and-conquer",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n == 1) return vector<int>{1};\\n\\n        int evens = n/2;\\n        int odds = n-evens;\\n        auto oddarr = beautifulArray(odds);\\n        auto evenarr = beautifulArray(evens);\\n        vector<int> ans(n);\\n        int i = 0;\\n        for(int j:oddarr) ans[i++] = 2*(j-1)+1;\\n        for(int j:evenarr) ans[i++] = 2*j;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n == 1) return vector<int>{1};\\n\\n        int evens = n/2;\\n        int odds = n-evens;\\n        auto oddarr = beautifulArray(odds);\\n        auto evenarr = beautifulArray(evens);\\n        vector<int> ans(n);\\n        int i = 0;\\n        for(int j:oddarr) ans[i++] = 2*(j-1)+1;\\n        for(int j:evenarr) ans[i++] = 2*j;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744094,
                "title": "simple-python-solution-divide-and-conquer",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        \\n        def divide(N):\\n            if N == 1:\\n                return [1]\\n            \\n            odds = divide(N//2 + N%2)\\n            even = divide(N//2)\\n            \\n            return [2*x-1 for x in odds] + [2*x for x in even]\\n        \\n        return divide(n)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        \\n        def divide(N):\\n            if N == 1:\\n                return [1]\\n            \\n            odds = divide(N//2 + N%2)\\n            even = divide(N//2)\\n            \\n            return [2*x-1 for x in odds] + [2*x for x in even]\\n        \\n        return divide(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590422,
                "title": "c-o-n-2-o-n-100-99-72-beautiful-binary-tree-https-leetcode-com-nduru",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n        int a[n*2];\\n        int b[n*2];\\n        a[0] = 0;\\n        int *r =  a;\\n        int *r1 = b;\\n        for(int i = 1; i<=n; i*=2)\\n        {\\n            int *t = r;\\n            r = r1;\\n            r1 = t;\\n            for (int j=0,l=0; j<i; j++,l+=2)\\n            {\\n                r[l] = r1[j];                \\n                r[l+1] = r1[j]+i;\\n                // cout  << \", \" << r[l] << \", \" << r[l+1];\\n            }\\n            // cout << endl;\\n        }\\n        vector<int> ans(n);\\n        for(int i = 1, j = 0; j<n; i++)\\n        {\\n            if (r[i] <= n)\\n                ans[j++] = r[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n        int a[n*2];\\n        int b[n*2];\\n        a[0] = 0;\\n        int *r =  a;\\n        int *r1 = b;\\n        for(int i = 1; i<=n; i*=2)\\n        {\\n            int *t = r;\\n            r = r1;\\n            r1 = t;\\n            for (int j=0,l=0; j<i; j++,l+=2)\\n            {\\n                r[l] = r1[j];                \\n                r[l+1] = r1[j]+i;\\n                // cout  << \", \" << r[l] << \", \" << r[l+1];\\n            }\\n            // cout << endl;\\n        }\\n        vector<int> ans(n);\\n        for(int i = 1, j = 0; j<n; i++)\\n        {\\n            if (r[i] <= n)\\n                ans[j++] = r[i];\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1369750,
                "title": "c-solution",
                "content": "**Intuition**\\n\\nIf there are two arrays ```A:[A1, A2, ..., An]``` that only has odd numbers and ```B:[B1, B2, ..., Bn]``` that only has even numbers. If we merge them as ```C:[A1, A2, ..., An,B1, B2, ..., Bn]```, then there won\\'t be any number pair ```A[i]``` and ```B[j]```, such that ```A[i] + B[j] = 2 * C[k]```, because ```A[i] + B[j]``` will always be odd, while ```2 * C[k]``` will always be even. This property ensures the first and second parts of ```C``` follow the beautiful array rule. Let\\'s call it Mege property.\\n\\nNow we need to make sure ```A``` and ```B``` themselves are beautiful arrays. We can achieve this by gradually expanding an exisiting beautiful array to get ```A``` and ```B```. If array ```N:[N1, N2, ..., Nn]``` is a beautiful array, then it has below 3 properties:\\n1. Deletion property: After deleting some numbers from ```N```, the new array ```N\\'``` will still be a beautiful array.\\n2. Addition property: ```N\\':[N1+k, N2+k, ..., Nn+k]``` will still be a beautiful array. \\n3. Multiplication property: ```N\\':[N1*k, N2*k, ..., Nn*k]``` will still be a beautiful array. \\n\\nThe three properties together with merge property can be used to expand a beautiful array. For example, ```N:[N1]``` is a beautiful array.\\n\\n* According to propety 2 and 3, ```N\\': [N1 * 2 - 1]``` and ```N\\'\\': [N1 * 2]``` are beautiful arrays.\\n* We can use property 1 to build ```N\\'``` and ```N\\'\\'``` based on the original array ```N```.\\n* Then we merge ```N\\'``` and ```N\\'\\'``` will be a new beautiful array, which double the length of the original array.\\n\\n\\n```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n     \\n        List<int> res = new List<int>(){1};\\n        \\n        while(res.Count < n)\\n        {\\n            List<int> odd = new List<int>();\\n            List<int> even = new List<int>();\\n            \\n            // expand an existing beautiful array to new beautiful array and double the size \\n            foreach(var num in res)\\n            {\\n                // ensure all the numbers in the new beautiful array still within [1,n]\\n                if(2 * num - 1 <= n)\\n                    odd.Add(2 * num - 1);\\n                \\n                if(2 * num <= n)\\n                    even.Add(2 * num);\\n            }\\n            \\n            // use  merge rule to merge the odd and even arrays. This will double the size of the beautiful array.\\n            odd.AddRange(even);\\n            // update the result\\n            res = odd;\\n        }\\n        \\n        return res.ToArray(); \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```A:[A1, A2, ..., An]```\n```B:[B1, B2, ..., Bn]```\n```C:[A1, A2, ..., An,B1, B2, ..., Bn]```\n```A[i]```\n```B[j]```\n```A[i] + B[j] = 2 * C[k]```\n```A[i] + B[j]```\n```2 * C[k]```\n```C```\n```A```\n```B```\n```A```\n```B```\n```N:[N1, N2, ..., Nn]```\n```N```\n```N\\'```\n```N\\':[N1+k, N2+k, ..., Nn+k]```\n```N\\':[N1*k, N2*k, ..., Nn*k]```\n```N:[N1]```\n```N\\': [N1 * 2 - 1]```\n```N\\'\\': [N1 * 2]```\n```N\\'```\n```N\\'\\'```\n```N```\n```N\\'```\n```N\\'\\'```\n```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n     \\n        List<int> res = new List<int>(){1};\\n        \\n        while(res.Count < n)\\n        {\\n            List<int> odd = new List<int>();\\n            List<int> even = new List<int>();\\n            \\n            // expand an existing beautiful array to new beautiful array and double the size \\n            foreach(var num in res)\\n            {\\n                // ensure all the numbers in the new beautiful array still within [1,n]\\n                if(2 * num - 1 <= n)\\n                    odd.Add(2 * num - 1);\\n                \\n                if(2 * num <= n)\\n                    even.Add(2 * num);\\n            }\\n            \\n            // use  merge rule to merge the odd and even arrays. This will double the size of the beautiful array.\\n            odd.AddRange(even);\\n            // update the result\\n            res = odd;\\n        }\\n        \\n        return res.ToArray(); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369611,
                "title": "javascript-simple-solution",
                "content": "Thanks to [@lee215](https://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N))\\n```\\n\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar beautifulArray = function(n) {\\n    let arr = []\\n    arr.push(1)\\n    while(arr.length < n){\\n        let tmp = []\\n        for(const i of arr) if(i*2-1 <= n) tmp.push(i*2-1)\\n        for(const i of arr) if(i*2 <= n) tmp.push(i*2)\\n        arr = tmp\\n    }\\n\\n    \\n    return arr\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\n/**\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar beautifulArray = function(n) {\\n    let arr = []\\n    arr.push(1)\\n    while(arr.length < n){\\n        let tmp = []\\n        for(const i of arr) if(i*2-1 <= n) tmp.push(i*2-1)\\n        for(const i of arr) if(i*2 <= n) tmp.push(i*2)\\n        arr = tmp\\n    }\\n\\n    \\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369602,
                "title": "easy-java-solution-with-1-solved-example",
                "content": "```\\nclass Solution {\\n/*\\n    split the input array into two arrays of alternate numbers,\\n    recurse on those to splitted arrays and combine them\\n            [1,2,3,4,5,6,7]    \\n        [1,3,5, 7]         [2,4,6]\\n      [1, 5]  [3,7]      [2, 6] [4]\\n      [1, 5, 3, 7]       [2, 6, 4]\\n            [1,5,3,7,2,6,4] \\n*/\\n    public int[] beautifulArray(int n) {\\n        int[] arr = new int[n];\\n        for(int i=0; i < n; i++)\\n            arr[i] = i+1;\\n        return beautify(arr);\\n    }\\n    \\n    private int[] beautify(int[] arr){\\n        if(arr.length <= 2)\\n            return arr;\\n        int n = arr.length;\\n        int[] leftArray = new int[(n+1)/2];\\n        int[] rightArray = new int[n/2];\\n        \\n        populateAlternateLeftAndRight(leftArray, rightArray, arr);\\n        \\n        leftArray = beautify(leftArray);\\n        rightArray = beautify(rightArray);\\n        \\n        return concatenate(leftArray, rightArray);\\n    }\\n    \\n    void populateAlternateLeftAndRight(int[] left, int[] right, int[] arr){\\n        for(int i=0; i < arr.length; i++){\\n            if(i % 2 == 0)\\n                left[i/2] = arr[i];\\n            else\\n                right[i/2] = arr[i];\\n        }\\n    }\\n    \\n    int[] concatenate(int[] arr1, int[] arr2){\\n        int[] combinedArr = new int[arr1.length + arr2.length];\\n        copyToArr(arr1, 0, combinedArr);\\n        copyToArr(arr2, arr1.length, combinedArr);\\n        return combinedArr;\\n    }\\n    \\n    void copyToArr(int[] source, int start, int[] target){\\n        for(int i=0; i < source.length; i++)\\n            target[start++] = source[i];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n/*\\n    split the input array into two arrays of alternate numbers,\\n    recurse on those to splitted arrays and combine them\\n            [1,2,3,4,5,6,7]    \\n        [1,3,5, 7]         [2,4,6]\\n      [1, 5]  [3,7]      [2, 6] [4]\\n      [1, 5, 3, 7]       [2, 6, 4]\\n            [1,5,3,7,2,6,4] \\n*/\\n    public int[] beautifulArray(int n) {\\n        int[] arr = new int[n];\\n        for(int i=0; i < n; i++)\\n            arr[i] = i+1;\\n        return beautify(arr);\\n    }\\n    \\n    private int[] beautify(int[] arr){\\n        if(arr.length <= 2)\\n            return arr;\\n        int n = arr.length;\\n        int[] leftArray = new int[(n+1)/2];\\n        int[] rightArray = new int[n/2];\\n        \\n        populateAlternateLeftAndRight(leftArray, rightArray, arr);\\n        \\n        leftArray = beautify(leftArray);\\n        rightArray = beautify(rightArray);\\n        \\n        return concatenate(leftArray, rightArray);\\n    }\\n    \\n    void populateAlternateLeftAndRight(int[] left, int[] right, int[] arr){\\n        for(int i=0; i < arr.length; i++){\\n            if(i % 2 == 0)\\n                left[i/2] = arr[i];\\n            else\\n                right[i/2] = arr[i];\\n        }\\n    }\\n    \\n    int[] concatenate(int[] arr1, int[] arr2){\\n        int[] combinedArr = new int[arr1.length + arr2.length];\\n        copyToArr(arr1, 0, combinedArr);\\n        copyToArr(arr2, arr1.length, combinedArr);\\n        return combinedArr;\\n    }\\n    \\n    void copyToArr(int[] source, int start, int[] target){\\n        for(int i=0; i < source.length; i++)\\n            target[start++] = source[i];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369232,
                "title": "c-solution-o-n",
                "content": "Runtime: 4 ms, faster than 74.56% of C++ online submissions for Beautiful Array.\\nMemory Usage: 7.1 MB, less than 74.91% of C++ online submissions for Beautiful Array.\\n\\n\\n**Note** : Solution taken from other posts\\n\\n```\\nHere we need i<k<j such that A[k] * 2 != A[i] + A[j]\\nNow odd + even => odd which has no Integer when divided and so we can partition array in to 2 part\\nsuch that all odds are at the left half and all even are in the right half. Now odds and even list can mismatch\\nthe given condition also. Observation-\\n1. Beatiful array + c => Beautiful array\\n2. Beautiful array * c=> Beautiful array \\n3. Odd and even partition array can be Beautiful array\\n\\nUsing these properties we can build up the Beautiful array with initial array containing 1 only. \\n1. Add all values as Array A * 2 -1 in to temp which actually all odd values generated from current Beautiful array \\n2. Add all values as Array A * 2  in to temp which actually all even values generated from current Beautiful array \\n\\nHere we first add all odd and then the even values. So the result also stays Beautiful.\\n```\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        \\n        // initial beatiful array\\n        vector<int>res={1};\\n        \\n        // loop until all N values are generated\\n        while(res.size()<N)\\n        {\\n            vector<int>temp;\\n            \\n            // push all odd values generated from current beautiful array\\n            for(auto &x : res)if(x*2-1 <=N)temp.push_back(x*2-1);\\n            \\n            // push all even values generated from current beautiful array\\n            for(auto &x : res)if(x*2 <=N)temp.push_back(x*2);\\n            \\n            // swap result\\n            res=temp;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Array",
                    "Math"
                ],
                "code": "```\\nHere we need i<k<j such that A[k] * 2 != A[i] + A[j]\\nNow odd + even => odd which has no Integer when divided and so we can partition array in to 2 part\\nsuch that all odds are at the left half and all even are in the right half. Now odds and even list can mismatch\\nthe given condition also. Observation-\\n1. Beatiful array + c => Beautiful array\\n2. Beautiful array * c=> Beautiful array \\n3. Odd and even partition array can be Beautiful array\\n\\nUsing these properties we can build up the Beautiful array with initial array containing 1 only. \\n1. Add all values as Array A * 2 -1 in to temp which actually all odd values generated from current Beautiful array \\n2. Add all values as Array A * 2  in to temp which actually all even values generated from current Beautiful array \\n\\nHere we first add all odd and then the even values. So the result also stays Beautiful.\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        \\n        // initial beatiful array\\n        vector<int>res={1};\\n        \\n        // loop until all N values are generated\\n        while(res.size()<N)\\n        {\\n            vector<int>temp;\\n            \\n            // push all odd values generated from current beautiful array\\n            for(auto &x : res)if(x*2-1 <=N)temp.push_back(x*2-1);\\n            \\n            // push all even values generated from current beautiful array\\n            for(auto &x : res)if(x*2 <=N)temp.push_back(x*2);\\n            \\n            // swap result\\n            res=temp;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369183,
                "title": "c-linq-solution",
                "content": "C# LINQ solution inspired by @lee215\\'s Python list comprehension solution.\\n\\n```res``` is doubled in size after each iteration of the ```while``` loop, keeping odd numbers on the left and evens on the right, making the time complexity O(n log n). At the end, any numbers greater than n are pruned.\\n\\nLoop iterations:\\n```\\n[1]\\n[1,2]\\n[1,3,2,4]\\n[1,5,3,7,2,6,4,8]\\n[1,9,5,13,3,11,7,15,2,10,6,14,4,12,8,16]\\n...\\n```\\n\\n```\\npublic class Solution {\\n    public int [] BeautifulArray(int n) {\\n        List<int> res = new List<int>() {1};\\n        while(res.Count < n) {\\n            var odd = res.Select(a => a * 2 - 1);\\n            var even = res.Select(a => a * 2);\\n            res = odd.Concat(even).ToList();\\n        }\\n        return res.Where(a => a <= n).ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```res```\n```while```\n```\\n[1]\\n[1,2]\\n[1,3,2,4]\\n[1,5,3,7,2,6,4,8]\\n[1,9,5,13,3,11,7,15,2,10,6,14,4,12,8,16]\\n...\\n```\n```\\npublic class Solution {\\n    public int [] BeautifulArray(int n) {\\n        List<int> res = new List<int>() {1};\\n        while(res.Count < n) {\\n            var odd = res.Select(a => a * 2 - 1);\\n            var even = res.Select(a => a * 2);\\n            res = odd.Concat(even).ToList();\\n        }\\n        return res.Where(a => a <= n).ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369029,
                "title": "easy-java-solution-pattern-based",
                "content": "This is the most weird question I have seen till now.\\n\\nSomeone found this great pattern to solve this question.\\n\\nFor odd length : **2 * element - 1**\\nFor even length : **2 * element**\\n\\nSo, start with adding with to the list and use the pattern above to create new list until you reach \\'n\\'.\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> list = new ArrayList();\\n        list.add(1);\\n        \\n        while(list.size() < n){\\n            ArrayList<Integer> temp = new ArrayList();\\n            \\n            for(int el : list){\\n                if(2 * el - 1 <= n){\\n                    temp.add(2*el - 1);\\n                }\\n            }\\n            \\n            for(int el : list){\\n                if(2 * el <= n){\\n                    temp.add(2*el);\\n                }\\n            }\\n            list = temp;\\n        }\\n        \\n        int[] res = new int[n];\\n        for(int i = 0; i < list.size(); i++){\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> list = new ArrayList();\\n        list.add(1);\\n        \\n        while(list.size() < n){\\n            ArrayList<Integer> temp = new ArrayList();\\n            \\n            for(int el : list){\\n                if(2 * el - 1 <= n){\\n                    temp.add(2*el - 1);\\n                }\\n            }\\n            \\n            for(int el : list){\\n                if(2 * el <= n){\\n                    temp.add(2*el);\\n                }\\n            }\\n            list = temp;\\n        }\\n        \\n        int[] res = new int[n];\\n        for(int i = 0; i < list.size(); i++){\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368809,
                "title": "python3",
                "content": "No one can do by own its pattern based and getting logic of pattern is very rare\\n```\\ndef beautifulArray(self, n: int) -> List[int]:\\n        if n==1:return [1]\\n        prev=self.beautifulArray(n-1)\\n        arr=[]\\n        for nums in prev:\\n            if 2*nums-1<=n:\\n                arr.append(2*nums-1)\\n        for nums in prev:\\n            if 2*nums<=n:\\n                arr.append(2*nums)\\n        return arr",
                "solutionTags": [],
                "code": "No one can do by own its pattern based and getting logic of pattern is very rare\\n```\\ndef beautifulArray(self, n: int) -> List[int]:\\n        if n==1:return [1]\\n        prev=self.beautifulArray(n-1)\\n        arr=[]\\n        for nums in prev:\\n            if 2*nums-1<=n:\\n                arr.append(2*nums-1)\\n        for nums in prev:\\n            if 2*nums<=n:\\n                arr.append(2*nums)\\n        return arr",
                "codeTag": "Python3"
            },
            {
                "id": 1368760,
                "title": "simple-java-solution-with-tracing",
                "content": "\\t\\t\\t\\t\\t\\n# Code:\\nclass Solution {\\n\\n    public int[] beautifulArray(int n) {\\n        List<Integer> result = new ArrayList<Integer>();\\n        result.add(1);\\n        while(result.size() < n) {\\n            List<Integer> temp = new ArrayList<Integer>();\\n            for(int i : result) {\\n                if(i * 2 -1 <= n) temp.add(i * 2 - 1);\\n            }\\n            for(int i : result) {\\n                if(i * 2 <= n) temp.add(i * 2);\\n            }\\n            result = temp;\\n        }\\n        return result.stream().mapToInt(i->i).toArray();\\n    }\\n\\n}\\n\\n# Tracing:\\n\\n```\\nThe tracing of the algorithm seems far better than actual explanation.\\n\\nExample :  n = 13\\nresult : [1]\\n\\t\\t\\t\\t\\t\\t\\tresult                                                                temp   \\nsize = 1 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1]                                                                    [1]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1]                                                                    [1,2]\\n\\t\\t\\t\\t\\t\\t\\t[1,2]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 2 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,2]                                                                  [1,3]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,2]                                                                  [1,3,2,4]    \\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 4 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]                                                              [1,5,3,7]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]                                                              [1,5,3,7,2,10,6]    \\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 7 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]                                                       [1,9,513,3,11]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]                                                       [1,9,5,13,3,11,2,10,6,4,12]    \\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize =11 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]                                            [1,9,5,3,11,7]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]                                            [1,9,5,3,11,7,2,10,6,4,12,8]    \\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,3,11,7,2,10,6,4,12,8]\\n\\nsize = 13 < 13 ---X\\nresult = [1,9,5,3,11,7,2,10,6,4,12,8]\\t\\n```\\t\\t\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nThe tracing of the algorithm seems far better than actual explanation.\\n\\nExample :  n = 13\\nresult : [1]\\n\\t\\t\\t\\t\\t\\t\\tresult                                                                temp   \\nsize = 1 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1]                                                                    [1]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1]                                                                    [1,2]\\n\\t\\t\\t\\t\\t\\t\\t[1,2]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 2 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,2]                                                                  [1,3]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,2]                                                                  [1,3,2,4]    \\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 4 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]                                                              [1,5,3,7]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,3,2,4]                                                              [1,5,3,7,2,10,6]    \\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize = 7 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]                                                       [1,9,513,3,11]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,5,3,7,2,10,6]                                                       [1,9,5,13,3,11,2,10,6,4,12]    \\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]\\n\\t\\t\\t\\t\\t\\t\\t\\nsize =11 < 13       -----------------after 1st for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]                                            [1,9,5,3,11,7]\\n\\t\\t\\t\\t\\t\\t\\t----------------after 2nd for loop--------------------\\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,13,3,11,2,10,6,4,12]                                            [1,9,5,3,11,7,2,10,6,4,12,8]    \\n\\t\\t\\t\\t\\t\\t\\t[1,9,5,3,11,7,2,10,6,4,12,8]\\n\\nsize = 13 < 13 ---X\\nresult = [1,9,5,3,11,7,2,10,6,4,12,8]\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368758,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int>ans;\\n        ans.push_back(1);\\n        while(ans.size() < n){\\n            vector<int>temp;\\n            for(auto i : ans) if(2*i - 1 <= n) temp.push_back(2*i - 1);   //odd numbers\\n            for(auto i : ans) if(2*i <= n) temp.push_back(2*i);   //even numbers\\n            ans = temp;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int>ans;\\n        ans.push_back(1);\\n        while(ans.size() < n){\\n            vector<int>temp;\\n            for(auto i : ans) if(2*i - 1 <= n) temp.push_back(2*i - 1);   //odd numbers\\n            for(auto i : ans) if(2*i <= n) temp.push_back(2*i);   //even numbers\\n            ans = temp;\\n        } \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368755,
                "title": "c-dfs-memo-divide-conquer",
                "content": "Approach 1: DFS+memo, divide conquer [1]\\n Time complexity: O(NlogN)\\n Space complexity: O(NlogN)\\nThe solution is very conter-intuitive. \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {        \\n        if(_memo.count(n)) return _memo[n];\\n        vector<int> ans(n);\\n        if(n == 1) ans[0]=1;\\n        else{\\n            int t = 0;\\n            for(int x: beautifulArray((n+1)/2)) ans[t++] = 2* x - 1; // odds\\n            for(int x: beautifulArray(n/2)) ans[t++] = 2* x;  // evens\\n        }\\n        return _memo[n]=ans;        \\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<int> > _memo;\\n};\\n```\\nReference:\\n[1] https://leetcode.com/problems/beautiful-array/solution/",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {        \\n        if(_memo.count(n)) return _memo[n];\\n        vector<int> ans(n);\\n        if(n == 1) ans[0]=1;\\n        else{\\n            int t = 0;\\n            for(int x: beautifulArray((n+1)/2)) ans[t++] = 2* x - 1; // odds\\n            for(int x: beautifulArray(n/2)) ans[t++] = 2* x;  // evens\\n        }\\n        return _memo[n]=ans;        \\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<int> > _memo;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368694,
                "title": "java-solution-easy",
                "content": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        //ODD - 2*EL - 1\\n        //EVEN - 2*EL\\n        ArrayList<Integer> res = new ArrayList<Integer>();\\n        res.add(1);\\n        \\n        while(res.size() < n){\\n            ArrayList<Integer> temp = new ArrayList<Integer>();\\n            //odd\\n            for(int el : res){\\n                if(2*el - 1 <= n){\\n                    temp.add(2*el - 1);\\n                }\\n            }\\n            //even\\n            for(int el : res){\\n                if(2*el <= n){\\n                    temp.add(2*el);\\n                }\\n            }\\n            res = temp;\\n        }\\n        \\n        int[] result = new int[n];\\n        for(int i = 0; i < n ; i++){\\n            result[i] = res.get(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        //ODD - 2*EL - 1\\n        //EVEN - 2*EL\\n        ArrayList<Integer> res = new ArrayList<Integer>();\\n        res.add(1);\\n        \\n        while(res.size() < n){\\n            ArrayList<Integer> temp = new ArrayList<Integer>();\\n            //odd\\n            for(int el : res){\\n                if(2*el - 1 <= n){\\n                    temp.add(2*el - 1);\\n                }\\n            }\\n            //even\\n            for(int el : res){\\n                if(2*el <= n){\\n                    temp.add(2*el);\\n                }\\n            }\\n            res = temp;\\n        }\\n        \\n        int[] result = new int[n];\\n        for(int i = 0; i < n ; i++){\\n            result[i] = res.get(i);\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368571,
                "title": "c-932-beautiful-array",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans = {1}; \\n        while (ans.size() < n) {\\n            vector<int> tmp; \\n            for (auto& x : ans) if (2*x-1 <= n) tmp.push_back(2*x-1); \\n            for (auto& x : ans) if (2*x <= n) tmp.push_back(2*x); \\n            ans = tmp; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans = {1}; \\n        while (ans.size() < n) {\\n            vector<int> tmp; \\n            for (auto& x : ans) if (2*x-1 <= n) tmp.push_back(2*x-1); \\n            for (auto& x : ans) if (2*x <= n) tmp.push_back(2*x); \\n            ans = tmp; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368527,
                "title": "c-faster-than-100",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> v = {1};\\n        while(v.size() < n) {\\n            vector<int> temp;\\n            for(int i=0; i<v.size(); i++) {\\n                if(2*v[i] - 1 <= n)\\n                    temp.push_back(2*v[i] - 1);\\n            }\\n            for(int i=0; i<v.size(); i++) {\\n                if(2*v[i] <= n)\\n                    temp.push_back(2*v[i]);\\n            }\\n            v = temp;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> v = {1};\\n        while(v.size() < n) {\\n            vector<int> temp;\\n            for(int i=0; i<v.size(); i++) {\\n                if(2*v[i] - 1 <= n)\\n                    temp.push_back(2*v[i] - 1);\\n            }\\n            for(int i=0; i<v.size(); i++) {\\n                if(2*v[i] <= n)\\n                    temp.push_back(2*v[i]);\\n            }\\n            v = temp;\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368510,
                "title": "python-o-n-simple",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        dp = [None]*(n+1)\\n        dp[1]= [1]\\n        for i in range(2,n+1):\\n            #considering odd cases and even cases\\n            dp[i]= [(2*j)-1 for j in dp[(i+1)//2]]+ [(2*j) for j in dp[i//2]]\\n        return dp[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        dp = [None]*(n+1)\\n        dp[1]= [1]\\n        for i in range(2,n+1):\\n            #considering odd cases and even cases\\n            dp[i]= [(2*j)-1 for j in dp[(i+1)//2]]+ [(2*j) for j in dp[i//2]]\\n        return dp[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368149,
                "title": "c-solution-using-dp-memoization",
                "content": "Algorithm:\\n1. total odd numbers:  (N+1) / 2  and N / 2 even numbers.\\n2. store these separatly into map (unordered map)\\n3. Add them. store them into dp array; (memoization)\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        unordered_map<int, vector<int>> dp;\\n        if (dp.find(n) != dp.end()){\\n            return dp[n];\\n        }\\n            \\n        vector<int> result(n);\\n        if (n == 1) {\\n            result[0] = 1;\\n        } else {\\n            int i = 0;\\n            for (int x: beautifulArray((n+1)/2)){\\n                result[i++] = 2*x - 1;\\n            } \\n                \\n            for (int x: beautifulArray(n/2)){\\n                result[i++] = 2*x;\\n            }\\n        }\\n        dp[n] = result;\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        unordered_map<int, vector<int>> dp;\\n        if (dp.find(n) != dp.end()){\\n            return dp[n];\\n        }\\n            \\n        vector<int> result(n);\\n        if (n == 1) {\\n            result[0] = 1;\\n        } else {\\n            int i = 0;\\n            for (int x: beautifulArray((n+1)/2)){\\n                result[i++] = 2*x - 1;\\n            } \\n                \\n            for (int x: beautifulArray(n/2)){\\n                result[i++] = 2*x;\\n            }\\n        }\\n        dp[n] = result;\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368040,
                "title": "swift-odd-even-pattern-o-n",
                "content": "Swift solution based on Odd + Even Pattern suggested by lee215\\n\\nhttps://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N)\\n\\n```\\nclass Solution {\\n    func beautifulArray(_ n: Int) -> [Int] {\\n        var result: [Int] = [1]\\n        while result.count < n {\\n            var tmp: [Int] = []\\n            for i in result {\\n                if (i * 2 - 1 <= n) {\\n                    tmp.append(i * 2 - 1)\\n                }\\n            }\\n            for i in result {\\n                if (i * 2 <= n) {\\n                    tmp.append(i * 2)\\n                }\\n            }\\n            result = tmp\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func beautifulArray(_ n: Int) -> [Int] {\\n        var result: [Int] = [1]\\n        while result.count < n {\\n            var tmp: [Int] = []\\n            for i in result {\\n                if (i * 2 - 1 <= n) {\\n                    tmp.append(i * 2 - 1)\\n                }\\n            }\\n            for i in result {\\n                if (i * 2 <= n) {\\n                    tmp.append(i * 2)\\n                }\\n            }\\n            result = tmp\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1257565,
                "title": "why-my-answer-is-giving-wa",
                "content": "class Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        a=[]\\n        for _ in range(1,n+1):\\n            a.append(_)\\n        for _ in range(len(a)):\\n            if(_%2!=0):\\n                temp=a[_-1]\\n                a[_-1]=a[_]\\n                a[_]=temp\\n        return a\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nmy basic approach is i m swapping the elements present on the odd indecies with their previous elems.\\nthen the array generated by my approach is also a beautiful array!",
                "solutionTags": [],
                "code": "class Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        a=[]\\n        for _ in range(1,n+1):\\n            a.append(_)\\n        for _ in range(len(a)):\\n            if(_%2!=0):\\n                temp=a[_-1]\\n                a[_-1]=a[_]\\n                a[_]=temp\\n        return a\\n\\t\\t\\n\\t\\t\\n\\t\\t\\nmy basic approach is i m swapping the elements present on the odd indecies with their previous elems.\\nthen the array generated by my approach is also a beautiful array!",
                "codeTag": "Java"
            },
            {
                "id": 1172071,
                "title": "java-beats-100-explained-happy-coding-friend",
                "content": "```\\n// example: N = 9\\n// 1. we divide it into two parts: all odds: 1, 3, 5, 7, 9; all evens: 2, 4, 6, 8\\n//    we put all odds before evens, then if A[i] is from odds and A[j] from even, we will already be valid\\n//    So, all our job is to make sure within all odds and all even themselves are valid!\\n// 2. for all odds if a sequence 5 1 3 9 7 is valid, we take each x as (x+1)/2, then we got --> 3 1 2 5 4 is also valid\\n//        which, is a subproblem beautifulArray(5)\\n// 3. for all even if a sequence 4 2 6 8 is valid, we take each x as x/2, then we got --> 2 1 3 4 is also valid\\n//        which, is a subproblem beautifulArray(4)    \\n// thus, we cal solve it recursively!    \\n\\nclass Solution {\\n    public int[] beautifulArray(int N) { // dfs is not available here for N ~ 1000\\n        int[] res = new int[N];\\n        if (N == 1) {\\n            return new int[] {1};\\n        } else if (N == 2) {\\n            return new int[] {1, 2};\\n        } else {\\n            int[] odds = beautifulArray((N + 1) / 2);\\n            int[] even = beautifulArray(N / 2);\\n            for (int i = 0; i < odds.length; i ++) {\\n                res[i] = odds[i] * 2 - 1;\\n            }\\n            for (int j = 0; j < even.length; j ++) {\\n                res[odds.length + j] = even[j] * 2;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] beautifulArray(int N) { // dfs is not available here for N ~ 1000\\n        int[] res = new int[N];\\n        if (N == 1) {\\n            return new int[] {1}",
                "codeTag": "Java"
            },
            {
                "id": 1148615,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        int[] arr=new int[N];\\n        List<Integer> ls=new ArrayList<>();\\n        ls.add(1);\\n        while(ls.size()<N){\\n            List<Integer> temp=new ArrayList<>();\\n            for(int i:ls){\\n                if(i*2-1<=N)\\n                    temp.add(2*i-1);\\n            }\\n             for(int i:ls){\\n                if(i*2<=N)\\n                    temp.add(2*i);\\n            }\\n             ls=temp;\\n        }\\n       for(int i=0;i<N;i++){\\n           arr[i]=ls.get(i);\\n       }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        int[] arr=new int[N];\\n        List<Integer> ls=new ArrayList<>();\\n        ls.add(1);\\n        while(ls.size()<N){\\n            List<Integer> temp=new ArrayList<>();\\n            for(int i:ls){\\n                if(i*2-1<=N)\\n                    temp.add(2*i-1);\\n            }\\n             for(int i:ls){\\n                if(i*2<=N)\\n                    temp.add(2*i);\\n            }\\n             ls=temp;\\n        }\\n       for(int i=0;i<N;i++){\\n           arr[i]=ls.get(i);\\n       }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760023,
                "title": "divide-and-conquer-in-python-47-100",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        res = [0] * N\\n        if N==1:\\n            return [1]\\n        if N==2:\\n            return [1,2]\\n        if N%2 == 0:\\n            half = self.beautifulArray(int(N/2))\\n            for i in range(int(N/2)):\\n                res[i] = half[i] * 2-1\\n            for i in range(int(N/2), N):\\n                res[i] = half[i-int(N/2)] * 2\\n        \\n        else:\\n            res[int((N-1)/2)] = N\\n            whole = self.beautifulArray(N-1)\\n            for i in range(int((N-1)/2)):\\n                res[i] = whole[i+int((N-1)/2)]\\n            for i in range(int((N-1)/2),N-1):\\n                res[i+1] = whole[i-int((N-1)/2)]\\n        return res\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N: int) -> List[int]:\\n        res = [0] * N\\n        if N==1:\\n            return [1]\\n        if N==2:\\n            return [1,2]\\n        if N%2 == 0:\\n            half = self.beautifulArray(int(N/2))\\n            for i in range(int(N/2)):\\n                res[i] = half[i] * 2-1\\n            for i in range(int(N/2), N):\\n                res[i] = half[i-int(N/2)] * 2\\n        \\n        else:\\n            res[int((N-1)/2)] = N\\n            whole = self.beautifulArray(N-1)\\n            for i in range(int((N-1)/2)):\\n                res[i] = whole[i+int((N-1)/2)]\\n            for i in range(int((N-1)/2),N-1):\\n                res[i+1] = whole[i-int((N-1)/2)]\\n        return res\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 656220,
                "title": "python",
                "content": "def beautifulArray(n):\\n\\n    arr = list(range(1, n + 1))\\n    def helper(arr):\\n        if len(arr) < 3:\\n            return arr\\n        even = arr[::2]\\n        odd = arr[1::2]\\n\\n        return helper(even) + helper(odd)\\n    return helper(arr)#pehl call\\n    \\n    \\n\\nn = int(input())\\nk = beautifulArray(n)\\nprint(*k)\\n\\n\\n",
                "solutionTags": [],
                "code": "def beautifulArray(n):\\n\\n    arr = list(range(1, n + 1))\\n    def helper(arr):\\n        if len(arr) < 3:\\n            return arr\\n        even = arr[::2]\\n        odd = arr[1::2]\\n\\n        return helper(even) + helper(odd)\\n    return helper(arr)#pehl call\\n    \\n    \\n\\nn = int(input())\\nk = beautifulArray(n)\\nprint(*k)\\n\\n\\n",
                "codeTag": "Python3"
            },
            {
                "id": 575240,
                "title": "java-solution-divide-conquer",
                "content": "Idea:\\n 1. We are going to find a arthemetic subsequence free array (example 1 3 5  or 2 6 10) can  not exist\\n2. If we can deal a small subset, let\\'s say the answer for N=3 is [1,3,2], [1,3,2] is arthemetic free. Is that the same for [2,6,4] and [1,5,3]??\\n```\\nclass Solution {\\n    //1 2 3 4 5 as example\\n    Map<Integer,int[]>dp=new HashMap<>();\\n    public int[] beautifulArray(int N) {\\n        if(dp.containsKey(N))return dp.get(N);\\n        int res[]=new int[N];\\n        if(N==1){\\n            res[0]=1;return res;\\n        }\\n        int index=0;\\n        int left[]=beautifulArray((N+1)/2); //dealing 1 2 3=>convert to 1 3 5\\n        int right[]=beautifulArray(N/2);\\n        for(int i:left){\\n            res[index++]=i*2-1;\\n        }\\n        for(int i:right){\\n            res[index++]=i*2;\\n        }\\n        dp.put(N,res);\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    //1 2 3 4 5 as example\\n    Map<Integer,int[]>dp=new HashMap<>();\\n    public int[] beautifulArray(int N) {\\n        if(dp.containsKey(N))return dp.get(N);\\n        int res[]=new int[N];\\n        if(N==1){\\n            res[0]=1;return res;\\n        }\\n        int index=0;\\n        int left[]=beautifulArray((N+1)/2); //dealing 1 2 3=>convert to 1 3 5\\n        int right[]=beautifulArray(N/2);\\n        for(int i:left){\\n            res[index++]=i*2-1;\\n        }\\n        for(int i:right){\\n            res[index++]=i*2;\\n        }\\n        dp.put(N,res);\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 214185,
                "title": "c-recursion-odd-even",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> v(N);\\n        fill(N, 0, v);\\n        return v;\\n    }\\n    \\n    void fill(int n, int beg, vector<int>& v)\\n    {\\n        if(n==1)\\n        {\\n            v[beg] = 1;\\n            return;\\n        }\\n       \\n        int n2 = n/2;\\n        fill(n2, beg, v); \\n        for(int i=0;i<n2;i++)\\n            v[beg+i] *= 2;\\n        fill(n-n2, beg+n2, v);\\n        for(int i=0;i<n-n2;i++)\\n            v[beg+n2+i] = v[beg+n2+i]*2-1;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> v(N);\\n        fill(N, 0, v);\\n        return v;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 199427,
                "title": "c-o-n-recursive-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    void bar(vector<int>& v, int strt, int size) {\\n        if (size < 3) return;\\n        \\n        int step  = (v[strt + 1] - v[strt])*2;\\n        int lsize = (size + 1)/2;\\n        int ridx  = strt + lsize;\\n        int rsize = size/2;\\n        \\n        v[ridx] = v[strt + 1];\\n        if (ridx + 1 < strt + size) v[ridx + 1] = v[ridx] + step;\\n        v[strt + 1] = v[strt] + step;\\n        \\n        bar(v, strt, lsize);\\n        bar(v, ridx, rsize);\\n    }\\n    \\n    vector<int> beautifulArray(int N) {\\n        vector<int> v(N);\\n        v[0] = 1;\\n        v[1] = 2;\\n        bar(v, 0, N);\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void bar(vector<int>& v, int strt, int size) {\\n        if (size < 3) return;\\n        \\n        int step  = (v[strt + 1] - v[strt])*2;\\n        int lsize = (size + 1)/2;\\n        int ridx  = strt + lsize;\\n        int rsize = size/2;\\n        \\n        v[ridx] = v[strt + 1];\\n        if (ridx + 1 < strt + size) v[ridx + 1] = v[ridx] + step;\\n        v[strt + 1] = v[strt] + step;\\n        \\n        bar(v, strt, lsize);\\n        bar(v, ridx, rsize);\\n    }\\n    \\n    vector<int> beautifulArray(int N) {\\n        vector<int> v(N);\\n        v[0] = 1;\\n        v[1] = 2;\\n        bar(v, 0, N);\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186786,
                "title": "c-dp-copied-from-someone-else-i-was-wondering-who-was-the-first-guy-hit-this-in-the-interview",
                "content": "credit goes to https://leetcode.com/problems/beautiful-array/discuss/186679/C++JavaPython-Odd-+-Even-Pattern-O(N)\\n\\nimpossible to figure it out in a 45mins interview. fml...\\n\\n```\\n// reference:\\n// https://leetcode.com/problems/beautiful-array/discuss/186679/C++JavaPython-Odd-+-Even-Pattern-O(N)\\n\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    unordered_map<int, vector<int>> dp;\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res;\\n        if (N == 1) {\\n            res.push_back(1);\\n            return res;\\n        }\\n\\n        if (dp.find(N) != dp.end()) {\\n            return dp[N];\\n        }\\n\\n        auto left = beautifulArray(N / 2);\\n        auto right = beautifulArray(N - N / 2);\\n\\n        for (auto num : left) {\\n            res.push_back(2 * num);\\n        }\\n        for (auto num : right) {\\n            res.push_back(2 * num - 1);\\n        }\\n        dp[N] = res;\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n// reference:\\n// https://leetcode.com/problems/beautiful-array/discuss/186679/C++JavaPython-Odd-+-Even-Pattern-O(N)\\n\\n#include <vector>\\n#include <unordered_map>\\n\\nusing namespace std;\\n\\nclass Solution {\\nprivate:\\n    unordered_map<int, vector<int>> dp;\\npublic:\\n    vector<int> beautifulArray(int N) {\\n        vector<int> res;\\n        if (N == 1) {\\n            res.push_back(1);\\n            return res;\\n        }\\n\\n        if (dp.find(N) != dp.end()) {\\n            return dp[N];\\n        }\\n\\n        auto left = beautifulArray(N / 2);\\n        auto right = beautifulArray(N - N / 2);\\n\\n        for (auto num : left) {\\n            res.push_back(2 * num);\\n        }\\n        for (auto num : right) {\\n            res.push_back(2 * num - 1);\\n        }\\n        dp[N] = res;\\n        return res;\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4101508,
                "title": "python-o-n-solution",
                "content": "In this problem we have n = 1000, which is too big to use dfs/backtracking, so we need to find some pattern. We need to avoid structures like i < k < j with nums[i] + nums[j] = 2 * nums[k], which means that nums[i] and nums[j] has the same parity: they are both odd or even. This lead us to the following idea: let us split all numbers into 2 groups: all odd numbers and then all even numbers.\\n\\n[ odd numbers ] [ even numbers ]\\n\\nThen if i, j, k lies in two different groups, we are OK, we will hever have forbidden pattern. Also, if we look at odd numbers, imagine n = 12, then we have [1, 3, 5, 7, 9, 11] and if we subtract 1 to each number and divide each number by 2 then we have [0, 1, 2, 3, 4, 5]. Note, that is linear transform: when we did this transformation, if we did not have forbidden pattern, we still do not have it! So, what we need to do is to run function recursively for odd and even numbers and concatenate them.\\n\\n\\n\\n# Complexity\\nFrom the first sight, time complexity is O(n log n), because we have recursion C(n) = C(n//2) + C((n+1)//2), which lead to O(n log n). However it can be shown that it is O(n). Imagine case n = 105, then we have 105 -> (52, 53) -> (26, 26, 27, 27) -> (13, 13, 13, 13, 14, 14, 14, 14) and if we use memoisation, no need to solve problem each time for 13, we can do it only once. On each level we will have at most two values in our recursion tree. Space complexity is O(n).\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulArray(self, N):\\n        @lru_cache(None)\\n        def dfs(N):\\n            if N == 1: return (1,)\\n            t1 = dfs((N+1)//2)\\n            t2 = dfs(N//2)\\n            return [i*2-1 for i in t1] + [i*2 for i in t2]\\n        \\n        return dfs(N)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, N):\\n        @lru_cache(None)\\n        def dfs(N):\\n            if N == 1: return (1,)\\n            t1 = dfs((N+1)//2)\\n            t2 = dfs(N//2)\\n            return [i*2-1 for i in t1] + [i*2 for i in t2]\\n        \\n        return dfs(N)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3807187,
                "title": "a-memory-efficient-implementation-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt uses a single vector only. The erase operation can be expensive.\\nIf we use two vectors, it will be faster.\\n \\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> array{1};\\n        for (int m = 2; m <= n; m++) {     \\n          for (int i = 0; i < m-1; i++) {\\n              int k = array[i];\\n              if (2 * k -1 <= m) \\n                array.push_back(2 * k - 1);\\n          }\\n          for (int i = 0; i < m-1; i++) {\\n              int k = array.front();\\n              array.erase(array.begin());\\n              if (2 * k <= m) \\n                array.push_back(2 * k);\\n          }         \\n        }\\n\\n        return array; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> array{1};\\n        for (int m = 2; m <= n; m++) {     \\n          for (int i = 0; i < m-1; i++) {\\n              int k = array[i];\\n              if (2 * k -1 <= m) \\n                array.push_back(2 * k - 1);\\n          }\\n          for (int i = 0; i < m-1; i++) {\\n              int k = array.front();\\n              array.erase(array.begin());\\n              if (2 * k <= m) \\n                array.push_back(2 * k);\\n          }         \\n        }\\n\\n        return array; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3790784,
                "title": "explanation-with-details",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBecause of item 2, there will be no average between the two numbers.\\n\\nThe odd part + even part will satisfy this situation. Because the average of an odd and an even will not be an integer.\\n\\nAnd we want to generate an array. So we may use Partition to solve this. \\n\\nAt first we have a beautiful array [1].\\n\\nWe will use it to generate longer array.\\n\\n2 * BA will also be BA\\n\\n2 * BA - 1 will also be BA\\n\\nSo we can use this to generate longer array.\\n\\nlength: 1 \\u2192 2 \\u2192 4 \\u2192 8\\n\\nwhat about length as 5?\\n\\nDeletion will not change the property of BA.\\n\\nSo we can just discard the element out of 1\\u2192n.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res = {1};\\n        while(res.size() < n)\\n        {\\n            vector<int> tmp;\\n            for(auto& elem : res)\\n            {\\n                if(elem*2 - 1 <= n)\\n                    tmp.push_back(elem * 2 - 1);\\n            }\\n            for(auto & elem: res)\\n            {\\n                if(elem * 2 <= n)\\n                    tmp.push_back(elem * 2);\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res = {1};\\n        while(res.size() < n)\\n        {\\n            vector<int> tmp;\\n            for(auto& elem : res)\\n            {\\n                if(elem*2 - 1 <= n)\\n                    tmp.push_back(elem * 2 - 1);\\n            }\\n            for(auto & elem: res)\\n            {\\n                if(elem * 2 <= n)\\n                    tmp.push_back(elem * 2);\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3788157,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<N){\\n            ArrayList<Integer> temp = new ArrayList<>();\\n           for(int ele : ans){\\n               if(2*ele-1 <= N)\\n               temp.add(ele*2-1);\\n           } \\n           for(int ele : ans){\\n               if(2*ele <= N)\\n               temp.add(ele*2);\\n           }\\n           ans=temp;\\n        }\\n        int[] res = new int[N];\\n        for(int i=0; i<N;i++)\\n        {\\n            res[i]=ans.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int N) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<N){\\n            ArrayList<Integer> temp = new ArrayList<>();\\n           for(int ele : ans){\\n               if(2*ele-1 <= N)\\n               temp.add(ele*2-1);\\n           } \\n           for(int ele : ans){\\n               if(2*ele <= N)\\n               temp.add(ele*2);\\n           }\\n           ans=temp;\\n        }\\n        int[] res = new int[N];\\n        for(int i=0; i<N;i++)\\n        {\\n            res[i]=ans.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3786654,
                "title": "approach-for-this-beautiful-array-1000-mind-blowing-question",
                "content": "# Source: https://youtu.be/7-RZ0Lw6VRg\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach Divide and Conquer technique\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans;\\n        ans.push_back(1);\\n        while(ans.size()<n)\\n        {\\n            vector<int> temp;\\n            for(int el:ans)\\n            {\\n                if(2*el-1<=n)\\n                {\\n                    temp.push_back(2*el-1);\\n                }\\n            }\\n            for(int el:ans)\\n            {\\n                if(2*el<=n)\\n                {\\n                    temp.push_back(2*el);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Divide and Conquer",
                    "Brainteaser"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans;\\n        ans.push_back(1);\\n        while(ans.size()<n)\\n        {\\n            vector<int> temp;\\n            for(int el:ans)\\n            {\\n                if(2*el-1<=n)\\n                {\\n                    temp.push_back(2*el-1);\\n                }\\n            }\\n            for(int el:ans)\\n            {\\n                if(2*el<=n)\\n                {\\n                    temp.push_back(2*el);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3716792,
                "title": "my-solutions",
                "content": "**1. Use the iteration**\\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    constexpr int range = 2;\\n    vector<int> nums[range];\\n    int previous = 0;\\n    int current = 1;\\n    nums[previous].emplace_back(1);\\n    while (nums[previous].size() < n) {\\n      for (int delta = 0; delta < 2; ++delta) {\\n        for (const int num : nums[previous]) {\\n          nums[current].emplace_back(2 * num - delta);\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      nums[current].clear();\\n    }\\n    \\n    if (nums[previous].size() == n) {\\n      return nums[previous];\\n    }\\n\\n    vector<int> ret;\\n    for (const int num : nums[previous]) {\\n      if (num >= 1 && num < n + 1) {\\n        ret.emplace_back(num);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the memorized Top-Down DP**\\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<vector<int>> memo(n);\\n    return dfs(n, memo);\\n  }\\n  \\n private:\\n  const vector<int>& dfs(const int n, vector<vector<int>> &memo) {\\n    vector<int> &ret = memo[n - 1];\\n    if (!ret.empty()) {\\n      return ret;\\n    }\\n    \\n    if (n == 1) {\\n      ret.emplace_back(1);\\n      return ret;\\n    }\\n    \\n    const vector<int> &odd = dfs((n + 1) / 2, memo);\\n    const vector<int> &even = dfs(n / 2, memo);\\n    for (const int num : odd) {\\n      ret.emplace_back(2 * num - 1);\\n    }\\n    for (const int num : even) {\\n      ret.emplace_back(2 * num);\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**3. Use the Bottom-Up DP**\\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<int> subarray_lengths({n});\\n    for (size_t i = 0; i < subarray_lengths.size() && subarray_lengths[i] != 1; ++i) {\\n      if ((subarray_lengths[i] + 1) / 2 != subarray_lengths.back()) {\\n        subarray_lengths.emplace_back((subarray_lengths[i] + 1) / 2);\\n      }\\n      if ((subarray_lengths[i] & 1) == 1) {\\n        // subarray_lengths[i] is odd\\n        subarray_lengths.emplace_back(subarray_lengths[i] / 2);\\n      }\\n    }\\n    \\n    vector<int> dp[n];\\n    dp[0].emplace_back(1);\\n    const int n_subarray_lengths = static_cast<int>(subarray_lengths.size());\\n    for (int i = n_subarray_lengths - 2; i > -1; --i) {\\n      const int subarray_length = subarray_lengths[i];\\n      const vector<int> &odd = dp[(subarray_length + 1) / 2 - 1];\\n      const vector<int> &even = dp[subarray_length / 2 - 1];\\n      for (const int num : odd) {\\n        dp[subarray_length - 1].emplace_back(2 * num - 1);\\n      }\\n      for (const int num : even) {\\n        dp[subarray_length - 1].emplace_back(2 * num);\\n      }\\n    }\\n    return dp[n - 1];\\n  }\\n};\\n```\\n**4. Sort the vector according to the binary representation of the element**\\n```\\n/**\\n * let bit(num, i) be `(num >> i) & 0b1`\\n * construct the array `nums` as [1, 2, ..., `n`]\\n * 1. sort the `nums` by `bit(num, 0)`\\n * 2. if `bit(lhs, 0)` == `bit(rhs, 0)`, sort them by `bit(num, 1)`\\n * 3. if `bit(lhs, 0)` == `bit(rhs, 0)` and `bit(lhs, 1)` == `bit(rhs, 1)`,\\n *    sort them by `bit(num, 2)`\\n * ...\\n * until the order of `num1` and `num2` is determined.\\n *\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<int> ret(n);\\n    iota(ret.begin(), ret.end(), 1);\\n    sort(ret.begin(), ret.end(), [](const int lhs, const int rhs) -> bool {\\n      int left = lhs;\\n      int right = rhs;\\n      for (; (left & 0b1) == (right & 0b1); left >>= 1, right >>= 1) {\\n      }\\n      return (left & 0b1) < (right & 0b1);\\n    });\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    constexpr int range = 2;\\n    vector<int> nums[range];\\n    int previous = 0;\\n    int current = 1;\\n    nums[previous].emplace_back(1);\\n    while (nums[previous].size() < n) {\\n      for (int delta = 0; delta < 2; ++delta) {\\n        for (const int num : nums[previous]) {\\n          nums[current].emplace_back(2 * num - delta);\\n        }\\n      }\\n      \\n      previous ^= 1;\\n      current ^= 1;\\n      nums[current].clear();\\n    }\\n    \\n    if (nums[previous].size() == n) {\\n      return nums[previous];\\n    }\\n\\n    vector<int> ret;\\n    for (const int num : nums[previous]) {\\n      if (num >= 1 && num < n + 1) {\\n        ret.emplace_back(num);\\n      }\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<vector<int>> memo(n);\\n    return dfs(n, memo);\\n  }\\n  \\n private:\\n  const vector<int>& dfs(const int n, vector<vector<int>> &memo) {\\n    vector<int> &ret = memo[n - 1];\\n    if (!ret.empty()) {\\n      return ret;\\n    }\\n    \\n    if (n == 1) {\\n      ret.emplace_back(1);\\n      return ret;\\n    }\\n    \\n    const vector<int> &odd = dfs((n + 1) / 2, memo);\\n    const vector<int> &even = dfs(n / 2, memo);\\n    for (const int num : odd) {\\n      ret.emplace_back(2 * num - 1);\\n    }\\n    for (const int num : even) {\\n      ret.emplace_back(2 * num);\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * let\\'s ignore the first condition of the beautiful array, that is,\\n * `nums` is a permutation of the integers in the range [1, n].\\n *\\n * some observations\\n * if the array `nums1`, whose length is `n`, is beautiful\\n * 1. the array `nums2`, whose length is `n`,\\n *    each element of which, `nums2[i]`, is equal to (2 * `nums1[i]`),\\n *    is beautiful as well\\n * 2. the array `nums3`, whose length is `n`,\\n *    each element of which, `nums3[i]`, is equal to (2 * `nums1[i]` - 1),\\n *    is beautiful as well\\n * 3. every element of `nums2` is even, and every element of `nums3` is odd,\\n *    so a new array `nums4` by concatenating them is beautiful\\n *    \\'cause\\n *    1) `nums2` is beautiful\\n *    2) `nums3` is beautiful\\n *    3) any element `nums4[k]` of `nums4`, where 0 < k < 2 * `n` - 1,\\n *       it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *       is true, where 0 <= `i` < `k` < `j` <= 2 * `n` - 1\\n *       the reason is as following,\\n *       i) if `j` <= `n` - 1,\\n *          that is the elements indexed by `i`, `k`, `j` are all from `nums2`\\n *          according to `1)`, the conclusion is true\\n *       ii) if `i` >= `n`,\\n *           that is the elements indexed by `i`, `k`, `j` are all from `nums3`\\n *           according to `2)`, the conclusion is true\\n *       iii) otherwise,\\n *            `nums4[i]` is even because it\\'s from `nums2`, and\\n *            `nums4[j]` is odd because it\\'s from `nums3`\\n *            so no matter `nums4[k]` is even or odd,\\n *            it\\'s impossible that the condition `nums4[k] == nums4[i] + nums4[j]`\\n *            is true, that is the conclusion is true\\n *\\n * the beautiful array of length `n` can be constructed using the following process,\\n * 1. length == 1, the beautiful array is `[1]`\\n * 2. length == 2, the beautiful array can be constructed by `[2]` + `[1]` = `[2, 1]`\\n * 3. length == 3, the beautiful array can be constructed as following\\n *    1) construct a 4-length beautiful array according to the 2-length beautiful array\\n *       `[4, 2]` + `[3, 1]` = `[4, 2, 3, 1]`\\n *    2) remove the element `4` from it, so the final beautiful array is `[2, 3, 1]`\\n * ...\\n * `n`. length == `n`, construct the n-length beautiful array accordingly\\n *\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<int> subarray_lengths({n});\\n    for (size_t i = 0; i < subarray_lengths.size() && subarray_lengths[i] != 1; ++i) {\\n      if ((subarray_lengths[i] + 1) / 2 != subarray_lengths.back()) {\\n        subarray_lengths.emplace_back((subarray_lengths[i] + 1) / 2);\\n      }\\n      if ((subarray_lengths[i] & 1) == 1) {\\n        // subarray_lengths[i] is odd\\n        subarray_lengths.emplace_back(subarray_lengths[i] / 2);\\n      }\\n    }\\n    \\n    vector<int> dp[n];\\n    dp[0].emplace_back(1);\\n    const int n_subarray_lengths = static_cast<int>(subarray_lengths.size());\\n    for (int i = n_subarray_lengths - 2; i > -1; --i) {\\n      const int subarray_length = subarray_lengths[i];\\n      const vector<int> &odd = dp[(subarray_length + 1) / 2 - 1];\\n      const vector<int> &even = dp[subarray_length / 2 - 1];\\n      for (const int num : odd) {\\n        dp[subarray_length - 1].emplace_back(2 * num - 1);\\n      }\\n      for (const int num : even) {\\n        dp[subarray_length - 1].emplace_back(2 * num);\\n      }\\n    }\\n    return dp[n - 1];\\n  }\\n};\\n```\n```\\n/**\\n * let bit(num, i) be `(num >> i) & 0b1`\\n * construct the array `nums` as [1, 2, ..., `n`]\\n * 1. sort the `nums` by `bit(num, 0)`\\n * 2. if `bit(lhs, 0)` == `bit(rhs, 0)`, sort them by `bit(num, 1)`\\n * 3. if `bit(lhs, 0)` == `bit(rhs, 0)` and `bit(lhs, 1)` == `bit(rhs, 1)`,\\n *    sort them by `bit(num, 2)`\\n * ...\\n * until the order of `num1` and `num2` is determined.\\n *\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n */\\nclass Solution {\\n public:\\n  vector<int> beautifulArray(const int n) {\\n    vector<int> ret(n);\\n    iota(ret.begin(), ret.end(), 1);\\n    sort(ret.begin(), ret.end(), [](const int lhs, const int rhs) -> bool {\\n      int left = lhs;\\n      int right = rhs;\\n      for (; (left & 0b1) == (right & 0b1); left >>= 1, right >>= 1) {\\n      }\\n      return (left & 0b1) < (right & 0b1);\\n    });\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629961,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        n1=[1]\\n        while len(n1)<n:\\n            e=[2*i for i in n1]\\n            o=[2*i-1 for i in n1]\\n            n1=e+o\\n        return [i for i in n1 if i<=n]        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        n1=[1]\\n        while len(n1)<n:\\n            e=[2*i for i in n1]\\n            o=[2*i-1 for i in n1]\\n            n1=e+o\\n        return [i for i in n1 if i<=n]        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3608130,
                "title": "solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res(n,0);\\n        int i = 1;\\n        int j = n;\\n        int k =0;\\n        while(i<=j)\\n        {  res[k]=i;\\n           if((k+1)<n)\\n           res[k+1]=j;\\n           k+=2;\\n           j--;\\n           i++;\\n        }\\n         \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res(n,0);\\n        int i = 1;\\n        int j = n;\\n        int k =0;\\n        while(i<=j)\\n        {  res[k]=i;\\n           if((k+1)<n)\\n           res[k+1]=j;\\n           k+=2;\\n           j--;\\n           i++;\\n        }\\n         \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3575996,
                "title": "beats-100-yet-again",
                "content": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n==1)\\n            return {1};\\n        vector<int>v={1};\\n        while(v.size()<n){\\n            vector<int>ans;\\n            for(int it:v){\\n                if((it*2)-1 <= n)\\n                    ans.push_back(it*2-1);\\n            }\\n            for(int it:v){\\n                if((it*2) <= n)\\n                    ans.push_back(it*2);\\n            }\\n            v=ans;\\n        }\\n        return v;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if(n==1)\\n            return {1}",
                "codeTag": "Java"
            },
            {
                "id": 3506180,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n        Dictionary<int, int[]> map = new Dictionary<int, int[]>();\\n   \\n        return BeautifulArray(n, map);\\n    }\\n\\n    private int[] BeautifulArray(int n, Dictionary<int, int[]> map) {\\n      if(map.ContainsKey(n)) return map[n];\\n     \\n      int[] ans = new int[n];\\n      if(n == 1) {\\n        ans[0] = 1;\\n      } else {\\n        int i = 0;\\n        foreach(int x in BeautifulArray(n / 2, map)) {\\n          ans[i++] = x * 2;\\n        }\\n\\n        foreach(int x in BeautifulArray((n + 1)/ 2, map)) {\\n          ans[i++] = x * 2 - 1;\\n        }\\n      }\\n      map[n] = ans;\\n     \\n      return ans;\\n     }\\n\\n    public int[] BeautifulArray1(int n) {\\n        List<int> ans = new List<int>() {1};\\n        for(int i = 0; i <= n / 2; i++) {\\n          List<int> temp = new List<int>();\\n          foreach(int num in ans) {\\n            if(num * 2 <= n) temp.Add(num * 2);\\n          }\\n          foreach(int num in ans) {\\n            if(num * 2 - 1 <= n) temp.Add(num * 2 - 1);\\n          }\\n          ans = temp;\\n        }\\n   \\n        return ans.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n        Dictionary<int, int[]> map = new Dictionary<int, int[]>();\\n   \\n        return BeautifulArray(n, map);\\n    }\\n\\n    private int[] BeautifulArray(int n, Dictionary<int, int[]> map) {\\n      if(map.ContainsKey(n)) return map[n];\\n     \\n      int[] ans = new int[n];\\n      if(n == 1) {\\n        ans[0] = 1;\\n      } else {\\n        int i = 0;\\n        foreach(int x in BeautifulArray(n / 2, map)) {\\n          ans[i++] = x * 2;\\n        }\\n\\n        foreach(int x in BeautifulArray((n + 1)/ 2, map)) {\\n          ans[i++] = x * 2 - 1;\\n        }\\n      }\\n      map[n] = ans;\\n     \\n      return ans;\\n     }\\n\\n    public int[] BeautifulArray1(int n) {\\n        List<int> ans = new List<int>() {1};\\n        for(int i = 0; i <= n / 2; i++) {\\n          List<int> temp = new List<int>();\\n          foreach(int num in ans) {\\n            if(num * 2 <= n) temp.Add(num * 2);\\n          }\\n          foreach(int num in ans) {\\n            if(num * 2 - 1 <= n) temp.Add(num * 2 - 1);\\n          }\\n          ans = temp;\\n        }\\n   \\n        return ans.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3365948,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n      vector<int>ans;\\n      ans.push_back(1);\\n      while(ans.size()!=n) \\n      {\\n          vector<int>temp;\\n          for (auto it: ans)\\n          {\\n              if (it*2-1<=n)\\n              temp.push_back(it*2-1);\\n          }\\n          for (auto it: ans)\\n          {\\n           if(it*2<=n)\\n           temp.push_back(it*2);\\n          }\\n          ans=temp;\\n      }  \\n      return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) \\n    {\\n      vector<int>ans;\\n      ans.push_back(1);\\n      while(ans.size()!=n) \\n      {\\n          vector<int>temp;\\n          for (auto it: ans)\\n          {\\n              if (it*2-1<=n)\\n              temp.push_back(it*2-1);\\n          }\\n          for (auto it: ans)\\n          {\\n           if(it*2<=n)\\n           temp.push_back(it*2);\\n          }\\n          ans=temp;\\n      }  \\n      return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364210,
                "title": "jaa-easy-to-understand-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n       List<Integer>ls=new ArrayList<>();\\n       ls.add(1);\\n       for(int i=0;i<n;i++)\\n       {\\n           ArrayList<Integer>temp=new ArrayList<>();\\n           for(int val:ls)\\n           {\\n               if(2*val<=n)temp.add(2*val);\\n               \\n           }\\n           for(int val:ls)\\n           {\\n               if(2*val-1<=n) temp.add(2*val-1);\\n           }\\n           ls=temp;\\n       } \\n       int[] ans=new int[n];\\n       int k=0;\\n       for(int i:ls)\\n       {\\n           ans[k++]=i;\\n       }\\n    return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n       List<Integer>ls=new ArrayList<>();\\n       ls.add(1);\\n       for(int i=0;i<n;i++)\\n       {\\n           ArrayList<Integer>temp=new ArrayList<>();\\n           for(int val:ls)\\n           {\\n               if(2*val<=n)temp.add(2*val);\\n               \\n           }\\n           for(int val:ls)\\n           {\\n               if(2*val-1<=n) temp.add(2*val-1);\\n           }\\n           ls=temp;\\n       } \\n       int[] ans=new int[n];\\n       int k=0;\\n       for(int i:ls)\\n       {\\n           ans[k++]=i;\\n       }\\n    return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281644,
                "title": "simple-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nmain logic is : odd = 2(element) - 1 || even = 2*(element)\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nsimple Iterative approach..\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        for(int i=2; i<=n; i++) {\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            for(Integer e:ans){\\n                if(2*e <= n){\\n                    temp.add(e*2);\\n                }\\n            }\\n            for(Integer e:ans){\\n                if(2*e-1 <= n){\\n                    temp.add(e*2-1);\\n                }\\n            }\\n            ans = temp;\\n        }\\n        int[] arr = new int[ans.size()];\\n        for(int i=0; i<arr.length; i++){\\n            arr[i] = ans.get(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        for(int i=2; i<=n; i++) {\\n            ArrayList<Integer> temp = new ArrayList<>();\\n            for(Integer e:ans){\\n                if(2*e <= n){\\n                    temp.add(e*2);\\n                }\\n            }\\n            for(Integer e:ans){\\n                if(2*e-1 <= n){\\n                    temp.add(e*2-1);\\n                }\\n            }\\n            ans = temp;\\n        }\\n        int[] arr = new int[ans.size()];\\n        for(int i=0; i<arr.length; i++){\\n            arr[i] = ans.get(i);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196915,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func beautifulArray(_ n: Int) -> [Int] {\\n\\n        let s = n / 2 + n % 2\\n        var o = [1]\\n        var d = 1\\n        var m = 0\\n        var j = 0\\n\\n        while o.count < s {\\n\\n            var i = 0\\n            d *= 2\\n            \\n            while o.count < s, i < o.count {\\n                if o[i] + d > n {\\n                    i += 1\\n                }\\n                else {\\n                    o.insert(o[i] + d, at: i + 1)\\n\\n                    if o[i] + d > m {\\n                        m = o[i] + d\\n                        j = i + 1\\n                    }\\n\\n                    i += 2\\n                }\\n            }\\n        }\\n\\n        var e = o.map { $0 + 1 }\\n        if n % 2 == 1 { e.remove(at: j) }\\n\\n        return o + e\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func beautifulArray(_ n: Int) -> [Int] {\\n\\n        let s = n / 2 + n % 2\\n        var o = [1]\\n        var d = 1\\n        var m = 0\\n        var j = 0\\n\\n        while o.count < s {\\n\\n            var i = 0\\n            d *= 2\\n            \\n            while o.count < s, i < o.count {\\n                if o[i] + d > n {\\n                    i += 1\\n                }\\n                else {\\n                    o.insert(o[i] + d, at: i + 1)\\n\\n                    if o[i] + d > m {\\n                        m = o[i] + d\\n                        j = i + 1\\n                    }\\n\\n                    i += 2\\n                }\\n            }\\n        }\\n\\n        var e = o.map { $0 + 1 }\\n        if n % 2 == 1 { e.remove(at: j) }\\n\\n        return o + e\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184256,
                "title": "c-solution-hashmap",
                "content": "# Code\\n```\\nint * bild_array(int n, int **ans_per_n){\\n    if (ans_per_n[n] != NULL){\\n        return ans_per_n[n];\\n    }\\n\\n    int* ans =(int*)malloc(sizeof(int)*n);\\n    if (n == 1){\\n        ans[0] = 1;\\n    } else{\\n        int j = 0;\\n        int * odds = bild_array((n+1)/2,ans_per_n);\\n        for (int x = 0; x < (n+1)/2; x++){\\n            ans[x] = 2*odds[x] - 1;\\n        }\\n        \\n        int * evens = bild_array(n/2,ans_per_n);\\n        for (int y = 0; y < n/2; y++){\\n            ans[((n+1)/2)+y] = 2*evens[y];\\n        }\\n    }\\n    ans_per_n[n] = ans;\\n    return ans;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* beautifulArray(int n, int* returnSize){\\n    int * sol =(int*) malloc(sizeof(int)*n);\\n    *returnSize = n;\\n    if (n == 1){\\n        sol[0] = 1;\\n        return sol;\\n    }\\n    if (n == 2){\\n        sol[0] = 1;\\n        sol[1] = 2;\\n        return sol;\\n    }\\n\\n    // create array in this way: -odds-evens-\\n    int ** ans_per_n = (int**)malloc(sizeof(int*)*(n+1));\\n    for (int i = 0; i < n + 1; i++){\\n        ans_per_n[i] = NULL;\\n    }\\n    \\n    sol = bild_array(n,ans_per_n); \\n    *returnSize = n;\\n\\n\\n    // free\\n    for (int i = 0; i < n; i++){\\n        if (ans_per_n[i] != NULL){\\n            free(ans_per_n[i]);\\n        }\\n    }\\n    free(ans_per_n);\\n\\n    return sol;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint * bild_array(int n, int **ans_per_n){\\n    if (ans_per_n[n] != NULL){\\n        return ans_per_n[n];\\n    }\\n\\n    int* ans =(int*)malloc(sizeof(int)*n);\\n    if (n == 1){\\n        ans[0] = 1;\\n    } else{\\n        int j = 0;\\n        int * odds = bild_array((n+1)/2,ans_per_n);\\n        for (int x = 0; x < (n+1)/2; x++){\\n            ans[x] = 2*odds[x] - 1;\\n        }\\n        \\n        int * evens = bild_array(n/2,ans_per_n);\\n        for (int y = 0; y < n/2; y++){\\n            ans[((n+1)/2)+y] = 2*evens[y];\\n        }\\n    }\\n    ans_per_n[n] = ans;\\n    return ans;\\n}\\n\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* beautifulArray(int n, int* returnSize){\\n    int * sol =(int*) malloc(sizeof(int)*n);\\n    *returnSize = n;\\n    if (n == 1){\\n        sol[0] = 1;\\n        return sol;\\n    }\\n    if (n == 2){\\n        sol[0] = 1;\\n        sol[1] = 2;\\n        return sol;\\n    }\\n\\n    // create array in this way: -odds-evens-\\n    int ** ans_per_n = (int**)malloc(sizeof(int*)*(n+1));\\n    for (int i = 0; i < n + 1; i++){\\n        ans_per_n[i] = NULL;\\n    }\\n    \\n    sol = bild_array(n,ans_per_n); \\n    *returnSize = n;\\n\\n\\n    // free\\n    for (int i = 0; i < n; i++){\\n        if (ans_per_n[i] != NULL){\\n            free(ans_per_n[i]);\\n        }\\n    }\\n    free(ans_per_n);\\n\\n    return sol;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3156812,
                "title": "c",
                "content": "(```)  class Solution {\\npublic:\\n    vector<int> beautifulArray(int n)\\n    {\\n        vector<int> res{1};\\n        \\n        while(res.size() < n)\\n        {\\n            vector<int> tmp;\\n            \\n            for(auto &x: res)\\n            {\\n                if(2*x - 1 <= n)\\n                {\\n                    tmp.push_back(2*x-1);\\n                }\\n            }\\n            \\n            for(auto &x: res)\\n            {\\n                if(2*x  <= n)\\n                {\\n                    tmp.push_back(2*x);\\n                }\\n            }\\n            \\n            res = tmp;\\n        }\\n        \\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n)\\n    {\\n        vector<int> res{1}",
                "codeTag": "Java"
            },
            {
                "id": 3075044,
                "title": "c",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* beautifulArray(int n, int* returnSize){\\n    *returnSize =  n ;\\n    int* ans = malloc(2 * n * sizeof(int) ) ;\\n    ans[0] = 1 ;\\n    if(n == 1){\\n        ans = realloc(ans, n * sizeof(int)) ;\\n        return ans ;\\n    }\\n    int idx = 1 ;\\n    while(idx < n){\\n        for(int i = idx ; i < idx*2; i++){\\n            ans[i] = ans[i-idx] * 2 ;\\n        }\\n        for(int i = 0; i < idx ; i++){\\n            ans[i] = 2 * ans[i] - 1 ;\\n        }\\n        idx *= 2 ;\\n    }\\n    int p = 0 ;\\n    for(int i = 0; i < idx ; i++){\\n        if(ans[i] <= n){\\n            ans[p] = ans[i] ;\\n            p++ ;\\n        }\\n    }\\n    ans = realloc(ans, n * sizeof(int) ) ;\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* beautifulArray(int n, int* returnSize){\\n    *returnSize =  n ;\\n    int* ans = malloc(2 * n * sizeof(int) ) ;\\n    ans[0] = 1 ;\\n    if(n == 1){\\n        ans = realloc(ans, n * sizeof(int)) ;\\n        return ans ;\\n    }\\n    int idx = 1 ;\\n    while(idx < n){\\n        for(int i = idx ; i < idx*2; i++){\\n            ans[i] = ans[i-idx] * 2 ;\\n        }\\n        for(int i = 0; i < idx ; i++){\\n            ans[i] = 2 * ans[i] - 1 ;\\n        }\\n        idx *= 2 ;\\n    }\\n    int p = 0 ;\\n    for(int i = 0; i < idx ; i++){\\n        if(ans[i] <= n){\\n            ans[p] = ans[i] ;\\n            p++ ;\\n        }\\n    }\\n    ans = realloc(ans, n * sizeof(int) ) ;\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2946364,
                "title": "c-o-n-time-and-o-1-extra-space",
                "content": "O(N) time and O(1) extra space (not including output array)!\\n```\\nvector<int> beautifulArray(int n) {\\n    vector <int> ret(n, 1); \\n\\n    // fill in array up to what we can O(N)\\n    // if `n` was always a power of 2 this is all we would need to do\\n    int m;\\n    for (m = 1; 2 * m <= n; m *= 2) {\\n        for (int i = 0; i < m; i++) {\\n            ret[i] = ret[i + m] = ret[i] * 2; // make even and copy\\n            ret[i]--; // odd\\n        }\\n    }\\n    if (m != n) { // `n` is not a power of 2\\n        // one last iterations for the leftovers\\n        m = (n + 1) / 2;\\n        // construct odds on it\\'s own half\\n        for (int i = 0, j = 0; j < m; i++) \\n            if (ret[i] * 2 - 1 <= n)\\n                ret[j++] = ret[i] * 2 - 1;\\n        \\n        // construct evens from odds\\n        for (int i = m, j = 0; j < m; j++) \\n            if (ret[j] + 1 <= n)\\n                ret[i++] = ret[j] + 1;\\n    }\\n    return ret;\\n}\\n```\\n\\nTechnically, this can be combined, but then most of logic is not obvious in the code:\\n```\\nvector<int> beautifulArray(int n) {\\n    vector <int> ret(n, 1);\\n    for (int m = 1; m < n; m *= 2) {\\n        if (m > (n + 1) / 2)\\n            m = (n + 1) / 2;\\n        for (int i = 0, j = 0; j < m; i++) // odds\\n            if (ret[i] * 2 - 1 <= n)\\n                ret[j++] = ret[i] * 2 - 1;\\n        for (int i = m, j = 0; j < m; j++) // evens\\n            if (ret[j] + 1 <= n)\\n                ret[i++] = ret[j] + 1;\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<int> beautifulArray(int n) {\\n    vector <int> ret(n, 1); \\n\\n    // fill in array up to what we can O(N)\\n    // if `n` was always a power of 2 this is all we would need to do\\n    int m;\\n    for (m = 1; 2 * m <= n; m *= 2) {\\n        for (int i = 0; i < m; i++) {\\n            ret[i] = ret[i + m] = ret[i] * 2; // make even and copy\\n            ret[i]--; // odd\\n        }\\n    }\\n    if (m != n) { // `n` is not a power of 2\\n        // one last iterations for the leftovers\\n        m = (n + 1) / 2;\\n        // construct odds on it\\'s own half\\n        for (int i = 0, j = 0; j < m; i++) \\n            if (ret[i] * 2 - 1 <= n)\\n                ret[j++] = ret[i] * 2 - 1;\\n        \\n        // construct evens from odds\\n        for (int i = m, j = 0; j < m; j++) \\n            if (ret[j] + 1 <= n)\\n                ret[i++] = ret[j] + 1;\\n    }\\n    return ret;\\n}\\n```\n```\\nvector<int> beautifulArray(int n) {\\n    vector <int> ret(n, 1);\\n    for (int m = 1; m < n; m *= 2) {\\n        if (m > (n + 1) / 2)\\n            m = (n + 1) / 2;\\n        for (int i = 0, j = 0; j < m; i++) // odds\\n            if (ret[i] * 2 - 1 <= n)\\n                ret[j++] = ret[i] * 2 - 1;\\n        for (int i = m, j = 0; j < m; j++) // evens\\n            if (ret[j] + 1 <= n)\\n                ret[i++] = ret[j] + 1;\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2927166,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<n) {\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        for(int x : ans){\\n          if(2*x-1<=n)\\n          temp.add(x * 2 -1);\\n         }\\n        for(int x : ans){\\n            if(2*x<=n)\\n            temp.add(x * 2);\\n         }\\n        ans = temp;\\n     }\\n        int res[] = new int[n];\\n        for(int i=0;i<n;i++)\\n           res[i]=ans.get(i);\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans = new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<n) {\\n        ArrayList<Integer> temp = new ArrayList<>();\\n        for(int x : ans){\\n          if(2*x-1<=n)\\n          temp.add(x * 2 -1);\\n         }\\n        for(int x : ans){\\n            if(2*x<=n)\\n            temp.add(x * 2);\\n         }\\n        ans = temp;\\n     }\\n        int res[] = new int[n];\\n        for(int i=0;i<n;i++)\\n           res[i]=ans.get(i);\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2911566,
                "title": "easy-faster-efficient-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        List<Integer> al = new ArrayList<>();\\n        if(n == 1){\\n            return new int[]{1};\\n        }\\n        if(n == 2){\\n            return new int[]{1, 2};\\n        }\\n        al.add(1);\\n        al.add(2);\\n        for(int i = 3; i <= n; i++){\\n            List<Integer> odd = new ArrayList<>();\\n            List<Integer> even = new ArrayList<>();\\n            for(int val : al){\\n                int el = 2 * val - 1;\\n                if(el <= n){\\n                    odd.add(el);\\n                }\\n            }\\n            for(int val : al){\\n                int el = 2 * val;\\n                if(el <= n){\\n                    even.add(el);\\n                }\\n            }\\n            al = new ArrayList<>(odd);\\n            for(int val : even){\\n                al.add(val);\\n            }\\n        }\\n        int [] arr = new int[al.size()];\\n        int i = 0;\\n        for(int val : al){\\n            arr[i++] = val;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        List<Integer> al = new ArrayList<>();\\n        if(n == 1){\\n            return new int[]{1};\\n        }\\n        if(n == 2){\\n            return new int[]{1, 2};\\n        }\\n        al.add(1);\\n        al.add(2);\\n        for(int i = 3; i <= n; i++){\\n            List<Integer> odd = new ArrayList<>();\\n            List<Integer> even = new ArrayList<>();\\n            for(int val : al){\\n                int el = 2 * val - 1;\\n                if(el <= n){\\n                    odd.add(el);\\n                }\\n            }\\n            for(int val : al){\\n                int el = 2 * val;\\n                if(el <= n){\\n                    even.add(el);\\n                }\\n            }\\n            al = new ArrayList<>(odd);\\n            for(int val : even){\\n                al.add(val);\\n            }\\n        }\\n        int [] arr = new int[al.size()];\\n        int i = 0;\\n        for(int val : al){\\n            arr[i++] = val;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2909516,
                "title": "python-solution-iteration-divide-and-conquer-faster-than-95",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- Divide and Conquer\\n- Iteration\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        res = [1]\\n        if n==1:\\n            return res \\n\\n        count = 1 \\n        while count<n: \\n            new_list = [2*x for x in res] + [2*x-1 for x in res]  \\n            res = new_list.copy() \\n            count *=2 \\n            new_list.clear() \\n        res_list = list()    \\n        for item in res:  \\n            if item<=n: \\n                res_list += [item]\\n        res.clear() \\n        return res_list \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        res = [1]\\n        if n==1:\\n            return res \\n\\n        count = 1 \\n        while count<n: \\n            new_list = [2*x for x in res] + [2*x-1 for x in res]  \\n            res = new_list.copy() \\n            count *=2 \\n            new_list.clear() \\n        res_list = list()    \\n        for item in res:  \\n            if item<=n: \\n                res_list += [item]\\n        res.clear() \\n        return res_list \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2723730,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<n){\\n          ArrayList<Integer> tmp=new ArrayList<>();\\n          for(int el:ans){\\n              if(2*el-1<=n){\\n                  tmp.add(el*2-1);\\n              }\\n          }\\n              for(int el:ans){\\n                  if(2*el<=n){\\n                      tmp.add(el*2);\\n                  }\\n              }\\n              ans=tmp;\\n        }\\n        int[] res=new int[n];\\n        for(int i=0;i<n;i++){\\n            res[i]=ans.get(i);\\n        }\\n        return res;\\n        }\\n    }\\n             \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        ArrayList<Integer> ans=new ArrayList<>();\\n        ans.add(1);\\n        while(ans.size()<n){\\n          ArrayList<Integer> tmp=new ArrayList<>();\\n          for(int el:ans){\\n              if(2*el-1<=n){\\n                  tmp.add(el*2-1);\\n              }\\n          }\\n              for(int el:ans){\\n                  if(2*el<=n){\\n                      tmp.add(el*2);\\n                  }\\n              }\\n              ans=tmp;\\n        }\\n        int[] res=new int[n];\\n        for(int i=0;i<n;i++){\\n            res[i]=ans.get(i);\\n        }\\n        return res;\\n        }\\n    }\\n             \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2721557,
                "title": "python-easy-to-understand",
                "content": "class Solution(object):\\n    \\n\\tdef beautifulArray(self, n):\\n       \\n        if n == 1:\\n            return [1]\\n        elif n == 2:\\n            return [1,2]\\n        \\n        even = self.beautifulArray(n // 2)\\n        odd = self.beautifulArray((n + 1)// 2)\\n        even = [2*n for n in even]\\n        odd = [2*n - 1 for n in odd]\\n        \\n        return even + odd\\n",
                "solutionTags": [
                    "Python",
                    "Divide and Conquer"
                ],
                "code": "class Solution(object):\\n    \\n\\tdef beautifulArray(self, n):\\n       \\n        if n == 1:\\n            return [1]\\n        elif n == 2:\\n            return [1,2]\\n        \\n        even = self.beautifulArray(n // 2)\\n        odd = self.beautifulArray((n + 1)// 2)\\n        even = [2*n for n in even]\\n        odd = [2*n - 1 for n in odd]\\n        \\n        return even + odd\\n",
                "codeTag": "Java"
            },
            {
                "id": 2678256,
                "title": "c-solution-beautiful-array-odd-even-pattern-math",
                "content": "**Using Math - Odd Even Pattern**\\n* Time Complexity - O( N )\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans = {1};\\n        \\n        while(ans.size() < n){\\n            vector<int> temp;\\n            //For ODD values\\n            for(int i = 0; i < ans.size(); i++){\\n                if( 2*ans[i] - 1 <= n){\\n                    temp.push_back(2*ans[i] - 1);\\n                }\\n            }\\n            //For EVEN Values\\n            for(int i = 0; i < ans.size(); i++){\\n                if( 2*ans[i] <= n){\\n                    temp.push_back(2*ans[i]);\\n                }\\n            }\\n            \\n            ans = temp;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Please Upvote if it helps :)**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Math",
                    "Divide and Conquer"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans = {1};\\n        \\n        while(ans.size() < n){\\n            vector<int> temp;\\n            //For ODD values\\n            for(int i = 0; i < ans.size(); i++){\\n                if( 2*ans[i] - 1 <= n){\\n                    temp.push_back(2*ans[i] - 1);\\n                }\\n            }\\n            //For EVEN Values\\n            for(int i = 0; i < ans.size(); i++){\\n                if( 2*ans[i] <= n){\\n                    temp.push_back(2*ans[i]);\\n                }\\n            }\\n            \\n            ans = temp;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2555059,
                "title": "o-n-time-o-n-space-clear-explanation-three-lines-of-code",
                "content": "![image](https://assets.leetcode.com/users/images/be4bdebb-f990-42fa-a5dc-95b2db2b0912_1662750147.5099263.png)\\n\\n\\n\\tclass Solution:\\n\\t\\t@functools.cache\\n\\t\\tdef beautifulArray(self, n: int) -> List[int]:\\n\\t\\t\\t\"\"\" O(N)TS \"\"\"\\n\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\treturn [1]\\n\\t\\t\\treturn [2 * x - 1 for x in self.beautifulArray((n + 1) // 2)] + [2 * x for x in self.beautifulArray(n // 2)]\\n\\n\\n![image](https://assets.leetcode.com/users/images/eecd513a-c51d-4ff8-ab1a-adb99e7cbc4a_1662750200.8244958.png)\\n",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/be4bdebb-f990-42fa-a5dc-95b2db2b0912_1662750147.5099263.png)\\n\\n\\n\\tclass Solution:\\n\\t\\t@functools.cache\\n\\t\\tdef beautifulArray(self, n: int) -> List[int]:\\n\\t\\t\\t\"\"\" O(N)TS \"\"\"\\n\\t\\t\\tif n <= 1:\\n\\t\\t\\t\\treturn [1]\\n\\t\\t\\treturn [2 * x - 1 for x in self.beautifulArray((n + 1) // 2)] + [2 * x for x in self.beautifulArray(n // 2)]\\n\\n\\n![image](https://assets.leetcode.com/users/images/eecd513a-c51d-4ff8-ab1a-adb99e7cbc4a_1662750200.8244958.png)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2203813,
                "title": "932-beautiful-array-c-100-faster",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> beautifulArray(int n) {\\n\\n\\t\\t\\tvector<int> v = {1};\\n\\n\\t\\t\\twhile(v.size()<n)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvector<int> x;\\n\\n\\t\\t\\t\\tfor(auto c:v)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(c*2-1<=n)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tx.push_back(c*2-1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tfor(auto d:v)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(d*2<=n)\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tx.push_back(d*2);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tv=x;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn v;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> beautifulArray(int n) {\\n\\n\\t\\t\\tvector<int> v = {1}",
                "codeTag": "Java"
            },
            {
                "id": 2119515,
                "title": "ruby-one-liner-beats-100-100",
                "content": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef beautiful_array(n)\\n  (@a ||= [1, [1]])[n] ||= [0, 1].flat_map { |d| beautiful_array((n + d) / 2).map { _1 * 2 - d } }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef beautiful_array(n)\\n  (@a ||= [1, [1]])[n] ||= [0, 1].flat_map { |d| beautiful_array((n + d) / 2).map { _1 * 2 - d } }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2116653,
                "title": "ts-solution-divide-and-conquer",
                "content": "```\\nfunction beautifulArray(n: number): number[] {\\n        if(n === 1) return [1];\\n        return beautifulArray(Math.floor(n/2) + Math.floor(n%2))\\n            .map((num : number) => 2 * num -1)\\n            .concat(beautifulArray(Math.floor(n/2)).map((num : number) => 2 * num));\\n};\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Divide and Conquer"
                ],
                "code": "```\\nfunction beautifulArray(n: number): number[] {\\n        if(n === 1) return [1];\\n        return beautifulArray(Math.floor(n/2) + Math.floor(n%2))\\n            .map((num : number) => 2 * num -1)\\n            .concat(beautifulArray(Math.floor(n/2)).map((num : number) => 2 * num));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2084864,
                "title": "c-code-editorial-explanation",
                "content": "The solution provided guarantees the left hand side are odd and right hand side are even numbers. so left and right won\\'t have duplicates.\\nIt is not trivial to say put them together it covers all number between (1...N). But not difficult to prove: left hand-side max = 2*((N+1)/2) - 1 = N if N is odd or N-1 if N is even. right hand side max = 2 * (N/2) = N if N is even, N-1 if N is odd. So max is always N.\\nNow check the beautifiulness:\\n3.1 Both sides by themselves are correct because each side just multiplied by a constant and possibly reduced by 1 from an already correct sequence. That won\\'t impact the beautifulness.\\n3.2 how about a sequence with a mixture of left and right? Well any such sequence would make A[i] + A[j] an odd number, which is impossible to be equal to 2*A[k], an even number.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> f(int n, unordered_map<int, vector<int>> &memo) {\\n      if(memo.count(n) > 0) {\\n        return memo[n];\\n      }\\n      vector<int> res(n, 0);\\n      if(n == 1) {\\n        res[0] = 1;\\n      }else {\\n        int pos = 0;\\n        for(auto &i : f((n+1)/2, memo)) {\\n          res[pos++] = 2*i - 1;\\n        }\\n        for(auto &i : f((n)/2, memo)) {\\n          res[pos++] = 2*i;\\n        }\\n      }\\n      memo[n] = res;\\n      return res;\\n    }\\n    vector<int> beautifulArray(int n) {\\n      unordered_map<int, vector<int>> memo;\\n      return f(n, memo);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> f(int n, unordered_map<int, vector<int>> &memo) {\\n      if(memo.count(n) > 0) {\\n        return memo[n];\\n      }\\n      vector<int> res(n, 0);\\n      if(n == 1) {\\n        res[0] = 1;\\n      }else {\\n        int pos = 0;\\n        for(auto &i : f((n+1)/2, memo)) {\\n          res[pos++] = 2*i - 1;\\n        }\\n        for(auto &i : f((n)/2, memo)) {\\n          res[pos++] = 2*i;\\n        }\\n      }\\n      memo[n] = res;\\n      return res;\\n    }\\n    vector<int> beautifulArray(int n) {\\n      unordered_map<int, vector<int>> memo;\\n      return f(n, memo);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1901472,
                "title": "why-my-output-isn-t-beautiful",
                "content": "Did I understand the question wrong?\\n\\n![image](https://assets.leetcode.com/users/images/755a6dce-7807-48fa-afe8-a1ce1f1abed8_1648758119.037145.png)\\n",
                "solutionTags": [],
                "code": "Did I understand the question wrong?\\n\\n![image](https://assets.leetcode.com/users/images/755a6dce-7807-48fa-afe8-a1ce1f1abed8_1648758119.037145.png)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1846093,
                "title": "a-novel-solution-that-manually-builds-the-array-o-n-2",
                "content": "```\\ntype Node struct {\\n    val int\\n    pre *Node\\n    next *Node\\n}\\n\\nfunc insertNode(dict *map[int]*Node, hash *map[int]int, head *Node, val int, insert *Node, op int) *Node {\\n    var node *Node = &Node{val:val}\\n    if insert != nil {\\n        if op == 1 {\\n            node.next = insert.next\\n            node.pre = insert\\n            if insert.next != nil {\\n                insert.next.pre = node\\n            }\\n            insert.next = node\\n            (*hash)[val] = (*hash)[insert.val]+1\\n            for tmp := node.next; tmp != nil; tmp=tmp.next {\\n                (*hash)[tmp.val]++\\n            }\\n        } else if op == -1 {\\n            node.pre = insert.pre\\n            node.next = insert\\n            if insert.pre != nil {\\n                insert.pre.next = node\\n            }\\n            insert.pre = node\\n            (*hash)[val] = (*hash)[insert.val]\\n            for tmp := insert; tmp != nil; tmp=tmp.next {\\n                (*hash)[tmp.val]++\\n            }\\n            if insert == head {\\n                head = node\\n            }\\n        }\\n    }\\n    if len(*dict) == 0 {\\n        (*hash)[val] = 1\\n        head = node\\n    }\\n    \\n    (*dict)[val] = node\\n    return head\\n}\\n\\nfunc beautifulArray(n int) []int {\\n    ij := [][]int{}\\n    for i := 1; i <= n; i++ {\\n        ij = append(ij, []int{})\\n    }\\n    \\n    for i := 1; i <= n; i++ {\\n        for j := i-1; j >= 1; j-- {\\n            if i*2-j > n {\\n                break  \\n            } \\n            ij[j-1] = append(ij[j-1], i*2-j)\\n            ij[i*2-j-1] = append(ij[i*2-j-1], j)\\n        }\\n    }\\n    \\n    var s, t int\\n    if n % 2 == 0 {\\n        t = -1\\n    } else {\\n        t = 1\\n    }\\n    l := (n+1)/2\\n    \\n    var dict = map[int]*Node{}\\n    var hash = map[int]int{}\\n    var head *Node\\n    for l > 0 && l <= n{\\n        var insertAt, op = (*Node)(nil), 1\\n        min, max := 0, n+1\\n        \\n        for _, r := range ij[l-1] {\\n            mid := (l+r)/2\\n            _, ok1 := dict[mid]\\n            _, ok2 := dict[r]\\n            \\n            if ok1 && ok2 {\\n                if hash[r] < hash[mid] {\\n                    if hash[mid] < max {\\n                        max = hash[mid]\\n                        if hash[r] <= max && hash[r] >= min {\\n                            insertAt, op = dict[r], 1\\n                        }\\n                    }\\n                } else {\\n                    if hash[mid] > min {\\n                        min = hash[mid]\\n                        if hash[r] <= max && hash[r] >= min {\\n                            insertAt, op = dict[r], -1\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if len(hash) > 0 && insertAt == nil{\\n            insertAt = dict[head.val]\\n        }\\n        \\n        head = insertNode(&dict, &hash, head, l, insertAt, op)\\n        \\n        t = -t\\n        s += 1\\n        l += t*s\\n    }\\n    \\n    res := []int{}\\n    for head != nil {\\n        res = append(res, head.val)\\n        head = head.next\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\ntype Node struct {\\n    val int\\n    pre *Node\\n    next *Node\\n}\\n\\nfunc insertNode(dict *map[int]*Node, hash *map[int]int, head *Node, val int, insert *Node, op int) *Node {\\n    var node *Node = &Node{val:val}\\n    if insert != nil {\\n        if op == 1 {\\n            node.next = insert.next\\n            node.pre = insert\\n            if insert.next != nil {\\n                insert.next.pre = node\\n            }\\n            insert.next = node\\n            (*hash)[val] = (*hash)[insert.val]+1\\n            for tmp := node.next; tmp != nil; tmp=tmp.next {\\n                (*hash)[tmp.val]++\\n            }\\n        } else if op == -1 {\\n            node.pre = insert.pre\\n            node.next = insert\\n            if insert.pre != nil {\\n                insert.pre.next = node\\n            }\\n            insert.pre = node\\n            (*hash)[val] = (*hash)[insert.val]\\n            for tmp := insert; tmp != nil; tmp=tmp.next {\\n                (*hash)[tmp.val]++\\n            }\\n            if insert == head {\\n                head = node\\n            }\\n        }\\n    }\\n    if len(*dict) == 0 {\\n        (*hash)[val] = 1\\n        head = node\\n    }\\n    \\n    (*dict)[val] = node\\n    return head\\n}\\n\\nfunc beautifulArray(n int) []int {\\n    ij := [][]int{}\\n    for i := 1; i <= n; i++ {\\n        ij = append(ij, []int{})\\n    }\\n    \\n    for i := 1; i <= n; i++ {\\n        for j := i-1; j >= 1; j-- {\\n            if i*2-j > n {\\n                break  \\n            } \\n            ij[j-1] = append(ij[j-1], i*2-j)\\n            ij[i*2-j-1] = append(ij[i*2-j-1], j)\\n        }\\n    }\\n    \\n    var s, t int\\n    if n % 2 == 0 {\\n        t = -1\\n    } else {\\n        t = 1\\n    }\\n    l := (n+1)/2\\n    \\n    var dict = map[int]*Node{}\\n    var hash = map[int]int{}\\n    var head *Node\\n    for l > 0 && l <= n{\\n        var insertAt, op = (*Node)(nil), 1\\n        min, max := 0, n+1\\n        \\n        for _, r := range ij[l-1] {\\n            mid := (l+r)/2\\n            _, ok1 := dict[mid]\\n            _, ok2 := dict[r]\\n            \\n            if ok1 && ok2 {\\n                if hash[r] < hash[mid] {\\n                    if hash[mid] < max {\\n                        max = hash[mid]\\n                        if hash[r] <= max && hash[r] >= min {\\n                            insertAt, op = dict[r], 1\\n                        }\\n                    }\\n                } else {\\n                    if hash[mid] > min {\\n                        min = hash[mid]\\n                        if hash[r] <= max && hash[r] >= min {\\n                            insertAt, op = dict[r], -1\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        if len(hash) > 0 && insertAt == nil{\\n            insertAt = dict[head.val]\\n        }\\n        \\n        head = insertNode(&dict, &hash, head, l, insertAt, op)\\n        \\n        t = -t\\n        s += 1\\n        l += t*s\\n    }\\n    \\n    res := []int{}\\n    for head != nil {\\n        res = append(res, head.val)\\n        head = head.next\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1727328,
                "title": "java-backtracking-memo",
                "content": "~~~java\\n\\nclass Solution {\\n    Map<Integer, int[]> memo;\\n    \\n    public int[] beautifulArray(int n) {\\n        memo = new HashMap<>();\\n        \\n        return helper(n);\\n    }\\n    \\n    private int[] helper(int n) {\\n        if (n == 1) {\\n            memo.put(1, new int[]{1});\\n            return new int[]{1};\\n        }\\n        \\n        if (memo.containsKey(n)) {\\n            return memo.get(n);\\n        }\\n        \\n        int mid = (n + 1) / 2;\\n        int[] left = helper(mid);\\n        int[] right = helper(n - mid);\\n        int[] rst = new int[n];\\n        for (int i = 0; i < mid; i++) {\\n            rst[i] = left[i] * 2 - 1;\\n        }\\n        for (int i = mid; i < n; i++) {\\n            rst[i] = right[i - mid] * 2;\\n        }\\n        \\n        memo.put(n, rst);\\n        return rst;\\n    }\\n}\\n\\n\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    Map<Integer, int[]> memo;\\n    \\n    public int[] beautifulArray(int n) {\\n        memo = new HashMap<>();\\n        \\n        return helper(n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1643658,
                "title": "a-simple-three-line-solution-o-n",
                "content": "```\\n    def beautifulArray(self, n):\\n        nums = list(range(1,n+1))\\n        nums.sort(key=lambda x: bin(x)[:1:-1])\\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n    def beautifulArray(self, n):\\n        nums = list(range(1,n+1))\\n        nums.sort(key=lambda x: bin(x)[:1:-1])\\n        return nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1539991,
                "title": "golang-simple-solution-beat-100",
                "content": "```go\\nfunc beautifulArray(N int) []int {\\n\\tbeautArray1024 := make([]int, 0, 1024)\\n\\tbeautArray1024 = append(beautArray1024, 1, 2)\\n\\tfor i := 2; i <= 1024; i*=2 {\\n\\t\\ttemp := make([]int, len(beautArray1024))\\n\\t\\tcopy(temp, beautArray1024)\\n\\t\\tfor index, value := range temp {\\n\\t\\t\\ttemp[index] = 2*value\\n\\t\\t}\\n\\t\\tbeautArray1024 = append(beautArray1024, temp...)\\n\\t\\tfor index := range temp {\\n\\t\\t\\tbeautArray1024[index] = temp[index] - 1\\n\\t\\t}\\n\\t}\\n\\tbeautArray := make([]int, 0, N)\\n\\tfor _, v := range beautArray1024 {\\n\\t\\tif v <= N {\\n\\t\\t\\tbeautArray = append(beautArray, v)\\n\\t\\t}\\n\\t}\\n\\treturn beautArray\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc beautifulArray(N int) []int {\\n\\tbeautArray1024 := make([]int, 0, 1024)\\n\\tbeautArray1024 = append(beautArray1024, 1, 2)\\n\\tfor i := 2; i <= 1024; i*=2 {\\n\\t\\ttemp := make([]int, len(beautArray1024))\\n\\t\\tcopy(temp, beautArray1024)\\n\\t\\tfor index, value := range temp {\\n\\t\\t\\ttemp[index] = 2*value\\n\\t\\t}\\n\\t\\tbeautArray1024 = append(beautArray1024, temp...)\\n\\t\\tfor index := range temp {\\n\\t\\t\\tbeautArray1024[index] = temp[index] - 1\\n\\t\\t}\\n\\t}\\n\\tbeautArray := make([]int, 0, N)\\n\\tfor _, v := range beautArray1024 {\\n\\t\\tif v <= N {\\n\\t\\t\\tbeautArray = append(beautArray, v)\\n\\t\\t}\\n\\t}\\n\\treturn beautArray\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1482077,
                "title": "odd-even-java-recursive-solution-o-n-no-extra-space",
                "content": "Let\\'s start from a simple 3 numbers case: `(1, 2, 3)` -> the only thing we need to do is move `2` out of `1` and `3` -> `(1, 3, 2)`.\\nThen what if the case is `(1, 5, 9 )` which has `increment = 4`? It\\'s same thing -> move `3` out of `1` and `5` -> `(1, 9, 5)`.\\nNow, what if the case is `(1, 3, 5, 7, 9)` ? With odd + even or divide + conque idea in mind, we can simply divide it to `(1, 5, 9)` and `(3, 7)`. Since no change needed for 2 numbers case, after following the above steps, we can conque them to `(1, 9, 5, 3, 7)`.\\n\\nNow, coming back the this problem, if input n is `10`, then our case becomes to:\\n\\n\\t                         (1, 2, 3, 4, 5, 6, 7, 8, 9, 10), inc = 1\\n\\t\\t\\t\\t\\t\\t\\t                  |\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  | => [1, 9, 5, 3, 7, 2, 10, 6, 4, 8]\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t  |\\n\\t\\t  (1, 3, 5, 7, 9),  inc = 2               +              (2, 4, 6, 8, 10),  inc = 2\\n\\t\\t            |                                                      |\\n\\t                | => [1, 9, 5, 3, 7]                                   | => [2, 10, 6, 4, 8]\\n\\t\\t\\t\\t\\t|                                                      |\\n\\t    (1, 5, 9)   +   (3, 7), inc = 4                        (2, 6, 10)   +   (4, 8), inc = 4\\n\\t\\t    |                                                       |\\n\\t        | => [1, 9, 5]                                          | => [2, 10, 6]\\n\\t\\t\\t|                                                       |\\n\\t(1, 9) + (5), inc = 8                                (2, 10) + (6), inc = 8\\n \\n\\n\\n\\n```\\nclass Solution {\\n    int k, n;\\n    int[] res;\\n    public int[] beautifulArray(int n) {\\n        res = new int[n];\\n        k = 0;\\n        this.n = n;\\n        divideConque(1, 1);\\n        return res;\\n    }\\n    private void divideConque(int start, int increment) {\\n        if (start + increment > n) {\\n            res[k++] = start;\\n            return;\\n        }\\n        divideConque(start, 2 * increment);\\n        divideConque(start + increment, 2 * increment);\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int k, n;\\n    int[] res;\\n    public int[] beautifulArray(int n) {\\n        res = new int[n];\\n        k = 0;\\n        this.n = n;\\n        divideConque(1, 1);\\n        return res;\\n    }\\n    private void divideConque(int start, int increment) {\\n        if (start + increment > n) {\\n            res[k++] = start;\\n            return;\\n        }\\n        divideConque(start, 2 * increment);\\n        divideConque(start + increment, 2 * increment);\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1437516,
                "title": "c-easy-solution",
                "content": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int>ans;\\n        ans.push_back(1);\\n        while(ans.size()<n)\\n        {\\n            vector<int>t;\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(2*ans[i]-1<=n)\\n                {\\n                    t.push_back(2*ans[i]-1);\\n                }\\n            }\\n                        for(int i=0;i<ans.size();i++)\\n            {\\n                if(2*ans[i]<=n)\\n                {\\n                    t.push_back(2*ans[i]);\\n                }\\n            }\\n            ans=t;\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int>ans;\\n        ans.push_back(1);\\n        while(ans.size()<n)\\n        {\\n            vector<int>t;\\n            for(int i=0;i<ans.size();i++)\\n            {\\n                if(2*ans[i]-1<=n)\\n                {\\n                    t.push_back(2*ans[i]-1);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1430076,
                "title": "java-nlog-n-0ms-different-recursive-solution-thinking",
                "content": "**Idea / Intuition**\\n* The strategy that I found was that any 3 of the elements which are same distance apart in the same sequence would cause the array to not be beautiful.\\n* That is 1,2,3 are not beautiful and also 1,3,5 . But I realized that if I split the array as odds and evens then between the two subarrays if we pick one from each the beautiful condition was satisfied (ofcourse because even + odd divided by 2 will not be an integer :) ). \\n* Still within each half it was not beautiful. Then I thought for each half as well, if we did the same but not thinking of odds and evens as numbers but indices then it would make the new smaller quarters beautiful. Because the equidistant 3 numbers need to be shuffled, so **we pick alternatively and group them together.**\\n\\n**Example:**\\n\\t[1,2,3,4,5,6]    -> [1,3,5] & [2,4,6] **(beautiful condition satisfied for any i from first half and j from second half)**\\n[1,3,5] & [2,4,6]  -> [1,5] & [3] & [2,6] & [4] ** (now (1+3)/2 was not 5 and same for (2+4)/2)**\\n\\nSo I inferred that if we did it till we reach individual elements we would have a beautiful array. So here is my solution below:\\n**Code:**\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int[] res= new int[n];\\n        for(int i=0;i<n;i++)\\n            res[i]=i+1;\\n        recur(0,n-1,res);\\n        return res;\\n    }\\n    \\n    void recur(int i, int j, int[] res){\\n        if(j-i<2) return;\\n        int even=(j-i+1)/2;\\n        int odd=even;\\n        if ((j-i+1)%2==1) odd++;\\n        int[] odarr= new int[odd];\\n        int[] evarr= new int[even];\\n        int ic=i,jc=j,vi=0;\\n        while(ic<=jc){\\n            odarr[vi]=res[ic];\\n            if(ic+1<=jc) evarr[vi]=res[ic+1];\\n            ic+=2;vi++;\\n        }\\n        for(int x=0;x<odd;x++)\\n            res[i+x]=odarr[x];\\n        for(int x=0;x<even;x++)\\n            res[i+odd+x]=evarr[x];\\n        recur(i, i+odd-1, res);\\n        recur(i+odd, j, res);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int[] res= new int[n];\\n        for(int i=0;i<n;i++)\\n            res[i]=i+1;\\n        recur(0,n-1,res);\\n        return res;\\n    }\\n    \\n    void recur(int i, int j, int[] res){\\n        if(j-i<2) return;\\n        int even=(j-i+1)/2;\\n        int odd=even;\\n        if ((j-i+1)%2==1) odd++;\\n        int[] odarr= new int[odd];\\n        int[] evarr= new int[even];\\n        int ic=i,jc=j,vi=0;\\n        while(ic<=jc){\\n            odarr[vi]=res[ic];\\n            if(ic+1<=jc) evarr[vi]=res[ic+1];\\n            ic+=2;vi++;\\n        }\\n        for(int x=0;x<odd;x++)\\n            res[i+x]=odarr[x];\\n        for(int x=0;x<even;x++)\\n            res[i+odd+x]=evarr[x];\\n        recur(i, i+odd-1, res);\\n        recur(i+odd, j, res);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1389201,
                "title": "ruby-sorting-by-lower-bits-of-binary-representation",
                "content": "Sorting numbers by lower bits makes the array beautiful.\\n\\nLet\\'s  take number 8. In binary representation it is `100`. Multiplying by 2 results in `1000`. To make sum of two numbers resulting in `1000` both must have lower bits set, e.g. `111` and `001`, `110` and `010`, `110` and `011`. I.e. all of these numbers go on one side of `100` when sorting by lower bits.\\n\\n```\\ndef beautiful_array(n)\\n \\xA0  (1..n).sort_by{ |x| x.to_s(2).reverse }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautiful_array(n)\\n \\xA0  (1..n).sort_by{ |x| x.to_s(2).reverse }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1387475,
                "title": "ruby-o-n-simple-iterative-solution",
                "content": "```\\ndef beautiful_array(n)\\n    r = [1]\\n\\n    while r.size < n\\n        r = r.map{ |n| n * 2 - 1 } + r.map{ |n| n * 2 }\\n    end\\n\\n    r.reject{ |x| x > n }\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef beautiful_array(n)\\n    r = [1]\\n\\n    while r.size < n\\n        r = r.map{ |n| n * 2 - 1 } + r.map{ |n| n * 2 }\\n    end\\n\\n    r.reject{ |x| x > n }\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1375014,
                "title": "c-divide-and-conquer-sln-beats-100",
                "content": "```\\nvector<int> beautifulArray(int n) {\\n        vector<vector<int>> dp(n + 1, vector<int>());\\n        function<vector<int>(int)> get_or_compute;\\n        get_or_compute = [&get_or_compute, &dp](int k) {\\n            if (!dp[k].empty()) {\\n                return dp[k];\\n            }\\n            if (k == 1) {\\n                return dp[1] = {1};\\n            }\\n            int i = 0;\\n            vector<int> res(k);\\n            for (int x : get_or_compute((k + 1) / 2)) {\\n                res[i++] = x * 2 - 1;\\n            }\\n            for (int x : get_or_compute(k / 2)) {\\n                res[i++] = x * 2;\\n            }\\n            return dp[k] = move(res);\\n        };\\n        return get_or_compute(n);\\n    }",
                "solutionTags": [],
                "code": "```\\nvector<int> beautifulArray(int n) {\\n        vector<vector<int>> dp(n + 1, vector<int>());\\n        function<vector<int>(int)> get_or_compute;\\n        get_or_compute = [&get_or_compute, &dp](int k) {\\n            if (!dp[k].empty()) {\\n                return dp[k];\\n            }\\n            if (k == 1) {\\n                return dp[1] = {1};\\n            }\\n            int i = 0;\\n            vector<int> res(k);\\n            for (int x : get_or_compute((k + 1) / 2)) {\\n                res[i++] = x * 2 - 1;\\n            }\\n            for (int x : get_or_compute(k / 2)) {\\n                res[i++] = x * 2;\\n            }\\n            return dp[k] = move(res);\\n        };\\n        return get_or_compute(n);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1373568,
                "title": "is-this-solution-o-nlogn",
                "content": "```\\nclass Solution {\\npublic:\\n    void merge_vector(vector<int> &vec)\\n    {\\n        if (vec.size() < 2)\\n            return;\\n        int l = vec.size();\\n        int c = 0;\\n        vector<int> left((l + 1) / 2);\\n        vector<int> right(l / 2);\\n        for (int i = 0; i < l; i += 2)\\n            left[c++] = vec[i];\\n        c = 0;\\n        for (int i = 1; i < l; i += 2)\\n            right[c++] = vec[i];\\n        c = 0;\\n        merge_vector(left);\\n        merge_vector(right);\\n        for (auto &&v : left)\\n            vec[c++] = v;\\n        for (auto &&v : right)\\n            vec[c++] = v;\\n        return;\\n    }\\n    vector<int> beautifulArray(int n) {\\n        vector<int> res(n);\\n        for (int i = 0; i < n; i++)\\n            res[i] = i + 1;\\n        merge_vector(res);\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void merge_vector(vector<int> &vec)\\n    {\\n        if (vec.size() < 2)\\n            return;\\n        int l = vec.size();\\n        int c = 0;\\n        vector<int> left((l + 1) / 2);\\n        vector<int> right(l / 2);\\n        for (int i = 0; i < l; i += 2)\\n            left[c++] = vec[i];\\n        c = 0;\\n        for (int i = 1; i < l; i += 2)\\n            right[c++] = vec[i];\\n        c = 0;\\n        merge_vector(left);\\n        merge_vector(right);\\n        for (auto &&v : left)\\n            vec[c++] = v;\\n        for (auto &&v : right)\\n            vec[c++] = v;\\n        return;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1372686,
                "title": "c-recursive-solution",
                "content": "Split numbers into odd and even parts; in each part, recurisively split. \\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if (n == 1) return {1};\\n        if (n == 2) return {1,2};\\n        if (n == 3) return {1,3,2};\\n        if (n == 4) return {1,3,2,4};\\n        vector<int> ans(n);\\n        int index = 0;\\n        int k = (n+1)/2;\\n        vector<int> base = beautifulArray(k);\\n        for (int i = 0; i < k; ++i) {\\n            ans[index++] = 2*base[i]-1;   \\n        }\\n        for (int i = 0; i < k; ++i) {\\n            if (2*base[i]>n) continue;\\n            ans[index++] = 2*base[i];   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        if (n == 1) return {1};\\n        if (n == 2) return {1,2};\\n        if (n == 3) return {1,3,2};\\n        if (n == 4) return {1,3,2,4};\\n        vector<int> ans(n);\\n        int index = 0;\\n        int k = (n+1)/2;\\n        vector<int> base = beautifulArray(k);\\n        for (int i = 0; i < k; ++i) {\\n            ans[index++] = 2*base[i]-1;   \\n        }\\n        for (int i = 0; i < k; ++i) {\\n            if (2*base[i]>n) continue;\\n            ans[index++] = 2*base[i];   \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371274,
                "title": "c-easy-dfs-solution-with-explicit-explanation",
                "content": "Firstly, we devide array into two partition, one of it consist of odd numbers and other consist of even, then, in the conjunction of two arrays, two of the numbers are in the proper place (for the reason odd + even would not be even) .  \\n\\nand then, odd number could be written as 1+2K_i, as well as even number could be written as 2K_i, we could devided K_i into two partition, odd and even, and, for the same reason, in the conjunction, those number are in the correct place.  If we iterate this process, we could get our beautiful array\\n\\nif we play attention to the detail, we would find out that, after we devided array 1,2,3, ... , n into two part, such as 1,3,5,...,2K+1,2,4,6,...,2K, each number are still with the same key value Ki (or index) , it mean 1,3,5,...,2K+1 also could be written as  1 + 0,1 + 2 * 1,1 + 2 * 2,..., 1 + 2 * k, and the function we use to devide array into two part are still useful to devide the changing array, hence dfs is useful in that situation. \\n```\\nclass Solution {\\npublic:\\n    vector<int> re;\\n    void rearrange(int left,int right){\\n        vector<int> tmp(re.size(),0);\\n        for(int i=left;i<=(right+left)/2;++i){\\n            tmp[i]=re[2*(i-left)+left];\\n        }\\n        for(int i=1+(right+left)/2;i<=right;++i){\\n            tmp[i]=re[2*(i-1-(right+left)/2)+1+left];\\n        }\\n        for(int i=left;i<=right;++i){\\n            re[i]=tmp[i];\\n        }\\n        return ;\\n    }\\n    void dfs(int left,int right){\\n        if(left==right) return ;\\n        rearrange(left,right);\\n        int mid=(left+right)>>1;\\n        dfs(left,mid);\\n        dfs(mid+1,right);\\n        return ;\\n    }\\n    vector<int> beautifulArray(int n) {\\n        for(int i=1;i<=n;++i) re.push_back(i);\\n        dfs(0,re.size()-1);\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> re;\\n    void rearrange(int left,int right){\\n        vector<int> tmp(re.size(),0);\\n        for(int i=left;i<=(right+left)/2;++i){\\n            tmp[i]=re[2*(i-left)+left];\\n        }\\n        for(int i=1+(right+left)/2;i<=right;++i){\\n            tmp[i]=re[2*(i-1-(right+left)/2)+1+left];\\n        }\\n        for(int i=left;i<=right;++i){\\n            re[i]=tmp[i];\\n        }\\n        return ;\\n    }\\n    void dfs(int left,int right){\\n        if(left==right) return ;\\n        rearrange(left,right);\\n        int mid=(left+right)>>1;\\n        dfs(left,mid);\\n        dfs(mid+1,right);\\n        return ;\\n    }\\n    vector<int> beautifulArray(int n) {\\n        for(int i=1;i<=n;++i) re.push_back(i);\\n        dfs(0,re.size()-1);\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370218,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        \\n        vector<int>memo = {1};\\n        \\n        while(memo.size() < n)\\n        {\\n             vector<int>curr;\\n            \\n            for(auto x : memo)\\n            {\\n                 if(2*x-1 <= n)\\n                     curr.push_back(2*x-1);\\n            }\\n            for(auto x : memo)\\n            {\\n                 if(2*x <= n)\\n                     curr.push_back(2*x);\\n            }\\n            memo = curr;\\n        }\\n        return memo;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        \\n        vector<int>memo = {1};\\n        \\n        while(memo.size() < n)\\n        {\\n             vector<int>curr;\\n            \\n            for(auto x : memo)\\n            {\\n                 if(2*x-1 <= n)\\n                     curr.push_back(2*x-1);\\n            }\\n            for(auto x : memo)\\n            {\\n                 if(2*x <= n)\\n                     curr.push_back(2*x);\\n            }\\n            memo = curr;\\n        }\\n        return memo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369773,
                "title": "java-easy-1ms-with-explanation",
                "content": "1. As per problem condition A+B != 2C, where  A<C<B\\nObviously, if  A is odd and  B is even (and vice versa) then we satisfy condition with any C in-between.\\nFor ex.  in the array 2,4,6,8,  1,3,5,7,9 , for any A from 2,4,6,8 and B from 1,3,5,7,9, condition is always valid \\nFinally, every array can be divided into odds and evens, so both groups will co-satisfy condition.\\nBut what to do with each group itsef?\\n\\n2. Let\\'s talk about even group.\\nA+B != 2C, all are evens, let\\'s divide them by 2\\nA/2 + B/2 != c; where C is even, A/2 and B/2 can be odd or even \\nif we regroup all given evens by placing first evens with odd A/2 and then all evens with even B/2, then we satisfy condition for any A and B and any C in-between\\n2,4,6,8,10,12,14,16\\nA : 2,6,10,14,  B: 4,8,12,16\\n\\n3. There is intersting property for any A,B,C.\\nA+B !=2C, where A<C<B\\nif w increment A, B, C, then condition is still valid\\nA+1+B+1 != 2*(C+1)\\nA+B+2 != 2C +2\\nA+B!=C\\n\\n4. if we increment all items of  Odd group, then we can treat it as Even group. We only need to adjust group back afterwards by decrement \\n\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int m = n/2 + n%2;\\n        int[] buf = new int[n];\\n        for(int i=1;i<=n;i+=2)\\n            buf[i/2] = i;\\n        for(int i=2;i<=n;i+=2)\\n            buf[m + i/2 -1] = i;\\n        //1,3,5,7,9,  2,4,6,8,10\\n        recOdd(buf,0,m-1);\\n        recEven(buf,m, n-1);\\n        return buf;\\n    }\\n    private void recOdd(int[] buf, int from, int to){\\n        if(from <0 || from>=to || to>=buf.length)\\n            return;\\n        for(int f=from;f<=to;f++)\\n            buf[f]++;\\n        recEven(buf,from, to);\\n        for(int f=from;f<=to;f++)\\n            buf[f]--;\\n        \\n    }\\n    private void recEven(int[] buf, int from, int to){\\n        if(from <0 || from>=to || to>=buf.length)\\n            return;\\n\\n        for(int i=from;i<=to;i++)\\n            buf[i]/=2;\\n\\n        int f = from, t = to;\\n        while(f<t){\\n            while(f < t && buf[f]%2==1) \\n                f++;\\n            while(f < t && buf[t]%2==0)\\n                t--;\\n            if(f < t){\\n                int temp = buf[f];\\n                buf[f]=buf[t];\\n                buf[t] = temp;\\n            }\\n\\n        }\\n        recOdd(buf, from, f+buf[f]%2-1);\\n        recEven(buf, f+buf[f]%2, to);\\n\\n        for(int i=from;i<=to;i++)\\n            buf[i]*=2;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        int m = n/2 + n%2;\\n        int[] buf = new int[n];\\n        for(int i=1;i<=n;i+=2)\\n            buf[i/2] = i;\\n        for(int i=2;i<=n;i+=2)\\n            buf[m + i/2 -1] = i;\\n        //1,3,5,7,9,  2,4,6,8,10\\n        recOdd(buf,0,m-1);\\n        recEven(buf,m, n-1);\\n        return buf;\\n    }\\n    private void recOdd(int[] buf, int from, int to){\\n        if(from <0 || from>=to || to>=buf.length)\\n            return;\\n        for(int f=from;f<=to;f++)\\n            buf[f]++;\\n        recEven(buf,from, to);\\n        for(int f=from;f<=to;f++)\\n            buf[f]--;\\n        \\n    }\\n    private void recEven(int[] buf, int from, int to){\\n        if(from <0 || from>=to || to>=buf.length)\\n            return;\\n\\n        for(int i=from;i<=to;i++)\\n            buf[i]/=2;\\n\\n        int f = from, t = to;\\n        while(f<t){\\n            while(f < t && buf[f]%2==1) \\n                f++;\\n            while(f < t && buf[t]%2==0)\\n                t--;\\n            if(f < t){\\n                int temp = buf[f];\\n                buf[f]=buf[t];\\n                buf[t] = temp;\\n            }\\n\\n        }\\n        recOdd(buf, from, f+buf[f]%2-1);\\n        recEven(buf, f+buf[f]%2, to);\\n\\n        for(int i=from;i<=to;i++)\\n            buf[i]*=2;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369728,
                "title": "is-2-1-4-3-5-a-valid-solution-for-n-5",
                "content": "I am confused as to why **2,1,4,3,5** is not a valid answer for n=5. Similarly, why 2,1,4,3,6,5 not a valid solution for n=6?",
                "solutionTags": [],
                "code": "I am confused as to why **2,1,4,3,5** is not a valid answer for n=5. Similarly, why 2,1,4,3,6,5 not a valid solution for n=6?",
                "codeTag": "Unknown"
            },
            {
                "id": 1369540,
                "title": "c-easy-to-understand-beautiful-array-fast-and-efficient",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans ;\\n        ans.push_back(1) ;\\n\\t\\tvector<int> temp ;\\n        while(ans.size() < n)\\n        {\\n            temp.clear();\\n            for(auto i:ans)\\n            {\\n                if(i*2 - 1 <= n)\\n                {\\n                    temp.push_back(i*2 - 1) ;\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(i*2 <= n)\\n                {\\n                    temp.push_back(i*2) ;\\n                }\\n            }\\n            ans = temp ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        vector<int> ans ;\\n        ans.push_back(1) ;\\n\\t\\tvector<int> temp ;\\n        while(ans.size() < n)\\n        {\\n            temp.clear();\\n            for(auto i:ans)\\n            {\\n                if(i*2 - 1 <= n)\\n                {\\n                    temp.push_back(i*2 - 1) ;\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(i*2 <= n)\\n                {\\n                    temp.push_back(i*2) ;\\n                }\\n            }\\n            ans = temp ;\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369535,
                "title": "c-easy-to-understand-fast-and-efficient-solution",
                "content": "**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**\\n```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n       vector<int> ans;\\n        ans.push_back(1);\\n        vector<int> temp;\\n        while(ans.size()<n)\\n        {\\n            temp.clear();\\n            for(auto i:ans)\\n            {\\n                if(2*i-1<=n)\\n                {\\n                    temp.push_back(2*i-1);\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(2*i<=n)\\n                {\\n                    temp.push_back(2*i);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n       vector<int> ans;\\n        ans.push_back(1);\\n        vector<int> temp;\\n        while(ans.size()<n)\\n        {\\n            temp.clear();\\n            for(auto i:ans)\\n            {\\n                if(2*i-1<=n)\\n                {\\n                    temp.push_back(2*i-1);\\n                }\\n            }\\n            for(auto i:ans)\\n            {\\n                if(2*i<=n)\\n                {\\n                    temp.push_back(2*i);\\n                }\\n            }\\n            ans=temp;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369501,
                "title": "c-solution-o-n-solution-beautiful-array",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Beautiful Array.\\nMemory Usage: 7.2 MB, less than 74.91% of C++ online submissions for Beautiful Array.\\n*********************************\\nI took help from youtube because this is weirdest question on leetcode\\n\\n***********************************\\nvector<int> beautifulArray(int n) {\\n        vector<int>ans={1};  // our final/resultant array\\n        while(ans.size()<n)  // this loop will run until all the number are not generated till n\\n        {\\n           vector<int>res; //it is like a temparory array\\n\\t\\t   //for all the odd number \\n            for(auto &x : ans) \\n            {\\n              if(x*2-1<=n) res.push_back(x*2-1);\\n            }\\n\\t\\t\\t//for all the even number \\n            for(auto &x : ans)\\n            {\\n              if(x*2<=n) res.push_back(x*2);\\n            }\\n            ans=res;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Beautiful Array.\\nMemory Usage: 7.2 MB, less than 74.91% of C++ online submissions for Beautiful Array.\\n*********************************\\nI took help from youtube because this is weirdest question on leetcode\\n\\n***********************************\\nvector<int> beautifulArray(int n) {\\n        vector<int>ans={1};  // our final/resultant array\\n        while(ans.size()<n)  // this loop will run until all the number are not generated till n\\n        {\\n           vector<int>res; //it is like a temparory array\\n\\t\\t   //for all the odd number \\n            for(auto &x : ans) \\n            {\\n              if(x*2-1<=n) res.push_back(x*2-1);\\n            }\\n\\t\\t\\t//for all the even number \\n            for(auto &x : ans)\\n            {\\n              if(x*2<=n) res.push_back(x*2);\\n            }\\n            ans=res;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1369455,
                "title": "go-0ms-o-n-using-bit-reversal",
                "content": "This solution generates the exact same arrays on the test cases as the built-in solution (tested with n = 1000).\\n\\nI noticed that evens on one side and odds on the other is a good strategy, since the average of even and odd is a fraction so you only need to worry about the in-between numbers within the evens/odds sections.\\n\\nSimilarly, within the evens section you can have sub-sections of multiples-of-4 and not-multiples of-4, since averaging one of each will be an odd number (since non-multiple-of-4 + multiple-of-4 is non-multiple-of-4, and non-multiple-of-4 divided by 2 is odd).\\n\\nGenerating a sequence sorted by the ones place first, then the twos place etc can be done by reversing the bits of an iterator that counts up by one.  Reversing the bits can cause some numbers to be too big, this solution gets around that by generating all the numbers with the same number of (binary) digits and discarding the ones that are too big.\\n\\n```\\nimport \"math/bits\"\\n\\nfunc beautifulArray(n int) []int {\\n    out := make([]int, 0, n)\\n    blen := bits.Len16(uint16(n))\\n    twoPow := uint16(1 << blen)\\n    for i := uint16(0); i < twoPow; i++ {\\n        num := int(bits.Reverse16(i) >> (16-blen))\\n        if num < n {\\n            out = append(out, num + 1)\\n        }\\n    }\\n    return out\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport \"math/bits\"\\n\\nfunc beautifulArray(n int) []int {\\n    out := make([]int, 0, n)\\n    blen := bits.Len16(uint16(n))\\n    twoPow := uint16(1 << blen)\\n    for i := uint16(0); i < twoPow; i++ {\\n        num := int(bits.Reverse16(i) >> (16-blen))\\n        if num < n {\\n            out = append(out, num + 1)\\n        }\\n    }\\n    return out\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1369387,
                "title": "javascript-even-odd-enlarge-from-1-80ms-100",
                "content": "```\\nconst beautifulArray = (n) => {\\n    let res = [1];\\n    while (res.length < n) {\\n        let tmp = [];\\n        for (const x of res) {\\n            if (x * 2 - 1 <= n) tmp.push(x * 2 - 1);\\n        }\\n        for (const x of res) {\\n            if (x * 2 <= n) tmp.push(x * 2);\\n        }\\n        res = tmp;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst beautifulArray = (n) => {\\n    let res = [1];\\n    while (res.length < n) {\\n        let tmp = [];\\n        for (const x of res) {\\n            if (x * 2 - 1 <= n) tmp.push(x * 2 - 1);\\n        }\\n        for (const x of res) {\\n            if (x * 2 <= n) tmp.push(x * 2);\\n        }\\n        res = tmp;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1369381,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n        List<int> beautiful = new List<int>{1};\\n        while(beautiful.Count<n){\\n            List<int> temp = new List<int>();\\n            foreach(int i in beautiful){\\n                if((i*2-1)<=n) temp.Add((i*2-1));\\n            }\\n            foreach(int j in beautiful){\\n                if(2*j<=n) temp.Add(2*j);\\n            }\\n            beautiful=temp;\\n        }\\n        return beautiful.ToArray();\\n    }\\n}\\n  \\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] BeautifulArray(int n) {\\n        List<int> beautiful = new List<int>{1};\\n        while(beautiful.Count<n){\\n            List<int> temp = new List<int>();\\n            foreach(int i in beautiful){\\n                if((i*2-1)<=n) temp.Add((i*2-1));\\n            }\\n            foreach(int j in beautiful){\\n                if(2*j<=n) temp.Add(2*j);\\n            }\\n            beautiful=temp;\\n        }\\n        return beautiful.ToArray();\\n    }\\n}\\n  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369350,
                "title": "solution-based-on-inspection-and-oeis-org",
                "content": "Before I got this solution, my other solution spat out these output for n=1...10\\n![image](https://assets.leetcode.com/users/images/ce1c1fb7-edbf-427d-9d49-c9b321648c1a_1627526519.91102.png)\\nIf you look closely, you\\'ll notice that in this specific output, the answer for n is just the answer for n-1 with n inserted somewhere. Looking up the sequence of insert positions in 1-based indexing (1,2,2,4,2,...), you\\'ll find this sequence: https://oeis.org/A088371. Therefore, all that\\'s needed to be done is get beautifulArray(n-1), and insert n at a(n) position. Formula for a(n) is given in the link also\\n```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int a(int n) {\\n        if (dp[n] != -1) { return dp[n]; }\\n\\n        if (n == 1) { return 1; }\\n        if (n == 2) { return 2; }\\n\\n        if (n % 2 == 0) {\\n            dp[n] = n/2 + a(n / 2);\\n        }\\n\\n        else { \\n            dp[n] = a((n + 1) / 2); \\n        }\\n\\n        return dp[n];\\n    }\\n\\n    vector<int> beautifulArray(int n) {\\n        if (dp.size() == 0) {\\n            dp = vector<int>(n+1, -1);\\n        }\\n\\n        if (n == 1) {\\n            return { 1 };\\n        }\\n\\n        if (n == 2) {\\n            return { 1,2 };\\n        }\\n\\n        if (n == 3) {\\n            return { 1,3,2 };\\n        }\\n\\n        vector<int> res = beautifulArray(n - 1);\\n        int p = a(n) - 1;\\n        res.insert(res.begin() + p, n);\\n\\n        return res;\\n    }\\n};\\n```\\nSpace complexity: O(n)\\nTime complexity: I actually dont know, maybe the inserting part makes it O(n^2)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> dp;\\n    int a(int n) {\\n        if (dp[n] != -1) { return dp[n]; }\\n\\n        if (n == 1) { return 1; }\\n        if (n == 2) { return 2; }\\n\\n        if (n % 2 == 0) {\\n            dp[n] = n/2 + a(n / 2);\\n        }\\n\\n        else { \\n            dp[n] = a((n + 1) / 2); \\n        }\\n\\n        return dp[n];\\n    }\\n\\n    vector<int> beautifulArray(int n) {\\n        if (dp.size() == 0) {\\n            dp = vector<int>(n+1, -1);\\n        }\\n\\n        if (n == 1) {\\n            return { 1 };\\n        }\\n\\n        if (n == 2) {\\n            return { 1,2 };\\n        }\\n\\n        if (n == 3) {\\n            return { 1,3,2 };\\n        }\\n\\n        vector<int> res = beautifulArray(n - 1);\\n        int p = a(n) - 1;\\n        res.insert(res.begin() + p, n);\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369272,
                "title": "python3-recursion-recursive-solution",
                "content": "The key ideas are:\\n- The array can be formed by placing all even number in front of odd numbers, because  even and odd number cannot have a interger average. \\n- The \"Beauty\" of an array is invariant of any addition or multiplication by constants to each of its elements.\\n- An array of consecutive even numbers can be transformed into an array of consecutive integers by dividing each by 2 and the \"Beauty\" will not change.\\n- An array of consecutive odd numbers can be transformed into array of consecutive integers by adding one and dividing by 2, and the \"Beauty\" will not change.\\n\\n```\\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n==1: return [1]\\n        \\n        even=[2*i for i in self.beautifulArray(n//2)]\\n        odd=[2*i-1 for i in self.beautifulArray(n-n//2)]\\n        \\n        return even+odd\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n==1: return [1]\\n        \\n        even=[2*i for i in self.beautifulArray(n//2)]\\n        odd=[2*i-1 for i in self.beautifulArray(n-n//2)]\\n        \\n        return even+odd\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1369262,
                "title": "beautiful-array-using-even-odd-indexes-approach",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        def dfs(arr):\\n            if len(arr) <= 1:\\n                return arr\\n            even,odd = [],[]\\n            for i in range(len(arr)):\\n                if i & 1:\\n                    odd.append(arr[i])\\n                else:\\n                    even.append(arr[i])\\n            return dfs(odd) + dfs(even)\\n        return dfs(range(1,n+1))\\n```\\nif you put the permutation in order like 1,2,3,4,5,6,7 you will notice that for a center number, num[center] and num[center-x] and number[center+x] where x = 1,2,3,4,5...  satisfy the 2k = i + j. so you need to break them up somehow.\\none way is to separate them by even,odd index which break some of the 2k = i,j but not all of them. there are still problems in the subsequent even odd lists. so separate them out again into even odd index. keep doing this until one element remains and build it back up.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        def dfs(arr):\\n            if len(arr) <= 1:\\n                return arr\\n            even,odd = [],[]\\n            for i in range(len(arr)):\\n                if i & 1:\\n                    odd.append(arr[i])\\n                else:\\n                    even.append(arr[i])\\n            return dfs(odd) + dfs(even)\\n        return dfs(range(1,n+1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369252,
                "title": "quick-and-clean-python-solution-90-time",
                "content": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n==1: return [1]\\n        if n==2: return [1,2]\\n        if n==3: return [1,3,2]\\n        if n==4: return [1,3,2,4]\\n        \\n        #get a beautiful array the length of the odd integers\\n        odd_beaut = self.beautifulArray((n+1)//2)\\n        \\n        #map the array to the odds\\n        odds = [(2*i)-1 for i in odd_beaut]\\n        \\n        #create an even array\\n        evens = [i+1 for i in odds]\\n        \\n        result = odds+evens\\n        \\n        #may have to remove one if we did too many evens\\n        if n%2==1: result.remove(n+1)\\n        \\n        return result\\n            ```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n==1: return [1]\\n        if n==2: return [1,2]\\n        if n==3: return [1,3,2]\\n        if n==4: return [1,3,2,4]\\n        \\n        #get a beautiful array the length of the odd integers\\n        odd_beaut = self.beautifulArray((n+1)//2)\\n        \\n        #map the array to the odds\\n        odds = [(2*i)-1 for i in odd_beaut]\\n        \\n        #create an even array\\n        evens = [i+1 for i in odds]\\n        \\n        result = odds+evens\\n        \\n        #may have to remove one if we did too many evens\\n        if n%2==1: result.remove(n+1)\\n        \\n        return result\\n            ```",
                "codeTag": "Java"
            },
            {
                "id": 1369174,
                "title": "java-by-inductive-construction-with-explanation",
                "content": "Key observations:\\n1. If we have a solution that works for n integers, we can double every number and remain compliant with the rule: nums[i] + nums[j] <> nums[k] * 2.\\n1. Using the doubled solution, we can append a copy to the right in reverse order, and decrement every element of the copy by one, to get a valid solution of length 2n.  That is because both copies  still satisfy the above rule, and for any pairs that cross the midpoint, parity is different, making the sum odd.\\n1. If we have a solution of length n, we can construct a solution of length m where m < n by simply removing all elements that are greater than m.\\n\\nPutting the first 2 observations together, given any solution, we can construct a new solution of double the original length.  So just start with the solution for n = 1, which is [1], and repeatedly double its length until it is at least long enough.  If it is too long, use observation 3 to trim it to the desired length.\\n\\nFor example:\\n[2,1,4,3] --> [4,2,8,6] (doubling) --> [4,2,8,6,5,7,1,3] (copy, reverse, decrement, append)\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        // Find the smallest power of 2 that is greater than or equal to n\\n        int x = 1;\\n        while (x < n) x += x;\\n        \\n        int[] answer = new int[x];\\n        \\n        // Populate the first position\\n        answer[0] = 1;\\n        int size = 1;\\n        \\n        // Now repeat: reverse and append, while doubling\\n        // Each iteration generates a solution that is twice as long as the previous step\\n        while (size * 2 <= x) {\\n            for (int i = 0; i < size; i++) {\\n                answer[i] += answer[i];\\n                answer[size * 2 - i - 1] = answer[i] - 1;\\n            }\\n            size += size;\\n        }\\n        if (x == n) return answer;\\n        \\n        // Create an answer array of the right length, discarding numbers that are too big\\n        int[] finalAnswer = new int[n];\\n        int j = 0;\\n        for (int i = 0; i < answer.length; i++) if (answer[i] <= n) finalAnswer[j++] = answer[i];\\n        \\n        return finalAnswer;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        // Find the smallest power of 2 that is greater than or equal to n\\n        int x = 1;\\n        while (x < n) x += x;\\n        \\n        int[] answer = new int[x];\\n        \\n        // Populate the first position\\n        answer[0] = 1;\\n        int size = 1;\\n        \\n        // Now repeat: reverse and append, while doubling\\n        // Each iteration generates a solution that is twice as long as the previous step\\n        while (size * 2 <= x) {\\n            for (int i = 0; i < size; i++) {\\n                answer[i] += answer[i];\\n                answer[size * 2 - i - 1] = answer[i] - 1;\\n            }\\n            size += size;\\n        }\\n        if (x == n) return answer;\\n        \\n        // Create an answer array of the right length, discarding numbers that are too big\\n        int[] finalAnswer = new int[n];\\n        int j = 0;\\n        for (int i = 0; i < answer.length; i++) if (answer[i] <= n) finalAnswer[j++] = answer[i];\\n        \\n        return finalAnswer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369096,
                "title": "java-o-n-0ms-beats-100-divide-and-conquer-explained",
                "content": "### Problem Solving\\nWe can solve this question using one (generalized) key observation: for any permutation, **if you separate the numbers** such that all numbers on one side are the same MOD `m` (where `m` in `{2, 4, 8, ...}`, it is impossible for `arr[i] + arr[j] == 2 * arr[k]`.\\nE.g. #1\\n```\\n\\tarr = [1, 5, 3, 7, 2, 6, 4, 8]\\n\\t\\t= [1, 1, 1, 1, 0, 0, 0, 0] (MOD 2)\\n\\t\\t= [1, 1, 3, 3, 0, 0, 2, 2] (MOD 4)\\n```\\nE.g. #2\\n```\\n\\tarr = [1, 9, 5, 3, 11, 7, 2, 10, 6, 4, 8]\\n\\t\\t= [1, 1, 1, 1, 1 , 1, 0, 0 , 0, 0, 0] (MOD 2)\\n\\t\\t= [1, 1, 1, 3, 3 , 3, 2, 2 , 2, 0, 0] (MOD 4)\\n\\t\\t= [1, 1, 5, 3, 3 , 7, 2, 2 , 6, 4, 0] (MOD 8)\\n```\\nAs you can see, these permutations keep the numbers separated as described above, and you can check for yourself that if you take any two numbers that belong to different groups (for example, `9` and `3` in e.g. #2), none of the numbers inbetween them will break the requirement.\\nThis makes the problem suitable for a **divide and conquer** approach, where we separate numbers according to these rules at every level.\\n### Implementation\\n\\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        final int[] beauty = new int[n];\\n        fill(beauty, 0, n, 0, 1);\\n        return beauty;\\n    }\\n    \\n    private void fill(int[] arr, int lo, int hi, int start, int mod) {\\n        if(hi - lo == 1) { // base case\\n            arr[lo] = start + 1;\\n        } else { // divide and conquer\\n            final int mid = lo + (hi - lo + 1) / 2;\\n            fill(arr, lo, mid, start, mod << 1);\\n            fill(arr, mid, hi, start + mod, mod << 1); // (start + mod) to prevent overlap\\n        }\\n    }\\n    \\n\\t/* not part of the solution, but helpful for debugging. verify:\\n\\t\\t* no duplicates and within range --> is permutation of [1...n]\\n\\t\\t* arr[i] + arr[j] != 2 * arr[k] for all 0 <= i < k < j < n\\n\\t*/\\n    private boolean verify(int[] arr) {\\n        final Set<Integer> seen = new HashSet<>(arr.length);\\n        for(int i = 0; i < arr.length; i++) {\\n            if(arr[i] < 1 || arr[i] > arr.length || seen.contains(arr[i])) return false;\\n            seen.add(arr[i]);\\n            for(int k = i + 1; k < arr.length; k++)\\n                for(int j = k + 1; j < arr.length; j++)\\n                    if(arr[i] + arr[j] == arr[k] * 2) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tarr = [1, 5, 3, 7, 2, 6, 4, 8]\\n\\t\\t= [1, 1, 1, 1, 0, 0, 0, 0] (MOD 2)\\n\\t\\t= [1, 1, 3, 3, 0, 0, 2, 2] (MOD 4)\\n```\n```\\n\\tarr = [1, 9, 5, 3, 11, 7, 2, 10, 6, 4, 8]\\n\\t\\t= [1, 1, 1, 1, 1 , 1, 0, 0 , 0, 0, 0] (MOD 2)\\n\\t\\t= [1, 1, 1, 3, 3 , 3, 2, 2 , 2, 0, 0] (MOD 4)\\n\\t\\t= [1, 1, 5, 3, 3 , 7, 2, 2 , 6, 4, 0] (MOD 8)\\n```\n```\\nclass Solution {\\n    public int[] beautifulArray(int n) {\\n        final int[] beauty = new int[n];\\n        fill(beauty, 0, n, 0, 1);\\n        return beauty;\\n    }\\n    \\n    private void fill(int[] arr, int lo, int hi, int start, int mod) {\\n        if(hi - lo == 1) { // base case\\n            arr[lo] = start + 1;\\n        } else { // divide and conquer\\n            final int mid = lo + (hi - lo + 1) / 2;\\n            fill(arr, lo, mid, start, mod << 1);\\n            fill(arr, mid, hi, start + mod, mod << 1); // (start + mod) to prevent overlap\\n        }\\n    }\\n    \\n\\t/* not part of the solution, but helpful for debugging. verify:\\n\\t\\t* no duplicates and within range --> is permutation of [1...n]\\n\\t\\t* arr[i] + arr[j] != 2 * arr[k] for all 0 <= i < k < j < n\\n\\t*/\\n    private boolean verify(int[] arr) {\\n        final Set<Integer> seen = new HashSet<>(arr.length);\\n        for(int i = 0; i < arr.length; i++) {\\n            if(arr[i] < 1 || arr[i] > arr.length || seen.contains(arr[i])) return false;\\n            seen.add(arr[i]);\\n            for(int k = i + 1; k < arr.length; k++)\\n                for(int j = k + 1; j < arr.length; j++)\\n                    if(arr[i] + arr[j] == arr[k] * 2) return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369079,
                "title": "aging-s-rpr-solution",
                "content": "This solution is posted here by user@ Aging - https://leetcode.com/problems/beautiful-array/solution/192124\\n\\nI wanted to post it here in case anyone else found it useful, as i did:\\n\\nWe can reverse a number\\'s binary format bitwisely to get its reversed binary representation (RPR). For this question, 10 bits are enough, as N is always less than 1024. In this case, RPR(1) = 0b1000000000, RPR(2) = 0b0100000000, RPR(12) = 0b0011000000.\\n\\nIt could be proved that: for any i < j < k, if i + k = j * 2, then RPR(j) is either less than or larger than both RPR(i) and RPR(k), or in another word, RPR(j) can not be between RPR(i) and RPR(k).\\nProve:\\nConsider these four conditions:\\n\\ni, k is odd, j is even (e.g. 1+7=4*2). The first bit of RPR(i) and RPR(k) is 1, and the first bit of RPR(j) is 0, so RPR(j) is smaller than both RPR(i) and RPR(k).\\ni, k is even, j is odd (e.g. 2+4=3*2). The first bit of RPR(i) and RPR(k) is 0, and the first bit of RPR(j) is 1, so RPR(j) is larger than both RPR(i) and RPR(k).\\ni, k is odd, j is odd (e.g. 1+5=3*2). Define i1 = (i-1)/2, k1=(k-1)/2, j1 = (j-1)/2, then we have i1<j1<k1, and i1+k1=j1*2. i1, j1, k1 could be treated as new i, j, k.\\ni, k is even, j is even (e.g. 2+6=4*2). Define i1=i/2, k1=k/2, j1=j/2, then we have i1<j1<k1, and i1+k1=j1*2. i1, j1, k1 could be treated as new i, j, k.\\nFor case #3 and #4, it is reduced to the original proposition, and must be finally reduced to case #1 or #2, because i < j < k.\\nBased on this, the algorithm is simple: sort all the numbers for 1 to N by its RPR. The final array is a result.\\nTime complexity is O(N log N) and space complexity is O(N).\\n\\nThe code is like:\\n\\n```\\nclass Solution {\\npublic:\\n  int rev(int N) {\\n  int ret = 0;\\n  for (int i = 0; i <= 9; ++i)\\n  ret += ((N >> i) & 0x1) << (9 - i);\\n  return ret;\\n}\\n\\nvector<int> beautifulArray(int N) {\\n    vector<int> ans(N, 0);\\n    for (int i = 0; i < N; ++i) ans[i] = i + 1;\\n    sort(ans.begin(), ans.end(), [&](int i, int j){\\n        return rev(i) < rev(j);\\n    });\\n    \\n    return ans;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int rev(int N) {\\n  int ret = 0;\\n  for (int i = 0; i <= 9; ++i)\\n  ret += ((N >> i) & 0x1) << (9 - i);\\n  return ret;\\n}\\n\\nvector<int> beautifulArray(int N) {\\n    vector<int> ans(N, 0);\\n    for (int i = 0; i < N; ++i) ans[i] = i + 1;\\n    sort(ans.begin(), ans.end(), [&](int i, int j){\\n        return rev(i) < rev(j);\\n    });\\n    \\n    return ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369076,
                "title": "ruby-recursion",
                "content": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef beautiful_array(n)\\n  @cache = {}\\n  solve(n)\\nend\\n\\ndef solve(n)\\n  return [1] if n == 1\\n  return @cache[n] if @cache[n]\\n  \\n  even_index = n/2\\n  odd_index = n - even_index\\n  even = solve(even_index)\\n  odd = solve(odd_index)\\n  even = even.map{|v| 2*v}\\n  odd = odd.map{|v| 2*v-1}\\n  @cache[n] = even + odd\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Recursion"
                ],
                "code": "```\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef beautiful_array(n)\\n  @cache = {}\\n  solve(n)\\nend\\n\\ndef solve(n)\\n  return [1] if n == 1\\n  return @cache[n] if @cache[n]\\n  \\n  even_index = n/2\\n  odd_index = n - even_index\\n  even = solve(even_index)\\n  odd = solve(odd_index)\\n  even = even.map{|v| 2*v}\\n  odd = odd.map{|v| 2*v-1}\\n  @cache[n] = even + odd\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1369048,
                "title": "beautiful-array-python",
                "content": "The key thing to recognize is that a beautiful array is still beautiful if you double all the numbers in it. It\\'s also still beautiful if you double all the numbers and subtract one. Another thing to notice is that we can deal with even and odd numbers in the array separately, because the sum of even and odd is odd, and half an odd number is not a whole number. Recognizing these two facts, we can write a recursive function to find a beautiful array of size n given that we already know the beautiful array of half the size of n. (When n is even you can use n/2, when it\\'s odd you need n/2 rounded down and n/2 rounded up.)\\n\\nSo here\\'s my solution:\\n```\\nclass Solution:\\n    def __init__(self):\\n\\t\\t# Initiate a memo so we don\\'t calculate the same array twice\\n        self.memo = {1: [1]}\\n    \\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n in self.memo:\\n            return self.memo[n]\\n        \\n\\t\\t# We can deal with even and odd numbers separately, since an even plus an odd equals an odd, and half an odd is not a whole number\\n        even = self.beautifulArray(n//2)\\n        even = [x*2 for x in even]\\n        \\n        odd = self.beautifulArray(n//2+n%2)\\n        odd = [(x*2)-1 for x in odd]\\n        \\n        self.memo[n] = even + odd\\n        print(self.memo)\\n        return self.memo[n]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n\\t\\t# Initiate a memo so we don\\'t calculate the same array twice\\n        self.memo = {1: [1]}\\n    \\n    def beautifulArray(self, n: int) -> List[int]:\\n        if n in self.memo:\\n            return self.memo[n]\\n        \\n\\t\\t# We can deal with even and odd numbers separately, since an even plus an odd equals an odd, and half an odd is not a whole number\\n        even = self.beautifulArray(n//2)\\n        even = [x*2 for x in even]\\n        \\n        odd = self.beautifulArray(n//2+n%2)\\n        odd = [(x*2)-1 for x in odd]\\n        \\n        self.memo[n] = even + odd\\n        print(self.memo)\\n        return self.memo[n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1369006,
                "title": "go-solution",
                "content": "Inspired by [this solution](https://leetcode.com/problems/beautiful-array/discuss/186679/Odd-%2B-Even-Pattern-O(N))\\n```\\nfunc beautifulArray(n int) []int {\\n\\tresult := []int{1}\\n\\tfor len(result) < n {\\n\\t\\ttemp := make([]int, 0, 2*len(result))\\n\\t\\tfor _, i := range result {\\n\\t\\t\\tif x := i*2 - 1; x <= n {\\n\\t\\t\\t\\ttemp = append(temp, x)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor _, i := range result {\\n\\t\\t\\tif x := i * 2; x <= n {\\n\\t\\t\\t\\ttemp = append(temp, x)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult = temp\\n\\t}\\n\\treturn result\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc beautifulArray(n int) []int {\\n\\tresult := []int{1}\\n\\tfor len(result) < n {\\n\\t\\ttemp := make([]int, 0, 2*len(result))\\n\\t\\tfor _, i := range result {\\n\\t\\t\\tif x := i*2 - 1; x <= n {\\n\\t\\t\\t\\ttemp = append(temp, x)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor _, i := range result {\\n\\t\\t\\tif x := i * 2; x <= n {\\n\\t\\t\\t\\ttemp = append(temp, x)\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresult = temp\\n\\t}\\n\\treturn result\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368934,
                "title": "java-arraylist-easiest",
                "content": "```\\n  public int[] beautifulArray(int n) {\\n        \\n List<Integer> p= new ArrayList();\\n        p.add(1);\\n        int a=2;\\n        int k=n-1;\\n        while(k>0){\\n              List<Integer> q= new ArrayList();\\n        for(int i=0;i<p.size();i++){\\n            if(p.get(i)*2-1 <=a){\\n                q.add(p.get(i)*2-1);\\n            \\n        \\n            }\\n        }\\n           List<Integer> r= new ArrayList();\\n        \\n          for(int i=0;i<p.size();i++){\\n              \\n            if(p.get(i)*2<=a){\\n                r.add(p.get(i)*2);\\n            }\\n        }\\n         p.clear();\\n        \\n     for(int i=0;i<q.size();i++){\\n               p.add(q.get(i));\\n     }\\n       for(int i=0;i<r.size();i++){\\n               p.add(r.get(i));\\n     }   \\n        a++;\\n            k--;\\n        \\n        }\\n        \\nint arr[]=new int[p.size()];\\n        for(int i=0;i<p.size();i++){\\n            arr[i]=p.get(i);\\n        }\\n        return arr;\\n     \\n        \\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n  public int[] beautifulArray(int n) {\\n        \\n List<Integer> p= new ArrayList();\\n        p.add(1);\\n        int a=2;\\n        int k=n-1;\\n        while(k>0){\\n              List<Integer> q= new ArrayList();\\n        for(int i=0;i<p.size();i++){\\n            if(p.get(i)*2-1 <=a){\\n                q.add(p.get(i)*2-1);\\n            \\n        \\n            }\\n        }\\n           List<Integer> r= new ArrayList();\\n        \\n          for(int i=0;i<p.size();i++){\\n              \\n            if(p.get(i)*2<=a){\\n                r.add(p.get(i)*2);\\n            }\\n        }\\n         p.clear();\\n        \\n     for(int i=0;i<q.size();i++){\\n               p.add(q.get(i));\\n     }\\n       for(int i=0;i<r.size();i++){\\n               p.add(r.get(i));\\n     }   \\n        a++;\\n            k--;\\n        \\n        }\\n        \\nint arr[]=new int[p.size()];\\n        for(int i=0;i<p.size();i++){\\n            arr[i]=p.get(i);\\n        }\\n        return arr;\\n     \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1368874,
                "title": "python-explained-0-n-time",
                "content": "Consider\\nn=1 -> [1]\\nn=2 -> [1,2], [2,1]\\nn=3 -> [1,3,2], [2,3,1], [2,1,3]\\nn=4 -> [1,3,2,4], ....\\nn=5 -> [1,5,3,2,4]\\nn=6 -> [1,5,3,  2,6,4]\\n             -Odd--Even--\\nBy looking at the patterns, we can see that some valid sequences have Odd and Even number separated\\n\\nEach element of the current level is made by a combination of Odd and Even elements separated.\\n\\nOur problem let it be f(n) where f(x) gives the beautiful array\\n\\nThen each odd element -> 2*x-1   for x in f(n-1)\\nThen each even element -> 2x       for x in f(n-1)\\nProvided each resultant element is in the range of our current level i,e, 1<=2*x-1<n and 1<2*n<n\\n\\nThe sum of both the odd and even elements one after the other, gives our answer.\\n\\nTime complexity can be optimized to O(n) using memoization. Since this problem at each level just finds the individual elements without repeating intermediate steps (due to memo) so it is of linear time complexity.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        @lru_cache(None)\\n        def helper(n):\\n            if n==1:\\n                return [1]\\n            odd = []\\n            for x in helper(n-1):\\n                if 2*x-1<=n:\\n                    odd.append(2*x-1)\\n            even = []\\n            for x in helper(n-1):\\n                if 2*x<=n:\\n                    even.append(2*x)\\n            return odd+even\\n        return helper(n)",
                "solutionTags": [
                    "Python",
                    "Memoization"
                ],
                "code": "Consider\\nn=1 -> [1]\\nn=2 -> [1,2], [2,1]\\nn=3 -> [1,3,2], [2,3,1], [2,1,3]\\nn=4 -> [1,3,2,4], ....\\nn=5 -> [1,5,3,2,4]\\nn=6 -> [1,5,3,  2,6,4]\\n             -Odd--Even--\\nBy looking at the patterns, we can see that some valid sequences have Odd and Even number separated\\n\\nEach element of the current level is made by a combination of Odd and Even elements separated.\\n\\nOur problem let it be f(n) where f(x) gives the beautiful array\\n\\nThen each odd element -> 2*x-1   for x in f(n-1)\\nThen each even element -> 2x       for x in f(n-1)\\nProvided each resultant element is in the range of our current level i,e, 1<=2*x-1<n and 1<2*n<n\\n\\nThe sum of both the odd and even elements one after the other, gives our answer.\\n\\nTime complexity can be optimized to O(n) using memoization. Since this problem at each level just finds the individual elements without repeating intermediate steps (due to memo) so it is of linear time complexity.\\n\\n```\\nclass Solution:\\n    def beautifulArray(self, n: int) -> List[int]:\\n        @lru_cache(None)\\n        def helper(n):\\n            if n==1:\\n                return [1]\\n            odd = []\\n            for x in helper(n-1):\\n                if 2*x-1<=n:\\n                    odd.append(2*x-1)\\n            even = []\\n            for x in helper(n-1):\\n                if 2*x<=n:\\n                    even.append(2*x)\\n            return odd+even\\n        return helper(n)",
                "codeTag": "Java"
            },
            {
                "id": 1368852,
                "title": "best-cpp-solution-o-n-beautiful-array",
                "content": "class Solution {\\npublic:\\n     vector<int> beautifulArray(int N) {\\n        vector<int> res = {1};\\n        while (res.size() < N) \\n        {\\n            vector<int> tmp;\\n            for (int i : res)\\n            {\\n                if (i * 2 - 1 <= N) tmp.push_back(i * 2 - 1);\\n            }\\n            for (int i : res)\\n            {\\n                if (i * 2 <= N) tmp.push_back(i * 2);\\n            }\\n            res = tmp;\\n        }\\n        return res;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n     vector<int> beautifulArray(int N) {\\n        vector<int> res = {1}",
                "codeTag": "Java"
            },
            {
                "id": 1368782,
                "title": "odd-even-simple-pattern-code-with-proper-explanation-and-cases-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        // Logic is start from 1, now firstly firstly make all of them odd and then make all of them even\\n        // it means odd odd odd odd odd ........ even even even\\n        /// by using this method it never possible to get nums[k]*2=nums[i]+nums[j]\\n        // because \\n        \\n        // 1. Case 1: if you consider odd odd odd pair then odd + odd=even and odd*2=even, but they always have gap of 2 minimum.\\n        \\n        // Case 2: odd odd even:- here odd + even=odd, and odd*2= even, so even!=odd;\\n        \\n        // case 3: odd even even:- Same as case 2 , not possible;\\n        \\n        // case 4: even even even: - same as case 1, i.e., always have gap or diff of 2 minimum;\\n        \\n        vector<int>vec={1};\\n        while(vec.size()<n)\\n        {\\n            vector<int>temp;\\n             for(auto x: vec) if(x*2-1<=n) temp.push_back(x*2-1);\\n             for(auto x: vec) if(x*2<=n) temp.push_back(x*2);\\n            vec=temp;\\n        }\\n        \\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> beautifulArray(int n) {\\n        // Logic is start from 1, now firstly firstly make all of them odd and then make all of them even\\n        // it means odd odd odd odd odd ........ even even even\\n        /// by using this method it never possible to get nums[k]*2=nums[i]+nums[j]\\n        // because \\n        \\n        // 1. Case 1: if you consider odd odd odd pair then odd + odd=even and odd*2=even, but they always have gap of 2 minimum.\\n        \\n        // Case 2: odd odd even:- here odd + even=odd, and odd*2= even, so even!=odd;\\n        \\n        // case 3: odd even even:- Same as case 2 , not possible;\\n        \\n        // case 4: even even even: - same as case 1, i.e., always have gap or diff of 2 minimum;\\n        \\n        vector<int>vec={1};\\n        while(vec.size()<n)\\n        {\\n            vector<int>temp;\\n             for(auto x: vec) if(x*2-1<=n) temp.push_back(x*2-1);\\n             for(auto x: vec) if(x*2<=n) temp.push_back(x*2);\\n            vec=temp;\\n        }\\n        \\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1368680,
                "title": "o-n-2-solution-c",
                "content": "```\\nstruct ListNode {\\n        int val;\\n        ListNode *next;\\n        ListNode() : val(0), next(nullptr) {}\\n        ListNode(int x) : val(x), next(nullptr) {}\\n        ListNode(int x, ListNode *next) : val(x), next(next) {}\\n    };\\n    vector<int> beautifulArray(int n) {\\n        vector<vector<int>> p = {{1}, {1, 2}, {1, 3, 2}, {2, 1, 4, 3}, {3,1,2,5,4}, {1,5,3,2,6,4}};\\n        if (n <= 6) {\\n            return p[n-1];\\n        } else {\\n            ListNode* fun = new ListNode(1);\\n            auto it  = fun;\\n            for (int i = 1; i < 6; i++) {\\n                it->next = new ListNode(p[5][i]);\\n                it = it->next;\\n            }\\n            int cycles = 7;\\n            int loop = 8;\\n            int prevLoop = 4;\\n            while (cycles <= n) {\\n                if (cycles == loop) {\\n                    prevLoop = loop;\\n                    loop *= 2;\\n                }\\n                for (it = fun; it != nullptr; it = it->next) {\\n                    if (it->val+prevLoop == cycles) {\\n                        it->next = new ListNode(cycles, it->next);\\n                        break;\\n                    } else if (it->next == nullptr) {\\n                        it->next = new ListNode(cycles);\\n                        break;\\n                    }\\n                }\\n                cycles++;\\n            }\\n            vector<int> out;\\n            while (fun != NULL) {\\n                out.push_back(fun->val);\\n                fun = fun->next;\\n            }\\n            return out;\\n        }\\n    }\\n```\\n\\nI came up with this strange solution through pattern analysis, but I really dont understand why it works. Why does this recurrent pattern of multiples of 2 (4->8->16->32) show up, and why does it not seem to apply to the cases where n = 4 and 5 respectively? Somehow this seemingly inefficient solution also manages to achieve a respectable runtime of 4ms",
                "solutionTags": [],
                "code": "```\\nstruct ListNode {\\n        int val;\\n        ListNode *next;\\n        ListNode() : val(0), next(nullptr) {}\\n        ListNode(int x) : val(x), next(nullptr) {}\\n        ListNode(int x, ListNode *next) : val(x), next(next) {}\\n    };\\n    vector<int> beautifulArray(int n) {\\n        vector<vector<int>> p = {{1}, {1, 2}, {1, 3, 2}, {2, 1, 4, 3}, {3,1,2,5,4}, {1,5,3,2,6,4}};\\n        if (n <= 6) {\\n            return p[n-1];\\n        } else {\\n            ListNode* fun = new ListNode(1);\\n            auto it  = fun;\\n            for (int i = 1; i < 6; i++) {\\n                it->next = new ListNode(p[5][i]);\\n                it = it->next;\\n            }\\n            int cycles = 7;\\n            int loop = 8;\\n            int prevLoop = 4;\\n            while (cycles <= n) {\\n                if (cycles == loop) {\\n                    prevLoop = loop;\\n                    loop *= 2;\\n                }\\n                for (it = fun; it != nullptr; it = it->next) {\\n                    if (it->val+prevLoop == cycles) {\\n                        it->next = new ListNode(cycles, it->next);\\n                        break;\\n                    } else if (it->next == nullptr) {\\n                        it->next = new ListNode(cycles);\\n                        break;\\n                    }\\n                }\\n                cycles++;\\n            }\\n            vector<int> out;\\n            while (fun != NULL) {\\n                out.push_back(fun->val);\\n                fun = fun->next;\\n            }\\n            return out;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1564546,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1564927,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1565543,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1569730,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1729838,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1568403,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1567052,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1572545,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1569329,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1573243,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1564546,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1564927,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1565543,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1569730,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1729838,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1568403,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1567052,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1572545,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1569329,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            },
            {
                "id": 1573243,
                "content": [
                    {
                        "username": "StrangeCloud9",
                        "content": "If you agree, click  the \"up\" bottom."
                    },
                    {
                        "username": "_aka5h",
                        "content": "agree to what?\\n"
                    },
                    {
                        "username": "huowa222",
                        "content": "\\nweird ,  meaningless nonsense question"
                    },
                    {
                        "username": "yanbin_ma",
                        "content": "The description says to return any beautiful array. However, the auto-grader expects a fixed array. So if your submission returns a valid array by definition, but not matching what the auto-grader expects, it still not accepted."
                    },
                    {
                        "username": "shafiqa_iqbal",
                        "content": "Can someone please explain the problem statement to me?"
                    },
                    {
                        "username": "disturbedbrown1",
                        "content": "There should be some check and balance on what problems are posted on LC. Companies (preliminary interview rounds), or bootcamps don\\'t understand this; if you fail to solve such vague questions, then that\\'s it, you are done. They dont care if the question itself is crap."
                    },
                    {
                        "username": "elvinyang",
                        "content": "I get that we can duduct it is an arithmetic-free sequence from `2*A[k] = A[i] + A[j]`, but how can I come up with the idea of splitting odd and even apart?\\nI understand that there will be no valiation between `odd[]` and `even[]`, but internally within them there could still be validations. (e.g. `1, 3, 5` or `2, 4, 6`)."
                    },
                    {
                        "username": "wpopielarski",
                        "content": "I understand that solution is in some sense beautiful, nice and concise DP, but the way how to generate this non-aritmetic order is really challenging. What do you feel about that?"
                    },
                    {
                        "username": "JPV",
                        "content": "The Nth element gets inserted at position A(N), where A(N) is from the sequence described here:\\nhttps://oeis.org/A264596\\nThis lets you, by inserting one more element, turn an answer for K elements into an answer for K+1 elements, and build up to whatever number you need."
                    },
                    {
                        "username": "herbertzou",
                        "content": "They are intrinsically the same.\\nCould anyone explain how you brought up the solution, instead simply constructing it?\\nThanks."
                    },
                    {
                        "username": "liketheflower",
                        "content": "I have summarized two similar problems. I\\'d like to share the link. Hope it is helpful. \\nhttps://medium.com/@jim.morris.shen/divide-conquer-combine-recursion-greedy-dp-64c2b06f517c?source=friends_link&sk=eca9e9446bf41bd1a1a0428e2a13d68c"
                    }
                ]
            }
        ]
    },
    {
        "title": "How Many Numbers Are Smaller Than the Current Number",
        "question_content": "<p>Given the array <code>nums</code>, for each <code>nums[i]</code> find out how many numbers in the array are smaller than it. That is, for each <code>nums[i]</code> you have to count the number of valid <code>j&#39;s</code>&nbsp;such that&nbsp;<code>j != i</code> <strong>and</strong> <code>nums[j] &lt; nums[i]</code>.</p>\n\n<p>Return the answer in an array.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [8,1,2,2,3]\n<strong>Output:</strong> [4,0,1,1,3]\n<strong>Explanation:</strong> \nFor nums[0]=8 there exist four smaller numbers than it (1, 2, 2 and 3). \nFor nums[1]=1 does not exist any smaller number than it.\nFor nums[2]=2 there exist one smaller number than it (1). \nFor nums[3]=2 there exist one smaller number than it (1). \nFor nums[4]=3 there exist three smaller numbers than it (1, 2 and 2).\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [6,5,4,8]\n<strong>Output:</strong> [2,1,0,3]\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [7,7,7,7]\n<strong>Output:</strong> [0,0,0,0]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>2 &lt;= nums.length &lt;= 500</code></li>\n\t<li><code>0 &lt;= nums[i] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 524996,
                "title": "java-beats-100-o-n",
                "content": "Store the count in a bucket and take the running sum.\\n\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] count = new int[101];\\n        int[] res = new int[nums.length];\\n        \\n        for (int i =0; i < nums.length; i++) {\\n            count[nums[i]]++;\\n        }\\n        \\n        for (int i = 1 ; i <= 100; i++) {\\n            count[i] += count[i-1];    \\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0)\\n                res[i] = 0;\\n            else \\n                res[i] = count[nums[i] - 1];\\n        }\\n        \\n        return res;        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] count = new int[101];\\n        int[] res = new int[nums.length];\\n        \\n        for (int i =0; i < nums.length; i++) {\\n            count[nums[i]]++;\\n        }\\n        \\n        for (int i = 1 ; i <= 100; i++) {\\n            count[i] += count[i-1];    \\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if (nums[i] == 0)\\n                res[i] = 0;\\n            else \\n                res[i] = count[nums[i] - 1];\\n        }\\n        \\n        return res;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 535421,
                "title": "java-clean-hashmap-solution-with-explanation",
                "content": "So the idea is:\\nLet\\'s use this input for illustration: [8,1,2,2,3]\\n1. Create a copy of the input array. copy = [8,1,2,2,3]\\n2. Sort the copy array. copy = [1,2,2,3,8]\\n3. Fill the map: number => count (where count is an index in sorted array, so first number with index 0 has 0 numbers less than it, index 1 has 1 number less, etc). We update only first time we enocunter the number so that way we skip duplicates.\\nmap[1]=>0\\nmap[2]=>1\\nmap[3]=>3\\nmap[8]=>4\\n4. We re-use our copy array to get our result, we iterate over original array, and get counts from the map.\\n[4,0,1,1,3]\\n\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] copy = nums.clone();\\n        \\n        Arrays.sort(copy);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            map.putIfAbsent(copy[i], i);\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            copy[i] = map.get(nums[i]);\\n        }\\n        \\n        return copy;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] copy = nums.clone();\\n        \\n        Arrays.sort(copy);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            map.putIfAbsent(copy[i], i);\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            copy[i] = map.get(nums[i]);\\n        }\\n        \\n        return copy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 819148,
                "title": "python-3-91-11-faster-52ms-time-explanation-added",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\n**2 possible solutions:**\\n1. For every i element, iterate the list with j as index. If i!=j and nums[j]<nums[i], we can update the count for that number. Time: O(n2). Space: O(1)\\n2. This is optimal solution. We can sort the list and store in another temp list. We use dictionary to store the counts and later use it to create result. Time: O(n log n) bcoz of sort. Space: O(n) bcoz of dictionary.\\n\\n**Explanation of solution 2:**\\nnums = 8, 1, 2, 2, 3\\n1. We sort the list bcoz we don\\'t want to keep traversing the list back and forth. After sorting, we get temp = 1, 2, 2, 3, 8\\n2. We traverse temp list. If we find unique element, we know all the previous elements have been recorded. So we add this unique element to the dictionary with index i as value.\\nIf duplicate element is encountered, we don\\'t add it and don\\'t update the value in dictionary.\\n3. After the dictionary is constructed, we create output after doing O(1) lookup in dictionary for nums[i]\\n\\n```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\ttemp = sorted(nums)\\n\\tmapping = {}\\n\\tresult = []\\n\\tfor i in range(len(temp)):\\n\\t\\tif temp[i] not in mapping:\\n\\t\\t\\tmapping[temp[i]] = i\\n\\tfor i in range(len(nums)):\\n\\t\\tresult.append(mapping[nums[i]])\\n\\treturn result\\n```\\n\\n**If this solution helped, please upvote it for others to take advantage of it and learn their techniques**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\ttemp = sorted(nums)\\n\\tmapping = {}\\n\\tresult = []\\n\\tfor i in range(len(temp)):\\n\\t\\tif temp[i] not in mapping:\\n\\t\\t\\tmapping[temp[i]] = i\\n\\tfor i in range(len(nums)):\\n\\t\\tresult.append(mapping[nums[i]])\\n\\treturn result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 693600,
                "title": "c-99-o-n",
                "content": "```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> answer;\\n        int i, j;\\n        int count[101] = {0, 0, 0};\\n\\t\\tint len = nums.size();\\n        for(i = 0; i < len; i++) {\\n            count[nums[i]]++;\\n        }\\n        for(i = 1; i < 101; i++) {\\n            count[i] += count[i - 1];\\n        }\\n        for(i = 0; i < len; i++) {\\n            if(nums[i] == 0)\\n                answer.push_back(0);\\n            else\\n                answer.push_back(count[nums[i] - 1]);\\n                \\n        }\\n        return answer;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> answer;\\n        int i, j;\\n        int count[101] = {0, 0, 0};\\n\\t\\tint len = nums.size();\\n        for(i = 0; i < len; i++) {\\n            count[nums[i]]++;\\n        }\\n        for(i = 1; i < 101; i++) {\\n            count[i] += count[i - 1];\\n        }\\n        for(i = 0; i < len; i++) {\\n            if(nums[i] == 0)\\n                answer.push_back(0);\\n            else\\n                answer.push_back(count[nums[i] - 1]);\\n                \\n        }\\n        return answer;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 641884,
                "title": "java-o-n-1ms-less-memory-than-100-explained",
                "content": "```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] buck = new int[101];\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            buck[nums[i]] +=1;\\n        }\\n        \\n        for(int j=1; j<= 100; j++) {\\n            buck[j] += buck[j-1];\\n        }\\n        \\n        for(int k=0; k< nums.length; k++) {\\n            int pos = nums[k];\\n            nums[k] = pos==0 ? 0 : buck[pos-1];\\n        }\\n        \\n        return nums;\\n    }\\n```\\n\\nThis solution maps the numbers in the array to a counter.\\nSince the numbers are between 0 and 100  I create an array of length 101 and iterate over the original array and put each number in the corresponding index in the bucket array. If the original array contains the number 1, number 1 goes to index 1 in the new array.\\n\\nSince the nums array may contain duplicates, in the bucket array I store a counter for each of the numbers, not the number itself. So if the number 1 occurs 3 times in the nums array, in index 1 of the bucket array we store the value 3.\\n\\n4 5 1 3 5 4 4 1 4 5 1 4\\nbecomes\\n0 3 0 1 5 3\\n\\n(0 zeros, 3 ones, 0 twos, 1 three, 5 fours and 3 fives)\\n\\nAfter the bucket array has been populated, I iterate it again from index 1 to index 100 and to each of the values I add the previous value. A similar example with a smaller array:\\n\\n0 3 0 1 5 3\\nbecomes\\n0 3 3 4 9 12\\n\\n(0 numbers are <= 0, 3 numbers are are <= 1, 3 numbers are are <= 2, 4 numbers are are <= 3 and so on.)\\n\\n That way each position contains how many numbers are smaller or equal than the current position.\\n\\nFinally I iterate the original nums array and get the index from bucket corresponding the value of the number from nums - 1 (minus one because without it we also get the ones equal to it and we only want smaller). When doing this I assign the result as the new value in the nums array instead of creating a new array. Also if value is 0 we automatically return 0 as no element can be smaller than it.\\n\\nFor example, if nums array is\\n4 5 1 3 5 4 4 1 4 5 1 4\\n\\nand the final bucket mapping is:\\n0 3 3 4 9 12\\n\\nbuck[4-1] = 4\\nbuck[5-1] = 9\\nbuck[1-1] = 0\\nbuck[3-1] = 3\\nbuck[5-1] = 9\\nbuck[4-1] = 4\\nbuck[4-1] = 4\\nbuck[1-1] = 0\\nbuck[4-1] = 4\\nbuck[5-1] = 9\\nbuck[1-1] = 0\\nbuck[4-1] = 4",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] buck = new int[101];\\n        \\n        for(int i=0; i<nums.length; i++) {\\n            buck[nums[i]] +=1;\\n        }\\n        \\n        for(int j=1; j<= 100; j++) {\\n            buck[j] += buck[j-1];\\n        }\\n        \\n        for(int k=0; k< nums.length; k++) {\\n            int pos = nums[k];\\n            nums[k] = pos==0 ? 0 : buck[pos-1];\\n        }\\n        \\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 524865,
                "title": "clean-python-3-sorting-and-counting",
                "content": "**Solution 1**\\nRecord index in sorted nums if it didn\\'t appear before.\\nThen just dump it\\'s corresponding index in original nums.\\n\\nTime: O(NlogN)\\nSpace: O(N) for output list\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        indices = {}\\n        for idx, num in enumerate(sorted(nums)):\\n            indices.setdefault(num, idx)\\n        return [indices[num] for num in nums]\\n```\\n\\n\\n**Soluiton 2**\\nRefer to [this solution](https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/discuss/524996/JAVA-beats-100-O(n)) of @equ1n0x, we are already told the range of the given numbers is between 1 and 100.\\nSo we can easily count each number and sum their prefix and dump.\\n\\nTime: O(N)\\nSpace: O(N) for output list\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count = [0] * 102\\n        for num in nums:\\n            count[num+1] += 1\\n        for i in range(1, 102):\\n            count[i] += count[i-1]\\n        return [count[num] for num in nums]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        indices = {}\\n        for idx, num in enumerate(sorted(nums)):\\n            indices.setdefault(num, idx)\\n        return [indices[num] for num in nums]\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count = [0] * 102\\n        for num in nums:\\n            count[num+1] += 1\\n        for i in range(1, 102):\\n            count[i] += count[i-1]\\n        return [count[num] for num in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1214105,
                "title": "c-solution-along-with-explanation-and-time-complexity",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPRECIATED !!!**\\n\\n*Overload the comments section with doubts and praises if you have.!!!*\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        map<int, int> m;\\n        vector<int> vec = nums;\\n        int n = nums.size();\\n        \\n        // Sort vec in ascending order\\n        // T.C = O(nlogn)\\n        sort(vec.begin(), vec.end());\\n        \\n        // Put the values in hash-map according to their values corresponding to their places in nums \\n        // T.C = O(n)\\n        for(int i=n-1; i>=0; i--) {\\n            m[vec[i]] = i;\\n        }\\n        \\n        // Saving the result again in nums, b\\'cos space complexity matters XD\\n        // T.C = O(n)\\n        for(int i=0; i<n; i++) {\\n            nums[i] = m[nums[i]];\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        map<int, int> m;\\n        vector<int> vec = nums;\\n        int n = nums.size();\\n        \\n        // Sort vec in ascending order\\n        // T.C = O(nlogn)\\n        sort(vec.begin(), vec.end());\\n        \\n        // Put the values in hash-map according to their values corresponding to their places in nums \\n        // T.C = O(n)\\n        for(int i=n-1; i>=0; i--) {\\n            m[vec[i]] = i;\\n        }\\n        \\n        // Saving the result again in nums, b\\'cos space complexity matters XD\\n        // T.C = O(n)\\n        for(int i=0; i<n; i++) {\\n            nums[i] = m[nums[i]];\\n        }\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 575760,
                "title": "java-simple-to-complex-explained-0-ms-faster-than-100-less-space-than-100-5-lines-of-code",
                "content": "Naive, for every number count every number smaller than it: \\n\\nO(n^2) time\\nO(n) space\\n13 ms fast than 37%\\n40 MB less space than 100%\\n\\n```\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] answer = new int[nums.length];\\n        int count;\\n        for(int i=0; i<nums.length; i++) {\\n            count = 0;\\n            for(int j=0; j<nums.length; j++) {\\n                if(i!=j && nums[j] < nums[i]) \\n                    count++;\\n            }    \\n            answer[i] = count;\\n        }\\n        return answer;\\n    }\\n```\\n\\nIntuition: count the number occurrences of each number. The count of numbers smaller than 1 is how many 0\\'s are in the array. The count of numbers smaller than 2 is how many 0\\'s plus how many 1\\'s. The count of numbers smaller than x is how many x-1, x-2, x-3... exist in the array.\\n\\nSolution: count the number of occurrences in the array of each number from 0 to 100. Sum the numbers so that in index i you have the sum of all counts of i-1, i-2,... Replace in the original array each number with the count of numbers smaller than itself. \\n\\nWe can modify the original array and save space to reach O(1). Don\\'t do this in production code!\\n\\nO(n) time, n the size of the array (actually O(n + m) where m is the max value of a number, but m is 100 max) \\nO(1) space (actually O(m) where m is the max value of a number, but m is 100 max) \\n1 ms fast than 99.9%\\n39.3 MB less space than 100%\\n\\n```\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] bucket = new int[101];\\n        int[] count = new int[101];\\n        for(int i=0; i<nums.length; i++)\\n            bucket[nums[i]]++;\\n\\n        for(int i=1; i<count.length; i++) \\n            count[i] = count[i-1] + bucket[i-1];\\n        \\n        for(int i=0; i<nums.length; i++)\\n            nums[i] = count[nums[i]];\\n        \\n        return nums;\\n    }\\n```\\n\\nWe can actually use only 1 array. \\n\\nO(n) time\\nO(1) space\\n0 ms fast than 100%\\n\\n```\\n        int[] bucket = new int[102];\\n        for(int i=0; i<nums.length; i++)\\n            bucket[nums[i]+1]++;\\n\\t\\t\\t\\n        for(int i=0; i<101; i++) \\n            bucket[i+1] += bucket[i];\\n\\t\\t\\t\\n        for(int i=0; i<nums.length; i++)\\n            nums[i] = bucket[nums[i]];\\n\\t\\t\\t\\n        return nums;\\n```\\n\\n\\nfor fun, let\\'s wrap it up into just 5 lines of code: \\n\\n```\\n        int[] bucket = new int[102];\\n        for(int i=0; i<nums.length; bucket[nums[i]+1]++, i++);\\n        for(int i=0; i<101; bucket[i+1] += bucket[i], i++);\\n        for(int i=0; i<nums.length; nums[i] = bucket[nums[i]], i++);\\n        return nums;\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] answer = new int[nums.length];\\n        int count;\\n        for(int i=0; i<nums.length; i++) {\\n            count = 0;\\n            for(int j=0; j<nums.length; j++) {\\n                if(i!=j && nums[j] < nums[i]) \\n                    count++;\\n            }    \\n            answer[i] = count;\\n        }\\n        return answer;\\n    }\\n```\n```\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] bucket = new int[101];\\n        int[] count = new int[101];\\n        for(int i=0; i<nums.length; i++)\\n            bucket[nums[i]]++;\\n\\n        for(int i=1; i<count.length; i++) \\n            count[i] = count[i-1] + bucket[i-1];\\n        \\n        for(int i=0; i<nums.length; i++)\\n            nums[i] = count[nums[i]];\\n        \\n        return nums;\\n    }\\n```\n```\\n        int[] bucket = new int[102];\\n        for(int i=0; i<nums.length; i++)\\n            bucket[nums[i]+1]++;\\n\\t\\t\\t\\n        for(int i=0; i<101; i++) \\n            bucket[i+1] += bucket[i];\\n\\t\\t\\t\\n        for(int i=0; i<nums.length; i++)\\n            nums[i] = bucket[nums[i]];\\n\\t\\t\\t\\n        return nums;\\n```\n```\\n        int[] bucket = new int[102];\\n        for(int i=0; i<nums.length; bucket[nums[i]+1]++, i++);\\n        for(int i=0; i<101; bucket[i+1] += bucket[i], i++);\\n        for(int i=0; i<nums.length; nums[i] = bucket[nums[i]], i++);\\n        return nums;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1139277,
                "title": "easy-100-faster-c-optimised-code",
                "content": "Input: nums = [8,1,2,2,3]\\nOutput: [4,0,1,1,3]\\n\\nsnum=sorted array(nums) = [1,2,2,3,8]\\nmp=(snum[i],i) (tail to head insertion in map)\\n8 4\\n3 3\\n2 2=>1\\n1 0\\n\\nnums[i]=maps[nums[i]]\\nnums=[4,0,1,1,3]=output\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n    \\n        map<int,int> mp;    \\n        int n=nums.size();\\n        vector<int> snum=nums;\\n        \\n        sort(snum.begin(),snum.end());\\n        for(int i=n-1;i>=0;i--)\\n            mp[snum[i]]=i;\\n        \\n        for(int i=0;i<n;i++)\\n            nums[i]=mp[nums[i]];\\n        \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n    \\n        map<int,int> mp;    \\n        int n=nums.size();\\n        vector<int> snum=nums;\\n        \\n        sort(snum.begin(),snum.end());\\n        for(int i=n-1;i>=0;i--)\\n            mp[snum[i]]=i;\\n        \\n        for(int i=0;i<n;i++)\\n            nums[i]=mp[nums[i]];\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 547953,
                "title": "faster-than-98-32-memory-usage-less-than-100-00-2-lines-of-code",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const sorted = [...nums].sort((a, b) => a - b);\\n    return nums.map(num => sorted.indexOf(num));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const sorted = [...nums].sort((a, b) => a - b);\\n    return nums.map(num => sorted.indexOf(num));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1053117,
                "title": "python-simple-one-liner",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        return [sorted(nums).index(i) for i in nums]\\n```\\nExplanation:\\n* ```sorted(nums)``` returns a sorted list e.g. ```[1,2,2,3,8]```\\n* The index of the ordered list actually shows how many numbers are smaller than the current number\\n* ```.index(i)``` returns the index of i in the list",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        return [sorted(nums).index(i) for i in nums]\\n```\n```sorted(nums)```\n```[1,2,2,3,8]```\n```.index(i)```",
                "codeTag": "Java"
            },
            {
                "id": 553078,
                "title": "python3-easy-bucket-sort-o-n-beats-100",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        buckets = [0] * 101\\n        \\n        for num in nums:\\n            buckets[num] += 1\\n            \\n        previous = 0    \\n        for i, bucket in enumerate(buckets):\\n            if bucket != 0:\\n                buckets[i] = previous \\n                previous += bucket \\n                \\n        return [buckets[num] for num in nums]        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        buckets = [0] * 101\\n        \\n        for num in nums:\\n            buckets[num] += 1\\n            \\n        previous = 0    \\n        for i, bucket in enumerate(buckets):\\n            if bucket != 0:\\n                buckets[i] = previous \\n                previous += bucket \\n                \\n        return [buckets[num] for num in nums]        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 525004,
                "title": "javascript-clean-solution-using-array-sort",
                "content": "**Code (JavaScript):**\\n\\n```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nfunction smallerNumbersThanCurrent(nums) {\\n  const sorted = Array.from(nums).sort((n1, n2) => n2 - n1);\\n  const map = new Map(sorted.map((num, index) => [num, nums.length - index - 1]));\\n  return nums.map(num => map.get(num));\\n}\\n```\\n\\n**Complexity:**\\n\\nTime `O(NlogN)`\\nSpace `O(N)`\\n\\n**Example:**\\nnums `[8,1,2,2,3]`\\n\\n1. Sort `nums` by descending order\\n    - sorted `[8,3,2,2,1]`\\n2. Create `map` with counts\\n    - map: `{8:4,3:3,2:1,1:0}`\\n3. Return an array with counts stored in `map`\\n    - result: `[4,0,1,1,3]`\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nfunction smallerNumbersThanCurrent(nums) {\\n  const sorted = Array.from(nums).sort((n1, n2) => n2 - n1);\\n  const map = new Map(sorted.map((num, index) => [num, nums.length - index - 1]));\\n  return nums.map(num => map.get(num));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525124,
                "title": "1-line-python-solution",
                "content": "```\\nclass Solution:\\n  def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n    return [sorted(nums).index(a) for a in nums]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n  def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n    return [sorted(nums).index(a) for a in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548851,
                "title": "here-s-my-solution-python3",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        result = []\\n        tempNums = nums.copy()\\n        nums.sort()\\n        for n in tempNums:\\n            result.append(nums.index(n))\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        result = []\\n        tempNums = nums.copy()\\n        nums.sort()\\n        for n in tempNums:\\n            result.append(nums.index(n))\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288341,
                "title": "java-solution-0ms-faster-than-100-submissions",
                "content": "***Please upvote the post if find the solution useful!!!!***\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        int[] bucket = new int[102];\\n        for(int i=0;i<nums.length;i++)        \\n            bucket[nums[i]+1]++;\\n        \\n        for(int i=0;i<101;i++)\\n            bucket[i+1] = bucket[i+1]+bucket[i];\\n        \\n        for(int i=0;i<nums.length;i++)\\n            nums[i] = bucket[nums[i]];\\n        \\n        return nums;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        int[] bucket = new int[102];\\n        for(int i=0;i<nums.length;i++)        \\n            bucket[nums[i]+1]++;\\n        \\n        for(int i=0;i<101;i++)\\n            bucket[i+1] = bucket[i+1]+bucket[i];\\n        \\n        for(int i=0;i<nums.length;i++)\\n            nums[i] = bucket[nums[i]];\\n        \\n        return nums;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642495,
                "title": "javascript-solution",
                "content": "```\\nlet sorted = nums.slice().sort((a,b) => a - b);\\nlet result = [];\\nfor(let i=0; i<nums.length; i++){\\n\\tresult.push(sorted.indexOf(nums[i]));\\n}\\nreturn result;\\n```",
                "solutionTags": [],
                "code": "```\\nlet sorted = nums.slice().sort((a,b) => a - b);\\nlet result = [];\\nfor(let i=0; i<nums.length; i++){\\n\\tresult.push(sorted.indexOf(nums[i]));\\n}\\nreturn result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1057145,
                "title": "python-3-solution-with-explaination",
                "content": "The logic here might confuse you, but its a *ahaa !* moment when you realize it.\\n\\nWe basically need to get the count of numbers smaller than a given number. If this array were to be filled with distinct elements, we would just sort it and get the counts by just accessing their respective index values.\\n\\nfor example :  \\nA = [ 9,4,3,1,6 ] \\n\\nwhen you sort it, you get : [ 1 , 3 , 4 , 6 , 9  ]\\nso if you pick any number, it\\'s index value would denote the position of the element in the sorted array, thereby stating the count of values that are **smaller than it**!   \\n[ 1 =>0, 3 =>1, 4 =>2, 6 => 3, 9 => 4]\\n\\nBut in this question the array can have duplicates. Hence only using the above approach would not solve our issue as we need to get rid of duplicates. \\nFor example :  [ 3 , 3, 5, 8 ] with just the above approach would give us  [ 0, 1 , 2, 3 ], which is wrong, as 3 at index 1 does not have any number smaller than it before it.\\n\\nHence we take the help of a hash map to solve the issue of not considering duplicate values.\\nSo ,\\n1. Go through the same process as above ie sort the array\\n2. Use a hash map to store the element as key and its corresponding index as the value.\\n\\t*Note : Here we ignore the elements that already exist in the hashMap while inserting their values to avoid rewritting of index.*\\n3. Bingo, our answer is ready in the hash map. Now iterate the nums and display its respective hash value.\\n\\nExample: \\n[ 3, 3, 5, 8 ]\\nHash = { }\\n\\n**index : process**\\n**0** : 3 is not in Hash, hence insert it => { 3 : **0** }\\n**1** : 3 is in the Hash, so ignore it this time\\n**2** : 5 is not in the Hash, hence insert it => { 3 : **0**, 5 : **2** }\\n**3** : 8 is not in the Hash, hence insert it => {  3 : **0**, 5 : **2** , 8 : **3** }\\n\\nThere you go ! Use the hash map and extract the counts for respective numbers in nums array.\\n\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n      d = {}\\n      for index,value in enumerate(sorted(nums)):\\n        if value not in d:\\n          d[value] = index\\n          \\n      #iterate through the nums and fetch its corresponding hash table value \\n      ans = [d[value] for value in nums]\\n      return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n      d = {}\\n      for index,value in enumerate(sorted(nums)):\\n        if value not in d:\\n          d[value] = index\\n          \\n      #iterate through the nums and fetch its corresponding hash table value \\n      ans = [d[value] for value in nums]\\n      return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673630,
                "title": "python-3-tow-solutions",
                "content": "1. Sorting+dictionary\\n```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\tdic = {}\\n\\tsorted_list = sorted(nums)\\n\\tl = len(nums)\\n\\tfor i in range(0, l):\\n\\t\\tif sorted_list[i] not in dic:\\n\\t\\t\\tdic[sorted_list[i]] = i\\n\\treturn [dic[n] for n in nums]\\n```\\n\\n2. linear time complexity and constant space\\n\\n```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\tsmaller = [0]*101\\n\\tl = len(nums)\\n\\tfor i in range(0, l):\\n\\t\\tsmaller[nums[i]]+=1\\n\\n\\tfor n in range(1, 101):\\n\\t\\tsmaller[n]+=smaller[n-1]\\n\\n\\tfor i in range(0, l):\\n\\t\\tnums[i] = smaller[nums[i]-1] if nums[i]!=0 else 0\\n\\treturn nums\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table"
                ],
                "code": "```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\tdic = {}\\n\\tsorted_list = sorted(nums)\\n\\tl = len(nums)\\n\\tfor i in range(0, l):\\n\\t\\tif sorted_list[i] not in dic:\\n\\t\\t\\tdic[sorted_list[i]] = i\\n\\treturn [dic[n] for n in nums]\\n```\n```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\tsmaller = [0]*101\\n\\tl = len(nums)\\n\\tfor i in range(0, l):\\n\\t\\tsmaller[nums[i]]+=1\\n\\n\\tfor n in range(1, 101):\\n\\t\\tsmaller[n]+=smaller[n-1]\\n\\n\\tfor i in range(0, l):\\n\\t\\tnums[i] = smaller[nums[i]-1] if nums[i]!=0 else 0\\n\\treturn nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2837597,
                "title": "faster-than-100-simple-javascript-hashmap-solution",
                "content": "**Algorithm**\\n\\n`input: [8, 1, 2, 2, 3]`\\n* declare a new array with the input array sorted in ascending order\\n+++ The elements\\'s index shows the amount of numbers that are smaller.+++\\n\\n`sorted: [1, 2, 2, 3, 8]`\\n* iterate through sorted array and set the number and its index to a Map (skip any that already exist in the Map)\\n\\n`map: {\\n1 => 0,\\n2 => 1,\\n3 => 3,\\n8 => 4\\n}`\\n* iterate through the original input and create a new array with the current number\\'s value from the Map\\n\\n`output: [4, 0, 1, 1, 3]`\\n\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    let hash = new Map();\\n    let sorted = nums.slice().sort((a,b) => a - b);\\n    sorted.forEach((number, idx) => hash.has(number)? null: hash.set(number, idx));\\n    return nums.map(x => hash.get(x));\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a11f5325-2826-4f0b-8a7c-8d3f9931ef4a_1669076360.1411996.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Sorting"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    let hash = new Map();\\n    let sorted = nums.slice().sort((a,b) => a - b);\\n    sorted.forEach((number, idx) => hash.has(number)? null: hash.set(number, idx));\\n    return nums.map(x => hash.get(x));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526946,
                "title": "c-two-solutions",
                "content": "First solution - **Brute force**\\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n\\tvector<int> res;\\n\\tint i = 0, n = nums.size();\\n\\twhile (i < n) {\\n\\t\\tint count = 0, j = 0;\\n\\t\\twhile (j < n) {\\n\\t\\t\\tif (j != i && nums[i] > nums[j]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tres.push_back(count);\\n\\t\\ti++;\\n\\t}\\n\\treturn res;\\n}\\n```\\nSecond solution - **Using sort and map**\\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        vector<int> arr = nums;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < arr.size(); i++) {\\n            if (map.find(arr[i]) == map.end()) {\\n                map[arr[i]] = i;\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n            nums[i] = map[nums[i]];\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n\\tvector<int> res;\\n\\tint i = 0, n = nums.size();\\n\\twhile (i < n) {\\n\\t\\tint count = 0, j = 0;\\n\\t\\twhile (j < n) {\\n\\t\\t\\tif (j != i && nums[i] > nums[j]) {\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t\\tj++;\\n\\t\\t}\\n\\t\\tres.push_back(count);\\n\\t\\ti++;\\n\\t}\\n\\treturn res;\\n}\\n```\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        unordered_map<int, int> map;\\n        vector<int> arr = nums;\\n        sort(arr.begin(), arr.end());\\n        for (int i = 0; i < arr.size(); i++) {\\n            if (map.find(arr[i]) == map.end()) {\\n                map[arr[i]] = i;\\n            }\\n        }\\n        for (int i = 0; i < nums.size(); i++) {\\n            nums[i] = map[nums[i]];\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526903,
                "title": "1365-javascript-1-line-solution",
                "content": "I\\'m \\uD83E\\uDD1C\\u23AFS\\u23AFT\\u23AFR\\u23AFE\\u23AFT\\u23AFC\\u23AFH\\u23AFI\\u23AFN\\u23AFG\\u23AF\\uD83E\\uDD1B the definition a bit here.\\n\\nBut, then again, aren\\'t I always? \\uD83D\\uDE1C\\n\\n> Runtime: **92 ms**, faster than *84.06%* of JavaScript online submissions\\n> Memory Usage: **41 MB**, less than *17.24%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums =>\\n  (map => nums.map(n => map.get(n)))(\\n    new Map(\\n      [...nums]\\n        .sort((a, b) => b - a)\\n        .map((val, idx) => [val, nums.length - idx - 1]),\\n    ),\\n  );\\n```\\n\\nHere is the boring multiple-line solution.\\n\\n> Runtime: **92 ms**, faster than *85.25%* of JavaScript online submissions\\n> Memory Usage: **40.9 MB**, less than *20.23%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums => {\\n  const map = new Map(\\n    [...nums]\\n      .sort((a, b) => b - a)\\n      .map((val, idx) => [val, nums.length - idx - 1]),\\n  );\\n  return nums.map(n => map.get(n));\\n};\\n```\\n\\nHere is another 1-line solution where the `Map` object is created in the\\nparameters of the original function. Some people seem to prefer this technique.\\n\\n> Runtime: **92 ms**, faster than *85.25%* of JavaScript online submissions\\n> Memory Usage: **41.1 MB**, less than *17.95%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n const smallerNumbersThanCurrent = (\\n  nums,\\n  map = new Map(\\n    [...nums]\\n      .sort((a, b) => b - a)\\n      .map((val, idx) => [val, nums.length - idx - 1]),\\n  ),\\n) => nums.map(n => map.get(n));\\n```\\n\\nCreating the `Map` object outside of the `map` function is important for\\nperformance reasons. Recreating the `Map` object on every iteration of the `map`\\nfunction slows execution significantly.\\n\\n> Runtime: **1004 ms**, faster than *5.58%* of JavaScript online submissions\\n> Memory Usage: **45.4 MB**, less than *5.05%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums =>\\n  nums.map(n =>\\n    new Map(\\n      [...nums]\\n        .sort((a, b) => b - a)\\n        .map((val, idx) => [val, nums.length - idx - 1]),\\n    ).get(n),\\n  );\\n```\\n\\nAnd here is the original solution with the unnecessary `reverse` function.\\n\\n> Runtime: **100 ms**, faster than *49.01%* of JavaScript online submissions\\n> Memory Usage: **40.3 MB**, less than *14.09%* of JavaScript online submissions\\n\\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums =>\\n  (map => nums.map(n => map.get(n)))(\\n    new Map(\\n      [...nums]\\n        .sort((a, b) => a - b)\\n        .map((val, idx) => [val, idx])\\n        .reverse(),\\n    ),\\n  );\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums =>\\n  (map => nums.map(n => map.get(n)))(\\n    new Map(\\n      [...nums]\\n        .sort((a, b) => b - a)\\n        .map((val, idx) => [val, nums.length - idx - 1]),\\n    ),\\n  );\\n```\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums => {\\n  const map = new Map(\\n    [...nums]\\n      .sort((a, b) => b - a)\\n      .map((val, idx) => [val, nums.length - idx - 1]),\\n  );\\n  return nums.map(n => map.get(n));\\n};\\n```\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\n const smallerNumbersThanCurrent = (\\n  nums,\\n  map = new Map(\\n    [...nums]\\n      .sort((a, b) => b - a)\\n      .map((val, idx) => [val, nums.length - idx - 1]),\\n  ),\\n) => nums.map(n => map.get(n));\\n```\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums =>\\n  nums.map(n =>\\n    new Map(\\n      [...nums]\\n        .sort((a, b) => b - a)\\n        .map((val, idx) => [val, nums.length - idx - 1]),\\n    ).get(n),\\n  );\\n```\n```javascript\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nconst smallerNumbersThanCurrent = nums =>\\n  (map => nums.map(n => map.get(n)))(\\n    new Map(\\n      [...nums]\\n        .sort((a, b) => a - b)\\n        .map((val, idx) => [val, idx])\\n        .reverse(),\\n    ),\\n  );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 841228,
                "title": "java-best-time-o-n-counting-each-occurrence",
                "content": "```\\nclass Solution {\\n\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        var buck = new int[101];\\n        \\n        for (int i = 0; i < nums.length; i++)\\n            buck[nums[i]]++;                                // count each occurence\\n      \\n        for (int i = 1; i < buck.length; i++)\\n            buck[i] += buck[i - 1];                         // calc how manu numbers are smaller\\n\\n        for (int i = 0; i < nums.length; i++)\\n            nums[i] = nums[i] == 0 ? 0 : buck[nums[i] - 1]; // fill resulting array\\n        \\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        var buck = new int[101];\\n        \\n        for (int i = 0; i < nums.length; i++)\\n            buck[nums[i]]++;                                // count each occurence\\n      \\n        for (int i = 1; i < buck.length; i++)\\n            buck[i] += buck[i - 1];                         // calc how manu numbers are smaller\\n\\n        for (int i = 0; i < nums.length; i++)\\n            nums[i] = nums[i] == 0 ? 0 : buck[nums[i] - 1]; // fill resulting array\\n        \\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2663898,
                "title": "two-line-solution-with-python",
                "content": "#### Less efficient way of solving\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        l1 = sorted(nums)\\n        return [l1.index(i) for i in nums]\\n```\\n\\n#### Solution with relatively faster runtime\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        mydict = dict()\\n        for k, v in enumerate(sorted(nums)):\\n            if v not in mydict:\\n                mydict[v] = k\\n        return [mydict[item] for item in nums]\\n```\\n![image.png](https://assets.leetcode.com/users/images/4e946e69-28b8-4895-a90b-a35340856b63_1672588044.6296315.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        l1 = sorted(nums)\\n        return [l1.index(i) for i in nums]\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        mydict = dict()\\n        for k, v in enumerate(sorted(nums)):\\n            if v not in mydict:\\n                mydict[v] = k\\n        return [mydict[item] for item in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 588833,
                "title": "java-clean-code-with-time-complexity",
                "content": "```\\nExplanation:\\nstep 1. count[] array for number counting of given array, sum[] array to store sum count upto any specific number(array length is 100 as range is given 0<=nums<=100)\\nstep 2. traverse given array and update count of each number.\\nstep3. traverse 0 to 100 and update sum count of each number\\neg:\\nsum[3] = sum[2]+count[2](as sum of two does n\\'t include count of 2).\\nstep4. return sum count based on your given input array.\\nTC=O(n)\\nSC= O(n)+O(n) = O(n)\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] count = new int[101];\\n        int[] sum = new int[101];\\n        for(int i=0; i<nums.length; i++) {\\n            count[nums[i]]++;\\n        }\\n\\n        for(int i=1; i<101; i++) {\\n            sum[i] = count[i-1] + sum[i-1];\\n        }\\n        for(int i=0; i<nums.length; i++) {\\n            nums[i] = sum[nums[i]];\\n        }\\n        return nums;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nExplanation:\\nstep 1. count[] array for number counting of given array, sum[] array to store sum count upto any specific number(array length is 100 as range is given 0<=nums<=100)\\nstep 2. traverse given array and update count of each number.\\nstep3. traverse 0 to 100 and update sum count of each number\\neg:\\nsum[3] = sum[2]+count[2](as sum of two does n\\'t include count of 2).\\nstep4. return sum count based on your given input array.\\nTC=O(n)\\nSC= O(n)+O(n) = O(n)\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] count = new int[101];\\n        int[] sum = new int[101];\\n        for(int i=0; i<nums.length; i++) {\\n            count[nums[i]]++;\\n        }\\n\\n        for(int i=1; i<101; i++) {\\n            sum[i] = count[i-1] + sum[i-1];\\n        }\\n        for(int i=0; i<nums.length; i++) {\\n            nums[i] = sum[nums[i]];\\n        }\\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3774860,
                "title": "best-two-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code1\\n\\n```\\nclass Solution {\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] output = new int[nums.length];\\n    int[] count = new int[101]; // since the numbers are between 0 and 100\\n    for (int num : nums) {\\n        count[num]++;\\n    }\\n    for (int i = 1; i <= 100; i++) {\\n        count[i] += count[i-1];\\n    }\\n    for (int i = 0; i < nums.length; i++) {\\n        output[i] = nums[i] == 0 ? 0 : count[nums[i]-1];\\n    }\\n    return output;\\n}\\n}\\n```\\n\\n\\n# Code2\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int output[] = new int[nums.length];\\n        ArrayList<Integer> list = (ArrayList<Integer>) Arrays.stream(nums).boxed().collect(Collectors.toList());\\n        Collections.sort(list);\\n\\n        for (int i = 0; i <= nums.length-1 ; i++)\\n        {\\n            int n = 0;\\n            int index = list.indexOf( nums[i] );\\n\\n            for (int j = index-1; j >= 0 ; j-- )\\n            {\\n                if (nums[i] > list.get(j) )\\n                    n++;\\n            }\\n                output[i] = n;\\n        }\\n\\n\\n        return output;\\n    }\\n}\\n```\\n\\n\\n![e78315ef-8a9d-492b-9908-e3917f23eb31_1674946036.087042.jpeg](https://assets.leetcode.com/users/images/97d10918-e64a-449d-b61b-998bb9e52937_1689529870.2512202.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] output = new int[nums.length];\\n    int[] count = new int[101]; // since the numbers are between 0 and 100\\n    for (int num : nums) {\\n        count[num]++;\\n    }\\n    for (int i = 1; i <= 100; i++) {\\n        count[i] += count[i-1];\\n    }\\n    for (int i = 0; i < nums.length; i++) {\\n        output[i] = nums[i] == 0 ? 0 : count[nums[i]-1];\\n    }\\n    return output;\\n}\\n}\\n```\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int output[] = new int[nums.length];\\n        ArrayList<Integer> list = (ArrayList<Integer>) Arrays.stream(nums).boxed().collect(Collectors.toList());\\n        Collections.sort(list);\\n\\n        for (int i = 0; i <= nums.length-1 ; i++)\\n        {\\n            int n = 0;\\n            int index = list.indexOf( nums[i] );\\n\\n            for (int j = index-1; j >= 0 ; j-- )\\n            {\\n                if (nums[i] > list.get(j) )\\n                    n++;\\n            }\\n                output[i] = n;\\n        }\\n\\n\\n        return output;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526266,
                "title": "o-n-o-nlogn-o-n-2-3-different-solutions-in-go",
                "content": "## 1. Count the number of occurrences\\n\\n- Time Complexity: O(N) (N + 100 + N)\\n- Space Complexity: O(1) (101 + answer)\\n\\n> Runtime: 4 ms (faster than 100.00%)\\n> Memory Usage: 3.1 MB (less than 100.00%)\\n\\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n  occurrences := [101]int{}\\n  for _, num := range nums {\\n    occurrences[num]++\\n  }\\n  prevOccurrences := occurrences[0]\\n  occurrences[0] = 0\\n  for i := range occurrences[1:] {\\n    occurrences[i+1], prevOccurrences = prevOccurrences, prevOccurrences+occurrences[i+1]\\n  }\\n  counts := make([]int, len(nums))\\n  for i, num := range nums {\\n    counts[i] = occurrences[num]\\n  }\\n  return counts\\n}\\n```\\n\\n## 2-1. Sort and binary search\\n\\n- Time Complexity: O(NlogN) (N + NlogN + NlogN)\\n- Space Complexity: O(N) (N + logN + answer)\\n\\n> Runtime: 4 ms (faster than 100.00%)\\n> Memory Usage: 3.2 MB (less than 100.00%)\\n\\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n sortedNums := make([]int, len(nums))\\n copy(sortedNums, nums)\\n sort.Ints(sortedNums)\\n counts := make([]int, len(nums))\\n for i, num := range nums {\\n   counts[i] = sort.Search(len(sortedNums), func(j int) bool {\\n     return num <= sortedNums[j]\\n   })\\n }\\n return counts\\n}\\n```\\n\\n## 2-2. Sort and binary search with cache\\n\\n- Time Complexity: O(NlogN) (N + NlogN + NlogN)\\n- Space Complexity: O(N) (N + logN + N + answer)\\n\\n> Runtime: 4 ms (faster than 100.00%)\\n> Memory Usage: 3.5 MB (less than 100.00%)\\n\\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n sortedNums := make([]int, len(nums))\\n copy(sortedNums, nums)\\n sort.Ints(sortedNums)\\n counts := make([]int, len(nums))\\n cache := map[int]int{}\\n for i, num := range nums {\\n   if count, ok := cache[num]; ok {\\n     counts[i] = count\\n     continue\\n   }\\n   counts[i] = sort.Search(len(sortedNums), func(j int) bool {\\n     return num <= sortedNums[j]\\n   })\\n   cache[num] = counts[i]\\n }\\n return counts\\n}\\n```\\n\\n## 2-3. Sort and pre-calculate the index of each number as map\\n\\nref: https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/discuss/525004/JavaScript-Clean-solution-using-array-sort\\n\\n- Time Complexity: O(NlogN) (N + NlogN + N + N)\\n- Space Complexity: O(N) (N + logN + N + answer)\\n\\n> Runtime: 4 ms (faster than 95.08%)\\n> Memory Usage: 3.5 MB (less than 100.00%)\\n\\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n  sortedNums := make([]int, len(nums))\\n  copy(sortedNums, nums)\\n  sort.Ints(sortedNums)\\n  countMap := map[int]int{}\\n  for i, num := range sortedNums {\\n    if _, ok := countMap[num]; !ok {\\n      countMap[num] = i\\n    }\\n  }\\n  counts := make([]int, len(nums))\\n  for i, num := range nums {\\n    counts[i] = countMap[num]\\n  }\\n  return counts\\n}\\n```\\n\\n## 3-1. Brute force\\n\\n- Time Complexity: O(N^2)\\n- Space Complexity: O(1)\\n\\n> Runtime: 12 ms (faster than 100.00%)\\n> Memory Usage: 3.1 MB (less than 100.00%)\\n\\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n counts := make([]int, len(nums))\\n for i, current := range nums {\\n   for _, target := range nums {\\n     if current > target {\\n       counts[i]++\\n     }\\n   }\\n }\\n return counts\\n}\\n```\\n\\n## 3-2. Brute force with cache\\n\\n- Time Complexity: O(N^2)\\n- Space Complexity: O(N) (N + answer)\\n\\n> Runtime: 4 ms (faster than 100.00%)\\n> Memory Usage: 3.4 MB (less than 100.00%)\\n\\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n counts := make([]int, len(nums))\\n cache := map[int]int{}\\n for i, current := range nums {\\n   if count, ok := cache[current]; ok {\\n     counts[i] = count\\n     continue\\n   }\\n   for _, target := range nums {\\n     if current > target {\\n       counts[i]++\\n     }\\n   }\\n   cache[current] = counts[i]\\n }\\n return counts\\n}\\n```\\n",
                "solutionTags": [
                    "Go",
                    "Array",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n  occurrences := [101]int{}\\n  for _, num := range nums {\\n    occurrences[num]++\\n  }\\n  prevOccurrences := occurrences[0]\\n  occurrences[0] = 0\\n  for i := range occurrences[1:] {\\n    occurrences[i+1], prevOccurrences = prevOccurrences, prevOccurrences+occurrences[i+1]\\n  }\\n  counts := make([]int, len(nums))\\n  for i, num := range nums {\\n    counts[i] = occurrences[num]\\n  }\\n  return counts\\n}\\n```\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n sortedNums := make([]int, len(nums))\\n copy(sortedNums, nums)\\n sort.Ints(sortedNums)\\n counts := make([]int, len(nums))\\n for i, num := range nums {\\n   counts[i] = sort.Search(len(sortedNums), func(j int) bool {\\n     return num <= sortedNums[j]\\n   })\\n }\\n return counts\\n}\\n```\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n sortedNums := make([]int, len(nums))\\n copy(sortedNums, nums)\\n sort.Ints(sortedNums)\\n counts := make([]int, len(nums))\\n cache := map[int]int{}\\n for i, num := range nums {\\n   if count, ok := cache[num]; ok {\\n     counts[i] = count\\n     continue\\n   }\\n   counts[i] = sort.Search(len(sortedNums), func(j int) bool {\\n     return num <= sortedNums[j]\\n   })\\n   cache[num] = counts[i]\\n }\\n return counts\\n}\\n```\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n  sortedNums := make([]int, len(nums))\\n  copy(sortedNums, nums)\\n  sort.Ints(sortedNums)\\n  countMap := map[int]int{}\\n  for i, num := range sortedNums {\\n    if _, ok := countMap[num]; !ok {\\n      countMap[num] = i\\n    }\\n  }\\n  counts := make([]int, len(nums))\\n  for i, num := range nums {\\n    counts[i] = countMap[num]\\n  }\\n  return counts\\n}\\n```\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n counts := make([]int, len(nums))\\n for i, current := range nums {\\n   for _, target := range nums {\\n     if current > target {\\n       counts[i]++\\n     }\\n   }\\n }\\n return counts\\n}\\n```\n```\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n counts := make([]int, len(nums))\\n cache := map[int]int{}\\n for i, current := range nums {\\n   if count, ok := cache[current]; ok {\\n     counts[i] = count\\n     continue\\n   }\\n   for _, target := range nums {\\n     if current > target {\\n       counts[i]++\\n     }\\n   }\\n   cache[current] = counts[i]\\n }\\n return counts\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526057,
                "title": "javascript-and-c-solutions",
                "content": "**Solution #1 - Brute-Force:**\\n\\nBrute-force check each pair `i`, `j`.\\n\\n**Runtime:** O(N<sup>2</sup>)\\n\\n*Javascript*\\n```\\nlet smallerNumbersThanCurrent = A => {\\n    let N = A.length;\\n    let ans = Array(N).fill(0);\\n    for (let i = 0; i < N; ++i)\\n        for (let j = 0; j < N; ++j)\\n            if (i != j && A[i] > A[j])\\n                ++ans[i];\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI smallerNumbersThanCurrent(VI& A) {\\n        int N = A.size();\\n        VI ans(N);\\n        for (auto i = 0; i < N; ++i)\\n            for (auto j = 0; j < N; ++j)\\n                if (i != j && A[i] > A[j])\\n                    ++ans[i];\\n        return ans;\\n    }\\n};\\n```\\n\\n**Solution #2 - Counting Sort:**\\n\\nLet `cnt` be `101` \"buckets\", where each index corresponds to each value from `0` to `100` inclusive.  The value at each index is the count of that value.\\n\\n**Runtime:** O(N)\\n\\n*Javascript*\\n```\\nlet smallerNumbersThanCurrent = (A, cnt = Array(101).fill(0), ans = []) => {\\n    for (let x of A)\\n        ++cnt[x];\\n    for (let i = 1; i < cnt.length; ++i)\\n        cnt[i] += cnt[i - 1];\\n    for (let x of A)\\n        ans.push(x == 0 ? 0 : cnt[x - 1]);\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI smallerNumbersThanCurrent(VI& A, VI cnt = VI(101), VI ans = {}) {\\n        for (auto x: A)\\n            ++cnt[x];\\n        for (auto i = 1; i < cnt.size(); ++i)\\n            cnt[i] += cnt[i - 1];\\n        for (auto x: A)\\n            ans.push_back(x == 0 ? 0 : cnt[x - 1]);\\n        return ans;\\n    }\\n};\\n```\\n\\n**Solution #3 - Sort & O(logN) Lookup:**\\n\\nSort `A` in a multiset `S`, then lookup each value in `A` by it\\'s index in `S` to formulate the answer.\\n\\n**Runtime:** O(N * logN)\\n\\n*Javascript*\\n```\\nlet smallerNumbersThanCurrent = (A, ans = []) => {\\n    let S = [...A].sort((a, b) => a - b);\\n    let find = (x, i = 0, j = S.length - 1, ans = 0) => {\\n        while (i <= j) {\\n            let k = (i + j) >> 1;\\n            if (x <= S[k]) {\\n                ans = k;\\n                j = k - 1;\\n            } else {\\n                i = k + 1;\\n            }\\n        }\\n        return ans;\\n    };\\n    for (let x of A)\\n        ans.push(find(x));\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = multiset<int>;\\n    VI smallerNumbersThanCurrent(VI& A, VI ans = {}) {\\n        Set S{A.begin(), A.end()};\\n        for (auto x: A)\\n            ans.push_back(distance(S.begin(), S.find(x)));\\n        return ans;\\n    }\\n};\\n```\\n\\n**Solution #4 - Sort & O(1) Lookup:**\\n\\nSort `A` and store each key `x` in a map `m` whose value is the sorted index of `x`.\\n\\n**Runtime:** O(N * logN)\\n\\n*Javascript*\\n```\\nlet smallerNumbersThanCurrent = (A, m = {}, ans = []) => {\\n    let S = [...A].sort((a, b) => a - b);\\n    for (let i = 0; i < S.length; ++i)\\n        m[S[i]] = m[S[i]] >= 0 ? m[S[i]] : i;\\n    for (let x of A)\\n        ans.push(m[x]);\\n    return ans;\\n};\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = multiset<int>;\\n    using Map = unordered_map<int, int>;\\n    VI smallerNumbersThanCurrent(VI& A, Map m = {}, VI ans = {}) {\\n        Set S{A.begin(), A.end()};\\n        for (auto it = S.begin(); it != S.end(); ++it)\\n            if (m.find(*it) == m.end())\\n                m[*it] = distance(S.begin(), it);\\n        for (auto x: A)\\n            ans.push_back(m[x]);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet smallerNumbersThanCurrent = A => {\\n    let N = A.length;\\n    let ans = Array(N).fill(0);\\n    for (let i = 0; i < N; ++i)\\n        for (let j = 0; j < N; ++j)\\n            if (i != j && A[i] > A[j])\\n                ++ans[i];\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI smallerNumbersThanCurrent(VI& A) {\\n        int N = A.size();\\n        VI ans(N);\\n        for (auto i = 0; i < N; ++i)\\n            for (auto j = 0; j < N; ++j)\\n                if (i != j && A[i] > A[j])\\n                    ++ans[i];\\n        return ans;\\n    }\\n};\\n```\n```\\nlet smallerNumbersThanCurrent = (A, cnt = Array(101).fill(0), ans = []) => {\\n    for (let x of A)\\n        ++cnt[x];\\n    for (let i = 1; i < cnt.length; ++i)\\n        cnt[i] += cnt[i - 1];\\n    for (let x of A)\\n        ans.push(x == 0 ? 0 : cnt[x - 1]);\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    VI smallerNumbersThanCurrent(VI& A, VI cnt = VI(101), VI ans = {}) {\\n        for (auto x: A)\\n            ++cnt[x];\\n        for (auto i = 1; i < cnt.size(); ++i)\\n            cnt[i] += cnt[i - 1];\\n        for (auto x: A)\\n            ans.push_back(x == 0 ? 0 : cnt[x - 1]);\\n        return ans;\\n    }\\n};\\n```\n```\\nlet smallerNumbersThanCurrent = (A, ans = []) => {\\n    let S = [...A].sort((a, b) => a - b);\\n    let find = (x, i = 0, j = S.length - 1, ans = 0) => {\\n        while (i <= j) {\\n            let k = (i + j) >> 1;\\n            if (x <= S[k]) {\\n                ans = k;\\n                j = k - 1;\\n            } else {\\n                i = k + 1;\\n            }\\n        }\\n        return ans;\\n    };\\n    for (let x of A)\\n        ans.push(find(x));\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = multiset<int>;\\n    VI smallerNumbersThanCurrent(VI& A, VI ans = {}) {\\n        Set S{A.begin(), A.end()};\\n        for (auto x: A)\\n            ans.push_back(distance(S.begin(), S.find(x)));\\n        return ans;\\n    }\\n};\\n```\n```\\nlet smallerNumbersThanCurrent = (A, m = {}, ans = []) => {\\n    let S = [...A].sort((a, b) => a - b);\\n    for (let i = 0; i < S.length; ++i)\\n        m[S[i]] = m[S[i]] >= 0 ? m[S[i]] : i;\\n    for (let x of A)\\n        ans.push(m[x]);\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = multiset<int>;\\n    using Map = unordered_map<int, int>;\\n    VI smallerNumbersThanCurrent(VI& A, Map m = {}, VI ans = {}) {\\n        Set S{A.begin(), A.end()};\\n        for (auto it = S.begin(); it != S.end(); ++it)\\n            if (m.find(*it) == m.end())\\n                m[*it] = distance(S.begin(), it);\\n        for (auto x: A)\\n            ans.push_back(m[x]);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1718411,
                "title": "java-o-nlogn-soln-using-sort-map",
                "content": "**Upvote if you Got It** \\uD83D\\uDE42\\nclass Solution {\\n\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] ans = nums.clone();\\n        int count = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        Arrays.sort(nums);\\n        \\n        for(int i=0;i<nums.length;){\\n            if(i==nums.length-1 || nums[i]!=nums[i+1]){\\n                hm.put(nums[i],count);\\n                count = (i+1); \\n            }\\n            i++; \\n        } \\n        \\n        for(int i=0;i<nums.length;i++)\\n            ans[i] = hm.get(ans[i]);\\n        \\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] ans = nums.clone();\\n        int count = 0;\\n        HashMap<Integer, Integer> hm = new HashMap<>();\\n        Arrays.sort(nums);\\n        \\n        for(int i=0;i<nums.length;){\\n            if(i==nums.length-1 || nums[i]!=nums[i+1]){\\n                hm.put(nums[i],count);\\n                count = (i+1); \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1419341,
                "title": "javascript-elegant-o-n-solution",
                "content": "\\nThe key thing to understand here is that the numbers are in the **range of 0 to 100**.\\nThis allows us to compute the amount of smaller numbers for every possible number in constant time.\\n\\nLet\\'s define: **smaller(n) = amount of numbers smaller than n in nums**.\\n\\nWe start off by initializing two arrays:\\n\\n```\\nconst frequencies = new Array(101).fill(0);\\nconst smaller = new Array(101).fill(0);\\n```\\n\\nThen we want to compute what is the frequency of any given 0 <= n <= 100 in the array:\\n\\n```\\nnums.forEach(num => frequencies[num]++);\\n```\\n\\nNow for the important part:\\n\\nWe will compute **smaller(n)** for every **0 <= n <= 100**.\\n\\n**The value of smaller(n) is how many numbers are smaller than the number before it plus the frequency of that number in nums.**\\n\\n*(If that sentence didn\\'t make sense to you, read it again or try playing with some examples. Continue reading after you\\'re comfortable with the idea)*\\n\\nNotice how this is exactly the definition from the beginning.\\n\"how many numbers are smaller than the number before it\" is just **smaller(n-1)**.\\n\\nSo in other words: **smaller(n) = smaller(n-1) + frequency(n-1)**\\n\\nThis is great, we can now just compute smaller(n) on the go:\\n\\n```\\n for (let i = 1; i < 101; i++) {\\n   smaller[i] = smaller[i - 1] + frequencies[i - 1];\\n}\\n```\\n\\nAt last, we actually don\\'t want every smaller(n), just the ones from the nums array, and in the same order. So we will map every num in nums to smaller(num):\\n\\n```\\nreturn nums.map(num => smaller[num]);\\n```\\n\\nAnd this is the entire code:\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nfunction smallerNumbersThanCurrent(nums) {\\n  const frequencies = new Array(101).fill(0);\\n  const smaller = new Array(101).fill(0);\\n\\n  nums.forEach(num => frequencies[num]++);\\n\\n  for (let i = 1; i < 101; i++) {\\n    smaller[i] = smaller[i - 1] + frequencies[i - 1];\\n  }\\n\\n  return nums.map(num => smaller[num]);\\n}\\n```\\n\\n**Side note:** this method is often described as \"dynamic programming\". Basically, we broke down the value of smaller(n) to a simpler sub-problem and used it to optimize the computation of smaller(n).",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst frequencies = new Array(101).fill(0);\\nconst smaller = new Array(101).fill(0);\\n```\n```\\nnums.forEach(num => frequencies[num]++);\\n```\n```\\n for (let i = 1; i < 101; i++) {\\n   smaller[i] = smaller[i - 1] + frequencies[i - 1];\\n}\\n```\n```\\nreturn nums.map(num => smaller[num]);\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nfunction smallerNumbersThanCurrent(nums) {\\n  const frequencies = new Array(101).fill(0);\\n  const smaller = new Array(101).fill(0);\\n\\n  nums.forEach(num => frequencies[num]++);\\n\\n  for (let i = 1; i < 101; i++) {\\n    smaller[i] = smaller[i - 1] + frequencies[i - 1];\\n  }\\n\\n  return nums.map(num => smaller[num]);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 900280,
                "title": "easiest-solution-using-sorted-function-python",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        sort = sorted(nums)\\n        for i in nums:\\n            ans.append(sort.index(i))\\n        return ans\\n```\\nFor more such questions: https://github.com/vanigupta20024/Programming-Challenges",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        sort = sorted(nums)\\n        for i in nums:\\n            ans.append(sort.index(i))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 656903,
                "title": "java-using-list-simple-solutions",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int len = nums.length;\\n        int[] result = new int[len];\\n        List<Integer> temp = new ArrayList<>();\\n\\n        for(int n : nums) temp.add(n);\\n\\n        Collections.sort(temp);\\n\\n        for (int i = 0 ; i < len ; i++) {\\n            result[i] = temp.indexOf(nums[i]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int len = nums.length;\\n        int[] result = new int[len];\\n        List<Integer> temp = new ArrayList<>();\\n\\n        for(int n : nums) temp.add(n);\\n\\n        Collections.sort(temp);\\n\\n        for (int i = 0 ; i < len ; i++) {\\n            result[i] = temp.indexOf(nums[i]);\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 613343,
                "title": "simple-python-solution-72ms-and-13-8-mb-explained",
                "content": "We are just using another list which is sorted of nums and then finding the location of first occurence of the element in the sorted list and returning its index that means it will return the remaining number of smaller elements in the list.\\n\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        numi = sorted(nums)\\n        for i in range(0,len(nums)):\\n            a.append(numi.index(nums[i]))\\n        return a\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        a=[]\\n        numi = sorted(nums)\\n        for i in range(0,len(nums)):\\n            a.append(numi.index(nums[i]))\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 578007,
                "title": "c-linq-solution-in-one-string",
                "content": "```\\npublic int[] SmallerNumbersThanCurrent(int[] nums) {\\n     return nums.Select(x => (nums.Where(i => i < x).Count())).ToArray();\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic int[] SmallerNumbersThanCurrent(int[] nums) {\\n     return nums.Select(x => (nums.Where(i => i < x).Count())).ToArray();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 530928,
                "title": "python-very-fast-99-84-explained-with-some-tips-on-how-to-get-to-99",
                "content": "Here is the code:\\n\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        d = {}\\n        snums = sorted(nums)\\n        for i,v in enumerate(snums):\\n            if v not in d:\\n                d[v]=i       \\n        return [ d[n] for n in nums ]\\n```\\n\\nThe logic:\\n\\n1. since we are comparing values against each other, we\\'ll need to sort them. so we just do `snums = sorted(nums)`\\n2. this is an important part. At some point we\\'ll need to search index of an element by its value. There are two ways to do it. One is to use list.index(v) method, another one is to use a dictionary. The problem is those methods have very different time complexity. list.index() is O(N) because python effective scans through the list. While using a dictionary is O(1) because is hash based.  So while functionally the method above and something like:\\n\\n`return [sorted(nums).index(n) for n in nums]` \\n\\nproduce the same result, the complexity is different. the one-liner above is:\\n\\nO(NlogN) for `sorted`, O(N) for the `for` loop and  O(N) for `index()`  \\n\\nBut the important part is for every element inside `for` we are doing sort and index(), so it is:\\n\\nN*(N + NlogN) = N^2 + N^2*logN, the highest order id N^2 * logN\\n\\nIt can be improved  if we move sorted() outside of the loop:\\n\\n```\\ns=sorted(nums)\\nreturn [s.index(n) for n in nums]\\n``` \\n\\nhere we do NlogN + N * N (because for each element we do index(), that means loop inside another loop), and the highest component is N^2.\\n\\nMeanwhile the dictionary approach above is:\\n\\nNlogN to do the first `sorted`, then we add N for `for i,v in enumerate(snums)` and then we add another N for `d[n] for n in nums ]`. The important part is we run loops sequentially and not one inside another.\\n\\nThat means a sort / index approach will take NlogN + N^2 - the highest is N^2 while a dictionary based would be NlogN + N + N - the highest NlogN.\\n\\nTo keep story short, due to the way how Python implemented lists and dictionaries, a dictionary based approach should be faster.\\n\\nSo when I ran a few tests, this solution scored up to 99.84%, so that goes inline with that theory.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        d = {}\\n        snums = sorted(nums)\\n        for i,v in enumerate(snums):\\n            if v not in d:\\n                d[v]=i       \\n        return [ d[n] for n in nums ]\\n```\n```\\ns=sorted(nums)\\nreturn [s.index(n) for n in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525059,
                "title": "python-o-n-solution-count-instead-of-sort",
                "content": "Use `bucket` to count the occurence of 0 ~ 100 instead of sorting because of the constraint `0 <= nums[i] <= 100`.\\nThen accumulate `bucket` to get `accu`. `accu[i]` is the count of `num` in `nums` which is smaller than i.\\n\\n```python\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        bucket = [0] * 101\\n        for num in nums:\\n            bucket[num] += 1\\n            \\n        accu = [0] * 101\\n        for i in range(1, 101):   # 1 ~ 100\\n            accu[i] = accu[i-1] + bucket[i-1]\\n            \\n        return [ accu[num] for num in nums ]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        bucket = [0] * 101\\n        for num in nums:\\n            bucket[num] += 1\\n            \\n        accu = [0] * 101\\n        for i in range(1, 101):   # 1 ~ 100\\n            accu[i] = accu[i-1] + bucket[i-1]\\n            \\n        return [ accu[num] for num in nums ]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153982,
                "title": "swift-how-many-numbers-are-smaller-than-the-current-number",
                "content": "### Solution:\\n```swift\\nclass Solution {\\n    func smallerNumbersThanCurrent(_ nums: [Int]) -> [Int] {\\n        var counts = Array(repeating: 0, count: 101), arr = counts, sum = 0\\n        nums.map{ counts[$0] += 1 }\\n        \\n        for i in 1...counts.count - 1 {\\n            sum += counts[i-1]\\n            arr[i] = sum\\n        }\\n        \\n        var ans = Array(repeating: 0, count: nums.count)\\n        for i in 0..<nums.count { ans[i] = arr[nums[i]]}\\n        return ans\\n    }\\n}\\n```\\n\\n### Tests:\\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.097 (0.098) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssertEqual(s.smallerNumbersThanCurrent([8,1,2,2,3]), [4,0,1,1,3]) // success\\n    }\\n    func testExample2() {\\n        XCTAssertEqual(s.smallerNumbersThanCurrent([6,5,4,8]), [2,1,0,3]) // success\\n    }\\n    func testExample3() {\\n        XCTAssertEqual(s.smallerNumbersThanCurrent([7,7,7,7]), [0,0,0,0]) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func smallerNumbersThanCurrent(_ nums: [Int]) -> [Int] {\\n        var counts = Array(repeating: 0, count: 101), arr = counts, sum = 0\\n        nums.map{ counts[$0] += 1 }\\n        \\n        for i in 1...counts.count - 1 {\\n            sum += counts[i-1]\\n            arr[i] = sum\\n        }\\n        \\n        var ans = Array(repeating: 0, count: nums.count)\\n        for i in 0..<nums.count { ans[i] = arr[nums[i]]}\\n        return ans\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\n// Executed 3 tests, with 0 failures (0 unexpected) in 0.097 (0.098) seconds\\n\\nclass Tests: XCTestCase {\\n    private let s = Solution()\\n    func testExample1() {\\n        XCTAssertEqual(s.smallerNumbersThanCurrent([8,1,2,2,3]), [4,0,1,1,3]) // success\\n    }\\n    func testExample2() {\\n        XCTAssertEqual(s.smallerNumbersThanCurrent([6,5,4,8]), [2,1,0,3]) // success\\n    }\\n    func testExample3() {\\n        XCTAssertEqual(s.smallerNumbersThanCurrent([7,7,7,7]), [0,0,0,0]) // success\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 525062,
                "title": "python-extremely-simple-solution",
                "content": "```python\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        return [sorted_nums.index(num) for num in nums]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        return [sorted_nums.index(num) for num in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1269634,
                "title": "sorted-list-lookup-70-faster-python3",
                "content": "# Solution\\nThe idea is to **sort the list** and **use the sorted list for an index look-up**.\\n```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        larger_nums = []\\n        for num in nums:\\n            larger_nums.append(sorted_nums.index(num))\\n        return larger_nums\\n```\\n\\n# Simple Explanation:\\n\\nSort `nums` and store the sorted list to `sorted_nums`. For example: \\n```\\nnums = [8,1,2,2,3]\\nsorted_nums = sorted(nums)\\n# [1, 2, 2, 3, 8]\\n```\\n\\n\\nIterate through `nums`, and search the index of `num` from `sorted_list`. \\n\\nThe index of `num` indicates how many numbers are smaller than itself.\\n\\nFor example on the **first iteration**:\\n```\\n# nums = [8,1,2,2,3]\\nfor num in nums:\\n\\t# num = 8\\n\\tsorted_nums.index(num) # 4\\n```\\n\\n**second iteration**:\\n```\\n# nums = [8,1,2,2,3]\\nfor num in nums:\\n\\t# num = 1\\n\\tsorted_nums.index(num) # 0\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        larger_nums = []\\n        for num in nums:\\n            larger_nums.append(sorted_nums.index(num))\\n        return larger_nums\\n```\n```\\nnums = [8,1,2,2,3]\\nsorted_nums = sorted(nums)\\n# [1, 2, 2, 3, 8]\\n```\n```\\n# nums = [8,1,2,2,3]\\nfor num in nums:\\n\\t# num = 8\\n\\tsorted_nums.index(num) # 4\\n```\n```\\n# nums = [8,1,2,2,3]\\nfor num in nums:\\n\\t# num = 1\\n\\tsorted_nums.index(num) # 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1191556,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] result = new int[nums.length];\\n       int[] temp = new int[101];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            temp[nums[i]]++;\\n        }\\n        \\n        for (int i = 1; i < 101; i++) {\\n            temp[i] += temp[i-1];\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 0) {\\n                result[i] = 0;\\n            } else {\\n                result[i] = temp[nums[i] - 1];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] result = new int[nums.length];\\n       int[] temp = new int[101];\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            temp[nums[i]]++;\\n        }\\n        \\n        for (int i = 1; i < 101; i++) {\\n            temp[i] += temp[i-1];\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            if(nums[i] == 0) {\\n                result[i] = 0;\\n            } else {\\n                result[i] = temp[nums[i] - 1];\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1144363,
                "title": "javascript-faster-than-97-88-and-less-than-94-41",
                "content": "Sort the array in asceding order and use the position in the sorted array to determine how many numbers in the array are smaller than it.\\n\\t\\n\\tconst sorted = [...nums].sort((a, b) => a - b);\\n\\n    return nums.map((value) => sorted.indexOf(value));",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "Sort the array in asceding order and use the position in the sorted array to determine how many numbers in the array are smaller than it.\\n\\t\\n\\tconst sorted = [...nums].sort((a, b) => a - b);\\n\\n    return nums.map((value) => sorted.indexOf(value));",
                "codeTag": "Unknown"
            },
            {
                "id": 931357,
                "title": "c-sorting-vs-non-sorting-solution-compared-and-explained-100-time-75-space",
                "content": "So, my first approach was to work on sorted elements.\\n\\nTo do so, I needed a few extra variables:\\n* `len` will store the length of our input;\\n* `res` will storet the final result and we can set it to be `len` long from the beginning, to avoid expensive reallocations;\\n* `copyV` will initially mirror the content of `nums`.\\n\\nWe will then sort `copyV` and proceed to search each element of `nums`, iterating with a pointer `i` through it.\\n\\nFor each number so parsed, we will set `res[i]` to be equal of the value position said element has in the freshly sorted `copyV` - no need to go linear here, since we know that sorted data structures are the ideal ground for a healthy binary search and, to be more specific, we will go with `lower_bound` that does all the work for us, right out of the box.\\n\\nOnce we are done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size();\\n        vector<int> res(len), copyV(nums);\\n        // reading copyV to be binary-searched\\n        sort(begin(copyV), end(copyV));\\n        for (int i = 0; i < len; i++) {\\n            res[i] = lower_bound(begin(copyV), end(copyV), nums[i]) - begin(copyV);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nThen I had another idea: storing the frequency of each element (we know they are rather limited, going only up to `100`) and then progressing in a similar fashion to the previous problem.\\n\\nOur initial variables are almost the same, we just drop `copyV` and use instead the int array `freqs` set to be `101` elements long, with all the values initialised to `0`.\\n\\nWe do one first pass through `nums` to store/update each frequency in `res`.\\n\\nA second pass will have populate `res`, assigning to its `i`th value the cumulative sum of all the first `nums[i]` values.\\n\\nOnce done, we can return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), freqs[101] = {};\\n        vector<int> res(len);\\n        // populating freqs\\n        for (int n: nums) freqs[n]++;\\n        for (int i = 0; i < len; i++) {\\n            res[i] = accumulate(freqs, freqs + nums[i], 0);\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\nAnd then I realised we were doing the same stuff potentially over and over again, while a nice DP approach would work better, so I refactored the computing part, leaving accumulate on the ground.\\n\\nThe logic is the same as the previous, but we just turn turn `freqs` into a cumulative set of frequencies, up to that point included.\\n\\nFor this reason, the frequency of all the smaller elements before `n` is now `freqs[n - 1]` - or just `0` for `n == 0`, since we are assured by the requirements that we cannot have any element smaller than that.\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), freqs[101] = {}, maxV = 0;\\n        vector<int> res(len);\\n        // populating freqs, updating maxV\\n        for (int n: nums) {\\n            freqs[n]++;\\n            maxV = max(maxV, n);\\n        }\\n        // turning freqs into a table of cumulative frequencies\\n        for (int i = 1; i <= maxV; i++) freqs[i] += freqs[i - 1];\\n        for (int i = 0; i < len; i++) {\\n            res[i] = nums[i] ? freqs[nums[i] - 1] : 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Binary Tree",
                    "Counting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size();\\n        vector<int> res(len), copyV(nums);\\n        // reading copyV to be binary-searched\\n        sort(begin(copyV), end(copyV));\\n        for (int i = 0; i < len; i++) {\\n            res[i] = lower_bound(begin(copyV), end(copyV), nums[i]) - begin(copyV);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), freqs[101] = {};\\n        vector<int> res(len);\\n        // populating freqs\\n        for (int n: nums) freqs[n]++;\\n        for (int i = 0; i < len; i++) {\\n            res[i] = accumulate(freqs, freqs + nums[i], 0);\\n        }\\n        return res;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        // support variables\\n        int len = nums.size(), freqs[101] = {}, maxV = 0;\\n        vector<int> res(len);\\n        // populating freqs, updating maxV\\n        for (int n: nums) {\\n            freqs[n]++;\\n            maxV = max(maxV, n);\\n        }\\n        // turning freqs into a table of cumulative frequencies\\n        for (int i = 1; i <= maxV; i++) freqs[i] += freqs[i - 1];\\n        for (int i = 0; i < len; i++) {\\n            res[i] = nums[i] ? freqs[nums[i] - 1] : 0;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 623050,
                "title": "one-line-javascript-solution",
                "content": "> Runtime: 68 ms, faster than 95.48% of JavaScript online submissions for How Many Numbers Are Smaller Than the Current Number.\\nMemory Usage: 36.1 MB, less than 100.00% of JavaScript online submissions for How Many Numbers Are Smaller Than the Current Number.\\n```js\\nvar smallerNumbersThanCurrent = function(nums) {\\n    return nums.map((numa, i) => nums.reduce((total, numb,ii)=> numa>numb ? total+1 : total, 0))\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nvar smallerNumbersThanCurrent = function(nums) {\\n    return nums.map((numa, i) => nums.reduce((total, numb,ii)=> numa>numb ? total+1 : total, 0))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 528560,
                "title": "100-memory-javascript-solution-with-explanation",
                "content": "First off, a simple brute force approach would be something like this:\\n\\n```\\nconst smallerNumbersThanCurrent = (arr) => {\\n\\tconst resultArray = [];\\n\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\tlet counter = 0;\\n\\t\\tfor (let j = 0; j < arr.length; j++) {\\n\\t\\t\\tif (arr[i] > arr[j]) {\\n\\t\\t\\t\\tcounter++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresultArray.push(counter);\\n\\t}\\n\\treturn resultArray;\\n}\\n```\\n\\nWe\\u2019re using nested ```for``` loops to compare each item in the array to the rest of the items in the array. Since we\\u2019re iterating over the entire array with each comparison, that gives us an ```O(n^2)``` time complexity (not great).\\n\\nHowever, a better solution can be found by taking advantage of sorting and a few built-in JavaScript methods. If you have a number ```n``` in a sorted copy of an array, you know that everything to the left of ```n``` will be lower than it. So conveniently enough, you can just take the index of ```n``` in the sorted array and that will be the number of items that are less than it, and thus the number that should be pushed to the result array.\\n\\n```\\nconst smallerNumbersThanCurrent = (arr) => {\\n\\tconst result = [];\\n\\tconst unsortedArr = [...arr];\\n\\tarr.sort((a, b) => a - b);\\n\\tfor (let i = 0; i < unsortedArr.length; i++) {\\n\\t\\tresult.push(arr.indexOf(unsortedArr[i]));\\n\\t}\\n\\treturn result;\\n}\\n```\\n\\nSince ```.sort()``` is implemented differently on different browsers, its time complexity can\\u2019t be guaranteed. However, the big O of the function as a whole would be ```O(n)```, a considerable improvement over the quadratic ```O(n^2)``` from the brute force approach.\\n\\n----------------\\n\\n*3/18/21 edit:* Looking back at this, it would be a much better idea to copy the `arr` parameter to a `sortedArr` variable and sort that instead:\\n```\\nconst sortedArr = [...arr];\\nsortedArr.sort((a, b) => a - b);\\n```\\nYou can then swap out the `for` loop variables accordingly. JavaScript uses call by sharing, so `arr` stores a reference to the array object that\\'s passed in and the previous solution will sort that external array object, causing an unwanted side effect.",
                "solutionTags": [],
                "code": "```\\nconst smallerNumbersThanCurrent = (arr) => {\\n\\tconst resultArray = [];\\n\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\tlet counter = 0;\\n\\t\\tfor (let j = 0; j < arr.length; j++) {\\n\\t\\t\\tif (arr[i] > arr[j]) {\\n\\t\\t\\t\\tcounter++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresultArray.push(counter);\\n\\t}\\n\\treturn resultArray;\\n}\\n```\n```for```\n```O(n^2)```\n```n```\n```n```\n```n```\n```\\nconst smallerNumbersThanCurrent = (arr) => {\\n\\tconst result = [];\\n\\tconst unsortedArr = [...arr];\\n\\tarr.sort((a, b) => a - b);\\n\\tfor (let i = 0; i < unsortedArr.length; i++) {\\n\\t\\tresult.push(arr.indexOf(unsortedArr[i]));\\n\\t}\\n\\treturn result;\\n}\\n```\n```.sort()```\n```O(n)```\n```O(n^2)```\n```\\nconst sortedArr = [...arr];\\nsortedArr.sort((a, b) => a - b);\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 526393,
                "title": "c-dictionary-array-indexof-counting-sort",
                "content": "**Dictionary**\\n```\\npublic class Solution {\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n      \\n        // Sort nums\\n        int[] res = new int[nums.Length];                  \\n        int[] sortNums = (int[])nums.Clone();\\n        Array.Sort(sortNums);\\n        \\n        /* \\n\\t\\t    For each key-value pair, key is the number, value is number\\'s index of the sorted array.\\n\\t\\t    The smaller number count of a given number (Key) is its Value.\\n\\t\\t*/\\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        for(int i = 0; i < sortNums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(sortNums[i]))\\n                dic.Add(sortNums[i], i);\\n        }\\n        \\n        for(int j = 0; j < res.Length; j++)\\n            res[j] = dic[nums[j]];\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Array.IndexOf()**\\nSame idea as the dictionary solution. Instead of using a dictionary to store the indexes, this solution will get the index from sorted array directly by using Array.IndexOf().\\n```\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n        \\n        int[] sortedNums = (int[])nums.Clone();\\n        Array.Sort(sortedNums);\\n        \\n        for(int j = 0; j < nums.Length; j++)\\n        {\\n            nums[j] = Array.IndexOf(sortedNums, nums[j]);\\n        }\\n        \\n        return nums;\\n    }\\n```\\n\\n**Counting Sort 1**\\n```\\npublic class Solution {\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n        \\n        int[] res = new int[nums.Length];  \\n        \\n        /* \\n\\t\\t   Count the occurence of each number in nums[]. \\n           Hashing the nums to the indexes of freq[].\\n           E.g., nums[] = [8, 1, 2, 2, 3]\\n                 freq[] = [0, 1, 2, 1, 0, 0, 0, 0, 1]\\n        */\\n        int[] freq = new int[101];\\n        foreach(int num in nums)\\n            freq[num]++;\\n        \\n        /*\\n\\t\\t    Count how many numbers are smaller than nums[i]     \\n         E.g.,     freq[] = [0, 1, 2, 1, 0, 0, 0, 0, 1]\\n                ==>freq[] = [0, 1, 3, 4, 4, 4, 4, 4, 5]\\n        */                               \\n        for(int i = 1; i < freq.Length; i++)\\n            freq[i] += freq[i - 1];\\n        \\n        /* Fill in res[] E.g., the smaller number count of 8 is freq[7]*/\\n        for(int j = 0; j < res.Length; j++)\\n        {\\n            if(nums[j] == 0)\\n                 res[j] = 0;\\n            else\\n                res[j] = freq[nums[j] - 1];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n**Counting Sort 2**\\n```\\npublic class Solution {\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return nums;\\n        \\n        int k = nums.Max();        \\n        int[] count = new int[k + 1];\\n        foreach(int num in nums)\\n            count[num]++;\\n        \\n        for(int i = 1; i < count.Length; i++)\\n            count[i] += count[i-1];\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            nums[i] = (nums[i] == 0)? 0 : count[nums[i] - 1];\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n      \\n        // Sort nums\\n        int[] res = new int[nums.Length];                  \\n        int[] sortNums = (int[])nums.Clone();\\n        Array.Sort(sortNums);\\n        \\n        /* \\n\\t\\t    For each key-value pair, key is the number, value is number\\'s index of the sorted array.\\n\\t\\t    The smaller number count of a given number (Key) is its Value.\\n\\t\\t*/\\n        Dictionary<int,int> dic = new Dictionary<int,int>();\\n        for(int i = 0; i < sortNums.Length; i++)\\n        {\\n            if(!dic.ContainsKey(sortNums[i]))\\n                dic.Add(sortNums[i], i);\\n        }\\n        \\n        for(int j = 0; j < res.Length; j++)\\n            res[j] = dic[nums[j]];\\n        \\n        return res;\\n    }\\n}\\n```\n```\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n        \\n        int[] sortedNums = (int[])nums.Clone();\\n        Array.Sort(sortedNums);\\n        \\n        for(int j = 0; j < nums.Length; j++)\\n        {\\n            nums[j] = Array.IndexOf(sortedNums, nums[j]);\\n        }\\n        \\n        return nums;\\n    }\\n```\n```\\npublic class Solution {\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n        \\n        int[] res = new int[nums.Length];  \\n        \\n        /* \\n\\t\\t   Count the occurence of each number in nums[]. \\n           Hashing the nums to the indexes of freq[].\\n           E.g., nums[] = [8, 1, 2, 2, 3]\\n                 freq[] = [0, 1, 2, 1, 0, 0, 0, 0, 1]\\n        */\\n        int[] freq = new int[101];\\n        foreach(int num in nums)\\n            freq[num]++;\\n        \\n        /*\\n\\t\\t    Count how many numbers are smaller than nums[i]     \\n         E.g.,     freq[] = [0, 1, 2, 1, 0, 0, 0, 0, 1]\\n                ==>freq[] = [0, 1, 3, 4, 4, 4, 4, 4, 5]\\n        */                               \\n        for(int i = 1; i < freq.Length; i++)\\n            freq[i] += freq[i - 1];\\n        \\n        /* Fill in res[] E.g., the smaller number count of 8 is freq[7]*/\\n        for(int j = 0; j < res.Length; j++)\\n        {\\n            if(nums[j] == 0)\\n                 res[j] = 0;\\n            else\\n                res[j] = freq[nums[j] - 1];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int[] SmallerNumbersThanCurrent(int[] nums) {\\n        \\n        if(nums == null || nums.Length == 0)\\n            return nums;\\n        \\n        int k = nums.Max();        \\n        int[] count = new int[k + 1];\\n        foreach(int num in nums)\\n            count[num]++;\\n        \\n        for(int i = 1; i < count.Length; i++)\\n            count[i] += count[i-1];\\n        \\n        for(int i = 0; i < nums.Length; i++)\\n        {\\n            nums[i] = (nums[i] == 0)? 0 : count[nums[i] - 1];\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3349424,
                "title": "100-beats-accepted-short-simple-best-method-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nBotirjon Shokirov\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis solution first creates an array counts of size 101 (the maximum value of a number in the input array is 100), initializes all its elements to 0, and then counts the number of occurrences of each number in the input array. Then, it calculates the running total of counts in counts, and uses the running total to determine the number of smaller numbers for each element in the input array.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const counts = new Array(101).fill(0);\\n    nums.forEach(num => counts[num]++);\\n    \\n    let prevCount = 0;\\n    for (let i = 0; i < counts.length; i++) {\\n        const count = counts[i];\\n        counts[i] = prevCount;\\n        prevCount += count;\\n    }\\n    \\n    return nums.map(num => counts[num]);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const counts = new Array(101).fill(0);\\n    nums.forEach(num => counts[num]++);\\n    \\n    let prevCount = 0;\\n    for (let i = 0; i < counts.length; i++) {\\n        const count = counts[i];\\n        counts[i] = prevCount;\\n        prevCount += count;\\n    }\\n    \\n    return nums.map(num => counts[num]);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2203191,
                "title": "click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n",
                "content": "## // **Using Hashtable in O(n)**\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n            int count[101]={0};\\n            vector<int> vec;\\n            for(int i = 0 ; i < nums.size() ; i++){\\n                count[nums[i]]++;\\n            }\\n            for(int i = 1 ; i < 101 ; i++){\\n                count[i]+=count[i-1];\\n            }\\n            for(int i = 0 ; i < nums.size() ; i++){\\n                if(nums[i] == 0)\\n                    vec.emplace_back(0);\\n                else {\\n                    vec.emplace_back(count[nums[i] - 1]);\\n            }\\n        }\\n      return vec;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n            int count[101]={0};\\n            vector<int> vec;\\n            for(int i = 0 ; i < nums.size() ; i++){\\n                count[nums[i]]++;\\n            }\\n            for(int i = 1 ; i < 101 ; i++){\\n                count[i]+=count[i-1];\\n            }\\n            for(int i = 0 ; i < nums.size() ; i++){\\n                if(nums[i] == 0)\\n                    vec.emplace_back(0);\\n                else {\\n                    vec.emplace_back(count[nums[i] - 1]);\\n            }\\n        }\\n      return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1095467,
                "title": "rust-clean-and-functional-one-liner-0ms-2-2-mb",
                "content": "```\\nimpl Solution {\\n    pub fn smaller_numbers_than_current(nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter()\\n            .map(|i| nums.iter().filter(|j| *j < &i).count() as i32)\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn smaller_numbers_than_current(nums: Vec<i32>) -> Vec<i32> {\\n        nums.iter()\\n            .map(|i| nums.iter().filter(|j| *j < &i).count() as i32)\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 690921,
                "title": "python3-2-line-simple-solution",
                "content": "```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        x = sorted(nums)\\n        return [x.index(i) for i in nums]\\n```",
                "solutionTags": [],
                "code": "```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        x = sorted(nums)\\n        return [x.index(i) for i in nums]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 642803,
                "title": "javascript-map-reduce",
                "content": "```\\nvar smallerNumbersThanCurrent = function (nums) {\\n    return nums.map(n => nums.reduce((a, b) => a + (n > b ? 1 : 0), 0))\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar smallerNumbersThanCurrent = function (nums) {\\n    return nums.map(n => nums.reduce((a, b) => a + (n > b ? 1 : 0), 0))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 567290,
                "title": "my-python-solution",
                "content": "Runtime: 116 ms, faster than 46.89% of Python3 online submissions for How Many Numbers Are Smaller Than the Current Number.\\nMemory Usage: 13.8 MB, less than 100.00% of Python3 online submissions for How Many Numbers Are Smaller Than the Current Number.\\n\\nMight not be answer for interview question since may be asked to implement sort function and index function again. \\n\\n```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        cp = sorted(nums)\\n        ret = []\\n        for i in nums:\\n            ret.append(cp.index(i))\\n        return ret\\n```",
                "solutionTags": [],
                "code": "```\\ndef smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        cp = sorted(nums)\\n        ret = []\\n        for i in nums:\\n            ret.append(cp.index(i))\\n        return ret\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 530742,
                "title": "c-prefix-sum-8ms-99-64",
                "content": "# Possible Algorithms and Their Complexity\\n## Algorithm 0:\\nfor i in nums\\n  for j in nums, j != i: out[j] +=1 if nums[j] < nums[i]\\n* O(n^2)\\n  \\n## Algorithm 1:\\nCopy array.\\nSort Array.\\nloop over nums incing a count of run length.\\n  when a new run starts add the run length to a total count\\n  and reset run to 1.\\n  for each element in run, set the output element to the total count.\\nO(n log n) (std::sort) or O(n) (counting or radix sort)\\n\\n## Algorithm 2:\\narray of counts\\nfor each in num, inc count of its value.\\nfor each in side array, prefix sum.\\nfor each in nums, copy prefix sum out of side array.\\nO(n + 101) == O(n)\\n\\n# Code\\n## Algorithm 2 Implementation\\n```c++\\nnamespace\\n{\\n    class Solution {\\n    public:\\n       static vector<int> smallerNumbersThanCurrent(const vector<int>& nums);  \\n    };\\n\\n    // Algorithm 2 implementation:\\n    vector<int> Solution::smallerNumbersThanCurrent(const vector<int>& nums)\\n    {\\n        // Work out how many of each value there are:\\n       uint16_t val_counts[101] {0};\\n        for(auto& num : nums){\\n            val_counts[num] += 1u;\\n        }\\n        \\n        // prefix sum the values:\\n        unsigned sum = 0;\\n        for(unsigned i = 0; i < 101; ++i){\\n            const unsigned val = val_counts[i];\\n            val_counts[i] = sum;\\n            sum += val;\\n        }\\n        \\n        // Let\\'s run through the input again lookup the number of\\n        // elements less than it in the table we just made:\\n        vector<int> counts(nums.size());\\n        for(unsigned i = 0, end = nums.size(); i < end; ++i)\\n        {\\n            counts[i] = val_counts[nums[i]];\\n        }\\n        return counts;\\n    }\\n    \\n    static const auto fast=[](){ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return nullptr;}();\\n\\n}\\n```\\n\\n# Results\\nAlgorithm 2 Best Submission:\\n>Runtime: 8 ms, faster than 99.64% of C++ online submissions for How Many Numbers Are Smaller Than the Current Number.\\n>Memory Usage: 8.6 MB, less than 100.00% of C++ online submissions for How Many Numbers Are Smaller Than the Current Number.\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```c++\\nnamespace\\n{\\n    class Solution {\\n    public:\\n       static vector<int> smallerNumbersThanCurrent(const vector<int>& nums);  \\n    };\\n\\n    // Algorithm 2 implementation:\\n    vector<int> Solution::smallerNumbersThanCurrent(const vector<int>& nums)\\n    {\\n        // Work out how many of each value there are:\\n       uint16_t val_counts[101] {0};\\n        for(auto& num : nums){\\n            val_counts[num] += 1u;\\n        }\\n        \\n        // prefix sum the values:\\n        unsigned sum = 0;\\n        for(unsigned i = 0; i < 101; ++i){\\n            const unsigned val = val_counts[i];\\n            val_counts[i] = sum;\\n            sum += val;\\n        }\\n        \\n        // Let\\'s run through the input again lookup the number of\\n        // elements less than it in the table we just made:\\n        vector<int> counts(nums.size());\\n        for(unsigned i = 0, end = nums.size(); i < end; ++i)\\n        {\\n            counts[i] = val_counts[nums[i]];\\n        }\\n        return counts;\\n    }\\n    \\n    static const auto fast=[](){ios_base::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return nullptr;}();\\n\\n}\\n```",
                "codeTag": "C++"
            },
            {
                "id": 525326,
                "title": "c-solution",
                "content": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize){\\n    \\n    int *answer = (int *)malloc(sizeof(int) * numsSize); \\n    int i = 0, j = 0;\\n    \\n    *returnSize = numsSize;\\n    \\n    for(i=0; i<numsSize; i++) {\\n        answer[i] = 0;\\n    }\\n       \\n\\n    for(i=0; i<numsSize; i++) {\\n        for(j=i+1; j<numsSize; j++) {\\n            if(nums[i] > nums[j]) {\\n                answer[i]++;\\n            }\\n            else if(nums[i] < nums[j]) {\\n                answer[j]++;\\n            }\\n        }\\n    }   \\n    \\n    return answer;\\n}\\n```\\n\\nNote: malloc memory on Leetcode will lead unexpectbale integer like -152152424 .... , so we need to initialize the answer array(or you can use calloc)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Note: The returned array must be malloced, assume caller calls free().\\n */\\nint* smallerNumbersThanCurrent(int* nums, int numsSize, int* returnSize){\\n    \\n    int *answer = (int *)malloc(sizeof(int) * numsSize); \\n    int i = 0, j = 0;\\n    \\n    *returnSize = numsSize;\\n    \\n    for(i=0; i<numsSize; i++) {\\n        answer[i] = 0;\\n    }\\n       \\n\\n    for(i=0; i<numsSize; i++) {\\n        for(j=i+1; j<numsSize; j++) {\\n            if(nums[i] > nums[j]) {\\n                answer[i]++;\\n            }\\n            else if(nums[i] < nums[j]) {\\n                answer[j]++;\\n            }\\n        }\\n    }   \\n    \\n    return answer;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 524927,
                "title": "java-100-runtime-solution",
                "content": "```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] numsCopy = Arrays.copyOf(nums, nums.length);\\n        Arrays.sort(numsCopy);\\n        int[] res = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            res[i] = binarySearch(numsCopy, nums[i]);\\n        }\\n        return res;\\n    }\\n    private int binarySearch(int[] nums, int target) {\\n        int l = 0, r = nums.length - 1;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] < target) l = mid + 1;\\n            else r = mid;\\n        }\\n        return l;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] numsCopy = Arrays.copyOf(nums, nums.length);\\n        Arrays.sort(numsCopy);\\n        int[] res = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++) {\\n            res[i] = binarySearch(numsCopy, nums[i]);\\n        }\\n        return res;\\n    }\\n    private int binarySearch(int[] nums, int target) {\\n        int l = 0, r = nums.length - 1;\\n        while (l < r) {\\n            int mid = l + (r - l) / 2;\\n            if (nums[mid] < target) l = mid + 1;\\n            else r = mid;\\n        }\\n        return l;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3784618,
                "title": "2-c-solutions-o-n-time-complexity-sort-and-hash-table-beats-100",
                "content": "# Code\\n```\\n// Solution 1 (brute force O(N^2) time complexity)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto i: nums){\\n            int count = 0;\\n            for(auto j : nums){\\n                if(i>j)\\n                    count++;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n};\\n\\n// Solution 2 : Time complexity = O(N) (Unordered_map / Sort)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans = nums;\\n        unordered_map<int, int> m;\\n        sort(ans.begin(), ans.end());\\n        for(int i=nums.size()-1; i>=0; i--)\\n            m[ans[i]] = i;\\n        for(int i=0; i<nums.size(); i++)\\n            nums[i] = m[nums[i]];\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\n// Solution 1 (brute force O(N^2) time complexity)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        for(auto i: nums){\\n            int count = 0;\\n            for(auto j : nums){\\n                if(i>j)\\n                    count++;\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n};\\n\\n// Solution 2 : Time complexity = O(N) (Unordered_map / Sort)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans = nums;\\n        unordered_map<int, int> m;\\n        sort(ans.begin(), ans.end());\\n        for(int i=nums.size()-1; i>=0; i--)\\n            m[ans[i]] = i;\\n        for(int i=0; i<nums.size(); i++)\\n            nums[i] = m[nums[i]];\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3451659,
                "title": "easy-java-solution-for-smaller-numbers-than-current-number",
                "content": "\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int temp = 0, size = nums.length;\\n        int[] result = new int[size];\\n\\n        for(int i = 0; i < size; i++){\\n            for(int j = 0; j < size; j++){\\n                if(i != j){\\n                    if(nums[i] > nums[j]){\\n                        temp++;\\n                    }\\n                }\\n            }\\n            result[i] = temp;\\n            temp = 0;\\n        }\\n\\n        return result;\\n    }\\n}\\n```\\nPlease upvote me, it encourages me a lot!!",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int temp = 0, size = nums.length;\\n        int[] result = new int[size];\\n\\n        for(int i = 0; i < size; i++){\\n            for(int j = 0; j < size; j++){\\n                if(i != j){\\n                    if(nums[i] > nums[j]){\\n                        temp++;\\n                    }\\n                }\\n            }\\n            result[i] = temp;\\n            temp = 0;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1322900,
                "title": "c-95-faster-98-smaller",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> sorted = nums;\\n        sort(sorted.begin(), sorted.end());\\n        \\n        for(int& num : nums)\\n        {\\n            num = lower_bound(sorted.begin(), sorted.end(), num) - sorted.begin();\\n        }\\n        return nums;\\n    }\\n};\\n\\n```\\n\\n\\n** Uses search method from STL.",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> sorted = nums;\\n        sort(sorted.begin(), sorted.end());\\n        \\n        for(int& num : nums)\\n        {\\n            num = lower_bound(sorted.begin(), sorted.end(), num) - sorted.begin();\\n        }\\n        return nums;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1127479,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> v;\\n        int maxi;\\n        for(int i=0;i<nums.size();i++){\\n            maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(j != i and nums[j] < nums[i])\\n                    maxi++;\\n            }\\n            v.push_back(maxi);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> v;\\n        int maxi;\\n        for(int i=0;i<nums.size();i++){\\n            maxi=0;\\n            for(int j=0;j<nums.size();j++){\\n                if(j != i and nums[j] < nums[i])\\n                    maxi++;\\n            }\\n            v.push_back(maxi);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 936122,
                "title": "python-40ms-faster-than-99-64",
                "content": "```\\n        dic1 = {}\\n        nums1 = sorted(nums, reverse=True)\\n        for index in range(0, len(nums1) - 1):\\n            if nums1[index] == nums1[index + 1]:\\n                continue\\n            dic1[nums1[index]] = len(nums1) - index -1    \\n        dic1[nums1[-1]] = 0\\n        return([dic1[x] for x in nums])\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n        dic1 = {}\\n        nums1 = sorted(nums, reverse=True)\\n        for index in range(0, len(nums1) - 1):\\n            if nums1[index] == nums1[index + 1]:\\n                continue\\n            dic1[nums1[index]] = len(nums1) - index -1    \\n        dic1[nums1[-1]] = 0\\n        return([dic1[x] for x in nums])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 653879,
                "title": "java-o-n-solution-99-3-runtime-100-memory",
                "content": "Solution is based on counting frequency of the elements in array.\\nAfter creating the frequency array, add the frequencies together like prefix sum.\\nNow, your **array is increasing by total number of entries** before the current entry. Simple logic to find how many numbers smaller than the current num in array is\\n``` \\nif array entry is 0: (there would be no element before 0) simply assign 0 here\\nelse assign previous entry from the array.\\n```\\nFor eg. if the given array is **[8, 1, 0, 2, 2, 3, 0]**\\nafter frequency count and prefix addition, the frequency array would become\\n**[0, 1, 3, 4, 4, 4, 4, 4, 5, 5, 5, ...]** (all next entries would be 5)\\nhow many elements before 2 you would ask. it\\'s nums[2 - 1] = 1 in array. before 3, it\\'s nums[3 - 1] = 3.\\n\\n```java\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] freq = new int[101];\\n    \\n    for (int num: nums) {\\n      freq[num]++;\\n    }\\n\\n    int total = 0;\\n    for (int i = 1; i < freq.length; i++) {\\n      freq[i] += freq[i - 1];\\n    }\\n        \\n    int[] ans = new int[nums.length];\\n    \\n    for (int i = 0; i < nums.length; i++) {\\n      if (nums[i] != 0)\\n        ans[i] = freq[nums[i] - 1];\\n      else \\n        ans[i] = 0;\\n    }\\n    \\n    \\n    return ans;\\n  }\\n```",
                "solutionTags": [],
                "code": "``` \\nif array entry is 0: (there would be no element before 0) simply assign 0 here\\nelse assign previous entry from the array.\\n```\n```java\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] freq = new int[101];\\n    \\n    for (int num: nums) {\\n      freq[num]++;\\n    }\\n\\n    int total = 0;\\n    for (int i = 1; i < freq.length; i++) {\\n      freq[i] += freq[i - 1];\\n    }\\n        \\n    int[] ans = new int[nums.length];\\n    \\n    for (int i = 0; i < nums.length; i++) {\\n      if (nums[i] != 0)\\n        ans[i] = freq[nums[i] - 1];\\n      else \\n        ans[i] = 0;\\n    }\\n    \\n    \\n    return ans;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525274,
                "title": "c-o-n-o-102-use-constraints-0-100",
                "content": "Known: Range for number is [0,100].\\n\\n0. Need a count table of size 101.\\n1. `F(n+1) = sum(cnt[0...n])`, hence mapping [0,100] to [1,101] to store counts less than current.\\n2. Use the count table as a dp and update rolling counts `cnt[n\\'] = sum(cnt[0...n]) = cnt[n]+cnt[(n-1)\\']`.\\n3. Replace original number in array with counts less than it.\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> cnt(102, 0);\\n        for(auto n : nums) {\\n            ++cnt[n+1]; // e.g. for n = 1, it\\'s valid for cnt[2+] but not for cnt[1]\\n        }\\n        for(int i = 1; i < cnt.size(); ++i) {\\n            cnt[i] += cnt[i-1]; // rolling counts\\n        }\\n        for(auto& n : nums) {\\n            n = cnt[n]; // replace with counts\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> cnt(102, 0);\\n        for(auto n : nums) {\\n            ++cnt[n+1]; // e.g. for n = 1, it\\'s valid for cnt[2+] but not for cnt[1]\\n        }\\n        for(int i = 1; i < cnt.size(); ++i) {\\n            cnt[i] += cnt[i-1]; // rolling counts\\n        }\\n        for(auto& n : nums) {\\n            n = cnt[n]; // replace with counts\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1863223,
                "title": "python-solution-faster-than-86",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sort_nums = sorted(nums)\\n        res = []\\n        for i in nums:\\n            res.append(sort_nums.index(i))\\n        return res",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sort_nums = sorted(nums)\\n        res = []\\n        for i in nums:\\n            res.append(sort_nums.index(i))\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1425585,
                "title": "c-hashmap-sol-how-many-numbers-are-smaller-than-the-current-number",
                "content": "```\\nclass Solution {            //0(nlogn)\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n      unordered_map<int, int > map;\\n      vector<int> v(nums);     //[8,1,2,2,3]  copy of nums array\\n      \\n      sort(v.begin(), v.end());  //[1,2,2,3,8]  \\n      \\n      for(int i = 0; i<v.size() ; i++)    \\n      {\\n          //map[v[i]] = i;   can\\'t use this  bcz of duplicate elements//\\n          map.insert({v[i], i});\\n      }\\n\\t  //map[1]=>0  \\n\\t  //map[2]=>1  \\n\\t  //map[2]=>1  \\n\\t  //map[3]=>3  \\n\\t  //map[8]=>4\\n      \\n\\t  for(int i =0 ; i< nums.size(); i++)\\n      {\\n         v[i] = map[nums[i]];    // simply iterate original array, and get counts from the map.\\n      }\\n      return v;     //[4,0,1,1,3]\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {            //0(nlogn)\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n      unordered_map<int, int > map;\\n      vector<int> v(nums);     //[8,1,2,2,3]  copy of nums array\\n      \\n      sort(v.begin(), v.end());  //[1,2,2,3,8]  \\n      \\n      for(int i = 0; i<v.size() ; i++)    \\n      {\\n          //map[v[i]] = i;   can\\'t use this  bcz of duplicate elements//\\n          map.insert({v[i], i});\\n      }\\n\\t  //map[1]=>0  \\n\\t  //map[2]=>1  \\n\\t  //map[2]=>1  \\n\\t  //map[3]=>3  \\n\\t  //map[8]=>4\\n      \\n\\t  for(int i =0 ; i< nums.size(); i++)\\n      {\\n         v[i] = map[nums[i]];    // simply iterate original array, and get counts from the map.\\n      }\\n      return v;     //[4,0,1,1,3]\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1412772,
                "title": "both-o-n-2-and-o-n-check-it-well-expend-1-ms-faster-than-97-06-of-java-online",
                "content": "o(n2) Solution\\n```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]<nums[i] && i!=j)\\n                    count++;\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n```\\n\\nO(n) Solution\\nRuntime: 1 ms, faster than 97.06% of Java online submissions for How Many Numbers Are Smaller Than the Current Number.\\nMemory Usage: 38.7 MB, less than 99.37% of Java online submissions for How Many Numbers Are Smaller Than the Current Number.\\n```\\nint maxLength=101;\\n        int[] countNum=new int[maxLength];\\n        //finding the number of the digit in array\\n        for(int i=0;i<nums.length;i++){\\n            countNum[nums[i]]++;\\n        }\\n              \\n        int[] ans=new int[nums.length];\\n        int count=0,temp;\\n        for(int i=0;i<maxLength && count < nums.length ;i++){\\n            if(countNum[i] != 0){\\n                temp=countNum[i];\\n                countNum[i]=count;\\n                count+=temp;\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=countNum[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] ans=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            int count=0;\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[j]<nums[i] && i!=j)\\n                    count++;\\n            }\\n            ans[i]=count;\\n        }\\n        return ans;\\n    }\\n```\n```\\nint maxLength=101;\\n        int[] countNum=new int[maxLength];\\n        //finding the number of the digit in array\\n        for(int i=0;i<nums.length;i++){\\n            countNum[nums[i]]++;\\n        }\\n              \\n        int[] ans=new int[nums.length];\\n        int count=0,temp;\\n        for(int i=0;i<maxLength && count < nums.length ;i++){\\n            if(countNum[i] != 0){\\n                temp=countNum[i];\\n                countNum[i]=count;\\n                count+=temp;\\n            }\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            ans[i]=countNum[nums[i]];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1299219,
                "title": "javascript-hashmap-solution",
                "content": "```\\n\\tlet sortedArr = [...nums].sort((a,b)=> a-b)\\n    \\n    let hash = {}, res = []\\n    \\n    for(let i = 0; i < sortedArr.length; i++){\\n    \\tif(sortedArr[i] == sortedArr[i-1]) continue;\\n        hash[sortedArr[i]] = i\\n    }\\n    for(let i = 0; i < nums.length; i++){\\n        res[i] = hash[nums[i]]\\n    }\\n    return res\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n\\tlet sortedArr = [...nums].sort((a,b)=> a-b)\\n    \\n    let hash = {}, res = []\\n    \\n    for(let i = 0; i < sortedArr.length; i++){\\n    \\tif(sortedArr[i] == sortedArr[i-1]) continue;\\n        hash[sortedArr[i]] = i\\n    }\\n    for(let i = 0; i < nums.length; i++){\\n        res[i] = hash[nums[i]]\\n    }\\n    return res\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1144972,
                "title": "python-simple-and-easy-solution-24ms",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        abc = sorted(nums)\\n        for i in range(len(nums)):\\n            nums[i] = abc.index(nums[i])\\n            \\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        abc = sorted(nums)\\n        for i in range(len(nums)):\\n            nums[i] = abc.index(nums[i])\\n            \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007818,
                "title": "efficient-javascript-solution",
                "content": "sort array from the biggest to the smallest\\n[8,1,2,2,3] --> [8,3,2,2,1]\\n\\nnow we just locate the number we want using lastIndexOf()\\nto avoid the duplicate values\\n\\nthe amount of numbers that come after that number is the answer\\n\\nEX:\\nnum8 has 4nums after it (3,2,2,1) so the answer is 4\\nnum3 has 3nums after it (2,2,1) so the answer is 3\\nnum2 here we gonna find the second value of 2 cuz we are using lastIndexOf()\\nso the numbers that come after it is just 1 so the answer is 1\\n\\nHope You Like My Solution!\\n\\n```\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const sortedNums = [...nums].sort((a,b) => b-a),\\n          numsIndexLength = nums.length - 1;\\n    \\n    return nums.map(val => numsIndexLength - sortedNums.lastIndexOf(val));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const sortedNums = [...nums].sort((a,b) => b-a),\\n          numsIndexLength = nums.length - 1;\\n    \\n    return nums.map(val => numsIndexLength - sortedNums.lastIndexOf(val));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 919263,
                "title": "java-o-n-1ms",
                "content": "**1ms O(n) time and O(n) solution** if any question please ask.\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t\\tint[] freq = new int[101];\\n        int[] count = new int[nums.length];\\n        for(int a : nums)\\n            freq[a]++;\\n        for(int i = 1 ; i < freq.length ; i++){\\n            freq[i] += freq[i-1];\\n        }\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i]==0)continue;\\n            count[i]=freq[nums[i]-1];\\n        }\\n        return count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t\\tint[] freq = new int[101];\\n        int[] count = new int[nums.length];\\n        for(int a : nums)\\n            freq[a]++;\\n        for(int i = 1 ; i < freq.length ; i++){\\n            freq[i] += freq[i-1];\\n        }\\n        for(int i = 0 ; i < nums.length ; i++){\\n            if(nums[i]==0)continue;\\n            count[i]=freq[nums[i]-1];\\n        }\\n        return count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526874,
                "title": "c-solution-faster-than-70-using-unordered-map",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        vector<int> vec;\\n        for(auto &num:nums)\\n        {\\n            mp[num]++;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int count=0;\\n            for(auto &nn:mp)\\n                if(nn.first!=nums[i] && nn.first<=nums[i])\\n                    count+=nn.second;\\n            vec.push_back(count);\\n            \\n        }\\n        return vec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        unordered_map<int,int> mp;\\n        vector<int> vec;\\n        for(auto &num:nums)\\n        {\\n            mp[num]++;\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int count=0;\\n            for(auto &nn:mp)\\n                if(nn.first!=nums[i] && nn.first<=nums[i])\\n                    count+=nn.second;\\n            vec.push_back(count);\\n            \\n        }\\n        return vec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3446946,
                "title": "my-smallernumbersthancurrent",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity\\n- Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function (nums) {\\n  let res = [];\\n\\n  for (const i of nums) {\\n    const c = nums.reduce((count, num) => {\\n      if (num < i) count++;\\n      return count;\\n    }, 0);\\n    res.push(c);\\n  }\\n\\n  return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function (nums) {\\n  let res = [];\\n\\n  for (const i of nums) {\\n    const c = nums.reduce((count, num) => {\\n      if (num < i) count++;\\n      return count;\\n    }, 0);\\n    res.push(c);\\n  }\\n\\n  return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2938422,
                "title": "c-sort-map",
                "content": "# Intuition:         \\nPut the values in hash-map according to their values corresponding to their places in nums in reverse order.\\n \\n# Complexity:\\n- Time complexity: O(nlogn) + O(n)<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code:\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int> &nums)\\n    {\\n        vector<int> v = nums;\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        sort(v.begin(), v.end());\\n\\n        for (int i = n - 1; i >= 0; i--)\\n            mp[v[i]] = i;\\n\\n        for (int i = 0; i < n; i++)\\n            nums[i] = mp[nums[i]];\\n\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Sorting"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int> &nums)\\n    {\\n        vector<int> v = nums;\\n        int n = nums.size();\\n        unordered_map<int, int> mp;\\n        sort(v.begin(), v.end());\\n\\n        for (int i = n - 1; i >= 0; i--)\\n            mp[v[i]] = i;\\n\\n        for (int i = 0; i < n; i++)\\n            nums[i] = mp[nums[i]];\\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2429787,
                "title": "c-two-solution-o-n-easy-solution",
                "content": "**Approach 1: (Sorting) \\u2705**\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        map<int,int> mp;  // Map for storing frequencies of number less than that number\\n        int n = nums.size();\\n        \\n        vector<int> sortednum = nums;\\n        sort(sortednum.begin(),sortednum.end());\\n        \\n        //Iterating from back and assigning index of number to that number \\n        for(int i = n-1;i>=0;i--)\\n        {\\n            mp[sortednum[i]] = i;\\n        }\\n        \\n        //Assigning frequencies to each elements\\n        for(int i= 0;i<n;i++){\\n            nums[i] = mp[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n**Approach 2: (Counting)  \\u2705AC**\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;  // vector to store final answer\\n        int count[101] = {0};    // Array to store count\\n\\t\\tint len = nums.size();\\n        \\n        //Store count of each number\\n        for(int i = 0; i < len; i++) {\\n            count[nums[i]]++;\\n        }\\n        \\n        //Assigning count of smaller number to that number\\n        for(int i = 1; i < 101; i++) {\\n            count[i] += count[i - 1];\\n        }\\n        \\n        \\n        for(int i = 0; i < len; i++) {\\n            if(nums[i] == 0)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(count[nums[i] - 1]);\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        map<int,int> mp;  // Map for storing frequencies of number less than that number\\n        int n = nums.size();\\n        \\n        vector<int> sortednum = nums;\\n        sort(sortednum.begin(),sortednum.end());\\n        \\n        //Iterating from back and assigning index of number to that number \\n        for(int i = n-1;i>=0;i--)\\n        {\\n            mp[sortednum[i]] = i;\\n        }\\n        \\n        //Assigning frequencies to each elements\\n        for(int i= 0;i<n;i++){\\n            nums[i] = mp[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;  // vector to store final answer\\n        int count[101] = {0};    // Array to store count\\n\\t\\tint len = nums.size();\\n        \\n        //Store count of each number\\n        for(int i = 0; i < len; i++) {\\n            count[nums[i]]++;\\n        }\\n        \\n        //Assigning count of smaller number to that number\\n        for(int i = 1; i < 101; i++) {\\n            count[i] += count[i - 1];\\n        }\\n        \\n        \\n        for(int i = 0; i < len; i++) {\\n            if(nums[i] == 0)\\n                ans.push_back(0);\\n            else\\n                ans.push_back(count[nums[i] - 1]);\\n                \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2119776,
                "title": "python-easy-solution-with-complexities",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        \\n        nums1 = sorted(nums)            #time O(nlogn)\\n        dic = {}\\n        answer = []\\n        \\n        for i in range(0,len(nums1)):   #time O(n)\\n            if nums1[i] in dic:         #time O(1)\\n                continue\\n            else:\\n                dic[nums1[i]] = i\\n                \\n        for i in range(0,len(nums)):    #time O(n)\\n            answer.append(dic[nums[i]])\\n            \\n        return answer\\n    \\n#time O(nlogn)\\n#space O(n)\\n```\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        \\n        nums1 = sorted(nums)                    #time O(nlogn)\\n        dic = {}\\n        answer = []\\n        \\n        for index,value in enumerate(nums1):    #time O(n)\\n            dic.setdefault(value,index)\\n                \\n        for i in range(0,len(nums)):            #time O(n)\\n            answer.append(dic[nums[i]])\\n            \\n        return answer\\n    \\n#time O(nlogn)\\n#space O(n)\\n```\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        \\n        nums1 = sorted(nums)                     #time O(nlogn)\\n        dic = {}\\n        answer = []\\n        \\n        for index,value in enumerate(nums1):     #time O(n)\\n            dic.setdefault(value,index)\\n                \\n        for i in nums:                           #time O(n)\\n            answer.append(dic[i])\\n            \\n        return answer\\n    \\n#time O(nlogn)\\n#space O(n)\\n```\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\n        count = [0] * 102\\n        answer = []\\n        \\n        for num in nums:\\n            count[num+1] = count[num+1] + 1\\n            \\n        for i in range(1, 102):\\n            count[i] = count[i] + count[i-1]\\n            \\n        for num in nums:\\n            answer.append(count[num])\\n            \\n        return answer\\n    \\n#time O(n)\\n#space O(n)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        \\n        nums1 = sorted(nums)            #time O(nlogn)\\n        dic = {}\\n        answer = []\\n        \\n        for i in range(0,len(nums1)):   #time O(n)\\n            if nums1[i] in dic:         #time O(1)\\n                continue\\n            else:\\n                dic[nums1[i]] = i\\n                \\n        for i in range(0,len(nums)):    #time O(n)\\n            answer.append(dic[nums[i]])\\n            \\n        return answer\\n    \\n#time O(nlogn)\\n#space O(n)\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        \\n        nums1 = sorted(nums)                    #time O(nlogn)\\n        dic = {}\\n        answer = []\\n        \\n        for index,value in enumerate(nums1):    #time O(n)\\n            dic.setdefault(value,index)\\n                \\n        for i in range(0,len(nums)):            #time O(n)\\n            answer.append(dic[nums[i]])\\n            \\n        return answer\\n    \\n#time O(nlogn)\\n#space O(n)\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        \\n        nums1 = sorted(nums)                     #time O(nlogn)\\n        dic = {}\\n        answer = []\\n        \\n        for index,value in enumerate(nums1):     #time O(n)\\n            dic.setdefault(value,index)\\n                \\n        for i in nums:                           #time O(n)\\n            answer.append(dic[i])\\n            \\n        return answer\\n    \\n#time O(nlogn)\\n#space O(n)\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\n        count = [0] * 102\\n        answer = []\\n        \\n        for num in nums:\\n            count[num+1] = count[num+1] + 1\\n            \\n        for i in range(1, 102):\\n            count[i] = count[i] + count[i-1]\\n            \\n        for num in nums:\\n            answer.append(count[num])\\n            \\n        return answer\\n    \\n#time O(n)\\n#space O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2099284,
                "title": "java-using-hashmap-easy-to-understand",
                "content": "```\\n\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] copy = nums.clone();\\n        \\n        Arrays.sort(copy);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            map.putIfAbsent(copy[i], i);\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            copy[i] = map.get(nums[i]);\\n        }\\n        \\n        return copy;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int[] copy = nums.clone();\\n        \\n        Arrays.sort(copy);\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            map.putIfAbsent(copy[i], i);\\n        }\\n        \\n        for (int i = 0; i < nums.length; i++) {\\n            copy[i] = map.get(nums[i]);\\n        }\\n        \\n        return copy;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1616837,
                "title": "java-solution-o-n-time-complexity",
                "content": "Kindly upvote, if it helps you!\\n```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] farr = new int[101];\\n\\t\\t//count the occurence of each number\\n        for(int num: nums){\\n            farr[num]++;\\n        }\\n\\t\\t//calculate prefix sum\\n        for(int i = 1; i<farr.length; i++){\\n            farr[i] += farr[i-1];\\n        }\\n\\t\\t//number of elements smaller than that particular element \\n\\t\\t//would be the value stored at farr[nums[i]-1]\\n        for(int i= 0; i<nums.length; i++){\\n            nums[i] = nums[i]==0 ? 0 : farr[nums[i]-1];\\n        }\\n        return nums;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Kindly upvote, if it helps you!\\n```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] farr = new int[101];\\n\\t\\t//count the occurence of each number\\n        for(int num: nums){\\n            farr[num]++;\\n        }\\n\\t\\t//calculate prefix sum\\n        for(int i = 1; i<farr.length; i++){\\n            farr[i] += farr[i-1];\\n        }\\n\\t\\t//number of elements smaller than that particular element \\n\\t\\t//would be the value stored at farr[nums[i]-1]\\n        for(int i= 0; i<nums.length; i++){\\n            nums[i] = nums[i]==0 ? 0 : farr[nums[i]-1];\\n        }\\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1265695,
                "title": "2-solutions-in-java-with-explanation",
                "content": "## Brute force\\nThat\\'s super simple, loop through the array and for each value, search the array again, excluding the current value. Increment value on new array on outer index to indicate how many numbers are smaller than this number. Continue until visited each number in nums array.\\n\\nSome pseudocode to understand the solution:\\n* create a new empty array with same length as nums array\\n* loop through the nums array from i = 0 to length\\n\\t* for each value loop through the array once again (nested loop) from j = 0 to length\\n\\t\\t* if outer and inner indexes are the same continue\\n\\t\\t* if `nums[j] < nums[i]` increment cell value on new array\\n\\t\\t* return new array\\n\\nAs this is a brute force solution, the time complexity is T(N) = O(N^2)\\n```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] smallerNums = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = 0; j < nums.length; j++) {\\n                if (j == i) continue;\\n                \\n                if (nums[j] < nums[i])\\n                    smallerNums[i]++;\\n            }\\n        }\\n        \\n        return smallerNums;\\n    }\\n}\\n```\\n\\n## Improving time complexity\\nThis solution has better time complexity but it\\'s a bit more complicated.\\nFirst, you need to clone the current nums array. Then sort the cloned array.\\nAfter you sort it, loop through it and insert each value to a HashMap. Key would be the number and value will be the current index. Only put in HashMap if the key doesn\\'t exist, if it already exists, ignore and continue. Why put the index as value? This will indicate how many numbers are smaller than this number, all others, on the left handside of the array are smaller (hence they have also smaller index value).\\n\\nFinally, loop through the original nums array. For each key, retrieve it from HashMap. This is cheap operation, of O(1) complexity. Put the value from HashMap to the new array. Finally return the new array.\\n\\nThis algorithm\\'s time complexity is: O(NlogN)\\nHowever, space wise, this solution is more expensive and takes O(N) as auxiliary space is needed to create a cloned array, a hashmap and a new array to hold the result.\\n\\n```\\nimport java.util.Arrays;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {      \\n        int[] b = nums.clone();\\n        Arrays.sort(b);\\n\\t\\t\\n        HashMap<Integer, Integer> uniques = new HashMap<Integer, Integer>();\\n        for(int i = 0; i < b.length; i++) {\\n            if(!uniques.containsKey(b[i])) {\\n                uniques.put(b[i], i);\\n            }\\n        }\\n        \\n        int[] smallerNums = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            var value = uniques.get(nums[i]);\\n            smallerNums[i] = value;\\n        }\\n        return smallerNums;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.Arrays;\\n\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] smallerNums = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            for(int j = 0; j < nums.length; j++) {\\n                if (j == i) continue;\\n                \\n                if (nums[j] < nums[i])\\n                    smallerNums[i]++;\\n            }\\n        }\\n        \\n        return smallerNums;\\n    }\\n}\\n```\n```\\nimport java.util.Arrays;\\nimport java.util.HashMap;\\n\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {      \\n        int[] b = nums.clone();\\n        Arrays.sort(b);\\n\\t\\t\\n        HashMap<Integer, Integer> uniques = new HashMap<Integer, Integer>();\\n        for(int i = 0; i < b.length; i++) {\\n            if(!uniques.containsKey(b[i])) {\\n                uniques.put(b[i], i);\\n            }\\n        }\\n        \\n        int[] smallerNums = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            var value = uniques.get(nums[i]);\\n            smallerNums[i] = value;\\n        }\\n        return smallerNums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1083834,
                "title": "java-solution-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int n = nums.length;\\n        int[] copy = Arrays.copyOf(nums, n);\\n        Arrays.sort(copy);\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            map.put(copy[i], i);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = map.get(nums[i]);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int n = nums.length;\\n        int[] copy = Arrays.copyOf(nums, n);\\n        Arrays.sort(copy);\\n\\n        Map<Integer, Integer> map = new HashMap<>();\\n        for (int i = n - 1; i >= 0; i--) {\\n            map.put(copy[i], i);\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            nums[i] = map.get(nums[i]);\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1065199,
                "title": "python-easy-5-way-to-understand-1-liner-64-ms-faster-than-72-51",
                "content": "I try hard to reduce the runtime many times.\\n\\ntry 1 \\n```\\nb=len(nums)\\na=[0 for i in range(b)]\\nfor i in range(len(nums)):\\n\\tfor j in range(len(nums)):\\n\\t\\tif nums[i]>nums[j]:\\n\\t\\t\\ta[i]+=1\\nreturn a\\n```\\nRuntime:516 ms\\tMemory:14.5  MB\\n\\ntry 2\\n```\\na=len(nums)\\nb,count=[0]*a,0\\nwhile count<a:\\n\\tfor i in range(a):\\n\\t\\tif nums[count]>nums[i]:    \\n\\t\\t\\tb[count]+=1\\n\\tcount+=1\\nreturn b\\n```\\nRuntime:244 ms\\tMemory:14.4 MB\\n\\ntry 3 \\n```\\na,b = [],sorted(nums) \\nfor i in nums:\\n\\tindex=b.index(i)\\n\\ta.append(index)\\nreturn a\\n```\\nRuntime:64 ms\\tMemory:14.3 MB\\n\\ntry 4\\n```\\nb = sorted(nums) \\nreturn [b.index(i) for i in nums]\\n```\\nRuntime:68 ms\\tMemory:14.4 MB\\n\\ntry 5 1 liner\\n```\\nreturn [sorted(nums) .index(i) for i in nums]\\n```\\nRuntime:232 ms\\tMemory:14.3 MB\\n\\nif you like, give me a like and comment.Thx",
                "solutionTags": [],
                "code": "```\\nb=len(nums)\\na=[0 for i in range(b)]\\nfor i in range(len(nums)):\\n\\tfor j in range(len(nums)):\\n\\t\\tif nums[i]>nums[j]:\\n\\t\\t\\ta[i]+=1\\nreturn a\\n```\n```\\na=len(nums)\\nb,count=[0]*a,0\\nwhile count<a:\\n\\tfor i in range(a):\\n\\t\\tif nums[count]>nums[i]:    \\n\\t\\t\\tb[count]+=1\\n\\tcount+=1\\nreturn b\\n```\n```\\na,b = [],sorted(nums) \\nfor i in nums:\\n\\tindex=b.index(i)\\n\\ta.append(index)\\nreturn a\\n```\n```\\nb = sorted(nums) \\nreturn [b.index(i) for i in nums]\\n```\n```\\nreturn [sorted(nums) .index(i) for i in nums]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 946677,
                "title": "c-3-solutions",
                "content": "**soultion  1**\\n\\nsort + binary search  \\nTime complexity \\n O(n log(n)) +  O(n log(n)) = 2 O(n log(n)) =  O(n log(n))\\n space complexity O(n)\\n```\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        auto sorted(nums);\\n        sort(sorted.begin(), sorted.end());\\n        transform(cbegin(nums), cend(nums), begin(nums), [&sorted](const auto& val) {\\n            return lower_bound(cbegin(sorted), cend(sorted), val) - cbegin(sorted);\\n        });\\n       return nums;        \\n    }\\n```\\n\\n**soultion 2** \\n\\nsort + get the index from a hash map \\nTime complexity \\n O(n log(n))\\n O(n log(n))  +O(n) =  O(n log(n))\\n space complexity O(n)\\n```\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        unordered_map<int, int> counter;\\n        auto sorted(nums);\\n        sort(begin(sorted), end(sorted));\\n        for(int i = 0 ; i < size(sorted);++i ) counter.try_emplace(sorted[i], i);\\n        transform(cbegin(nums), cend(nums), begin(nums), [&counter](const auto& val) {\\n            return counter.find(val)->second;\\n        });\\n        return nums;        \\n    }\\n```\\n**soultion 3** \\ncalculating the partial sum from the counter\\n\\nTime complexity O(n)\\n O(n) + O(102) = O(n)\\nspace complexity O(102) = O(1)\\n\\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n    array<int,102> counter {};\\n    for(const auto&val : nums)  ++counter[val + 1 ];\\n    partial_sum(cbegin(counter), cend(counter), begin(counter));\\n    transform(cbegin(nums),cend(nums), begin(nums), [&counter](const auto& val) {\\n        return counter[val];\\n    });\\n    return  nums;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        auto sorted(nums);\\n        sort(sorted.begin(), sorted.end());\\n        transform(cbegin(nums), cend(nums), begin(nums), [&sorted](const auto& val) {\\n            return lower_bound(cbegin(sorted), cend(sorted), val) - cbegin(sorted);\\n        });\\n       return nums;        \\n    }\\n```\n```\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        unordered_map<int, int> counter;\\n        auto sorted(nums);\\n        sort(begin(sorted), end(sorted));\\n        for(int i = 0 ; i < size(sorted);++i ) counter.try_emplace(sorted[i], i);\\n        transform(cbegin(nums), cend(nums), begin(nums), [&counter](const auto& val) {\\n            return counter.find(val)->second;\\n        });\\n        return nums;        \\n    }\\n```\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n    array<int,102> counter {};\\n    for(const auto&val : nums)  ++counter[val + 1 ];\\n    partial_sum(cbegin(counter), cend(counter), begin(counter));\\n    transform(cbegin(nums),cend(nums), begin(nums), [&counter](const auto& val) {\\n        return counter[val];\\n    });\\n    return  nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 929911,
                "title": "java-o-n-solution",
                "content": "The approach is based on the counting sort. We start by creating an array with all the frequencies of each element. Then, for each element in this array, we add how many numbers are small than the number at the current index. The last step is to extract this value for each number in the nums array.\\n\\n\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\n        int[] freq = new int[101];\\n            \\n        for (int i = 0; i < nums.length; i++) {\\n            freq[nums[i]]++;\\n        }\\n           \\n        int sum = 0;\\n            \\n        for (int i = 0; i < freq.length; i++) {\\n            int temp = freq[i];                \\n            freq[i] = sum;\\n            sum = sum + temp;\\n        }\\n                               \\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = freq[nums[i]];\\n        }\\n            \\n        return nums;\\n    }",
                "solutionTags": [],
                "code": "The approach is based on the counting sort. We start by creating an array with all the frequencies of each element. Then, for each element in this array, we add how many numbers are small than the number at the current index. The last step is to extract this value for each number in the nums array.\\n\\n\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\n        int[] freq = new int[101];\\n            \\n        for (int i = 0; i < nums.length; i++) {\\n            freq[nums[i]]++;\\n        }\\n           \\n        int sum = 0;\\n            \\n        for (int i = 0; i < freq.length; i++) {\\n            int temp = freq[i];                \\n            freq[i] = sum;\\n            sum = sum + temp;\\n        }\\n                               \\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = freq[nums[i]];\\n        }\\n            \\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 836537,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for (int i=0;i<nums.length;i++){\\n            for (int j=0;j<nums.length;j++){\\n                if (nums[i]>nums[j]){\\n                    temp[i]++;\\n                }\\n            }\\n        }\\n    return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] temp = new int[nums.length];\\n        for (int i=0;i<nums.length;i++){\\n            for (int j=0;j<nums.length;j++){\\n                if (nums[i]>nums[j]){\\n                    temp[i]++;\\n                }\\n            }\\n        }\\n    return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 761182,
                "title": "java-stream-based-one-liner",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        return Arrays.stream(nums).map(i -> (int) Arrays.stream(nums).filter(j -> j < i).count()).toArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        return Arrays.stream(nums).map(i -> (int) Arrays.stream(nums).filter(j -> j < i).count()).toArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 752036,
                "title": "c-100-faster-solution-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int>count_map(101, 0);\\n        for(int num : nums){\\n            count_map[num] += 1;\\n        }\\n        int total = 0;\\n        for (int i = 0; i < 101; i++){\\n            if(count_map[i] != 0){\\n                int num_count = count_map[i];\\n                count_map[i] = total;\\n                total += num_count;\\n            }\\n        }\\n        for( int i = 0; i < nums.size(); i++){\\n            nums[i] = count_map[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int>count_map(101, 0);\\n        for(int num : nums){\\n            count_map[num] += 1;\\n        }\\n        int total = 0;\\n        for (int i = 0; i < 101; i++){\\n            if(count_map[i] != 0){\\n                int num_count = count_map[i];\\n                count_map[i] = total;\\n                total += num_count;\\n            }\\n        }\\n        for( int i = 0; i < nums.size(); i++){\\n            nums[i] = count_map[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 549279,
                "title": "python-solution-with-analysis-and-complexities",
                "content": "We must find a way to know how many numbers are smaller than each number of nums. For that we need to sort the list nums. By sorting it we have by the index the number of numbers that are smaller than the considered number. But because there can be dupplicates, we increment number_of_smaller only if we did not meet the number before.\\nWe use a dictionnary because we need to access the elements in it several times, so the O(1) complexity of the acces is appreciable.\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        dict_pos = {}\\n        number_of_smaller = 0\\n        for e in sorted_nums:\\n            if e not in dict_pos:\\n                dict_pos[e] = number_of_smaller\\n            number_of_smaller += 1\\n        res = []\\n        for e in nums:\\n            res.append(dict_pos[e])\\n        return res\\n```\\nIn terms of temporal complexity, the sort function is in O(nlogn) where n is the length of the list nums, the acces in dict_pos is in O(1), so because of the two loops, the complexity is in O(n).\\nConcerning the space complexity, it is in O(n), because we store one dictionnary and one list.",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        dict_pos = {}\\n        number_of_smaller = 0\\n        for e in sorted_nums:\\n            if e not in dict_pos:\\n                dict_pos[e] = number_of_smaller\\n            number_of_smaller += 1\\n        res = []\\n        for e in nums:\\n            res.append(dict_pos[e])\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538482,
                "title": "python-o-n",
                "content": "```\\n def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count,lessthan = [0]*101,[0]*101\\n        for num in nums:\\n            count[num]+=1\\n        for i in range(1,101):\\n            lessthan[i]=count[i-1]+lessthan[i-1]\\n        res=[lessthan[num] for num in nums]\\n        return res``\\n```\\n",
                "solutionTags": [],
                "code": "```\\n def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count,lessthan = [0]*101,[0]*101\\n        for num in nums:\\n            count[num]+=1\\n        for i in range(1,101):\\n            lessthan[i]=count[i-1]+lessthan[i-1]\\n        res=[lessthan[num] for num in nums]\\n        return res``\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 528852,
                "title": "ruby",
                "content": "# @param {Integer[]} nums\\n# @return {Integer[]}\\n```\\ndef smaller_numbers_than_current(nums)\\n    sorted_nums = nums.sort\\n    nums.map {|num| sorted_nums.index(num)} \\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef smaller_numbers_than_current(nums)\\n    sorted_nums = nums.sort\\n    nums.map {|num| sorted_nums.index(num)} \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 527328,
                "title": "java",
                "content": "```\\nimport java.util.*;\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        SortedMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i],0) + 1);\\n        }\\n        int prev = 0;\\n        int sum = 0;\\n        for(int key : map.keySet()) {\\n            int temp = map.get(key); // Store current key safely\\n            sum = sum + prev; // Sum = sum + previous \\n            map.put(key, sum); //Store in map the sum\\n            prev = temp; // Store temp in previous\\n        }\\n        for(int i = 0; i < nums.length; i++) {\\n            nums[i] = map.get(nums[i]);\\n        }\\n        return nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        SortedMap<Integer, Integer> map = new TreeMap<>();\\n        for(int i = 0; i < nums.length; i++) {\\n            map.put(nums[i], map.getOrDefault(nums[i],0) + 1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 524883,
                "title": "simple-java-solution-o-nlogn-o-n",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int numsClone[] = nums.clone(); \\n        Arrays.sort(nums);\\n       for(int i = 0 ; i < nums.length;i++) {\\n           if(!map.containsKey(nums[i])) {\\n               map.put(nums[i],i);\\n           }\\n            \\n        }\\n        int[] result = new int[nums.length];\\n        for(int i = 0 ; i < numsClone.length;i++) {\\n           result[i] = map.get(numsClone[i]); \\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        Map<Integer,Integer> map = new HashMap<>();\\n        int numsClone[] = nums.clone(); \\n        Arrays.sort(nums);\\n       for(int i = 0 ; i < nums.length;i++) {\\n           if(!map.containsKey(nums[i])) {\\n               map.put(nums[i],i);\\n           }\\n            \\n        }\\n        int[] result = new int[nums.length];\\n        for(int i = 0 ; i < numsClone.length;i++) {\\n           result[i] = map.get(numsClone[i]); \\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872593,
                "title": "python-94-44-faster-simple-concept",
                "content": "# Intuition\\nThe problem asks us to find the number of elements in the input list `nums` that are smaller than each element at each position. To solve this, we can use a counting sort technique. We will first count the occurrences of each number in the `nums` list and then use the count information to find the number of elements smaller than each element.\\n\\n# Approach\\n1. Create a `count` list of size 101 (since the constraint specifies that the numbers in the input list will be in the range [0, 100]).\\n2. Traverse through the `nums` list and count the occurrences of each number by incrementing the corresponding index in the `count` list.\\n3. Create a new list `res` to store the results.\\n4. Traverse through the `nums` list again and for each element `num`, find the sum of all elements in `count` list up to the index `num` and append it to the `res` list.\\n5. Return the `res` list as the final result.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the size of the `nums` list. We traverse the list twice, but both traversals are linear in terms of the input size.\\n- Space complexity: O(1) since the `count` list is of constant size (101) and the `res` list is the same size as the input `nums` list. So, we can consider it as O(1) space complexity.\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count=[0]*101\\n        res=[]\\n        for num in nums:\\n            count[num]+=1 \\n        for num in nums:\\n            res.append(sum(count[:num]))\\n        return res\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        count=[0]*101\\n        res=[]\\n        for num in nums:\\n            count[num]+=1 \\n        for num in nums:\\n            res.append(sum(count[:num]))\\n        return res\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3208521,
                "title": "javascript-two-pointer-approach",
                "content": "# Complexity\\n- Time complexity: **Exponential** - **O(N^2)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **Linear** - **O(N)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    let arr = [];\\n    for(let i=0; i<nums.length; i++){\\n        let j=0, count=0;\\n        while(j < nums.length){\\n            if(nums[j] < nums[i]){\\n                count++;\\n            }\\n            j++;\\n        }\\n        arr.push(count);\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    let arr = [];\\n    for(let i=0; i<nums.length; i++){\\n        let j=0, count=0;\\n        while(j < nums.length){\\n            if(nums[j] < nums[i]){\\n                count++;\\n            }\\n            j++;\\n        }\\n        arr.push(count);\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3068636,
                "title": "by-c-sorted-and-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int length = nums.size();\\n        map <int, int> mp;\\n        vector <int> numsSorted = nums;\\n        sort(numsSorted.begin(), numsSorted.end());\\n\\n        for(int i = length-1; i >=0; i--){\\n            mp[numsSorted[i]] = i;\\n        }\\n        for(int i = 0; i < length; i++){\\n            nums[i] = mp[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sort",
                    "Ordered Map"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int length = nums.size();\\n        map <int, int> mp;\\n        vector <int> numsSorted = nums;\\n        sort(numsSorted.begin(), numsSorted.end());\\n\\n        for(int i = length-1; i >=0; i--){\\n            mp[numsSorted[i]] = i;\\n        }\\n        for(int i = 0; i < length; i++){\\n            nums[i] = mp[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658737,
                "title": "c-instead-of-using-lots-of-space-see-the-best-way",
                "content": "# vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n        int cnt=0;\\n        vector<int>ans;\\n\\t\\t//using map it will take lots of time and space too\\n\\t\\t// so do the problem using brute force approach\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])\\n                cnt++;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "# vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n        int cnt=0;\\n        vector<int>ans;\\n\\t\\t//using map it will take lots of time and space too\\n\\t\\t// so do the problem using brute force approach\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j])\\n                cnt++;\\n            }\\n            ans.push_back(cnt);\\n            cnt=0;\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2545658,
                "title": "simple-hashmap-solution",
                "content": "```\\nclass Solution {\\n    \\n     public int[] smallerNumbersThanCurrent(int[] nums) {\\n         HashMap<Integer, Integer> map = new HashMap<>();\\n         \\n         int []copy = nums.clone();\\n         \\n         Arrays.sort(copy);\\n         for(int i=0;i<copy.length;i++){\\n             map.putIfAbsent(copy[i],i);\\n         }         \\n         for(int i=0;i<nums.length;++i){\\n             copy[i]= map.get(nums[i]);\\n         }\\n         return copy;\\n     }\\n\\n```\\n**Credit To : rxdbeard**",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    \\n     public int[] smallerNumbersThanCurrent(int[] nums) {\\n         HashMap<Integer, Integer> map = new HashMap<>();\\n         \\n         int []copy = nums.clone();\\n         \\n         Arrays.sort(copy);\\n         for(int i=0;i<copy.length;i++){\\n             map.putIfAbsent(copy[i],i);\\n         }         \\n         for(int i=0;i<nums.length;++i){\\n             copy[i]= map.get(nums[i]);\\n         }\\n         return copy;\\n     }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2359295,
                "title": "my-python-solution",
                "content": "```class Solution(object):\\n    def smallerNumbersThanCurrent(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n\\t\\t\\n        arr = sorted(nums)\\n\\t\\t\\n        for i in range(len(nums)):\\n            nums[i] = arr.index(nums[i])\\n        \\n        return nums\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution(object):\\n    def smallerNumbersThanCurrent(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n\\t\\t\\n        arr = sorted(nums)\\n\\t\\t\\n        for i in range(len(nums)):\\n            nums[i] = arr.index(nums[i])\\n        \\n        return nums\\n",
                "codeTag": "Java"
            },
            {
                "id": 2208278,
                "title": "c-hash-table-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> s(101,-1);        //this is our hash table. \\n\\t\\t//We have created 101 elements in this vector and initialised to the to -1\\n        vector<int> f=nums;     // this vector f will be our original vector given in the question. \\n        sort(nums.begin(),nums.end());  //sorting the nums vector\\n\\t\\t //Using for loop we are entering the value in the hash table s \\n\\t\\t //where index of the table is equal to the value in the nums array. //Since we have already sorted the nums vector,\\n\\t\\t //the index of an element in nums gives the number of elements //smaller than it. \\n\\t\\t //for eg. ( in sorted vector [1,2,5] index of element 5 is 2, hence 2 numbers are smaller than it.)\\n        for(int i=0;i<nums.size();i++){    \\n            if(s[nums[i]]==-1){\\n                s[nums[i]]=i;                \\n            }\\n        }\\n\\t\\t//finally we reassign the values to un sorted vector f by retrieving its value from hash table s\\n        for(int i=0;i<f.size();i++){\\n            f[i]=s[f[i]];\\n        }\\n        return f;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> s(101,-1);        //this is our hash table. \\n\\t\\t//We have created 101 elements in this vector and initialised to the to -1\\n        vector<int> f=nums;     // this vector f will be our original vector given in the question. \\n        sort(nums.begin(),nums.end());  //sorting the nums vector\\n\\t\\t //Using for loop we are entering the value in the hash table s \\n\\t\\t //where index of the table is equal to the value in the nums array. //Since we have already sorted the nums vector,\\n\\t\\t //the index of an element in nums gives the number of elements //smaller than it. \\n\\t\\t //for eg. ( in sorted vector [1,2,5] index of element 5 is 2, hence 2 numbers are smaller than it.)\\n        for(int i=0;i<nums.size();i++){    \\n            if(s[nums[i]]==-1){\\n                s[nums[i]]=i;                \\n            }\\n        }\\n\\t\\t//finally we reassign the values to un sorted vector f by retrieving its value from hash table s\\n        for(int i=0;i<f.size();i++){\\n            f[i]=s[f[i]];\\n        }\\n        return f;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2166125,
                "title": "python-faster-76-02-explained",
                "content": "# Python Easy Solution.\\n**Faster Than 76.02%**\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        # in sorted_num every num\\'s i(index) shows just how many numbers are smaller than it, \\n        # so we just add the indexes and return it.\\n        sorted_nums = sorted(nums)\\n        return [sorted_nums.index(num) for num in nums]\\n```\\n## Give it a **Upvote** If You Like My Explanation.\\n### Have a Great Day/Night.",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        # in sorted_num every num\\'s i(index) shows just how many numbers are smaller than it, \\n        # so we just add the indexes and return it.\\n        sorted_nums = sorted(nums)\\n        return [sorted_nums.index(num) for num in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902691,
                "title": "solved-using-hashmap-and-priority-queue",
                "content": "Added every element of the array in the priority queue and after that in map added the peek element and size of the priority queue - 1. As the peek element of the priority queue tells us about the largest element in the queue, after adding it to the map, Removed it from the map.\\n\\n```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i=0; i<nums.length; i++) {\\n            pq.add(nums[i]);\\n        }\\n        \\n        int[] arr = new int[nums.length];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++) {\\n            map.put(pq.peek(), pq.size()-1);\\n            pq.remove();\\n        }\\n        \\n       \\n        for(int i=0; i<nums.length; i++) {\\n            arr[i] = map.get(nums[i]);\\n        }\\n        \\n        return arr;\\n    }",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "Added every element of the array in the priority queue and after that in map added the peek element and size of the priority queue - 1. As the peek element of the priority queue tells us about the largest element in the queue, after adding it to the map, Removed it from the map.\\n\\n```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Collections.reverseOrder());\\n        for(int i=0; i<nums.length; i++) {\\n            pq.add(nums[i]);\\n        }\\n        \\n        int[] arr = new int[nums.length];\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        for(int i=0; i<nums.length; i++) {\\n            map.put(pq.peek(), pq.size()-1);\\n            pq.remove();\\n        }\\n        \\n       \\n        for(int i=0; i<nums.length; i++) {\\n            arr[i] = map.get(nums[i]);\\n        }\\n        \\n        return arr;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1464971,
                "title": "c-solution-using-map-94-70",
                "content": "**Please Upvote if you like the solution**\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        map<int,int>mp;\\n        int n=nums.size();\\n        vector<int> res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        int c=0,temp;\\n        for(auto i:mp)\\n        {\\n            temp=i.second;  \\n            mp[i.first]=c;\\n            c+=temp;  \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=mp[nums[i]];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        map<int,int>mp;\\n        int n=nums.size();\\n        vector<int> res(n);\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[nums[i]]++;\\n        }\\n        int c=0,temp;\\n        for(auto i:mp)\\n        {\\n            temp=i.second;  \\n            mp[i.first]=c;\\n            c+=temp;  \\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            res[i]=mp[nums[i]];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1428526,
                "title": "java-easy-solution-for-90-fast-and-2-ms-runtime",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        //Storing number count in an array ofsmall[0,1,2,3,4,5....]\\n        int [] small= new int[101];\\n        for(int i =0;i<nums.length;i++){\\n            small[nums[i]]++;\\n        }\\n        \\n        //adding elements from the past elements;\\n        //0 1 2 3 4 5 6 7 8 ----->element\\n        //0 1 2 1 0 0 0 0 1  ------>count of the element in the array\\n        //0 1 3 4 4 4 4 4 5 -------->sum of the previous element\\n        for(int i =1;i<101;i++){\\n            small[i]+=small[i-1];\\n        }\\n        \\n        //Returning the value of sum[index-1] \\n        for(int i =0;i<nums.length;i++){\\n            int position = nums[i];\\n            if(position==0) nums[i]=0;\\n            else{\\n                nums[i]= small[position-1];\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        //Storing number count in an array ofsmall[0,1,2,3,4,5....]\\n        int [] small= new int[101];\\n        for(int i =0;i<nums.length;i++){\\n            small[nums[i]]++;\\n        }\\n        \\n        //adding elements from the past elements;\\n        //0 1 2 3 4 5 6 7 8 ----->element\\n        //0 1 2 1 0 0 0 0 1  ------>count of the element in the array\\n        //0 1 3 4 4 4 4 4 5 -------->sum of the previous element\\n        for(int i =1;i<101;i++){\\n            small[i]+=small[i-1];\\n        }\\n        \\n        //Returning the value of sum[index-1] \\n        for(int i =0;i<nums.length;i++){\\n            int position = nums[i];\\n            if(position==0) nums[i]=0;\\n            else{\\n                nums[i]= small[position-1];\\n            }\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1397270,
                "title": "c-brute-force-optimal",
                "content": "```\\n//Approach-1 (Brute Force)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> result(n);\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(i == j) continue;\\n                \\n                if(nums[i] > nums[j])\\n                    result[i]++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Optimal using map)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> mp(101);\\n        \\n        for(int i = 0; i<n; i++) mp[nums[i]]++;\\n        \\n        int sum = 0;\\n        for(int i = 1; i<101; i++) {\\n            mp[i] += mp[i-1];\\n        }\\n        \\n        for(int i = 0; i<n; i++)\\n            nums[i] = nums[i]==0 ? 0 : mp[nums[i]-1];\\n        \\n        return nums;\\n    }\\n};    \\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Brute Force)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> result(n);\\n        for(int i = 0; i<n; i++) {\\n            for(int j = 0; j<n; j++) {\\n                if(i == j) continue;\\n                \\n                if(nums[i] > nums[j])\\n                    result[i]++;\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\n```\\n//Approach-2 (Optimal using map)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int n = nums.size();\\n        vector<int> mp(101);\\n        \\n        for(int i = 0; i<n; i++) mp[nums[i]]++;\\n        \\n        int sum = 0;\\n        for(int i = 1; i<101; i++) {\\n            mp[i] += mp[i-1];\\n        }\\n        \\n        for(int i = 0; i<n; i++)\\n            nums[i] = nums[i]==0 ? 0 : mp[nums[i]-1];\\n        \\n        return nums;\\n    }\\n};    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1336603,
                "title": "swift-one-liner",
                "content": "```\\nclass Solution {\\n    func smallerNumbersThanCurrent(_ nums: [Int]) -> [Int] {\\n        return nums.map { num in nums.filter { $0 < num }.count }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func smallerNumbersThanCurrent(_ nums: [Int]) -> [Int] {\\n        return nums.map { num in nums.filter { $0 < num }.count }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1218252,
                "title": "c-beats-100-solution",
                "content": "first lopp finds the maximum | second loop adds the count of each element in first vector | second loop finds the elements that are less than that element | final loop just substitues the answer in the solution.\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& t) {\\n        int max=INT_MIN;\\n        for(int i=0;i<t.size();i++){\\n            if(max<t[i])\\n                max=t[i];\\n        }\\n        vector<int> l1(max+1,0);\\n        for(int i=0;i<t.size();i++){\\n            l1[t[i]]++;\\n        }\\n        vector<int> l2;\\n        int sum=0;\\n        for(int i=0;i<l1.size();i++){\\n            l2.push_back(sum);\\n            sum+=l1[i];\\n        }\\n        for(int i=0;i<t.size();i++){\\n            t[i]=l2[t[i]];\\n        }\\n        return t;\\n    }\\n};\\n```\\n\\n**Do like if you think the solution is decent keeps me motivated**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& t) {\\n        int max=INT_MIN;\\n        for(int i=0;i<t.size();i++){\\n            if(max<t[i])\\n                max=t[i];\\n        }\\n        vector<int> l1(max+1,0);\\n        for(int i=0;i<t.size();i++){\\n            l1[t[i]]++;\\n        }\\n        vector<int> l2;\\n        int sum=0;\\n        for(int i=0;i<l1.size();i++){\\n            l2.push_back(sum);\\n            sum+=l1[i];\\n        }\\n        for(int i=0;i<t.size();i++){\\n            t[i]=l2[t[i]];\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1070102,
                "title": "well-explained-o-n-time-space-solution-faster-than-100-0ms",
                "content": "The idea is :\\n* Count occurences of all values( 1-100 )\\n* Then we have to check for each value, how many are smaller than \\'i\\'  :\\n* We colud do that by either visiting count of all values less than \\'i\\' and adding them\\n* OR we could could create something like a cumulative sum which keeps count of number of smaller elements\\n ```\\n\\t  for( int i=0; i<101; i++ )\\n        {\\n            sum += count[i];\\n            count[i] = sum-count[i];\\n        }\\n```\\n* And then you just return count of numbers smaller than \\'i\\'\\n```\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> count(101);\\n        vector<int> res( nums.size() );\\n        for( int& i : nums ) count[i] += 1;\\n        int sum = 0;\\n        for( int i=0; i<101; i++ )\\n        {\\n            sum += count[i];\\n            count[i] = sum-count[i];\\n        }\\n        for( int i=0; i<nums.size(); i++ )\\n        {\\n            res[i] = count[ nums[i] ];\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t  for( int i=0; i<101; i++ )\\n        {\\n            sum += count[i];\\n            count[i] = sum-count[i];\\n        }\\n```\n```\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> count(101);\\n        vector<int> res( nums.size() );\\n        for( int& i : nums ) count[i] += 1;\\n        int sum = 0;\\n        for( int i=0; i<101; i++ )\\n        {\\n            sum += count[i];\\n            count[i] = sum-count[i];\\n        }\\n        for( int i=0; i<nums.size(); i++ )\\n        {\\n            res[i] = count[ nums[i] ];\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1049134,
                "title": "java-bucket-solution-with-in-depth-explanation",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t    // constraint: values 0 <= nums[i] <= 100\\n        // that means we need 101 slots \\n        int[] bucket = new int[101];\\n        int[] res = new int[nums.length];\\n\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            // Every occurance of a value, \\n            // will increase the values\\' spot by one\\n            bucket[nums[i]]++;\\n\\t    }\\n            \\n        for(int i = 1; i < 101; i++) {\\n            // Store the running sum - the sum up to current spot -\\n            // instead of just the number of occurances of the current spot\\n            // Spot 0: Count of 0\\'s = 2\\n            // Spot 1: Count of 1\\'s = 1\\n            // Spot 2: Count of 2\\'s = 1\\n            // will change to\\n            // Spot 0: will always be 0, since we don\\'t have negative numbers\\n            // Spot 1: Count of 0\\'s = 2\\n            // Spot 2: Count of 0\\'s + Count of 1\\'s = 3\\n            // and so on\\n            bucket[i] += bucket[i-1];\\n        }\\n        \\n        // for the resulting array we must put the entries in the bucket\\n        // to the right places\\n        for(int i=0; i < nums.length; i++) {\\n            // running sum up to 0 will always be 0 as explained above\\n            if (nums[i] == 0) {\\n                res[i] = 0;\\n            } else {\\n                // just retrieve the running sum up to i (but excluding i)\\n                // out of it\\'s spot and save to\\n                res[i] = bucket[nums[i] - 1];\\n            }\\n        }\\n              \\n        return res;\\n    }\\n}\\n```\\n\\nAlthough it\\'s a smart (and fast) solution, I wouldn\\'t recommend it in a real production environment since it heavily depends on the fact, that the given constraints will forever remain the same else the code will stop working. An easy solution to this problem is to dynamically determine the bucket size like this (This solution will put you in the ~65% range):\\n\\n```\\nint bucketSize = Arrays.stream(nums).max().getAsInt() + 1;\\nint[] bucket = new int[bucketSize];\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t    // constraint: values 0 <= nums[i] <= 100\\n        // that means we need 101 slots \\n        int[] bucket = new int[101];\\n        int[] res = new int[nums.length];\\n\\n        \\n        for(int i = 0; i < nums.length; i++) {\\n            // Every occurance of a value, \\n            // will increase the values\\' spot by one\\n            bucket[nums[i]]++;\\n\\t    }\\n            \\n        for(int i = 1; i < 101; i++) {\\n            // Store the running sum - the sum up to current spot -\\n            // instead of just the number of occurances of the current spot\\n            // Spot 0: Count of 0\\'s = 2\\n            // Spot 1: Count of 1\\'s = 1\\n            // Spot 2: Count of 2\\'s = 1\\n            // will change to\\n            // Spot 0: will always be 0, since we don\\'t have negative numbers\\n            // Spot 1: Count of 0\\'s = 2\\n            // Spot 2: Count of 0\\'s + Count of 1\\'s = 3\\n            // and so on\\n            bucket[i] += bucket[i-1];\\n        }\\n        \\n        // for the resulting array we must put the entries in the bucket\\n        // to the right places\\n        for(int i=0; i < nums.length; i++) {\\n            // running sum up to 0 will always be 0 as explained above\\n            if (nums[i] == 0) {\\n                res[i] = 0;\\n            } else {\\n                // just retrieve the running sum up to i (but excluding i)\\n                // out of it\\'s spot and save to\\n                res[i] = bucket[nums[i] - 1];\\n            }\\n        }\\n              \\n        return res;\\n    }\\n}\\n```\n```\\nint bucketSize = Arrays.stream(nums).max().getAsInt() + 1;\\nint[] bucket = new int[bucketSize];\\n```",
                "codeTag": "Java"
            },
            {
                "id": 996785,
                "title": "easy-c-o-n-for-how-many-numbers-are-smaller-than-the-current-number",
                "content": "1. Keep track of count of each number in nums\\n2. Make prefix sum of count of numbers less than the current number.\\n3. Update ans vector\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n        vector<int> count(101);\\n        vector<int> ans(nums.size());\\n        \\n        for(int i=0;i<nums.size();i++)\\n            count[nums[i]]++;\\n        \\n        for(int i=1;i<=100;i++)\\n        {\\n            count[i]+=count[i-1];\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n                ans[i]=0;\\n            else\\n                ans[i]=count[nums[i]-1];\\n        }\\n        return ans;\\n    }\\n    \\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n        vector<int> count(101);\\n        vector<int> ans(nums.size());\\n        \\n        for(int i=0;i<nums.size();i++)\\n            count[nums[i]]++;\\n        \\n        for(int i=1;i<=100;i++)\\n        {\\n            count[i]+=count[i-1];\\n        }\\n        \\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n                ans[i]=0;\\n            else\\n                ans[i]=count[nums[i]-1];\\n        }\\n        return ans;\\n    }\\n    \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 851642,
                "title": "java-runtime-99-and-1ms-using-freq-array",
                "content": "```\\nclass Solution {\\n    // 8 1 2 2 3\\n    // 0 0 0 0 0 0 0 0\\n    //-----------------\\n    // 1 2 1 0 0 0 0 1\\n    // 1 3 4 4 4 4 4 5\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[]helper = new int [101];\\n        for(int i=0;i<nums.length;i++){\\n            helper[nums[i]]++;\\n        }\\n        for(int i=1;i<101;i++){\\n            helper[i]+=helper[i-1];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){continue;}\\n            nums[i] = helper[nums[i]-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // 8 1 2 2 3\\n    // 0 0 0 0 0 0 0 0\\n    //-----------------\\n    // 1 2 1 0 0 0 0 1\\n    // 1 3 4 4 4 4 4 5\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[]helper = new int [101];\\n        for(int i=0;i<nums.length;i++){\\n            helper[nums[i]]++;\\n        }\\n        for(int i=1;i<101;i++){\\n            helper[i]+=helper[i-1];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]==0){continue;}\\n            nums[i] = helper[nums[i]-1];\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 835391,
                "title": "clean-python",
                "content": "Solution 1: slow but clean\\n\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        return [sorted_nums.index(num) for num in nums]\\n```\\n\\nSolution 2: faster, but need more space (additional hash map)\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        lookup = {}\\n        for i, v in enumerate(sorted(nums)):\\n            if v in lookup:\\n                continue\\n            lookup[v] = i\\n        return [lookup[num] for num in nums]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        return [sorted_nums.index(num) for num in nums]\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        lookup = {}\\n        for i, v in enumerate(sorted(nums)):\\n            if v in lookup:\\n                continue\\n            lookup[v] = i\\n        return [lookup[num] for num in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 822167,
                "title": "c-sol-with-detailed-comments-o-n-time-faster-than-95-54",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        \\n        vector<int> counts(101, 0);\\n        /*101 because 0 <= nums[i] <= 100;\\n        Parse the nums vector, and take the corresponding val as index of the counts   \\n        vector and increase one.\\n        */\\n        for(int val : nums ){\\n            int index = val;\\n            counts[index] ++;\\n        }\\n        \\n        /* Parse the lessThanCounts vector, for the index = i, sum will contain sum\\n\\t\\tof all the counts from i = 0 to i-1, given the counts array and will assign it to \\n\\t\\tlessThanCounts[i], and then add counts[i] to the running \"sum\" variable */\\n        \\n        vector<int> lessThanCounts(101, 0);\\n        int sum = 0;\\n        for(int i = 0 ; i < 101 ; i++){\\n            lessThanCounts[i] = sum;\\n            sum += counts[i];\\n        }\\n        \\n\\t\\t/* Now the count of each \"val\" of the vector nums is the value present at index \"val\" of the\\n\\t\\tlessThanCounts vector*/\\n        \\n        vector<int> ans;\\n        for(int val : nums){\\n            ans.push_back(lessThanCounts[val]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        \\n        vector<int> counts(101, 0);\\n        /*101 because 0 <= nums[i] <= 100;\\n        Parse the nums vector, and take the corresponding val as index of the counts   \\n        vector and increase one.\\n        */\\n        for(int val : nums ){\\n            int index = val;\\n            counts[index] ++;\\n        }\\n        \\n        /* Parse the lessThanCounts vector, for the index = i, sum will contain sum\\n\\t\\tof all the counts from i = 0 to i-1, given the counts array and will assign it to \\n\\t\\tlessThanCounts[i], and then add counts[i] to the running \"sum\" variable */\\n        \\n        vector<int> lessThanCounts(101, 0);\\n        int sum = 0;\\n        for(int i = 0 ; i < 101 ; i++){\\n            lessThanCounts[i] = sum;\\n            sum += counts[i];\\n        }\\n        \\n\\t\\t/* Now the count of each \"val\" of the vector nums is the value present at index \"val\" of the\\n\\t\\tlessThanCounts vector*/\\n        \\n        vector<int> ans;\\n        for(int val : nums){\\n            ans.push_back(lessThanCounts[val]);\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 810082,
                "title": "time-o-n-space-o-1-constant-100-faster-memory-simple-solution-with-explanation",
                "content": "Java\\nTime: O(n), where n is length of nums.length, assuming nums.length can be any number\\nSpace: O(1) constant space of length 101\\n\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        //Go through the given array and save the frequency of each number element\\n        int[] valFrequency = new int[101]; \\n        for (int i = 0; i < nums.length; i++) {\\n                valFrequency[nums[i]]++; //map each number element as it\\'s own index\\n        }\\n        \\n        //For possible numbers 0 to 100, go from left to right and count frequency, where every number is smaller than the next iteration)\\n        int count = 0;\\n        for (int i = 0; i < valFrequency.length; i++) {\\n            if (valFrequency[i] != 0) { \\n                int freqHolder = valFrequency[i]; //store the frequency of the current number\\n                valFrequency[i] = count; //replace the purpose of the element from frequency to count (re-using the same array to save space)\\n                count = count + freqHolder ; //add the saved frequency to the count answer\\n            }\\n        }\\n        \\n        //Replace the given array\\'s elements with its own count answer\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = valFrequency[nums[i]];\\n        }\\n        \\n\\n        return nums;\\n        \\n    }\\n}\\n```\\nPlease feel free to comment for discussions",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        //Go through the given array and save the frequency of each number element\\n        int[] valFrequency = new int[101]; \\n        for (int i = 0; i < nums.length; i++) {\\n                valFrequency[nums[i]]++; //map each number element as it\\'s own index\\n        }\\n        \\n        //For possible numbers 0 to 100, go from left to right and count frequency, where every number is smaller than the next iteration)\\n        int count = 0;\\n        for (int i = 0; i < valFrequency.length; i++) {\\n            if (valFrequency[i] != 0) { \\n                int freqHolder = valFrequency[i]; //store the frequency of the current number\\n                valFrequency[i] = count; //replace the purpose of the element from frequency to count (re-using the same array to save space)\\n                count = count + freqHolder ; //add the saved frequency to the count answer\\n            }\\n        }\\n        \\n        //Replace the given array\\'s elements with its own count answer\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = valFrequency[nums[i]];\\n        }\\n        \\n\\n        return nums;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801471,
                "title": "faster-than-72-of-python3",
                "content": "```python\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        l = nums[:]\\n        l.sort()\\n        return [l.index(n) for n in nums]\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        l = nums[:]\\n        l.sort()\\n        return [l.index(n) for n in nums]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754084,
                "title": "two-simple-c-solution-complexity-o-n-log-n-and-o-n",
                "content": "**Solution 1:**  Sorting and position finding\\n\\n1. Copy the input and Sort it. \\n2. Now try to find the position of each value with respect to starting element and that value would be number of elements lesser than it.\\n3. Time Complexity : O(n log(n)), Space Complexity : O(n)\\n\\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> res;\\n        vector<int> copy(nums);\\n        \\n        sort(copy.begin(), copy.end());\\n        auto it = copy.begin();\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            it = find(copy.begin(), copy.end(), nums[i]);\\n            res.push_back(it - copy.begin());\\n        }\\n        return res;\\n    }\\n```\\n\\t\\n\\t\\n**Solution 2:** Count array\\n\\n1. Make Count array for input since the range of values of num is between 0 to 100 (inclusive)\\n2. Now Compute Sum of elements lesser than current element.\\n3. Traverse the original input vector and get values from count_sum_arr one by one which can be pushed to result (answer)\\n4. Time Complexity : O(R) , Space Complexity : O(R) where R is range of values of nums[i]\\n\\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> res;\\n        int count_arr[101] = {0}; // Since nums[i] can have max value of 100\\n        int count_array_size = 0;\\n        int i = 0, val = 0;\\n        \\n        for (i = 0; i < nums.size(); i++)\\n        {\\n            count_arr[nums[i]]++;\\n            if (nums[i] > count_array_size) // Getting the max range\\n                count_array_size = nums[i];\\n        }\\n        \\n        int count_sum_arr[101] = {0};\\n        count_sum_arr[0] = 0;\\n        for (i = 1; i <= count_array_size; i++)\\n            count_sum_arr[i] = count_sum_arr[i - 1] + count_arr[i-1];\\n        \\n        for (i = 0; i < nums.size(); i++)\\n        {\\n            val = count_sum_arr[nums[i]];\\n            res.push_back(val);\\n        }\\n        \\n        return res;\\n    }\\n\\t```\\n\\t\\n\\t",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> res;\\n        vector<int> copy(nums);\\n        \\n        sort(copy.begin(), copy.end());\\n        auto it = copy.begin();\\n        \\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            it = find(copy.begin(), copy.end(), nums[i]);\\n            res.push_back(it - copy.begin());\\n        }\\n        return res;\\n    }\\n```\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> res;\\n        int count_arr[101] = {0}; // Since nums[i] can have max value of 100\\n        int count_array_size = 0;\\n        int i = 0, val = 0;\\n        \\n        for (i = 0; i < nums.size(); i++)\\n        {\\n            count_arr[nums[i]]++;\\n            if (nums[i] > count_array_size) // Getting the max range\\n                count_array_size = nums[i];\\n        }\\n        \\n        int count_sum_arr[101] = {0};\\n        count_sum_arr[0] = 0;\\n        for (i = 1; i <= count_array_size; i++)\\n            count_sum_arr[i] = count_sum_arr[i - 1] + count_arr[i-1];\\n        \\n        for (i = 0; i < nums.size(); i++)\\n        {\\n            val = count_sum_arr[nums[i]];\\n            res.push_back(val);\\n        }\\n        \\n        return res;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 747187,
                "title": "easy-c-o-n-solution-without-sorting",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums)\\n    {\\n        int count[101] = {0}, n = nums.size();\\n        vector<int>ans(n);\\n\\n        for(int i=0; i<n; i++)\\n            count[nums[i]]++;\\n\\n        for(int i=1; i<101; i++)\\n            count[i] += count[i-1];\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] == 0)\\n                ans[i] = 0;\\n            else\\n                ans[i] = count[nums[i]-1];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums)\\n    {\\n        int count[101] = {0}, n = nums.size();\\n        vector<int>ans(n);\\n\\n        for(int i=0; i<n; i++)\\n            count[nums[i]]++;\\n\\n        for(int i=1; i<101; i++)\\n            count[i] += count[i-1];\\n\\n        for(int i=0; i<n; i++)\\n        {\\n            if(nums[i] == 0)\\n                ans[i] = 0;\\n            else\\n                ans[i] = count[nums[i]-1];\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 729834,
                "title": "python-simple-solution-6-liner",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums):\\n        \\n        counter = [0] * 102\\n        for x in nums:\\n            counter[x+1] += 1\\n        \\n        for i in range(1, 102):\\n            counter[i] += counter[i-1]\\n        \\n        return [counter[nums[i]] for i in range(len(nums))]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums):\\n        \\n        counter = [0] * 102\\n        for x in nums:\\n            counter[x+1] += 1\\n        \\n        for i in range(1, 102):\\n            counter[i] += counter[i-1]\\n        \\n        return [counter[nums[i]] for i in range(len(nums))]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 637309,
                "title": "javascript-brute-force-and-optimized",
                "content": "Brute Force\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    let result = [];\\n    for(let i=0; i<nums.length; i++) {\\n        let count = 0;\\n        for(let j=0; j<nums.length; j++) {\\n            if(j!=i && nums[j] < nums[i]) {\\n                count++;\\n            }            \\n        }\\n        result.push(count);\\n    }    \\n    return result;\\n};\\n```\\n\\nOptimized:\\n\\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const sorted = [...nums].sort((a, b) => a - b);\\n    return nums.map(num => sorted.indexOf(num));\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    let result = [];\\n    for(let i=0; i<nums.length; i++) {\\n        let count = 0;\\n        for(let j=0; j<nums.length; j++) {\\n            if(j!=i && nums[j] < nums[i]) {\\n                count++;\\n            }            \\n        }\\n        result.push(count);\\n    }    \\n    return result;\\n};\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @return {number[]}\\n */\\nvar smallerNumbersThanCurrent = function(nums) {\\n    const sorted = [...nums].sort((a, b) => a - b);\\n    return nums.map(num => sorted.indexOf(num));\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 588301,
                "title": "go-o-n",
                "content": "```go\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n    buckets := make([]int, 101)\\n    for _, v := range nums {\\n        buckets[v]++\\n    }\\n    \\n    sum := 0\\n    sums := make([]int, 101)\\n    for i, v := range buckets {\\n        sums[i] = sum\\n        sum += v\\n    }\\n\\n    res := make([]int, len(nums))\\n    for i, v := range nums {\\n        res[i] = sums[v]\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```go\\nfunc smallerNumbersThanCurrent(nums []int) []int {\\n    buckets := make([]int, 101)\\n    for _, v := range nums {\\n        buckets[v]++\\n    }\\n    \\n    sum := 0\\n    sums := make([]int, 101)\\n    for i, v := range buckets {\\n        sums[i] = sum\\n        sum += v\\n    }\\n\\n    res := make([]int, len(nums))\\n    for i, v := range nums {\\n        res[i] = sums[v]\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 574134,
                "title": "java-1ms-99-time-o-n-using-counting-sort",
                "content": "\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] counts = new int[102];\\n        for (int n : nums) {\\n            counts[n+1] += 1;\\n        }\\n        for (int i = 1; i < counts.length; i++) {\\n            counts[i] = counts[i-1] + counts[i];\\n        }\\n\\n        int[] ans = new int[nums.length];\\n        for (int i = 0; i < ans.length; i++) {\\n            ans[i] = counts[nums[i]];\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] counts = new int[102];\\n        for (int n : nums) {\\n            counts[n+1] += 1;\\n        }\\n        for (int i = 1; i < counts.length; i++) {\\n            counts[i] = counts[i-1] + counts[i];\\n        }\\n\\n        int[] ans = new int[nums.length];\\n        for (int i = 0; i < ans.length; i++) {\\n            ans[i] = counts[nums[i]];\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 531206,
                "title": "100-explained-counting-sort-linear-swift-syntax",
                "content": "This is a play on Counting Sort. It is slightly modified at the end, but the idea is still there. \\nThere are MANY solutions already posted like this, but with almost no explanation.\\n\\nIf I am missing anything or incorrect, just leave a comment explaining why and how. Counting sort is one of those ones that is kind of hard to wrap your head around at first, and I recommend watching a video on counting sort to understand what is going on.\\n```\\n\\n```func smallerNumbersThanCurrent(_ nums: [Int]) -> [Int] {\\n    var countOfNums = [Int](repeating: 0, count: 101) \\n\\t\\t//since max in this case is 100, you could theoretically just find the max number, and use this instead, but it\\'s just easier in this case to write 101.\\n\\t\\t//all these numbers start with 0 occurences: [0,0,0,0.....,0,0] -length=100\\n    \\n\\tfor num in nums{\\n        countOfNums[num] += 1 //Each time you find a number, add this occurence to the counts array\\n\\t\\t\\t//[0,1,2,1,0,0,0,0,1] if you use a test case like [8,1,2,2,3]\\n\\t\\t\\t// 0 counts of 0, 1 count of 1, 2 of 2, 1 of 3, and 1 of 8.... all the way to 100...\\n    }\\n    var sumOfSmallerNums = 0     // start sum as 0, this will keep tally for us.\\n    var countOfSmallerNums = [Int](repeating: 0, count: 101) //number of smaller numbers than current\\n    \\n\\tfor i in 1...100 {\\n        sumOfSmallerNums += countOfNums[i-1] //this part of counting sort shifts all counts of a number to the right one, to get the correct amount of numbers smaller than it.\\n        countOfSmallerNums[i] = sumOfSmallerNums //the sum of all numbers smaller than the current number\\n    }\\n    var finalArray = [Int](repeating: 0, count: nums.count) //Note, these repeating 0 arrays aren\\'t necessary, but it takes out a block of If,Else statments to check if the sumOfSmallerNums == 0, I haven\\'t checked if it is actually any faster, but it looks cool. (Useful for people using languages without repeating array)\\n   \\n    for i in 0..<nums.count{\\n        finalArray[i] = countOfSmallerNums[nums[i]] //the answer array is the summ array in the order of the initial array\\n\\t\\t\\t//So for [8,1,2,2,3] it will return the number of smaller numbers in the same order... [4,0,1,1,3] in this case.\\n    }\\n    return finalArray\\n}",
                "solutionTags": [
                    "Swift",
                    "Counting Sort"
                ],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 528355,
                "title": "my-o-n-java-solution-beating-99",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] count = new int[101];\\n        for(int ele: nums){\\n            count[ele]++;\\n        }\\n        \\n        int[] res = new int[nums.length];\\n        int[] sums = new int[101];\\n        sums[0] = count[0];\\n        \\n        for(int i=1;i<=100;i++){\\n            sums[i] = count[i] + sums[i-1];\\n        }\\n        \\n        for(int i=0;i<nums.length;i++){\\n            res[i] = sums[nums[i]] - count[nums[i]];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] count = new int[101];\\n        for(int ele: nums){\\n            count[ele]++;\\n        }\\n        \\n        int[] res = new int[nums.length];\\n        int[] sums = new int[101];\\n        sums[0] = count[0];\\n        \\n        for(int i=1;i<=100;i++){\\n            sums[i] = count[i] + sums[i-1];\\n        }\\n        \\n        for(int i=0;i<nums.length;i++){\\n            res[i] = sums[nums[i]] - count[nums[i]];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 526039,
                "title": "javascript-solution",
                "content": "```\\nlet smallerNumbersThanCurrent = function(nums) {\\n    let sortNums = nums.slice().sort((a, b) => a - b),\\n        result = []\\n    for (let i = 0; i < nums.length; i ++) {\\n        result.push(sortNums.indexOf(nums[i]))\\n    }\\n    return result\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nlet smallerNumbersThanCurrent = function(nums) {\\n    let sortNums = nums.slice().sort((a, b) => a - b),\\n        result = []\\n    for (let i = 0; i < nums.length; i ++) {\\n        result.push(sortNums.indexOf(nums[i]))\\n    }\\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 525033,
                "title": "python-simple-solution",
                "content": "O(n^2) Time Solution\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(nums)):\\n            count = 0\\n            for j in range(len(nums)):\\n                if i != j and nums[i] > nums[j]:\\n                    count += 1\\n            res.append(count)\\n        \\n        return res\\n```\\n\\nO(nlog(n)) Time Solution\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        s, res, d = sorted(nums), [-1] * len(nums), {}\\n\\n        for i, e in enumerate(nums):\\n            if e in d: d[e].append(i)\\n            else: d[e] = [i]\\n        \\n        for i, e in enumerate(s):\\n            l = len(s[:i])\\n            for j in d[e]:\\n                if res[j] == -1:\\n                    res[j] = l\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        res = []\\n        for i in range(len(nums)):\\n            count = 0\\n            for j in range(len(nums)):\\n                if i != j and nums[i] > nums[j]:\\n                    count += 1\\n            res.append(count)\\n        \\n        return res\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        s, res, d = sorted(nums), [-1] * len(nums), {}\\n\\n        for i, e in enumerate(nums):\\n            if e in d: d[e].append(i)\\n            else: d[e] = [i]\\n        \\n        for i, e in enumerate(s):\\n            l = len(s[:i])\\n            for j in d[e]:\\n                if res[j] == -1:\\n                    res[j] = l\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524989,
                "title": "java-hash-count",
                "content": "```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++){\\n            arr[i] = nums[i];\\n        }\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int prev = nums[0], cnt = 0;\\n        map.put(prev, 0);\\n        for (int n : nums) {\\n            if (prev != n) {\\n                map.put(n, cnt);\\n                prev = n;\\n            }\\n            cnt++;\\n        }\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = map.get(arr[i]);\\n        }\\n        return arr;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for (int i = 0; i < nums.length; i++){\\n            arr[i] = nums[i];\\n        }\\n        Arrays.sort(nums);\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int prev = nums[0], cnt = 0;\\n        map.put(prev, 0);\\n        for (int n : nums) {\\n            if (prev != n) {\\n                map.put(n, cnt);\\n                prev = n;\\n            }\\n            cnt++;\\n        }\\n        for (int i = 0; i < arr.length; i++) {\\n            arr[i] = map.get(arr[i]);\\n        }\\n        return arr;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 524887,
                "title": "straight-forward-python-solution",
                "content": "```\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\tres = []\\n\\tfor x in nums:\\n\\t\\tres.append(sum([y < x for y in nums]))\\n\\treturn res\\n```",
                "solutionTags": [],
                "code": "```\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n\\tres = []\\n\\tfor x in nums:\\n\\t\\tres.append(sum([y < x for y in nums]))\\n\\treturn res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 524823,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] table = new int[101];\\n        int[] res = new int[nums.length];\\n        for(int n : nums){\\n            table[n]++;\\n        }\\n        int sum = 0;\\n        for(int i = 0; i < 101; i++){\\n            sum += table[i];\\n            table[i] = sum;\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == 0){\\n                res[i] = 0;\\n            }else{\\n                res[i] = table[nums[i] - 1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] table = new int[101];\\n        int[] res = new int[nums.length];\\n        for(int n : nums){\\n            table[n]++;\\n        }\\n        int sum = 0;\\n        for(int i = 0; i < 101; i++){\\n            sum += table[i];\\n            table[i] = sum;\\n        }\\n        for(int i = 0; i < nums.length; i++){\\n            if(nums[i] == 0){\\n                res[i] = 0;\\n            }else{\\n                res[i] = table[nums[i] - 1];\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3976912,
                "title": "brute-force-method-sorting-and-dictionary-method",
                "content": "# Brute Force Method: \\n\\n# Complexity\\n- Time complexity:\\nO(N^2) - It\\'s kind of inefficient with larger inputs!\\n\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        List = []\\n        for i in range(len(nums)):\\n            count = 0\\n            for j in range(len(nums)):\\n                if(j != i and nums[j] < nums[i]):\\n                    count = count + 1\\n            List.append(count)\\n        return List\\n\\n\\n```\\n\\n# Sorting and Dictionary Method: \\n\\n# Complexity\\n- Time Complexity: \\nO(NlogN)\\n\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        count_dict = {}\\n        result = []\\n        for i, num in enumerate(sorted_nums):\\n            if num not in count_dict:\\n                count_dict[num] = i\\n                \\n        for num in nums:\\n            result.append(count_dict[num])\\n            \\n        return result\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        List = []\\n        for i in range(len(nums)):\\n            count = 0\\n            for j in range(len(nums)):\\n                if(j != i and nums[j] < nums[i]):\\n                    count = count + 1\\n            List.append(count)\\n        return List\\n\\n\\n```\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        sorted_nums = sorted(nums)\\n        count_dict = {}\\n        result = []\\n        for i, num in enumerate(sorted_nums):\\n            if num not in count_dict:\\n                count_dict[num] = i\\n                \\n        for num in nums:\\n            result.append(count_dict[num])\\n            \\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3871615,
                "title": "c-python-brute-force-approach-too-easy-fully-explained",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSuppose we have the following input vector:\\n```\\nvector<int> nums = {8, 1, 2, 2, 3};\\n```\\n\\nNow, let\\'s go through the function step by step:\\n\\n1. Initialize an empty vector `ans` to store the results.\\n2. Start a loop to iterate through the `nums` vector.\\n   - First iteration: `i` is 0, `nums[i]` is 8.\\n     - Initialize `count` to 0.\\n     - Start another loop to compare the current element (`nums[i]`) with all the elements in the `nums` vector.\\n       - First comparison: `nums[i]` (which is 8) is greater than `nums[j]` (which is 8). It\\'s not smaller, so no change in `count`.\\n       - Second comparison: `nums[i]` (which is 8) is greater than `nums[j]` (which is 1). Increment `count` to 1.\\n       - Third comparison: `nums[i]` (which is 8) is greater than `nums[j]` (which is 2). Increment `count` to 2.\\n       - Fourth comparison: `nums[i]` (which is 8) is greater than `nums[j]` (which is 2). Increment `count` to 3.\\n       - Fifth comparison: `nums[i]` (which is 8) is greater than `nums[j]` (which is 3). Increment `count` to 4.\\n     - Push `count` (which is 4) into the `ans` vector.\\n   - Second iteration: `i` is 1, `nums[i]` is 1.\\n     - Initialize `count` to 0.\\n     - Start another loop to compare the current element (`nums[i]`) with all the elements in the `nums` vector.\\n       - First comparison: `nums[i]` (which is 1) is not greater than `nums[j]` (which is 8), so no change in `count`.\\n       - Second comparison: `nums[i]` (which is 1) is smaller than `nums[j]` (which is 1). It\\'s not greater, so no change in `count`.\\n       - Third comparison: `nums[i]` (which is 1) is smaller than `nums[j]` (which is 2). It\\'s not greater, so no change in `count`.\\n       - Fourth comparison: `nums[i]` (which is 1) is smaller than `nums[j]` (which is 2). It\\'s not greater, so no change in `count`.\\n       - Fifth comparison: `nums[i]` (which is 1) is smaller than `nums[j]` (which is 3). It\\'s not greater, so no change in `count`.\\n   - The loop continues for the remaining elements in the `nums` vector.\\n\\n3. The loop ends, and the `ans` vector contains [4, 0, 1, 1, 2], which represents the number of elements in the `nums` vector that are smaller than the corresponding element at each index.\\n\\n\\n# Complexity\\n- Time complexity:$$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            int count = 0;\\n            for(int j = 0; j < nums.size(); j++){\\n                if(nums[i] > nums[j])\\n                    count++;\\n            }\\n            ans.push_back(count);\\n        }\\n    return ans;\\n    }\\n};\\n```\\n``` Python []\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n            inc = 0\\n            for j in range(len(nums)):\\n                if nums[i] > nums[j]:\\n                    inc += 1\\n            ans.append(inc)\\n        return ans\\n```",
                "solutionTags": [
                    "C++",
                    "Python3"
                ],
                "code": "```\\nvector<int> nums = {8, 1, 2, 2, 3};\\n```\n``` C++ []\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i = 0; i < nums.size(); i++){\\n            int count = 0;\\n            for(int j = 0; j < nums.size(); j++){\\n                if(nums[i] > nums[j])\\n                    count++;\\n            }\\n            ans.push_back(count);\\n        }\\n    return ans;\\n    }\\n};\\n```\n``` Python []\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        ans = []\\n        for i in range(len(nums)):\\n            inc = 0\\n            for j in range(len(nums)):\\n                if nums[i] > nums[j]:\\n                    inc += 1\\n            ans.append(inc)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3743191,
                "title": "c-2-different-solution-naive-using-array-effficient-solution-hash-map-and-sorting",
                "content": "# Approach 1 : Using Array\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n     vector<int> result;\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n   \\n        for(int itr =0 ; itr<nums.size(); itr++){\\n            int count=0;\\n            for(int ptr=0 ; ptr < nums.size() ; ptr++){\\n                if(nums[itr]>nums[ptr]){\\n                    count++;\\n                }        \\n            }\\n            result.push_back(count);\\n        }\\n        return result;\\n    }\\n};\\n```\\n=========================================================\\n# Approach 2: Using hasmap and sorting\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlog(n)) + O(n) => O(nlong(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        //create a  map to  map value with it,\\'s piosition in sorted array\\n        map<int,int>mp;\\n        int n = nums.size();\\n        vector<int>snum = nums;\\n        \\n        sort(snum.begin(),snum.end());\\n        //to maintain the value of smallest index\\n        //map value of no with the sorted index\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            mp[snum[i]]=i;\\n        }\\n        \\n       //get the no of smallest no from current\\n        for(int i=0;i<n;i++)\\n            nums[i] = mp[nums[i]];\\n        \\n        return nums;\\n    }\\n};\\n```\\nIf you find any issue in understanding the solution then comment below, will try to help you.\\nIf you found my solution useful.\\nSo please do upvote and encourage me to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Merge Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n     vector<int> result;\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n   \\n        for(int itr =0 ; itr<nums.size(); itr++){\\n            int count=0;\\n            for(int ptr=0 ; ptr < nums.size() ; ptr++){\\n                if(nums[itr]>nums[ptr]){\\n                    count++;\\n                }        \\n            }\\n            result.push_back(count);\\n        }\\n        return result;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        //create a  map to  map value with it,\\'s piosition in sorted array\\n        map<int,int>mp;\\n        int n = nums.size();\\n        vector<int>snum = nums;\\n        \\n        sort(snum.begin(),snum.end());\\n        //to maintain the value of smallest index\\n        //map value of no with the sorted index\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            mp[snum[i]]=i;\\n        }\\n        \\n       //get the no of smallest no from current\\n        for(int i=0;i<n;i++)\\n            nums[i] = mp[nums[i]];\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3695117,
                "title": "how-many-numbers-are-smaller-than-the-current-number-java-solution-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        int arr[] = new int[nums.length];\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i]>nums[j]){\\n                    count++;\\n                }\\n            }\\n            arr[i] = count;\\n            count =0;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        int arr[] = new int[nums.length];\\n        int count = 0;\\n        for(int i=0; i<nums.length; i++){\\n            for(int j=0; j<nums.length; j++){\\n                if(nums[i]>nums[j]){\\n                    count++;\\n                }\\n            }\\n            arr[i] = count;\\n            count =0;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3384032,
                "title": "easy-to-understand-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nNeed to traverse the entire array to search smaller elements.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nChoose each element one by one as pivot , Compare it with the entire array to check how many elements are smaller and keep count of it. Then insert the count value in an another array at the position of the pivot element.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n^2)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        for(int i=0;i<n;i++){\\n            int pivot=nums[i];\\n            int cnt=0;\\n            int j=0;\\n            while(j<n){\\n                if(nums[j]<pivot){\\n                    cnt++;\\n                    j++;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            temp.push_back(cnt);\\n        }\\n        return temp;\\n    }\\n};\\n```\\n# Please Upvote if it is helpful \\u2B06\\uFE0F",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int n=nums.size();\\n        vector<int>temp;\\n        for(int i=0;i<n;i++){\\n            int pivot=nums[i];\\n            int cnt=0;\\n            int j=0;\\n            while(j<n){\\n                if(nums[j]<pivot){\\n                    cnt++;\\n                    j++;\\n                }\\n                else{\\n                    j++;\\n                }\\n            }\\n            temp.push_back(cnt);\\n        }\\n        return temp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3321438,
                "title": "o-n-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code has a time complexity of O(n) because it only iterates through the array three times. The first loop counts the number of occurrences of each element in the array, the second loop calculates the prefix sum of the count array, and the third loop calculates the number of elements that are smaller than the current element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a hash table to store the count of each element in the array.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] ans = new int[nums.length];\\n    int[] count = new int[101]; \\n    for(int i=0;i<nums.length ;i++){\\n        count[nums[i]]++;\\n    }\\n    for(int i=1;i<count.length;i++){\\n        count[i] += count[i-1];\\n    }\\n    for(int i=0;i<nums.length ;i++){\\n        if(nums[i] == 0){\\n            ans[i] = 0;\\n        }else{\\n            ans[i] = count[nums[i]-1];\\n        }\\n    }\\n    return ans;\\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] ans = new int[nums.length];\\n    int[] count = new int[101]; \\n    for(int i=0;i<nums.length ;i++){\\n        count[nums[i]]++;\\n    }\\n    for(int i=1;i<count.length;i++){\\n        count[i] += count[i-1];\\n    }\\n    for(int i=0;i<nums.length ;i++){\\n        if(nums[i] == 0){\\n            ans[i] = 0;\\n        }else{\\n            ans[i] = count[nums[i]-1];\\n        }\\n    }\\n    return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303330,
                "title": "3-approach-easy-c-solution-brute-force-better-sorting-optimized-approach",
                "content": "# Approach 1: Brute Force Approach\\n\\n# Complexity\\n- Time complexity: O(n^2)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n// Brute Force Approach\\n// Time complexity -> O(n^2) and Space -> O(n)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j] && i!=j)\\n                {\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\\n\\n# Approach 2: Better Approach [Using Sorting]\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n// Better Approach\\n// Time complexity -> O(nlogn) and Space -> O(n)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        vector<int> temp = nums;\\n        sort(temp.begin(),temp.end());\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            int low = 0;\\n            int high = temp.size()-1;\\n            while(low<=high)\\n            {\\n                int mid = low+(high-low)/2;\\n                if(temp[mid] == nums[i])\\n                {\\n                    high=mid-1;\\n                }\\n                else if(temp[mid] > nums[i])\\n                {\\n                    high=mid-1;\\n                }\\n                else\\n                {\\n                    low=mid+1;\\n                }\\n            }\\n            ans.push_back(low);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# Approach 3: Optimized Approach\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n\\n# Code\\n```\\n// Optimized Approach\\n// Time complexity -> O(n) and Space -> O(n)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        vector<int> temp(101);\\n        for(int i=0;i<nums.size();i++) \\n        {\\n            temp[nums[i]]++;  // Storing the frequency\\n        }\\n        for(int i=1;i<101;i++)\\n        {\\n            temp[i]=temp[i]+temp[i-1];\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                ans[i]=0;\\n            }\\n            else\\n            {\\n                ans[i]=temp[nums[i]-1];\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Sorting"
                ],
                "code": "```\\n// Brute Force Approach\\n// Time complexity -> O(n^2) and Space -> O(n)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            int count=0;\\n            for(int j=0;j<nums.size();j++)\\n            {\\n                if(nums[i]>nums[j] && i!=j)\\n                {\\n                    count++;\\n                }\\n            }\\n            ans.push_back(count);\\n        }\\n        return ans;\\n\\n    }\\n};\\n```\n```\\n// Better Approach\\n// Time complexity -> O(nlogn) and Space -> O(n)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans;\\n        vector<int> temp = nums;\\n        sort(temp.begin(),temp.end());\\n        for(int i = 0; i < nums.size(); i++)\\n        {\\n            int low = 0;\\n            int high = temp.size()-1;\\n            while(low<=high)\\n            {\\n                int mid = low+(high-low)/2;\\n                if(temp[mid] == nums[i])\\n                {\\n                    high=mid-1;\\n                }\\n                else if(temp[mid] > nums[i])\\n                {\\n                    high=mid-1;\\n                }\\n                else\\n                {\\n                    low=mid+1;\\n                }\\n            }\\n            ans.push_back(low);\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n// Optimized Approach\\n// Time complexity -> O(n) and Space -> O(n)\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans(nums.size());\\n        vector<int> temp(101);\\n        for(int i=0;i<nums.size();i++) \\n        {\\n            temp[nums[i]]++;  // Storing the frequency\\n        }\\n        for(int i=1;i<101;i++)\\n        {\\n            temp[i]=temp[i]+temp[i-1];\\n        }\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]==0)\\n            {\\n                ans[i]=0;\\n            }\\n            else\\n            {\\n                ans[i]=temp[nums[i]-1];\\n            }\\n        }\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196869,
                "title": "simple-easy-to-understand-solution-for-beginners",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        countnum = []\\n        for i in range(0,len(nums)):\\n            count = 0\\n            for j in range(0,len(nums)):\\n                if nums[j]<nums[i]:\\n                    count+=1\\n            countnum.append(count)\\n        return countnum\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        countnum = []\\n        for i in range(0,len(nums)):\\n            count = 0\\n            for j in range(0,len(nums)):\\n                if nums[j]<nums[i]:\\n                    count+=1\\n            countnum.append(count)\\n        return countnum\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153905,
                "title": "java-o-n-time-complexity-solution",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nTo create a prefix sum array \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        int []map = new int[101]; // 101->because of the given range ** otherwise a pass can be done to determine the largest value in the array \\n        for(int x : nums){\\n            map[x]++; \\n        }\\n        for(int i=1;i<map.length;i++){\\n            map[i] += map[i-1]; // prefix sum \\n        }\\n        int []res = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=0){\\n                res[i] = map[nums[i]-1]; // answer will be stored in previous index\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        \\n        int []map = new int[101]; // 101->because of the given range ** otherwise a pass can be done to determine the largest value in the array \\n        for(int x : nums){\\n            map[x]++; \\n        }\\n        for(int i=1;i<map.length;i++){\\n            map[i] += map[i-1]; // prefix sum \\n        }\\n        int []res = new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=0){\\n                res[i] = map[nums[i]-1]; // answer will be stored in previous index\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3100038,
                "title": "c-2-easiest-soln-map",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int length = nums.size();\\n        map <int, int> mp;\\n        vector <int> numsSorted = nums;\\n        sort(numsSorted.begin(), numsSorted.end());\\n\\n        for(int i = length-1; i >=0; i--){\\n            mp[numsSorted[i]] = i;\\n        }\\n        for(int i = 0; i < length; i++){\\n            nums[i] = mp[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n\\n```\\n\\n```\\n class Solution {\\n public:\\n     vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n     int last = nums.size()-1;   \\n     vector<int>  p;\\n     for(int i = 0 ; i<last+1 ; i++){\\n         int count = last ;\\n         for(int j=0;j<last+1;j++){\\n             if(i==j) continue;\\n             if(nums[j]>=nums[i])\\n                 count--;\\n         }\\n         p.push_back(count);\\n     }\\n     return p ; \\n     }\\n };\\n\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        int length = nums.size();\\n        map <int, int> mp;\\n        vector <int> numsSorted = nums;\\n        sort(numsSorted.begin(), numsSorted.end());\\n\\n        for(int i = length-1; i >=0; i--){\\n            mp[numsSorted[i]] = i;\\n        }\\n        for(int i = 0; i < length; i++){\\n            nums[i] = mp[nums[i]];\\n        }\\n        return nums;\\n    }\\n};\\n\\n```\n```\\n class Solution {\\n public:\\n     vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n     int last = nums.size()-1;   \\n     vector<int>  p;\\n     for(int i = 0 ; i<last+1 ; i++){\\n         int count = last ;\\n         for(int j=0;j<last+1;j++){\\n             if(i==j) continue;\\n             if(nums[j]>=nums[i])\\n                 count--;\\n         }\\n         p.push_back(count);\\n     }\\n     return p ; \\n     }\\n };\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3095057,
                "title": "solution-in-java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public  int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] result = new int[nums.length];\\n    int count;\\n        for (int i = 0; i < nums.length; i++) {\\n            count = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[i] > nums[j] && i != j) {\\n                    count++;\\n                }\\n                result[i] = count;\\n            }\\n        }\\n    return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public  int[] smallerNumbersThanCurrent(int[] nums) {\\n    int[] result = new int[nums.length];\\n    int count;\\n        for (int i = 0; i < nums.length; i++) {\\n            count = 0;\\n            for (int j = 0; j < nums.length; j++) {\\n                if (nums[i] > nums[j] && i != j) {\\n                    count++;\\n                }\\n                result[i] = count;\\n            }\\n        }\\n    return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2976589,
                "title": "java-easy-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int ans[]=new int[nums.length];\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]>nums[j]){\\n                    count+=1;\\n                }\\n            }\\n            ans[i]=count;\\n            count=0;\\n            }\\n            return ans;\\n\\n        }\\n        \\n    }\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int ans[]=new int[nums.length];\\n        int count=0;\\n        for(int i=0;i<nums.length;i++){\\n            for(int j=0;j<nums.length;j++){\\n                if(nums[i]>nums[j]){\\n                    count+=1;\\n                }\\n            }\\n            ans[i]=count;\\n            count=0;\\n            }\\n            return ans;\\n\\n        }\\n        \\n    }\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2924554,
                "title": "how-many-numbers-are-smaller-than-the-current-number-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int length = nums.length;\\n        int[] sorted = new int[length];\\n        System.arraycopy(nums, 0, sorted, 0, length);\\n        Arrays.sort(sorted);\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < length; i++) {\\n            if (i > 0 && sorted[i] == sorted[i - 1])\\n                continue;\\n            else\\n                map.put(sorted[i], i);\\n        }\\n        int[] smaller = new int[length];\\n        for (int i = 0; i < length; i++)\\n            smaller[i] = map.get(nums[i]);\\n        return smaller;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Hash Table",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int length = nums.length;\\n        int[] sorted = new int[length];\\n        System.arraycopy(nums, 0, sorted, 0, length);\\n        Arrays.sort(sorted);\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>();\\n        for (int i = 0; i < length; i++) {\\n            if (i > 0 && sorted[i] == sorted[i - 1])\\n                continue;\\n            else\\n                map.put(sorted[i], i);\\n        }\\n        int[] smaller = new int[length];\\n        for (int i = 0; i < length; i++)\\n            smaller[i] = map.get(nums[i]);\\n        return smaller;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2728451,
                "title": "c",
                "content": "Bruteforce Approach - gives 89ms runtime faster than 32% \\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans(nums.size(),0);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int cnt=0;\\n            for(int j= 0;j<nums.size();j++){\\n                if(nums[j]<nums[i]){\\n                    cnt++;\\n                }\\n            }\\n            ans[i]= cnt;\\n        }\\n        return ans;\\n    }\\n```\\nOptimal - 24ms runtime and 62% faster than other \\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> arr=nums;\\n        unordered_map<int, int> map1;\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<arr.size();i++){\\n            if(map1.find(arr[i])==map1.end()){\\n                map1[arr[i]]=i;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]=map1[nums[i]];\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> ans(nums.size(),0);\\n        \\n        for(int i=0;i<nums.size();i++){\\n            int cnt=0;\\n            for(int j= 0;j<nums.size();j++){\\n                if(nums[j]<nums[i]){\\n                    cnt++;\\n                }\\n            }\\n            ans[i]= cnt;\\n        }\\n        return ans;\\n    }\\n```\n```\\nvector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> arr=nums;\\n        unordered_map<int, int> map1;\\n        sort(arr.begin(),arr.end());\\n        for(int i=0;i<arr.size();i++){\\n            if(map1.find(arr[i])==map1.end()){\\n                map1[arr[i]]=i;\\n            }\\n        }\\n        for(int i=0;i<nums.size();i++){\\n            nums[i]=map1[nums[i]];\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2640168,
                "title": "python-easy-solution-in-o-n-log-n-complexity",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        a=sorted(nums)\\n        b=[]\\n        d=dict()\\n        for i in range(n):\\n            if a[i] not in d:\\n                d[a[i]]=i\\n        for i in nums:\\n            b.append(d[i])\\n        return b\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        a=sorted(nums)\\n        b=[]\\n        d=dict()\\n        for i in range(n):\\n            if a[i] not in d:\\n                d[a[i]]=i\\n        for i in nums:\\n            b.append(d[i])\\n        return b\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640136,
                "title": "python-simple-solution",
                "content": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        a=[]\\n        for i in range(n):\\n            c=0\\n            for j in range(n):\\n                if i!=j and nums[j]<nums[i]:\\n                    c+=1\\n            a.append(c)\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n        n=len(nums)\\n        a=[]\\n        for i in range(n):\\n            c=0\\n            for j in range(n):\\n                if i!=j and nums[j]<nums[i]:\\n                    c+=1\\n            a.append(c)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2601314,
                "title": "very-easy-solution-strictly-for-beginners",
                "content": "class Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n    \\n    #nums = [8,1,2,2,3]\\n        \\n        lst = []\\n        for i in nums:       # i will be get compared with every element in nums array\\n            \\n            c=0              # var to count numbers Are Smaller Than the Current Number i.e. i in our case\\n            \\n            for j in nums:  \\n                            # this loop is to iterate through every element of array\\n                if i > j:\\n\\t\\t\\t\\t   c+=1\\n        # for 1st occurence:  i=8 and j=8, 8 !> 8 : c=0\\n        # for 2nd  occurence: i=8 and j=1, 8 > 1 : c=1\\n        # for 3rd  occurence: i=8 and j=2, 8 > 2 : c=2\\n        # for 4th  occurence: i=8 and j=1, 8 > 2 : c=3\\n        \\n        # similarly will continue\\n                          \\n            lst.append(c)\\n        return lst\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t# Don\\'t Forget to UPvote if this solution helped you a bit.",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n    def smallerNumbersThanCurrent(self, nums: List[int]) -> List[int]:\\n    \\n    #nums = [8,1,2,2,3]\\n        \\n        lst = []\\n        for i in nums:       # i will be get compared with every element in nums array\\n            \\n            c=0              # var to count numbers Are Smaller Than the Current Number i.e. i in our case\\n            \\n            for j in nums:  \\n                            # this loop is to iterate through every element of array\\n                if i > j:\\n\\t\\t\\t\\t   c+=1\\n        # for 1st occurence:  i=8 and j=8, 8 !> 8 : c=0\\n        # for 2nd  occurence: i=8 and j=1, 8 > 1 : c=1\\n        # for 3rd  occurence: i=8 and j=2, 8 > 2 : c=2\\n        # for 4th  occurence: i=8 and j=1, 8 > 2 : c=3\\n        \\n        # similarly will continue\\n                          \\n            lst.append(c)\\n        return lst\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n\\t\\t# Don\\'t Forget to UPvote if this solution helped you a bit.",
                "codeTag": "Java"
            },
            {
                "id": 2585047,
                "title": "python3-one-line-solution-i-love-this-code",
                "content": "```\\nreturn [sum(1 for n in nums if n<i) for i in nums]\\n```",
                "solutionTags": [],
                "code": "```\\nreturn [sum(1 for n in nums if n<i) for i in nums]\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2511577,
                "title": "java-2-approach-easy-to-understand",
                "content": "```\\n   //Brute force approach O(N^2) time complexity\\n\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t\\tint ans[] = new int[nums.length];\\n\\t\\t\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int j = 0; j < nums.length; j++){\\n\\t\\t\\t\\t\\tif(i != j){\\n\\t\\t\\t\\t\\t   if(nums[i] > nums[j])\\n\\t\\t\\t\\t\\t\\t   count++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[i] = count;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n}\\n\\n\\t //optimized approach using hashmap O(NlogN) time complexity\\n\\t   public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t\\t   HashMap<Integer,Integer> map = new HashMap<>();\\n\\t\\t\\tint ans[] = new int[nums.length];\\n\\t\\t\\tint copyArr[] = nums.clone();\\n\\t\\t\\tArrays.sort(copyArr);\\n\\n\\t\\t\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\t\\t\\tmap.putIfAbsent(copyArr[i], i);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i < nums.length; i++){\\n\\t\\t\\t\\tans[i] = map.get(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n}",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\n   //Brute force approach O(N^2) time complexity\\n\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t\\tint ans[] = new int[nums.length];\\n\\t\\t\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\t\\t\\tint count = 0;\\n\\t\\t\\t\\tfor(int j = 0; j < nums.length; j++){\\n\\t\\t\\t\\t\\tif(i != j){\\n\\t\\t\\t\\t\\t   if(nums[i] > nums[j])\\n\\t\\t\\t\\t\\t\\t   count++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tans[i] = count;\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n}\\n\\n\\t //optimized approach using hashmap O(NlogN) time complexity\\n\\t   public int[] smallerNumbersThanCurrent(int[] nums) {\\n\\t\\t   HashMap<Integer,Integer> map = new HashMap<>();\\n\\t\\t\\tint ans[] = new int[nums.length];\\n\\t\\t\\tint copyArr[] = nums.clone();\\n\\t\\t\\tArrays.sort(copyArr);\\n\\n\\t\\t\\tfor(int i = 0; i < nums.length; i++){\\n\\t\\t\\t\\tmap.putIfAbsent(copyArr[i], i);\\n\\t\\t\\t}\\n\\t\\t\\tfor(int i=0; i < nums.length; i++){\\n\\t\\t\\t\\tans[i] = map.get(nums[i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2472761,
                "title": "easy-java-solution-hashset-beginner-friendly-best-method",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i = 0 ; i < arr.length; i ++){\\n            arr[i] = nums[i];\\n        }\\n        Arrays.sort(arr);\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        for(int i = 0 ; i < arr.length; i ++){\\n            al.add(arr[i]);\\n        }\\n        for(int i = 0 ; i < nums.length; i ++){\\n            arr[i] = al.indexOf(nums[i]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i = 0 ; i < arr.length; i ++){\\n            arr[i] = nums[i];\\n        }\\n        Arrays.sort(arr);\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n        for(int i = 0 ; i < arr.length; i ++){\\n            al.add(arr[i]);\\n        }\\n        for(int i = 0 ; i < nums.length; i ++){\\n            arr[i] = al.indexOf(nums[i]);\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2357495,
                "title": "java-easy-to-understand",
                "content": "```\\n\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] copy = nums.clone();\\n        Arrays.sort(copy);\\n        Map<Integer, Integer> map = new HashMap();\\n        for(int i = 0; i < copy.length; i++) {\\n            map.putIfAbsent(copy[i], i);\\n        }\\n        int ans[] = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            ans[i] = map.get(nums[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\tpublic int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] copy = nums.clone();\\n        Arrays.sort(copy);\\n        Map<Integer, Integer> map = new HashMap();\\n        for(int i = 0; i < copy.length; i++) {\\n            map.putIfAbsent(copy[i], i);\\n        }\\n        int ans[] = new int[nums.length];\\n        for(int i = 0; i < nums.length; i++) {\\n            ans[i] = map.get(nums[i]);\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2353154,
                "title": "java-1-ms-faster-than-99-99-o-n",
                "content": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[]map= new int[101];\\n        for(int i=0;i<nums.length;i++){\\n            map[nums[i]]++;\\n        }\\n        for(int i=1;i<map.length;i++){\\n            map[i]+=map[i-1];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=0 )\\n                nums[i]=map[nums[i]-1];\\n            else\\n                nums[i]=0;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[]map= new int[101];\\n        for(int i=0;i<nums.length;i++){\\n            map[nums[i]]++;\\n        }\\n        for(int i=1;i<map.length;i++){\\n            map[i]+=map[i-1];\\n        }\\n        for(int i=0;i<nums.length;i++){\\n            if(nums[i]!=0 )\\n                nums[i]=map[nums[i]-1];\\n            else\\n                nums[i]=0;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2348310,
                "title": "easy-typescript-solution-using-sort-and-map",
                "content": "```\\nfunction smallerNumbersThanCurrent(nums: number[]): number[] {\\n    const sorted = [...nums].sort((a, b) => a - b);\\n    return nums.map((v) => sorted.indexOf(v))\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction smallerNumbersThanCurrent(nums: number[]): number[] {\\n    const sorted = [...nums].sort((a, b) => a - b);\\n    return nums.map((v) => sorted.indexOf(v))\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2322900,
                "title": "easy-solution-with-map",
                "content": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int> &nums)\\n    {\\n        map<int, int> m;\\n        for (int i : nums)\\n            m[i]++;\\n        vector<int> ans;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            auto it = m.find(nums[i]);\\n            auto xit = m.begin();\\n            int x = 0;\\n            while (xit != it)\\n            {\\n                x += (xit->second);\\n                xit++;\\n            }\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int> &nums)\\n    {\\n        map<int, int> m;\\n        for (int i : nums)\\n            m[i]++;\\n        vector<int> ans;\\n        for (int i = 0; i < nums.size(); i++)\\n        {\\n            auto it = m.find(nums[i]);\\n            auto xit = m.begin();\\n            int x = 0;\\n            while (xit != it)\\n            {\\n                x += (xit->second);\\n                xit++;\\n            }\\n            ans.push_back(x);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2319580,
                "title": "python-98-simple",
                "content": "```\\ndef get_num_smaller(array):\\n\\n    dict_nums = {}\\n\\n\\n    for x, number in enumerate(sorted(array)):\\n        if number not in dict_nums:\\n            dict_nums[number] = x\\n\\n    numbers_less_than = []\\n    for x, number in enumerate(array):\\n        numbers_less_than.append(dict_nums[number])\\n\\n    return numbers_less_than\\n\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef get_num_smaller(array):\\n\\n    dict_nums = {}\\n\\n\\n    for x, number in enumerate(sorted(array)):\\n        if number not in dict_nums:\\n            dict_nums[number] = x\\n\\n    numbers_less_than = []\\n    for x, number in enumerate(array):\\n        numbers_less_than.append(dict_nums[number])\\n\\n    return numbers_less_than\\n\\t```",
                "codeTag": "Python3"
            },
            {
                "id": 2089224,
                "title": "c-solution-faster-than-83-01-runtime-8ms-memory-10-4mb",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> v;\\n        vector<int> idx;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            v.push_back(nums[i]);\\n        }\\n        sort(v.begin(), v.end());\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            auto it = find(v.begin(), v.end(), nums[i]);\\n            int index = distance(v.begin(), it);\\n            idx.push_back(index);\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) {\\n        vector<int> v;\\n        vector<int> idx;\\n        \\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            v.push_back(nums[i]);\\n        }\\n        sort(v.begin(), v.end());\\n        for(int i=0; i<nums.size(); i++)\\n        {\\n            auto it = find(v.begin(), v.end(), nums[i]);\\n            int index = distance(v.begin(), it);\\n            idx.push_back(index);\\n        }\\n        return idx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1906387,
                "title": "c-map",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n        map<int, int> m;\\n        for(int& n : nums)\\n        {\\n            m[n]++;\\n        }\\n        int count = 0;\\n        for(auto& it : m)\\n        {\\n            int buf = it.second;\\n            it.second = count;\\n            count += buf;\\n        }\\n        for(int& n : nums)\\n        {\\n            n = m[n];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> smallerNumbersThanCurrent(vector<int>& nums) \\n    {\\n        map<int, int> m;\\n        for(int& n : nums)\\n        {\\n            m[n]++;\\n        }\\n        int count = 0;\\n        for(auto& it : m)\\n        {\\n            int buf = it.second;\\n            it.second = count;\\n            count += buf;\\n        }\\n        for(int& n : nums)\\n        {\\n            n = m[n];\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1666828,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1570213,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1673729,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1789511,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1575209,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1575684,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1575623,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1676998,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 2063794,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1927786,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1666828,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1570213,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1673729,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1789511,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1575209,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1575684,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1575623,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1676998,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 2063794,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            },
            {
                "id": 1927786,
                "content": [
                    {
                        "username": "ccristiany339",
                        "content": "You don\\'t need to check for `j != i`, since `nums[j]` is never less than `nums[i]` when `j = i`"
                    },
                    {
                        "username": "JustinAdams",
                        "content": "Good catch, love that"
                    },
                    {
                        "username": "user6536C",
                        "content": "\\'\\'\\'\\nreturn [sorted(nums).index(i) for i in nums]"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "wisdomkhan",
                        "content": "Is there a O(N) solution?"
                    },
                    {
                        "username": "AstroDeveloper1010",
                        "content": "[@mukadas026](/mukadas026) what will you do for same numbers? [... ,2, 2, ...] according to you the answer would be [... m, m + 1, ...] which is wrong since both are equal"
                    },
                    {
                        "username": "venkatsc",
                        "content": "I used frequency and running sum to solve it in O(N)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/3556942/100-java-o-n/"
                    },
                    {
                        "username": "Basavaraj_Devaramani",
                        "content": "Yes, using frequency array we can solve it in O(N)"
                    },
                    {
                        "username": "mayank-01",
                        "content": "[@Vasee](/Vasee) yes, same question"
                    },
                    {
                        "username": "Vasee",
                        "content": "[@mukadas026](/mukadas026) won\\'t it give wrong result if there are multiple numbers having same values in array."
                    },
                    {
                        "username": "mukadas026",
                        "content": "yes, if you create a duplicate array that is sorted , the indices are the num of elements less than that target number.  You can check out my solution in javascript"
                    },
                    {
                        "username": "Nikhil_Pall",
                        "content": "// Java Solution : \\nclass Solution {\\n    public int[] smallerNumbersThanCurrent(int[] nums) {\\n        int[] arr = new int[nums.length];\\n        for(int i=0; i<nums.length; i++){\\n            int length=0;\\n            int num = nums[i];\\n            for(int j=0; j<nums.length; j++){\\n                if(num-nums[j]>0 && num!=nums[j]){\\n                    length = length + 1;\\n                }\\n            }\\n            arr[i] = length;\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "jackal_07",
                        "content": "madarchod yaha solution post maat kar"
                    },
                    {
                        "username": "tzuyi0817",
                        "content": "\\tvar smallerNumbersThanCurrent = function(nums) {\\n\\t\\treturn nums.map(curr => nums.filter(num => curr > num).length)\\n\\t};"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "sid7549",
                        "content": "The bounds are 0 to 100, we can use hashing to keep the count of each element in an array of size 101. Then calculate the cummulative frequency at each element. store the counts in a new array and return it."
                    },
                    {
                        "username": "sahuprashant29",
                        "content": "![image](https://assets.leetcode.com/users/images/7031491f-1739-450a-9355-aa778a2130c1_1628273474.685189.png)\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "# Click Only if U wanna learn something new | Using Hashtable in O(n)\\nhttps://leetcode.com/problems/how-many-numbers-are-smaller-than-the-current-number/solutions/2203191/click-only-if-u-wanna-learn-something-new-using-hashtable-in-o-n/"
                    },
                    {
                        "username": "saikat2300",
                        "content": "you don\\'t need to count each letter of a word. just count the number of words of each sentence"
                    },
                    {
                        "username": "Shaswat_Pandey",
                        "content": "Can anyone guide me ?\\nOn declaring the size of my frequency array to (100) it is giving \"heap-buffer overflow error\" while submitting the same code .  for this Test case :-\\n[37,64,63,2,41,78,51,36,2,20,25,41,72,100,17,43,54,27,34,86,12,48,70,44,87,68,62,98,68,30,8,92,5,10]\\nBut on initializing the value of my frequency array to (102) it gets submitted easily . without any error.\\n\\nWhy this is happening , if the max value of nums[i] is given as 2 <= nums[i] <= 100.   Then why it is demanding the size to be initialized with 102 or greater values than 100?\\nAnd on initializing the frequency array with size of 101 its performance is increased i.e., on 102 -> 18 ms\\nand on 101 -> 7ms.\\n\\nThanks!"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Number of Events That Can Be Attended II",
        "question_content": "<p>You are given an array of <code>events</code> where <code>events[i] = [startDay<sub>i</sub>, endDay<sub>i</sub>, value<sub>i</sub>]</code>. The <code>i<sup>th</sup></code> event starts at <code>startDay<sub>i</sub></code><sub> </sub>and ends at <code>endDay<sub>i</sub></code>, and if you attend this event, you will receive a value of <code>value<sub>i</sub></code>. You are also given an integer <code>k</code> which represents the maximum number of events you can attend.</p>\n\n<p>You can only attend one event at a time. If you choose to attend an event, you must attend the <strong>entire</strong> event. Note that the end day is <strong>inclusive</strong>: that is, you cannot attend two events where one of them starts and the other ends on the same day.</p>\n\n<p>Return <em>the <strong>maximum sum</strong> of values that you can receive by attending events.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60048-pm.png\" style=\"width: 400px; height: 103px;\" /></p>\n\n<pre>\n<strong>Input:</strong> events = [[1,2,4],[3,4,3],[2,3,1]], k = 2\n<strong>Output:</strong> 7\n<strong>Explanation: </strong>Choose the green events, 0 and 1 (0-indexed) for a total value of 4 + 3 = 7.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<p><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60150-pm.png\" style=\"width: 400px; height: 103px;\" /></p>\n\n<pre>\n<strong>Input:</strong> events = [[1,2,4],[3,4,3],[2,3,10]], k = 2\n<strong>Output:</strong> 10\n<strong>Explanation:</strong> Choose event 2 for a total value of 10.\nNotice that you cannot attend any other event as they overlap, and that you do <strong>not</strong> have to attend k events.</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<p><strong><img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-60703-pm.png\" style=\"width: 400px; height: 126px;\" /></strong></p>\n\n<pre>\n<strong>Input:</strong> events = [[1,1,1],[2,2,2],[3,3,3],[4,4,4]], k = 3\n<strong>Output:</strong> 9\n<strong>Explanation:</strong> Although the events do not overlap, you can only attend 3 events. Pick the highest valued three.</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= k &lt;= events.length</code></li>\n\t<li><code>1 &lt;= k * events.length &lt;= 10<sup>6</sup></code></li>\n\t<li><code>1 &lt;= startDay<sub>i</sub> &lt;= endDay<sub>i</sub> &lt;= 10<sup>9</sup></code></li>\n\t<li><code>1 &lt;= value<sub>i</sub> &lt;= 10<sup>6</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 1052442,
                "title": "simple-dp-solution-recursion-memoization-c",
                "content": "**Solution:**\\n\\n* First sort the events in ascending order according to starting time and if equal then by ending time.\\n\\nNow start traversing the events, at each event we have two options:\\n1. Skip this event and move to next event, no change in profit.\\n2. Attend this event add its profit and move to next such event whose starting time is greater than the ending time of this event.\\n\\nCompare the profits made by these two choices and return the maximum value of the two.\\n\\n**Code (Recursion without memoization (TLE)):**\\n\\n```\\nint solve(vector<vector<int>>& events, int n, int pos, int k)\\n{\\n        int i;\\n        \\n        if(pos >= n || k == 0)\\n            return 0;\\n        \\n        // finding the next event which we can attend\\n        for(i = pos + 1; i < n; i++)\\n            if(events[i][0] > events[pos][1])\\n                break;\\n        \\n       return max(solve(events, n, pos+1, k), events[pos][2] + solve(events, n, i, k-1));\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) \\n    {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n\\n        return solve(events, n, 0, k);\\n    }\\n```\\n\\n**Code (Memoized (Accepted)):**\\n\\n```\\nint solve(vector<vector<int>>&dp, vector<vector<int>>& events, int n, int pos, int k)\\n{\\n        int i;\\n        \\n        if(pos >= n || k == 0)\\n            return 0;\\n        \\n        if(dp[pos][k] != -1)\\n            return dp[pos][k];\\n        \\n        // finding the next event which we can attend\\n        for(i = pos + 1; i < n; i++)\\n            if(events[i][0] > events[pos][1])\\n                break;\\n        \\n       return dp[pos][k] = max(solve(dp, events, n, pos+1, k), events[pos][2] + solve(dp, events, n, i, k-1));\\n\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) \\n    {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        \\n        return solve(dp, events, n, 0, k);\\n    }\\n```\\n\\n**Note:**\\n\\n```\\nfor(i = pos + 1; i < n; i++)\\n            if(events[i][0] > events[pos][1])\\n                break;\\n```\\n        \\nThis can be O(n) atmax hence we can optimise it by using binary search.\\n```\\nvector<int> temp = {events[pos][1],INT_MAX,INT_MAX};\\ni = upper_bound(events.begin()+pos+1, events.end(), temp)-events.begin();\\n```\\n",
                "solutionTags": [],
                "code": "```\\nint solve(vector<vector<int>>& events, int n, int pos, int k)\\n{\\n        int i;\\n        \\n        if(pos >= n || k == 0)\\n            return 0;\\n        \\n        // finding the next event which we can attend\\n        for(i = pos + 1; i < n; i++)\\n            if(events[i][0] > events[pos][1])\\n                break;\\n        \\n       return max(solve(events, n, pos+1, k), events[pos][2] + solve(events, n, i, k-1));\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) \\n    {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n\\n        return solve(events, n, 0, k);\\n    }\\n```\n```\\nint solve(vector<vector<int>>&dp, vector<vector<int>>& events, int n, int pos, int k)\\n{\\n        int i;\\n        \\n        if(pos >= n || k == 0)\\n            return 0;\\n        \\n        if(dp[pos][k] != -1)\\n            return dp[pos][k];\\n        \\n        // finding the next event which we can attend\\n        for(i = pos + 1; i < n; i++)\\n            if(events[i][0] > events[pos][1])\\n                break;\\n        \\n       return dp[pos][k] = max(solve(dp, events, n, pos+1, k), events[pos][2] + solve(dp, events, n, i, k-1));\\n\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) \\n    {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        \\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        \\n        return solve(dp, events, n, 0, k);\\n    }\\n```\n```\\nfor(i = pos + 1; i < n; i++)\\n            if(events[i][0] > events[pos][1])\\n                break;\\n```\n```\\nvector<int> temp = {events[pos][1],INT_MAX,INT_MAX};\\ni = upper_bound(events.begin()+pos+1, events.end(), temp)-events.begin();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3766452,
                "title": "c-faster-than-95-explained-2d-dp-memoization-binary-search-clean-code",
                "content": "# PLEASE DO UPVOTE!!!!!\\n\\n**CONNECT WITH ME ON LINKEDIN :  https://www.linkedin.com/in/md-kamran-55b98521a/**\\n\\n# Intuition\\n\\nIntuition is very simple, first we will sort our vector according to the start values of events, then we have two options with us either we can attend the event, or we can simply not attend that particular event, incase if we attend an event, we get that particular value of attending the event (ie, events[index][2]). Also,we can only attend a new event after this particular event gets over, so we have to search an event such that its starting time is greater than our current event\\'s ending time which we have considered, we will take the maximum one of this two cases.\\n\\n**Tip : You can a use a for loop too for searching the next index to be considered but that will give a TLE verdict, thats why we have to use Binary Search Here**\\n\\n\\n# Approach\\n\\n1. Sort the Vector According to Starting Time (ie. events[index][0])\\n2. Initialize DP function\\n3. if we are choosing an event then add its value to c1 and search a new index whose starting time is greater than current ending time, and decrease k by 1\\n4. if not choosing the event simply increase index value\\n5. Take Maximum of these two cases\\n\\n\\n# Time Complexity \\n\\n**O(N(K + log(N)))**, N is size of the array, K is maximum events allowed to attend\\n\\n# Space Complexity\\n\\n**O(NK)**, N is size of the array, K is maximum events allowed to attend\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nint BS(int index,vector<vector<int>>&events,int value)\\n{\\n    int lo = index;\\n    int hi = events.size()-1;\\n    int req = -1;\\n    while(hi>=lo)\\n    {\\n      int mid = lo+(hi-lo)/2;\\n      if(events[mid][0] > value)\\n      {\\n        req = mid;\\n        hi = mid-1;\\n      }\\n      else lo = mid+1;\\n    }\\n    return req;\\n}\\n\\nint helper(int i,vector<vector<int>>&events,int k, vector<vector<int>>&dp)\\n{\\n  if(i >= events.size() || k == 0 || i == -1) return 0;\\n  if(dp[i][k] != -1) return dp[i][k];\\n\\n  int index = BS(i+1,events,events[i][1]);\\n\\n  int c1 = events[i][2] + helper(index,events,k-1,dp);\\n  int c2 = helper(i+1,events,k,dp);\\n\\n  return dp[i][k] = max(c1,c2);\\n}\\n\\n\\n int maxValue(vector<vector<int>>& events, int k){\\n\\n    sort(events.begin(),events.end());\\n    int n = events.size();\\n    vector<vector<int>>dp(n+5,vector<int>(k+1,-1));\\n    return helper(0,events,k,dp);\\n  }\\n};\\n\\n```\\n![b62ab1be-232a-438f-9524-7d8ca4dbd5fe_1675328166.1161866.png](https://assets.leetcode.com/users/images/8d5343b1-0eb4-4111-a914-40ce968fd034_1675389764.2273676.png)",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nint BS(int index,vector<vector<int>>&events,int value)\\n{\\n    int lo = index;\\n    int hi = events.size()-1;\\n    int req = -1;\\n    while(hi>=lo)\\n    {\\n      int mid = lo+(hi-lo)/2;\\n      if(events[mid][0] > value)\\n      {\\n        req = mid;\\n        hi = mid-1;\\n      }\\n      else lo = mid+1;\\n    }\\n    return req;\\n}\\n\\nint helper(int i,vector<vector<int>>&events,int k, vector<vector<int>>&dp)\\n{\\n  if(i >= events.size() || k == 0 || i == -1) return 0;\\n  if(dp[i][k] != -1) return dp[i][k];\\n\\n  int index = BS(i+1,events,events[i][1]);\\n\\n  int c1 = events[i][2] + helper(index,events,k-1,dp);\\n  int c2 = helper(i+1,events,k,dp);\\n\\n  return dp[i][k] = max(c1,c2);\\n}\\n\\n\\n int maxValue(vector<vector<int>>& events, int k){\\n\\n    sort(events.begin(),events.end());\\n    int n = events.size();\\n    vector<vector<int>>dp(n+5,vector<int>(k+1,-1));\\n    return helper(0,events,k,dp);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052536,
                "title": "c-2d-dp",
                "content": "This sounds like Knapsack 1/0 problem:\\n- For each meeting, either take it of skip it.\\n\\t- If you take it, collect the value\\n\\t- Decrement `k`\\n\\t- Skip all conflicting meetings so that `i` points to the next meeting we can attend.\\n\\nFor Knapsack to work, we need to sort meetings first by the start date, so we only move forward in our search.\\n\\nTo speed things up, we need to memoise our results based on the next meeting we can attend, and `k`. In addition, we can use binary search to find the next meeting that we can attend.\\n\\n```cpp\\nvector<vector<int>> dp;\\nint dfs(vector<vector<int>>& e, int i, int k) {\\n    if (k == 0 || i >= e.size())\\n        return 0;\\n    if (dp[i][k] != -1) \\n        return dp[i][k];\\n    auto j = upper_bound(begin(e) + i, end(e), e[i][1], \\n        [](int t, const vector<int> &v) {return v[0] > t;}) - begin(e);\\n    return dp[i][k] = max(e[i][2] + dfs(e, j, k - 1), dfs(e, i + 1, k));\\n}\\nint maxValue(vector<vector<int>>& events, int k) {\\n    dp = vector<vector<int>>(events.size(), vector<int>(k + 1, -1));\\n    sort(begin(events), end(events));\\n    return dfs(events, 0, k);\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nvector<vector<int>> dp;\\nint dfs(vector<vector<int>>& e, int i, int k) {\\n    if (k == 0 || i >= e.size())\\n        return 0;\\n    if (dp[i][k] != -1) \\n        return dp[i][k];\\n    auto j = upper_bound(begin(e) + i, end(e), e[i][1], \\n        [](int t, const vector<int> &v) {return v[0] > t;}) - begin(e);\\n    return dp[i][k] = max(e[i][2] + dfs(e, j, k - 1), dfs(e, i + 1, k));\\n}\\nint maxValue(vector<vector<int>>& events, int k) {\\n    dp = vector<vector<int>>(events.size(), vector<int>(k + 1, -1));\\n    sort(begin(events), end(events));\\n    return dfs(events, 0, k);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1052581,
                "title": "python-dp",
                "content": "# **Explanation**\\nFor each meeting,\\nfind the maximum value we can get before this meeting starts.\\nRepeatly doing this `K` times.\\n<br>\\n\\n# **Complexity**\\nTime `O(knlogn)`, can be improved to O(nk) like Knapsack problem\\nSpace `O(n)`\\n<br>\\n\\n**Python**\\n```py\\n    def maxValue(self, A, K):\\n        A.sort(key=lambda sev: sev[1])\\n        dp, dp2 = [[0, 0]], [[0, 0]]\\n        for k in xrange(K):\\n            for s, e, v in A:\\n                i = bisect.bisect(dp, [s]) - 1\\n                if dp[i][1] + v > dp2[-1][1]:\\n                    dp2.append([e, dp[i][1] + v])\\n            dp, dp2 = dp2, [[0, 0]]\\n        return dp[-1][-1]\\n```\\n",
                "solutionTags": [],
                "code": "```py\\n    def maxValue(self, A, K):\\n        A.sort(key=lambda sev: sev[1])\\n        dp, dp2 = [[0, 0]], [[0, 0]]\\n        for k in xrange(K):\\n            for s, e, v in A:\\n                i = bisect.bisect(dp, [s]) - 1\\n                if dp[i][1] + v > dp2[-1][1]:\\n                    dp2.append([e, dp[i][1] + v])\\n            dp, dp2 = dp2, [[0, 0]]\\n        return dp[-1][-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3766471,
                "title": "fast-solution-without-binary-search-very-easy-explanation-c-java-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe can see there are 2 choices we  attend the meeting or we do not attend the meeting if the meeting interval do not overlap or not in the previous meeting range  and if the previous meeting end is greater than or equal to start we have only one option we cant attend the meeting. \\n\\nFor detailed explanation you can refer to my youtube channel (Hindi Language)\\nhttps://youtu.be/fig222WmiIY\\n or link in my profile.Here,you can find any solution in playlists monthwise from June 2023 with detailed explanation.i upload daily leetcode solution video with short and precise explanation (5-10) minutes.\\nor\\nsearch \\uD83D\\uDC49 `Maximum Number of Events That Can Be Attended II by Let\\'s Code Together` on youtube\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n1. The `maxValue` function is the entry point of the solution. It takes a vector of events and the value of k as input. The events are sorted in ascending order based on their start time.\\n\\n2. The variable `n` is assigned the total number of events.\\n\\n3. The `dp` vector is resized to have `n` rows and `k + 1` columns. It is used for memoization, where `dp[i][j]` represents the maximum value that can be achieved by considering events from index `i` onwards with `j` remaining slots.\\n\\n4. The `solve` function is a recursive helper function that calculates the maximum value by considering different combinations of events.\\n\\n5. The base cases of the recursion are as follows:\\n   - If we have considered all events (` i== events.size()`), we return 0.\\n   - If we have used up all available slots (`k == 0`), we return 0.\\n   - If the current event\\'s start time is less than or equal to the previous event\\'s end time (`events[i][0] <= end`), we skip this event and move to the next one.\\n\\n6. If the maximum value for the current state (`dp[i][k]`) has already been calculated, we return it.\\n\\n7. Otherwise, we calculate the maximum value by considering two possibilities:\\n   - Attend the current event and recursively solve for the remaining events with `k-1` slots, updating the end time to the end time of the current event.\\n   - Skip the current event and recursively solve for the remaining events with `k` slots, keeping the end time unchanged.\\n\\n8. We take the maximum of the above two possibilities and store it in `choices`. Finally, we update `dp[i][k]` with the calculated result and return `choices`.\\n\\nThis approach effectively explores all possible combinations of events while considering the constraints of the problem, and it uses memoization to avoid redundant calculations. The overall result is the maximum value that can be achieved by attending the events.\\n\\nNote :-For those who are not understanding code `\\n if( events[i][0] <= end ) return solve( events, i + 1 , k , end )` here \\uD83D\\uDC49 solve function ensures that we only consider valid events that can be attended after the previous event ends. This is accomplished by checking if prev_ending_time is smaller than the start time of the next event. If it is not, we skip the calculation of solve (i+ 1, k+1, events[i][1]) and only consider the option of skipping the current event.\\n\\n# Complexity\\n- Time complexity:$$O(n*k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n*k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>>dp;\\n//dp[n][k+1]\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin() , events.end());\\n        int n = events.size();\\n        dp.resize( n, vector<int>( k + 1, -1));\\n        return solve(events , 0 , k , 0);\\n    }\\n    int solve(vector<vector<int>>& events,int i, int k,int end){\\n        if(i==events.size()) return 0;\\n\\n        if( k==0 ) return 0;\\n\\n        if( events[i][0] <= end ) return solve( events, i + 1 , k , end );\\n\\n        if( dp[i][k] != -1) return dp[i][k];\\n\\n        int choices= max ( events[i][2] + solve(events, i + 1, k - 1 , events[i][1] ),  solve(events , i + 1 , k , end ) );\\n        return dp[i][k] = choices;\\n    }\\n};\\n```\\n\\n\\n![images.jpeg](https://assets.leetcode.com/users/images/880b2b9b-e032-4ee1-af0e-0bad56089bd4_1689394082.3438835.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>>dp;\\n//dp[n][k+1]\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin() , events.end());\\n        int n = events.size();\\n        dp.resize( n, vector<int>( k + 1, -1));\\n        return solve(events , 0 , k , 0);\\n    }\\n    int solve(vector<vector<int>>& events,int i, int k,int end){\\n        if(i==events.size()) return 0;\\n\\n        if( k==0 ) return 0;\\n\\n        if( events[i][0] <= end ) return solve( events, i + 1 , k , end );\\n\\n        if( dp[i][k] != -1) return dp[i][k];\\n\\n        int choices= max ( events[i][2] + solve(events, i + 1, k - 1 , events[i][1] ),  solve(events , i + 1 , k , end ) );\\n        return dp[i][k] = choices;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766636,
                "title": "c-dp-binary-search",
                "content": "# Code\\n```\\n//WITHOUT BINARY SEARCH\\nclass Solution {\\npublic:\\n    int help(vector<vector<int>>&e,int k,int i,vector<vector<int>>&dp){\\n        if(i>=e.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int ans = help(e,k,i+1,dp);\\n        if(k){\\n            int in = e.size();\\n            for(int j=i+1;j<e.size();j++){\\n                if(e[j][0]>e[i][1]){\\n                    in = j;\\n                    break;\\n                }\\n            }\\n            ans = max(ans, e[i][2] + help(e,k-1,in,dp));\\n        }\\n        return dp[i][k] = ans;\\n    }\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        sort(e.begin(),e.end());\\n        vector<vector<int>>dp(e.size(),vector<int>(k+1,-1));\\n        return help(e,k,0,dp);\\n    }\\n};\\n```\\n```\\n//WITH BINARY SEARCH\\nclass Solution {\\npublic:\\n    int help(vector<vector<int>>&e,int k,int i,vector<vector<int>>&dp){\\n        if(i>=e.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int ans = help(e,k,i+1,dp);\\n        if(k){\\n           vector<int> temp = {e[i][1],INT_MAX,INT_MAX};\\n           int in = upper_bound(e.begin(), e.end(), temp)-e.begin();\\n           ans = max(ans, e[i][2] + help(e,k-1,in,dp));\\n        }\\n        return dp[i][k] = ans;\\n    }\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        sort(e.begin(),e.end());\\n        vector<vector<int>>dp(e.size(),vector<int>(k+1,-1));\\n        return help(e,k,0,dp);\\n    }\\n};\\n```\\n![upvote (2).jpg](https://assets.leetcode.com/users/images/2712f7f9-bfd4-4434-a011-8de4329a02ca_1689391643.5368514.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Recursion",
                    "Sorting"
                ],
                "code": "```\\n//WITHOUT BINARY SEARCH\\nclass Solution {\\npublic:\\n    int help(vector<vector<int>>&e,int k,int i,vector<vector<int>>&dp){\\n        if(i>=e.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int ans = help(e,k,i+1,dp);\\n        if(k){\\n            int in = e.size();\\n            for(int j=i+1;j<e.size();j++){\\n                if(e[j][0]>e[i][1]){\\n                    in = j;\\n                    break;\\n                }\\n            }\\n            ans = max(ans, e[i][2] + help(e,k-1,in,dp));\\n        }\\n        return dp[i][k] = ans;\\n    }\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        sort(e.begin(),e.end());\\n        vector<vector<int>>dp(e.size(),vector<int>(k+1,-1));\\n        return help(e,k,0,dp);\\n    }\\n};\\n```\n```\\n//WITH BINARY SEARCH\\nclass Solution {\\npublic:\\n    int help(vector<vector<int>>&e,int k,int i,vector<vector<int>>&dp){\\n        if(i>=e.size())return 0;\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        int ans = help(e,k,i+1,dp);\\n        if(k){\\n           vector<int> temp = {e[i][1],INT_MAX,INT_MAX};\\n           int in = upper_bound(e.begin(), e.end(), temp)-e.begin();\\n           ans = max(ans, e[i][2] + help(e,k-1,in,dp));\\n        }\\n        return dp[i][k] = ans;\\n    }\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        sort(e.begin(),e.end());\\n        vector<vector<int>>dp(e.size(),vector<int>(k+1,-1));\\n        return help(e,k,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052548,
                "title": "python-dp-binary-search",
                "content": "**Intuition:**\\nSort the events with respect to starting time. If you attend the current event then binary search the first event which you could attend after this. If you don\\'t attend the current event, then just check the next one after.\\n\\n**Top-Down Solution:**\\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:        \\n        events.sort()\\n        starts = [x for x,y,z in events]\\n        \\n        @lru_cache(None)\\n        def dp(idx, k):\\n            if k == 0 or idx >= len(events):\\n                return 0\\n            next_event = bisect_right(starts, events[idx][1])\\n            return max(dp(idx+1, k), events[idx][2] + dp(next_event, k-1))\\n    \\n        return dp(0,k)\\n```\\n\\n**Bottom-Up-Solution:**\\n```\\n    def maxValue(self, events: List[List[int]], k: int) -> int:        \\n        n = len(events)\\n        dp = [[0 for _ in range(k + 1)] for _ in range(n+1)]\\n        events.sort()\\n        starts = [x for x,y,z in events]\\n\\n        for i in range(n-1, -1, -1):\\n            for j in range(1, k+1):\\n                next_event = bisect_right(starts, events[i][1])\\n                dp[i][j] = max(dp[i+1][j], events[i][2] + dp[next_event][j-1])\\n        \\n        return dp[0][k]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:        \\n        events.sort()\\n        starts = [x for x,y,z in events]\\n        \\n        @lru_cache(None)\\n        def dp(idx, k):\\n            if k == 0 or idx >= len(events):\\n                return 0\\n            next_event = bisect_right(starts, events[idx][1])\\n            return max(dp(idx+1, k), events[idx][2] + dp(next_event, k-1))\\n    \\n        return dp(0,k)\\n```\n```\\n    def maxValue(self, events: List[List[int]], k: int) -> int:        \\n        n = len(events)\\n        dp = [[0 for _ in range(k + 1)] for _ in range(n+1)]\\n        events.sort()\\n        starts = [x for x,y,z in events]\\n\\n        for i in range(n-1, -1, -1):\\n            for j in range(1, k+1):\\n                next_event = bisect_right(starts, events[i][1])\\n                dp[i][j] = max(dp[i+1][j], events[i][2] + dp[next_event][j-1])\\n        \\n        return dp[0][k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1103634,
                "title": "python3-dp-simple-solution-explained",
                "content": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        \\n        # The number of events\\n        n = len(events)\\n        # Sort the events in chronological order\\n        events.sort()\\n        \\n        # k is the number of events we can attend\\n        # end is the last event we attended\\'s END TIME\\n        # event_index is the current event we are checking\\n        @lru_cache(None)\\n        def dp(end: int, event_index: int, k: int):\\n            \\n            # No more events left or we have checked all possible events\\n            if k == 0 or event_index == n:\\n                return 0\\n            \\n            event = events[event_index]\\n            event_start, event_end, event_value = event\\n            # Can we attend this event?\\n            # Does its start time conflict with the previous events end time?\\n            # If the start time is the same as the end time we cannot end as well (view example 2)\\n            if event_start <= end:\\n                # Could not attend, check the next event\\n                return dp(end, event_index + 1, k)\\n            \\n            # We made it here, so we can attend!\\n            # Two possible options, we either attend (add the value) or do not attend this event\\n            # Value for attending versus the value for skipping\\n            attend = event_value + dp(event_end, event_index + 1, k - 1)\\n            skip = dp(end, event_index + 1, k)\\n            \\n            # Get the best option\\n            return max(attend, skip)\\n            \\n        # Clear cache to save memory\\n        dp.cache_clear()\\n        return dp(0, 0, k)\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        \\n        # The number of events\\n        n = len(events)\\n        # Sort the events in chronological order\\n        events.sort()\\n        \\n        # k is the number of events we can attend\\n        # end is the last event we attended\\'s END TIME\\n        # event_index is the current event we are checking\\n        @lru_cache(None)\\n        def dp(end: int, event_index: int, k: int):\\n            \\n            # No more events left or we have checked all possible events\\n            if k == 0 or event_index == n:\\n                return 0\\n            \\n            event = events[event_index]\\n            event_start, event_end, event_value = event\\n            # Can we attend this event?\\n            # Does its start time conflict with the previous events end time?\\n            # If the start time is the same as the end time we cannot end as well (view example 2)\\n            if event_start <= end:\\n                # Could not attend, check the next event\\n                return dp(end, event_index + 1, k)\\n            \\n            # We made it here, so we can attend!\\n            # Two possible options, we either attend (add the value) or do not attend this event\\n            # Value for attending versus the value for skipping\\n            attend = event_value + dp(event_end, event_index + 1, k - 1)\\n            skip = dp(end, event_index + 1, k)\\n            \\n            # Get the best option\\n            return max(attend, skip)\\n            \\n        # Clear cache to save memory\\n        dp.cache_clear()\\n        return dp(0, 0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766527,
                "title": "video-solution-java-python",
                "content": "<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/Y1deO3QQnjk\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share\" allowfullscreen></iframe>\\n\\n```\\nclass Solution {\\n    int[][] events;\\n    public int maxValue(int[][] events, int k) {\\n        this.events = events;\\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\\n        int n = events.length;\\n        \\n        dp = new int[k + 1][n];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        return dfs(0, k);\\n    }    \\n    \\n    private int[][] dp;\\n    private int dfs(int index, int count) {\\n        \\n        if (count == 0 || index == events.length) {\\n            return 0;\\n        }\\n        if (dp[count][index] != -1) {\\n            return dp[count][index];\\n        }\\n        int nextIndex = binarySearch(events[index][1]);\\n        dp[count][index] = Math.max( events[index][2] + dfs(nextIndex, count - 1), dfs(index + 1, count));\\n        return dp[count][index];\\n    }\\n    \\n    public int binarySearch( int target) {\\n        int left = 0, right = events.length;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (events[mid][0] <= target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }   \\n}\\n```\\n\\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort(key=lambda x: x[0])\\n        n = len(events)\\n        \\n        dp = [[-1] * n for _ in range(k + 1)]\\n        \\n        def dfs(index: int, count: int) -> int:\\n            if count == 0 or index == n:\\n                return 0\\n            if dp[count][index] != -1:\\n                return dp[count][index]\\n            \\n            dp[count][index] = max(events[index][2] + dfs(binarySearch(events[index][1]), count - 1), dfs(index + 1, count))\\n            \\n            return dp[count][index]\\n        \\n        def binarySearch(target: int) -> int:\\n            left, right = 0, n - 1\\n            \\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                if events[mid][0] <= target:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n            \\n            return left\\n        \\n        return dfs(0, k)\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Python"
                ],
                "code": "```\\nclass Solution {\\n    int[][] events;\\n    public int maxValue(int[][] events, int k) {\\n        this.events = events;\\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\\n        int n = events.length;\\n        \\n        dp = new int[k + 1][n];\\n        for (int[] row : dp) {\\n            Arrays.fill(row, -1);\\n        }\\n        \\n        return dfs(0, k);\\n    }    \\n    \\n    private int[][] dp;\\n    private int dfs(int index, int count) {\\n        \\n        if (count == 0 || index == events.length) {\\n            return 0;\\n        }\\n        if (dp[count][index] != -1) {\\n            return dp[count][index];\\n        }\\n        int nextIndex = binarySearch(events[index][1]);\\n        dp[count][index] = Math.max( events[index][2] + dfs(nextIndex, count - 1), dfs(index + 1, count));\\n        return dp[count][index];\\n    }\\n    \\n    public int binarySearch( int target) {\\n        int left = 0, right = events.length;\\n        while (left < right) {\\n            int mid = (left + right) / 2;\\n            if (events[mid][0] <= target) {\\n                left = mid + 1;\\n            } else {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }   \\n}\\n```\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort(key=lambda x: x[0])\\n        n = len(events)\\n        \\n        dp = [[-1] * n for _ in range(k + 1)]\\n        \\n        def dfs(index: int, count: int) -> int:\\n            if count == 0 or index == n:\\n                return 0\\n            if dp[count][index] != -1:\\n                return dp[count][index]\\n            \\n            dp[count][index] = max(events[index][2] + dfs(binarySearch(events[index][1]), count - 1), dfs(index + 1, count))\\n            \\n            return dp[count][index]\\n        \\n        def binarySearch(target: int) -> int:\\n            left, right = 0, n - 1\\n            \\n            while left <= right:\\n                mid = left + (right - left) // 2\\n                if events[mid][0] <= target:\\n                    left = mid + 1\\n                else:\\n                    right = mid - 1\\n            \\n            return left\\n        \\n        return dfs(0, k)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052467,
                "title": "javascript-dp-smart-processing-o-n-k-logn",
                "content": "This is a dp problem that requires smart processing of states. \\nLet us first start with the naive approach.\\n\\nEach interval is a tuple [**start,end,val**]\\nif we first sort by **ascending start**, we can consider a state as :\\n```\\ndp[k][i]=The maximum value I can achieve if the k-th choice is the i-th interval\\n```\\nThere is only one way to compute this, and it is to consider all **previous states** \\n```\\ndp[k-1][j], where j corresponds to another interval [start2,end2] AND end2<start\\n```\\nWe can only use intervals that end before the current interval we re processing. \\n\\nSo what we can do, is consider all possible intervals that end before my current one\\n```\\n\\tfor(k=1;k<=K;k++)\\n\\t\\tfor(let i=0;i<n;i++)\\n\\t\\t\\tfor(let j=0;j<n;j++)\\n\\t\\t\\t\\tif( end[j] < start[i])\\n\\t\\t\\t\\t\\tdp[k][i]=Math.max(dp[k][i], dp[k-1][j]+val[i])\\n```\\nthis will however, most likely **TLE**\\n\\nWhat we can notice instead, is that we process tuples in a very specific way.\\n* The current items (i-loop) processes items with ascending starts, but the j loop essentially wants only items with **ascending ends**, that are smaller than start[i].\\n* Not only that, but each dp[k][i] picks **ONLY ONE** item out of the previous row, and that is the MAXIMUM dp[k-1][j] such that end[j]<start[i].\\n\\nNow let us say that we have to calculate **dp[k][i]**, and **dp[k][i+1]**.\\nNow assume that dp[k][i] picked j1 as the maximum dp[k-1][j]. \\nIt follows, that whatever dp[k][i+1] picks out of the previous row as its optimal arg, **it has to be >=dp[k-1][j1]**\\nWhy? Because we are already processing elements in ascending start, so start[i+1]>=start[i]\\nSo dp[k][i+1] can pick any j that dp[k][i] can pick, plus maybe some more indices .\\nTherefore \\n```\\ndp[k][i+1]= Math.max(\\n\\t\\t\\t\\t\\t\\tdp[k][i+1],\\n\\t\\t\\t\\t\\t\\tdp[k-1][j1]+val[i+1], //the optimal choice for dp[k][i]\\n\\t\\t\\t\\t\\t\\tdp[k-1][j2]+val[i+1], // such that  end[j1]<end[j2]<start[i+1]\\n\\t\\t\\t\\t\\t)\\n```\\nHmm, so if we process the items in ascending ends, we should be able to achieve linear complexity. \\nHow?\\nSay we had sorted the elements in ascending ends. let\\'s name that array Z\\nYou see from the above formula, **that each dp[k][i] processes up to some index of Z**. And it never goes back.\\nSo for each i, we can keep processing elements until the last invariant holds, and that is  end[j1]<start[i+1]\\nBy \"processing elements\" we mean that we find the maximum dp[k-1][j2] that we can. \\n\\nHere comes the main question that we need to ask ourselves. \\n**How can I, even though I m processing dp[k] elements in ascending starts, calculate dp[k][i] from elements that are in ascending ends?**\\n\\nWe keep track of the index the element **used to have when it was in ascending start**, and keep reprocessing Z.\\nEach element of Z corresponds to some end, that end is ascending. But I need to know the index the current element had when it was originally sorted in ascending starts, because that\\'s what dp[k-1] holds.\\n\\n```\\nvar maxValue = function(A, K) {\\n    A.sort((a,b)=>a[0]===b[0]?a[1]-b[1]:a[0]-b[0])\\n    A=A.map(([s,e,val],i)=>[s,e,val,i])\\n    let n=A.length,\\n\\t\\tdp=[...Array(K+1)].map(d=>[...Array(n+1)].map(d=>0)),\\n\\t\\tZ=[...A].sort((a,b)=>a[1]-b[1])\\n    for(let k=1;k<=K;k++ ){\\n        let indexOfZ=0,optimalPrevious=0\\n        for(let i=1;i<=n;i++){\\n            let [start,end,val,idx]=A[i-1]\\n            while(indexOfZ<n&& Z[indexOfZ][1]<start ){\\n                let originalIdx=Z[indexOfZ][3] //take the original index it used to have\\n                if(dp[k-1][originalIdx+1]>optimalPrevious)\\n                    optimalPrevious=dp[k-1][originalIdx+1]\\n                indexOfZ++\\n            }\\n            dp[k][i]=Math.max(val+optimalPrevious,dp[k][i]) //main dp computation\\n        }\\n    }\\n    return Math.max(...dp[K])\\n};\\n```\\nTime complexity is **O(n\\\\*k)**, because **we process Z only once**.\\n",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\ndp[k][i]=The maximum value I can achieve if the k-th choice is the i-th interval\\n```\n```\\ndp[k-1][j], where j corresponds to another interval [start2,end2] AND end2<start\\n```\n```\\n\\tfor(k=1;k<=K;k++)\\n\\t\\tfor(let i=0;i<n;i++)\\n\\t\\t\\tfor(let j=0;j<n;j++)\\n\\t\\t\\t\\tif( end[j] < start[i])\\n\\t\\t\\t\\t\\tdp[k][i]=Math.max(dp[k][i], dp[k-1][j]+val[i])\\n```\n```\\ndp[k][i+1]= Math.max(\\n\\t\\t\\t\\t\\t\\tdp[k][i+1],\\n\\t\\t\\t\\t\\t\\tdp[k-1][j1]+val[i+1], //the optimal choice for dp[k][i]\\n\\t\\t\\t\\t\\t\\tdp[k-1][j2]+val[i+1], // such that  end[j1]<end[j2]<start[i+1]\\n\\t\\t\\t\\t\\t)\\n```\n```\\nvar maxValue = function(A, K) {\\n    A.sort((a,b)=>a[0]===b[0]?a[1]-b[1]:a[0]-b[0])\\n    A=A.map(([s,e,val],i)=>[s,e,val,i])\\n    let n=A.length,\\n\\t\\tdp=[...Array(K+1)].map(d=>[...Array(n+1)].map(d=>0)),\\n\\t\\tZ=[...A].sort((a,b)=>a[1]-b[1])\\n    for(let k=1;k<=K;k++ ){\\n        let indexOfZ=0,optimalPrevious=0\\n        for(let i=1;i<=n;i++){\\n            let [start,end,val,idx]=A[i-1]\\n            while(indexOfZ<n&& Z[indexOfZ][1]<start ){\\n                let originalIdx=Z[indexOfZ][3] //take the original index it used to have\\n                if(dp[k-1][originalIdx+1]>optimalPrevious)\\n                    optimalPrevious=dp[k-1][originalIdx+1]\\n                indexOfZ++\\n            }\\n            dp[k][i]=Math.max(val+optimalPrevious,dp[k][i]) //main dp computation\\n        }\\n    }\\n    return Math.max(...dp[K])\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3766678,
                "title": "c-python-commented-code-video-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUse the 0/1 Knapsack approach for this problem. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4FVideo added for this problem. Please upvote\\uD83D\\uDE4F\\uD83D\\uDE4F\\uD83D\\uDE4F**\\n\\nhttps://youtu.be/ZLysYrrEzV8\\n# Complexity\\n\\nThe time and space complexity of the code can be analyzed as follows:\\n\\nTime Complexity:\\n\\nSorting the events takes O(n log n) time, where n is the number of events.\\nThe solve function is a recursive function that is called for each event and each value of k. The number of recursive calls depends on the number of events and the value of k. In the worst case, each event is considered for each value of k, resulting in a total of O(n * k) recursive calls.\\nThe bisect.bisect function is called within the solve function to find the next event that starts after the current event ends. It has a time complexity of O(log n).\\nOverall, the time complexity of the code is O(n log n + n * k * log n).\\nSpace Complexity:\\n\\nThe events list is stored as an instance variable, so it does not contribute to the space complexity of individual function calls.\\nThe space complexity of the solve function is determined by the maximum recursion depth, which is k. Each recursive call consumes additional space on the call stack.\\nTherefore, the space complexity of the code is O(k).\\n\\n- Time complexity: O(nk lg n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code (Python)\\n```\\nimport bisect\\n\\nclass Solution:\\n\\n    def __init__(self):\\n        self.events = []\\n\\n    # Cache decorator to memoize results of function calls\\n    @cache\\n    def solve(self, i, k):\\n        if i >= len(self.events): \\n            return 0\\n        if k <= 0: \\n            return 0\\n        \\n        # Retrieve start time, end time, and value of current event\\n        s, e, v = self.events[i]\\n        \\n        # Find the next event that starts after the current event ends\\n        j = bisect.bisect(self.events, [e+1])\\n        \\n        # We have two options: either take the current event or don\\'t\\n        return max(v + self.solve(j, k - 1), self.solve(i + 1, k))\\n\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort()  # Sort events based on their start times\\n        self.events = events\\n        return self.solve(0, k)\\n\\n\\n```\\n\\n# Code (C++)\\n\\n```\\n\\n#include <vector>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    int solve(int i, int k) {\\n        // Base cases\\n        if (i >= events.size()) {\\n            return 0;\\n        }\\n        if (k <= 0) {\\n            return 0;\\n        }\\n        \\n        // Check if the result for this state is already cached\\n        if (cache[i][k] != -1) {\\n            return cache[i][k];\\n        }\\n        \\n        // Retrieve start time, end time, and value of current event\\n        int start = events[i][0];\\n        int end = events[i][1];\\n        int value = events[i][2];\\n        \\n        // Find the next event that starts after the current event ends\\n        int nextIndex = i + 1;\\n        while (nextIndex < events.size() && events[nextIndex][0] <= end) {\\n            nextIndex++;\\n        }\\n        \\n        // We have two options: either take the current event or don\\'t\\n        int takeEvent = value + solve(nextIndex, k - 1);\\n        int skipEvent = solve(i + 1, k);\\n        \\n        // Cache the result for this state\\n        cache[i][k] = std::max(takeEvent, skipEvent);\\n        \\n        return cache[i][k];\\n    }\\n\\n    int maxValue(std::vector<std::vector<int>>& events, int k) {\\n        // Sort events based on their start times\\n        std::sort(events.begin(), events.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\\n            return a[0] < b[0];\\n        });\\n        \\n        // Store events for access within solve function\\n        this->events = events;\\n        \\n        // Clear cache before each function call\\n        cache.assign(events.size(), std::vector<int>(k + 1, -1));\\n        \\n        // Recursive call to solve the problem\\n        return solve(0, k);\\n    }\\n    \\nprivate:\\n    std::vector<std::vector<int>> events;\\n    std::vector<std::vector<int>> cache;\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Python3",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nimport bisect\\n\\nclass Solution:\\n\\n    def __init__(self):\\n        self.events = []\\n\\n    # Cache decorator to memoize results of function calls\\n    @cache\\n    def solve(self, i, k):\\n        if i >= len(self.events): \\n            return 0\\n        if k <= 0: \\n            return 0\\n        \\n        # Retrieve start time, end time, and value of current event\\n        s, e, v = self.events[i]\\n        \\n        # Find the next event that starts after the current event ends\\n        j = bisect.bisect(self.events, [e+1])\\n        \\n        # We have two options: either take the current event or don\\'t\\n        return max(v + self.solve(j, k - 1), self.solve(i + 1, k))\\n\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort()  # Sort events based on their start times\\n        self.events = events\\n        return self.solve(0, k)\\n\\n\\n```\n```\\n\\n#include <vector>\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    int solve(int i, int k) {\\n        // Base cases\\n        if (i >= events.size()) {\\n            return 0;\\n        }\\n        if (k <= 0) {\\n            return 0;\\n        }\\n        \\n        // Check if the result for this state is already cached\\n        if (cache[i][k] != -1) {\\n            return cache[i][k];\\n        }\\n        \\n        // Retrieve start time, end time, and value of current event\\n        int start = events[i][0];\\n        int end = events[i][1];\\n        int value = events[i][2];\\n        \\n        // Find the next event that starts after the current event ends\\n        int nextIndex = i + 1;\\n        while (nextIndex < events.size() && events[nextIndex][0] <= end) {\\n            nextIndex++;\\n        }\\n        \\n        // We have two options: either take the current event or don\\'t\\n        int takeEvent = value + solve(nextIndex, k - 1);\\n        int skipEvent = solve(i + 1, k);\\n        \\n        // Cache the result for this state\\n        cache[i][k] = std::max(takeEvent, skipEvent);\\n        \\n        return cache[i][k];\\n    }\\n\\n    int maxValue(std::vector<std::vector<int>>& events, int k) {\\n        // Sort events based on their start times\\n        std::sort(events.begin(), events.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\\n            return a[0] < b[0];\\n        });\\n        \\n        // Store events for access within solve function\\n        this->events = events;\\n        \\n        // Clear cache before each function call\\n        cache.assign(events.size(), std::vector<int>(k + 1, -1));\\n        \\n        // Recursive call to solve the problem\\n        return solve(0, k);\\n    }\\n    \\nprivate:\\n    std::vector<std::vector<int>> events;\\n    std::vector<std::vector<int>> cache;\\n};\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1052727,
                "title": "solution-using-dynamic-programming-time-o-n-k-logn-space-o-nk",
                "content": "**Steps:**\\n- Sort the events in ascending order\\n- While iterating each event we can make two choices based on the conditions\\n\\t- We can skip the meeting\\n\\t- we can pick the meeting if the previous meeting has ended before the current meeting start time\\n- This solution will take **expotential time** but using dynamic programming this can be solved by remembering the previous solution at indexes\\n\\n**Time Complexity:** O(NlogN) (for sorting the events) + O(NK) (for making K solutions at each event) = **O(N(K+logN))**\\n**Space Complexity:** O(NK) (for dp table) + O(K) (for recursion stack memory) = **O(NK)**\\n\\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        Arrays.sort(events, (e1, e2) -> (e1[0] == e2[0] ? e1[1]-e2[1] : e1[0]-e2[0]));\\n        return maxValue(events, 0, k, 0, new int[k+1][events.length]);\\n    }\\n    \\n    private int maxValue(int[][] events, int index, int remainingEvents, int lastEventEndDay, int[][] dp) {\\n\\t\\t// Return 0 if no events are left or maximum choice is reached\\n\\t\\tif (index >= events.length || remainingEvents == 0)\\n            return 0;\\n\\t\\t\\t\\n        // An Event cannot be picked if the previous event has not completed before current event\\n        if (lastEventEndDay >= events[index][0])\\n            return maxValue(events, index+1, remainingEvents, lastEventEndDay, dp);\\n        \\n\\t\\t// Return the value if the solution is already available\\n        if (dp[remainingEvents][index] != 0)\\n            return dp[remainingEvents][index];\\n                \\n\\t\\t// There are 2 choices that we can make,\\n\\t\\t\\t// SKIP this meeting or PICK this meeting\\n        return dp[remainingEvents][index] = Math.max(\\n            maxValue(events, index+1, remainingEvents, lastEventEndDay, dp), // skip\\n            maxValue(events, index+1, remainingEvents-1, events[index][1], dp) + events[index][2] // pick\\n        );\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        Arrays.sort(events, (e1, e2) -> (e1[0] == e2[0] ? e1[1]-e2[1] : e1[0]-e2[0]));\\n        return maxValue(events, 0, k, 0, new int[k+1][events.length]);\\n    }\\n    \\n    private int maxValue(int[][] events, int index, int remainingEvents, int lastEventEndDay, int[][] dp) {\\n\\t\\t// Return 0 if no events are left or maximum choice is reached\\n\\t\\tif (index >= events.length || remainingEvents == 0)\\n            return 0;\\n\\t\\t\\t\\n        // An Event cannot be picked if the previous event has not completed before current event\\n        if (lastEventEndDay >= events[index][0])\\n            return maxValue(events, index+1, remainingEvents, lastEventEndDay, dp);\\n        \\n\\t\\t// Return the value if the solution is already available\\n        if (dp[remainingEvents][index] != 0)\\n            return dp[remainingEvents][index];\\n                \\n\\t\\t// There are 2 choices that we can make,\\n\\t\\t\\t// SKIP this meeting or PICK this meeting\\n        return dp[remainingEvents][index] = Math.max(\\n            maxValue(events, index+1, remainingEvents, lastEventEndDay, dp), // skip\\n            maxValue(events, index+1, remainingEvents-1, events[index][1], dp) + events[index][2] // pick\\n        );\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052454,
                "title": "java-simple-top-down-dp-dfs-memorization",
                "content": "On each step we have two choices: take current event or skip it..\\n\\n```\\npublic int maxValue(int[][] events, int k) {\\n\\tArrays.sort(events, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n\\n\\t// <count + \"_\" + end, sum>\\n\\tMap<String, Integer> cache = new HashMap<>();\\n\\n\\treturn dfs(events, 0, 0, k, 0, cache);\\n}\\n\\nprivate int dfs(int[][] events, int cur, int count, int k, int end, Map<String, Integer> cache) {\\n\\tif (count == k || cur == events.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tString key = count + \"_\" + end;\\n\\tInteger val = cache.get(key);\\n\\tif (val != null) {\\n\\t\\treturn val;\\n\\t}\\n\\n\\t// skip\\n\\tint max = dfs(events, cur + 1, count, k, end, cache);\\n\\tif (events[cur][0] > end) {\\n\\t\\t// take current\\n\\t\\tmax = Math.max(max, dfs(events, cur + 1, count + 1, k, events[cur][1], cache) + events[cur][2]);\\n\\t}\\n\\n\\tcache.put(key, max);\\n\\treturn max;\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\npublic int maxValue(int[][] events, int k) {\\n\\tArrays.sort(events, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\\n\\n\\t// <count + \"_\" + end, sum>\\n\\tMap<String, Integer> cache = new HashMap<>();\\n\\n\\treturn dfs(events, 0, 0, k, 0, cache);\\n}\\n\\nprivate int dfs(int[][] events, int cur, int count, int k, int end, Map<String, Integer> cache) {\\n\\tif (count == k || cur == events.length) {\\n\\t\\treturn 0;\\n\\t}\\n\\n\\tString key = count + \"_\" + end;\\n\\tInteger val = cache.get(key);\\n\\tif (val != null) {\\n\\t\\treturn val;\\n\\t}\\n\\n\\t// skip\\n\\tint max = dfs(events, cur + 1, count, k, end, cache);\\n\\tif (events[cur][0] > end) {\\n\\t\\t// take current\\n\\t\\tmax = Math.max(max, dfs(events, cur + 1, count + 1, k, events[cur][1], cache) + events[cur][2]);\\n\\t}\\n\\n\\tcache.put(key, max);\\n\\treturn max;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3766626,
                "title": "line-by-line-explanation",
                "content": "This problem is similar to [1235 - Maximum Profit in Job Scheduling (Hard)](https://leetcode.com/problems/maximum-profit-in-job-scheduling/discuss/1959999/LeetCode-The-Hard-Way-1235-Maximum-Profit-in-Job-Scheduling-(Hard)).\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        // sort by start time\\n        sort(events.begin(), events.end());\\n        // dp[i][j] means the max value we could get \\n        // when we are at event i with k events left to join \\n        vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n        function<int(int,int,int)> dfs = [&](int idx, int k, int end) {\\n            // reached all events or attended all k events\\n            if (idx == n || k == 0) return 0;\\n            // current start time <= previous end time\\n            // cannot attend -> move to the next one\\n            if (events[idx][0] <= end) return dfs(idx + 1, k, end);\\n            // calculated before - return it immediately\\n            if (dp[idx][k] != -1) return dp[idx][k];\\n            // so we only have two choices left, we either\\n            return dp[idx][k] = max(\\n                // choice 1: attend this event \\n                // and search for the next events starting from this end time\\n                events[idx][2] + dfs(idx + 1, k - 1, events[idx][1]),\\n                // choice 2: skip this event - search for the next one\\n                dfs(idx + 1, k, end)\\n            );\\n        };\\n        return dfs(0, k, 0);\\n    }\\n};\\n```\\n\\n**p.s. Join us on the LeetCode The Hard Way Discord Study Group for timely discussion! Link in bio.**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        // sort by start time\\n        sort(events.begin(), events.end());\\n        // dp[i][j] means the max value we could get \\n        // when we are at event i with k events left to join \\n        vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n        function<int(int,int,int)> dfs = [&](int idx, int k, int end) {\\n            // reached all events or attended all k events\\n            if (idx == n || k == 0) return 0;\\n            // current start time <= previous end time\\n            // cannot attend -> move to the next one\\n            if (events[idx][0] <= end) return dfs(idx + 1, k, end);\\n            // calculated before - return it immediately\\n            if (dp[idx][k] != -1) return dp[idx][k];\\n            // so we only have two choices left, we either\\n            return dp[idx][k] = max(\\n                // choice 1: attend this event \\n                // and search for the next events starting from this end time\\n                events[idx][2] + dfs(idx + 1, k - 1, events[idx][1]),\\n                // choice 2: skip this event - search for the next one\\n                dfs(idx + 1, k, end)\\n            );\\n        };\\n        return dfs(0, k, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1611263,
                "title": "c-brute-recursion-better-dp-optimal-dp-binary-search-explained",
                "content": "## 1. Brute Force ( Recursion ) \\n\\nIn brute force we use simple recursion technique and opt between two choices:\\n\\t\\t\\t 1. Opt for an activity and add value to the answer\\n\\t\\t\\t 2. Skip the activity and move ahead\\n\\n```\\nclass Solution {\\npublic:\\n    int recur(int idx,vector<vector<int>>&events,int k)\\n    {\\n        if(idx>=events.size() or k==0)\\n            return 0;\\n        int i;\\n        for(i=idx+1;i<events.size();i++)\\n        {\\n            if(events[i][0]>events[idx][1])\\n            {\\n                break;\\n            }\\n        }\\n        int op1=recur(idx+1,events,k);\\n        int op2=events[idx][2]+recur(i,events,k-1);\\n        \\n        return max(op1,op2);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        \\n        //Sort the events first by Start Time and If\\n        // StartTime of two events are same sort by \\n        // EndTime of those Events\\n        \\n        sort(events.begin(),events.end(),[]\\n            (vector<int>&a,vector<int>&b)\\n             {\\n                 if(a[0]==b[0])\\n                     return a[1]<b[1];\\n                 return  a[0]<b[0];\\n             }\\n            );\\n        \\n        return recur(0,events,k);\\n        \\n        \\n    }\\n};\\n```\\n## 2. Better Approach ( Recursion + Memoization ) \\n\\n```\\nclass Solution {\\n\\npublic:\\n    \\n    int recur(vector<vector<int>>&dp,int idx,vector<vector<int>>&events,int k)\\n    {\\n        if(idx>=events.size() or k==0)\\n            return 0;\\n        int i;\\n        \\n        if(dp[idx][k]!=-1)\\n            return dp[idx][k];\\n        for(i=idx+1;i<events.size();i++)\\n        {\\n            if(events[i][0]>events[idx][1])\\n            {\\n                break;\\n            }\\n        }\\n        int op1=recur(dp,idx+1,events,k);\\n        int op2=events[idx][2]+recur(dp,i,events,k-1);\\n        \\n        return dp[idx][k]=max(op1,op2);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        \\n        //Sort the events first by Start Time and If\\n        // StartTime of two events are same sort by \\n        // EndTime of those Events\\n        \\n        sort(events.begin(),events.end(),[]\\n            (vector<int>&a,vector<int>&b)\\n             {\\n                 if(a[0]==b[0])\\n                     return a[1]<b[1];\\n                 return  a[0]<b[0];\\n             }\\n            );\\n        int n=events.size();\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        return recur(dp,0,events,k);\\n        \\n        \\n    }\\n};\\n```\\n\\n\\n## 3. Optimal Approach ( Recursion + Memoization + Binary Search )\\n\\nIn our recursion function we are finding new activity that has start time greater than the current activity\\'s end time. This may take up to O ( n ) \\ntime. \\n\\nSince the activities are already sorted we can use Binary Search Technique to solve the problem.\\n\\n```\\n\\nclass Solution {\\n\\npublic:\\n    int find(vector<vector<int>>&events,int start,int toFind)\\n    {\\n        int low=start;\\n        int high=events.size()-1;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            \\n            if(events[mid][0]>toFind)\\n            {\\n                ans=mid;\\n              high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n       // cout<<ans<<endl;\\n        return ans;\\n        \\n    }\\n    int recur(vector<vector<int>>&dp,int idx,vector<vector<int>>&events,int k)\\n    {\\n        if(idx==-1)\\n            return 0;\\n        if(idx>=events.size() or k==0)\\n            return 0;\\n\\n        \\n        if(dp[idx][k]!=-1)\\n            return dp[idx][k];\\n        // for(i=idx+1;i<events.size();i++)\\n        // {\\n        //     if(events[i][0]>events[idx][1])\\n        //     {\\n        //         break;\\n        //     }\\n        // }\\n        \\n        \\n        // Binary Search the value \\n        int i=find(events,idx+1,events[idx][1]);\\n        int op1=recur(dp,idx+1,events,k);\\n        int op2=events[idx][2]+recur(dp,i,events,k-1);\\n        \\n        return dp[idx][k]=max(op1,op2);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        \\n        //Sort the events first by Start Time and If\\n        // StartTime of two events are same sort by \\n        // EndTime of those Events\\n        \\n        sort(events.begin(),events.end(),[]\\n            (vector<int>&a,vector<int>&b)\\n             {\\n                 if(a[0]==b[0])\\n                     return a[1]<b[1];\\n                 return  a[0]<b[0];\\n             }\\n            );\\n        int n=events.size();\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        return recur(dp,0,events,k);\\n        \\n        \\n    }\\n};\\n```\\n\\n**Please Upvote if you gained something**\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int recur(int idx,vector<vector<int>>&events,int k)\\n    {\\n        if(idx>=events.size() or k==0)\\n            return 0;\\n        int i;\\n        for(i=idx+1;i<events.size();i++)\\n        {\\n            if(events[i][0]>events[idx][1])\\n            {\\n                break;\\n            }\\n        }\\n        int op1=recur(idx+1,events,k);\\n        int op2=events[idx][2]+recur(i,events,k-1);\\n        \\n        return max(op1,op2);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        \\n        //Sort the events first by Start Time and If\\n        // StartTime of two events are same sort by \\n        // EndTime of those Events\\n        \\n        sort(events.begin(),events.end(),[]\\n            (vector<int>&a,vector<int>&b)\\n             {\\n                 if(a[0]==b[0])\\n                     return a[1]<b[1];\\n                 return  a[0]<b[0];\\n             }\\n            );\\n        \\n        return recur(0,events,k);\\n        \\n        \\n    }\\n};\\n```\n```\\nclass Solution {\\n\\npublic:\\n    \\n    int recur(vector<vector<int>>&dp,int idx,vector<vector<int>>&events,int k)\\n    {\\n        if(idx>=events.size() or k==0)\\n            return 0;\\n        int i;\\n        \\n        if(dp[idx][k]!=-1)\\n            return dp[idx][k];\\n        for(i=idx+1;i<events.size();i++)\\n        {\\n            if(events[i][0]>events[idx][1])\\n            {\\n                break;\\n            }\\n        }\\n        int op1=recur(dp,idx+1,events,k);\\n        int op2=events[idx][2]+recur(dp,i,events,k-1);\\n        \\n        return dp[idx][k]=max(op1,op2);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        \\n        //Sort the events first by Start Time and If\\n        // StartTime of two events are same sort by \\n        // EndTime of those Events\\n        \\n        sort(events.begin(),events.end(),[]\\n            (vector<int>&a,vector<int>&b)\\n             {\\n                 if(a[0]==b[0])\\n                     return a[1]<b[1];\\n                 return  a[0]<b[0];\\n             }\\n            );\\n        int n=events.size();\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        return recur(dp,0,events,k);\\n        \\n        \\n    }\\n};\\n```\n```\\n\\nclass Solution {\\n\\npublic:\\n    int find(vector<vector<int>>&events,int start,int toFind)\\n    {\\n        int low=start;\\n        int high=events.size()-1;\\n        int ans=-1;\\n        while(low<=high)\\n        {\\n            int mid=(low+high)/2;\\n            \\n            if(events[mid][0]>toFind)\\n            {\\n                ans=mid;\\n              high=mid-1;\\n            }\\n            else\\n            {\\n                low=mid+1;\\n            }\\n        }\\n       // cout<<ans<<endl;\\n        return ans;\\n        \\n    }\\n    int recur(vector<vector<int>>&dp,int idx,vector<vector<int>>&events,int k)\\n    {\\n        if(idx==-1)\\n            return 0;\\n        if(idx>=events.size() or k==0)\\n            return 0;\\n\\n        \\n        if(dp[idx][k]!=-1)\\n            return dp[idx][k];\\n        // for(i=idx+1;i<events.size();i++)\\n        // {\\n        //     if(events[i][0]>events[idx][1])\\n        //     {\\n        //         break;\\n        //     }\\n        // }\\n        \\n        \\n        // Binary Search the value \\n        int i=find(events,idx+1,events[idx][1]);\\n        int op1=recur(dp,idx+1,events,k);\\n        int op2=events[idx][2]+recur(dp,i,events,k-1);\\n        \\n        return dp[idx][k]=max(op1,op2);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        \\n        //Sort the events first by Start Time and If\\n        // StartTime of two events are same sort by \\n        // EndTime of those Events\\n        \\n        sort(events.begin(),events.end(),[]\\n            (vector<int>&a,vector<int>&b)\\n             {\\n                 if(a[0]==b[0])\\n                     return a[1]<b[1];\\n                 return  a[0]<b[0];\\n             }\\n            );\\n        int n=events.size();\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        return recur(dp,0,events,k);\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1052448,
                "title": "java-bottom-up-dp-solution",
                "content": "**Intuition:**\\n\\nLet `DP[i][j] := Maximum value attending at most `j` events among the first `i`th events`\\n\\nWith this definition, our goal is to calculate `DP[N][K]`.\\n\\nWe cannot blindly attend both `i - 1`th and `i`th events because there is possiblity of confliction.\\nTherefore, we need to pre-construct `prev[i] := the index of valid previous event of i-th event` to look up the valid previous event.\\n\\nThe transition of DP is\\n\\n```java\\n// the maximum value by attending at most j events can be the same \\n// as what achieved by attending at most j - 1 events.\\ndp[i][j]= Math.max(dp[i][j], dp[i][j-1]);\\n\\n// the maximum value by attending j events from 0 to i-th events can be the same\\n// as what achieved by attending at most the same number of events from the first 0 to (i-1)-th events\\ndp[i][j] = Math.max(dp[i][j], dp[i-1][j]);\\n\\n// attend i-th event. In this case, add  event value (= events[i][2]) to dp[prev[i]][j-1]\\ndp[i][j] = Math.max(dp[i][j], dp[prev[i]][j-1] + events[i][2]); \\n```\\n\\n**Code:**\\n\\n\\n```java\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        Arrays.sort(events, (o1, o2) -> Integer.compare(o1[1], o2[1]));\\n\\n        int[] prev = new int[n];\\n        for (int i = 0; i < n; i++) prev[i] = binarySearsh(events, events[i][0]);\\n\\n        int[][] dp = new int[n+1][k+1];\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < k; j++) {\\n                dp[i+1][j+1] = Math.max(dp[i+1][j+1], dp[i+1][j]);\\n                dp[i+1][j+1] = Math.max(dp[i+1][j+1], dp[i][j+1]);\\n                dp[i+1][j+1] = Math.max(dp[i+1][j+1], dp[prev[i] + 1][j] + events[i][2]);\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n\\n    private int binarySearsh(int[][] a, int x) {\\n        int l = -1, r = a.length;\\n        while (r - l > 1) {\\n            int m = (l + r) / 2;\\n            if (a[m][1] < x) l = m;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n// the maximum value by attending at most j events can be the same \\n// as what achieved by attending at most j - 1 events.\\ndp[i][j]= Math.max(dp[i][j], dp[i][j-1]);\\n\\n// the maximum value by attending j events from 0 to i-th events can be the same\\n// as what achieved by attending at most the same number of events from the first 0 to (i-1)-th events\\ndp[i][j] = Math.max(dp[i][j], dp[i-1][j]);\\n\\n// attend i-th event. In this case, add  event value (= events[i][2]) to dp[prev[i]][j-1]\\ndp[i][j] = Math.max(dp[i][j], dp[prev[i]][j-1] + events[i][2]); \\n```\n```java\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        Arrays.sort(events, (o1, o2) -> Integer.compare(o1[1], o2[1]));\\n\\n        int[] prev = new int[n];\\n        for (int i = 0; i < n; i++) prev[i] = binarySearsh(events, events[i][0]);\\n\\n        int[][] dp = new int[n+1][k+1];\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < k; j++) {\\n                dp[i+1][j+1] = Math.max(dp[i+1][j+1], dp[i+1][j]);\\n                dp[i+1][j+1] = Math.max(dp[i+1][j+1], dp[i][j+1]);\\n                dp[i+1][j+1] = Math.max(dp[i+1][j+1], dp[prev[i] + 1][j] + events[i][2]);\\n            }\\n        }\\n\\n        return dp[n][k];\\n    }\\n\\n    private int binarySearsh(int[][] a, int x) {\\n        int l = -1, r = a.length;\\n        while (r - l > 1) {\\n            int m = (l + r) / 2;\\n            if (a[m][1] < x) l = m;\\n            else r = m;\\n        }\\n        return l;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766514,
                "title": "simple-java-solution-sort-and-dp",
                "content": "# Intuition\\nsort the elements based on the start time and if the start time is equal then sort based on the end time \\nthen in recursion :\\nfor every event we have only two options \\n1)to pick the current event\\n2)skip the event\\n\\nat the end picking the max of the two conditions\\n\\n# Code\\n```\\n//if you think this post is useful please upvote it\\nclass Solution \\n{\\n    public int fun(int i,int[][] nums,int prev,int max,int[][] dp)\\n    {\\n        if(i==nums.length || max==0)  return 0;\\n\\n        if(dp[prev+1][max]!=-1)  return dp[prev+1][max];\\n\\n        int take=0;\\n        int not=0;\\n        if(prev==-1 || nums[prev][1]<nums[i][0])\\n        {\\n            take=nums[i][2]+fun(i+1,nums,i,max-1,dp);\\n        }\\n        not=0+fun(i+1,nums,prev,max,dp);\\n        return dp[prev+1][max]=Math.max(take,not);\\n    }\\n    public int maxValue(int[][] events, int k) \\n    {\\n        Arrays.sort(events,(a,b) -> \\n        {\\n            if(a[0]==b[0])  return a[1]-b[1];\\n            return a[0]-b[0];\\n        });\\n       int[][] dp=new int[events.length+1][k+1];\\n       for(int[] j : dp) Arrays.fill(j,-1);\\n        return fun(0,events,-1,k,dp);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\n//if you think this post is useful please upvote it\\nclass Solution \\n{\\n    public int fun(int i,int[][] nums,int prev,int max,int[][] dp)\\n    {\\n        if(i==nums.length || max==0)  return 0;\\n\\n        if(dp[prev+1][max]!=-1)  return dp[prev+1][max];\\n\\n        int take=0;\\n        int not=0;\\n        if(prev==-1 || nums[prev][1]<nums[i][0])\\n        {\\n            take=nums[i][2]+fun(i+1,nums,i,max-1,dp);\\n        }\\n        not=0+fun(i+1,nums,prev,max,dp);\\n        return dp[prev+1][max]=Math.max(take,not);\\n    }\\n    public int maxValue(int[][] events, int k) \\n    {\\n        Arrays.sort(events,(a,b) -> \\n        {\\n            if(a[0]==b[0])  return a[1]-b[1];\\n            return a[0]-b[0];\\n        });\\n       int[][] dp=new int[events.length+1][k+1];\\n       for(int[] j : dp) Arrays.fill(j,-1);\\n        return fun(0,events,-1,k,dp);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052445,
                "title": "simple-and-easy-o-n-k-dp-solution-c",
                "content": "We make dp of index (where we are cureently at) and k (the number of events left to attend).\\nFirst, we sort the events array using start Time\\n\\nApproach- If we are currently at some index then we have to choices -\\n1. We attend this event and add values and recurse for next events starting after current event\\'s end time.\\n     ```    events[idx][2]+find(events,idx+1,k-1,events[idx][1])   ```\\n2. We don\\'t attend this event and go for next event \\n\\t``` find(events,idx+1,k,end) ```\\nand we take maximum of these.\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>>dp;\\n    int maxValue(vector<vector<int>>& events, int k) {\\n\\t\\t// Sorting the events using start time.\\n        sort(events.begin() , events.end());\\n        int n = events.size();\\n\\t\\t//Intialising DP and assigning value -1\\n        dp.resize( n, vector<int>( k + 1, -1));\\n        return find(events , 0 , k , 0);\\n    }\\n    int find(vector<vector<int>>& events,int idx, int k,int end){\\n\\t\\t// We reach final index, return 0\\n        if(idx==events.size()) return 0;\\n\\t\\t// We attended totak k events\\n        if( k==0 ) return 0;\\n\\t\\t// If the current start time is less than previous end time then we can\\'t attend this event, we move forward.\\n        if( events[idx][0] <= end ) return find( events, idx + 1 , k , end );\\n\\t\\t// Return pre stored value if we have \\n        if( dp[idx][k] != -1) return dp[idx][k];\\n        int res= max ( events[idx][2] + find(events, idx + 1, k - 1 , events[idx][1] ),  find(events , idx + 1 , k , end ) );\\n        return dp[idx][k] = res;\\n    }\\n};\\n```\\n\\nPlease upvote if you like my approach.\\n",
                "solutionTags": [],
                "code": "```    events[idx][2]+find(events,idx+1,k-1,events[idx][1])   ```\n``` find(events,idx+1,k,end) ```\n```\\nclass Solution {\\npublic:\\nvector<vector<int>>dp;\\n    int maxValue(vector<vector<int>>& events, int k) {\\n\\t\\t// Sorting the events using start time.\\n        sort(events.begin() , events.end());\\n        int n = events.size();\\n\\t\\t//Intialising DP and assigning value -1\\n        dp.resize( n, vector<int>( k + 1, -1));\\n        return find(events , 0 , k , 0);\\n    }\\n    int find(vector<vector<int>>& events,int idx, int k,int end){\\n\\t\\t// We reach final index, return 0\\n        if(idx==events.size()) return 0;\\n\\t\\t// We attended totak k events\\n        if( k==0 ) return 0;\\n\\t\\t// If the current start time is less than previous end time then we can\\'t attend this event, we move forward.\\n        if( events[idx][0] <= end ) return find( events, idx + 1 , k , end );\\n\\t\\t// Return pre stored value if we have \\n        if( dp[idx][k] != -1) return dp[idx][k];\\n        int res= max ( events[idx][2] + find(events, idx + 1, k - 1 , events[idx][1] ),  find(events , idx + 1 , k , end ) );\\n        return dp[idx][k] = res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3530055,
                "title": "recursion-memoization-custom-upper-bound",
                "content": "\\n\\n# Recursive\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n\\n    int f(int ind, int k,  vector<vector<int>>& events) {\\n        if(ind >= events.size() || k <= 0) return 0;\\n        if(dp[ind][k] != -1)return dp[ind][k];\\n\\n        int nextInd = upper_bound(begin(events)+ind, end(events), events[ind][1], [](int t, const vector<int> &v){\\n                return v[0] > t;\\n            }) - begin(events);\\n        int pick = events[ind][2] + f(nextInd, k-1, events);\\n        int skip = f(ind+1, k, events);\\n        return dp[ind][k] = max(pick, skip);\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(begin(events), end(events));\\n        dp.resize(events.size(), vector<int>(k+1, -1));\\n        return f(0, k, events);\\n    }\\n};\\n```\\n\\n# Memoization\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n\\n    int f(int ind, int k,  vector<vector<int>>& events) {\\n        if(ind >= events.size() || k <= 0) return 0;\\n        if(dp[ind][k] != -1)return dp[ind][k];\\n\\n        int nextInd = upper_bound(begin(events)+ind, end(events), events[ind][1], [](int t, const vector<int> &v){\\n                return v[0] > t;\\n            }) - begin(events);\\n        int pick = events[ind][2] + f(nextInd, k-1, events);\\n        int skip = f(ind+1, k, events);\\n        return dp[ind][k] = max(pick, skip);\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(begin(events), end(events));\\n        dp.resize(events.size(), vector<int>(k+1, -1));\\n        return f(0, k, events);\\n    }\\n};\\n```\\n\\n*Note :-* \\n- Instead of using upper_bound, you can simply iterate to find the next index.\\n- We can also implement custom upper_bound in following manner- \\n```\\n    static bool compare(int t, const vector<int> &e) {\\n        return e[0] > t; //means starting time of the given vector must be greater than t.\\n    }\\n    auto j = upper_bound(e.begin() + i, e.end(), e[i][1], compare) - begin(e);\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n\\n    int f(int ind, int k,  vector<vector<int>>& events) {\\n        if(ind >= events.size() || k <= 0) return 0;\\n        if(dp[ind][k] != -1)return dp[ind][k];\\n\\n        int nextInd = upper_bound(begin(events)+ind, end(events), events[ind][1], [](int t, const vector<int> &v){\\n                return v[0] > t;\\n            }) - begin(events);\\n        int pick = events[ind][2] + f(nextInd, k-1, events);\\n        int skip = f(ind+1, k, events);\\n        return dp[ind][k] = max(pick, skip);\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(begin(events), end(events));\\n        dp.resize(events.size(), vector<int>(k+1, -1));\\n        return f(0, k, events);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n\\n    int f(int ind, int k,  vector<vector<int>>& events) {\\n        if(ind >= events.size() || k <= 0) return 0;\\n        if(dp[ind][k] != -1)return dp[ind][k];\\n\\n        int nextInd = upper_bound(begin(events)+ind, end(events), events[ind][1], [](int t, const vector<int> &v){\\n                return v[0] > t;\\n            }) - begin(events);\\n        int pick = events[ind][2] + f(nextInd, k-1, events);\\n        int skip = f(ind+1, k, events);\\n        return dp[ind][k] = max(pick, skip);\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(begin(events), end(events));\\n        dp.resize(events.size(), vector<int>(k+1, -1));\\n        return f(0, k, events);\\n    }\\n};\\n```\n```\\n    static bool compare(int t, const vector<int> &e) {\\n        return e[0] > t; //means starting time of the given vector must be greater than t.\\n    }\\n    auto j = upper_bound(e.begin() + i, e.end(), e[i][1], compare) - begin(e);\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767257,
                "title": "elegant-python-solution-with-clear-explanation",
                "content": "# Intuition\\nThe problem asks to find the maximum value that can be obtained by attending at most `k` events from a given list of events.\\n* Each event has a start time, end time, and value.\\n* We can\\'t attend two events if their time ranges overlap.\\n\\n# Approach\\nWe can sort the events based on their start time so that all \\noverlapping events are next to each other.\\n* For each event we can either consider it for our solution or skip it. \\n* But we can consider it only if it\\'s start time is greater than the end time of last event we considered.\\n\\nWe can use a dictionary `dp` to store the maximum value that can be obtained by attending at most `k` events from the `i-th` event onwards, given that the last event we attended ended at time `prev`.\\n\\nIn the DFS function, we have three cases to consider:\\n1. If we have already considered all events or if we have already attended `k` events, we return 0.\\n\\n2. If the start time of the current event is greater than the end time of the last event that we considered we attended (`prev`), we can choose to attend this event and update our result accordingly.\\n\\n3. We can also choose not to attend the current event and move on to the next one.\\n\\nWe take the maximum value from these two cases and store it in our `dp` dictionary for future reference.\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach is $$O(nk)$$, where `n` is the number of events and `k` is the maximum number of events that we can attend.\\n- Space complexity: The space complexity of this approach is also $$O(nk)$$, as we need to store the results of our DFS function in a dictionary.\\n\\n# Code\\n```python\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort()\\n        \\n        dp = {}\\n        def dfs(i, k, endTime):\\n            #if we can\\'t consider more events\\n            if i >= len(events) or k == 0:\\n                return 0\\n\\n            #if we already reached this state\\n            if (i,k,endTime) in dp:\\n                return dp[(i,k,endTime)]\\n\\n            res = 0\\n            #if we can attend current event attend it\\n            if events[i][0] > endTime:\\n                res = dfs(i+1, k-1, events[i][1]) + events[i][2]\\n            \\n            #skip current event\\n            res = max(res, dfs(i+1,k, endTime))\\n            #store result for future use.\\n            dp[(i,k,endTime)] = res\\n            return res\\n        \\n        return dfs(0,k, -1)\\n```\\n\\nI hope this helps! Let me know if you have any further questions. \\uD83D\\uDE0A",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```python\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort()\\n        \\n        dp = {}\\n        def dfs(i, k, endTime):\\n            #if we can\\'t consider more events\\n            if i >= len(events) or k == 0:\\n                return 0\\n\\n            #if we already reached this state\\n            if (i,k,endTime) in dp:\\n                return dp[(i,k,endTime)]\\n\\n            res = 0\\n            #if we can attend current event attend it\\n            if events[i][0] > endTime:\\n                res = dfs(i+1, k-1, events[i][1]) + events[i][2]\\n            \\n            #skip current event\\n            res = max(res, dfs(i+1,k, endTime))\\n            #store result for future use.\\n            dp[(i,k,endTime)] = res\\n            return res\\n        \\n        return dfs(0,k, -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2825444,
                "title": "binary-search-knapsack-dp-scheduling-dp",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n\\n        // sort according to end time\\n        sort(events.begin(), events.end(), [] (const vector<int> &A, const vector<int> &B) {\\n            if (A[1] != B[1]) return (A[1] < B[1]);\\n            else return (A[0] < B[0]);\\n        });\\n        /* \\n        \\tdp[i][j] = maximum value you can get, if you attend \\n        \\tatmost i events out of first j events.\\n        \\t\\n        \\tTransition:\\n        \\t1. You dont attend the current event. i.e. at most i events \\n        \\t   out of first j-1 events. dp[i][j] = dp[i][j-1];\\n        \\t2. You attend the current event. Also check if attending \\n        \\t   other events were possible. If yes, add their previous stored results.\\n\\n        \\tAnswer: dp[k][n-1]\\n        */\\n        vector<vector<int>> dp(k + 1, vector<int>(n, 0));\\n        for (int i = 1; i <= k; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (j - 1 >= 0) dp[i][j] = dp[i][j - 1];\\n                int startTime = events[j][0];\\n                int index = get(events, startTime);\\n                if (index != -1) dp[i][j] = max(dp[i][j], dp[i - 1][index] + events[j][2]);\\n                else dp[i][j] = max(dp[i][j], events[j][2]);\\n            }\\n        }\\n        return dp[k][n - 1];\\n    }\\n\\n    int get(vector<vector<int>> &events, int startTime) {\\n        int lo = -1, hi = events.size();\\n        while (hi > lo + 1) {\\n            int mid = (lo + hi) >> 1;\\n            if (events[mid][1] < startTime) lo = mid;\\n            else hi = mid;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n\\n        // sort according to end time\\n        sort(events.begin(), events.end(), [] (const vector<int> &A, const vector<int> &B) {\\n            if (A[1] != B[1]) return (A[1] < B[1]);\\n            else return (A[0] < B[0]);\\n        });\\n        /* \\n        \\tdp[i][j] = maximum value you can get, if you attend \\n        \\tatmost i events out of first j events.\\n        \\t\\n        \\tTransition:\\n        \\t1. You dont attend the current event. i.e. at most i events \\n        \\t   out of first j-1 events. dp[i][j] = dp[i][j-1];\\n        \\t2. You attend the current event. Also check if attending \\n        \\t   other events were possible. If yes, add their previous stored results.\\n\\n        \\tAnswer: dp[k][n-1]\\n        */\\n        vector<vector<int>> dp(k + 1, vector<int>(n, 0));\\n        for (int i = 1; i <= k; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (j - 1 >= 0) dp[i][j] = dp[i][j - 1];\\n                int startTime = events[j][0];\\n                int index = get(events, startTime);\\n                if (index != -1) dp[i][j] = max(dp[i][j], dp[i - 1][index] + events[j][2]);\\n                else dp[i][j] = max(dp[i][j], events[j][2]);\\n            }\\n        }\\n        return dp[k][n - 1];\\n    }\\n\\n    int get(vector<vector<int>> &events, int startTime) {\\n        int lo = -1, hi = events.size();\\n        while (hi > lo + 1) {\\n            int mid = (lo + hi) >> 1;\\n            if (events[mid][1] < startTime) lo = mid;\\n            else hi = mid;\\n        }\\n        return lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770450,
                "title": "ex-amazon-explains-a-solution-with-a-video-python-javascript-java-and-c",
                "content": "# Intuition\\nKeep max value of attendance with end day.\\n\\n# Solution Video\\nPlease subscribe to my channel from here. I have 223 LeetCode videos as of July 16th, 2023.\\nhttp://www.youtube.com/channel/UC9RMNwYTL3SXCP6ShLWVFww?sub_confirmation=1\\n\\nhttps://youtu.be/1Y3IYETtr2Q\\n\\n# *** Please Upvote!! ***\\n\\n---\\n\\n# Approach\\nThis is based on Python code. Other language might be different.\\n\\n1. Sort the \\'events\\' list based on the end dates in ascending order using the `events.sort(key=lambda x: x[1])` statement. This will ensure that events with earlier end dates come first.\\n\\n2. Initialize two lists, \\'cur\\' and \\'temp\\', both containing a single element `[0, 0]`. These lists will be used to keep track of the maximum value that can be obtained by attending events at each step.\\n\\n3. Start a loop that runs \\'k\\' times. This loop is used to consider the maximum number of event attendances, which is specified by the variable \\'k\\'.\\n\\n4. Within each iteration of the outer loop, start an inner loop that iterates over each event in the \\'events\\' list.\\n\\n5. For each event, find the appropriate position (index) to insert the event based on its start date in the \\'cur\\' list. This is done using the `bisect.bisect(cur, [start])` statement, which returns the index where the event should be inserted in order to maintain the sorted order. Subtract 1 from this index to get the index of the previous event with the closest start date that has already been attended.\\n\\n6. Check if attending the current event along with the value obtained from the previous maximum value (cur[i][1]) results in a higher value than the current maximum value (temp[-1][1]). If it does, append a new entry `[end, cur[i][1] + value]` to the \\'temp\\' list, where \\'end\\' is the end date of the current event and \\'cur[i][1] + value\\' is the updated maximum value that can be obtained by attending this event.\\n\\n7. After processing all events in the \\'events\\' list, update the \\'cur\\' list by swapping it with the \\'temp\\' list. This step is done to keep track of the maximum values for the next iteration of the outer loop.\\n\\n8. Reset the \\'temp\\' list to contain a single element `[0, 0]` again. This prepares the \\'temp\\' list for storing the maximum values in the next iteration.\\n\\n9. Repeat steps 4 to 8 for \\'k\\' iterations.\\n\\n10. After completing the \\'k\\' iterations, the final maximum value that can be obtained by attending events is stored in the last element of the \\'cur\\' list. Return this value as the result.\\n\\n# Complexity\\n- Time complexity: O(N log N + K * N)\\n    -   Sorting the events list: The events.sort() method has a time complexity of O(N log N), where N is the number of events.\\n\\n    - Main Loop: The outer loop runs \\'k\\' times, and the inner loop iterates over all \\'N\\' events. Therefore, the overall time complexity of the main loop is O(k * N).\\n\\n        Overall Time Complexity: O(N log N + k * N)\\n\\n- Space complexity: O(N)\\n\\n```javascript []\\n/**\\n * @param {number[][]} events\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxValue = function(events, k) {\\n    events.sort((a, b) => a[1] - b[1]);\\n\\n    let dp = [[0, 0]];\\n    let dp2 = [[0, 0]];\\n\\n    for (let _ = 0; _ < k; _++) {\\n      for (let [start, end, value] of events) {\\n        let i = bisect(dp, [start]) - 1;\\n\\n        if (dp[i][1] + value > dp2[dp2.length - 1][1]) {\\n          dp2.push([end, dp[i][1] + value]);\\n        }\\n      }\\n\\n      [dp, dp2] = [dp2, [[0, 0]]];\\n    }\\n\\n    return dp[dp.length - 1][1];    \\n};\\n\\nvar bisect = function(arr, target) {\\n    var low = 0;\\n    var high = arr.length;\\n\\n    while (low < high) {\\n        var mid = Math.floor((low + high) / 2);\\n\\n        if (arr[mid][0] < target[0]) {\\n            low = mid + 1;\\n        } else {\\n            high = mid;\\n        }\\n    }\\n\\n    return low;\\n};\\n```\\n```python []\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort(key=lambda x: x[1])\\n        cur, temp = [[0, 0]], [[0, 0]]\\n\\n        for _ in range(k):\\n            for start, end, value in events:\\n                i = bisect.bisect(cur, [start]) - 1\\n                if cur[i][1] + value > temp[-1][1]:\\n                    temp.append([end, cur[i][1] + value])\\n            \\n            cur, temp = temp, [[0, 0]]\\n        \\n        return cur[-1][-1]\\n```\\n```java []\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        Arrays.sort(events, (a, b) -> (a[1] - b[1]));\\n        TreeMap<Integer, Integer> dp = new TreeMap<>();\\n        TreeMap<Integer, Integer> dp2 = new TreeMap<>();\\n        dp.put(0, 0);\\n        dp2.put(0, 0);\\n        for (int i = 0; i < k; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int cur = dp.lowerEntry(events[j][0]).getValue();\\n                if (cur + events[j][2] > dp2.lastEntry().getValue()) {\\n                    dp2.put(events[j][1], cur + events[j][2]);\\n                }\\n            }\\n            dp = dp2;\\n            dp2 = new TreeMap<>();\\n            dp2.put(0, 0);\\n        }\\n        return dp.lastEntry().getValue(); \\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        std::sort(events.begin(), events.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\\n            return a[1] < b[1];\\n        });\\n\\n        std::vector<std::vector<int>> dp = {{0, 0}};\\n        std::vector<std::vector<int>> dp2 = {{0, 0}};\\n\\n        for (int _ = 0; _ < k; ++_) {\\n            for (const auto& event : events) {\\n                int start = event[0];\\n                int end = event[1];\\n                int value = event[2];\\n\\n                int i = bisect(dp, start) - 1;\\n\\n                if (dp[i][1] + value > dp2.back()[1]) {\\n                    dp2.push_back({end, dp[i][1] + value});\\n                }\\n            }\\n\\n            dp.swap(dp2);\\n            dp2 = {{0, 0}};\\n        }\\n\\n        return dp.back()[1];        \\n    }\\n\\nprivate:\\n    int bisect(const std::vector<std::vector<int>>& arr, int target) {\\n        int low = 0;\\n        int high = arr.size();\\n\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (arr[mid][0] < target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "JavaScript"
                ],
                "code": "```javascript []\\n/**\\n * @param {number[][]} events\\n * @param {number} k\\n * @return {number}\\n */\\nvar maxValue = function(events, k) {\\n    events.sort((a, b) => a[1] - b[1]);\\n\\n    let dp = [[0, 0]];\\n    let dp2 = [[0, 0]];\\n\\n    for (let _ = 0; _ < k; _++) {\\n      for (let [start, end, value] of events) {\\n        let i = bisect(dp, [start]) - 1;\\n\\n        if (dp[i][1] + value > dp2[dp2.length - 1][1]) {\\n          dp2.push([end, dp[i][1] + value]);\\n        }\\n      }\\n\\n      [dp, dp2] = [dp2, [[0, 0]]];\\n    }\\n\\n    return dp[dp.length - 1][1];    \\n};\\n\\nvar bisect = function(arr, target) {\\n    var low = 0;\\n    var high = arr.length;\\n\\n    while (low < high) {\\n        var mid = Math.floor((low + high) / 2);\\n\\n        if (arr[mid][0] < target[0]) {\\n            low = mid + 1;\\n        } else {\\n            high = mid;\\n        }\\n    }\\n\\n    return low;\\n};\\n```\n```python []\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort(key=lambda x: x[1])\\n        cur, temp = [[0, 0]], [[0, 0]]\\n\\n        for _ in range(k):\\n            for start, end, value in events:\\n                i = bisect.bisect(cur, [start]) - 1\\n                if cur[i][1] + value > temp[-1][1]:\\n                    temp.append([end, cur[i][1] + value])\\n            \\n            cur, temp = temp, [[0, 0]]\\n        \\n        return cur[-1][-1]\\n```\n```java []\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        Arrays.sort(events, (a, b) -> (a[1] - b[1]));\\n        TreeMap<Integer, Integer> dp = new TreeMap<>();\\n        TreeMap<Integer, Integer> dp2 = new TreeMap<>();\\n        dp.put(0, 0);\\n        dp2.put(0, 0);\\n        for (int i = 0; i < k; i++) {\\n            for (int j = 0; j < n; j++) {\\n                int cur = dp.lowerEntry(events[j][0]).getValue();\\n                if (cur + events[j][2] > dp2.lastEntry().getValue()) {\\n                    dp2.put(events[j][1], cur + events[j][2]);\\n                }\\n            }\\n            dp = dp2;\\n            dp2 = new TreeMap<>();\\n            dp2.put(0, 0);\\n        }\\n        return dp.lastEntry().getValue(); \\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        std::sort(events.begin(), events.end(), [](const std::vector<int>& a, const std::vector<int>& b) {\\n            return a[1] < b[1];\\n        });\\n\\n        std::vector<std::vector<int>> dp = {{0, 0}};\\n        std::vector<std::vector<int>> dp2 = {{0, 0}};\\n\\n        for (int _ = 0; _ < k; ++_) {\\n            for (const auto& event : events) {\\n                int start = event[0];\\n                int end = event[1];\\n                int value = event[2];\\n\\n                int i = bisect(dp, start) - 1;\\n\\n                if (dp[i][1] + value > dp2.back()[1]) {\\n                    dp2.push_back({end, dp[i][1] + value});\\n                }\\n            }\\n\\n            dp.swap(dp2);\\n            dp2 = {{0, 0}};\\n        }\\n\\n        return dp.back()[1];        \\n    }\\n\\nprivate:\\n    int bisect(const std::vector<std::vector<int>>& arr, int target) {\\n        int low = 0;\\n        int high = arr.size();\\n\\n        while (low < high) {\\n            int mid = low + (high - low) / 2;\\n\\n            if (arr[mid][0] < target) {\\n                low = mid + 1;\\n            } else {\\n                high = mid;\\n            }\\n        }\\n\\n        return low;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3426597,
                "title": "python3-dynamic-programming-binary-search-various-implementations-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst sort the `events` by starting time. If you attend the current event, you can binary search the first event which can be attended after this (the event has the starting time higher than the end time of current choosen attending event). If not attend the current event, checking to the next event.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n###### Top-down\\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        n = len(events)        \\n\\n        def helper(val: int) -> int:\\n            l, r = 0, n - 1\\n            while l <= r:\\n                m = (l + r) // 2\\n                s, e, v = events[m]\\n                if s > val: r = m - 1\\n                else: l = m + 1\\n            return l\\n\\n        events.sort()\\n        @cache\\n        def dp(i: int, k: int) -> int:\\n            if not k or i >= n: return 0\\n            j = helper(events[i][1])\\n            return max(dp(i + 1, k), events[i][2] + dp(j, k - 1))\\n        return dp(0, k)\\n```\\n\\n- Time complexity: $$O(n*k*log(n))$$\\n- Space complexity: $$O(n*k)$$\\n\\n###### Top-down with bisect\\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        n = len(events)        \\n        events.sort()\\n        @cache\\n        def dp(i: int, k: int) -> int:\\n            if not k or i >= n: return 0\\n            j = bisect_right(events, [events[i][1], inf, inf])\\n            return max(dp(i + 1, k), events[i][2] + dp(j, k - 1))\\n        return dp(0, k)\\n```\\n\\n- Time complexity: $$O(n*k*log(n))$$\\n- Space complexity: $$O(n*k)$$\\n\\n###### Bottom-Up\\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        n = len(events)\\n        dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\\n        events.sort()\\n        starts = [x for x, y, z in events]\\n\\n        for i in range(n - 1, -1, -1):\\n            for j in range(1, k + 1):\\n                next_event = bisect_right(starts, events[i][1])\\n                dp[i][j] = max(dp[i + 1][j], events[i][2] + dp[next_event][j - 1])\\n        \\n        return dp[0][k]\\n```\\n\\n- Time complexity: $$O(n*k*log(n))$$\\n- Space complexity: $$O(n*k)$$\\n\\n###### Bottom-Up Optimize\\n```\\ndef maxValue(self, events: List[List[int]], k: int) -> int:\\n        n = len(events)\\n        dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\\n        events.sort()\\n        starts = [x for x, y, z in events]\\n\\n        for i in range(n - 1, -1, -1):\\n            next_event = bisect_right(starts, events[i][1])\\n            for j in range(1, k + 1):\\n                dp[i][j] = max(dp[i + 1][j], events[i][2] + dp[next_event][j - 1])\\n        \\n        return dp[0][k]\\n```\\n\\n- Time complexity: $$O(n*(log(n) + k))$$ ~ $$O(n*k)$$\\n- Space complexity: $$O(n*k)$$",
                "solutionTags": [
                    "Python3",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        n = len(events)        \\n\\n        def helper(val: int) -> int:\\n            l, r = 0, n - 1\\n            while l <= r:\\n                m = (l + r) // 2\\n                s, e, v = events[m]\\n                if s > val: r = m - 1\\n                else: l = m + 1\\n            return l\\n\\n        events.sort()\\n        @cache\\n        def dp(i: int, k: int) -> int:\\n            if not k or i >= n: return 0\\n            j = helper(events[i][1])\\n            return max(dp(i + 1, k), events[i][2] + dp(j, k - 1))\\n        return dp(0, k)\\n```\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        n = len(events)        \\n        events.sort()\\n        @cache\\n        def dp(i: int, k: int) -> int:\\n            if not k or i >= n: return 0\\n            j = bisect_right(events, [events[i][1], inf, inf])\\n            return max(dp(i + 1, k), events[i][2] + dp(j, k - 1))\\n        return dp(0, k)\\n```\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        n = len(events)\\n        dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\\n        events.sort()\\n        starts = [x for x, y, z in events]\\n\\n        for i in range(n - 1, -1, -1):\\n            for j in range(1, k + 1):\\n                next_event = bisect_right(starts, events[i][1])\\n                dp[i][j] = max(dp[i + 1][j], events[i][2] + dp[next_event][j - 1])\\n        \\n        return dp[0][k]\\n```\n```\\ndef maxValue(self, events: List[List[int]], k: int) -> int:\\n        n = len(events)\\n        dp = [[0 for _ in range(k + 1)] for _ in range(n + 1)]\\n        events.sort()\\n        starts = [x for x, y, z in events]\\n\\n        for i in range(n - 1, -1, -1):\\n            next_event = bisect_right(starts, events[i][1])\\n            for j in range(1, k + 1):\\n                dp[i][j] = max(dp[i + 1][j], events[i][2] + dp[next_event][j - 1])\\n        \\n        return dp[0][k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052697,
                "title": "why-is-this-dp-solution-giving-wrong-answer",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> dp;\\n    \\n    int fun(int i, int k, int rb, vector<vector<int>>& v){\\n        if(k==0 || i==n)\\n            return 0;\\n        \\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        int val=0;\\n        if(v[i][0] > rb){\\n            val = max(v[i][2] + fun(i+1, k-1, v[i][1], v) ,  fun(i+1, k, rb, v));\\n        }else{\\n            val = fun(i+1, k, rb, v);\\n        }\\n        \\n        return dp[i][k]= val;\\n    }\\n    \\n    static bool cmp(vector<int>&v1, vector<int>&v2){\\n        if(v1[1] != v2[1])\\n            return (v1[1] < v2[1]);\\n        else\\n            return v1[0]<v2[0];\\n    }\\n    \\n    int maxValue(vector<vector<int>>& v, int k) {\\n        n = v.size();\\n        dp.clear();\\n        dp.resize(n+2, vector<int>(k+2, -1));\\n        \\n        sort(v.begin(), v.end(), cmp);\\n        int ans = fun(0, k, 0, v);\\n        return ans;\\n    }\\n};\\n```\\n\\nTest Case:\\nevents = [[1,2,4],[3,4,3],[2,3,10]], k = 2\\nMy Output : 13\\nExpected Output : 10\\n\\nAfter 2 hours of scratching my head, i could not debug, what\\'s wrong in this dp approach, please help out !!",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> dp;\\n    \\n    int fun(int i, int k, int rb, vector<vector<int>>& v){\\n        if(k==0 || i==n)\\n            return 0;\\n        \\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        int val=0;\\n        if(v[i][0] > rb){\\n            val = max(v[i][2] + fun(i+1, k-1, v[i][1], v) ,  fun(i+1, k, rb, v));\\n        }else{\\n            val = fun(i+1, k, rb, v);\\n        }\\n        \\n        return dp[i][k]= val;\\n    }\\n    \\n    static bool cmp(vector<int>&v1, vector<int>&v2){\\n        if(v1[1] != v2[1])\\n            return (v1[1] < v2[1]);\\n        else\\n            return v1[0]<v2[0];\\n    }\\n    \\n    int maxValue(vector<vector<int>>& v, int k) {\\n        n = v.size();\\n        dp.clear();\\n        dp.resize(n+2, vector<int>(k+2, -1));\\n        \\n        sort(v.begin(), v.end(), cmp);\\n        int ans = fun(0, k, 0, v);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1795254,
                "title": "python3-binary-search-top-down-dp-99-100-runtime",
                "content": "If you have any questions let me know.\\n\\n```\\nimport bisect\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        if k == 1: # optimization for TLE test case 57/67\\n            return max([event[2] for event in events])\\n        \\n        events.sort()\\n        event_starts = [event[0] for event in events] # enables binary search\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n            if j == 0: # out of turns\\n                return 0\\n            if i >= len(events): # end of events array\\n                return 0\\n            max_score = events[i][2]\\n            \\n            # get minimum index where start day is greater than current end day\\n            next_index_minimum = bisect.bisect_left(event_starts, events[i][1] + 1)\\n            \\n            # check each possibility from the minimum next index until end of the array\\n            for k in range(next_index_minimum, len(events)):\\n                max_score = max(max_score, events[i][2] + dp(k, j - 1))\\n            \\n            # check if we can get a better score if we skip this index altogether\\n            max_score = max(max_score, dp(i + 1, j))\\n            return max_score\\n        return dp(0, k)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nimport bisect\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        if k == 1: # optimization for TLE test case 57/67\\n            return max([event[2] for event in events])\\n        \\n        events.sort()\\n        event_starts = [event[0] for event in events] # enables binary search\\n        \\n        @lru_cache(None)\\n        def dp(i, j):\\n            if j == 0: # out of turns\\n                return 0\\n            if i >= len(events): # end of events array\\n                return 0\\n            max_score = events[i][2]\\n            \\n            # get minimum index where start day is greater than current end day\\n            next_index_minimum = bisect.bisect_left(event_starts, events[i][1] + 1)\\n            \\n            # check each possibility from the minimum next index until end of the array\\n            for k in range(next_index_minimum, len(events)):\\n                max_score = max(max_score, events[i][2] + dp(k, j - 1))\\n            \\n            # check if we can get a better score if we skip this index altogether\\n            max_score = max(max_score, dp(i + 1, j))\\n            return max_score\\n        return dp(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1403243,
                "title": "lis-java",
                "content": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n         Arrays.sort(events,(a,b)->{\\n             return a[0]-b[0];\\n         });\\n        int max=0;\\n        int[][] dp=new int[events.length+1][k+1];\\n        for(int[] row:dp)Arrays.fill(row,-1);\\n        for(int i=0;i<events.length;i++){\\n            max=Math.max(max,solve(events,k-1,i,dp)+events[i][2]);\\n            \\n        }\\n        return max;\\n    }\\n    \\n    public int solve(int[][] events,int k,int index,int[][] dp){\\n        int max=0;\\n        \\n        if(k==0)return 0;\\n        if(dp[index][k]!=-1)return dp[index][k];\\n        \\n        for(int i=index+1;i<events.length;i++){\\n            if(events[i][0]>events[index][1]){\\n                max=Math.max(max,solve(events,k-1,i,dp)+events[i][2]);\\n            }\\n        }\\n        return dp[index][k]= max;\\n        \\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n         Arrays.sort(events,(a,b)->{\\n             return a[0]-b[0];\\n         });\\n        int max=0;\\n        int[][] dp=new int[events.length+1][k+1];\\n        for(int[] row:dp)Arrays.fill(row,-1);\\n        for(int i=0;i<events.length;i++){\\n            max=Math.max(max,solve(events,k-1,i,dp)+events[i][2]);\\n            \\n        }\\n        return max;\\n    }\\n    \\n    public int solve(int[][] events,int k,int index,int[][] dp){\\n        int max=0;\\n        \\n        if(k==0)return 0;\\n        if(dp[index][k]!=-1)return dp[index][k];\\n        \\n        for(int i=index+1;i<events.length;i++){\\n            if(events[i][0]>events[index][1]){\\n                max=Math.max(max,solve(events,k-1,i,dp)+events[i][2]);\\n            }\\n        }\\n        return dp[index][k]= max;\\n        \\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767581,
                "title": "c-recursion-and-memoization-with-explaination",
                "content": "The Logic behind the the question is at every event, we have to decide weather going to that event will be benificail or not going to that will be be benificial\\nNow, for that we have to try out all possibilities \\n#Steps\\n* 1. Sort the array according to the start time \\n* 2. Iterate over it and and store the prev (ie. end time fo event) if choosen to go on that.\\n* 3. return the max of take and notake\\n\\n\\n####  Using recursion Gives TLE\\n\\n```\\nclass Solution {\\npublic:\\n    // Recursive function using take, nottake technique\\n    int fun(int ind, vector<vector<int>>& events, int k, int n, int prev)\\n    {\\n        // if we try to go outof the bound or our k is exhausted return 0\\n        if(ind>=n || k == 0)\\n            return 0;\\n        \\n        int nottake = 0 + fun(ind+1,events,k,n,prev);\\n        int take = INT_MIN;\\n        if(k && (prev == -1000 || prev<events[ind][0]))\\n        {\\n            // If you are taking a particular event then prev time will be the end time of current end time of the event for next iterations.\\n            prev = events[ind][1];     \\n            take = events[ind][2] + fun(ind+1,events,k-1,n,prev);\\n        }\\n        // At the end we return maximum of take and nottake\\n        return max(take,nottake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        int prev = -1000;                   // Initialize a prev Value with some negetive value\\n        // sort the events according to the start time, if it is equal then sort according to end time\\n        sort(events.begin(), events.end()); \\n        return fun(0,events,k,n,prev);\\n    }\\n};\\n```\\n\\n\\n### Optimized Using memoization - Accepted\\n```\\nclass Solution {\\npublic:\\n    int solve(int ind, vector<vector<int>>& events, int k, int n, vector<vector<int>> &dp)\\n    {\\n        int i;\\n        if(ind >= n || k == 0)\\n            return 0;\\n\\n        if(dp[ind][k] != -1)\\n            return dp[ind][k];\\n\\n        // just a slight change , since the array is sorted\\n        // finding the next event which we can attend\\n        for(i = ind + 1; i < n; i++)\\n            if(events[i][0] > events[ind][1])\\n                break;\\n        int take = events[ind][2] + solve(i, events, k-1, n, dp);\\n        int nottake = solve(ind+1, events, k, n, dp);\\n        \\n        return dp[ind][k] = max(take, nottake);\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) \\n    {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        return solve(0,events,k,n,dp);\\n    }\\n};\\n```\\n\\n\\nPlease Upvote if you find it Helpful",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Recursive function using take, nottake technique\\n    int fun(int ind, vector<vector<int>>& events, int k, int n, int prev)\\n    {\\n        // if we try to go outof the bound or our k is exhausted return 0\\n        if(ind>=n || k == 0)\\n            return 0;\\n        \\n        int nottake = 0 + fun(ind+1,events,k,n,prev);\\n        int take = INT_MIN;\\n        if(k && (prev == -1000 || prev<events[ind][0]))\\n        {\\n            // If you are taking a particular event then prev time will be the end time of current end time of the event for next iterations.\\n            prev = events[ind][1];     \\n            take = events[ind][2] + fun(ind+1,events,k-1,n,prev);\\n        }\\n        // At the end we return maximum of take and nottake\\n        return max(take,nottake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        int prev = -1000;                   // Initialize a prev Value with some negetive value\\n        // sort the events according to the start time, if it is equal then sort according to end time\\n        sort(events.begin(), events.end()); \\n        return fun(0,events,k,n,prev);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int solve(int ind, vector<vector<int>>& events, int k, int n, vector<vector<int>> &dp)\\n    {\\n        int i;\\n        if(ind >= n || k == 0)\\n            return 0;\\n\\n        if(dp[ind][k] != -1)\\n            return dp[ind][k];\\n\\n        // just a slight change , since the array is sorted\\n        // finding the next event which we can attend\\n        for(i = ind + 1; i < n; i++)\\n            if(events[i][0] > events[ind][1])\\n                break;\\n        int take = events[ind][2] + solve(i, events, k-1, n, dp);\\n        int nottake = solve(ind+1, events, k, n, dp);\\n        \\n        return dp[ind][k] = max(take, nottake);\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) \\n    {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        return solve(0,events,k,n,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766406,
                "title": "c-memoization-binary-search",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach:**\\n1. for each event we have 2 choices: attend or not attend\\n2. Not-Attend: just skip to next event \\n3. Attend: if start time of current event >end time of previously attended event\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> memo;\\n    \\n    // searching for 1st next non-conflicting event \\n    int search(vector<vector<int>>& events, int end, int idx){\\n        int n=events.size();\\n        int l=idx, r=n-1;\\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            int start=events[m][0];\\n            if(start>end){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        \\n        return ((l<n && events[l][0]>end) ? l:-1);\\n    }\\n    \\n    int profit(vector<vector<int>>& events, int n, int k, int idx){\\n        if(idx==n || k==0) return 0;\\n        \\n        if(memo[idx][k]!=-1) return memo[idx][k];\\n        \\n        int maxval=0;\\n        \\n        // not attend\\n        maxval = profit(events, n, k, idx+1);\\n        \\n        // attend event\\n        int next_possible_idx = search(events, events[idx][1], idx+1);\\n        maxval = max(maxval, events[idx][2] + (next_possible_idx==-1 ? 0:profit(events,n,k-1,next_possible_idx)));\\n        \\n        return memo[idx][k]=maxval;\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n=events.size();\\n        sort(events.begin(),events.end());\\n        \\n        memo.resize(n,vector<int>(k+1,-1));\\n        \\n        return profit(events,n,k,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<vector<int>> memo;\\n    \\n    // searching for 1st next non-conflicting event \\n    int search(vector<vector<int>>& events, int end, int idx){\\n        int n=events.size();\\n        int l=idx, r=n-1;\\n        while(l<r){\\n            int m=l+(r-l)/2;\\n            int start=events[m][0];\\n            if(start>end){\\n                r=m;\\n            }else{\\n                l=m+1;\\n            }\\n        }\\n        \\n        return ((l<n && events[l][0]>end) ? l:-1);\\n    }\\n    \\n    int profit(vector<vector<int>>& events, int n, int k, int idx){\\n        if(idx==n || k==0) return 0;\\n        \\n        if(memo[idx][k]!=-1) return memo[idx][k];\\n        \\n        int maxval=0;\\n        \\n        // not attend\\n        maxval = profit(events, n, k, idx+1);\\n        \\n        // attend event\\n        int next_possible_idx = search(events, events[idx][1], idx+1);\\n        maxval = max(maxval, events[idx][2] + (next_possible_idx==-1 ? 0:profit(events,n,k-1,next_possible_idx)));\\n        \\n        return memo[idx][k]=maxval;\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n=events.size();\\n        sort(events.begin(),events.end());\\n        \\n        memo.resize(n,vector<int>(k+1,-1));\\n        \\n        return profit(events,n,k,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766621,
                "title": "easy-fast-c",
                "content": "# Intuition\\nSort and use dp.\\n\\n# Approach\\n- The main idea is to ensure that the index we are currently on can be taken into consideration.\\n- Intuitively, the first index can always be taken, and then we ensure that we move only to a valid next index.\\n- Other parts of the solution are simple take/notTake and memoization. \\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int ind, int k, vector<vector<int>> &events, vector<vector<int>> &dp){\\n        if(ind == events.size() || k == 0){\\n            return 0;\\n        }\\n        if(dp[ind][k] != -1) return dp[ind][k];\\n        int take = events[ind][2];\\n        for(int i = ind+1; i < events.size(); ++i){\\n            if(events[ind][1] < events[i][0]){\\n                take += f(i,k-1,events,dp);\\n                break;\\n            }\\n        }\\n        int notTake = 0;\\n        notTake = f(ind+1, k, events, dp);\\n        return dp[ind][k] = max(take,notTake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(),events.end());\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return f(0,k,events,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int ind, int k, vector<vector<int>> &events, vector<vector<int>> &dp){\\n        if(ind == events.size() || k == 0){\\n            return 0;\\n        }\\n        if(dp[ind][k] != -1) return dp[ind][k];\\n        int take = events[ind][2];\\n        for(int i = ind+1; i < events.size(); ++i){\\n            if(events[ind][1] < events[i][0]){\\n                take += f(i,k-1,events,dp);\\n                break;\\n            }\\n        }\\n        int notTake = 0;\\n        notTake = f(ind+1, k, events, dp);\\n        return dp[ind][k] = max(take,notTake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(),events.end());\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return f(0,k,events,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766407,
                "title": "c-recursive-iterative-dp-w-cached-upper-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code utilizes Depth-First Search (DFS) combined with Binary Search to solve the problem efficiently. The \\'attend\\' function uses DFS to explore all possible event combinations, while \\'upper_bound\\' binary search identifies the next available event with a start time greater than the current event\\'s end time. This approach ensures optimal time complexity by avoiding redundant calculations, resulting in an effective solution for finding the maximum value while adhering to the event attendance constraints.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe second approach, we transform the recursive version into an iterative version using dynamic programming to avoid redundant calculations. By performing binary search for each event beforehand and storing the results in a cache, we can optimize the main loop of the \\'maxValue\\' function. This approach eliminates the need for recursion and improves the efficiency of the solution.\\n\\nA very similar \\'hard\" question can be solved in the same manner.\\n[1235. Maximum Profit in Job Scheduling\\n](https://leetcode.com/problems/maximum-profit-in-job-scheduling/description/)\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * num * log n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n * num)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int n;\\n\\n    int attend(int i, int num, vector<vector<int>>& events){\\n        if (i == n || num == 0) return 0;\\n        if (dp[i][num] != -1) return dp[i][num];\\n\\n        // Attend the event i\\n        int j = upper_bound(events.begin()+i, events.end(), vector<int>{events[i][1]+1, 0, 0}) - events.begin();\\n        int attend_i = events[i][2] + attend(j, num - 1, events);\\n\\n        // Skip the event i\\n        int skip_i = attend(i+1, num, events);\\n\\n        // Choose the maximum of attend_i& skip_i\\n        int ans = max(attend_i, skip_i);\\n        return dp[i][num] = ans;\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int num) {\\n        n = events.size();\\n        sort(events.begin(), events.end());\\n        dp.assign(n + 1, vector<int>(num + 1, -1));\\n        return attend(0, num, events);\\n    }\\n};\\n\\n```\\n# code with Explaination in Comment\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int n;\\n\\n    int attend(int i, int num, vector<vector<int>>& events){\\n        // Base case: If we have attended num events or reached the end of events list, return 0.\\n        if (i == n || num == 0) return 0;\\n\\n        // If the result for this state is already calculated, return it from the dp table.\\n        if (dp[i][num] != -1) return dp[i][num];\\n\\n        // Attend the event i and move on to the next available event that starts after this one ends.\\n        int j = upper_bound(events.begin() + i, events.end(), vector<int>{events[i][1] + 1, 0, 0}) - events.begin();\\n        int attend_i = events[i][2] + attend(j, num - 1, events);\\n\\n        // Skip the event i and move on to the next event.\\n        int skip_i = attend(i + 1, num, events);\\n\\n        // Choose the maximum between attending the current event (attend_i) and skipping it (skip_i).\\n        int ans = max(attend_i, skip_i);\\n\\n        // Store the result in the dp table and return it.\\n        return dp[i][num] = ans;\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int num) {\\n        // Get the total number of events in the input.\\n        n = events.size();\\n\\n        // Sort the events list based on their start times.\\n        sort(events.begin(), events.end());\\n\\n        // Initialize the dp table with -1 (indicating that the result for this state is not yet calculated).\\n        dp.assign(n + 1, vector<int>(num + 1, -1));\\n\\n        // Start the recursive process and return the maximum value possible.\\n        return attend(0, num, events);\\n    }\\n};\\n\\n```\\n# Note on ```vector<int>{events[i][1]+1, 0, 0}```\\n\\nJust an element with the type ```vector<int>```. We want to find the least upper bound for ```vector<int>{events[i][1]+1, 0, 0}``` which is eventually the next event.\\nin other words\\n``` min{{x, y, z } in events with {events[i][1]+1, 0, 0}<{x, y, z} }```\\n# Code for iterative Version (Buttom-up) with Precomputations for Binary Search\\n```\\n    vector<vector<int>> dp;\\n    int n;\\n    vector<int> next; \\n    void attend_iterate(int num, vector<vector<int>>& events){\\n        dp.assign(n + 1, vector<int>(num + 1, 0));\\n        \\n        //Perform binary search and store results in a table\\n        next.assign(n, n);\\n        for(int i=0; i<n; i++){\\n            next[i]=upper_bound(events.begin()+i, events.end(), \\n            vector<int>{events[i][1]+1, 0, 0}) - events.begin();\\n        }\\n        \\n        for (int i=n-1; i>=0; i--){\\n            for (int k=1; k<=num; k++){\\n                int j = next[i];\\n                int attend_i = events[i][2] + dp[j][k-1];\\n                int skip_i = dp[i+1][k];\\n                dp[i][k]=max(attend_i, skip_i);\\n            }           \\n        }\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int num) {\\n        n = events.size();\\n        sort(events.begin(), events.end());\\n        attend_iterate(num, events);\\n        return dp[0][num];\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int n;\\n\\n    int attend(int i, int num, vector<vector<int>>& events){\\n        if (i == n || num == 0) return 0;\\n        if (dp[i][num] != -1) return dp[i][num];\\n\\n        // Attend the event i\\n        int j = upper_bound(events.begin()+i, events.end(), vector<int>{events[i][1]+1, 0, 0}) - events.begin();\\n        int attend_i = events[i][2] + attend(j, num - 1, events);\\n\\n        // Skip the event i\\n        int skip_i = attend(i+1, num, events);\\n\\n        // Choose the maximum of attend_i& skip_i\\n        int ans = max(attend_i, skip_i);\\n        return dp[i][num] = ans;\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int num) {\\n        n = events.size();\\n        sort(events.begin(), events.end());\\n        dp.assign(n + 1, vector<int>(num + 1, -1));\\n        return attend(0, num, events);\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int n;\\n\\n    int attend(int i, int num, vector<vector<int>>& events){\\n        // Base case: If we have attended num events or reached the end of events list, return 0.\\n        if (i == n || num == 0) return 0;\\n\\n        // If the result for this state is already calculated, return it from the dp table.\\n        if (dp[i][num] != -1) return dp[i][num];\\n\\n        // Attend the event i and move on to the next available event that starts after this one ends.\\n        int j = upper_bound(events.begin() + i, events.end(), vector<int>{events[i][1] + 1, 0, 0}) - events.begin();\\n        int attend_i = events[i][2] + attend(j, num - 1, events);\\n\\n        // Skip the event i and move on to the next event.\\n        int skip_i = attend(i + 1, num, events);\\n\\n        // Choose the maximum between attending the current event (attend_i) and skipping it (skip_i).\\n        int ans = max(attend_i, skip_i);\\n\\n        // Store the result in the dp table and return it.\\n        return dp[i][num] = ans;\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int num) {\\n        // Get the total number of events in the input.\\n        n = events.size();\\n\\n        // Sort the events list based on their start times.\\n        sort(events.begin(), events.end());\\n\\n        // Initialize the dp table with -1 (indicating that the result for this state is not yet calculated).\\n        dp.assign(n + 1, vector<int>(num + 1, -1));\\n\\n        // Start the recursive process and return the maximum value possible.\\n        return attend(0, num, events);\\n    }\\n};\\n\\n```\n```vector<int>{events[i][1]+1, 0, 0}```\n```vector<int>```\n```vector<int>{events[i][1]+1, 0, 0}```\n``` min{{x, y, z } in events with {events[i][1]+1, 0, 0}<{x, y, z} }```\n```\\n    vector<vector<int>> dp;\\n    int n;\\n    vector<int> next; \\n    void attend_iterate(int num, vector<vector<int>>& events){\\n        dp.assign(n + 1, vector<int>(num + 1, 0));\\n        \\n        //Perform binary search and store results in a table\\n        next.assign(n, n);\\n        for(int i=0; i<n; i++){\\n            next[i]=upper_bound(events.begin()+i, events.end(), \\n            vector<int>{events[i][1]+1, 0, 0}) - events.begin();\\n        }\\n        \\n        for (int i=n-1; i>=0; i--){\\n            for (int k=1; k<=num; k++){\\n                int j = next[i];\\n                int attend_i = events[i][2] + dp[j][k-1];\\n                int skip_i = dp[i+1][k];\\n                dp[i][k]=max(attend_i, skip_i);\\n            }           \\n        }\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int num) {\\n        n = events.size();\\n        sort(events.begin(), events.end());\\n        attend_iterate(num, events);\\n        return dp[0][num];\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2646132,
                "title": "c-recursion-memoization-tabulation-01-knapsack",
                "content": "# Method -1 [Recursion]\\n![image](https://assets.leetcode.com/users/images/f64edf2f-b60f-46cf-b5a6-8090fa00d8e4_1664631994.2169175.png)\\n\\n**T->O(Expo) && S->O(n)[Recursion stack space]**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int i,int k,vector<vector<int>>& eve,vector<int>& st,int n){\\n\\t\\t\\t\\tif(i==n || k==0) return 0;\\n\\t\\t\\t\\tint ind=upper_bound(st.begin(),st.end(),eve[i][1])-st.begin();\\n\\t\\t\\t\\tint pick=eve[i][2]+f(ind,k-1,eve,st,n);\\n\\t\\t\\t\\tint notpick=f(i+1,k,eve,st,n);\\n\\t\\t\\t\\treturn max(pick,notpick);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint maxValue(vector<vector<int>>& eve, int k) {\\n\\t\\t\\t\\tint n=eve.size();\\n\\t\\t\\t\\tsort(eve.begin(),eve.end());\\n\\t\\t\\t\\tvector<int> st;\\n\\t\\t\\t\\tfor(auto i: eve) st.push_back(i[0]);\\n\\t\\t\\t\\treturn f(0,k,eve,st,n);\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n# Method -2 [Memoization]\\n\\n![image](https://assets.leetcode.com/users/images/8af88e7c-8947-4aa3-bdf5-a0810ad25971_1664632143.6026685.png)\\n\\n**T->O(kn) && S->O(kn) + O(n)[Recursion stack space]**\\n\\t\\t\\n\\t\\tclass Solution {\\n\\tpublic:\\n\\t\\tint f(int i,int k,vector<vector<int>>& eve,vector<int>& st,int n,vector<vector<int>>& dp){\\n\\t\\t\\tif(i==n || k==0) return 0;\\n\\t\\t\\tif(dp[i][k]!=-1) return dp[i][k];\\n\\t\\t\\tint ind=upper_bound(st.begin(),st.end(),eve[i][1])-st.begin();\\n\\t\\t\\tint pick=eve[i][2]+f(ind,k-1,eve,st,n,dp);\\n\\t\\t\\tint notpick=f(i+1,k,eve,st,n,dp);\\n\\t\\t\\treturn dp[i][k]=max(pick,notpick);\\n\\t\\t}\\n\\n\\t\\tint maxValue(vector<vector<int>>& eve, int k) {\\n\\t\\t\\tint n=eve.size();\\n\\t\\t\\tsort(eve.begin(),eve.end());\\n\\t\\t\\tvector<int> st;\\n\\t\\t\\tvector<vector<int>> dp(n,vector<int>(k+1,-1));\\n\\t\\t\\tfor(auto i: eve) st.push_back(i[0]);\\n\\t\\t\\treturn f(0,k,eve,st,n,dp);\\n\\t\\t}\\n\\t};\\t\\n\\t\\n# Method -3 [Tabulation]\\t\\n![image](https://assets.leetcode.com/users/images/f1faeee0-43f4-4329-a94d-e3c9844f79c7_1664632526.840584.png)\\n\\n**T->O(kn) && S->O(kn)**\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxTwoEvents(vector<vector<int>>& eve) {\\n\\t\\t\\tint n=eve.size();\\n\\t\\t\\tsort(eve.begin(),eve.end());\\n\\t\\t\\tvector<int> st;\\n\\t\\t\\tvector<vector<int>> dp(n+1,vector<int>(3,0));\\n\\t\\t\\tfor(auto i: eve) st.push_back(i[0]);\\n\\t\\t\\tfor(int i=n-1;i>=0;i--){\\n\\t\\t\\t\\tfor(int count=1;count>=0;count--){\\n\\t\\t\\t\\t\\tint ind=upper_bound(st.begin(),st.end(),eve[i][1])-st.begin();\\n\\t\\t\\t\\t\\tint pick = eve[i][2] + dp[ind][count+1];\\n\\t\\t\\t\\t\\tint notpick = dp[i+1][count];\\n\\t\\t\\t\\t\\tdp[i][count]=max(pick,notpick);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn dp[0][0];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint f(int i,int k,vector<vector<int>>& eve,vector<int>& st,int n){\\n\\t\\t\\t\\tif(i==n || k==0) return 0;\\n\\t\\t\\t\\tint ind=upper_bound(st.begin(),st.end(),eve[i][1])-st.begin();\\n\\t\\t\\t\\tint pick=eve[i][2]+f(ind,k-1,eve,st,n);\\n\\t\\t\\t\\tint notpick=f(i+1,k,eve,st,n);\\n\\t\\t\\t\\treturn max(pick,notpick);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1721451,
                "title": "simple-java-memoization-solution",
                "content": "class Solution {\\n   \\n\\t   public class Event{\\n\\t\\t\\tint s , e , v;\\n\\n\\t\\t\\tEvent(int s , int e , int v){\\n\\t\\t\\t\\tthis.s = s;\\n\\t\\t\\t\\tthis.e = e;\\n\\t\\t\\t\\tthis.v = v;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t\\n\\t\\tpublic int maxValue(int[][] event, int k) {\\n\\t\\t\\tint n = event.length;\\n\\t\\t\\tEvent[] events = new Event[n];\\n\\n\\t\\t\\tfor(int i = 0; i < n; i++)\\n\\t\\t\\t\\tevents[i] = new Event(event[i][0] ,event[i][1] ,event[i][2]);\\n\\n\\t\\t\\tArrays.sort(events ,(a ,b) -> a.s - b.s);\\n\\n\\t\\t\\tint[][] memo = new int[n][k];\\n\\t\\t\\tfor(int[] m : memo)\\n\\t\\t\\t\\tArrays.fill(m ,-1);\\n\\n\\t\\t\\treturn dfs(events ,memo ,0 ,k);\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int dfs(Event[] events ,int[][] memo ,int currIdx ,int k){\\n\\t\\t\\tif(currIdx == events.length || k == 0)\\n\\t\\t\\t\\treturn 0;\\n\\n\\t\\t\\tif(memo[currIdx][k - 1] == -1){\\n\\t\\t\\t\\tint idx = binarySearch(events ,currIdx);\\n\\t\\t\\t\\tmemo[currIdx][k - 1] = Math.max(events[currIdx].v + dfs(events ,memo ,idx ,k - 1) , \\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tdfs(events ,memo ,currIdx + 1 ,k));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn memo[currIdx][k - 1];\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int binarySearch(Event[] events ,int idx){\\n\\t\\t\\tint lo = idx + 1 ,hi = events.length - 1 ,res = events.length;\\n\\n\\t\\t\\twhile(lo <= hi){\\n\\t\\t\\t\\tint mid = lo + ((hi - lo) / 2);\\n\\n\\t\\t\\t\\tif(events[mid].s > events[idx].e){\\n\\t\\t\\t\\t\\tres = Math.min(res ,mid);\\n\\t\\t\\t\\t\\thi = mid - 1;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tlo = mid + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\t\\n\\n}",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n   \\n\\t   public class Event{\\n\\t\\t\\tint s , e , v;\\n\\n\\t\\t\\tEvent(int s , int e , int v){\\n\\t\\t\\t\\tthis.s = s;\\n\\t\\t\\t\\tthis.e = e;\\n\\t\\t\\t\\tthis.v = v;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3770375,
                "title": "recursion-memoization-similar-problems-time-complexity-analysis",
                "content": "# Similar Problems:\\n- [1218. Longest Arithmetic Subsequence of Given Difference](https://leetcode.com/problems/longest-arithmetic-subsequence-of-given-difference/)\\n- [1353. Maximum Number of Events That Can Be Attended](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/)\\n\\n# Intuition\\nChoice problem like previous day problem. For each entry we have two options **(1) take that entry or, (2) not take that entry**.\\n- If we take this entry, we need to consider next valid entry. Therefore, we need to find the **next valid index**. Then do recursive backtrack on that.\\n- If we don\\'t take this entry, we can simply do recursive backtrack on `idx+1`.\\n- Return the maximum of `(take, notTake)`.\\n\\n# Code With Recursion Only:\\nFirst we are sure this is a recursion problem, as we can divide it into sub problems and calculate them.\\n## Complexity\\n- Time complexity: $$O(N^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N^2)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code [TLE]\\n``` Java []\\nclass Solution {\\n    int n;\\n    public int maxValue(int[][] events, int k) {\\n        n = events.length;\\n        Arrays.sort(events, (a,b) -> a[0] == b[0] ? a[1]-b[1] : a[0]-b[0]);\\n        return backtrack(0, events, k);\\n    }\\n\\n    int backtrack(int idx, int[][] events, int k) {\\n        if(idx >= n || k == 0) {\\n            return 0;\\n        }\\n\\n        int nextValidIdx = idx+1;\\n\\n        for( ; nextValidIdx < n; nextValidIdx++) {\\n            if(events[nextValidIdx][0] > events[idx][1]) {\\n                break;\\n            }\\n        }\\n\\n        // take this\\n        int take = events[idx][2] + backtrack(nextValidIdx, events, k-1);\\n        // don\\'t take this\\n        int notTake = backtrack(idx+1, events, k);\\n        return Math.max(take, notTake);\\n    }\\n}\\n```\\n\\n# Recursion + Memoization:\\nOnly solving with recursion gives TLE. So, there are some sub problems that are being re-calculated several times. To fix it, we need to use memoization. But which parameters can be tracked to keep memoization. \\nWe can see the dynamic variables are `idx` and `k`. So, we can memoize based on these fields.\\n## Complexity\\n- Time complexity: $$O(N*K)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N*K)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code [Beats 87%]\\n``` Java []\\nclass Solution {\\n    int n;\\n    int[][] memo;\\n    public int maxValue(int[][] events, int k) {\\n        n = events.length;\\n        Arrays.sort(events, (a,b) -> a[0] == b[0] ? a[1]-b[1] : a[0]-b[0]);\\n        memo = new int[n+1][k+1];\\n        for(int[] mem:memo) {\\n            Arrays.fill(mem, -1);\\n        }\\n        return backtrack(0, events, k);\\n    }\\n\\n    int backtrack(int idx, int[][] events, int k) {\\n        if(idx >= n || k == 0) {\\n            return 0;\\n        }\\n        if(memo[idx][k] != -1) {\\n            return memo[idx][k];\\n        }\\n\\n        int nextValidIdx = idx+1;\\n\\n        for( ; nextValidIdx < n; nextValidIdx++) {\\n            if(events[nextValidIdx][0] > events[idx][1]) {\\n                break;\\n            }\\n        }\\n\\n        // take this\\n        int take = events[idx][2] + backtrack(nextValidIdx, events, k-1);\\n\\n        // don\\'t take this\\n        int notTake = backtrack(idx+1, events, k);\\n        return memo[idx][k] = Math.max(take, notTake);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Backtracking",
                    "Recursion",
                    "Memoization"
                ],
                "code": "``` Java []\\nclass Solution {\\n    int n;\\n    public int maxValue(int[][] events, int k) {\\n        n = events.length;\\n        Arrays.sort(events, (a,b) -> a[0] == b[0] ? a[1]-b[1] : a[0]-b[0]);\\n        return backtrack(0, events, k);\\n    }\\n\\n    int backtrack(int idx, int[][] events, int k) {\\n        if(idx >= n || k == 0) {\\n            return 0;\\n        }\\n\\n        int nextValidIdx = idx+1;\\n\\n        for( ; nextValidIdx < n; nextValidIdx++) {\\n            if(events[nextValidIdx][0] > events[idx][1]) {\\n                break;\\n            }\\n        }\\n\\n        // take this\\n        int take = events[idx][2] + backtrack(nextValidIdx, events, k-1);\\n        // don\\'t take this\\n        int notTake = backtrack(idx+1, events, k);\\n        return Math.max(take, notTake);\\n    }\\n}\\n```\n``` Java []\\nclass Solution {\\n    int n;\\n    int[][] memo;\\n    public int maxValue(int[][] events, int k) {\\n        n = events.length;\\n        Arrays.sort(events, (a,b) -> a[0] == b[0] ? a[1]-b[1] : a[0]-b[0]);\\n        memo = new int[n+1][k+1];\\n        for(int[] mem:memo) {\\n            Arrays.fill(mem, -1);\\n        }\\n        return backtrack(0, events, k);\\n    }\\n\\n    int backtrack(int idx, int[][] events, int k) {\\n        if(idx >= n || k == 0) {\\n            return 0;\\n        }\\n        if(memo[idx][k] != -1) {\\n            return memo[idx][k];\\n        }\\n\\n        int nextValidIdx = idx+1;\\n\\n        for( ; nextValidIdx < n; nextValidIdx++) {\\n            if(events[nextValidIdx][0] > events[idx][1]) {\\n                break;\\n            }\\n        }\\n\\n        // take this\\n        int take = events[idx][2] + backtrack(nextValidIdx, events, k-1);\\n\\n        // don\\'t take this\\n        int notTake = backtrack(idx+1, events, k);\\n        return memo[idx][k] = Math.max(take, notTake);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768040,
                "title": "c-very-clean-dp-solution-77-72-68-5",
                "content": "\\n# Approach\\nCode is self explanatory.\\nSimple DP.\\nMaybe the only trick is to sort in terms of start times.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(int index, vector<vector<int>>& events, int k, vector<vector<int>>&dp){\\n        if(index>=events.size()||k==0)return 0;\\n        if(dp[index][k]!=-1)return dp[index][k];\\n        int ans = helper(index+1,events,k,dp);\\n        int j=events.size();\\n        for(int i = index+1; i<events.size(); i++){\\n            if(events[i][0]>events[index][1]){\\n                j=i;\\n                break;\\n            }\\n        }\\n        ans=max(ans,events[index][2]+helper(j,events,k-1,dp));\\n        return dp[index][k]=ans;\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        vector<vector<int>> dp(events.size(),vector<int>(k+1,-1));\\n        return helper(0,events,k,dp);\\n    }\\n};\\n```\\n\\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(int index, vector<vector<int>>& events, int k, vector<vector<int>>&dp){\\n        if(index>=events.size()||k==0)return 0;\\n        if(dp[index][k]!=-1)return dp[index][k];\\n        int ans = helper(index+1,events,k,dp);\\n        int j=events.size();\\n        for(int i = index+1; i<events.size(); i++){\\n            if(events[i][0]>events[index][1]){\\n                j=i;\\n                break;\\n            }\\n        }\\n        ans=max(ans,events[index][2]+helper(j,events,k-1,dp));\\n        return dp[index][k]=ans;\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        vector<vector<int>> dp(events.size(),vector<int>(k+1,-1));\\n        return helper(0,events,k,dp);\\n    }\\n};\\n```\n```\\n\\n  int   int   if if if  set       set   OOO    for for for EEEEE  \\n  int   int   if    if   set     set  O     O      for     E      \\n  int   int   if if if    set   set   O     O      for     EEE    \\n  int   int   if           set set    O     O      for     E      \\n   int int    if             set        OOO        for     EEEEE  \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767699,
                "title": "easy-python-solution-using-dp-greedy-sorting",
                "content": "# Intuition\\nThe question is similar to what we do in meeting problems in greedy but the catch here is that now it has some reward attached to it which makes it a dp problem. Now we have to look for time a meeting ends as well as the value it brings on attending it. \\n\\n# Approach\\nSorting and DP\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n\\n- Space complexity: O(n^3)\\n\\n# Code\\n```\\nclass Solution:\\n    def dp(self,i,events,k,timeBooked,dct):\\n        if i<0 or k==0:\\n            return 0\\n        x=0\\n        if (i,k,timeBooked) in dct:\\n            return dct[(i,k,timeBooked)]\\n        if events[i][1]<timeBooked:\\n            x=self.dp(i-1,events,k-1,events[i][0],dct)+events[i][2]\\n        y=self.dp(i-1,events,k,timeBooked,dct)\\n        dct[(i,k,timeBooked)]=max(x,y)\\n        return max(x,y)\\n        \\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        n=len(events)\\n        dct={}\\n        events.sort(key=lambda x:x[1])\\n        return self.dp(n-1,events,k,float(\"infinity\"),dct)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def dp(self,i,events,k,timeBooked,dct):\\n        if i<0 or k==0:\\n            return 0\\n        x=0\\n        if (i,k,timeBooked) in dct:\\n            return dct[(i,k,timeBooked)]\\n        if events[i][1]<timeBooked:\\n            x=self.dp(i-1,events,k-1,events[i][0],dct)+events[i][2]\\n        y=self.dp(i-1,events,k,timeBooked,dct)\\n        dct[(i,k,timeBooked)]=max(x,y)\\n        return max(x,y)\\n        \\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        n=len(events)\\n        dct={}\\n        events.sort(key=lambda x:x[1])\\n        return self.dp(n-1,events,k,float(\"infinity\"),dct)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767371,
                "title": "very-simple-approach-using-lower-bound",
                "content": "# Intuition\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn*k)\\n\\n- Space complexity:\\nO(n*k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> dp;\\nint f(int idx,int k,vector<vector<int>>& arr){\\n    if(idx==arr.size()||k==0)\\n    return 0;\\n\\n    if(dp[idx][k]!=-1)\\n    return dp[idx][k];\\n\\n    vector<int> temp={arr[idx][1]+1,0,0};\\n    int j=lower_bound(arr.begin(),arr.end(),temp)-arr.begin();\\n\\n    return dp[idx][k]=max(f(idx+1,k,arr),arr[idx][2]+f(j,k-1,arr));\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        dp=vector<vector<int>>(events.size(),vector<int>(k+1,-1));\\n\\n        return f(0,k,events);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>> dp;\\nint f(int idx,int k,vector<vector<int>>& arr){\\n    if(idx==arr.size()||k==0)\\n    return 0;\\n\\n    if(dp[idx][k]!=-1)\\n    return dp[idx][k];\\n\\n    vector<int> temp={arr[idx][1]+1,0,0};\\n    int j=lower_bound(arr.begin(),arr.end(),temp)-arr.begin();\\n\\n    return dp[idx][k]=max(f(idx+1,k,arr),arr[idx][2]+f(j,k-1,arr));\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        dp=vector<vector<int>>(events.size(),vector<int>(k+1,-1));\\n\\n        return f(0,k,events);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767267,
                "title": "c-dp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        vector<int> s;\\n        for(auto i : e) s.push_back(i[0]);\\n        sort(s.begin(), s.end()); // Sort the start times\\n\\n        sort(e.begin(), e.end(), [](const vector<int>& a, const vector<int>& b){\\n           return a[0] < b[0]; \\n        }); // Sort the events based on start times\\n\\n        vector<vector<int>> dp(e.size()+1, vector<int>(k+1, 0)); // Create a 2D vector for dynamic programming\\n\\n        int n = e.size();\\n        for(int idx = n-1; idx >= 0; idx--){\\n            for(int j = 1; j <= k; j++){\\n                int ntake = dp[idx+1][j]; // Don\\'t take the current event\\n                int nxt = upper_bound(s.begin(), s.end(), e[idx][1]) - s.begin(); // Find the next event whose start time is after the current event\\'s end time\\n                int take = e[idx][2] + dp[nxt][j-1]; // Take the current event and add its value to the maximum value obtained from the next event\\n                dp[idx][j] = max(take, ntake); // Choose the maximum value between taking and not taking the current event\\n            }\\n        }\\n        return dp[0][k]; // Return the maximum value for k events starting from the first event\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        vector<int> s;\\n        for(auto i : e) s.push_back(i[0]);\\n        sort(s.begin(), s.end()); // Sort the start times\\n\\n        sort(e.begin(), e.end(), [](const vector<int>& a, const vector<int>& b){\\n           return a[0] < b[0]; \\n        }); // Sort the events based on start times\\n\\n        vector<vector<int>> dp(e.size()+1, vector<int>(k+1, 0)); // Create a 2D vector for dynamic programming\\n\\n        int n = e.size();\\n        for(int idx = n-1; idx >= 0; idx--){\\n            for(int j = 1; j <= k; j++){\\n                int ntake = dp[idx+1][j]; // Don\\'t take the current event\\n                int nxt = upper_bound(s.begin(), s.end(), e[idx][1]) - s.begin(); // Find the next event whose start time is after the current event\\'s end time\\n                int take = e[idx][2] + dp[nxt][j-1]; // Take the current event and add its value to the maximum value obtained from the next event\\n                dp[idx][j] = max(take, ntake); // Choose the maximum value between taking and not taking the current event\\n            }\\n        }\\n        return dp[0][k]; // Return the maximum value for k events starting from the first event\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767237,
                "title": "c-beginner-friendly-faster-than-90-of-sol-n-binary-search-dp-clean-and-concise",
                "content": "# **PLEASE DO UPVOTE !**\\n\\n**CONNECT WITH ME ON LINKEDIN : https://www.linkedin.com/in/kunal-shaw-/**\\n\\n# Hint : Knapsack variation with little use of binary search \\n\\n# Code\\n```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int BS(int i,vector<vector<int>>&events,int val){\\n        int l=i;\\n        int h=events.size()-1;\\n        int ind=-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(events[mid][0]>val){\\n                ind=mid;\\n                h=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ind;\\n    }\\n    ll f(vector<vector<int>>& events,int k,int i,vector<vector<ll>>& dp){\\n        if(i>=events.size() or i==-1) return 0;\\n        if(k<=0) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        //int ind=upper_bound(events[0].begin()+i,events[0].end(),events[i][1])-events[0].begin()+i;\\n        int ind=BS(i+1,events,events[i][1]);\\n        int pick=events[i][2]+f(events,k-1,ind,dp);\\n        int nonpick=f(events,k,i+1,dp);\\n        return dp[i][k]=max(pick,nonpick);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n=events.size();\\n        sort(events.begin(),events.end());\\n        vector<vector<ll>> dp(n+1,vector<ll> (k+1,-1));\\n        int ans=f(events,k,0,dp);\\n        return ans;\\n    }\\n};\\n```\\n![memer-cat.jpg](https://assets.leetcode.com/users/images/dfc2018d-01d8-43da-9889-af2896179f15_1675779280.3429081.jpeg)",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    int BS(int i,vector<vector<int>>&events,int val){\\n        int l=i;\\n        int h=events.size()-1;\\n        int ind=-1;\\n        while(l<=h){\\n            int mid=l+(h-l)/2;\\n            if(events[mid][0]>val){\\n                ind=mid;\\n                h=mid-1;\\n            }\\n            else l=mid+1;\\n        }\\n        return ind;\\n    }\\n    ll f(vector<vector<int>>& events,int k,int i,vector<vector<ll>>& dp){\\n        if(i>=events.size() or i==-1) return 0;\\n        if(k<=0) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        //int ind=upper_bound(events[0].begin()+i,events[0].end(),events[i][1])-events[0].begin()+i;\\n        int ind=BS(i+1,events,events[i][1]);\\n        int pick=events[i][2]+f(events,k-1,ind,dp);\\n        int nonpick=f(events,k,i+1,dp);\\n        return dp[i][k]=max(pick,nonpick);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n=events.size();\\n        sort(events.begin(),events.end());\\n        vector<vector<ll>> dp(n+1,vector<ll> (k+1,-1));\\n        int ans=f(events,k,0,dp);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767045,
                "title": "simple-solution-java-dp",
                "content": "\\n# Approach\\nMemoization\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        Arrays.sort(events,(ar1,ar2) -> ar1[0]-ar2[0]);\\n        int dp[][]=new int[k+1][events.length];\\n        return solve(events,dp,k,0);\\n    }\\n    public int solve(int events[][],int dp[][],int k,int idx){\\n        if(k==1){\\n            int ans=0;\\n            for(int i=idx;i<events.length;i++){\\n                ans=Math.max(ans,events[i][2]);\\n            }\\n            return ans;\\n        }\\n        if(dp[k][idx]!=0){\\n            return dp[k][idx];\\n        }\\n        int ans=0;\\n        for(int i=idx;i<events.length;i++){\\n            int val=events[i][2];\\n            for(int j=i+1;j<events.length;j++){\\n                if(events[j][0]>events[i][1]){\\n                    ans = Math.max(ans,val+solve(events,dp,k-1,j));\\n                }\\n            }\\n            ans=Math.max(ans,val);\\n        }\\n        return dp[k][idx]=ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        Arrays.sort(events,(ar1,ar2) -> ar1[0]-ar2[0]);\\n        int dp[][]=new int[k+1][events.length];\\n        return solve(events,dp,k,0);\\n    }\\n    public int solve(int events[][],int dp[][],int k,int idx){\\n        if(k==1){\\n            int ans=0;\\n            for(int i=idx;i<events.length;i++){\\n                ans=Math.max(ans,events[i][2]);\\n            }\\n            return ans;\\n        }\\n        if(dp[k][idx]!=0){\\n            return dp[k][idx];\\n        }\\n        int ans=0;\\n        for(int i=idx;i<events.length;i++){\\n            int val=events[i][2];\\n            for(int j=i+1;j<events.length;j++){\\n                if(events[j][0]>events[i][1]){\\n                    ans = Math.max(ans,val+solve(events,dp,k-1,j));\\n                }\\n            }\\n            ans=Math.max(ans,val);\\n        }\\n        return dp[k][idx]=ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1357936,
                "title": "simple-c-solution-knapsack-recursion-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int solve(vector<vector<int>>& events,int k,int i,int j)\\n    {\\n        if(i==events.size()||k==0) return 0;\\n        if(events[i][0]<=j) return solve(events,k,i+1,j);\\n\\t\\t//if current start time is less than equal to previous end time then we will move forward.\\n        if(dp[i][k]!=-1) return dp[i][k];\\n\\t\\t//knapsack equation\\n        return dp[i][k]=max(events[i][2]+solve(events,k-1,i+1,events[i][1]),solve(events,k,i+1,j));\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        dp.resize(events.size(),vector<int>(k+1,-1));\\n        return solve(events,k,0,0);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int solve(vector<vector<int>>& events,int k,int i,int j)\\n    {\\n        if(i==events.size()||k==0) return 0;\\n        if(events[i][0]<=j) return solve(events,k,i+1,j);\\n\\t\\t//if current start time is less than equal to previous end time then we will move forward.\\n        if(dp[i][k]!=-1) return dp[i][k];\\n\\t\\t//knapsack equation\\n        return dp[i][k]=max(events[i][2]+solve(events,k-1,i+1,events[i][1]),solve(events,k,i+1,j));\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        dp.resize(events.size(),vector<int>(k+1,-1));\\n        return solve(events,k,0,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1296572,
                "title": "python3-dp-memorization",
                "content": "\\nStatus: Accepted\\n66 / 66 test cases passed.\\nRuntime: 916 ms\\nMemory Usage: 177.9 MB\\nbeats 75.22 % of python3 submissions\\n\\nTop-down approach\\nfor each event **you can skip it** OR **add value of that event** + **value of next event which starts after this event**\\n\\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        \\n        dp = [ [-1]*(k+1) for _ in range(len(events)) ]\\n        events = sorted(events, key = lambda x: (x[0], x[1]))\\n        \\n        def sol(cur, k):\\n            if cur >= len(events) or k == 0:\\n                return 0\\n            \\n            if dp[cur][k] != -1:\\n                return dp[cur][k]\\n            \\n            i = cur + 1\\n            \\n            while (i < len(events)):\\n                if (events[i][0] > events[cur][1]):\\n                    break\\n                i+= 1\\n            \\n            dp[cur][k] =  max(sol(cur+1, k), events[cur][2] + sol(i, k-1) )\\n            return dp[cur][k]\\n        \\n        return sol(0, k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        \\n        dp = [ [-1]*(k+1) for _ in range(len(events)) ]\\n        events = sorted(events, key = lambda x: (x[0], x[1]))\\n        \\n        def sol(cur, k):\\n            if cur >= len(events) or k == 0:\\n                return 0\\n            \\n            if dp[cur][k] != -1:\\n                return dp[cur][k]\\n            \\n            i = cur + 1\\n            \\n            while (i < len(events)):\\n                if (events[i][0] > events[cur][1]):\\n                    break\\n                i+= 1\\n            \\n            dp[cur][k] =  max(sol(cur+1, k), events[cur][2] + sol(i, k-1) )\\n            return dp[cur][k]\\n        \\n        return sol(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057386,
                "title": "c-dp-recursion-memoization",
                "content": "This is similar to Knapscak problem but with some constraints.\\nHint , do standard knapsack problem , then get back to this one.\\n\\nKey points :\\n1. here , n,k and endtime is changing, so 3D table we need.\\n2. we need to sort the events vector according to the start time, Think abt it ....\\n\\n```\\nclass Solution {\\npublic:\\n     \\n    int ans;    \\n    unordered_map<int,unordered_map<int,unordered_map<int,int>>> dp;\\n    \\n    int Solve(vector<vector<int>>& events, int start, int n, int k, int endtime){\\n        if(k == 0 || start == n){\\n            return 0;\\n        }\\n        \\n        if(dp.find(start) != dp.end() && dp[start].find(k) != dp[start].end() && dp[start][k].find(endtime) != dp[start][k].end()){\\n        \\n            return dp[start][k][endtime];\\n        }\\n        int t1 = 0;\\n        if(events[start][0] > endtime){\\n            t1 = events[start][2] + Solve(events, start+1, n, k-1, events[start][1]);\\n        }\\n        \\n        int t2 = Solve(events,start+1,n,k,endtime);\\n        \\n        dp[start][k][endtime] = max(t1,t2);\\n       // cout<< dp[start][k][endtime]<<endl;\\n     \\n        return dp[start][k][endtime];\\n        \\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        \\n        dp.clear();\\n     \\n        // sort according to start time\\n        sort(events.begin(), events.end(),[](vector<int> &a,vector<int> &b){\\n            return a[0] < b[0];\\n        });\\n        \\n    return Solve(events,0,events.size(),k,0);\\n    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     \\n    int ans;    \\n    unordered_map<int,unordered_map<int,unordered_map<int,int>>> dp;\\n    \\n    int Solve(vector<vector<int>>& events, int start, int n, int k, int endtime){\\n        if(k == 0 || start == n){\\n            return 0;\\n        }\\n        \\n        if(dp.find(start) != dp.end() && dp[start].find(k) != dp[start].end() && dp[start][k].find(endtime) != dp[start][k].end()){\\n        \\n            return dp[start][k][endtime];\\n        }\\n        int t1 = 0;\\n        if(events[start][0] > endtime){\\n            t1 = events[start][2] + Solve(events, start+1, n, k-1, events[start][1]);\\n        }\\n        \\n        int t2 = Solve(events,start+1,n,k,endtime);\\n        \\n        dp[start][k][endtime] = max(t1,t2);\\n       // cout<< dp[start][k][endtime]<<endl;\\n     \\n        return dp[start][k][endtime];\\n        \\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        \\n        dp.clear();\\n     \\n        // sort according to start time\\n        sort(events.begin(), events.end(),[](vector<int> &a,vector<int> &b){\\n            return a[0] < b[0];\\n        });\\n        \\n    return Solve(events,0,events.size(),k,0);\\n    \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3769871,
                "title": "c-solution-beats-100-time-and-space-most-optimized-space-o-n-reduced-from-o-nk",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        std::vector<int> dp(events.size(), 0);\\n        sort(events.begin(), events.end(), [](const std::vector<int>& v1, const std::vector<int>& v2) {\\n            return v1[1] < v2[1];\\n        });\\n\\n        for (int i = 0; i < events.size(); ++i) {\\n            dp[i] = events[i][2];\\n        }\\n\\n        for (int i = 1; i < k; ++i) {\\n            for (int j = events.size() - 1; j >= 0; --j) {\\n                for (int l = 0; l < j; ++l) {\\n                    // events overlap\\n                    if (events[l][1] >= events[j][0]) break;\\n                    dp[j] = std::max(dp[j], dp[l] + events[j][2]);\\n                }\\n            }\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < events.size(); ++i) {\\n            res = std::max(res, dp[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        std::vector<int> dp(events.size(), 0);\\n        sort(events.begin(), events.end(), [](const std::vector<int>& v1, const std::vector<int>& v2) {\\n            return v1[1] < v2[1];\\n        });\\n\\n        for (int i = 0; i < events.size(); ++i) {\\n            dp[i] = events[i][2];\\n        }\\n\\n        for (int i = 1; i < k; ++i) {\\n            for (int j = events.size() - 1; j >= 0; --j) {\\n                for (int l = 0; l < j; ++l) {\\n                    // events overlap\\n                    if (events[l][1] >= events[j][0]) break;\\n                    dp[j] = std::max(dp[j], dp[l] + events[j][2]);\\n                }\\n            }\\n        }\\n\\n        int res = 0;\\n        for (int i = 0; i < events.size(); ++i) {\\n            res = std::max(res, dp[i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769152,
                "title": "c-solution-for-maximum-number-of-events-that-can-be-attended-ii-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe goal is to maximize the sum of values obtained by attending events within the given constraints. To achieve this, we need to consider different combinations of events while respecting the constraints.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the events based on their start days in ascending order.\\n- Use a top-down dynamic programming approach with memoization.\\n- Define a 2D memoization array, dp[count][curIndex], where count represents the remaining number of events that can be attended and curIndex represents the current event index.\\n- Implement a recursive function, DFS, that considers two options for each event: attending or skipping it.\\n- In the DFS function, if the base cases are reached (no more events or count is 0), return 0.\\n- Check if the result for the current combination of count and curIndex is already calculated and stored in the memoization array. If so, return the stored result.\\n- Find the next available event index, nextIndex, using the BisectRight function, which performs a binary search on the sorted events array based on the current event\\'s end day.\\n- Calculate the maximum value between attending the current event (events[curIndex][2] + DFS(nextIndex, count - 1)) and skipping the current event (DFS(curIndex + 1, count)).\\n- Store the calculated result in the memoization array for future reference and return the result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of the solution depends on the number of events, n, and the maximum number of events that can be attended, k. Sorting the events takes O(n log n) time. The recursive function DFS is called for each event and each possible value of count from k to 0. Therefore, the time complexity is O(n * k). Additionally, the BisectRight function performs a binary search, which takes O(log n) time. Overall, the time complexity of the solution is O(n log n + n * k * log n).\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity is determined by the memoization array dp. It has dimensions of (k + 1) x n, requiring O(k * n) space. Additionally, the sorting operation takes O(n) space. Therefore, the overall space complexity is O(k * n).\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxValue(int[][] events, int k) {\\n        Array.Sort(events, (a, b) => a[0] - b[0]);\\n        int n = events.Length;\\n\\n        int[][] dp = new int[k + 1][];\\n        for (int i = 0; i <= k; i++)\\n        {\\n            dp[i] = new int[n];\\n            Array.Fill(dp[i], -1);\\n        }\\n\\n        return DFS(0, k, events, dp);\\n    }\\n    private int DFS(int curIndex, int count, int[][] events, int[][] dp)\\n    {\\n        if (count == 0 || curIndex == events.Length)\\n        {\\n            return 0;\\n        }\\n        if (dp[count][curIndex] != -1)\\n        {\\n            return dp[count][curIndex];\\n        }\\n        int nextIndex = BisectRight(events, events[curIndex][1]);\\n        dp[count][curIndex] = Math.Max(DFS(curIndex + 1, count, events, dp), events[curIndex][2] + DFS(nextIndex, count - 1, events, dp));\\n        return dp[count][curIndex];\\n    }\\n\\n    public static int BisectRight(int[][] events, int target)\\n    {\\n        int left = 0, right = events.Length;\\n        while (left < right)\\n        {\\n            int mid = (left + right) / 2;\\n            if (events[mid][0] <= target)\\n            {\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxValue(int[][] events, int k) {\\n        Array.Sort(events, (a, b) => a[0] - b[0]);\\n        int n = events.Length;\\n\\n        int[][] dp = new int[k + 1][];\\n        for (int i = 0; i <= k; i++)\\n        {\\n            dp[i] = new int[n];\\n            Array.Fill(dp[i], -1);\\n        }\\n\\n        return DFS(0, k, events, dp);\\n    }\\n    private int DFS(int curIndex, int count, int[][] events, int[][] dp)\\n    {\\n        if (count == 0 || curIndex == events.Length)\\n        {\\n            return 0;\\n        }\\n        if (dp[count][curIndex] != -1)\\n        {\\n            return dp[count][curIndex];\\n        }\\n        int nextIndex = BisectRight(events, events[curIndex][1]);\\n        dp[count][curIndex] = Math.Max(DFS(curIndex + 1, count, events, dp), events[curIndex][2] + DFS(nextIndex, count - 1, events, dp));\\n        return dp[count][curIndex];\\n    }\\n\\n    public static int BisectRight(int[][] events, int target)\\n    {\\n        int left = 0, right = events.Length;\\n        while (left < right)\\n        {\\n            int mid = (left + right) / 2;\\n            if (events[mid][0] <= target)\\n            {\\n                left = mid + 1;\\n            }\\n            else\\n            {\\n                right = mid;\\n            }\\n        }\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768743,
                "title": "c-solution-dynamic-programming-supereasy-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n                        `Sorting + Dynamic Programming`\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. The $$solveDp$$ function is used to solve the problem using dynamic programming with memoization. It computes and returns the maximum value of events that can be attended based on the given constraints.\\n\\n2. The function starts with two base cases:\\nIf the `index` goes beyond the size of the `events` vector or if `k` becomes zero or negative, the function returns 0 (indicating no more events can be attended).\\nIf the result for the current index and k is already computed and stored in the dp table, it returns the precomputed value to avoid redundant computation.\\n\\n3. Next, the function iterates from `index+1` to the end of the events vector `e.size()`. It checks if the start time of the event at the current index i is greater than the end time of the current event `e[index][1]`. This loop is used to find the next event that starts after the current event ends.\\n\\n4. After finding the appropriate i value, it calculates two possibilities:\\ninclude: The maximum value that can be achieved by attending the current event `e[index][2]` and recursively calling the $$solveDp$$ function with `k-1` (as one event is attended) and the next event index `i`.\\nexclude: The maximum value that can be achieved by not attending the current event and recursively calling the $$solveDp$$ function with `k` and the next event index `index+1`.\\nFinally, it returns the maximum value between `include` and `exclude` and stores it in the dp table for future reference.\\n\\n5. The maxValue function takes two parameters:\\nevents: A reference to a 2D vector of integers representing the events.\\nk: An integer representing the maximum number of events that can be attended.\\nInside the $$maxValue$$ function, the events vector is sorted in ascending order based on the start time of the events using `sort()` function.\\n\\n6. It initializes a 2D vector `dp` with dimensions `n+1` (number of events) and `k+1` (maximum number of events that can be attended). All values in the dp table are initialized to -1, indicating that they are not computed yet.\\n\\n7. It calls the $$solveDp$$ function with the initial parameters (events, k, 0, dp) to compute and return the maximum value of events that can be attended.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n# Complexity\\n- Time complexity:$$O(n\\u2217k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n\\u2217k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solveDp(vector<vector<int>>& e,int k,int index,vector<vector<int>>&dp){\\n\\n        //base case\\n        if(index>=e.size()|| k<=0){\\n            return 0;\\n        }\\n        if(dp[index][k]!=-1){\\n            return dp[index][k];\\n        }\\n        int i;\\n        for( i=index+1;i<e.size();i++){\\n            if(e[i][0]>e[index][1])\\n             break;\\n        }\\n        int include=e[index][2]+solveDp(e,k-1,i,dp);\\n        int exclude= solveDp(e,k,index+1,dp);\\n        return dp[index][k]=max(include,exclude);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        //sort events by startTime\\n        sort(events.begin(),events.end());\\n\\n        int n=events.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n\\n        return solveDp(events,k,0,dp);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solveDp(vector<vector<int>>& e,int k,int index,vector<vector<int>>&dp){\\n\\n        //base case\\n        if(index>=e.size()|| k<=0){\\n            return 0;\\n        }\\n        if(dp[index][k]!=-1){\\n            return dp[index][k];\\n        }\\n        int i;\\n        for( i=index+1;i<e.size();i++){\\n            if(e[i][0]>e[index][1])\\n             break;\\n        }\\n        int include=e[index][2]+solveDp(e,k-1,i,dp);\\n        int exclude= solveDp(e,k,index+1,dp);\\n        return dp[index][k]=max(include,exclude);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        //sort events by startTime\\n        sort(events.begin(),events.end());\\n\\n        int n=events.size();\\n\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n\\n        return solveDp(events,k,0,dp);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768637,
                "title": "easy-java-solution-using-dp-and-sorting",
                "content": "# Complexity\\n- Time complexity:O(n^2*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```Please Upvote if it helped !! ```\\n# Code\\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        Arrays.sort(events,Comparator.comparingDouble(o->o[0]));\\n        int dp[][]= new int[k+1][events.length+1];\\n        return helper(events,k,0,dp);\\n    }\\n    int helper(int [][]eve,int k,int i,int dp[][]){\\n        if(i>=eve.length ||k<=0) return 0;\\n        if(dp[k][i]!=0) return dp[k][i];\\n        int skip=helper(eve,k,i+1,dp);\\n        int val=eve[i][2];\\n        int j=i+1;\\n        for(;j<eve.length;j++){\\n            if(eve[j][0]>eve[i][1]) break;\\n        }\\n        int take=val+helper(eve,k-1,j,dp);\\n        return dp[k][i]=Math.max(skip,take);\\n    }\\n}\\n// PLEASE UPVOTE <3 !!\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```Please Upvote if it helped !! ```\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        Arrays.sort(events,Comparator.comparingDouble(o->o[0]));\\n        int dp[][]= new int[k+1][events.length+1];\\n        return helper(events,k,0,dp);\\n    }\\n    int helper(int [][]eve,int k,int i,int dp[][]){\\n        if(i>=eve.length ||k<=0) return 0;\\n        if(dp[k][i]!=0) return dp[k][i];\\n        int skip=helper(eve,k,i+1,dp);\\n        int val=eve[i][2];\\n        int j=i+1;\\n        for(;j<eve.length;j++){\\n            if(eve[j][0]>eve[i][1]) break;\\n        }\\n        int take=val+helper(eve,k-1,j,dp);\\n        return dp[k][i]=Math.max(skip,take);\\n    }\\n}\\n// PLEASE UPVOTE <3 !!\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767742,
                "title": "top-down-dynamic-programming-solution-written-in-go",
                "content": "Sorry for my poor English skill at the very beginning.\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nFirst of all, to make this method can effectively sequentially check on every \"run\", I sort the `events` by the start time. I also think of we can sort by $\\\\frac{value}{end-start}$ at the same time, while I then think that it may not affect our performance.\\n\\nAfter sorting it, looking at this problem, I firstly come up with **Backtracking**. It\\'s not really wrong, but **too slow**. In my experience, to speed up backtracking, **Dynamic Programming** is a very useful method.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nDecided to use DP, the following question is \"What to store\". In my consideration, storing `(index, current_time, quota)` is enough. They are \"the event we focus on\", \"the end time of the previous event\" and \"how many events we can participate\" respectively.\\n\\nWe than start from the first event, scan to the last one step by step. In each run, we do the following actions:\\n\\n1. Check if we scan all of the event, or if we still able to participate any event(`quota >= 0`)\\n2. Store the outcome of \"If we ignore this event\"\\n3. Store the outcome of \"If we participate this event\", and we do also check if this event is able to participate (time constraint).\\n4. Store the maximum between `3.` and `4.`, then return\\n\\nJust before posting this solution, I\\'ve found out it looks same to the Approach 5 in Editorial. If you think a graph may help you understand the concept more easily, it may helps you.\\n\\n# Complexity\\n\\nI\\'m not very sure about this part, if I\\'m wrong, please leave your comment below and tell me.\\n\\n- Time complexity: $O(nk + n\\\\log{n})$ : sorting spends about $O(n\\\\log{n})$, and scanning them spend $O(nk)$. I think using a binary search on searching the next available event will make it faster.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(nk)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc dfs(events *[][]int, mem *map[[3]int]int, idx, time, quota int) int {\\n    key := [3]int{idx, time, quota}\\n    if idx == len(*events) || quota == 0 {\\n        return 0\\n    } else if v, ok := (*mem)[key]; ok {\\n        return v\\n    }\\n    \\n    left := dfs(events, mem, idx+1, time, quota)\\n\\n    right := 0\\n    if time < (*events)[idx][0]{\\n        right = dfs(events, mem, idx+1, (*events)[idx][1], quota-1) + (*events)[idx][2]\\n    }\\n    if left > right {\\n        (*mem)[key] = left\\n    } else {\\n        (*mem)[key] = right\\n    }\\n\\n    return (*mem)[key]\\n}\\nfunc maxValue(events [][]int, k int) int {\\n    sort.SliceStable(events, func(i, j int) bool {\\n            return events[i][0] < events[j][0]\\n    })\\n    mem := make(map[[3]int]int, 0)\\n    return dfs(&events, &mem, 0, -1, k)\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Hash Table",
                    "Sort",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nfunc dfs(events *[][]int, mem *map[[3]int]int, idx, time, quota int) int {\\n    key := [3]int{idx, time, quota}\\n    if idx == len(*events) || quota == 0 {\\n        return 0\\n    } else if v, ok := (*mem)[key]; ok {\\n        return v\\n    }\\n    \\n    left := dfs(events, mem, idx+1, time, quota)\\n\\n    right := 0\\n    if time < (*events)[idx][0]{\\n        right = dfs(events, mem, idx+1, (*events)[idx][1], quota-1) + (*events)[idx][2]\\n    }\\n    if left > right {\\n        (*mem)[key] = left\\n    } else {\\n        (*mem)[key] = right\\n    }\\n\\n    return (*mem)[key]\\n}\\nfunc maxValue(events [][]int, k int) int {\\n    sort.SliceStable(events, func(i, j int) bool {\\n            return events[i][0] < events[j][0]\\n    })\\n    mem := make(map[[3]int]int, 0)\\n    return dfs(&events, &mem, 0, -1, k)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3766945,
                "title": "c-dp-memoization-sorting",
                "content": "# Code\\n```\\nstruct mycmp{\\n    bool operator()(vector<int> &a , vector<int>&b){\\n        if(a[0]==b[0]){\\n            return a[1]<b[1];\\n        }\\n        else \\n           return a[0]<b[0];\\n    }\\n};\\nclass Solution {\\npublic:\\n    int searchIn(vector<vector<int>>&arr , int low , int high , int target){\\n        int index = arr.size();\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n            if(arr[mid][0] > target){\\n                 index = mid;\\n                 high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return index;\\n    }\\n    int solve(int index , vector<vector<int>>&arr , int k  , vector<vector<int>>&memo){\\n        int n = arr.size();\\n        if(index == n || k == 0)return 0;\\n        if(memo[index][k]!=-1)return memo[index][k];\\n        int result = arr[index][2];\\n        int newIndex = searchIn(arr , index+1 , n - 1 , arr[index][1]);\\n        return memo[index][k] = max(result + solve(newIndex , arr , k-1 , memo) , solve(index+1 , arr , k , memo));\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n         sort(events.begin() , events.end() , mycmp());\\n         int n = events.size();\\n         vector<vector<int>>memo(n , vector<int>(k+1 , -1));\\n         int result = solve(0 , events , k , memo);\\n         return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nstruct mycmp{\\n    bool operator()(vector<int> &a , vector<int>&b){\\n        if(a[0]==b[0]){\\n            return a[1]<b[1];\\n        }\\n        else \\n           return a[0]<b[0];\\n    }\\n};\\nclass Solution {\\npublic:\\n    int searchIn(vector<vector<int>>&arr , int low , int high , int target){\\n        int index = arr.size();\\n        while(low <= high){\\n            int mid = (low + high)/2;\\n            if(arr[mid][0] > target){\\n                 index = mid;\\n                 high = mid - 1;\\n            }\\n            else{\\n                low = mid + 1;\\n            }\\n        }\\n        return index;\\n    }\\n    int solve(int index , vector<vector<int>>&arr , int k  , vector<vector<int>>&memo){\\n        int n = arr.size();\\n        if(index == n || k == 0)return 0;\\n        if(memo[index][k]!=-1)return memo[index][k];\\n        int result = arr[index][2];\\n        int newIndex = searchIn(arr , index+1 , n - 1 , arr[index][1]);\\n        return memo[index][k] = max(result + solve(newIndex , arr , k-1 , memo) , solve(index+1 , arr , k , memo));\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n         sort(events.begin() , events.end() , mycmp());\\n         int n = events.size();\\n         vector<vector<int>>memo(n , vector<int>(k+1 , -1));\\n         int result = solve(0 , events , k , memo);\\n         return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766776,
                "title": "python-sorting-dp",
                "content": "```\\nclass Solution:\\n    \\n    def f(self, i, end, k, events):\\n        # print(i, end, k)\\n        if k==0 or i>=self.n:\\n            return 0\\n        if self.dp[(i,end,k)] != -1:\\n            return self.dp[(i,end,k)]\\n        \\n        not_pick = self.f(i+1, end, k, events)\\n        pick = 0\\n        if events[i][0]>end:\\n            pick = events[i][2] + self.f(i+1, events[i][1], k-1, events)\\n        self.dp[(i,end,k)] = max(pick, not_pick)\\n        return self.dp[(i,end,k)]\\n    \\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events = sorted(events, key=lambda event: event[0])\\n        self.n = len(events)\\n        self.dp = defaultdict(lambda:-1) \\n        return self.f(0, 0, k, events)\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def f(self, i, end, k, events):\\n        # print(i, end, k)\\n        if k==0 or i>=self.n:\\n            return 0\\n        if self.dp[(i,end,k)] != -1:\\n            return self.dp[(i,end,k)]\\n        \\n        not_pick = self.f(i+1, end, k, events)\\n        pick = 0\\n        if events[i][0]>end:\\n            pick = events[i][2] + self.f(i+1, events[i][1], k-1, events)\\n        self.dp[(i,end,k)] = max(pick, not_pick)\\n        return self.dp[(i,end,k)]\\n    \\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events = sorted(events, key=lambda event: event[0])\\n        self.n = len(events)\\n        self.dp = defaultdict(lambda:-1) \\n        return self.f(0, 0, k, events)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766741,
                "title": "c-dp",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&dp, vector<vector<int>>& events, int n, int pos, int k) {\\n        int i;\\n        \\n        if(pos >= n || k == 0)\\n            return 0;\\n        \\n        if(dp[pos][k] != -1)\\n            return dp[pos][k];\\n        \\n        for(i = pos + 1; i < n; i++)\\n            if(events[i][0] > events[pos][1])\\n                break;\\n        \\n       return dp[pos][k] = max(solve(dp, events, n, pos + 1, k), events[pos][2] + solve(dp, events, n, i, k - 1));\\n\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        \\n        vector<vector<int>>dp(n + 1, vector<int>(k + 1, -1));\\n        \\n        return solve(dp, events, n, 0, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(vector<vector<int>>&dp, vector<vector<int>>& events, int n, int pos, int k) {\\n        int i;\\n        \\n        if(pos >= n || k == 0)\\n            return 0;\\n        \\n        if(dp[pos][k] != -1)\\n            return dp[pos][k];\\n        \\n        for(i = pos + 1; i < n; i++)\\n            if(events[i][0] > events[pos][1])\\n                break;\\n        \\n       return dp[pos][k] = max(solve(dp, events, n, pos + 1, k), events[pos][2] + solve(dp, events, n, i, k - 1));\\n\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        \\n        vector<vector<int>>dp(n + 1, vector<int>(k + 1, -1));\\n        \\n        return solve(dp, events, n, 0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766679,
                "title": "easy-c-solution-dp-memoization-approach-explained",
                "content": "# Intuition\\nGreedy approach will fail here beause when we see example 1 then greedy works finne there but a slight change in example 1 becomes example 2 and there greedy work will not work. So we have to iuse DP.\\n\\nThere are 2 choices for each event, whether to take it or not. SO we will try all possible ways to check our maximum answer.\\n\\n# Approach\\nThere are 2 choices for each event whether to take it or not. If we take it then we will add the value to our answer and go ahead.\\nBut here we need to store previous state as well.\\n\\nPrevious state will be the end time of the previous meeting that we took in our answer.\\n\\nThis will be counted in base case as if start index of next state is less than previous state then we will not take it.\\n\\nOther base cases are when k==0 or ind==n then we return 0.\\n\\nThen in recursion we will take 2 choices and take the max out of it.\\n\\n# Complexity\\n- Time complexity:\\nO(NlogN) + O(N*K) == O(N*K)\\n\\n- Space complexity:\\nO(N*K)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int f(int ind, int k, int n, vector<vector<int>>& events, int prevstate, vector<vector<int>> &dp){\\n        if(ind==n) return 0;\\n        if(k==0) return 0;\\n        if(events[ind][0]<=prevstate) return f(ind+1, k, n, events, prevstate, dp);\\n\\n        if(dp[ind][k]!=-1) return dp[ind][k];\\n\\n        int take = events[ind][2] + f(ind+1, k-1, n, events, events[ind][1], dp);\\n        int nottake = f(ind+1, k, n, events, prevstate, dp);\\n        return dp[ind][k]=max(take, nottake);\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n=events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        int ans = f(0, k, n, events, 0, dp);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int f(int ind, int k, int n, vector<vector<int>>& events, int prevstate, vector<vector<int>> &dp){\\n        if(ind==n) return 0;\\n        if(k==0) return 0;\\n        if(events[ind][0]<=prevstate) return f(ind+1, k, n, events, prevstate, dp);\\n\\n        if(dp[ind][k]!=-1) return dp[ind][k];\\n\\n        int take = events[ind][2] + f(ind+1, k-1, n, events, events[ind][1], dp);\\n        int nottake = f(ind+1, k, n, events, prevstate, dp);\\n        return dp[ind][k]=max(take, nottake);\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n=events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        int ans = f(0, k, n, events, 0, dp);\\n        return ans;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766503,
                "title": "python3-solution",
                "content": "\\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort(key=lambda ans:ans[1])\\n        dp=[[0,0]]\\n        dp2=[[0,0]]\\n        for x in range(k):\\n            for s,e,v in events:\\n                i=bisect.bisect(dp,[s])-1\\n                if dp[i][1]+v>dp2[-1][1]:\\n                    dp2.append([e,dp[i][1]+v])\\n\\n            dp=dp2\\n            dp2=[[0,0]]\\n\\n        return dp[-1][-1]            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort(key=lambda ans:ans[1])\\n        dp=[[0,0]]\\n        dp2=[[0,0]]\\n        for x in range(k):\\n            for s,e,v in events:\\n                i=bisect.bisect(dp,[s])-1\\n                if dp[i][1]+v>dp2[-1][1]:\\n                    dp2.append([e,dp[i][1]+v])\\n\\n            dp=dp2\\n            dp2=[[0,0]]\\n\\n        return dp[-1][-1]            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701963,
                "title": "c-cleanest-code-dp-binary-search",
                "content": "This question is very very similar to 2008. Maximum Earnings From Taxi.\\nSo,do try out the other similar question as well.\\n```\\nusing ll=long long;\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int bsearch(vector<vector<int>> &events,int k){\\n        int low=0,high=events.size()-1;\\n        int oo=events.size();\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(events[mid][0]>events[k][1]){\\n                oo=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return oo;\\n    }\\n    ll helper(vector<vector<int>>& events,int idx,int k){\\n        if(idx>=events.size() or k<=0){\\n            return 0;\\n        }\\n        if(dp[idx][k]!=-1){\\n            return dp[idx][k];\\n        }\\n        ll op1=helper(events,idx+1,k);//if we dont pick this event\\n        //if we pick this event\\n        int nextidx=bsearch(events,idx);\\n        ll op2=events[idx][2]+helper(events,nextidx,k-1);\\n        return dp[idx][k]=max(op1,op2);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        dp=vector<vector<int>>(events.size()+1,vector<int>(k+1,-1));\\n        \\n        sort(events.begin(),events.end());\\n        //sorting by startdates\\n        return helper(events,0,k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nusing ll=long long;\\nclass Solution {\\npublic:\\n    vector<vector<int>> dp;\\n    int bsearch(vector<vector<int>> &events,int k){\\n        int low=0,high=events.size()-1;\\n        int oo=events.size();\\n        while(low<=high){\\n            int mid=(low+high)>>1;\\n            if(events[mid][0]>events[k][1]){\\n                oo=mid;\\n                high=mid-1;\\n            }\\n            else{\\n                low=mid+1;\\n            }\\n        }\\n        return oo;\\n    }\\n    ll helper(vector<vector<int>>& events,int idx,int k){\\n        if(idx>=events.size() or k<=0){\\n            return 0;\\n        }\\n        if(dp[idx][k]!=-1){\\n            return dp[idx][k];\\n        }\\n        ll op1=helper(events,idx+1,k);//if we dont pick this event\\n        //if we pick this event\\n        int nextidx=bsearch(events,idx);\\n        ll op2=events[idx][2]+helper(events,nextidx,k-1);\\n        return dp[idx][k]=max(op1,op2);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        dp=vector<vector<int>>(events.size()+1,vector<int>(k+1,-1));\\n        \\n        sort(events.begin(),events.end());\\n        //sorting by startdates\\n        return helper(events,0,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2315121,
                "title": "98-fast-c-knapsack-dp-binary-search",
                "content": "class Solution {\\npublic:\\n\\n    vector<vector<int>> dp;\\n\\t\\n    int fun(int i,vector<vector<int>>& arr,int k){\\n        if(i == arr.size() || k == 0)\\n            return 0;\\n        \\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        \\n        int s = arr[i][0] , e = arr[i][1] , val = arr[i][2];\\n        \\n        // binary search for next non overlapping event\\n        int  l = i+1, h = arr.size() - 1;\\n        while(l <= h){\\n            int m = l+(h-l)/2;\\n            \\n            if(arr[m][0] > arr[i][1])\\n                h = m-1;\\n            else \\n                l = m+1;\\n        }\\n        \\n        int take = val+fun(l,arr,k-1);     // attend event\\n        int leave = fun(i+1,arr,k)         // leave event\\n    \\n        return dp[i][k] = max(take,leave);\\n    }\\n    int maxValue(vector<vector<int>>& arr, int k) {\\n        sort(arr.begin(),arr.end());\\n        \\n        dp = vector<vector<int>>(arr.size(),vector<int>(k+1,-1));\\n        return fun(0,arr,k);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<vector<int>> dp;\\n\\t\\n    int fun(int i,vector<vector<int>>& arr,int k){\\n        if(i == arr.size() || k == 0)\\n            return 0;\\n        \\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        \\n        \\n        int s = arr[i][0] , e = arr[i][1] , val = arr[i][2];\\n        \\n        // binary search for next non overlapping event\\n        int  l = i+1, h = arr.size() - 1;\\n        while(l <= h){\\n            int m = l+(h-l)/2;\\n            \\n            if(arr[m][0] > arr[i][1])\\n                h = m-1;\\n            else \\n                l = m+1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2178106,
                "title": "python-2d-dp-bottom-up-o-n-k",
                "content": "``` \\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        n = len(events)\\n        events.sort() \\n        events.append([float(\"+inf\"), float(\"+inf\"), 0])\\n        \\n        dp = {n: {x: 0 for x in range(k+1)}}\\n        for i in range(n-1, -1, -1):  \\n            lo = i+1\\n            hi = n\\n            mid = (lo + hi)//2 \\n                \\n            while lo < hi: \\n                if events[mid][0] <= events[i][1]: \\n                    lo = mid + 1 \\n                else: \\n                    hi = mid  \\n                mid = (lo + hi)//2 \\n            \\n            dp[i] = {x: max(dp[i+1][x], events[i][2]+dp[lo][x-1]) for x in range(1, k+1)}  \\n            dp[i][0] = 0\\n        \\n        return dp[0][k] \\n``` \\n\\nTime Complexity: O(nk) \\nSpace Complexity: O(nk) \\n\\nPlease support me by upvoting this solution \\uD83D\\uDE0C",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "``` \\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        n = len(events)\\n        events.sort() \\n        events.append([float(\"+inf\"), float(\"+inf\"), 0])\\n        \\n        dp = {n: {x: 0 for x in range(k+1)}}\\n        for i in range(n-1, -1, -1):  \\n            lo = i+1\\n            hi = n\\n            mid = (lo + hi)//2 \\n                \\n            while lo < hi: \\n                if events[mid][0] <= events[i][1]: \\n                    lo = mid + 1 \\n                else: \\n                    hi = mid  \\n                mid = (lo + hi)//2 \\n            \\n            dp[i] = {x: max(dp[i+1][x], events[i][2]+dp[lo][x-1]) for x in range(1, k+1)}  \\n            dp[i][0] = 0\\n        \\n        return dp[0][k] \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2172767,
                "title": "c-o-n-k-dp-solution-using-binary-search",
                "content": "```\\nstatic bool comp(vector<int> &a,vector<int> &b){\\n        if(a[1]!=b[1]) return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n       int n=events.size();\\n       sort(events.begin(),events.end(),comp);\\n       vector<vector<int>> dp(k+1,vector<int> (n+1,0));\\n        for(int i=1;i<=k;i++){\\n           for(int j=1;j<=n;j++){\\n              int low=1,high=j-1;\\n              int ans=events[j-1][2],temp=0;\\n              while(low<=high){\\n                int mid=(high+low)/2;\\n                if(events[mid-1][1]<events[j-1][0]){\\n                  temp=max(temp,dp[i-1][mid]);\\n                  low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n              }\\n              dp[i][j]=max(dp[i][j-1],ans+temp);\\n           }\\n        }\\n        return dp[k][n];\\n    }",
                "solutionTags": [
                    "C",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nstatic bool comp(vector<int> &a,vector<int> &b){\\n        if(a[1]!=b[1]) return a[1]<b[1];\\n        return a[0]<b[0];\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n       int n=events.size();\\n       sort(events.begin(),events.end(),comp);\\n       vector<vector<int>> dp(k+1,vector<int> (n+1,0));\\n        for(int i=1;i<=k;i++){\\n           for(int j=1;j<=n;j++){\\n              int low=1,high=j-1;\\n              int ans=events[j-1][2],temp=0;\\n              while(low<=high){\\n                int mid=(high+low)/2;\\n                if(events[mid-1][1]<events[j-1][0]){\\n                  temp=max(temp,dp[i-1][mid]);\\n                  low=mid+1;\\n                }\\n                else{\\n                    high=mid-1;\\n                }\\n              }\\n              dp[i][j]=max(dp[i][j-1],ans+temp);\\n           }\\n        }\\n        return dp[k][n];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1213036,
                "title": "java-dp-binary-search-o-knlogn",
                "content": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        // dp + binary search\\n        Arrays.sort(events, new eventComparator());\\n        // dp[i][j]: max value obtained by attending no more than j events from prefix[0: i inclusive]\\n        // dp[i][j] = max(dp[p][j - 1], dp[i - 1][j]) where p is the first non overlapping events\\n        int n = events.length;\\n        int[][] dp = new int[n][k + 1];\\n        int res = events[0][2];\\n        for (int j = 1; j <= k; j++) {\\n            dp[0][j] = events[0][2];\\n        }\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                // case 1: job i is not used\\n                dp[i][j] = dp[i - 1][j];\\n                // case 2: job i is must be used\\n                int index = findIndex(events, i);\\n                if (index >= 0) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[index][j - 1] + events[i][2]);\\n                } else {\\n                    dp[i][j] = Math.max(dp[i][j], events[i][2]);\\n                }\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    // return the index of the first event whose end time does not overlap with start time of curr event i\\n    // if no such event, return -1;\\n    private int findIndex(int[][] events, int i) {\\n        int left = 0;\\n        int right = i - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (events[mid][1] < events[i][0]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left - 1;\\n    }\\n    \\n    class eventComparator implements Comparator<int[]> {\\n        public int compare(int[] a, int[] b) {\\n            return a[1] - b[1];\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        // dp + binary search\\n        Arrays.sort(events, new eventComparator());\\n        // dp[i][j]: max value obtained by attending no more than j events from prefix[0: i inclusive]\\n        // dp[i][j] = max(dp[p][j - 1], dp[i - 1][j]) where p is the first non overlapping events\\n        int n = events.length;\\n        int[][] dp = new int[n][k + 1];\\n        int res = events[0][2];\\n        for (int j = 1; j <= k; j++) {\\n            dp[0][j] = events[0][2];\\n        }\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j <= k; j++) {\\n                // case 1: job i is not used\\n                dp[i][j] = dp[i - 1][j];\\n                // case 2: job i is must be used\\n                int index = findIndex(events, i);\\n                if (index >= 0) {\\n                    dp[i][j] = Math.max(dp[i][j], dp[index][j - 1] + events[i][2]);\\n                } else {\\n                    dp[i][j] = Math.max(dp[i][j], events[i][2]);\\n                }\\n                res = Math.max(res, dp[i][j]);\\n            }\\n        }\\n        return res;\\n    }\\n    \\n    // return the index of the first event whose end time does not overlap with start time of curr event i\\n    // if no such event, return -1;\\n    private int findIndex(int[][] events, int i) {\\n        int left = 0;\\n        int right = i - 1;\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n            if (events[mid][1] < events[i][0]) {\\n                left = mid + 1;\\n            } else {\\n                right = mid - 1;\\n            }\\n        }\\n        return left - 1;\\n    }\\n    \\n    class eventComparator implements Comparator<int[]> {\\n        public int compare(int[] a, int[] b) {\\n            return a[1] - b[1];\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1100954,
                "title": "java-dp-solution-very-straight-forward",
                "content": "sort the events array first,then find the largest k-1 events before we take the kth event.\\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        Arrays.sort(events,(a,b)->a[1]-b[1]);\\n        int[][] dp=new int[k+1][events.length+1];\\n        int[] prev=new int[events.length+1];\\n        for(int i=2;i<prev.length;i++)\\n        {\\n             int start=1;\\n             int end=i-1;\\n            while(start<=end)\\n            {\\n                int mid=start+(end-start)/2;\\n                if(events[i-1][0]>events[mid-1][1])start=mid+1;\\n                else end=mid-1;\\n            }\\n            prev[i]=end;\\n        }\\n        for(int i=1;i<=k;i++)\\n        {\\n           for(int j=1;j<=events.length;j++)dp[i][j]=Math.max(dp[i-1][prev[j]]+events[j-1][2],Math.max(dp[i][j-1],dp[i-1][j]));      \\n        }\\n        return dp[k][events.length];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        Arrays.sort(events,(a,b)->a[1]-b[1]);\\n        int[][] dp=new int[k+1][events.length+1];\\n        int[] prev=new int[events.length+1];\\n        for(int i=2;i<prev.length;i++)\\n        {\\n             int start=1;\\n             int end=i-1;\\n            while(start<=end)\\n            {\\n                int mid=start+(end-start)/2;\\n                if(events[i-1][0]>events[mid-1][1])start=mid+1;\\n                else end=mid-1;\\n            }\\n            prev[i]=end;\\n        }\\n        for(int i=1;i<=k;i++)\\n        {\\n           for(int j=1;j<=events.length;j++)dp[i][j]=Math.max(dp[i-1][prev[j]]+events[j-1][2],Math.max(dp[i][j-1],dp[i-1][j]));      \\n        }\\n        return dp[k][events.length];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056655,
                "title": "python3-knapsack",
                "content": "**Algo**\\nTypical application of knapsack problem. \\n\\n**Implementation**\\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort()\\n        starts = [i for i, _, _ in events]\\n        \\n        @cache\\n        def fn(i, k): \\n            \"\"\"Return max score of attending k events from events[i:].\"\"\"\\n            if i == len(events) or k == 0: return 0 \\n            ii = bisect_left(starts, events[i][1]+1)\\n            return max(fn(i+1, k), events[i][2] + fn(ii, k-1))\\n        \\n        return fn(0, k)\\n```\\n\\n**Analysis**\\nTime complexity `O(KNlogN)`\\nSpace complexity `O(KN)`",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort()\\n        starts = [i for i, _, _ in events]\\n        \\n        @cache\\n        def fn(i, k): \\n            \"\"\"Return max score of attending k events from events[i:].\"\"\"\\n            if i == len(events) or k == 0: return 0 \\n            ii = bisect_left(starts, events[i][1]+1)\\n            return max(fn(i+1, k), events[i][2] + fn(ii, k-1))\\n        \\n        return fn(0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1053798,
                "title": "my-java-solution-using-dynamic-programming",
                "content": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        // sort based on the first number\\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\\n        int n = events.length;\\n        int [][] dp = new int [n][k + 1];\\n        int max = 0;\\n        // our possiblity:\\n        // -> skip the event and start with the next event with no change in profit\\n        // -> consider this event, add profit and move on to next non overlapping event\\n        for (int i=0; i<n; i++) {\\n            max = Math.max(max, events[i][2]);\\n            dp[i][1] = events[i][2];\\n        }\\n        if (k == 1)\\n            return max;\\n        for (int i=1; i<n; i++) {\\n            for (int j=0; j<i; j++) {\\n                // non overlapping\\n                if (events[j][1] < events[i][0]) {\\n                    for (int x=2; x<=k; x++) {\\n                        dp[i][x] = Math.max(dp[i][x], dp[j][x-1] + events[i][2]);\\n                    }\\n                }\\n            }\\n        }\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<=k; j++) {\\n                max = Math.max(dp[i][j], max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        // sort based on the first number\\n        Arrays.sort(events, (a, b) -> a[0] - b[0]);\\n        int n = events.length;\\n        int [][] dp = new int [n][k + 1];\\n        int max = 0;\\n        // our possiblity:\\n        // -> skip the event and start with the next event with no change in profit\\n        // -> consider this event, add profit and move on to next non overlapping event\\n        for (int i=0; i<n; i++) {\\n            max = Math.max(max, events[i][2]);\\n            dp[i][1] = events[i][2];\\n        }\\n        if (k == 1)\\n            return max;\\n        for (int i=1; i<n; i++) {\\n            for (int j=0; j<i; j++) {\\n                // non overlapping\\n                if (events[j][1] < events[i][0]) {\\n                    for (int x=2; x<=k; x++) {\\n                        dp[i][x] = Math.max(dp[i][x], dp[j][x-1] + events[i][2]);\\n                    }\\n                }\\n            }\\n        }\\n        for (int i=0; i<n; i++) {\\n            for (int j=0; j<=k; j++) {\\n                max = Math.max(dp[i][j], max);\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052646,
                "title": "java-dp-bottom-up",
                "content": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        int[][] dp = new int[n][k];\\n        Arrays.sort(events, (int[] a, int[] b) -> {\\n            if(a[1] == b[1]) return b[2] - a[2];\\n            else return a[1] - b[1];\\n        });\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int l = 0; l < k; l++) {\\n                dp[i][l] = events[i][2];\\n                if(l > 0) {\\n                    for(int j = i - 1; j >= 0; j--) {\\n                        if(events[i][0] > events[j][1]) {\\n                            dp[i][l] = Math.max(dp[i][l],events[i][2] + dp[j][l-1]);\\n                        }\\n                    }\\n                }\\n                ans = Math.max(ans, dp[i][l]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        int[][] dp = new int[n][k];\\n        Arrays.sort(events, (int[] a, int[] b) -> {\\n            if(a[1] == b[1]) return b[2] - a[2];\\n            else return a[1] - b[1];\\n        });\\n        int ans = 0;\\n        for(int i = 0; i < n; i++) {\\n            for(int l = 0; l < k; l++) {\\n                dp[i][l] = events[i][2];\\n                if(l > 0) {\\n                    for(int j = i - 1; j >= 0; j--) {\\n                        if(events[i][0] > events[j][1]) {\\n                            dp[i][l] = Math.max(dp[i][l],events[i][2] + dp[j][l-1]);\\n                        }\\n                    }\\n                }\\n                ans = Math.max(ans, dp[i][l]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052619,
                "title": "python-simple-solution-dp",
                "content": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort(key=lambda x: (x[0], x[1]))\\n        \\n        @lru_cache(None)\\n        def dp(idx, max_end, k):\\n            if idx < 0 or k == 0:\\n                return 0\\n            if events[idx][1] <= max_end:\\n                return max(\\n                    dp(idx-1, max_end, k),\\n                    dp(idx-1, events[idx][0] - 1, k-1) + events[idx][2]\\n                )\\n            else:\\n                return dp(idx-1, max_end, k)\\n       \\n        return dp(len(events) - 1, float(\\'inf\\'), k)\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nfrom functools import lru_cache\\n\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort(key=lambda x: (x[0], x[1]))\\n        \\n        @lru_cache(None)\\n        def dp(idx, max_end, k):\\n            if idx < 0 or k == 0:\\n                return 0\\n            if events[idx][1] <= max_end:\\n                return max(\\n                    dp(idx-1, max_end, k),\\n                    dp(idx-1, events[idx][0] - 1, k-1) + events[idx][2]\\n                )\\n            else:\\n                return dp(idx-1, max_end, k)\\n       \\n        return dp(len(events) - 1, float(\\'inf\\'), k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052439,
                "title": "python-dp-1-k-events-length-10-6",
                "content": "No need to do greedy when you know that the state space of (i,remaining) is upper bounded by 10^6. Sort the intervals by starting time. At each i, either use this index, or don\\'t. Return the max of the two cases. If you use the index, then the recursive call will be at the first interval that starts after interval i ends. \\n\\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort()\\n        @lru_cache(None)\\n        def dp(i,rem):\\n            if i == len(events):\\n                return 0\\n            elif rem == 0:\\n                return 0\\n            else:\\n                opt = dp(i+1,rem)\\n                idx = i+1\\n                while idx < len(events) and events[idx][0] <= events[i][1]:\\n                    idx += 1\\n                opt = max(opt,events[i][2]+dp(idx,rem-1))\\n                return opt\\n                \\n        return dp(0,k)\\n```\\n\\nTime: O(k times events.length^2) Can be improved to  O(kevents.lengthlog(events.length)) if use bisect to find next index. Kind of surprised that naive is not TLE. Either the test cases are uncomprehensive, or I have a misunderstanding of the runtime, but I feel like the top down dp solution is too slow. \\nSpace: O(k times events.length)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort()\\n        @lru_cache(None)\\n        def dp(i,rem):\\n            if i == len(events):\\n                return 0\\n            elif rem == 0:\\n                return 0\\n            else:\\n                opt = dp(i+1,rem)\\n                idx = i+1\\n                while idx < len(events) and events[idx][0] <= events[i][1]:\\n                    idx += 1\\n                opt = max(opt,events[i][2]+dp(idx,rem-1))\\n                return opt\\n                \\n        return dp(0,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052435,
                "title": "c-dp-greedy-sorting-easy-to-understand-sufficiently-commented",
                "content": "**Throught Process**: \\n- if take event i, we can\\'t take anything that overlaps with it --> it\\'d be helpful if we knew the latest event ending before event i starts\\n- so we sort by end time so that we can binary search for the latest event that ends before event i starts for all i\\n- then use dp to record all states\\n- where state = (i,j) = answer if we can go to at most i events using the first j events \\n- the rest you can see in comments\\n\\n**Time Complexity**: \\n- sorting = NlogN --> a bit worrisome if N = 1e6 but it passed\\n- binary searching = NlogN\\n- NK states in DP, each one is O(1)\\n- Total = NlogN + NK\\n\\n```\\nclass Solution {\\n public:\\n  struct compar {\\n    bool operator()(const vector<int>& a,\\n                    const vector<int>& b) const {\\n      return a[1] < b[1];\\n    }\\n  };\\n  int maxValue(vector<vector<int>>& events, int k) {\\n    int n = events.size();\\n    sort(events.begin(), events.end(), compar());  // sort by end\\n    vector<int> opt(n);\\n    for (int i = 0; i != n; ++i) {\\n      vector<int> point = {0, events[i][0]};\\n      auto it = lower_bound(events.begin(), events.begin() + i + 1, point, compar());  // first one that ends >= when event i starts\\n      opt[i] = it - events.begin() - 1;                                                // subtract 1 to get the latest good one\\n    }\\n    vector<vector<int>> dp(1 + k, vector<int>(n));  // dp[i][j] = max sum using <= i events from events [:j]\\n    for (int i = 1; i <= k; ++i) {\\n      for (int j = 0; j != n; ++j) {\\n        dp[i][j] = dp[i - 1][j];                        // using <= i-1 events is still valid\\n        if (j) dp[i][j] = max(dp[i][j], dp[i][j - 1]);  // don\\'t use this event\\n        int p = opt[j];                                 // latest event ending before this one starts\\n        dp[i][j] = max(dp[i][j], (p == -1 ? 0 : dp[i - 1][p]) + events[j][2]);\\n      }\\n    }\\n    return dp[k][n - 1];\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n public:\\n  struct compar {\\n    bool operator()(const vector<int>& a,\\n                    const vector<int>& b) const {\\n      return a[1] < b[1];\\n    }\\n  };\\n  int maxValue(vector<vector<int>>& events, int k) {\\n    int n = events.size();\\n    sort(events.begin(), events.end(), compar());  // sort by end\\n    vector<int> opt(n);\\n    for (int i = 0; i != n; ++i) {\\n      vector<int> point = {0, events[i][0]};\\n      auto it = lower_bound(events.begin(), events.begin() + i + 1, point, compar());  // first one that ends >= when event i starts\\n      opt[i] = it - events.begin() - 1;                                                // subtract 1 to get the latest good one\\n    }\\n    vector<vector<int>> dp(1 + k, vector<int>(n));  // dp[i][j] = max sum using <= i events from events [:j]\\n    for (int i = 1; i <= k; ++i) {\\n      for (int j = 0; j != n; ++j) {\\n        dp[i][j] = dp[i - 1][j];                        // using <= i-1 events is still valid\\n        if (j) dp[i][j] = max(dp[i][j], dp[i][j - 1]);  // don\\'t use this event\\n        int p = opt[j];                                 // latest event ending before this one starts\\n        dp[i][j] = max(dp[i][j], (p == -1 ? 0 : dp[i - 1][p]) + events[j][2]);\\n      }\\n    }\\n    return dp[k][n - 1];\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3815855,
                "title": "c-super-easy-clean-code-classic-2d-dp-easy-to-grasp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst int mod = 1e9+7;\\nclass Solution {\\nprivate:\\n    int solver(int i, vector<vector<int>>& events, int k, vector<vector<int>>& dp){\\n        if(i == events.size() || k == 0) return 0;\\n\\n        if(dp[i][k] != -1) return dp[i][k];\\n\\n        int skip = 0 + solver(i+1,events,k,dp);\\n\\n        vector<int> comparison = {events[i][1],mod,mod};\\n\\n        int next_pick = upper_bound(events.begin()+i+1,events.end(),comparison) - events.begin();\\n\\n        int pick = events[i][2] + solver(next_pick,events,k-1,dp);\\n\\n        return dp[i][k] = max(pick,skip); \\n    }\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        \\n        sort(events.begin(),events.end());\\n        int n = events.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n\\n        return solver(0,events,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nconst int mod = 1e9+7;\\nclass Solution {\\nprivate:\\n    int solver(int i, vector<vector<int>>& events, int k, vector<vector<int>>& dp){\\n        if(i == events.size() || k == 0) return 0;\\n\\n        if(dp[i][k] != -1) return dp[i][k];\\n\\n        int skip = 0 + solver(i+1,events,k,dp);\\n\\n        vector<int> comparison = {events[i][1],mod,mod};\\n\\n        int next_pick = upper_bound(events.begin()+i+1,events.end(),comparison) - events.begin();\\n\\n        int pick = events[i][2] + solver(next_pick,events,k-1,dp);\\n\\n        return dp[i][k] = max(pick,skip); \\n    }\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        \\n        sort(events.begin(),events.end());\\n        int n = events.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n\\n        return solver(0,events,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777070,
                "title": "solution-2d-dp-binary-search-fastest-c-code",
                "content": "\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int recursion(vector<vector<int>>& events, int k, int n, vector<vector<int>>& dp){\\n        if(n == events.size() || k == 0 || n == -1)   return 0;\\n        \\n        if(dp[n][k] != -1)  return dp[n][k];\\n\\n        int take = 0;\\n        int nextn = -1;\\n\\n        int left = n+1, right = events.size()-1;\\n        while(right >= left){\\n            int mid = left + (right-left)/2;\\n            if(events[mid][0] > events[n][1]){\\n                nextn = mid;\\n                right = mid-1;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n\\n        if(nextn){\\n            take = events[n][2] + recursion(events, k-1, nextn, dp);\\n        }\\n\\n        int nottake = recursion(events, k, n+1, dp);\\n\\n        return dp[n][k] = max(take, nottake);\\n\\n    }\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        if(k == 1){\\n            int maxi = 0;\\n            for(int i = 0; i < n; ++i){\\n                maxi = max(maxi, events[i][2]);\\n            }\\n            return maxi;\\n        }\\n        sort(events.begin(), events.end());\\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        return recursion(events, k, 0, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int recursion(vector<vector<int>>& events, int k, int n, vector<vector<int>>& dp){\\n        if(n == events.size() || k == 0 || n == -1)   return 0;\\n        \\n        if(dp[n][k] != -1)  return dp[n][k];\\n\\n        int take = 0;\\n        int nextn = -1;\\n\\n        int left = n+1, right = events.size()-1;\\n        while(right >= left){\\n            int mid = left + (right-left)/2;\\n            if(events[mid][0] > events[n][1]){\\n                nextn = mid;\\n                right = mid-1;\\n            }\\n            else{\\n                left = mid+1;\\n            }\\n        }\\n\\n        if(nextn){\\n            take = events[n][2] + recursion(events, k-1, nextn, dp);\\n        }\\n\\n        int nottake = recursion(events, k, n+1, dp);\\n\\n        return dp[n][k] = max(take, nottake);\\n\\n    }\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        if(k == 1){\\n            int maxi = 0;\\n            for(int i = 0; i < n; ++i){\\n                maxi = max(maxi, events[i][2]);\\n            }\\n            return maxi;\\n        }\\n        sort(events.begin(), events.end());\\n        vector<vector<int>> dp(n, vector<int>(k+1, -1));\\n        return recursion(events, k, 0, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3773145,
                "title": "dp-binarysearch-different-approach-92-timecomplexity-98-spacecomplexity",
                "content": "# Intuition\\nFirstly this problem i somewhat related it to longest increasing sequence but there was a slight modification in it... firstly lets look at how i solved LIS (in nlogn but sligtly unconventional)\\ni would make a set of pairs which store {nums[i],dp[nums[i]]}\\n(dp[nums[i]]=max LIS till this nums[i] is encountered) and would maintain the set that \"both\" of the element in the would be increasing , because if first increases and second decreases then why would i even store it because if someone bigger than this element comes and askes the set for its dp it would be lesses than smaller nums[i] so why even use this number so in that both will increase ... i just found for nums[i] lowerbound of it and its corresponding dp and also inserted (following the above property) in the set for next nums[i]\\n\\n# Approach\\ni would follow the intuition but the 2nd part of the pair will be dp[i]-> max value that can be achieved and follow that -> maintain that for K meetings \\n\\n# Complexity\\n- Time complexity:\\nn*k*log(k)\\n\\n- Space complexity:\\nn*k\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& v, int k) {\\n        int n = v.size(),ans=0;\\n        sort(v.begin(),v.end());\\n        set<pair<int,int>> pr[k+1];\\n        for(int j=0;j<=k;j++){\\n            pr[j].insert({-100,0});\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j = min(i,k);j>=1;j--){\\n                auto it = pr[j-1].upper_bound({v[i-1][0]-1,INT_MAX});it--;\\n                int ak = (it->second)+v[i-1][2];ans=max(ans,ak);\\n                auto it1 = pr[j].upper_bound({v[i-1][1]-1,INT_MAX});\\n                if(it1!=pr[j].end()){\\n                    int exx = it1->second;\\n                    if(exx>=ak && it1->first<=v[i-1][1]){\\n                        continue;\\n                    }\\n                }\\n                if(it1!=pr[j].begin()){\\n                    auto temp = it1;temp--;\\n                    if(temp->second>=ak)continue;\\n                }\\n                vector<pair<int,int>> ff;\\n                for(auto itr = it1;itr!=pr[j].end();itr++){\\n                    if(ak>=itr->second)ff.push_back({itr->first,itr->second});\\n                    else break;\\n                }\\n                for(int l=0;l<ff.size();l++){\\n                    pr[j].erase(ff[l]);\\n                }\\n                pr[j].insert({v[i-1][1],ak});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& v, int k) {\\n        int n = v.size(),ans=0;\\n        sort(v.begin(),v.end());\\n        set<pair<int,int>> pr[k+1];\\n        for(int j=0;j<=k;j++){\\n            pr[j].insert({-100,0});\\n        }\\n        for(int i=1;i<=n;i++){\\n            for(int j = min(i,k);j>=1;j--){\\n                auto it = pr[j-1].upper_bound({v[i-1][0]-1,INT_MAX});it--;\\n                int ak = (it->second)+v[i-1][2];ans=max(ans,ak);\\n                auto it1 = pr[j].upper_bound({v[i-1][1]-1,INT_MAX});\\n                if(it1!=pr[j].end()){\\n                    int exx = it1->second;\\n                    if(exx>=ak && it1->first<=v[i-1][1]){\\n                        continue;\\n                    }\\n                }\\n                if(it1!=pr[j].begin()){\\n                    auto temp = it1;temp--;\\n                    if(temp->second>=ak)continue;\\n                }\\n                vector<pair<int,int>> ff;\\n                for(auto itr = it1;itr!=pr[j].end();itr++){\\n                    if(ak>=itr->second)ff.push_back({itr->first,itr->second});\\n                    else break;\\n                }\\n                for(int l=0;l<ff.size();l++){\\n                    pr[j].erase(ff[l]);\\n                }\\n                pr[j].insert({v[i-1][1],ak});\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3772697,
                "title": "c-easy-recursion-memoization-dp-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic: \\n    int f( int i , vector<vector<int>>&events ,vector<int>&start  , int k ,vector<vector<int>>&dp)\\n    {\\n        int n = start.size();\\n        if(i>=n)return 0;\\n        if(k==0) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int index = upper_bound(start.begin() , start.end() , events[i][1]) -start.begin();\\n        int take  = events[i][2]+f(index  ,events, start  , k-1 , dp);\\n        int nottake = f(i+1  ,events, start  , k , dp);\\n        return  dp[i][k]=max(take, nottake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) \\n    {\\n        sort(events.begin() , events.end());\\n        vector<int>start ;\\n        int n = events.size();\\n        vector<vector<int>> dp(n+1 , vector<int>(k+1 , -1));\\n        for(int i =0 ; i<events.size() ;i++) start.push_back(events[i][0]);\\n        return f(0 , events , start , k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    int f( int i , vector<vector<int>>&events ,vector<int>&start  , int k ,vector<vector<int>>&dp)\\n    {\\n        int n = start.size();\\n        if(i>=n)return 0;\\n        if(k==0) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int index = upper_bound(start.begin() , start.end() , events[i][1]) -start.begin();\\n        int take  = events[i][2]+f(index  ,events, start  , k-1 , dp);\\n        int nottake = f(i+1  ,events, start  , k , dp);\\n        return  dp[i][k]=max(take, nottake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) \\n    {\\n        sort(events.begin() , events.end());\\n        vector<int>start ;\\n        int n = events.size();\\n        vector<vector<int>> dp(n+1 , vector<int>(k+1 , -1));\\n        for(int i =0 ; i<events.size() ;i++) start.push_back(events[i][0]);\\n        return f(0 , events , start , k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770352,
                "title": "recurrsion-same-take-not-take-concept-memo",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\n\\n//Approach <----------------Recurrsion------------->\\n\\n\\n\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        Arrays.sort(events,new Comparator<int[]>(){\\n            public int compare(int[] a,int[] b){\\n                if(a[0]!=b[0]){\\n                    return a[0]-b[0];\\n                }\\n                else{\\n                    return a[1]-b[1];\\n                }\\n            }\\n        });\\n        return solve(0,events,k,-1);\\n    }\\n    public int solve(int idx,int[][] events,int k,int prev){\\n        if(idx>=events.length){\\n            return 0;\\n        }\\n        int not_taken = solve(idx+1,events,k,prev);\\n        int taken = 0;\\n        if(prev==-1 ||(k>0 && events[prev][1]<events[idx][0])){\\n            taken = events[idx][2]+solve(idx+1,events,k-1,idx);\\n        }\\n        return Math.max(taken,not_taken);\\n\\n    }\\n}\\n\\n\\n\\n\\n//--------------------------------------------------//\\n\\n//<--------------- dp------>\\nclass Solution {\\n    int[][] dp;\\n    public int maxValue(int[][] events, int k) {\\n        dp = new int[events.length+1][k+1];\\n        for(int[] i:dp){\\n            Arrays.fill(i,-1);\\n        }\\n        Arrays.sort(events,new Comparator<int[]>(){\\n            public int compare(int[] a,int[] b){\\n                if(a[0]!=b[0]){\\n                    return a[0]-b[0];\\n                }\\n                else{\\n                    return a[1]-b[1];\\n                }\\n            }\\n        });\\n        return solve(0,events,k,-1);\\n    }\\n    public int solve(int idx,int[][] events,int k,int prev){\\n        if(idx>=events.length || k==0){\\n            return 0;\\n        }\\n        if(prev!=-1 && dp[prev][k]!=-1){\\n            return dp[prev][k];\\n        }\\n        int not_taken = solve(idx+1,events,k,prev);\\n        int taken = 0;\\n        if(prev==-1 ||events[prev][1]<events[idx][0]){\\n            taken = events[idx][2]+solve(idx+1,events,k-1,idx);\\n        }\\n        if(prev!=-1){\\n            dp[prev][k] = Math.max(taken,not_taken);\\n        }\\n        return Math.max(taken,not_taken);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\n\\n\\n//Approach <----------------Recurrsion------------->\\n\\n\\n\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        Arrays.sort(events,new Comparator<int[]>(){\\n            public int compare(int[] a,int[] b){\\n                if(a[0]!=b[0]){\\n                    return a[0]-b[0];\\n                }\\n                else{\\n                    return a[1]-b[1];\\n                }\\n            }\\n        });\\n        return solve(0,events,k,-1);\\n    }\\n    public int solve(int idx,int[][] events,int k,int prev){\\n        if(idx>=events.length){\\n            return 0;\\n        }\\n        int not_taken = solve(idx+1,events,k,prev);\\n        int taken = 0;\\n        if(prev==-1 ||(k>0 && events[prev][1]<events[idx][0])){\\n            taken = events[idx][2]+solve(idx+1,events,k-1,idx);\\n        }\\n        return Math.max(taken,not_taken);\\n\\n    }\\n}\\n\\n\\n\\n\\n//--------------------------------------------------//\\n\\n//<--------------- dp------>\\nclass Solution {\\n    int[][] dp;\\n    public int maxValue(int[][] events, int k) {\\n        dp = new int[events.length+1][k+1];\\n        for(int[] i:dp){\\n            Arrays.fill(i,-1);\\n        }\\n        Arrays.sort(events,new Comparator<int[]>(){\\n            public int compare(int[] a,int[] b){\\n                if(a[0]!=b[0]){\\n                    return a[0]-b[0];\\n                }\\n                else{\\n                    return a[1]-b[1];\\n                }\\n            }\\n        });\\n        return solve(0,events,k,-1);\\n    }\\n    public int solve(int idx,int[][] events,int k,int prev){\\n        if(idx>=events.length || k==0){\\n            return 0;\\n        }\\n        if(prev!=-1 && dp[prev][k]!=-1){\\n            return dp[prev][k];\\n        }\\n        int not_taken = solve(idx+1,events,k,prev);\\n        int taken = 0;\\n        if(prev==-1 ||events[prev][1]<events[idx][0]){\\n            taken = events[idx][2]+solve(idx+1,events,k-1,idx);\\n        }\\n        if(prev!=-1){\\n            dp[prev][k] = Math.max(taken,not_taken);\\n        }\\n        return Math.max(taken,not_taken);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770214,
                "title": "dp-memoization-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nbool cmp(vector<int> &a, vector<int> &b) {\\n    return a[1] < b[1];\\n}\\n\\nclass Solution {\\npublic:\\n    int binarySearch(vector<vector<int>> &events, int i, int lowThres) {\\n        int left = i + 1, right = events.size() - 1;\\n\\n        int result = events.size();\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (events[mid][0] > lowThres) {\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    int solveRec(vector<vector<int>> &events, int i, int k, vector<vector<int>> &dp) {\\n        if (i == events.size()) return 0;\\n\\n        if (k == 0) return 0;\\n\\n        if (dp[i][k] != -1) return dp[i][k];\\n\\n        // int nextIndex = events.size();\\n        int nextIndex = binarySearch(events, i, events[i][1]);\\n        // for (int j = i + 1; j < events.size(); j++) {\\n        //     if (events[j][0] < minValue && events[j][0] > events[i][1]) {\\n        //         minValue = min(minValue, events[j][0]);\\n        //         nextIndex = j;\\n        //     }\\n        // }\\n\\n        return dp[i][k] = max(events[i][2] + solveRec(events, nextIndex, k - 1, dp),\\n        solveRec(events, i + 1, k, dp));\\n    }\\n\\n    int maxValue(vector<vector<int>> &events, int k) {\\n        sort(events.begin(), events.end());\\n\\n        // Optimization 1: dp\\n        // Optimization 2: binary search\\n\\n        vector<vector<int>> dp(events.size() + 1, vector<int>(k + 1, -1));\\n\\n        return solveRec(events, 0, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nbool cmp(vector<int> &a, vector<int> &b) {\\n    return a[1] < b[1];\\n}\\n\\nclass Solution {\\npublic:\\n    int binarySearch(vector<vector<int>> &events, int i, int lowThres) {\\n        int left = i + 1, right = events.size() - 1;\\n\\n        int result = events.size();\\n        while (left <= right) {\\n            int mid = left + (right - left) / 2;\\n\\n            if (events[mid][0] > lowThres) {\\n                result = mid;\\n                right = mid - 1;\\n            } else {\\n                left = mid + 1;\\n            }\\n        }\\n\\n        return result;\\n    }\\n\\n    int solveRec(vector<vector<int>> &events, int i, int k, vector<vector<int>> &dp) {\\n        if (i == events.size()) return 0;\\n\\n        if (k == 0) return 0;\\n\\n        if (dp[i][k] != -1) return dp[i][k];\\n\\n        // int nextIndex = events.size();\\n        int nextIndex = binarySearch(events, i, events[i][1]);\\n        // for (int j = i + 1; j < events.size(); j++) {\\n        //     if (events[j][0] < minValue && events[j][0] > events[i][1]) {\\n        //         minValue = min(minValue, events[j][0]);\\n        //         nextIndex = j;\\n        //     }\\n        // }\\n\\n        return dp[i][k] = max(events[i][2] + solveRec(events, nextIndex, k - 1, dp),\\n        solveRec(events, i + 1, k, dp));\\n    }\\n\\n    int maxValue(vector<vector<int>> &events, int k) {\\n        sort(events.begin(), events.end());\\n\\n        // Optimization 1: dp\\n        // Optimization 2: binary search\\n\\n        vector<vector<int>> dp(events.size() + 1, vector<int>(k + 1, -1));\\n\\n        return solveRec(events, 0, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3770203,
                "title": "python-dp-heapq-640-ms-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI am very surprised very few (no?) people mentioned heapq for this question.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort events by the start time.\\n\\nUse dp[i] to store the max values if # of i events are attended.\\n\\nUse heapq to store (endtime, # of events, max value). Whenever current events\\' start time > endtime, pop it out and update dp.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxValue(self, events, k):\\n        \"\"\"\\n        :type events: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n\\n        events.sort()\\n        dp = [0] * (k+1)\\n        hq = []\\n\\n        for s,e,v in events:\\n            while hq and hq[0][0] < s:\\n                _, n, pv = heapq.heappop(hq)\\n                dp[n] = max(dp[n], pv)\\n\\n            for i in range(k):\\n                if i > 0 and dp[i] == 0: break\\n                heapq.heappush(hq, (e, i+1, v + dp[i]))\\n\\n        return max(max([pv for _,_,pv in hq]), max(dp))\\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI am very surprised very few (no?) people mentioned heapq for this question.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort events by the start time.\\n\\nUse dp[i] to store the max values if # of i events are attended.\\n\\nUse heapq to store (endtime, # of events, max value). Whenever current events\\' start time > endtime, pop it out and update dp.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def maxValue(self, events, k):\\n        \"\"\"\\n        :type events: List[List[int]]\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n\\n        events.sort()\\n        dp = [0] * (k+1)\\n        hq = []\\n\\n        for s,e,v in events:\\n            while hq and hq[0][0] < s:\\n                _, n, pv = heapq.heappop(hq)\\n                dp[n] = max(dp[n], pv)\\n\\n            for i in range(k):\\n                if i > 0 and dp[i] == 0: break\\n                heapq.heappush(hq, (e, i+1, v + dp[i]))\\n\\n        return max(max([pv for _,_,pv in hq]), max(dp))\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 3770145,
                "title": "c-easy-crisp-solution-2-d-dp-bs",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int binary_search(int target,vector<vector<int>>&events)\\n    {\\n        int i=0;\\n        int j=events.size()-1;\\n        int mid;\\n        int req=-1;\\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            if(events[mid][0]-1>=target)\\n            {\\n                req=mid;\\n                j=mid-1;\\n            }\\n            else\\n            i=mid+1;\\n        }\\n        return req;\\n    }\\n    int solve(int i,vector<vector<int>>&events,int k,vector<vector<int>>&dp)\\n    {\\n        if(k==0 || i>=events.size() || i==-1)\\n        return 0;\\n        if(dp[i][k]!=-1)\\n        return dp[i][k];\\n        \\n        int endtime=events[i][1];\\n        int idx=binary_search(endtime,events);\\n        int take=events[i][2]+solve(idx,events,k-1,dp);\\n        return dp[i][k]=max(take,solve(i+1,events,k,dp));\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<vector<int>> dp(events.size(),vector<int>(k+1,-1));\\n        sort(events.begin(),events.end());\\n        return solve(0,events,k,dp);\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int binary_search(int target,vector<vector<int>>&events)\\n    {\\n        int i=0;\\n        int j=events.size()-1;\\n        int mid;\\n        int req=-1;\\n        while(i<=j)\\n        {\\n            int mid=(i+j)/2;\\n            if(events[mid][0]-1>=target)\\n            {\\n                req=mid;\\n                j=mid-1;\\n            }\\n            else\\n            i=mid+1;\\n        }\\n        return req;\\n    }\\n    int solve(int i,vector<vector<int>>&events,int k,vector<vector<int>>&dp)\\n    {\\n        if(k==0 || i>=events.size() || i==-1)\\n        return 0;\\n        if(dp[i][k]!=-1)\\n        return dp[i][k];\\n        \\n        int endtime=events[i][1];\\n        int idx=binary_search(endtime,events);\\n        int take=events[i][2]+solve(idx,events,k-1,dp);\\n        return dp[i][k]=max(take,solve(i+1,events,k,dp));\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<vector<int>> dp(events.size(),vector<int>(k+1,-1));\\n        sort(events.begin(),events.end());\\n        return solve(0,events,k,dp);\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3769188,
                "title": "c-dp-binary-search-memoization-beats-98-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        init(events, k);\\n        return recursive(events, 0, m_k);\\n    }\\n    \\nprivate:\\n    void init(std::vector<std::vector<int>>& ev, int k) {\\n        m_n = ev.size();\\n        m_k = k;\\n        std::sort(ev.begin(), ev.end());\\n        m_indices.reserve(m_n);\\n        for (auto it = ev.cbegin(); it != ev.cend(); ++it)\\n            m_indices.emplace_back(std::distance(ev.cbegin(), std::upper_bound(it + 1, ev.cend(), it->at(1),\\n                [](int t, const auto& e) { return t < e[0]; })));\\n        m_cache.resize(m_n * m_k, -1);\\n    }\\n    \\n    int recursive(const std::vector<std::vector<int>>& ev, int i, int k) {\\n        if (k && i < m_n) {\\n            int index = i * m_k + k - 1;\\n            if (m_cache[index] == -1) \\n                m_cache[index] = std::max(recursive(ev, i + 1, k),\\n                                          ev[i][2] + recursive(ev, m_indices[i], k - 1));\\n            return m_cache[index];\\n        }\\n        return 0;\\n    }\\n    \\nprivate:\\n    int m_n;\\n    int m_k;\\n    std::vector<int> m_cache;\\n    std::vector<int> m_indices;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        init(events, k);\\n        return recursive(events, 0, m_k);\\n    }\\n    \\nprivate:\\n    void init(std::vector<std::vector<int>>& ev, int k) {\\n        m_n = ev.size();\\n        m_k = k;\\n        std::sort(ev.begin(), ev.end());\\n        m_indices.reserve(m_n);\\n        for (auto it = ev.cbegin(); it != ev.cend(); ++it)\\n            m_indices.emplace_back(std::distance(ev.cbegin(), std::upper_bound(it + 1, ev.cend(), it->at(1),\\n                [](int t, const auto& e) { return t < e[0]; })));\\n        m_cache.resize(m_n * m_k, -1);\\n    }\\n    \\n    int recursive(const std::vector<std::vector<int>>& ev, int i, int k) {\\n        if (k && i < m_n) {\\n            int index = i * m_k + k - 1;\\n            if (m_cache[index] == -1) \\n                m_cache[index] = std::max(recursive(ev, i + 1, k),\\n                                          ev[i][2] + recursive(ev, m_indices[i], k - 1));\\n            return m_cache[index];\\n        }\\n        return 0;\\n    }\\n    \\nprivate:\\n    int m_n;\\n    int m_k;\\n    std::vector<int> m_cache;\\n    std::vector<int> m_indices;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768797,
                "title": "smallest-java-code-simple-beginner-friendly-memoization",
                "content": "# Complexity\\nTime complexity: \\n- Best & Avg Case - $$O(n*k)$$\\n- Worst Case - $$O(n*n*k)$$ \\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nSpace complexity: $$O(n*k)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    Integer dp[][]; int n;\\n    public int maxValue(int[][] events, int k) {\\n        n=events.length; dp=new Integer[n][k];\\n        Arrays.sort(events,(a,b)->a[0]-b[0]);\\n        return find(0, events, -1, k, 0);\\n    }\\n    private int find(int end_time, int[][] ev, int ind, int k, int curr){\\n        if(k==0) return 0;\\n        if(ind!=-1 && dp[ind][k]!=null) return dp[ind][k];\\n        int maxv=0;\\n        for(int i=ind+1; i<n; i++)\\n            if(end_time<ev[i][0])\\n                maxv=Math.max(find(ev[i][1], ev, i, k-1, curr+ev[i][2])+ev[i][2], maxv);\\n        return (ind!=-1)? (dp[ind][k]=maxv): maxv;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Integer dp[][]; int n;\\n    public int maxValue(int[][] events, int k) {\\n        n=events.length; dp=new Integer[n][k];\\n        Arrays.sort(events,(a,b)->a[0]-b[0]);\\n        return find(0, events, -1, k, 0);\\n    }\\n    private int find(int end_time, int[][] ev, int ind, int k, int curr){\\n        if(k==0) return 0;\\n        if(ind!=-1 && dp[ind][k]!=null) return dp[ind][k];\\n        int maxv=0;\\n        for(int i=ind+1; i<n; i++)\\n            if(end_time<ev[i][0])\\n                maxv=Math.max(find(ev[i][1], ev, i, k-1, curr+ev[i][2])+ev[i][2], maxv);\\n        return (ind!=-1)? (dp[ind][k]=maxv): maxv;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768600,
                "title": "c-solution-dp-beats-100-o-n-k",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxValue(int[][] events, int k) {\\n        int[][] dp = new int[events.Length][];\\n\\n        for(int i=0; i<events.Length; i++){\\n            dp[i] = new int[k+1];\\n            Array.Fill(dp[i], -1);\\n        }\\n\\n        Array.Sort(events, (a, b) => {\\n            if(a[0] != b[0]){\\n                return a[0] - b[0];\\n            }\\n            else{\\n                return a[1] - b[1];\\n            }\\n        });\\n\\n        return DFS(events, dp, 0, k, 0);\\n    }\\n\\n    private int DFS(int[][] events, int[][] dp, int idx, int k, int eventEndDay){\\n        while(idx < events.Length && events[idx][0] <= eventEndDay){\\n            idx++;\\n        }\\n\\n        if(idx >= events.Length || k == 0){\\n            return 0;\\n        }\\n\\n        if(dp[idx][k] != -1){\\n            return dp[idx][k];\\n        }\\n\\n        dp[idx][k] = Math.Max(dp[idx][k], DFS(events, dp, idx+1, k, eventEndDay));\\n\\n        if(events[idx][0] > eventEndDay){\\n            dp[idx][k] = Math.Max(dp[idx][k], events[idx][2] + DFS(events, dp, idx+1, k-1, events[idx][1]));\\n        }\\n\\n        return dp[idx][k];\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxValue(int[][] events, int k) {\\n        int[][] dp = new int[events.Length][];\\n\\n        for(int i=0; i<events.Length; i++){\\n            dp[i] = new int[k+1];\\n            Array.Fill(dp[i], -1);\\n        }\\n\\n        Array.Sort(events, (a, b) => {\\n            if(a[0] != b[0]){\\n                return a[0] - b[0];\\n            }\\n            else{\\n                return a[1] - b[1];\\n            }\\n        });\\n\\n        return DFS(events, dp, 0, k, 0);\\n    }\\n\\n    private int DFS(int[][] events, int[][] dp, int idx, int k, int eventEndDay){\\n        while(idx < events.Length && events[idx][0] <= eventEndDay){\\n            idx++;\\n        }\\n\\n        if(idx >= events.Length || k == 0){\\n            return 0;\\n        }\\n\\n        if(dp[idx][k] != -1){\\n            return dp[idx][k];\\n        }\\n\\n        dp[idx][k] = Math.Max(dp[idx][k], DFS(events, dp, idx+1, k, eventEndDay));\\n\\n        if(events[idx][0] > eventEndDay){\\n            dp[idx][k] = Math.Max(dp[idx][k], events[idx][2] + DFS(events, dp, idx+1, k-1, events[idx][1]));\\n        }\\n\\n        return dp[idx][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768439,
                "title": "c-easy-approach-dp-bs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int help(vector<vector<int>>&e,int k,int i,vector<vector<int>>&dp)\\n    {\\n        if(i>=e.size())\\n        return 0;\\n        if(dp[i][k]!=-1)\\n        return dp[i][k];\\n        int ans = help(e,k,i+1,dp);\\n        if(k)\\n        {\\n           vector<int> temp = {e[i][1],INT_MAX,INT_MAX};\\n           int in = upper_bound(e.begin(), e.end(), temp)-e.begin();\\n           ans = max(ans, e[i][2] + help(e,k-1,in,dp));\\n        }\\n        return dp[i][k] = ans;\\n    }\\n    int maxValue(vector<vector<int>>& e, int k) \\n    {\\n        sort(e.begin(),e.end());\\n        vector<vector<int>>dp(e.size(),vector<int>(k+1,-1));\\n        return help(e,k,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int help(vector<vector<int>>&e,int k,int i,vector<vector<int>>&dp)\\n    {\\n        if(i>=e.size())\\n        return 0;\\n        if(dp[i][k]!=-1)\\n        return dp[i][k];\\n        int ans = help(e,k,i+1,dp);\\n        if(k)\\n        {\\n           vector<int> temp = {e[i][1],INT_MAX,INT_MAX};\\n           int in = upper_bound(e.begin(), e.end(), temp)-e.begin();\\n           ans = max(ans, e[i][2] + help(e,k-1,in,dp));\\n        }\\n        return dp[i][k] = ans;\\n    }\\n    int maxValue(vector<vector<int>>& e, int k) \\n    {\\n        sort(e.begin(),e.end());\\n        vector<vector<int>>dp(e.size(),vector<int>(k+1,-1));\\n        return help(e,k,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768389,
                "title": "leave-it-or-take-it-dp",
                "content": "T: O(nlogn+nk)\\ns:O(nk)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort()\\n        n=len(events)\\n        dp=[[-1]*n for _ in range(k)]\\n        def choice(index,count,end):\\n            if count==k or index==n:\\n                return 0\\n            if events[index][0]<=end:\\n                return choice(index+1,count,end)\\n            if dp[count][index]!=-1:\\n                return dp[count][index]\\n\\n            dp[count][index]=max(choice(index+1,count+1,events[index][1])+events[index][2],choice(index+1,count,end))\\n            return dp[count][index]\\n\\n        return choice(0,0,-1)\\n            \\n\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort()\\n        n=len(events)\\n        dp=[[-1]*n for _ in range(k)]\\n        def choice(index,count,end):\\n            if count==k or index==n:\\n                return 0\\n            if events[index][0]<=end:\\n                return choice(index+1,count,end)\\n            if dp[count][index]!=-1:\\n                return dp[count][index]\\n\\n            dp[count][index]=max(choice(index+1,count+1,events[index][1])+events[index][2],choice(index+1,count,end))\\n            return dp[count][index]\\n\\n        return choice(0,0,-1)\\n            \\n\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768385,
                "title": "dp-binary-search-c",
                "content": "```\\nclass Solution {\\n    int dfs(int i, int k, int n, vector<vector<int>> &events, vector<vector<int>> &dp) {\\n        if(i == n || !k) return 0;\\n        if(dp[i][k] != -1) return dp[i][k];\\n\\n        int notpick = dfs(i + 1, k, n, events, dp);\\n        \\n        vector<int> t = {events[i][1], (int)1e9, (int)1e9};\\n        int pos = upper_bound(events.begin() + i + 1, events.end(), t) - events.begin();\\n        int pick = events[i][2] + dfs(pos, k - 1, n, events, dp);\\n\\n        return dp[i][k] = max(pick, notpick);\\n    }\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        \\n        vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n        return dfs(0, k, n, events, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    int dfs(int i, int k, int n, vector<vector<int>> &events, vector<vector<int>> &dp) {\\n        if(i == n || !k) return 0;\\n        if(dp[i][k] != -1) return dp[i][k];\\n\\n        int notpick = dfs(i + 1, k, n, events, dp);\\n        \\n        vector<int> t = {events[i][1], (int)1e9, (int)1e9};\\n        int pos = upper_bound(events.begin() + i + 1, events.end(), t) - events.begin();\\n        int pick = events[i][2] + dfs(pos, k - 1, n, events, dp);\\n\\n        return dp[i][k] = max(pick, notpick);\\n    }\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        \\n        vector<vector<int>> dp(n, vector<int>(k + 1, -1));\\n        return dfs(0, k, n, events, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768368,
                "title": "easiest-c-solution-take-not-take-recursion-memorisation",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst sort the events according to starting time then you have two choices for each events you can either take it or don\\'t. make sure at each step when you take a event, its starting time must be greater than the ending time of previous event you have taken. for that i have used an end variable which keep tracks of which event have been previously attended. that\\'s it..just add the value of each event at every step and the problem is done.\\n\\n\\nupdate: You don\\'t need the comparator function to sort the events by start time. sort function will by default sort the events by the start time.\\n# Complexity\\n- Time complexity:  O(N*k)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- Space complexity: O(N*k)+O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//comparator function to sort the events according to start time.\\nstatic bool comp(vector<int>& a,vector<int>& b){\\n    return a[0]<b[0]; \\n}\\n\\n//helper function.\\nint solve(int i,int end,vector<vector<int>>& events, int k,vector<vector<int>>& dp){\\n\\nif(i==events.size()||k==0){\\n    return 0;\\n}\\n\\nif(dp[end+1][k]!=-1){\\n    return dp[end+1][k];\\n}\\n\\nint take=0,ntake=0;\\n\\nif(end==-1||events[i][0]>events[end][1]){\\n take=events[i][2]+solve(i+1,i,events,k-1,dp);\\n}\\n\\n ntake=solve(i+1,end,events,k,dp);\\n\\nreturn dp[end+1][k]=max(take,ntake);\\n\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n\\n        sort(events.begin(),events.end(),comp);\\n\\n        vector<vector<int>> dp(events.size()+1,vector<int>(k+1,-1));\\n\\n        return solve(0,-1,events,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//comparator function to sort the events according to start time.\\nstatic bool comp(vector<int>& a,vector<int>& b){\\n    return a[0]<b[0]; \\n}\\n\\n//helper function.\\nint solve(int i,int end,vector<vector<int>>& events, int k,vector<vector<int>>& dp){\\n\\nif(i==events.size()||k==0){\\n    return 0;\\n}\\n\\nif(dp[end+1][k]!=-1){\\n    return dp[end+1][k];\\n}\\n\\nint take=0,ntake=0;\\n\\nif(end==-1||events[i][0]>events[end][1]){\\n take=events[i][2]+solve(i+1,i,events,k-1,dp);\\n}\\n\\n ntake=solve(i+1,end,events,k,dp);\\n\\nreturn dp[end+1][k]=max(take,ntake);\\n\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n\\n        sort(events.begin(),events.end(),comp);\\n\\n        vector<vector<int>> dp(events.size()+1,vector<int>(k+1,-1));\\n\\n        return solve(0,-1,events,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768347,
                "title": "kotlin-dynamic-approach-o-n-k",
                "content": "# Intuition\\nWe could use dynamic programming approach, where is the new state with $$m$$ events is maximum of best previous score visiting $$m - 1$$ events which ended before current event started + $$value$$ of current event, previous state visiting $$m$$ events and current state. \\n\\nIt\\'s important to properly order events, one of possible solutions is sorting them by event\\'s end. \\n\\nAlso we need to find optimal solution to find index of last event ended before current one started. We could use binary search, but it would add $$O(log N)$$ complexity, so it\\'s important to find constant time algorithm. It could be achieved by using two pointers approach. \\nAt first - create sorted list of events start time. Then - create sorted list of events end time. For simplicity we remove duplicates in each list. After that just apply two pointers approach starting from right side of list. For simplicity we could also add artificial 0 element to events add time.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- $$O(N * k)$$ + $$O(N * log(N))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- $$O(N * k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    fun maxValue(events: Array<IntArray>, k: Int): Int {\\n        val starts = events.map { it[0] }.distinct().sorted()\\n        val ends = listOf(0) + events.map { it[1] }.distinct().sorted()\\n        val endsIdx = ends.mapIndexed { i, v -> v to i }.toMap()\\n        val prev = mutableMapOf<Int, Int>()\\n\\n        var j = ends.lastIndex\\n        for (i in starts.indices.reversed()) {\\n            while (starts[i] <= ends[j]) j--\\n\\n            prev[starts[i]] = j\\n        }\\n\\n        val dp = Array(ends.size + 1) { IntArray(k + 1) }\\n\\n        for ((start, end, value) in events.sortedBy { it[1] }) {\\n            val p = prev[start]!!\\n            val i = endsIdx[end]!!\\n\\n            for (j in k downTo 1) {\\n                dp[i][j] = maxOf(dp[i][j], dp[i - 1][j], dp[p][j - 1] + value)\\n            }\\n        }\\n\\n        return dp.map { it.max()!! }.max()!!\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    fun maxValue(events: Array<IntArray>, k: Int): Int {\\n        val starts = events.map { it[0] }.distinct().sorted()\\n        val ends = listOf(0) + events.map { it[1] }.distinct().sorted()\\n        val endsIdx = ends.mapIndexed { i, v -> v to i }.toMap()\\n        val prev = mutableMapOf<Int, Int>()\\n\\n        var j = ends.lastIndex\\n        for (i in starts.indices.reversed()) {\\n            while (starts[i] <= ends[j]) j--\\n\\n            prev[starts[i]] = j\\n        }\\n\\n        val dp = Array(ends.size + 1) { IntArray(k + 1) }\\n\\n        for ((start, end, value) in events.sortedBy { it[1] }) {\\n            val p = prev[start]!!\\n            val i = endsIdx[end]!!\\n\\n            for (j in k downTo 1) {\\n                dp[i][j] = maxOf(dp[i][j], dp[i - 1][j], dp[p][j - 1] + value)\\n            }\\n        }\\n\\n        return dp.map { it.max()!! }.max()!!\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768085,
                "title": "maximum-number-of-events-that-can-be-attended-ii-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int calc(vector<vector<int>>& events,int start,int k,int end,vector<vector<int>> &dp)\\n    {\\n        if(start==events.size()) return 0;\\n\\n        if(k==0) return 0;\\n\\n        if(events[start][0]<=end)\\n        {\\n            return calc(events,start+1,k,end,dp);\\n        }\\n        if(dp[start][k]!=-1)\\n        {\\n            return dp[start][k];\\n        }\\n        int choice=max(events[start][2]+calc(events,start+1,k-1,events[start][1],dp),calc(events,start+1,k,end,dp));\\n        return dp[start][k]=choice;\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        int n=events.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return calc(events,0,k,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int calc(vector<vector<int>>& events,int start,int k,int end,vector<vector<int>> &dp)\\n    {\\n        if(start==events.size()) return 0;\\n\\n        if(k==0) return 0;\\n\\n        if(events[start][0]<=end)\\n        {\\n            return calc(events,start+1,k,end,dp);\\n        }\\n        if(dp[start][k]!=-1)\\n        {\\n            return dp[start][k];\\n        }\\n        int choice=max(events[start][2]+calc(events,start+1,k-1,events[start][1],dp),calc(events,start+1,k,end,dp));\\n        return dp[start][k]=choice;\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        int n=events.size();\\n        vector<vector<int>> dp(n,vector<int>(k+1,-1));\\n        return calc(events,0,k,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3768077,
                "title": "journey-from-backtracking-tle-memoization-mle-dp-mle-dp-tle-memoization-accepted",
                "content": "# Intuition: Backtracking (TLE at 65th Test Case)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[1], b[1]));\\n        return backtrack(0, -1, 0, events, k);\\n    }\\n\\n    public int backtrack(int idx, int prevIdx, int currNoEvents, int[][] events, int k){\\n        if(currNoEvents >= k || idx == events.length){\\n            return 0;\\n        }\\n\\n        // don\\'t take this value\\n        int currValue = 0 + backtrack(idx + 1, prevIdx, currNoEvents, events, k);\\n        if(prevIdx == -1 || events[prevIdx][1] < events[idx][0]){\\n            currValue = Math.max(currValue, events[idx][2] + backtrack(idx + 1, idx, currNoEvents + 1, events, k));\\n        }\\n\\n        return currValue;\\n    }\\n}\\n```\\n---\\n# Intuition: Backtracking + Memoization (MLE at 58th Test Case)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        int[][][] MEMO = new int[n][n + 1][k];\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[1], b[1]));\\n        return backtrack(0, -1, 0, events, k, MEMO);\\n    }\\n\\n    public int backtrack(int idx, int prevIdx, int currNoEvents, int[][] events, int k, int[][][] MEMO){\\n        if(currNoEvents >= k || idx == events.length){\\n            return 0;\\n        }\\n\\n        if(MEMO[idx][prevIdx + 1][currNoEvents] != 0){\\n            return MEMO[idx][prevIdx + 1][currNoEvents];\\n        }\\n\\n        int currValue = 0 + backtrack(idx + 1, prevIdx, currNoEvents, events, k, MEMO);\\n        if(prevIdx == -1 || events[prevIdx][1] < events[idx][0]){\\n            currValue = Math.max(currValue, events[idx][2] + backtrack(idx + 1, idx, currNoEvents + 1, events, k, MEMO));\\n        }\\n\\n        return MEMO[idx][prevIdx + 1][currNoEvents] = currValue;\\n    }\\n}\\n```\\n\\n---\\n# Intuition: Bottom Up Approach (MLE at 58th Test Case)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        int[][][] MEMO = new int[n + 1][n + 1][k + 1];\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        for(int idx = n - 1; idx >= 0; idx--){\\n            for(int prevIdx = idx - 1; prevIdx >= -1; prevIdx--){\\n                for(int currK = k - 1; currK >= 0; currK--){\\n                    int currValue = 0 + MEMO[idx + 1][prevIdx + 1][currK];\\n                    if(prevIdx == -1 || events[prevIdx][1] < events[idx][0]){\\n                        currValue = Math.max(currValue, events[idx][2] + MEMO[idx + 1][idx + 1][currK + 1]);\\n                    }\\n\\n                    MEMO[idx][prevIdx + 1][currK] = currValue;\\n                }\\n            }\\n        }\\n        return MEMO[0][-1 + 1][0];\\n    }\\n}\\n```\\n---\\n\\n# Intuition: Bottom Up Approach (TLE at 58th Test Case)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        int[][] current = new int[n + 1][k + 1];\\n        int[][] next = new int[n + 1][k + 1];\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        for(int idx = n - 1; idx >= 0; idx--){\\n            for(int prevIdx = idx - 1; prevIdx >= -1; prevIdx--){\\n                for(int currK = k - 1; currK >= 0; currK--){\\n                    int currValue = 0 + next[prevIdx + 1][currK];\\n                    // take this value if it satisfies the condition\\n                    if(prevIdx == -1 || events[prevIdx][1] < events[idx][0]){\\n                        currValue = Math.max(currValue, events[idx][2] + next[idx + 1][currK + 1]);\\n                    }\\n\\n                    current[prevIdx + 1][currK] = currValue;\\n                }\\n            }\\n            next = current;\\n        }\\n        return next[-1 + 1][0];\\n    }\\n}\\n```\\n\\n# Intuition: Backtracking + Memoization (ACCEPTED - Space Optimized)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        int[][] MEMO = new int[n + 1][k];\\n        Arrays.sort(events, (a, b) -> {\\n            if(a[0] == b[0]){\\n                return a[1] - b[1];\\n            } else {\\n                return a[0] - b[0];\\n            }\\n        });\\n        return backtrack(0, -1, 0, events, k, MEMO);\\n    }\\n\\n    public int backtrack(int idx, int prevIdx, int currK, int[][] events, int k, int[][] MEMO){\\n        if(currK >= k || idx == events.length){\\n            return 0;\\n        }\\n\\n        if(MEMO[prevIdx + 1][currK] != 0){\\n            return MEMO[prevIdx + 1][currK];\\n        }\\n\\n        // don\\'t take this value\\n        int currValue = 0 + backtrack(idx + 1, prevIdx, currK, events, k, MEMO);\\n        if(prevIdx == -1 || events[prevIdx][1] < events[idx][0]){\\n            currValue = Math.max(currValue, events[idx][2] + backtrack(idx + 1, idx, currK + 1, events, k, MEMO));\\n        }\\n\\n        return MEMO[prevIdx + 1][currK] = currValue;\\n    }\\n}\\n```\\n\\n# Test Cases:\\n- 57th: [Link](https://drive.google.com/file/d/1VA5PenCBopesmcxRLD74_uNM192CJwUI/view?usp=sharing)\\n- 58th: [Link](https://drive.google.com/file/d/1902b_nBCcfu0nho2z86WfqoOz_u78X_9/view?usp=sharing)\\n- 65th: [Link](https://drive.google.com/file/d/1XAPHAmUPMGsTyWyZUtEKOHiEU8pDlyXd/view?usp=sharing)\\n\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Dynamic Programming",
                    "Backtracking",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[1], b[1]));\\n        return backtrack(0, -1, 0, events, k);\\n    }\\n\\n    public int backtrack(int idx, int prevIdx, int currNoEvents, int[][] events, int k){\\n        if(currNoEvents >= k || idx == events.length){\\n            return 0;\\n        }\\n\\n        // don\\'t take this value\\n        int currValue = 0 + backtrack(idx + 1, prevIdx, currNoEvents, events, k);\\n        if(prevIdx == -1 || events[prevIdx][1] < events[idx][0]){\\n            currValue = Math.max(currValue, events[idx][2] + backtrack(idx + 1, idx, currNoEvents + 1, events, k));\\n        }\\n\\n        return currValue;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        int[][][] MEMO = new int[n][n + 1][k];\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[1], b[1]));\\n        return backtrack(0, -1, 0, events, k, MEMO);\\n    }\\n\\n    public int backtrack(int idx, int prevIdx, int currNoEvents, int[][] events, int k, int[][][] MEMO){\\n        if(currNoEvents >= k || idx == events.length){\\n            return 0;\\n        }\\n\\n        if(MEMO[idx][prevIdx + 1][currNoEvents] != 0){\\n            return MEMO[idx][prevIdx + 1][currNoEvents];\\n        }\\n\\n        int currValue = 0 + backtrack(idx + 1, prevIdx, currNoEvents, events, k, MEMO);\\n        if(prevIdx == -1 || events[prevIdx][1] < events[idx][0]){\\n            currValue = Math.max(currValue, events[idx][2] + backtrack(idx + 1, idx, currNoEvents + 1, events, k, MEMO));\\n        }\\n\\n        return MEMO[idx][prevIdx + 1][currNoEvents] = currValue;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        int[][][] MEMO = new int[n + 1][n + 1][k + 1];\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        for(int idx = n - 1; idx >= 0; idx--){\\n            for(int prevIdx = idx - 1; prevIdx >= -1; prevIdx--){\\n                for(int currK = k - 1; currK >= 0; currK--){\\n                    int currValue = 0 + MEMO[idx + 1][prevIdx + 1][currK];\\n                    if(prevIdx == -1 || events[prevIdx][1] < events[idx][0]){\\n                        currValue = Math.max(currValue, events[idx][2] + MEMO[idx + 1][idx + 1][currK + 1]);\\n                    }\\n\\n                    MEMO[idx][prevIdx + 1][currK] = currValue;\\n                }\\n            }\\n        }\\n        return MEMO[0][-1 + 1][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        int[][] current = new int[n + 1][k + 1];\\n        int[][] next = new int[n + 1][k + 1];\\n        Arrays.sort(events, (a, b) -> Integer.compare(a[1], b[1]));\\n\\n        for(int idx = n - 1; idx >= 0; idx--){\\n            for(int prevIdx = idx - 1; prevIdx >= -1; prevIdx--){\\n                for(int currK = k - 1; currK >= 0; currK--){\\n                    int currValue = 0 + next[prevIdx + 1][currK];\\n                    // take this value if it satisfies the condition\\n                    if(prevIdx == -1 || events[prevIdx][1] < events[idx][0]){\\n                        currValue = Math.max(currValue, events[idx][2] + next[idx + 1][currK + 1]);\\n                    }\\n\\n                    current[prevIdx + 1][currK] = currValue;\\n                }\\n            }\\n            next = current;\\n        }\\n        return next[-1 + 1][0];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        int[][] MEMO = new int[n + 1][k];\\n        Arrays.sort(events, (a, b) -> {\\n            if(a[0] == b[0]){\\n                return a[1] - b[1];\\n            } else {\\n                return a[0] - b[0];\\n            }\\n        });\\n        return backtrack(0, -1, 0, events, k, MEMO);\\n    }\\n\\n    public int backtrack(int idx, int prevIdx, int currK, int[][] events, int k, int[][] MEMO){\\n        if(currK >= k || idx == events.length){\\n            return 0;\\n        }\\n\\n        if(MEMO[prevIdx + 1][currK] != 0){\\n            return MEMO[prevIdx + 1][currK];\\n        }\\n\\n        // don\\'t take this value\\n        int currValue = 0 + backtrack(idx + 1, prevIdx, currK, events, k, MEMO);\\n        if(prevIdx == -1 || events[prevIdx][1] < events[idx][0]){\\n            currValue = Math.max(currValue, events[idx][2] + backtrack(idx + 1, idx, currK + 1, events, k, MEMO));\\n        }\\n\\n        return MEMO[prevIdx + 1][currK] = currValue;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767950,
                "title": "dp-binary-search-90-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDynamic Programming and Binary Search Approach\\nUse DP to memorize maximum value of events at a specific index\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1) sort the events by their start time\\n2) Prepare a dp array to memorize \\n3) This is simple approach in which we either take current event or skip\\n4) If we pick current event then find the next event that we can attain using binary search\\nIn binary search check if the current event has start time less than end time of event that we have picked and return the index of it\\n5) Now pass that next index to recursive function to check for further events\\n6) If in any iteration if we encounter the index that we havre previously calculated value for return it immediately\\n7) Also handle bases cases in which if i is greather than equal to vector size or k becomes zero\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\n    int next(vector<vector<int>>&v,int currEve,int e){\\n        int m,i = currEve+1,j = v.size()-1;\\n        if(i==j && v[j][0]==e)return j+1;\\n        while(i<=j){\\n            m = i+(j-i)/2;\\n            if(v[m][0]<=e){\\n                i = m+1;\\n            }else{\\n                j = m-1;\\n            }\\n        }\\n        return i;\\n    }\\n\\n    int solve(vector<vector<int>>&v,int k,int i,vector<vector<int>>&dp){\\n        if(k==0 || i>=v.size()){\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1){\\n            return dp[i][k];\\n        }\\n        int nextEvent = next(v,i,v[i][1]);\\n        int take = solve(v,k-1,nextEvent,dp)+v[i][2];\\n        int skip = solve(v,k,i+1,dp);\\n        return dp[i][k]=max(take,skip);\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        sort(events.begin(),events.end());\\n        return solve(events,k,0,dp);\\n    }\\n};\\n```\\n\\n# Note\\nPlease upvote if you undestand my approach \\uD83D\\uDE01",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int next(vector<vector<int>>&v,int currEve,int e){\\n        int m,i = currEve+1,j = v.size()-1;\\n        if(i==j && v[j][0]==e)return j+1;\\n        while(i<=j){\\n            m = i+(j-i)/2;\\n            if(v[m][0]<=e){\\n                i = m+1;\\n            }else{\\n                j = m-1;\\n            }\\n        }\\n        return i;\\n    }\\n\\n    int solve(vector<vector<int>>&v,int k,int i,vector<vector<int>>&dp){\\n        if(k==0 || i>=v.size()){\\n            return 0;\\n        }\\n        if(dp[i][k]!=-1){\\n            return dp[i][k];\\n        }\\n        int nextEvent = next(v,i,v[i][1]);\\n        int take = solve(v,k-1,nextEvent,dp)+v[i][2];\\n        int skip = solve(v,k,i+1,dp);\\n        return dp[i][k]=max(take,skip);\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        sort(events.begin(),events.end());\\n        return solve(events,k,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767726,
                "title": "simple-take-skip-recursion-easiest-explanation-codestorywithmik",
                "content": "YouTube Video Link - [Maximum Number of Events That Can Be Attended II](https://www.youtube.com/watch?v=9ykgLt25X9c)\\nMy Github Treasure - [Maximum Number of Events That Can Be Attended II](https://github.com/MAZHARMIK/Interview_DS_Algo/blob/master/Arrays/Intervals_Based_Qn/Maximum%20Number%20of%20Events%20That%20Can%20Be%20Attended%20II.cpp)\\n\\n```\\n//Approach-1 (Using Recursion + Memo) using Linear Search for next event - T.C. - O(n\\u22C5k\\u22C5n)\\n/*\\n  We visit at most n*k states (size of memoization array) - O(n*k)\\n  At every state, we do a linear search - which takes O(n) time\\n*/\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> t;\\n    int solve(vector<vector<int>>& events, int i, int k) {\\n        \\n        if(k <= 0 || i >= n)\\n            return 0;\\n        \\n        int start = events[i][0];\\n        int end   = events[i][1];\\n        int value = events[i][2];\\n        \\n        if(t[i][k] != -1)\\n            return t[i][k];\\n        \\n        // finding the next event which we can attend\\n        int j = i+1;\\n        for(; j < n; j++) {\\n            if(events[j][0] > events[i][1])\\n                break;\\n        }\\n        \\n        int take = value + solve(events, j, k-1);\\n        int skip = solve(events, i+1, k);\\n        \\n        return t[i][k] = max(take, skip);\\n        \\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(begin(events), end(events));\\n        \\n        n = events.size();\\n        \\n        t.resize(n+1, vector<int>(k+1, -1));\\n        \\n        return solve(events, 0, k);\\n    }\\n};\\n```\\n\\n```\\n//Approach-2 (Using Recursion + Memo) using Binary Search for next event - T.C. - O(n\\u22C5k\\u22C5log(n))\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> t;\\n    int solve(vector<vector<int>>& events, int i, int k) {\\n        \\n        if(k <= 0 || i >= n)\\n            return 0;\\n        \\n        int start = events[i][0];\\n        int endt   = events[i][1];\\n        int value = events[i][2];\\n        \\n        if(t[i][k] != -1)\\n            return t[i][k];\\n        \\n        // finding the next event which we can attend\\n        vector<int> temp = {endt, INT_MAX, INT_MAX};\\n        int j = upper_bound(events.begin(), events.end(), temp) - events.begin();\\n        \\n        int take = value + solve(events, j, k-1);\\n        int skip = solve(events, i+1, k);\\n        \\n        return t[i][k] = max(take, skip);\\n        \\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(begin(events), end(events));\\n        \\n        n = events.size();\\n        \\n        t.resize(n+1, vector<int>(k+1, -1));\\n        \\n        return solve(events, 0, k);\\n    }\\n};\\n```\\n\\n\\n```\\n//Approach-3 (Without doing any linear or binary search) - Simply keep track of last taken event\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> t;\\n    int solve(vector<vector<int>>& events, int i, int prev, int k) {\\n        \\n        if(k == 0 || i == n)\\n            return 0;\\n        \\n        if(t[prev+1][k] != -1) //prev+1 because intially prev is = -1\\n            return t[prev+1][k];\\n        \\n        int start = events[i][0];\\n        int endt   = events[i][1];\\n        int value = events[i][2];\\n        \\n        \\n        int take = 0, skip = 0;\\n        if(prev == -1 || events[prev][1] < events[i][0]) {\\n            take = value + solve(events, i+1, i, k-1);\\n        }   \\n        \\n        skip = solve(events, i+1, prev, k);\\n        \\n        return t[prev+1][k] = max(take, skip);\\n        \\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        \\n        auto lambda = [&](auto &a, auto &b) {\\n            if(a[1]==b[1])  \\n                return a[0]-b[0];\\n            \\n            return a[1]-b[1];\\n        };\\n        \\n        sort(begin(events), end(events));\\n        \\n        n = events.size();\\n        \\n        t.resize(n+1, vector<int>(k+1, -1));\\n        \\n        return solve(events, 0, -1, k);\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n//Approach-1 (Using Recursion + Memo) using Linear Search for next event - T.C. - O(n\\u22C5k\\u22C5n)\\n/*\\n  We visit at most n*k states (size of memoization array) - O(n*k)\\n  At every state, we do a linear search - which takes O(n) time\\n*/\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> t;\\n    int solve(vector<vector<int>>& events, int i, int k) {\\n        \\n        if(k <= 0 || i >= n)\\n            return 0;\\n        \\n        int start = events[i][0];\\n        int end   = events[i][1];\\n        int value = events[i][2];\\n        \\n        if(t[i][k] != -1)\\n            return t[i][k];\\n        \\n        // finding the next event which we can attend\\n        int j = i+1;\\n        for(; j < n; j++) {\\n            if(events[j][0] > events[i][1])\\n                break;\\n        }\\n        \\n        int take = value + solve(events, j, k-1);\\n        int skip = solve(events, i+1, k);\\n        \\n        return t[i][k] = max(take, skip);\\n        \\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(begin(events), end(events));\\n        \\n        n = events.size();\\n        \\n        t.resize(n+1, vector<int>(k+1, -1));\\n        \\n        return solve(events, 0, k);\\n    }\\n};\\n```\n```\\n//Approach-2 (Using Recursion + Memo) using Binary Search for next event - T.C. - O(n\\u22C5k\\u22C5log(n))\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> t;\\n    int solve(vector<vector<int>>& events, int i, int k) {\\n        \\n        if(k <= 0 || i >= n)\\n            return 0;\\n        \\n        int start = events[i][0];\\n        int endt   = events[i][1];\\n        int value = events[i][2];\\n        \\n        if(t[i][k] != -1)\\n            return t[i][k];\\n        \\n        // finding the next event which we can attend\\n        vector<int> temp = {endt, INT_MAX, INT_MAX};\\n        int j = upper_bound(events.begin(), events.end(), temp) - events.begin();\\n        \\n        int take = value + solve(events, j, k-1);\\n        int skip = solve(events, i+1, k);\\n        \\n        return t[i][k] = max(take, skip);\\n        \\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(begin(events), end(events));\\n        \\n        n = events.size();\\n        \\n        t.resize(n+1, vector<int>(k+1, -1));\\n        \\n        return solve(events, 0, k);\\n    }\\n};\\n```\n```\\n//Approach-3 (Without doing any linear or binary search) - Simply keep track of last taken event\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>> t;\\n    int solve(vector<vector<int>>& events, int i, int prev, int k) {\\n        \\n        if(k == 0 || i == n)\\n            return 0;\\n        \\n        if(t[prev+1][k] != -1) //prev+1 because intially prev is = -1\\n            return t[prev+1][k];\\n        \\n        int start = events[i][0];\\n        int endt   = events[i][1];\\n        int value = events[i][2];\\n        \\n        \\n        int take = 0, skip = 0;\\n        if(prev == -1 || events[prev][1] < events[i][0]) {\\n            take = value + solve(events, i+1, i, k-1);\\n        }   \\n        \\n        skip = solve(events, i+1, prev, k);\\n        \\n        return t[prev+1][k] = max(take, skip);\\n        \\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        \\n        auto lambda = [&](auto &a, auto &b) {\\n            if(a[1]==b[1])  \\n                return a[0]-b[0];\\n            \\n            return a[1]-b[1];\\n        };\\n        \\n        sort(begin(events), end(events));\\n        \\n        n = events.size();\\n        \\n        t.resize(n+1, vector<int>(k+1, -1));\\n        \\n        return solve(events, 0, -1, k);\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767662,
                "title": "simple-beginner-friendly-c-solution-with-intuition-and-explanation",
                "content": "# Intuition\\nThe problem aims to find the maximum value that can be obtained by attending events, considering a limit on the number of events that can be attended. So we use dynamic programming and memoization to efficiently explore different event combinations. By recursively considering attending or skipping events, and storing computed results in a memoization array, we determine the maximum value that can be achieved.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nSteps to follow:\\n- At first, we sort events based on start time.\\n- Then in the helper function, we handle the base case when all events have been considered.\\n- We also use memoization to avoid redundant computations.\\n- We recursively consider attending the current event or skipping it.\\n- And update the memoization array with the maximum value obtained.\\n- Initialize the memoization array and call the helper function in the maxValue function to obtain the maximum value.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n*k*logn), where n is the number of events and k is the maximum number of events that can be attended.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n*k) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nUPVOTE. Glad to help.\\n# Code\\n```\\nclass Solution {\\n    int helper(vector<vector<int>>& events, int k,int i, \\n    vector<vector<int>>& dp){\\n        if(i>=events.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int ans = helper(events,k,i+1,dp);\\n        if(k){\\n            vector<int> temp={events[i][1],INT_MAX,INT_MAX};\\n            int next=upper_bound(events.begin(),events.end(),temp)\\n            -events.begin();\\n            ans=max(ans,events[i][2]+helper(events,k-1,next,dp));\\n        }\\n        return dp[i][k]=ans;\\n    }\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        vector<vector<int>> dp(events.size(),vector<int>(k+1,-1));\\n        return helper(events,k,0,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n    int helper(vector<vector<int>>& events, int k,int i, \\n    vector<vector<int>>& dp){\\n        if(i>=events.size()) return 0;\\n        if(dp[i][k]!=-1) return dp[i][k];\\n        int ans = helper(events,k,i+1,dp);\\n        if(k){\\n            vector<int> temp={events[i][1],INT_MAX,INT_MAX};\\n            int next=upper_bound(events.begin(),events.end(),temp)\\n            -events.begin();\\n            ans=max(ans,events[i][2]+helper(events,k-1,next,dp));\\n        }\\n        return dp[i][k]=ans;\\n    }\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        vector<vector<int>> dp(events.size(),vector<int>(k+1,-1));\\n        return helper(events,k,0,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767640,
                "title": "brute-force-and-memoized-solutions",
                "content": "# Simple Brute Force Solution 1 but got a TLE\\n```\\nclass Solution {\\npublic:\\n\\n    int solve(int index, vector<vector<int>>& events, int prevEnd, int k, int ans)\\n    {\\n        if(index >= events.size() || k<=0)\\n        return ans;\\n\\n        int notTake=0, take = 0;\\n\\n        notTake = solve(index+1, events, prevEnd, k, ans);\\n\\n\\n        if(prevEnd < events[index][0])\\n        take = solve(index+1, events, events[index][1], --k, ans + events[index][2]);\\n\\n        ans =  max(notTake, take);\\n        \\n        return ans;\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n    \\n    sort(events.begin(), events.end());\\n    int ans = 0;\\n    ans = solve(0, events, 0, k, 0);\\n    return ans;    \\n    }\\n};\\n```\\n\\n# Optimized brute Force Solution 2 but, again got a TLE\\n```\\nclass Solution {\\npublic:\\n\\n   int solve(vector<vector<int>>& events, int n, int pos, int k)\\n{\\n        int i;\\n        \\n        if(pos >= n || k == 0)\\n            return 0;\\n        \\n        // finding the next event which we can attend\\n        for(i = pos + 1; i < n; i++)\\n            if(events[i][0] > events[pos][1])\\n                break;\\n        \\n       return max(solve(events, n, pos+1, k), events[pos][2] + solve(events, n, i, k-1));\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) \\n    {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n\\n        return solve(events, n, 0, k);\\n    }\\n};\\n```\\n\\n# Memoized Solution which passed successfully\\n```\\nclass Solution {\\npublic:\\n\\n   int solve(vector<vector<int>>& dp, vector<vector<int>>& events, int n, int pos, int k)\\n{\\n        int i;\\n        \\n        if(pos >= n || k == 0)\\n            return 0;\\n\\n            if(dp[pos][k] != -1)\\n            return dp[pos][k];\\n        \\n        // finding the next event which we can attend\\n        for(i = pos + 1; i < n; i++)\\n            if(events[i][0] > events[pos][1])\\n                break;\\n        \\n       return dp[pos][k] = max(solve(dp, events, n, pos+1, k), events[pos][2] + solve(dp, events, n, i, k-1));\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) \\n    {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n\\n        vector<vector<int>> dp(n+1,vector<int> (k+1, -1));\\n\\n        return solve(dp, events, n, 0, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int solve(int index, vector<vector<int>>& events, int prevEnd, int k, int ans)\\n    {\\n        if(index >= events.size() || k<=0)\\n        return ans;\\n\\n        int notTake=0, take = 0;\\n\\n        notTake = solve(index+1, events, prevEnd, k, ans);\\n\\n\\n        if(prevEnd < events[index][0])\\n        take = solve(index+1, events, events[index][1], --k, ans + events[index][2]);\\n\\n        ans =  max(notTake, take);\\n        \\n        return ans;\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n    \\n    sort(events.begin(), events.end());\\n    int ans = 0;\\n    ans = solve(0, events, 0, k, 0);\\n    return ans;    \\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n   int solve(vector<vector<int>>& events, int n, int pos, int k)\\n{\\n        int i;\\n        \\n        if(pos >= n || k == 0)\\n            return 0;\\n        \\n        // finding the next event which we can attend\\n        for(i = pos + 1; i < n; i++)\\n            if(events[i][0] > events[pos][1])\\n                break;\\n        \\n       return max(solve(events, n, pos+1, k), events[pos][2] + solve(events, n, i, k-1));\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) \\n    {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n\\n        return solve(events, n, 0, k);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n\\n   int solve(vector<vector<int>>& dp, vector<vector<int>>& events, int n, int pos, int k)\\n{\\n        int i;\\n        \\n        if(pos >= n || k == 0)\\n            return 0;\\n\\n            if(dp[pos][k] != -1)\\n            return dp[pos][k];\\n        \\n        // finding the next event which we can attend\\n        for(i = pos + 1; i < n; i++)\\n            if(events[i][0] > events[pos][1])\\n                break;\\n        \\n       return dp[pos][k] = max(solve(dp, events, n, pos+1, k), events[pos][2] + solve(dp, events, n, i, k-1));\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) \\n    {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n\\n        vector<vector<int>> dp(n+1,vector<int> (k+1, -1));\\n\\n        return solve(dp, events, n, 0, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767320,
                "title": "c-easy-to-understand-o-n-log-n-o-n-k-recursion-memoization-hard-problem",
                "content": "# C++ | Easy to Understand | O(n log n) | O (N * K) | Recursion | Memoization | Hard Problem | 1751. Maximum Number of Events That Can Be Attended II\\n```\\nclass Solution {\\npublic:\\n  int func(vector<vector<int>>& events, int k, int idx, vector<vector<int>>& memo) {\\n    if(idx == events.size() || k == 0){\\n      return 0;\\n    }\\n    if(memo[idx][k] != -1)\\n      return memo[idx][k];\\n    vector<int> tmp = {events[idx][1], INT_MAX, INT_MAX};\\n    int i = upper_bound(events.begin() + idx + 1, events.end(), tmp) - events.begin();\\n    return memo[idx][k] = max(func(events, k - 1, i, memo) + events[idx][2], func(events, k, idx + 1, memo));\\n  }\\n  int maxValue(vector<vector<int>>& events, int k) {\\n    sort(events.begin(), events.end());\\n    int n = events.size();\\n    vector<vector<int>> memo(n + 1, vector<int>(k + 1, -1));\\n    int ans = func(events, k, 0, memo);\\n    return ans;      \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int func(vector<vector<int>>& events, int k, int idx, vector<vector<int>>& memo) {\\n    if(idx == events.size() || k == 0){\\n      return 0;\\n    }\\n    if(memo[idx][k] != -1)\\n      return memo[idx][k];\\n    vector<int> tmp = {events[idx][1], INT_MAX, INT_MAX};\\n    int i = upper_bound(events.begin() + idx + 1, events.end(), tmp) - events.begin();\\n    return memo[idx][k] = max(func(events, k - 1, i, memo) + events[idx][2], func(events, k, idx + 1, memo));\\n  }\\n  int maxValue(vector<vector<int>>& events, int k) {\\n    sort(events.begin(), events.end());\\n    int n = events.size();\\n    vector<vector<int>> memo(n + 1, vector<int>(k + 1, -1));\\n    int ans = func(events, k, 0, memo);\\n    return ans;      \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767293,
                "title": "c-explained-with-comments-dp-binary-search-sorting",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<vector<int>> dp;\\n    int maxValue(vector<vector<int>>& ev, int k) {\\n      sort(ev.begin(),ev.end());\\n      dp.resize(ev.size(),vector<int>(k+1,-1)); \\n      return f(ev,k,0); \\n    }\\nint f(vector<vector<int>>& ev, int k,int ind){\\n    //base cases\\n   if(ind>=ev.size() || k<=0){\\n       return 0;\\n   }\\n   if(dp[ind][k]!=-1){\\n       return dp[ind][k];\\n   }\\n   //using binary search to find next possible index we can take.\\n   //next index should have starting time more than ending time for current index.\\n   int st=ind+1;\\n   int en=ev.size()-1;\\n   int index=en+1;\\n   while(st<=en){\\n    int mid=st+(en-st)/2;\\n       if(ev[mid][0]>ev[ind][1]){\\n           index=mid;\\n           en=mid-1;\\n       }\\n       else{\\n          st=mid+1;\\n       }\\n   }\\n   //two possible conditions\\n   //if we skip current index and search for anse=wer in next indices \\n   //OR we take that element and land on next index such that its starting time is greater than previous ones ending time.\\n   int t=0;\\n   int nt=0;\\n   t=ev[ind][2]+f(ev,k-1,index);\\n   nt=f(ev,k,ind+1);\\n  //finally returned maximum of both cases\\n   return dp[ind][k]=max(t,nt);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<vector<int>> dp;\\n    int maxValue(vector<vector<int>>& ev, int k) {\\n      sort(ev.begin(),ev.end());\\n      dp.resize(ev.size(),vector<int>(k+1,-1)); \\n      return f(ev,k,0); \\n    }\\nint f(vector<vector<int>>& ev, int k,int ind){\\n    //base cases\\n   if(ind>=ev.size() || k<=0){\\n       return 0;\\n   }\\n   if(dp[ind][k]!=-1){\\n       return dp[ind][k];\\n   }\\n   //using binary search to find next possible index we can take.\\n   //next index should have starting time more than ending time for current index.\\n   int st=ind+1;\\n   int en=ev.size()-1;\\n   int index=en+1;\\n   while(st<=en){\\n    int mid=st+(en-st)/2;\\n       if(ev[mid][0]>ev[ind][1]){\\n           index=mid;\\n           en=mid-1;\\n       }\\n       else{\\n          st=mid+1;\\n       }\\n   }\\n   //two possible conditions\\n   //if we skip current index and search for anse=wer in next indices \\n   //OR we take that element and land on next index such that its starting time is greater than previous ones ending time.\\n   int t=0;\\n   int nt=0;\\n   t=ev[ind][2]+f(ev,k-1,index);\\n   nt=f(ev,k,ind+1);\\n  //finally returned maximum of both cases\\n   return dp[ind][k]=max(t,nt);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767290,
                "title": "easy-clean-code-binary-search-same-as-non-overlapping-intervals-problem",
                "content": "\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAs contraints are upto 10^6 we need some method to find the previous non overlaping event in O(1) or O(log(n)).We will use binary search for it.So our solution runs in 0(nlogn).For each event we have two choices-1->Take it and find previous non overlapping event using binary search.2->Leave it.\\nSimilar Problems-\\n1->[https://leetcode.com/problems/non-overlapping-intervals/description/]()\\n2->[https://cses.fi/problemset/task/1140]()\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n*k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a,vector<int>& b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    int calc(int idx,vector<vector<int>>& a)\\n    {\\n        int l=0;\\n        int r=idx-1;\\n        int req_l=a[idx][0];\\n        int ans=-1;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(a[mid][1]<req_l)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        \\n        }\\n        return ans;\\n    }\\n    int maxValue(vector<vector<int>>& a, int k) {\\n        int n=a.size();\\n        sort(a.begin(),a.end(),cmp);\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        // dp[0][1]=a[0][2];/\\n        for(int i=1;i<=k;i++)\\n        {\\n            dp[0][i]=a[0][2];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            int pre=calc(i,a);\\n            cout<<pre<<endl;\\n            for(int j=1;j<=k;j++)\\n            {\\n                //either attend it or leave it;\\n                //take it and find the pre not intersecting event\\n                int val=0;\\n                if(pre!=-1)\\n                {\\n                    val=dp[pre][j-1];\\n                }\\n                dp[i][j]=max(dp[i][j],val+a[i][2]);\\n\\n                //leave it\\n                dp[i][j]=max(dp[i][j],dp[i-1][j]);\\n            }\\n        }\\n        return dp[n-1][k];\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a,vector<int>& b)\\n    {\\n        return a[1]<b[1];\\n    }\\n    int calc(int idx,vector<vector<int>>& a)\\n    {\\n        int l=0;\\n        int r=idx-1;\\n        int req_l=a[idx][0];\\n        int ans=-1;\\n        while(l<=r)\\n        {\\n            int mid=(l+r)/2;\\n            if(a[mid][1]<req_l)\\n            {\\n                ans=mid;\\n                l=mid+1;\\n            }\\n            else\\n            {\\n                r=mid-1;\\n            }\\n        \\n        }\\n        return ans;\\n    }\\n    int maxValue(vector<vector<int>>& a, int k) {\\n        int n=a.size();\\n        sort(a.begin(),a.end(),cmp);\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        // dp[0][1]=a[0][2];/\\n        for(int i=1;i<=k;i++)\\n        {\\n            dp[0][i]=a[0][2];\\n        }\\n        for(int i=1;i<n;i++)\\n        {\\n            int pre=calc(i,a);\\n            cout<<pre<<endl;\\n            for(int j=1;j<=k;j++)\\n            {\\n                //either attend it or leave it;\\n                //take it and find the pre not intersecting event\\n                int val=0;\\n                if(pre!=-1)\\n                {\\n                    val=dp[pre][j-1];\\n                }\\n                dp[i][j]=max(dp[i][j],val+a[i][2]);\\n\\n                //leave it\\n                dp[i][j]=max(dp[i][j],dp[i-1][j]);\\n            }\\n        }\\n        return dp[n-1][k];\\n\\n\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3767271,
                "title": "c-memoization-knapsack-97",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   int solve(vector<vector<int>>&events,int pos,int n,int k,vector<vector<int>>&dp)\\n   {\\n       if(pos>=n || k==0)return 0;\\n\\n       if(dp[pos][k]!=-1)\\n       return dp[pos][k];\\n\\n       int i;\\n       for(i=pos+1;i<n;i++)\\n       {\\n           if(events[i][0]>events[pos][1])\\n           break;\\n       }\\n\\n       return dp[pos][k]=max(solve(events,pos+1,n,k,dp),events[pos][2]+solve(events,i,n,k-1,dp));\\n   }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        int n=events.size();\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        return solve(events,0,n,k,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   int solve(vector<vector<int>>&events,int pos,int n,int k,vector<vector<int>>&dp)\\n   {\\n       if(pos>=n || k==0)return 0;\\n\\n       if(dp[pos][k]!=-1)\\n       return dp[pos][k];\\n\\n       int i;\\n       for(i=pos+1;i<n;i++)\\n       {\\n           if(events[i][0]>events[pos][1])\\n           break;\\n       }\\n\\n       return dp[pos][k]=max(solve(events,pos+1,n,k,dp),events[pos][2]+solve(events,i,n,k-1,dp));\\n   }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        int n=events.size();\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        return solve(events,0,n,k,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767268,
                "title": "simple-c-solution-3d-dynamic-programing-explained-clean-code-o-n3-time-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSort the Time Series so we get linear time period. then we can chose one option wether to include the time into attended event or not, go recusively until we get out of possible event to attend or we reach to end choose max value path.\\n\\n# Approach\\n1. Sort event list for linear time `sort(begin(e), end(e))`\\n2. During Recusion choose non overlaping event. therefore check previous event end time is smaller than current one. `pre_end < e[i][0]`. if condition gets satisfied then add event value and go for next round while decrementing k `solve(e, k-1, e[i][1], i+1) + e[i][2]`\\n3. check for other option without considering current inclusion into evnet that attended and return max value from both of option  `max(Option1 ,  solve(e, k, pre_end, i+1))`\\n4. To Optimize apply memoization, use currnet index `i`, event count `k`, and previous event end `pre_end` to avoid extra usage of map which caused increase in run time by O(n) to find.  \\n\\n# Complexity\\n- Time complexity: \\n    - $$O(n^3)$$ with recursion + memoization\\n    - $$O(2^n)$$ only recursion\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n^3)$$ -> $$O(n)$$ * $$O(k)$$ * $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    vector<vector<unordered_map<int, int>>> mp;\\n    int solve(vector<vector<int>>& e, int k, int pre_end, int i)  {\\n        if(i >= e.size() || k == 0) return 0;\\n        if(mp[i][k].count(pre_end)) return mp[i][k][pre_end];\\n        mp[i][k][pre_end] = 0;\\n        if(pre_end < e[i][0]) \\n            mp[i][k][pre_end]  = solve(e, k-1, e[i][1], i+1) + e[i][2];\\n        return mp[i][k][pre_end] = max(mp[i][k][pre_end] ,  solve(e, k, pre_end, i+1));\\n    }\\npublic:\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        sort(begin(e), end(e));\\n        mp.resize(e.size(), vector<unordered_map<int, int>>(k+1));\\n        return solve(e,k, -1, 0);\\n    }\\n};\\n```\\n\\n# **Upvote if You Like it**",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    vector<vector<unordered_map<int, int>>> mp;\\n    int solve(vector<vector<int>>& e, int k, int pre_end, int i)  {\\n        if(i >= e.size() || k == 0) return 0;\\n        if(mp[i][k].count(pre_end)) return mp[i][k][pre_end];\\n        mp[i][k][pre_end] = 0;\\n        if(pre_end < e[i][0]) \\n            mp[i][k][pre_end]  = solve(e, k-1, e[i][1], i+1) + e[i][2];\\n        return mp[i][k][pre_end] = max(mp[i][k][pre_end] ,  solve(e, k, pre_end, i+1));\\n    }\\npublic:\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        sort(begin(e), end(e));\\n        mp.resize(e.size(), vector<unordered_map<int, int>>(k+1));\\n        return solve(e,k, -1, 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767087,
                "title": "c-dp-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>&events,int k,int i,int j,vector<vector<int>>&dp)\\n    {\\n        if(i==events.size() || k==0)return 0;\\n        if(j!=-1 && dp[j][k]!=-1)return dp[j][k];\\n        int val=0;\\n        if(j==-1 || events[i][0]>events[j][1])\\n        {\\n            val=events[i][2]+helper(events,k-1,i+1,i,dp);\\n        }\\n        val=max(val,helper(events,k,i+1,j,dp));\\n        if(j==-1)return val;\\n        return dp[j][k]=val;\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        vector<vector<int>>dp(events.size()+1,vector<int>(k+1,-1));\\n        return helper(events,k,0,-1,dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int helper(vector<vector<int>>&events,int k,int i,int j,vector<vector<int>>&dp)\\n    {\\n        if(i==events.size() || k==0)return 0;\\n        if(j!=-1 && dp[j][k]!=-1)return dp[j][k];\\n        int val=0;\\n        if(j==-1 || events[i][0]>events[j][1])\\n        {\\n            val=events[i][2]+helper(events,k-1,i+1,i,dp);\\n        }\\n        val=max(val,helper(events,k,i+1,j,dp));\\n        if(j==-1)return val;\\n        return dp[j][k]=val;\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        vector<vector<int>>dp(events.size()+1,vector<int>(k+1,-1));\\n        return helper(events,k,0,-1,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3767075,
                "title": "c-memoisation-and-tabulation-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: $$O(n*k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Memoisation\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        vector<int> s;\\n        for(auto i : e) s.push_back(i[0]);\\n        sort(s.begin(), s.end());\\n        sort(e.begin(), e.end(),  [](const vector<int>&a, const vector<int>&b){\\n           return a[0] < b[0]; \\n        });\\n\\n        vector<vector<int>> dp(e.size()+1, vector<int>(k+1, 0));\\n        int n = e.size();\\n        for(int idx = n-1;idx >= 0;idx--){\\n            for(int j = 1;j <= k;j++){\\n                int ntake = dp[idx+1][j];\\n                int nxt = upper_bound(s.begin(), s.end(), e[idx][1]) - s.begin();\\n                int take = e[idx][2] + dp[nxt][j-1];\\n                dp[idx][j] = max(take, ntake); \\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```\\n# Tabulation\\n```cpp\\nclass Solution {\\n    int f(int idx, vector<vector<int>>& e, int k, vector<int>& s, vector<vector<int>> &dp){\\n        if(idx >= e.size() || k <= 0) return 0;\\n        if(dp[idx][k] != -1) return dp[idx][k];\\n\\n        int ntake = f(idx+1, e, k ,s, dp);\\n        int nxt = upper_bound(s.begin(), s.end(), e[idx][1]) - s.begin();\\n        int take = e[idx][2] + f(nxt, e, k-1, s, dp);\\n        return dp[idx][k] = max(take, ntake); \\n    }\\npublic:\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        vector<int> s;\\n        for(auto i : e) s.push_back(i[0]);\\n        sort(s.begin(), s.end());\\n        sort(e.begin(), e.end(),  [](const vector<int>&a, const vector<int>&b){\\n           return a[0] < b[0]; \\n        });\\n\\n        vector<vector<int>> dp(e.size()+1, vector<int>(k+1, 0));\\n        int n = e.size();\\n        for(int idx = n-1;idx >= 0;idx--){\\n            for(int j = 1;j <= k;j++){\\n                int ntake = dp[idx+1][j];\\n                int nxt = upper_bound(s.begin(), s.end(), e[idx][1]) - s.begin();\\n                int take = e[idx][2] + dp[nxt][j-1];\\n                dp[idx][j] = max(take, ntake); \\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        vector<int> s;\\n        for(auto i : e) s.push_back(i[0]);\\n        sort(s.begin(), s.end());\\n        sort(e.begin(), e.end(),  [](const vector<int>&a, const vector<int>&b){\\n           return a[0] < b[0]; \\n        });\\n\\n        vector<vector<int>> dp(e.size()+1, vector<int>(k+1, 0));\\n        int n = e.size();\\n        for(int idx = n-1;idx >= 0;idx--){\\n            for(int j = 1;j <= k;j++){\\n                int ntake = dp[idx+1][j];\\n                int nxt = upper_bound(s.begin(), s.end(), e[idx][1]) - s.begin();\\n                int take = e[idx][2] + dp[nxt][j-1];\\n                dp[idx][j] = max(take, ntake); \\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\n    int f(int idx, vector<vector<int>>& e, int k, vector<int>& s, vector<vector<int>> &dp){\\n        if(idx >= e.size() || k <= 0) return 0;\\n        if(dp[idx][k] != -1) return dp[idx][k];\\n\\n        int ntake = f(idx+1, e, k ,s, dp);\\n        int nxt = upper_bound(s.begin(), s.end(), e[idx][1]) - s.begin();\\n        int take = e[idx][2] + f(nxt, e, k-1, s, dp);\\n        return dp[idx][k] = max(take, ntake); \\n    }\\npublic:\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        vector<int> s;\\n        for(auto i : e) s.push_back(i[0]);\\n        sort(s.begin(), s.end());\\n        sort(e.begin(), e.end(),  [](const vector<int>&a, const vector<int>&b){\\n           return a[0] < b[0]; \\n        });\\n\\n        vector<vector<int>> dp(e.size()+1, vector<int>(k+1, 0));\\n        int n = e.size();\\n        for(int idx = n-1;idx >= 0;idx--){\\n            for(int j = 1;j <= k;j++){\\n                int ntake = dp[idx+1][j];\\n                int nxt = upper_bound(s.begin(), s.end(), e[idx][1]) - s.begin();\\n                int take = e[idx][2] + dp[nxt][j-1];\\n                dp[idx][j] = max(take, ntake); \\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766940,
                "title": "simple-intuitive-recursion-memoization-all-possible-sequence",
                "content": "Let\\'s first sort the array according to start time then we will think how to select meetings\\n\\nHere the problem with knap sack approach is that ki our current selection depends upon previous selection so\\nwe need to keep 3 variable   curr_index ,  prev_index , k and given the constrains it may surpass the complexcity limit of ~10^8 so can we think about something like let\\'s say we have already some portion of problem till some index  \\nsay idx where \"idx\\' is the index of last selected element.\\n\\n```\\nso from idx to n-1 we can check all possible next element and take max of all possiblities \\n```\\n\\nSTILL WE HAVE AN ISSUE \\nhow we are going to select first element bcz all the answer will depend upon this selection, and if we let\\'s say start from all possible startig index from 0 to n-k then i will again exceed the time complexcity  { (n *   (n*k) )-> n for loop and  n*k for solve function }\\n\\nSOLUTION: \\nlet\\'s insert {0,0,0} in array and then do sorting.\\nand then call solve(0,k)\\nthis won\\'t change our solution bcz we have selected a dummy interval it won\\'t affect our answer bcz still we are selecting k element,\\nthe benifit of doing this is, we have a current first selected element(start point) and also \\nstart time , end time and  value are >=1\\nso it\\'s ideal for making a start point\\n```\\n UPVOTE IF U LIKE THE SOLUTION :)\\n```\\n\\nIMPLIMENTATION :\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>>a;\\n    vector<vector<int>>dp;\\n    int solve(int idx, int k) // till i solved // i encluded\\n    {\\n        if(idx==n|| k==0) return 0;\\n        \\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n         int ans=0;\\n        for(int i=idx+1; i<n; i++)\\n        {\\n            if(a[i][0]>a[idx][1]) ans= max(ans, solve(i,k-1)+a[i][2]); \\n            \\n        }\\n        \\n        return dp[idx][k]=ans;\\n        \\n    }\\n    int maxValue(vector<vector<int>>& e, int k) \\n    {\\n        e.push_back({0,0,0});\\n        sort(e.begin(),e.end());\\n        \\n        a=e;\\n        n=e.size();\\n        dp.resize(n+3, vector<int>(k+2,-1));\\n        int ans=0;\\n        ans= (solve(0,k));\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nso from idx to n-1 we can check all possible next element and take max of all possiblities \\n```\n```\\n UPVOTE IF U LIKE THE SOLUTION :)\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<vector<int>>a;\\n    vector<vector<int>>dp;\\n    int solve(int idx, int k) // till i solved // i encluded\\n    {\\n        if(idx==n|| k==0) return 0;\\n        \\n        if(dp[idx][k]!=-1) return dp[idx][k];\\n         int ans=0;\\n        for(int i=idx+1; i<n; i++)\\n        {\\n            if(a[i][0]>a[idx][1]) ans= max(ans, solve(i,k-1)+a[i][2]); \\n            \\n        }\\n        \\n        return dp[idx][k]=ans;\\n        \\n    }\\n    int maxValue(vector<vector<int>>& e, int k) \\n    {\\n        e.push_back({0,0,0});\\n        sort(e.begin(),e.end());\\n        \\n        a=e;\\n        n=e.size();\\n        dp.resize(n+3, vector<int>(k+2,-1));\\n        int ans=0;\\n        ans= (solve(0,k));\\n        return ans;\\n        \\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766870,
                "title": "memoization-code-c-java-solution",
                "content": "# Code\\n\\n**Java**\\n```\\nclass Solution {\\n    Integer dp[][];\\n    public int maxValue(int[][] events, int k) {\\n        int n=events.length;\\n        dp=new Integer[n][k+1];\\n        Arrays.sort(events,(a,b)->Integer.compare(a[0],b[0]));\\n        return solve(events,k,0,-1);\\n    }\\n    public int solve(int [][] events,int k,int curr,int prev){\\n        if(curr==events.length || k==0) return 0;\\n        if(prev==-1 || events[prev][1]<events[curr][0]){\\n            if(dp[curr][k]!=null) return dp[curr][k];\\n            return dp[curr][k]=Math.max(solve(events,k-1,curr+1,curr)+events[curr][2],\\n                            solve(events,k,curr+1,prev));\\n        }\\n        else return solve(events,k,curr+1,prev);\\n    }\\n}\\n```\\n\\n**C++**\\n\\n```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        dp.resize(n, vector<int>(k+1, -1));\\n        sort(events.begin(), events.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0];\\n        });\\n        return solve(events, k, 0, -1);\\n    }\\n    \\n    int solve(vector<vector<int>>& events, int k, int curr, int prev) {\\n        if (curr == events.size() || k == 0) return 0;\\n        if (prev == -1 || events[prev][1] < events[curr][0]) {\\n            if (dp[curr][k] != -1) return dp[curr][k];\\n            return dp[curr][k] = max(solve(events, k - 1, curr + 1, curr) + events[curr][2],\\n                                     solve(events, k, curr + 1, prev));\\n        } else {\\n            return solve(events, k, curr + 1, prev);\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    Integer dp[][];\\n    public int maxValue(int[][] events, int k) {\\n        int n=events.length;\\n        dp=new Integer[n][k+1];\\n        Arrays.sort(events,(a,b)->Integer.compare(a[0],b[0]));\\n        return solve(events,k,0,-1);\\n    }\\n    public int solve(int [][] events,int k,int curr,int prev){\\n        if(curr==events.length || k==0) return 0;\\n        if(prev==-1 || events[prev][1]<events[curr][0]){\\n            if(dp[curr][k]!=null) return dp[curr][k];\\n            return dp[curr][k]=Math.max(solve(events,k-1,curr+1,curr)+events[curr][2],\\n                            solve(events,k,curr+1,prev));\\n        }\\n        else return solve(events,k,curr+1,prev);\\n    }\\n}\\n```\n```\\nclass Solution {\\n    vector<vector<int>> dp;\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        dp.resize(n, vector<int>(k+1, -1));\\n        sort(events.begin(), events.end(), [](const vector<int>& a, const vector<int>& b) {\\n            return a[0] < b[0];\\n        });\\n        return solve(events, k, 0, -1);\\n    }\\n    \\n    int solve(vector<vector<int>>& events, int k, int curr, int prev) {\\n        if (curr == events.size() || k == 0) return 0;\\n        if (prev == -1 || events[prev][1] < events[curr][0]) {\\n            if (dp[curr][k] != -1) return dp[curr][k];\\n            return dp[curr][k] = max(solve(events, k - 1, curr + 1, curr) + events[curr][2],\\n                                     solve(events, k, curr + 1, prev));\\n        } else {\\n            return solve(events, k, curr + 1, prev);\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766750,
                "title": "c-easy-to-understand-simple-memoization-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nHere we can see, taking the events depends upon the previous event. So, clearly we have to use sorting\\nSecond thing .... we can take maximum K events that gives us maximum value. So we are seeing there are two choices at each index take it or not take ...keeping in mind it should not exceed the limit K. So dp is used\\nThird thing, we have to decide which next event we should attend it can find in linear fashion but if we have sorted events then why not use Binary Search\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1-Sort the events using its start time\\n2-Write a helper function to use dp that will return max value or your ans\\n3-In helper function, after taking a event, we have to decide which element should pick first ... So write a function that use Binary search and return nextIndex\\n\\n# Complexity\\nTime complexity: O(N(K + log(N))),\\n\\nN is size of the array, K is maximum events allowed to attend\\n\\nSpace complexity: O(NK)\\nN is size of the array, K is maximum events allowed to attend\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    //Binary Search \\n    // next index\\n    int BinarySearch(int i, vector<vector<int>>& e, int val){\\n        int st = i;\\n        int end = e.size() - 1;\\n        int nextIdx = -1;\\n\\n        while(st <= end){\\n            int mid = st + (end - st)/2;\\n            if(e[mid][0] > val){\\n                nextIdx = mid;\\n                end = mid - 1;\\n            }\\n            else{\\n                st = mid + 1;\\n            }\\n        }\\n\\n        return nextIdx;\\n    }\\n\\n    // keep that index or not\\n    int solve(int idx, vector<vector<int>>& e, int k,vector<vector<int>>& dp){\\n        if(idx >= e.size() || k <= 0 || idx ==-1){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][k] != -1){\\n            return dp[idx][k];\\n        }\\n\\n        int nextIdx = BinarySearch(idx + 1, e, e[idx][1]);\\n        \\n        int take = e[idx][2] + solve(nextIdx , e, k-1, dp);\\n        \\n        \\n        int notTake = 0 + solve(idx + 1, e, k, dp);\\n\\n        return dp[idx][k] = max(take, notTake);\\n    }\\n\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        //sorting on basis of start\\n\\n        sort(e.begin(), e.end());\\n        int n = e.size();\\n        vector<vector<int>> dp(n , vector<int>(k+1, -1));\\n        return solve(0, e, k, dp);\\n\\n\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //Binary Search \\n    // next index\\n    int BinarySearch(int i, vector<vector<int>>& e, int val){\\n        int st = i;\\n        int end = e.size() - 1;\\n        int nextIdx = -1;\\n\\n        while(st <= end){\\n            int mid = st + (end - st)/2;\\n            if(e[mid][0] > val){\\n                nextIdx = mid;\\n                end = mid - 1;\\n            }\\n            else{\\n                st = mid + 1;\\n            }\\n        }\\n\\n        return nextIdx;\\n    }\\n\\n    // keep that index or not\\n    int solve(int idx, vector<vector<int>>& e, int k,vector<vector<int>>& dp){\\n        if(idx >= e.size() || k <= 0 || idx ==-1){\\n            return 0;\\n        }\\n        \\n        if(dp[idx][k] != -1){\\n            return dp[idx][k];\\n        }\\n\\n        int nextIdx = BinarySearch(idx + 1, e, e[idx][1]);\\n        \\n        int take = e[idx][2] + solve(nextIdx , e, k-1, dp);\\n        \\n        \\n        int notTake = 0 + solve(idx + 1, e, k, dp);\\n\\n        return dp[idx][k] = max(take, notTake);\\n    }\\n\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        //sorting on basis of start\\n\\n        sort(e.begin(), e.end());\\n        int n = e.size();\\n        vector<vector<int>> dp(n , vector<int>(k+1, -1));\\n        return solve(0, e, k, dp);\\n\\n\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766667,
                "title": "javascript-100-faster",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number[][]} events\\n * @param {number} k\\n * @return {number}\\n */\\n\\nvar f = function(ind,k,events,dp){\\n    if(ind == events.length || k == 0) return 0;\\n    \\n    if(dp[ind][k] != -1) return dp[ind][k];\\n    let take = events[ind][2];\\n    for(let i = ind+1; i < events.length; ++i){\\n        if(events[ind][1] < events[i][0]){\\n            take += f(i,k-1,events,dp);\\n            break;\\n        }\\n    }\\n    let notTake = f(ind+1,k,events,dp);\\n    return dp[ind][k] = Math.max(take,notTake);\\n}\\nvar maxValue = function(events, k) {\\n    const dp = [];\\n    events.sort((a,b)=>a[0]===b[0]?a[1]-b[1]:a[0]-b[0])\\n    for(let i = 0; i < events.length; ++i){\\n        dp[i] = new Array(k+1).fill(-1);\\n    }\\n    return f(0,k,events,dp);\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} events\\n * @param {number} k\\n * @return {number}\\n */\\n\\nvar f = function(ind,k,events,dp){\\n    if(ind == events.length || k == 0) return 0;\\n    \\n    if(dp[ind][k] != -1) return dp[ind][k];\\n    let take = events[ind][2];\\n    for(let i = ind+1; i < events.length; ++i){\\n        if(events[ind][1] < events[i][0]){\\n            take += f(i,k-1,events,dp);\\n            break;\\n        }\\n    }\\n    let notTake = f(ind+1,k,events,dp);\\n    return dp[ind][k] = Math.max(take,notTake);\\n}\\nvar maxValue = function(events, k) {\\n    const dp = [];\\n    events.sort((a,b)=>a[0]===b[0]?a[1]-b[1]:a[0]-b[0])\\n    for(let i = 0; i < events.length; ++i){\\n        dp[i] = new Array(k+1).fill(-1);\\n    }\\n    return f(0,k,events,dp);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3766576,
                "title": "dp-sorting",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nstatic bool cmp(vector<int> &a, vector<int> &b)\\n{\\n    if (a[0] == b[0] and a[1] == b[1])\\n    {\\n        return a[2] > b[2];\\n    }\\n    else if (a[0] == b[0])\\n    {\\n        return a[1] < b[1];\\n    }\\n    return a[0] < b[0];\\n}\\n\\nint solve(int ind, int end, vector<vector<int>> &events, int k, vector<map<pair<int, int>, int>> &dp)\\n{\\n    if (k == 0)\\n    {\\n        return 0;\\n    }\\n    if (ind == events.size())\\n    {\\n        return 0;\\n    }\\n\\n    if (dp[ind].find({end, k}) != dp[ind].end())\\n    {\\n        return dp[ind][{end, k}];\\n    }\\n\\n    int nonpick = 0 + solve(ind + 1, end, events, k, dp);\\n    int pick = 0;\\n    if (events[ind][0] > end)\\n    {\\n        pick = events[ind][2] + solve(ind + 1, events[ind][1], events, k - 1, dp);\\n    }\\n\\n    return dp[ind][{end, k}] = max(pick, nonpick);\\n}\\n\\nint maxValue(vector<vector<int>> &events, int k)\\n{\\n    int n = events.size();\\n    vector<map<pair<int, int>, int>> dp(n);\\n    sort(events.begin(), events.end(), cmp);\\n    return solve(0, -1, events, k, dp);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstatic bool cmp(vector<int> &a, vector<int> &b)\\n{\\n    if (a[0] == b[0] and a[1] == b[1])\\n    {\\n        return a[2] > b[2];\\n    }\\n    else if (a[0] == b[0])\\n    {\\n        return a[1] < b[1];\\n    }\\n    return a[0] < b[0];\\n}\\n\\nint solve(int ind, int end, vector<vector<int>> &events, int k, vector<map<pair<int, int>, int>> &dp)\\n{\\n    if (k == 0)\\n    {\\n        return 0;\\n    }\\n    if (ind == events.size())\\n    {\\n        return 0;\\n    }\\n\\n    if (dp[ind].find({end, k}) != dp[ind].end())\\n    {\\n        return dp[ind][{end, k}];\\n    }\\n\\n    int nonpick = 0 + solve(ind + 1, end, events, k, dp);\\n    int pick = 0;\\n    if (events[ind][0] > end)\\n    {\\n        pick = events[ind][2] + solve(ind + 1, events[ind][1], events, k - 1, dp);\\n    }\\n\\n    return dp[ind][{end, k}] = max(pick, nonpick);\\n}\\n\\nint maxValue(vector<vector<int>> &events, int k)\\n{\\n    int n = events.size();\\n    vector<map<pair<int, int>, int>> dp(n);\\n    sort(events.begin(), events.end(), cmp);\\n    return solve(0, -1, events, k, dp);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766557,
                "title": "beats-98-intuition-approach-dp-binary-search",
                "content": "# Intuition\\nThe intuition is simple. For every meeting, you have a choice. **Attend** or **Not Attend**. \\n\\nIf you choose to  **Not Attend** a meeting = Look for the next meeting that you can attend. The value of `k` does not change, however the value of index changes as we move to the next meeting. \\n\\nIf you **Attend** a meeting = value to that meeting is added, and you have to look for the next meeting that you can attend according to the end time of the current meeting. After every meeting attended, the available value of `k` gets reduced by one. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe search for the next meeting to attend could be done using 2 for loops, but that would lead to TLE. Hence, we first sort `events` according to the starting time and then apply Binary Search on it. \\nThe binary search is performed on the remaining events starting from index i+1, searching for the first event whose start day is greater than the end day of the current event : `(events[i][1])`.\\n\\nCheck for the **base cases** : \\n- If k is 0, it means the maximum number of events have already been attended. Return 0 since no more events can be attended.\\n- If i is -1 or exceeds the size of the events array, it means there = are no more events available. Return 0 since no events can be attended.\\n- If the result for the current parameters dp[i][k] has already been calculated, return the stored result.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n     sort(events.begin(), events.end());\\n     int n = events.size();\\n     vector<vector<int>>dp(n+5,vector<int>(k+1,-1));\\n     return solve(0,events,k,dp);\\n    }\\n\\n    int binarySearch(int ind, vector<vector<int>>& events, int val) {\\n        int low = ind, high = events.size()-1, required = -1;\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n            if(events[mid][0] > val) {\\n                required = mid;\\n                high = mid - 1;\\n            }\\n            else    low = mid+1;\\n        }\\n        return required;\\n    }\\n\\n    int solve(int i, vector<vector<int>>& events, int k, vector<vector<int>>& dp) {\\n        if(k == 0 || i == -1 || i >= events.size())     return 0;\\n        if(dp[i][k] != -1)       return dp[i][k];\\n\\n        int ind = binarySearch(i+1, events, events[i][1]);\\n        int attend = events[i][2] + solve(ind, events, k-1, dp);\\n        int notAttend = solve(i+1, events, k, dp);\\n\\n        return dp[i][k] = max(attend, notAttend);   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n     sort(events.begin(), events.end());\\n     int n = events.size();\\n     vector<vector<int>>dp(n+5,vector<int>(k+1,-1));\\n     return solve(0,events,k,dp);\\n    }\\n\\n    int binarySearch(int ind, vector<vector<int>>& events, int val) {\\n        int low = ind, high = events.size()-1, required = -1;\\n        while(low <= high) {\\n            int mid = low + (high-low)/2;\\n            if(events[mid][0] > val) {\\n                required = mid;\\n                high = mid - 1;\\n            }\\n            else    low = mid+1;\\n        }\\n        return required;\\n    }\\n\\n    int solve(int i, vector<vector<int>>& events, int k, vector<vector<int>>& dp) {\\n        if(k == 0 || i == -1 || i >= events.size())     return 0;\\n        if(dp[i][k] != -1)       return dp[i][k];\\n\\n        int ind = binarySearch(i+1, events, events[i][1]);\\n        int attend = events[i][2] + solve(ind, events, k-1, dp);\\n        int notAttend = solve(i+1, events, k, dp);\\n\\n        return dp[i][k] = max(attend, notAttend);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766524,
                "title": "9-lines-of-short-and-simple-code-step-by-step-explanation",
                "content": "# Intuition\\nThe problem requires finding the maximum total value that can be obtained by attending events, given a list of events with their start and end times and their respective values. Each event can be attended for its entire duration.\\n\\n# Approach\\nOne way to solve this problem is to use a recursive approach with memoization. We can define a recursive function max that takes three parameters: i (the current index of the event), k (the remaining number of events that can be attended), and prev (the previous end time of the last attended event).\\n\\nWe start by sorting the events array based on their start times in ascending order. This allows us to process the events in a chronological order.\\n\\nIn each recursive call, we have two choices: either attend the current event or skip it. If we attend the current event, we calculate the value that can be obtained by adding the value of the current event (events[i][2]) to the maximum value that can be obtained from attending the remaining events with k - 1 events and updating prev to the end time of the current event (events[i][1]).\\n\\nIf we skip the current event, we calculate the maximum value that can be obtained from attending the remaining events with k events and keeping prev unchanged.\\n\\nWe memoize the results of subproblems using an object obj to avoid redundant calculations. The memoization is based on the current index i, the remaining number of events k, and the previous end time prev.\\n\\nAfter the recursive calls, we return the maximum value obtained from attending the events starting from index 0, with k events and a previous end time of 0.\\n\\n# Complexity\\n- Time complexity: The time complexity of this approach is O(n * k), where n is the number of events and k is the remaining number of events that can be attended. We have to consider all possible combinations of events.\\n- Space complexity: The space complexity is O(n * k) as we use memoization to store the results of subproblems.\\n\\n# Code\\n```\\nfunction maxValue(events: number[][], k: number): number {\\n    events.sort((a, b) => a[0] - b[0]);\\n    let n = events.length, obj = {}\\n    const max = (i:number, k:number, prev:number): number => {\\n        if(i === n || k === 0)return 0;\\n        let str = `${i}-${k}-${prev}`\\n        if( obj[str] )return obj[str];\\n        if(prev >= events[i][0])return obj[str] = max(i + 1, k, prev);\\n        return obj[str] = Math.max(events[i][2] + max(i + 1, k - 1, events[i][1]), max(i + 1, k, prev))\\n    }\\n    return max(0 , k , 0)\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Array",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nfunction maxValue(events: number[][], k: number): number {\\n    events.sort((a, b) => a[0] - b[0]);\\n    let n = events.length, obj = {}\\n    const max = (i:number, k:number, prev:number): number => {\\n        if(i === n || k === 0)return 0;\\n        let str = `${i}-${k}-${prev}`\\n        if( obj[str] )return obj[str];\\n        if(prev >= events[i][0])return obj[str] = max(i + 1, k, prev);\\n        return obj[str] = Math.max(events[i][2] + max(i + 1, k - 1, events[i][1]), max(i + 1, k, prev))\\n    }\\n    return max(0 , k , 0)\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3766519,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n    sort(events.begin(), events.end(), [](const vector<int>& a, const vector<int>& b) {\\n        return a[1] < b[1];\\n    });\\n    int n = events.size();\\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1));\\n    for (int i = 1; i <= n; i++) {\\n        int l = 0, r = i - 1, last = -1;\\n        while (l <= r) {\\n            int mid = (l + r) / 2;\\n            if (events[mid][1] < events[i - 1][0]) {\\n                last = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        for (int j = 1; j <= k; j++) {\\n            dp[i][j] = max(dp[i - 1][j], dp[last + 1][j - 1] + events[i - 1][2]);\\n        }\\n    }\\n    return dp[n][k];\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n    sort(events.begin(), events.end(), [](const vector<int>& a, const vector<int>& b) {\\n        return a[1] < b[1];\\n    });\\n    int n = events.size();\\n    vector<vector<int>> dp(n + 1, vector<int>(k + 1));\\n    for (int i = 1; i <= n; i++) {\\n        int l = 0, r = i - 1, last = -1;\\n        while (l <= r) {\\n            int mid = (l + r) / 2;\\n            if (events[mid][1] < events[i - 1][0]) {\\n                last = mid;\\n                l = mid + 1;\\n            } else {\\n                r = mid - 1;\\n            }\\n        }\\n        for (int j = 1; j <= k; j++) {\\n            dp[i][j] = max(dp[i - 1][j], dp[last + 1][j - 1] + events[i - 1][2]);\\n        }\\n    }\\n    return dp[n][k];\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766455,
                "title": "easy-dp-recursive-memoization",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int dfs(int i,int k,int end,vector<vector<int>>& evnt){\\n        // we have attended all events or we have took out k events so return \\n       if(i==dp.size() || !k)return 0;\\n        //evnt ko attend nhi krskte to skip krdo\\n        if(evnt[i][0]<=end)return dfs(i+1,k,end,evnt);\\n        //already solved case\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        //ya to event pick kro aur profit rkhlo ya skip krdo\\n        return dp[i][k]=max(evnt[i][2]+dfs(i+1,k-1,evnt[i][1],evnt),dfs(i+1,k,end,evnt));\\n    }\\n    int maxValue(vector<vector<int>>& evnt, int k) {\\n        int n=evnt.size();\\n        sort(evnt.begin(),evnt.end());\\n        dp.resize(n,vector<int>(k+1,-1));\\n        return dfs(0,k,0,evnt);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int dfs(int i,int k,int end,vector<vector<int>>& evnt){\\n        // we have attended all events or we have took out k events so return \\n       if(i==dp.size() || !k)return 0;\\n        //evnt ko attend nhi krskte to skip krdo\\n        if(evnt[i][0]<=end)return dfs(i+1,k,end,evnt);\\n        //already solved case\\n        if(dp[i][k]!=-1)return dp[i][k];\\n        //ya to event pick kro aur profit rkhlo ya skip krdo\\n        return dp[i][k]=max(evnt[i][2]+dfs(i+1,k-1,evnt[i][1],evnt),dfs(i+1,k,end,evnt));\\n    }\\n    int maxValue(vector<vector<int>>& evnt, int k) {\\n        int n=evnt.size();\\n        sort(evnt.begin(),evnt.end());\\n        dp.resize(n,vector<int>(k+1,-1));\\n        return dfs(0,k,0,evnt);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766444,
                "title": "ruby-solution-with-memoization-explained",
                "content": "# Intuition\\nFor each event, you can choose to include it (and exclude any overlapping events), or exclude it (and move onto the next event).  Sort and memoize for efficiency.\\n\\n# Approach\\nMain function:\\n1. Sort the events and store in a class variable.\\n2. Create a memo using an array for fast lookup.\\n3. Use a helper function starting at the first event, with k events.\\n\\nHelper function:\\n1. Return 0 if you\\'ve checked all events or you can\\'t attend any more events.\\n2. Return your stored value if it\\'s in memo.\\n3. Create option 1: do not go to current event, and call the function starting at the next event.\\n4. For option 2, you *will* go to current event.  Use a while loop to skip past any overlapping events, then create option 2 starting at j (next non-overlapping event) and adding the value of current event.\\n5. Find the max of option 1 and option 2, memoize, and return.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n * k)$$ or $$O(n * log(n))$$ (whichever is higher), where *n* is the number of events.\\n\\n- Space complexity:\\n$$O(n * k)$$\\n\\n# Code\\n```\\ndef max_value(events, k)\\n    @events = events.sort\\n    @memo = Array.new(events.length) { {} }\\n    max_val(0,k)\\nend\\n\\ndef max_val(i,k)\\n    return 0 if i == @events.length || k == 0\\n    return @memo[i][k] if @memo[i][k]\\n\\n    option1 = max_val(i+1,k)\\n\\n    j = i+1\\n    while @events[j] && @events[j][0] <= @events[i][1]\\n        j += 1\\n    end\\n    option2 = max_val(j,k-1) + @events[i][2]\\n\\n    @memo[i][k] = [option1,option2].max\\nend\\n\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef max_value(events, k)\\n    @events = events.sort\\n    @memo = Array.new(events.length) { {} }\\n    max_val(0,k)\\nend\\n\\ndef max_val(i,k)\\n    return 0 if i == @events.length || k == 0\\n    return @memo[i][k] if @memo[i][k]\\n\\n    option1 = max_val(i+1,k)\\n\\n    j = i+1\\n    while @events[j] && @events[j][0] <= @events[i][1]\\n        j += 1\\n    end\\n    option2 = max_val(j,k-1) + @events[i][2]\\n\\n    @memo[i][k] = [option1,option2].max\\nend\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3766427,
                "title": "top-down-dp-cached-binary-search",
                "content": "# Approach\\nWe first sort the events by their starting time. This helps us better organize and navigate the events. Then for each event, we identify the next one that doesn\\'t overlap with it. This helps us to avoid conflicts between events.\\nNext, we then start looking at different combinations of events to attend. We consider two options: either we attend the current event and then go to the next event that doesn\\'t clash, or we skip the current event and move on to the next one. We use a technique called dynamic programming to store the best choice we\\'ve made so far for each scenario. This way, we don\\'t have to calculate the same thing over and over again.\\nAfter we\\'ve explored all options, we look at our stored results and pick the combination of events that gives us the maximum total value.\\nEssentially, we\\'re creating a game plan for the best events to attend to get the most value, while avoiding any overlap in events.\\n\\n# Time Complexity\\n**O(n\\u22C5k\\u22C5log n)**\\nThe time complexity of the code is dominated by two factors: `sorting the events`, and the `depth-first search`.\\n\\n# Space complexity\\n**O(n\\u22C5k)**\\nThe space complexity is dominated by the storage needed for the `dp array` and the `nextIndices array`.\\n\\n# Solution\\n```swift\\nfinal class Solution {\\n    private var dp: [[Int]]\\n    private var nextIndices: [Int]\\n    \\n    init() {\\n        dp = [[Int]]()\\n        nextIndices = [Int]()\\n    }\\n    \\n    func maxValue(_ events: [[Int]], _ k: Int) -> Int {\\n        let sortedEvents = events.sorted(by: { $0[0] < $1[0] })\\n        let n = sortedEvents.count\\n        nextIndices = [Int](repeating: 0, count: n)\\n\\n        for curIndex in 0..<n {\\n            nextIndices[curIndex] = bisectRight(sortedEvents, sortedEvents[curIndex][1])\\n        }\\n        dp = Array(repeating: Array(repeating: -1, count: n), count: k + 1)\\n        return dfs(0, k, sortedEvents)\\n    }\\n    \\n    private func dfs(_ curIndex: Int, _ count: Int, _ events: [[Int]]) -> Int {\\n        if count == 0 || curIndex == events.count { return 0 }\\n        if dp[count][curIndex] != -1 { return dp[count][curIndex] }\\n        \\n        let nextIndex = nextIndices[curIndex]\\n        dp[count][curIndex] = max(\\n            dfs(curIndex + 1, count, events), \\n            events[curIndex][2] + dfs(nextIndex, count - 1, events)\\n        )\\n        return dp[count][curIndex]\\n    }\\n    \\n    private func bisectRight(_ events: [[Int]], _ target: Int) -> Int {\\n        var left = 0, right = events.count\\n        while left < right {\\n            let mid = (left + right) / 2\\n            events[mid][0] <= target ? (left = mid + 1) : (right = mid)\\n        }\\n        return left\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Swift",
                    "Binary Search",
                    "Dynamic Programming"
                ],
                "code": "```swift\\nfinal class Solution {\\n    private var dp: [[Int]]\\n    private var nextIndices: [Int]\\n    \\n    init() {\\n        dp = [[Int]]()\\n        nextIndices = [Int]()\\n    }\\n    \\n    func maxValue(_ events: [[Int]], _ k: Int) -> Int {\\n        let sortedEvents = events.sorted(by: { $0[0] < $1[0] })\\n        let n = sortedEvents.count\\n        nextIndices = [Int](repeating: 0, count: n)\\n\\n        for curIndex in 0..<n {\\n            nextIndices[curIndex] = bisectRight(sortedEvents, sortedEvents[curIndex][1])\\n        }\\n        dp = Array(repeating: Array(repeating: -1, count: n), count: k + 1)\\n        return dfs(0, k, sortedEvents)\\n    }\\n    \\n    private func dfs(_ curIndex: Int, _ count: Int, _ events: [[Int]]) -> Int {\\n        if count == 0 || curIndex == events.count { return 0 }\\n        if dp[count][curIndex] != -1 { return dp[count][curIndex] }\\n        \\n        let nextIndex = nextIndices[curIndex]\\n        dp[count][curIndex] = max(\\n            dfs(curIndex + 1, count, events), \\n            events[curIndex][2] + dfs(nextIndex, count - 1, events)\\n        )\\n        return dp[count][curIndex]\\n    }\\n    \\n    private func bisectRight(_ events: [[Int]], _ target: Int) -> Int {\\n        var left = 0, right = events.count\\n        while left < right {\\n            let mid = (left + right) / 2\\n            events[mid][0] <= target ? (left = mid + 1) : (right = mid)\\n        }\\n        return left\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766388,
                "title": "python-hard",
                "content": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n\\n\\n        events.sort(key = lambda x: x[0])\\n        N = len(events)\\n\\n\\n        @cache\\n        def calc(index, currentDay, currentK):\\n            if index == N or currentK == 0:\\n                return 0\\n\\n            while index < N and events[index][0] <= currentDay:\\n                index += 1\\n            \\n            if index == N:\\n                return 0\\n\\n            best = 0\\n\\n            for j in range(index, N):\\n                best = max(best, events[j][2] + calc(j + 1, events[j][1], currentK - 1))\\n\\n            return best\\n\\n        return calc(0, 0, k)\\n            \\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n\\n\\n        events.sort(key = lambda x: x[0])\\n        N = len(events)\\n\\n\\n        @cache\\n        def calc(index, currentDay, currentK):\\n            if index == N or currentK == 0:\\n                return 0\\n\\n            while index < N and events[index][0] <= currentDay:\\n                index += 1\\n            \\n            if index == N:\\n                return 0\\n\\n            best = 0\\n\\n            for j in range(index, N):\\n                best = max(best, events[j][2] + calc(j + 1, events[j][1], currentK - 1))\\n\\n            return best\\n\\n        return calc(0, 0, k)\\n            \\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766377,
                "title": "beats-100-fast-solution-dp-tabulation-fully-optimized",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe given code is a C++ implementation of a solution to a problem that involves maximizing the value of attending events while considering some constraints. Let\\'s break down the code step by step:\\n\\n1. The code defines a class named `Solution`.\\n\\n2. Inside the `Solution` class, there is a static comparison function `cmp` that compares two vectors `a` and `b`. It compares the first element of each vector (`a[0]` and `b[0]`) and returns `true` if `a[0]` is less than `b[0]`, indicating that `a` should come before `b` in sorting order.\\n\\n3. The `solveTab` function is defined. It takes three parameters: `events` (a 2D vector of integers representing events), `j` (an integer representing the maximum number of events that can be attended), and `start` (a vector of integers representing the start times of events).\\n\\n4. Inside the `solveTab` function, a 2D vector `DP` is initialized with dimensions `events.size() + 1` and `j + 1`. The values are set to 0 initially.\\n\\n5. The function then enters a nested loop to calculate the maximum value of attending events. It iterates over the events in reverse order using a loop variable `i`, and for each event, it iterates from `k = 1` to `j` (inclusive) using another loop variable `k`.\\n\\n6. Within the nested loop, the variable `last` is assigned the end time of the current event (`events[i][1]`).\\n\\n7. The `upper_bound` function is called to find the position of the first element in the `start` vector that is greater than `last`. The difference between this position and the beginning of the `start` vector (`start.begin()`) is stored in `idx`.\\n\\n8. The variable `incl` is calculated by adding the value of the current event (`events[i][2]`) to the value stored in `DP[idx][k-1]`. This represents the case where the current event is attended (`incl` stands for \"included\").\\n\\n9. The variable `excl` is assigned the value stored in `DP[i+1][k]`. This represents the case where the current event is not attended (`excl` stands for \"excluded\").\\n\\n10. The maximum value between `incl` and `excl` is assigned to `DP[i][k]`, representing the maximum value that can be achieved at the current event and considering the maximum number of events `k`.\\n\\n11. After the nested loops finish, the function returns the maximum value stored in `DP[0][j]`, which represents the maximum value achievable by attending events.\\n\\n12. The `maxValue` function is defined. It takes two parameters: `events` (a 2D vector of integers representing events) and `k` (an integer representing the maximum number of events that can be attended).\\n\\n13. Inside the `maxValue` function, a vector `start` is initialized to store the start times of events by iterating over the `events` vector.\\n\\n14. The `start` vector is sorted in ascending order using the `sort` function.\\n\\n15. The `events` vector is sorted in ascending order based on the start times of events using the `cmp` comparison function defined earlier.\\n\\n16. The `solveTab` function is called with `events`, `k`, and `start` as arguments, and its result is returned as the final output of the `maxValue` function.\\n\\nThat\\'s a step-by-step breakdown of the given code. It implements a dynamic programming approach to solve the problem of maximizing the value of attending events while considering the constraint of the maximum number of events that can be attended.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a, vector<int> &b){\\n        return a[0] < b[0];\\n    }\\n\\n    \\n\\n    int solveTab(vector<vector<int>>& events, int j, vector<int> &start){\\n        vector<vector<int>> DP(events.size()+1, vector<int>(j+1, 0));\\n\\n        for(int i=events.size()-1; i>=0; i--){\\n            for(int k=1; k<=j; k++){\\n                int last = events[i][1];\\n                int idx = upper_bound(start.begin(), start.end(), last) - start.begin();\\n                int incl = events[i][2] + DP[idx][k-1];\\n\\n                int excl = DP[i+1][k];\\n\\n                DP[i][k] = max(incl, excl);\\n            }\\n        }\\n\\n        return DP[0][j];\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<int> start;\\n        for(auto i : events) start.push_back(i[0]);\\n\\n        sort(start.begin(), start.end());\\n        sort(events.begin(), events.end(), cmp);\\n\\n        // vector<vector<int>> DP(events.size(), vector<int>(k+1, -1));\\n        // return solve(0, events, k, start, DP);\\n\\n        return solveTab(events, k, start);\\n    }\\n};\\n```\\n![7abc56.jpg](https://assets.leetcode.com/users/images/323a747c-ca90-41c6-95e7-2e64b74ad4cc_1689381488.4092333.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a, vector<int> &b){\\n        return a[0] < b[0];\\n    }\\n\\n    \\n\\n    int solveTab(vector<vector<int>>& events, int j, vector<int> &start){\\n        vector<vector<int>> DP(events.size()+1, vector<int>(j+1, 0));\\n\\n        for(int i=events.size()-1; i>=0; i--){\\n            for(int k=1; k<=j; k++){\\n                int last = events[i][1];\\n                int idx = upper_bound(start.begin(), start.end(), last) - start.begin();\\n                int incl = events[i][2] + DP[idx][k-1];\\n\\n                int excl = DP[i+1][k];\\n\\n                DP[i][k] = max(incl, excl);\\n            }\\n        }\\n\\n        return DP[0][j];\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<int> start;\\n        for(auto i : events) start.push_back(i[0]);\\n\\n        sort(start.begin(), start.end());\\n        sort(events.begin(), events.end(), cmp);\\n\\n        // vector<vector<int>> DP(events.size(), vector<int>(k+1, -1));\\n        // return solve(0, events, k, start, DP);\\n\\n        return solveTab(events, k, start);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3766339,
                "title": "daily-leetcoding-challenge-july-day-15",
                "content": "This problem is the Daily LeetCoding Challenge for July, Day 15.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  ** Do you want to learn the problem thoroughly?**\n  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 5 approaches in the official solution</summary>\n\n  \n**Approach 1:** Top-down Dynamic Programming + Binary Search\n\n  \n**Approach 2:** Bottom-up Dynamic Programming + Binary Search\n\n  \n**Approach 3:** Top-down Dynamic Programming + Cached Binary Search\n\n  \n**Approach 4:** Bottom-up Dynamic Programming + Optimized Binary Search\n\n  \n**Approach 5:** Top-down Dynamic Programming Without Binary Search\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**  LeetCode Official Solution**](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 3642428,
                "title": "c-dp-memoization-tabulation",
                "content": "# Intuition\\nIf we select an event, then directly moves to the next event that can be selected using binary search instead of iterating event by event.\\n\\n# Approach \\nMake a separate array for begin days in order to use upper_bound function\\n\\n# Complexity\\n- Time complexity:\\nO(n*k)\\n\\n- Space complexity:\\nO(n*k)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a, vector<int> &b){\\n        return a[0] < b[0];\\n    }\\n\\n    int solve(int i, vector<vector<int>>& events, int k, vector<int>& start, vector<vector<int>> &DP){\\n        if(i >= events.size()) return 0;\\n        if(k <= 0) return 0;\\n\\n        if(DP[i][k] != -1) return DP[i][k];\\n\\n        int last = events[i][1];\\n        int idx = upper_bound(start.begin(), start.end(), last) - start.begin();\\n        int incl = events[i][2] + solve(idx, events, k-1, start, DP);\\n\\n        int excl = solve(i+1, events, k, start, DP);\\n\\n        return DP[i][k] = max(incl, excl);\\n    }\\n\\n    int solveTab(vector<vector<int>>& events, int j, vector<int> &start){\\n        vector<vector<int>> DP(events.size()+1, vector<int>(j+1, 0));\\n\\n        for(int i=events.size()-1; i>=0; i--){\\n            for(int k=1; k<=j; k++){\\n                int last = events[i][1];\\n                int idx = upper_bound(start.begin(), start.end(), last) - start.begin();\\n                int incl = events[i][2] + DP[idx][k-1];\\n\\n                int excl = DP[i+1][k];\\n\\n                DP[i][k] = max(incl, excl);\\n            }\\n        }\\n\\n        return DP[0][j];\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<int> start;\\n        for(auto i : events) start.push_back(i[0]);\\n\\n        sort(start.begin(), start.end());\\n        sort(events.begin(), events.end(), cmp);\\n\\n        // vector<vector<int>> DP(events.size(), vector<int>(k+1, -1));\\n        // return solve(0, events, k, start, DP);\\n\\n        return solveTab(events, k, start);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool static cmp(vector<int> &a, vector<int> &b){\\n        return a[0] < b[0];\\n    }\\n\\n    int solve(int i, vector<vector<int>>& events, int k, vector<int>& start, vector<vector<int>> &DP){\\n        if(i >= events.size()) return 0;\\n        if(k <= 0) return 0;\\n\\n        if(DP[i][k] != -1) return DP[i][k];\\n\\n        int last = events[i][1];\\n        int idx = upper_bound(start.begin(), start.end(), last) - start.begin();\\n        int incl = events[i][2] + solve(idx, events, k-1, start, DP);\\n\\n        int excl = solve(i+1, events, k, start, DP);\\n\\n        return DP[i][k] = max(incl, excl);\\n    }\\n\\n    int solveTab(vector<vector<int>>& events, int j, vector<int> &start){\\n        vector<vector<int>> DP(events.size()+1, vector<int>(j+1, 0));\\n\\n        for(int i=events.size()-1; i>=0; i--){\\n            for(int k=1; k<=j; k++){\\n                int last = events[i][1];\\n                int idx = upper_bound(start.begin(), start.end(), last) - start.begin();\\n                int incl = events[i][2] + DP[idx][k-1];\\n\\n                int excl = DP[i+1][k];\\n\\n                DP[i][k] = max(incl, excl);\\n            }\\n        }\\n\\n        return DP[0][j];\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<int> start;\\n        for(auto i : events) start.push_back(i[0]);\\n\\n        sort(start.begin(), start.end());\\n        sort(events.begin(), events.end(), cmp);\\n\\n        // vector<vector<int>> DP(events.size(), vector<int>(k+1, -1));\\n        // return solve(0, events, k, start, DP);\\n\\n        return solveTab(events, k, start);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3611858,
                "title": "recursion-memoization-tabulation-dynamic-programming",
                "content": "\\n\\n# Recursion\\n```\\nclass Solution {\\npublic:\\n    int getNextCurr(vector<vector<int>>& events,int left,int key){\\n        int right=events.size()-1;\\n        int nextCurr=events.size();\\n        int mid;\\n        while(left<=right){\\n            mid=(left+right)/2;\\n            if(events[mid][0]>=key){\\n                nextCurr=mid;\\n                right=mid-1;\\n            }\\n            else left=mid+1;\\n        }\\n        return nextCurr;\\n    }\\n    int maxEvent(int curr,int k,vector<vector<int>>& events){\\n        if(curr>=events.size()) return 0;\\n        int pick=0;\\n        int nextCurr=getNextCurr(events,curr,events[curr][1]+1);\\n        if(k>0) pick=events[curr][2]+maxEvent(nextCurr,k-1,events);\\n        int notpick=maxEvent(curr+1,k,events);\\n        return max(pick,notpick);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        return maxEvent(0,k,events);\\n        \\n    }\\n};\\n```\\n\\n# Memoization\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int getNextCurr(vector<vector<int>>& events,int left,int key){\\n        int right=events.size()-1;\\n        int nextCurr=events.size();\\n        int mid;\\n        while(left<=right){\\n            mid=(left+right)/2;\\n            if(events[mid][0]>=key){\\n                nextCurr=mid;\\n                right=mid-1;\\n            }\\n            else left=mid+1;\\n        }\\n        return nextCurr;\\n    }\\n    int maxEvent(int curr,int k,vector<vector<int>>& events,vector<vector<int>>& dp){\\n        if(curr>=events.size()) return 0;\\n        if(dp[k][curr]!=-1) return dp[k][curr];\\n        int pick=0;\\n        int nextCurr=getNextCurr(events,curr,events[curr][1]+1);\\n        if(k>0) pick=events[curr][2]+maxEvent(nextCurr,k-1,events,dp);\\n        int notpick=maxEvent(curr+1,k,events,dp);\\n        return dp[k][curr]=max(pick,notpick);\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        vector<vector<int>> dp(k+1,vector<int>(events.size(),-1));\\n        return maxEvent(0,k,events,dp);\\n    }\\n};\\n```\\n\\n# Tabulation \\n```\\nclass Solution {\\npublic:\\n    int getNextCurr(vector<vector<int>>& events,int left,int key){\\n        int right=events.size()-1;\\n        int nextCurr=events.size();\\n        int mid;\\n        while(left<=right){\\n            mid=(left+right)/2;\\n            if(events[mid][0]>=key){\\n                nextCurr=mid;\\n                right=mid-1;\\n            }\\n            else left=mid+1;\\n        }\\n        return nextCurr;\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        vector<vector<int>> dp(events.size()+1,vector<int>(k+1,0));\\n        for(int curr=events.size()-1;curr>=0;curr--){\\n            for(int K=0;K<=k;K++){\\n                int pick=0;\\n                int nextCurr=getNextCurr(events,curr,events[curr][1]+1);\\n                if(K>0) pick=events[curr][2]+dp[nextCurr][K-1];\\n                int notpick=dp[curr+1][K];\\n                dp[curr][K]=max(pick,notpick);\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getNextCurr(vector<vector<int>>& events,int left,int key){\\n        int right=events.size()-1;\\n        int nextCurr=events.size();\\n        int mid;\\n        while(left<=right){\\n            mid=(left+right)/2;\\n            if(events[mid][0]>=key){\\n                nextCurr=mid;\\n                right=mid-1;\\n            }\\n            else left=mid+1;\\n        }\\n        return nextCurr;\\n    }\\n    int maxEvent(int curr,int k,vector<vector<int>>& events){\\n        if(curr>=events.size()) return 0;\\n        int pick=0;\\n        int nextCurr=getNextCurr(events,curr,events[curr][1]+1);\\n        if(k>0) pick=events[curr][2]+maxEvent(nextCurr,k-1,events);\\n        int notpick=maxEvent(curr+1,k,events);\\n        return max(pick,notpick);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        return maxEvent(0,k,events);\\n        \\n    }\\n};\\n```\n```\\n\\n\\nclass Solution {\\npublic:\\n    int getNextCurr(vector<vector<int>>& events,int left,int key){\\n        int right=events.size()-1;\\n        int nextCurr=events.size();\\n        int mid;\\n        while(left<=right){\\n            mid=(left+right)/2;\\n            if(events[mid][0]>=key){\\n                nextCurr=mid;\\n                right=mid-1;\\n            }\\n            else left=mid+1;\\n        }\\n        return nextCurr;\\n    }\\n    int maxEvent(int curr,int k,vector<vector<int>>& events,vector<vector<int>>& dp){\\n        if(curr>=events.size()) return 0;\\n        if(dp[k][curr]!=-1) return dp[k][curr];\\n        int pick=0;\\n        int nextCurr=getNextCurr(events,curr,events[curr][1]+1);\\n        if(k>0) pick=events[curr][2]+maxEvent(nextCurr,k-1,events,dp);\\n        int notpick=maxEvent(curr+1,k,events,dp);\\n        return dp[k][curr]=max(pick,notpick);\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        vector<vector<int>> dp(k+1,vector<int>(events.size(),-1));\\n        return maxEvent(0,k,events,dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int getNextCurr(vector<vector<int>>& events,int left,int key){\\n        int right=events.size()-1;\\n        int nextCurr=events.size();\\n        int mid;\\n        while(left<=right){\\n            mid=(left+right)/2;\\n            if(events[mid][0]>=key){\\n                nextCurr=mid;\\n                right=mid-1;\\n            }\\n            else left=mid+1;\\n        }\\n        return nextCurr;\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(),events.end());\\n        vector<vector<int>> dp(events.size()+1,vector<int>(k+1,0));\\n        for(int curr=events.size()-1;curr>=0;curr--){\\n            for(int K=0;K<=k;K++){\\n                int pick=0;\\n                int nextCurr=getNextCurr(events,curr,events[curr][1]+1);\\n                if(K>0) pick=events[curr][2]+dp[nextCurr][K-1];\\n                int notpick=dp[curr+1][K];\\n                dp[curr][K]=max(pick,notpick);\\n            }\\n        }\\n        return dp[0][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580595,
                "title": "python-3-sort-binary-search-dp",
                "content": "# Complexity\\n- Time complexity:\\n$O(n\\\\log (n) + nk)$\\n\\n- Space complexity:\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort(key=lambda e: e[0])\\n        n = len(events)\\n        nextEvents = [0] * n\\n        for i, (_, endDay, _) in enumerate(events):\\n            j = bisect_left(events, endDay + 1, key=lambda e: e[0], lo=i+1)\\n            nextEvents[i] = j\\n        prev = [0] * (n + 1)\\n        for _ in range(k):\\n            cur = [0] * (n + 1)\\n            for i in range(n - 1, -1, -1):\\n                cur[i] = max(cur[i + 1], prev[nextEvents[i]] + events[i][2])\\n            prev = cur\\n        return prev[0]\\n                \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort(key=lambda e: e[0])\\n        n = len(events)\\n        nextEvents = [0] * n\\n        for i, (_, endDay, _) in enumerate(events):\\n            j = bisect_left(events, endDay + 1, key=lambda e: e[0], lo=i+1)\\n            nextEvents[i] = j\\n        prev = [0] * (n + 1)\\n        for _ in range(k):\\n            cur = [0] * (n + 1)\\n            for i in range(n - 1, -1, -1):\\n                cur[i] = max(cur[i + 1], prev[nextEvents[i]] + events[i][2])\\n            prev = cur\\n        return prev[0]\\n                \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502374,
                "title": "dynamic-programming",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(nk+n \\\\log n)$$\\n\\n- Space complexity:\\n$$O(nk)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MaxValue(int[][] events, int k) {\\n        int n = events.Length;\\n        events = (from x in events orderby x[0] select x).ToArray();\\n        \\n        int[,] dp = new int[n, k];\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < k; j++)\\n                dp[i, j] = -1;\\n        int DP(int eventIdx, int remainingK) {\\n            if(remainingK <= 0)\\n                return 0;\\n            if(eventIdx >= events.Length)\\n                return 0;\\n            if(dp[eventIdx, remainingK - 1] > -1)\\n                return dp[eventIdx, remainingK - 1];\\n            int ans = 0;\\n\\n            //attend event at eventIdx\\n            ans += events[eventIdx][2];\\n            //find next possible event to attend\\n            int nextEventIdx = eventIdx;\\n            while(++nextEventIdx < n && events[nextEventIdx][0] <= events[eventIdx][1]);\\n            ans += DP(nextEventIdx, remainingK - 1);\\n\\n            //dont attend event\\n            ans = Math.Max(ans, DP(eventIdx + 1, remainingK));\\n            dp[eventIdx, remainingK - 1] = ans;\\n            return ans;\\n        }\\n        return DP(0, k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\npublic class Solution {\\n    public int MaxValue(int[][] events, int k) {\\n        int n = events.Length;\\n        events = (from x in events orderby x[0] select x).ToArray();\\n        \\n        int[,] dp = new int[n, k];\\n        for(int i = 0; i < n; i++)\\n            for(int j = 0; j < k; j++)\\n                dp[i, j] = -1;\\n        int DP(int eventIdx, int remainingK) {\\n            if(remainingK <= 0)\\n                return 0;\\n            if(eventIdx >= events.Length)\\n                return 0;\\n            if(dp[eventIdx, remainingK - 1] > -1)\\n                return dp[eventIdx, remainingK - 1];\\n            int ans = 0;\\n\\n            //attend event at eventIdx\\n            ans += events[eventIdx][2];\\n            //find next possible event to attend\\n            int nextEventIdx = eventIdx;\\n            while(++nextEventIdx < n && events[nextEventIdx][0] <= events[eventIdx][1]);\\n            ans += DP(nextEventIdx, remainingK - 1);\\n\\n            //dont attend event\\n            ans = Math.Max(ans, DP(eventIdx + 1, remainingK));\\n            dp[eventIdx, remainingK - 1] = ans;\\n            return ans;\\n        }\\n        return DP(0, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3501916,
                "title": "c-solution-dp-binary-search",
                "content": "Similar to weighted job scheduling problem\\nhttps://leetcode.com/problems/maximum-profit-in-job-scheduling/description/\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a , vector<int>& b){\\n        if(a[1]!=b[1]) return a[1]<b[1];\\n        else return a[0]<b[0];\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end(), cmp);\\n        int n = events.size();\\n        vector<vector<int>> dp(n, vector<int>(k+1, 0));\\n        int max_ans=INT_MIN;\\n        dp[0][1]=events[0][2];\\n        max_ans = max(max_ans, dp[0][1]);\\n\\n        for(int i=1;i<n;i++){\\n            int st=events[i][0], et=events[i][1], cost=events[i][2];\\n            int idx=helper(events, i-1, st);\\n\\n            for(int j=1;j<=k;j++){\\n                int subans=0;\\n                if(idx!=-1) subans=dp[idx][j-1];\\n                dp[i][j]=max(subans+cost, dp[i-1][j]);\\n                max_ans=max(max_ans, dp[i][j]);\\n            }\\n        }\\n        return max_ans;\\n    }\\n    \\n    int helper(vector<vector<int>>& events, int end, int startDay){\\n        int l=0, r=end;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(events[mid][1]<startDay) l=mid+1;\\n            else r=mid-1;\\n        }\\n        return r;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Dynamic Programming",
                    "Sorting"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    static bool cmp(vector<int>& a , vector<int>& b){\\n        if(a[1]!=b[1]) return a[1]<b[1];\\n        else return a[0]<b[0];\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end(), cmp);\\n        int n = events.size();\\n        vector<vector<int>> dp(n, vector<int>(k+1, 0));\\n        int max_ans=INT_MIN;\\n        dp[0][1]=events[0][2];\\n        max_ans = max(max_ans, dp[0][1]);\\n\\n        for(int i=1;i<n;i++){\\n            int st=events[i][0], et=events[i][1], cost=events[i][2];\\n            int idx=helper(events, i-1, st);\\n\\n            for(int j=1;j<=k;j++){\\n                int subans=0;\\n                if(idx!=-1) subans=dp[idx][j-1];\\n                dp[i][j]=max(subans+cost, dp[i-1][j]);\\n                max_ans=max(max_ans, dp[i][j]);\\n            }\\n        }\\n        return max_ans;\\n    }\\n    \\n    int helper(vector<vector<int>>& events, int end, int startDay){\\n        int l=0, r=end;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(events[mid][1]<startDay) l=mid+1;\\n            else r=mid-1;\\n        }\\n        return r;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407672,
                "title": "replace-lower-bound-with-upper-bound",
                "content": "This problem is the same as that of the famous \"Maximum Profit in Job Scheduling\" problem -https://leetcode.com/problems/maximum-profit-in-job-scheduling/\\n\\nYou just have to tackle a new parameter \\'k\\' and repace lower_bound function with an upper_bound. This is because the way the timeline is defined here is a little bit different from the above mentioned problem.\\nPeace!\\n\\n\\n```\\nclass Solution {\\nprivate:\\n    int solve(int cur, vector<vector<int>> &events, vector<int> &start, int k){\\n        if(k==0) return 0;\\n        if(cur>=events.size()) return 0;\\n        \\n        if(dp[cur][k]!=-1) return dp[cur][k];\\n        \\n        int pick=0; int notPick=0;\\n        \\n        int index=upper_bound(start.begin(),start.end(),events[cur][1])-start.begin();\\n        \\n        pick=events[cur][2]+solve(index,events,start,k-1);\\n\\n        notPick=solve(cur+1,events,start,k);\\n \\n        return dp[cur][k]= max(pick,notPick);\\n    }\\n    \\n    \\npublic:\\n    vector<vector<int>> dp;\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        //start  end  val\\n        dp.resize(events.size()+1,vector<int>(k+1,-1));\\n        sort(events.begin(),events.end());\\n        vector<int> start;\\n        for(auto it: events){\\n            start.push_back(it[0]);\\n        }\\n        return solve(0,events,start,k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int solve(int cur, vector<vector<int>> &events, vector<int> &start, int k){\\n        if(k==0) return 0;\\n        if(cur>=events.size()) return 0;\\n        \\n        if(dp[cur][k]!=-1) return dp[cur][k];\\n        \\n        int pick=0; int notPick=0;\\n        \\n        int index=upper_bound(start.begin(),start.end(),events[cur][1])-start.begin();\\n        \\n        pick=events[cur][2]+solve(index,events,start,k-1);\\n\\n        notPick=solve(cur+1,events,start,k);\\n \\n        return dp[cur][k]= max(pick,notPick);\\n    }\\n    \\n    \\npublic:\\n    vector<vector<int>> dp;\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        //start  end  val\\n        dp.resize(events.size()+1,vector<int>(k+1,-1));\\n        sort(events.begin(),events.end());\\n        vector<int> start;\\n        for(auto it: events){\\n            start.push_back(it[0]);\\n        }\\n        return solve(0,events,start,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364902,
                "title": "c-dp-binary-search",
                "content": "\\n\\n# Approach\\nSimilar to [https://leetcode.com/problems/maximum-earnings-from-taxi/description/](https://leetcode.com/problems/maximum-earnings-from-taxi/description/). First Solve the above mentioned problem then move to this one. Just a small variation.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int bS(int tar,vector<vector<int>>& events)\\n    {\\n        int l = 0,r = events.size()-1;\\n        int ans = events.size();\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(events[mid][0]>tar)\\n            {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else\\n            l = mid+1;\\n        }\\n        return ans;\\n    }\\n    int solve(int idx,vector<vector<int>>& events,int k,map<pair<int,int>,int>& dp)\\n    {\\n        if(k==0)\\n        return 0;\\n        if(idx>=events.size())\\n        return 0;\\n        if(dp.find({idx,k})!=dp.end())\\n        return dp[{idx,k}];\\n        int start = events[idx][0];\\n        int end = events[idx][1];\\n        int value = events[idx][2];\\n        int i = bS(end,events);\\n        int take = value + solve(i,events,k-1,dp);\\n        int notTake = solve(idx+1,events,k,dp);\\n        return dp[{idx,k}] = max(take,notTake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        map<pair<int,int>,int> dp;\\n        sort(events.begin(),events.end());\\n        return solve(0,events,k,dp); \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int bS(int tar,vector<vector<int>>& events)\\n    {\\n        int l = 0,r = events.size()-1;\\n        int ans = events.size();\\n        while(l<=r)\\n        {\\n            int mid = (l+r)/2;\\n            if(events[mid][0]>tar)\\n            {\\n                ans = mid;\\n                r = mid-1;\\n            }\\n            else\\n            l = mid+1;\\n        }\\n        return ans;\\n    }\\n    int solve(int idx,vector<vector<int>>& events,int k,map<pair<int,int>,int>& dp)\\n    {\\n        if(k==0)\\n        return 0;\\n        if(idx>=events.size())\\n        return 0;\\n        if(dp.find({idx,k})!=dp.end())\\n        return dp[{idx,k}];\\n        int start = events[idx][0];\\n        int end = events[idx][1];\\n        int value = events[idx][2];\\n        int i = bS(end,events);\\n        int take = value + solve(i,events,k-1,dp);\\n        int notTake = solve(idx+1,events,k,dp);\\n        return dp[{idx,k}] = max(take,notTake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        map<pair<int,int>,int> dp;\\n        sort(events.begin(),events.end());\\n        return solve(0,events,k,dp); \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979746,
                "title": "intuitive-o-k-n-n-log-n-dp-solution-with-sets",
                "content": "# Complexity\\n- Time complexity:\\n$$O(k * (n + n * log(n)))$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        // sort events by startDay\\n        sort(events.begin(), events.end());\\n\\n        // pending will hold pair<endDay, maxSum> for x - 1 number of maximum events\\n        set<pair<long long, long long>> pending;\\n        // current will hold pair<endDay, maxSum> for x number of maximum events \\n        set<pair<long long, long long>> current;\\n\\n        long long ans = 0;\\n        for (int i = 1; i <= k; i++) {\\n            current.clear();\\n            long long best = 0;\\n            for (int j = 0; j < n; j++) {\\n                while (!pending.empty()) {\\n                    auto it = *pending.begin();\\n                    // we remove events from pending as long as they end before current event starts\\n                    // each of the removed event can be joined with the current event\\n                    if (it.first < events[j][0]) {\\n                        best = max(best, it.second);\\n                        pending.erase(pending.begin());\\n                    } else {\\n                        break;\\n                    }\\n                }\\n\\n                ans = max(ans, best + events[j][2]);\\n                current.insert({events[j][1], best + events[j][2]});\\n            }\\n\\n            pending = current;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        // sort events by startDay\\n        sort(events.begin(), events.end());\\n\\n        // pending will hold pair<endDay, maxSum> for x - 1 number of maximum events\\n        set<pair<long long, long long>> pending;\\n        // current will hold pair<endDay, maxSum> for x number of maximum events \\n        set<pair<long long, long long>> current;\\n\\n        long long ans = 0;\\n        for (int i = 1; i <= k; i++) {\\n            current.clear();\\n            long long best = 0;\\n            for (int j = 0; j < n; j++) {\\n                while (!pending.empty()) {\\n                    auto it = *pending.begin();\\n                    // we remove events from pending as long as they end before current event starts\\n                    // each of the removed event can be joined with the current event\\n                    if (it.first < events[j][0]) {\\n                        best = max(best, it.second);\\n                        pending.erase(pending.begin());\\n                    } else {\\n                        break;\\n                    }\\n                }\\n\\n                ans = max(ans, best + events[j][2]);\\n                current.insert({events[j][1], best + events[j][2]});\\n            }\\n\\n            pending = current;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849325,
                "title": "java-solution-dp-binary-search",
                "content": "```\\nclass Solution {\\n    private static class Event {\\n\\t\\tprivate int start;\\n\\t\\tprivate int end;\\n\\t\\tprivate int value;\\n\\n\\t\\tpublic Event(int start, int end, int value) {\\n\\t\\t\\tthis.start = start;\\n\\t\\t\\tthis.end = end;\\n\\t\\t\\tthis.value = value;\\n\\t\\t}\\n\\t}\\n\\n\\tprivate int binarySearch(Event events[], int index) {\\n\\t\\tint low = index + 1;\\n\\t\\tint high = events.length - 1;\\n\\t\\tint ans = events.length;\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tint mid = low + (high - low) / 2;\\n\\t\\t\\tif (events[mid].start > events[index].end) {\\n\\t\\t\\t\\tans = Math.min(ans, mid);\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate int backtrack(Event[] events, int[][] dp, int index, int k) {\\n\\t\\tif (index == events.length || k == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (dp[index][k - 1] != -1) {\\n\\t\\t\\treturn dp[index][k - 1];\\n\\t\\t}\\n\\t\\tint idx = binarySearch(events, index);\\n\\t\\tdp[index][k - 1] = Math.max(events[index].value + backtrack(events, dp, idx, k - 1), backtrack(events, dp, index + 1, k));\\n\\t\\treturn dp[index][k - 1];\\n\\t}\\n\\n\\tpublic int maxValue(int[][] events, int k) {\\n\\t\\tEvent eventArr[] = new Event[events.length];\\n\\t\\tfor (int i = 0; i < events.length; i++) {\\n\\t\\t\\teventArr[i] = new Event(events[i][0], events[i][1], events[i][2]);\\n\\t\\t}\\n\\t\\tArrays.sort(eventArr, (e1, e2) -> (e1.start - e2.start));\\n\\t\\tint[][] dp = new int[events.length][k];\\n\\t\\tfor (int[] row : dp)\\n\\t\\t\\tArrays.fill(row, -1);\\n\\n\\t\\treturn backtrack(eventArr, dp, 0, k);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    private static class Event {\\n\\t\\tprivate int start;\\n\\t\\tprivate int end;\\n\\t\\tprivate int value;\\n\\n\\t\\tpublic Event(int start, int end, int value) {\\n\\t\\t\\tthis.start = start;\\n\\t\\t\\tthis.end = end;\\n\\t\\t\\tthis.value = value;\\n\\t\\t}\\n\\t}\\n\\n\\tprivate int binarySearch(Event events[], int index) {\\n\\t\\tint low = index + 1;\\n\\t\\tint high = events.length - 1;\\n\\t\\tint ans = events.length;\\n\\t\\twhile (low <= high) {\\n\\t\\t\\tint mid = low + (high - low) / 2;\\n\\t\\t\\tif (events[mid].start > events[index].end) {\\n\\t\\t\\t\\tans = Math.min(ans, mid);\\n\\t\\t\\t\\thigh = mid - 1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tlow = mid + 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ans;\\n\\t}\\n\\n\\tprivate int backtrack(Event[] events, int[][] dp, int index, int k) {\\n\\t\\tif (index == events.length || k == 0) {\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t\\tif (dp[index][k - 1] != -1) {\\n\\t\\t\\treturn dp[index][k - 1];\\n\\t\\t}\\n\\t\\tint idx = binarySearch(events, index);\\n\\t\\tdp[index][k - 1] = Math.max(events[index].value + backtrack(events, dp, idx, k - 1), backtrack(events, dp, index + 1, k));\\n\\t\\treturn dp[index][k - 1];\\n\\t}\\n\\n\\tpublic int maxValue(int[][] events, int k) {\\n\\t\\tEvent eventArr[] = new Event[events.length];\\n\\t\\tfor (int i = 0; i < events.length; i++) {\\n\\t\\t\\teventArr[i] = new Event(events[i][0], events[i][1], events[i][2]);\\n\\t\\t}\\n\\t\\tArrays.sort(eventArr, (e1, e2) -> (e1.start - e2.start));\\n\\t\\tint[][] dp = new int[events.length][k];\\n\\t\\tfor (int[] row : dp)\\n\\t\\t\\tArrays.fill(row, -1);\\n\\n\\t\\treturn backtrack(eventArr, dp, 0, k);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748551,
                "title": "c-top-down-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        sort(e.begin(), e.end());\\n        n = e.size();\\n        vector<vector<int>> memo(n + 1, vector<int>(k + 1, -1));\\n        return dp(memo, e, 0, 0, k);\\n    }\\n    int dp(vector<vector<int>>& memo, vector<vector<int>>& e, int idx, int time, int k){\\n        if(idx == n || k == 0)\\n            return 0;\\n        if(time > e[idx][0])\\n            return dp(memo, e, idx + 1, time, k);\\n        if(memo[idx][k] != -1)\\n            return memo[idx][k];\\n        return memo[idx][k] = max(dp(memo, e, idx + 1, time, k), dp(memo, e, idx + 1, e[idx][1] + 1, k - 1) + e[idx][2]);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    int maxValue(vector<vector<int>>& e, int k) {\\n        sort(e.begin(), e.end());\\n        n = e.size();\\n        vector<vector<int>> memo(n + 1, vector<int>(k + 1, -1));\\n        return dp(memo, e, 0, 0, k);\\n    }\\n    int dp(vector<vector<int>>& memo, vector<vector<int>>& e, int idx, int time, int k){\\n        if(idx == n || k == 0)\\n            return 0;\\n        if(time > e[idx][0])\\n            return dp(memo, e, idx + 1, time, k);\\n        if(memo[idx][k] != -1)\\n            return memo[idx][k];\\n        return memo[idx][k] = max(dp(memo, e, idx + 1, time, k), dp(memo, e, idx + 1, e[idx][1] + 1, k - 1) + e[idx][2]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475485,
                "title": "understanding-the-pattern-java-solution-recursion-memoization",
                "content": "I wanted to solve binary search + dp problems and was looking for similar patterns.\\nAfter few hours of grilling and understanding patterns  between \\nhttps://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/\\nhttps://leetcode.com/problems/two-best-non-overlapping-events/\\nhttps://leetcode.com/problems/maximum-profit-in-job-scheduling/\\nWill add more problems to this template\\n\\nI came up with following template -\\nSolution for https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/\\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        //here k is optional maximum capacity of like knapsack \\n int n=events.length;\\n      \\n       Arrays.sort(events, (a, b) ->  Integer.compare(a[0], b[0]) );\\n        Integer[][] dp=new Integer[n][k];\\n        return dfs(events,0,0,n,k,dp);\\n    }\\n    \\n    public int dfs(int[][] events, int idx,int choose, int n,int k,Integer[][] dp){\\n        if(idx>=n)return 0;\\n        if(choose>=k)return 0;\\n        if(dp[idx][choose]!=null)return dp[idx][choose];\\n        int nextIdx=findNext(events, idx,n);\\n        int pick=events[idx][2]+dfs(events, nextIdx,choose+1, n,k,dp);\\n        int notPick=dfs(events, idx+1,choose, n,k,dp);\\n        return dp[idx][choose]= Math.max(pick,notPick);\\n    }\\n    public int findNext(int[][] events, int idx, int n){\\n        int ans=n;\\n        int l=idx+1;\\n        int r=n-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(events[idx][1]<events[mid][0]){\\n                ans=mid;\\n                r=mid-1;\\n            }else {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nFor https://leetcode.com/problems/two-best-non-overlapping-events/ k=2\\n\\n```\\n int n=events.length;\\n      \\n       Arrays.sort(events, (a, b) ->  Integer.compare(a[0], b[0]) );\\n        Integer[][] dp=new Integer[n][k];\\n        return dfs(events,0,0,n,k,dp);\\n    }\\n    \\n    public int dfs(int[][] events, int idx,int choose, int n,int k,Integer[][] dp){\\n        if(idx>=n)return 0;\\n        if(choose>=k)return 0;\\n        if(dp[idx][choose]!=null)return dp[idx][choose];\\n        int nextIdx=findNext(events, idx,n);\\n        int pick=events[idx][2]+dfs(events, nextIdx,choose+1, n,k,dp);\\n        int notPick=dfs(events, idx+1,choose, n,k,dp);\\n        return dp[idx][choose]= Math.max(pick,notPick);\\n    }\\n    public int findNext(int[][] events, int idx, int n){\\n        int ans=n;\\n        int l=idx+1;\\n        int r=n-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(events[idx][1]<events[mid][0]){\\n                ans=mid;\\n                r=mid-1;\\n            }else {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\nThere may be condition when no k boundation is required for example in question https://leetcode.com/problems/maximum-profit-in-job-scheduling/\\n\\n```\\nclass Solution {\\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\\n        int n=startTime.length;\\n        int[][] events=new int[n][3];\\n        for(int i=0;i<n;i++){\\n            events[i][0]=startTime[i];\\n            events[i][1]=endTime[i];\\n            events[i][2]=profit[i];\\n        }\\n        Arrays.sort(events,(a,b)->Integer.compare(a[0], b[0]));\\n        Integer[] dp=new Integer[n];\\n        return dfs(events,0,n,dp);\\n    }\\n    \\n    public int dfs(int[][] events, int idx, int n,Integer[] dp){\\n        if(idx==n)return 0;\\n        if(dp[idx]!=null)return dp[idx];\\n        int nextIdx=findNext(events, idx,n);\\n        int pick=events[idx][2]+dfs(events, nextIdx, n,dp);\\n        int notPick=dfs(events, idx+1, n,dp);\\n        return dp[idx]= Math.max(pick,notPick);\\n    }\\n    public int findNext(int[][] events, int idx, int n){\\n        int ans=n;\\n        int l=idx+1;\\n        int r=n-1;\\n        while(l<=r){\\n            int mid=(l+r)>>1;\\n            if(events[idx][1]<=events[mid][0]){\\n                ans=mid;\\n                r=mid-1;\\n            }else {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        //here k is optional maximum capacity of like knapsack \\n int n=events.length;\\n      \\n       Arrays.sort(events, (a, b) ->  Integer.compare(a[0], b[0]) );\\n        Integer[][] dp=new Integer[n][k];\\n        return dfs(events,0,0,n,k,dp);\\n    }\\n    \\n    public int dfs(int[][] events, int idx,int choose, int n,int k,Integer[][] dp){\\n        if(idx>=n)return 0;\\n        if(choose>=k)return 0;\\n        if(dp[idx][choose]!=null)return dp[idx][choose];\\n        int nextIdx=findNext(events, idx,n);\\n        int pick=events[idx][2]+dfs(events, nextIdx,choose+1, n,k,dp);\\n        int notPick=dfs(events, idx+1,choose, n,k,dp);\\n        return dp[idx][choose]= Math.max(pick,notPick);\\n    }\\n    public int findNext(int[][] events, int idx, int n){\\n        int ans=n;\\n        int l=idx+1;\\n        int r=n-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(events[idx][1]<events[mid][0]){\\n                ans=mid;\\n                r=mid-1;\\n            }else {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n int n=events.length;\\n      \\n       Arrays.sort(events, (a, b) ->  Integer.compare(a[0], b[0]) );\\n        Integer[][] dp=new Integer[n][k];\\n        return dfs(events,0,0,n,k,dp);\\n    }\\n    \\n    public int dfs(int[][] events, int idx,int choose, int n,int k,Integer[][] dp){\\n        if(idx>=n)return 0;\\n        if(choose>=k)return 0;\\n        if(dp[idx][choose]!=null)return dp[idx][choose];\\n        int nextIdx=findNext(events, idx,n);\\n        int pick=events[idx][2]+dfs(events, nextIdx,choose+1, n,k,dp);\\n        int notPick=dfs(events, idx+1,choose, n,k,dp);\\n        return dp[idx][choose]= Math.max(pick,notPick);\\n    }\\n    public int findNext(int[][] events, int idx, int n){\\n        int ans=n;\\n        int l=idx+1;\\n        int r=n-1;\\n        while(l<=r){\\n            int mid=l+(r-l)/2;\\n            if(events[idx][1]<events[mid][0]){\\n                ans=mid;\\n                r=mid-1;\\n            }else {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int jobScheduling(int[] startTime, int[] endTime, int[] profit) {\\n        int n=startTime.length;\\n        int[][] events=new int[n][3];\\n        for(int i=0;i<n;i++){\\n            events[i][0]=startTime[i];\\n            events[i][1]=endTime[i];\\n            events[i][2]=profit[i];\\n        }\\n        Arrays.sort(events,(a,b)->Integer.compare(a[0], b[0]));\\n        Integer[] dp=new Integer[n];\\n        return dfs(events,0,n,dp);\\n    }\\n    \\n    public int dfs(int[][] events, int idx, int n,Integer[] dp){\\n        if(idx==n)return 0;\\n        if(dp[idx]!=null)return dp[idx];\\n        int nextIdx=findNext(events, idx,n);\\n        int pick=events[idx][2]+dfs(events, nextIdx, n,dp);\\n        int notPick=dfs(events, idx+1, n,dp);\\n        return dp[idx]= Math.max(pick,notPick);\\n    }\\n    public int findNext(int[][] events, int idx, int n){\\n        int ans=n;\\n        int l=idx+1;\\n        int r=n-1;\\n        while(l<=r){\\n            int mid=(l+r)>>1;\\n            if(events[idx][1]<=events[mid][0]){\\n                ans=mid;\\n                r=mid-1;\\n            }else {\\n                l=mid+1;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2338423,
                "title": "java-98-fast-iterative-with-comments",
                "content": "```class Solution {\\n    \\n    public int maxValue(int[][] events, int k) {\\n        int max = 0; \\n        if (k == 1) {\\n            // just return the highest value\\n            for(int [] event : events) \\n                max = Math.max(max, event[2]);\\n           \\n            return max;\\n        }\\n       \\n        // sort the events based on start time\\n        Arrays.sort(events, (a,b) -> Integer.compare(a[0], b[0]));\\n        int size = events.length;\\n       \\n        int[][] cache = new int[size + 1][k + 1];\\n       \\n\\t   // if you want to create a recursive method, you can break off the rest of the code into a DFS method\\n\\t   \\n\\t   // looping through each event from the back\\n        for (int i = size - 1; i >= 0; i--) {\\n            // find the next available event (next event\\'s start must be after current event\\'s end)\\n            int next = binarySearch(events, events[i][1], i + 1, size);\\n            \\n            for (int j = 1; j <= k; j++) {\\n                // we have 2 choices: attend current event OR skip current & attend the next available event\\n                cache[i][j] = Math.max(cache[i + 1][j], // current event\\n                                       cache[next][j - 1] + events[i][2]); // last event + next available event\\n            }\\n        }\\n        return cache[0][k];\\n    }\\n\\n    // search for next available event that starts after current event ends\\n    private int binarySearch(int[][] events, int targetEnd, int lo, int hi) {\\n        while (lo < hi) {\\n            int mid = (hi - lo) / 2 + lo;\\n            if (targetEnd >= events[mid][0]) {\\n                lo = mid + 1;\\n            } else {\\n                hi = mid;\\n            }\\n        }\\n        return lo;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    \\n    public int maxValue(int[][] events, int k) {\\n        int max = 0; \\n        if (k == 1) {\\n            // just return the highest value\\n            for(int [] event : events) \\n                max = Math.max(max, event[2]);\\n           \\n            return max;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2204293,
                "title": "python-recursion-lru-cache-binary-search-3-lines-only",
                "content": "3 liner ( Using Lambda function and Bisect)\\n```\\nclass Solution:\\n    def maxValue(self, x: List[List[int]], k: int) -> int:\\n        x.sort()\\n        f=lru_cache(None)(lambda i,k:0 if i==len(x) or k==0 else max(f(i+1,k),x[i][2]+f(bisect_left(x,[x[i][1]+1,-inf]),k-1)))\\n        return f(0,k)\\n```\\nWithout using (without Using Lambda function or Bisect)\\n```\\nclass Solution:\\n    def maxValue(self, x: List[List[int]], k: int) -> int:\\n        n=len(x)\\n        x.sort()\\n        @lru_cache(None)\\n        def f(i,k):\\n            if i==n or k==0:return 0\\n            def binse(e):\\n                l=i\\n                h=n-1\\n                ans=n\\n                while l<=h:\\n                    m=(l+h)//2\\n                    if x[m][0]>=e:\\n                        ans=m\\n                        h=m-1\\n                    else:\\n                        l=m+1\\n                return ans          \\n            return max(f(i+1,k),x[i][2]+f(binse(x[i][1]+1),k-1))\\n        return f(0,k)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxValue(self, x: List[List[int]], k: int) -> int:\\n        x.sort()\\n        f=lru_cache(None)(lambda i,k:0 if i==len(x) or k==0 else max(f(i+1,k),x[i][2]+f(bisect_left(x,[x[i][1]+1,-inf]),k-1)))\\n        return f(0,k)\\n```\n```\\nclass Solution:\\n    def maxValue(self, x: List[List[int]], k: int) -> int:\\n        n=len(x)\\n        x.sort()\\n        @lru_cache(None)\\n        def f(i,k):\\n            if i==n or k==0:return 0\\n            def binse(e):\\n                l=i\\n                h=n-1\\n                ans=n\\n                while l<=h:\\n                    m=(l+h)//2\\n                    if x[m][0]>=e:\\n                        ans=m\\n                        h=m-1\\n                    else:\\n                        l=m+1\\n                return ans          \\n            return max(f(i+1,k),x[i][2]+f(binse(x[i][1]+1),k-1))\\n        return f(0,k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2203345,
                "title": "dp-memoization-with-binary-search-c",
                "content": "\\u261E **Plz upvote if it helps**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint bs(vector<vector<int>> &nums,int l,int r,int tar){\\n\\t\\t\\t\\twhile(l<=r){\\n\\t\\t\\t\\t\\tint mid=(l+r)/2;\\n\\t\\t\\t\\t\\tif(nums[mid][0]<=tar){\\n\\t\\t\\t\\t\\t\\tl=mid+1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\tr=mid-1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn l;\\n\\t\\t\\t}\\n\\t\\t\\tvector<vector<int>>dp;\\n\\t\\t\\tint solve(vector<vector<int>> &nums,int k,int n,int pos){\\n\\t\\t\\t\\t// If there is no event left or we cannot attend more event\\n\\t\\t\\t\\tif(k==0 || pos>=n) return 0;\\n\\n\\t\\t\\t\\tif(dp[pos][k]!=-1) return dp[pos][k];\\n\\n\\t\\t\\t\\t// Next event pos that can be attended if we attend the current event\\n\\t\\t\\t\\tint nextPos = bs(nums,pos+1,n-1,nums[pos][1]);\\n\\n\\t\\t\\t\\t// If we attend the current event then search for next event that can be attended\\n\\t\\t\\t\\tint attendEvent = nums[pos][2] + solve(nums,k-1,n,nextPos);\\n\\n\\t\\t\\t\\t// If we didn\\'t attend the current event\\n\\t\\t\\t\\tint notAttendEvent = solve(nums,k,n,pos+1);\\n\\n\\t\\t\\t\\treturn dp[pos][k] = max(attendEvent,notAttendEvent);\\n\\t\\t\\t}\\n\\t\\t\\tint maxValue(vector<vector<int>>& events, int k) {\\n\\t\\t\\t\\t// Sort according to the startTime\\n\\t\\t\\t\\tsort(events.begin(),events.end());\\n\\n\\t\\t\\t\\tint n=events.size();\\n\\t\\t\\t\\tdp.assign(n,vector<int>(k+1,-1));\\n\\n\\t\\t\\t\\treturn solve(events,k,n,0);\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint bs(vector<vector<int>> &nums,int l,int r,int tar){\\n\\t\\t\\t\\twhile(l<=r){\\n\\t\\t\\t\\t\\tint mid=(l+r)/2;\\n\\t\\t\\t\\t\\tif(nums[mid][0]<=tar){\\n\\t\\t\\t\\t\\t\\tl=mid+1;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2036104,
                "title": "c-recursive-dp-solution",
                "content": "Approach: We use the simple idea that an event can be included or excluded. If we include an event , then it will decrease k by 1 else k will remain same. When attending an event, we know we cannot attend an overlapping event, so we need nect index which has startTime > current EndTime. We can find this using binary search by sorting all events according to start time.\\n\\n```\\nclass Solution {\\npublic:\\n    int findNonOverlappingNextInterval( vector<vector<int>>& jobs, int ind){\\n        int n = jobs.size() , low = ind+1, high = n-1 , ans = n ;\\n        while(low <= high ){\\n            int mid = low + ( high - low )/2 ;\\n            if(jobs[mid][0] > jobs[ind][1]){\\n                ans = mid ;\\n                high = mid-1 ;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n        return ans ;\\n    }\\n    \\n    int cal(int ind,int k, vector<vector<int>>& jobs, vector<vector<int>>&dp){\\n        if(ind == -1 || ind == jobs.size() || k<=0)\\n            return 0 ;\\n        if(dp[ind][k] != -1)\\n            return dp[ind][k] ;\\n        \\n        int nextInd = findNonOverlappingNextInterval(jobs, ind);\\n       \\n        int inc =  jobs[ind][2] + cal(nextInd,k-1, jobs, dp) ;\\n       \\n        int exc = cal(ind+1,k ,jobs, dp) ;\\n        \\n        return dp[ind][k] = max(inc, exc) ;\\n    }\\n    int maxValue(vector<vector<int>>&jobs, int k) {\\n        int sz = jobs.size() ;\\n        sort(jobs.begin(), jobs.end()) ;\\n        vector<vector<int>>dp(sz+1, vector<int>(k+1, -1)) ;\\n        return cal(0,k, jobs, dp) ;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int findNonOverlappingNextInterval( vector<vector<int>>& jobs, int ind){\\n        int n = jobs.size() , low = ind+1, high = n-1 , ans = n ;\\n        while(low <= high ){\\n            int mid = low + ( high - low )/2 ;\\n            if(jobs[mid][0] > jobs[ind][1]){\\n                ans = mid ;\\n                high = mid-1 ;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n        return ans ;\\n    }\\n    \\n    int cal(int ind,int k, vector<vector<int>>& jobs, vector<vector<int>>&dp){\\n        if(ind == -1 || ind == jobs.size() || k<=0)\\n            return 0 ;\\n        if(dp[ind][k] != -1)\\n            return dp[ind][k] ;\\n        \\n        int nextInd = findNonOverlappingNextInterval(jobs, ind);\\n       \\n        int inc =  jobs[ind][2] + cal(nextInd,k-1, jobs, dp) ;\\n       \\n        int exc = cal(ind+1,k ,jobs, dp) ;\\n        \\n        return dp[ind][k] = max(inc, exc) ;\\n    }\\n    int maxValue(vector<vector<int>>&jobs, int k) {\\n        int sz = jobs.size() ;\\n        sort(jobs.begin(), jobs.end()) ;\\n        vector<vector<int>>dp(sz+1, vector<int>(k+1, -1)) ;\\n        return cal(0,k, jobs, dp) ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1857174,
                "title": "why-does-dp-not-work-when-you-sort-by-end-time",
                "content": "you have to sort by start time. Why can\\'t you sort by end time and then iterate through until you find one that has a start time after the end time of the one you picked",
                "solutionTags": [],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 1803360,
                "title": "c-simple-bottom-up-2d-dp-with-explanation",
                "content": "**General Idea**\\nWe will use bottom up DP to solve this problem with the following state and transitions.\\nThe reason we have to use DP instead of greedy is because choosing event `i` could result\\nin later overlapping events with large value(`INF`) being passed on but passing on event `i` could\\nresult in a wrong answer if event `i` has (`INF`) value.\\n\\n**DP State** - `dp[i][j]`\\n* Represents the maximum score at the end of `events[i]`\\'s end time with `j` events selected.\\n\\n**DP Transition** - when processing event `i` we could:\\n* Choosing current event:\\n  * Logically, this means choosing the current events with the maximum valid combination of previous\\n  events that do not overlap with the current event.\\n  * The value will be equals to `events[i]`\\'s value sum with `dp[k][j-1]` where `k` is the event with\\n  end time strictly less than the current event start time.\\n  * `dp[k][j-1]`: represents a combination of `j-1` previous events that has the maximum value and\\n  do not overlap with the current event\\n* Passing on the current event:\\n  * Value Equals to `dp[i-1][j]` as it represents the combination of previous `j` events\\n* Final dp transition: `dp[i][j] = max(dp[i-1][j], events[i][2] + dp[k][j-1])`\\n\\n\\n### Implementation\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        events.push_back({0,0,0});\\n        int n = events.size();\\n        sort(events.begin(), events.end(), [](const auto& a, const auto& b){return a[1] < b[1];});\\n        vector<int> end_times(n,0);\\n        for (int i = 0; i < n; i++) end_times[i] = events[i][1];\\n\\n        vector<vector<int>> dp(n, vector<int>(k+1, 0));\\n        int ret = 0;\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < k+1; j++) {\\n                auto it = lower_bound(end_times.begin(), end_times.end(), events[i][0]);\\n                assert(it != end_times.end());\\n                assert(it != end_times.begin());\\n                it--;\\n                int k = std::distance(end_times.begin(), it);\\n                dp[i][j] = max(events[i][2] + dp[k][j-1], dp[i-1][j]);\\n                ret = max(ret, dp[i][j]);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        events.push_back({0,0,0});\\n        int n = events.size();\\n        sort(events.begin(), events.end(), [](const auto& a, const auto& b){return a[1] < b[1];});\\n        vector<int> end_times(n,0);\\n        for (int i = 0; i < n; i++) end_times[i] = events[i][1];\\n\\n        vector<vector<int>> dp(n, vector<int>(k+1, 0));\\n        int ret = 0;\\n        for (int i = 1; i < n; i++) {\\n            for (int j = 1; j < k+1; j++) {\\n                auto it = lower_bound(end_times.begin(), end_times.end(), events[i][0]);\\n                assert(it != end_times.end());\\n                assert(it != end_times.begin());\\n                it--;\\n                int k = std::distance(end_times.begin(), it);\\n                dp[i][j] = max(events[i][2] + dp[k][j-1], dp[i-1][j]);\\n                ret = max(ret, dp[i][j]);\\n            }\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1631018,
                "title": "c-solution",
                "content": "DFS\\n```\\npublic class Solution {\\n    public int MaxValue(int[][] events, int k) {\\n        List<(int s, int e, int v)> es = new List<(int s, int e, int v)>();\\n        foreach (int[] e in events) es.Add((e[0], e[1], e[2]));\\n        \\n        es.Sort((x, y) => x.s.CompareTo(y.s));\\n        \\n        int r = 0;\\n        Dictionary<string, int> v = new Dictionary<string, int>();\\n        for (int i = 0; i < es.Count; ++i) {\\n            r = Math.Max(r, DFS(i, 0, k, es, v));\\n        }\\n        \\n        return r;\\n    }\\n    \\n    public int DFS(int si, int att, int k, List<(int s, int e, int v)> ev, Dictionary<string, int> v) {\\n        if (si >= ev.Count || att == k) return 0;\\n\\t\\t\\n\\t\\tstring vk = \"si: \" + si + \" att: \" + att;\\n        else if (v.ContainsKey(vk)) return v[vk];\\n\\n        int next = FindNextEvent(si, ev);\\n\\n        int inc = ev[si].v + (next == -1 ? 0 : DFS(next, att + 1, k, ev, v));\\n        int exc = DFS(si + 1, att, k, ev, v);\\n        \\n        v[vk] = Math.Max(inc, exc);\\n        \\n        return v[vk];\\n        \\n    }\\n    \\n    public int FindNextEvent(int prev, List<(int s, int e, int v)> ev) {\\n        for (int i = prev + 1; i < ev.Count; ++i) {\\n            if (ev[i].s > ev[prev].e) {\\n                return i;\\n            }\\n        }\\n\\t\\t\\n        return -1;\\n    }\\n}\\n```\\n\\nBinary Search + DFS\\n```\\npublic class Solution {\\n    public int MaxValue(int[][] events, int k) {\\n        Array.Sort(events, (x, y) => x[0] == y[0] ? x[1] - y[1] : x[0] - y[0]);\\n        int[] next = new int[events.Length];\\n        for (int i = 0; i < events.Length; ++i) {\\n            int l = i, r = events.Length - 1;\\n            while (l < r) {\\n                int m = l + (r - l) / 2;\\n                if (events[m][0] > events[i][1]) {\\n                    r = m;\\n                } else {\\n                    l = m + 1;\\n                }\\n            }\\n            \\n            if (events[l][0] <= events[i][1]) l++;\\n            next[i] = l;\\n        }\\n        \\n        int[,] dp = new int[events.Length + 1, k + 1];\\n        for (int i = 0; i < dp.GetLength(0); ++i)\\n            for (int j = 0; j < dp.GetLength(1); ++j)\\n                dp[i, j] = -1;\\n        \\n        return DFS(events, 0, 0, k, next, dp);\\n    }\\n    \\n    public int DFS(int[][] ev, int pos, int ec, int k, int[] next, int[,] dp) {\\n        if (pos >= ev.Length || ec == k) return 0;\\n        if (dp[pos, ec] != -1) return dp[pos, ec];\\n        int nx = next[pos];\\n        return dp[pos, ec] = Math.Max(DFS(ev, pos + 1, ec, k, next, dp), ev[pos][2] + DFS(ev, nx, ec + 1, k, next, dp));\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int MaxValue(int[][] events, int k) {\\n        List<(int s, int e, int v)> es = new List<(int s, int e, int v)>();\\n        foreach (int[] e in events) es.Add((e[0], e[1], e[2]));\\n        \\n        es.Sort((x, y) => x.s.CompareTo(y.s));\\n        \\n        int r = 0;\\n        Dictionary<string, int> v = new Dictionary<string, int>();\\n        for (int i = 0; i < es.Count; ++i) {\\n            r = Math.Max(r, DFS(i, 0, k, es, v));\\n        }\\n        \\n        return r;\\n    }\\n    \\n    public int DFS(int si, int att, int k, List<(int s, int e, int v)> ev, Dictionary<string, int> v) {\\n        if (si >= ev.Count || att == k) return 0;\\n\\t\\t\\n\\t\\tstring vk = \"si: \" + si + \" att: \" + att;\\n        else if (v.ContainsKey(vk)) return v[vk];\\n\\n        int next = FindNextEvent(si, ev);\\n\\n        int inc = ev[si].v + (next == -1 ? 0 : DFS(next, att + 1, k, ev, v));\\n        int exc = DFS(si + 1, att, k, ev, v);\\n        \\n        v[vk] = Math.Max(inc, exc);\\n        \\n        return v[vk];\\n        \\n    }\\n    \\n    public int FindNextEvent(int prev, List<(int s, int e, int v)> ev) {\\n        for (int i = prev + 1; i < ev.Count; ++i) {\\n            if (ev[i].s > ev[prev].e) {\\n                return i;\\n            }\\n        }\\n\\t\\t\\n        return -1;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MaxValue(int[][] events, int k) {\\n        Array.Sort(events, (x, y) => x[0] == y[0] ? x[1] - y[1] : x[0] - y[0]);\\n        int[] next = new int[events.Length];\\n        for (int i = 0; i < events.Length; ++i) {\\n            int l = i, r = events.Length - 1;\\n            while (l < r) {\\n                int m = l + (r - l) / 2;\\n                if (events[m][0] > events[i][1]) {\\n                    r = m;\\n                } else {\\n                    l = m + 1;\\n                }\\n            }\\n            \\n            if (events[l][0] <= events[i][1]) l++;\\n            next[i] = l;\\n        }\\n        \\n        int[,] dp = new int[events.Length + 1, k + 1];\\n        for (int i = 0; i < dp.GetLength(0); ++i)\\n            for (int j = 0; j < dp.GetLength(1); ++j)\\n                dp[i, j] = -1;\\n        \\n        return DFS(events, 0, 0, k, next, dp);\\n    }\\n    \\n    public int DFS(int[][] ev, int pos, int ec, int k, int[] next, int[,] dp) {\\n        if (pos >= ev.Length || ec == k) return 0;\\n        if (dp[pos, ec] != -1) return dp[pos, ec];\\n        int nx = next[pos];\\n        return dp[pos, ec] = Math.Max(DFS(ev, pos + 1, ec, k, next, dp), ev[pos][2] + DFS(ev, nx, ec + 1, k, next, dp));\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615189,
                "title": "js-beat-50-speed-100-space",
                "content": "```\\n/**\\n * @param {number[][]} events\\n * @param {number} k\\n * @return {number}\\n */\\n var maxValue = function (events, k) {\\n    // sort the events\\n    events.sort((a,b) => a[1] - b[1]);\\n    // findMaxMeeting\\n    return findMaxMeeting(events, k);\\n};\\n\\nvar findMaxMeeting = function (events, k) {\\n    let maxValue = new Array(events.length).fill(0).map(() => new Array(k + 1).fill(0));\\n    maxValue[0][1] = events[0][2];\\n    let ans = maxValue[0][1];\\n\\n    for (let i = 1; i < events.length; i++) {\\n        for (let j = 1; j <= Math.min(k, i + 1); j++) {\\n            maxValue[i][j] = Math.max(events[i][2], maxValue[i - 1][j]);\\n            let closestMeetingIndex = findClosestMeeting(events, i);\\n            if (closestMeetingIndex != -1) {\\n                maxValue[i][j] = Math.max(maxValue[i][j], maxValue[closestMeetingIndex][j - 1] + events[i][2]);\\n            }\\n            ans = Math.max(ans, maxValue[i][j]);\\n        }\\n    }\\n\\n    return ans;\\n}\\n\\nvar findClosestMeeting = function (events, currentIndex) {\\n    let start = 0;\\n    let end = currentIndex - 1;\\n    let targetIndex = -1;\\n\\n    while (start <= end) {\\n        let mid = Math.floor((start + end) / 2);\\n        if (events[mid][1] < events[currentIndex][0]) {\\n            targetIndex = mid;\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n\\n    return targetIndex;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[][]} events\\n * @param {number} k\\n * @return {number}\\n */\\n var maxValue = function (events, k) {\\n    // sort the events\\n    events.sort((a,b) => a[1] - b[1]);\\n    // findMaxMeeting\\n    return findMaxMeeting(events, k);\\n};\\n\\nvar findMaxMeeting = function (events, k) {\\n    let maxValue = new Array(events.length).fill(0).map(() => new Array(k + 1).fill(0));\\n    maxValue[0][1] = events[0][2];\\n    let ans = maxValue[0][1];\\n\\n    for (let i = 1; i < events.length; i++) {\\n        for (let j = 1; j <= Math.min(k, i + 1); j++) {\\n            maxValue[i][j] = Math.max(events[i][2], maxValue[i - 1][j]);\\n            let closestMeetingIndex = findClosestMeeting(events, i);\\n            if (closestMeetingIndex != -1) {\\n                maxValue[i][j] = Math.max(maxValue[i][j], maxValue[closestMeetingIndex][j - 1] + events[i][2]);\\n            }\\n            ans = Math.max(ans, maxValue[i][j]);\\n        }\\n    }\\n\\n    return ans;\\n}\\n\\nvar findClosestMeeting = function (events, currentIndex) {\\n    let start = 0;\\n    let end = currentIndex - 1;\\n    let targetIndex = -1;\\n\\n    while (start <= end) {\\n        let mid = Math.floor((start + end) / 2);\\n        if (events[mid][1] < events[currentIndex][0]) {\\n            targetIndex = mid;\\n            start = mid + 1;\\n        } else {\\n            end = mid - 1;\\n        }\\n    }\\n\\n    return targetIndex;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1577878,
                "title": "why-a-priorityqueue-solution-doesn-t-work",
                "content": "Its not passing few testcases:\\n\\n```\\npublic int maxValue(int[][] events, int k) {\\n        if (k == 1) {\\n            return Arrays.stream(events).max(Comparator.comparingInt(e -> e[2])).get()[2];\\n        }\\n        Arrays.sort(events, (a,b)-> Integer.compare(a[0], b[0]));\\n       // System.out.println(Arrays.deepToString(events));\\n        int maxSum = 0;\\n        int minSum = Integer.MAX_VALUE;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[0] - b[0]);\\n        \\n        for(int i=0; i<events.length; i++){\\n            int start = events[i][0];\\n            int end = events[i][1];\\n            int sum = events[i][2];\\n            int cnt = 0;\\n            while(!pq.isEmpty() && pq.peek()[0] < start){\\n                int[] t = pq.poll();\\n                if(t[1] > maxSum){\\n                    maxSum = t[1];\\n                    cnt = t[2];\\n                }\\n                minSum = Math.min(minSum, t[1]);\\n            }\\n            if(cnt>=k){\\n                 maxSum -= minSum;\\n                 pq.add(new int[]{end, sum+maxSum, cnt});\\n            }\\n            else \\n                pq.add(new int[]{end, sum+maxSum, cnt+1});\\n            //System.out.println(Arrays.deepToString(pq.toArray()));\\n        }        \\n        while (!pq.isEmpty()) {\\n            maxSum = Math.max(maxSum, pq.poll()[1]);\\n        }\\n        return maxSum; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxValue(int[][] events, int k) {\\n        if (k == 1) {\\n            return Arrays.stream(events).max(Comparator.comparingInt(e -> e[2])).get()[2];\\n        }\\n        Arrays.sort(events, (a,b)-> Integer.compare(a[0], b[0]));\\n       // System.out.println(Arrays.deepToString(events));\\n        int maxSum = 0;\\n        int minSum = Integer.MAX_VALUE;\\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a,b) -> a[0] - b[0]);\\n        \\n        for(int i=0; i<events.length; i++){\\n            int start = events[i][0];\\n            int end = events[i][1];\\n            int sum = events[i][2];\\n            int cnt = 0;\\n            while(!pq.isEmpty() && pq.peek()[0] < start){\\n                int[] t = pq.poll();\\n                if(t[1] > maxSum){\\n                    maxSum = t[1];\\n                    cnt = t[2];\\n                }\\n                minSum = Math.min(minSum, t[1]);\\n            }\\n            if(cnt>=k){\\n                 maxSum -= minSum;\\n                 pq.add(new int[]{end, sum+maxSum, cnt});\\n            }\\n            else \\n                pq.add(new int[]{end, sum+maxSum, cnt+1});\\n            //System.out.println(Arrays.deepToString(pq.toArray()));\\n        }        \\n        while (!pq.isEmpty()) {\\n            maxSum = Math.max(maxSum, pq.poll()[1]);\\n        }\\n        return maxSum; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1562298,
                "title": "tabulated-dp-c",
                "content": "```\\nint maxValue(vector<vector<int>> &events, int k) {\\n\\tsort(events.begin(), events.end());\\n\\tint n = events.size();\\n\\tmap<int, int> mp;\\n\\tfor (int i = 0; i <= n - 1; ++i) {\\n\\t\\tif (not mp.count(events[i][0])) {\\n\\t\\t\\tmp[events[i][0]] = i;\\n\\t\\t}\\n\\t}\\n\\n\\tvector<vector<int>> dp(n, vector<int>(k + 1));\\n\\tfor (int i = 1; i <= k; ++i) {\\n\\t\\tdp[n - 1][i] = events[n - 1][2];\\n\\t}\\n\\n\\tfor (int i = n - 2; i >= 0; --i) {\\n\\t\\tauto it = mp.upper_bound(events[i][1]);\\n\\t\\tfor (int j = 1; j <= k; ++j) {\\n\\t\\t\\tdp[i][j] = max(events[i][2], dp[i + 1][j]);\\n\\t\\t\\tif (it != mp.end()) {\\n\\t\\t\\t\\tint x = it->second;\\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j], events[i][2] + dp[x][j - 1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[0][k];\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint maxValue(vector<vector<int>> &events, int k) {\\n\\tsort(events.begin(), events.end());\\n\\tint n = events.size();\\n\\tmap<int, int> mp;\\n\\tfor (int i = 0; i <= n - 1; ++i) {\\n\\t\\tif (not mp.count(events[i][0])) {\\n\\t\\t\\tmp[events[i][0]] = i;\\n\\t\\t}\\n\\t}\\n\\n\\tvector<vector<int>> dp(n, vector<int>(k + 1));\\n\\tfor (int i = 1; i <= k; ++i) {\\n\\t\\tdp[n - 1][i] = events[n - 1][2];\\n\\t}\\n\\n\\tfor (int i = n - 2; i >= 0; --i) {\\n\\t\\tauto it = mp.upper_bound(events[i][1]);\\n\\t\\tfor (int j = 1; j <= k; ++j) {\\n\\t\\t\\tdp[i][j] = max(events[i][2], dp[i + 1][j]);\\n\\t\\t\\tif (it != mp.end()) {\\n\\t\\t\\t\\tint x = it->second;\\n\\t\\t\\t\\tdp[i][j] = max(dp[i][j], events[i][2] + dp[x][j - 1]);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn dp[0][k];\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1278438,
                "title": "simple-dp-solution-c-beats-90",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int K) {\\n        int n = events.size();\\n        \\n        auto comp = [&] (vector<int> &a, vector<int> &b) {\\n            return a[1] < b[1];\\n        };\\n        \\n        sort(events.begin(), events.end(), comp);\\n        \\n        // this will store the last non-overlapping event before event_i\\n        int prevIndex[n];\\n        \\n        for(int i=0; i<n; i++) {\\n            prevIndex[i] = -1;\\n            int low = 0, high = i-1;\\n            \\n            while(low <= high) {\\n                int mid = low + (high-low)/2;\\n                \\n                if(events[mid][1] < events[i][0]) {\\n                    prevIndex[i] = mid;\\n                    low = mid + 1;\\n                } else high = mid-1;\\n            }\\n        }\\n        \\n        vector<int> prev(n, 0);\\n        \\n        for(int k=1; k<=K; k++) {\\n            vector<int> cur(n);\\n            \\n            for(int i=0; i<n; i++) {\\n                cur[i] = events[i][2];\\n                int idx = prevIndex[i];\\n                \\n                // our answer either includes the current event or excludes it::\\n                if(idx!=-1) cur[i] = max(cur[i], prev[idx] + events[i][2]);\\n                if(i>0) cur[i] = max(cur[i], cur[i-1]);\\n            }\\n            \\n            prev = cur;\\n        }\\n        \\n        return prev[n-1];\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int K) {\\n        int n = events.size();\\n        \\n        auto comp = [&] (vector<int> &a, vector<int> &b) {\\n            return a[1] < b[1];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1128787,
                "title": "c-just-a-memoization-dfs-and-treemap-tp-accelerate-the-lookup",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    #define vi vector<int>\\n#define vii vector<vector<int>>\\n\\nint f(int idx, int k, vii &events, vii &tab, std::map<int, int> &map)\\n{\\n    \\n \\n    const size_t len = events.size();\\n    if (idx >= len || k <= 0)\\n        return 0;\\n    if (tab[idx][k] != -1)\\n        return tab[idx][k];\\n  \\n    int take = events[idx][2];\\n  \\n    auto ptr = map.upper_bound(events[idx][1]);\\n    if (ptr != map.end())\\n        take += f(ptr->second, k - 1, events, tab, map);\\n    \\n    tab[idx][k] = std::max(f(idx + 1, k, events, tab, map), take);\\n   \\n    return tab[idx][k];\\n}\\n\\nint maxValue(vector<vector<int>> &events, int k)\\n{\\n    std::sort(events.begin(), events.end(), [](vi &a, vi &b) -> bool { return a[0] != b[0] ? a[0] < b[0] : a[1] < b[1]; });\\n    std::map<int, int> map;\\n    for (int i = 0; i < events.size(); i++)\\n        if (map.find(events[i][0]) == map.end())\\n            map.emplace(events[i][0], i);\\n\\n    vii tab(events.size(), vi(k + 1, -1));\\n    return f(0, k, events, tab, map);\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    #define vi vector<int>\\n#define vii vector<vector<int>>\\n\\nint f(int idx, int k, vii &events, vii &tab, std::map<int, int> &map)\\n{\\n    \\n \\n    const size_t len = events.size();\\n    if (idx >= len || k <= 0)\\n        return 0;\\n    if (tab[idx][k] != -1)\\n        return tab[idx][k];\\n  \\n    int take = events[idx][2];\\n  \\n    auto ptr = map.upper_bound(events[idx][1]);\\n    if (ptr != map.end())\\n        take += f(ptr->second, k - 1, events, tab, map);\\n    \\n    tab[idx][k] = std::max(f(idx + 1, k, events, tab, map), take);\\n   \\n    return tab[idx][k];\\n}\\n\\nint maxValue(vector<vector<int>> &events, int k)\\n{\\n    std::sort(events.begin(), events.end(), [](vi &a, vi &b) -> bool { return a[0] != b[0] ? a[0] < b[0] : a[1] < b[1]; });\\n    std::map<int, int> map;\\n    for (int i = 0; i < events.size(); i++)\\n        if (map.find(events[i][0]) == map.end())\\n            map.emplace(events[i][0], i);\\n\\n    vii tab(events.size(), vi(k + 1, -1));\\n    return f(0, k, events, tab, map);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104568,
                "title": "c-max-profit-in-job-selection",
                "content": "```\\n\\tint n;\\n    vector<vector<int>> dp;\\n    \\n    int nextEvent(vector<vector<int>> &events, int i) {\\n        int l = i+1, h = n-1;\\n        int currEnd = events[i][1];\\n        int j = n;\\n        \\n        while(l <= h) {\\n            int mid = l + (h-l)/2;\\n            int nextEnd = events[mid][0];\\n            \\n            if(currEnd < nextEnd) {\\n                // try to reduce more\\n                j = mid;\\n                h = mid-1;\\n            }\\n            else {\\n                l = mid+1;\\n            }\\n        }\\n        return j;\\n    }\\n    \\n    int go(vector<vector<int>>& events, int i, int k) {\\n        if(i == n) {\\n            return 0;\\n        }   \\n        \\n        if(dp[i][k] != -1) {\\n            return dp[i][k];\\n        }\\n        int &ans = dp[i][k];\\n        \\n        // skip event\\n        ans = go(events, i+1, k);\\n        \\n        // attend event if can, and look for next\\n        if(k > 0) {\\n            int value = events[i][2];\\n            int j = nextEvent(events, i);\\n            ans = max(ans, events[i][2] + go(events, j, k-1));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        n = events.size();\\n        sort(events.begin(), events.end());\\n        dp.assign(n+1, vector<int>(k+1, -1));\\n        return go(events, 0, k);   \\n    }\\n```",
                "solutionTags": [
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n\\tint n;\\n    vector<vector<int>> dp;\\n    \\n    int nextEvent(vector<vector<int>> &events, int i) {\\n        int l = i+1, h = n-1;\\n        int currEnd = events[i][1];\\n        int j = n;\\n        \\n        while(l <= h) {\\n            int mid = l + (h-l)/2;\\n            int nextEnd = events[mid][0];\\n            \\n            if(currEnd < nextEnd) {\\n                // try to reduce more\\n                j = mid;\\n                h = mid-1;\\n            }\\n            else {\\n                l = mid+1;\\n            }\\n        }\\n        return j;\\n    }\\n    \\n    int go(vector<vector<int>>& events, int i, int k) {\\n        if(i == n) {\\n            return 0;\\n        }   \\n        \\n        if(dp[i][k] != -1) {\\n            return dp[i][k];\\n        }\\n        int &ans = dp[i][k];\\n        \\n        // skip event\\n        ans = go(events, i+1, k);\\n        \\n        // attend event if can, and look for next\\n        if(k > 0) {\\n            int value = events[i][2];\\n            int j = nextEvent(events, i);\\n            ans = max(ans, events[i][2] + go(events, j, k-1));\\n        }\\n        \\n        return ans;\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n        n = events.size();\\n        sort(events.begin(), events.end());\\n        dp.assign(n+1, vector<int>(k+1, -1));\\n        return go(events, 0, k);   \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1062919,
                "title": "java-dp-binary-search",
                "content": "```\\nclass Solution {\\n    int[][] dp;\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        Arrays.sort(events, (a,b)->{\\n            if(Integer.compare(a[0],b[0])==0){\\n                return Integer.compare(a[1],b[1]);\\n            }\\n            else {\\n                return Integer.compare(a[0],b[0]);\\n            }\\n        });\\n        dp = new int[n+1][k+1];\\n        return helper(events, 0, k);\\n    }\\n    \\n    public int helper(int[][] events, int idx, int k){\\n        if(idx==events.length || k==0) return 0;\\n        if(dp[idx][k]!=0) return dp[idx][k];\\n        \\n        int lo = idx+1;\\n        int hi = events.length-1;\\n        int nextIdx = hi+1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(events[mid][0]>events[idx][1]){\\n                nextIdx = mid;\\n                hi = mid-1;\\n            }\\n            else {\\n                lo = mid+1;\\n            }\\n        }\\n        int res = 0;\\n            res = Math.max(events[idx][2]+helper(events, nextIdx, k-1), helper(events, idx+1, k));\\n\\n        dp[idx][k] = res;\\n        return dp[idx][k];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int[][] dp;\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n        Arrays.sort(events, (a,b)->{\\n            if(Integer.compare(a[0],b[0])==0){\\n                return Integer.compare(a[1],b[1]);\\n            }\\n            else {\\n                return Integer.compare(a[0],b[0]);\\n            }\\n        });\\n        dp = new int[n+1][k+1];\\n        return helper(events, 0, k);\\n    }\\n    \\n    public int helper(int[][] events, int idx, int k){\\n        if(idx==events.length || k==0) return 0;\\n        if(dp[idx][k]!=0) return dp[idx][k];\\n        \\n        int lo = idx+1;\\n        int hi = events.length-1;\\n        int nextIdx = hi+1;\\n        while(lo<=hi){\\n            int mid = (lo+hi)/2;\\n            if(events[mid][0]>events[idx][1]){\\n                nextIdx = mid;\\n                hi = mid-1;\\n            }\\n            else {\\n                lo = mid+1;\\n            }\\n        }\\n        int res = 0;\\n            res = Math.max(events[idx][2]+helper(events, nextIdx, k-1), helper(events, idx+1, k));\\n\\n        dp[idx][k] = res;\\n        return dp[idx][k];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1059715,
                "title": "python3-o-n-k-n-log-n-explained-no-bisect-no-recursion",
                "content": "### Preface:\\n\\nMost submitted solutions use bisect, but you can precompute preceding event for every event, so it runs **O(n\\\\*k + n\\\\*log(n))** instead of **O(n\\\\*k\\\\*log(n))**\\n\\n### Full explanation:\\n\\nLet\\'s consider we want to know max value achieved with **j** events attended. We can do it by iterating over all events and check sum of current event value with max value achieved with **j-1** events attended over preceding events. In case **j==1** we can get only current event value, no preceding events. Typical dynamic programming problem.\\n\\nThe only problem is see what events preceding current event. It can\\'t be solved with one sort by start or end date, but with two sorts we can build **preceding** array. It shows last (by end date) event which has end date before start of current event.\\n\\nTime complexity: **O(n\\\\*k + n\\\\*log(n))**\\nSpace complexity: **O(n)**\\n\\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events,n=sorted(events, key=lambda e:e[1]), len(events)\\n        events_start_sorted = sorted([(e[0], i) for i,e in enumerate(events)])\\n        preceding,j = [-1]*n,0\\n        for start, index in events_start_sorted:            \\n            while events[j][1]<start:\\n                j+=1\\n            preceding[index]=j-1\\n\\n        dp,res = [0]*n,0\\n        for j in range(1, k+1):\\n            max_value=-1\\n            dp_next=[-1]*n            \\n            for i in range(n):\\n                if j==1:\\n                    max_value=max(max_value, events[i][2])                    \\n                elif preceding[i]>=0 and dp[preceding[i]]>=0:\\n                    max_value=max(max_value, dp[preceding[i]]+events[i][2])\\n                dp_next[i]=max_value                \\n            dp=dp_next\\n            res=max(res, max_value)\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events,n=sorted(events, key=lambda e:e[1]), len(events)\\n        events_start_sorted = sorted([(e[0], i) for i,e in enumerate(events)])\\n        preceding,j = [-1]*n,0\\n        for start, index in events_start_sorted:            \\n            while events[j][1]<start:\\n                j+=1\\n            preceding[index]=j-1\\n\\n        dp,res = [0]*n,0\\n        for j in range(1, k+1):\\n            max_value=-1\\n            dp_next=[-1]*n            \\n            for i in range(n):\\n                if j==1:\\n                    max_value=max(max_value, events[i][2])                    \\n                elif preceding[i]>=0 and dp[preceding[i]]>=0:\\n                    max_value=max(max_value, dp[preceding[i]]+events[i][2])\\n                dp_next[i]=max_value                \\n            dp=dp_next\\n            res=max(res, max_value)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1056608,
                "title": "c-memorization-simple-solution-using-recursion",
                "content": "Steps\\n**1. Sort By end times, siilar to maximum non intersecting intervals problem.\\n2. Recursively check all possible combinations with memorization.\\n\\t1. consider with the event, then update the new \\'end_time\\'  of the event as max(old_end_time, event_end_time)\\n\\t2. Dont not consider the event.\\n\\t\\n**\\tMaximum of the above two cases.**\\n\\t\\n```\\nstruct comp{\\n    bool operator()(vector<int>& a, vector<int>& b)\\n    {\\n        return a[1] == b[1] ? a[0] < b[0] : a[0] < b[0];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    unordered_map<string, int> memo;\\n    int recur(int i, vector<vector<int>>& events, int k, int end)\\n    {\\n\\n        string memoS = to_string(i) + \" \" + to_string(k) + \" \" + to_string(end);\\n        if(k <= 0 || i >= events.size())\\n            return 0;\\n        else\\n        {\\n            if(memo.find(memoS) != memo.end())\\n                return memo[memoS];\\n            int ans = 0;\\n            \\n            //consider\\n            if(events[i][0] > end)\\n                ans = events[i][2] + recur(i + 1, events, k - 1, max(end, events[i][1]));\\n            \\n            //Not Consider\\n            ans = max(ans, recur(i + 1, events, k, end));\\n            memo[memoS] = ans;\\n            return ans;\\n        }\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n\\t//sort by end times\\n        sort(events.begin(), events.end(), comp());\\n\\n        return recur(0, events, k, -1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nstruct comp{\\n    bool operator()(vector<int>& a, vector<int>& b)\\n    {\\n        return a[1] == b[1] ? a[0] < b[0] : a[0] < b[0];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    unordered_map<string, int> memo;\\n    int recur(int i, vector<vector<int>>& events, int k, int end)\\n    {\\n\\n        string memoS = to_string(i) + \" \" + to_string(k) + \" \" + to_string(end);\\n        if(k <= 0 || i >= events.size())\\n            return 0;\\n        else\\n        {\\n            if(memo.find(memoS) != memo.end())\\n                return memo[memoS];\\n            int ans = 0;\\n            \\n            //consider\\n            if(events[i][0] > end)\\n                ans = events[i][2] + recur(i + 1, events, k - 1, max(end, events[i][1]));\\n            \\n            //Not Consider\\n            ans = max(ans, recur(i + 1, events, k, end));\\n            memo[memoS] = ans;\\n            return ans;\\n        }\\n    }\\n    \\n    int maxValue(vector<vector<int>>& events, int k) {\\n\\t//sort by end times\\n        sort(events.begin(), events.end(), comp());\\n\\n        return recur(0, events, k, -1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055596,
                "title": "java-memo-recursion-intuitive-solution",
                "content": "```\\nclass Solution {\\n    int dp[][];\\n    int help(int s[],int e[],int v[],int k,int prevEnd,int curr){\\n        if(k<=0)\\n            return 0;\\n        if(curr>=s.length)\\n            return 0;\\n        \\n        if(prevEnd<s[curr]){\\n            \\n            if(dp[curr][k]!=-1)\\n            return dp[curr][k];\\n            \\n            return dp[curr][k]=Math.max(v[curr]+help(s,e,v,k-1,e[curr],curr+1),help(s,e,v,k,prevEnd,curr+1));\\n        }\\n        \\n        else //if(prevEnd>=s[curr])\\n        {\\n            return help(s,e,v,k,prevEnd,curr+1);\\n        }\\n    }\\n    public int maxValue(int[][] events, int k) {\\n        int n=events.length;\\n        dp=new int[n][k+1];\\n        \\n        for(int i[]:dp)\\n            Arrays.fill(i,-1);\\n        \\n        Arrays.sort(events,(a,b)->a[0]-b[0]);\\n        int s[]=new int[n];\\n        int e[]=new int[n];\\n        int v[]=new int[n];\\n        \\n      \\n        for(int i=0;i<n;i++){\\n            s[i]=events[i][0];\\n        }\\n        for(int i=0;i<n;i++){\\n            e[i]=events[i][1];\\n        }\\n        for(int i=0;i<n;i++){\\n            v[i]=events[i][2];\\n        }\\n        \\n        return help(s,e,v,k,-1,0);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int dp[][];\\n    int help(int s[],int e[],int v[],int k,int prevEnd,int curr){\\n        if(k<=0)\\n            return 0;\\n        if(curr>=s.length)\\n            return 0;\\n        \\n        if(prevEnd<s[curr]){\\n            \\n            if(dp[curr][k]!=-1)\\n            return dp[curr][k];\\n            \\n            return dp[curr][k]=Math.max(v[curr]+help(s,e,v,k-1,e[curr],curr+1),help(s,e,v,k,prevEnd,curr+1));\\n        }\\n        \\n        else //if(prevEnd>=s[curr])\\n        {\\n            return help(s,e,v,k,prevEnd,curr+1);\\n        }\\n    }\\n    public int maxValue(int[][] events, int k) {\\n        int n=events.length;\\n        dp=new int[n][k+1];\\n        \\n        for(int i[]:dp)\\n            Arrays.fill(i,-1);\\n        \\n        Arrays.sort(events,(a,b)->a[0]-b[0]);\\n        int s[]=new int[n];\\n        int e[]=new int[n];\\n        int v[]=new int[n];\\n        \\n      \\n        for(int i=0;i<n;i++){\\n            s[i]=events[i][0];\\n        }\\n        for(int i=0;i<n;i++){\\n            e[i]=events[i][1];\\n        }\\n        for(int i=0;i<n;i++){\\n            v[i]=events[i][2];\\n        }\\n        \\n        return help(s,e,v,k,-1,0);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1055283,
                "title": "python-3-simple-dp-with-memorization",
                "content": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n\\t\\tevents.sort()\\n\\t\\tstarts = [x[0] for x in events]\\n\\t\\t@lru_cache(None)\\n\\t\\tdef dp(i, k):\\n\\t\\t\\tif k == 0 or i >= len(events):\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\treturn max(events[i][-1] + dp(bisect.bisect_right(starts, events[i][1]), k - 1), dp(i+1, k))\\n\\t\\treturn dp(0, k)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n\\t\\tevents.sort()\\n\\t\\tstarts = [x[0] for x in events]\\n\\t\\t@lru_cache(None)\\n\\t\\tdef dp(i, k):\\n\\t\\t\\tif k == 0 or i >= len(events):\\n\\t\\t\\t\\treturn 0\\n\\t\\t\\treturn max(events[i][-1] + dp(bisect.bisect_right(starts, events[i][1]), k - 1), dp(i+1, k))\\n\\t\\treturn dp(0, k)",
                "codeTag": "Java"
            },
            {
                "id": 1052844,
                "title": "dp-with-binary-search-o-k-logn",
                "content": "```\\nbool compare(vector<int> a,vector<int> b)\\n{\\n   \\n    return a[1]<b[1];\\n}\\n\\nint binarysearch(vector<vector<int>>& events,int idx)\\n{\\n    int start=0;\\n    int end=idx-1;\\n    int mid=(start+end)/2;\\n    int ans=-1;\\n    while(start<=end)\\n    {\\n        mid=(start+end)/2;\\n        if(events[mid][1]<events[idx][0])\\n        {\\n            ans=mid;\\n            start=mid+1;\\n        }\\n        else\\n        {\\n            end=mid-1;\\n        }\\n        \\n        \\n        \\n        \\n        \\n    }\\n    return ans;\\n    \\n}\\nclass Solution {\\npublic:\\n  int maxValue(vector<vector<int>>& events, int K) {\\n        \\n        int n=events.size();\\n        vector<vector<int> > dp(n,vector<int>(K+1,0));\\n        sort(events.begin(),events.end(),compare);\\n      \\n      for(int i=0;i<n;i++)\\n      {\\n          dp[i][1]=events[i][2];\\n      }\\n        \\n        for(int i=1;i<=K;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                \\n                 int l=binarysearch(events,j);\\n                 \\n                       if(l!=-1)\\n                      dp[j][i]=max(dp[j][i],dp[l][i-1]+events[j][2]);\\n                    if(j>0)\\n                      dp[j][i]=max(dp[j][i],dp[j-1][i]);\\n                  \\n                \\n              \\n                \\n               \\n                \\n                \\n            }\\n                \\n        }\\n      int maxi=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<=K;j++)\\n            {\\n              \\n                maxi=max(maxi,dp[i][j]);\\n                \\n                \\n            }\\n           \\n    \\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool compare(vector<int> a,vector<int> b)\\n{\\n   \\n    return a[1]<b[1];\\n}\\n\\nint binarysearch(vector<vector<int>>& events,int idx)\\n{\\n    int start=0;\\n    int end=idx-1;\\n    int mid=(start+end)/2;\\n    int ans=-1;\\n    while(start<=end)\\n    {\\n        mid=(start+end)/2;\\n        if(events[mid][1]<events[idx][0])\\n        {\\n            ans=mid;\\n            start=mid+1;\\n        }\\n        else\\n        {\\n            end=mid-1;\\n        }\\n        \\n        \\n        \\n        \\n        \\n    }\\n    return ans;\\n    \\n}\\nclass Solution {\\npublic:\\n  int maxValue(vector<vector<int>>& events, int K) {\\n        \\n        int n=events.size();\\n        vector<vector<int> > dp(n,vector<int>(K+1,0));\\n        sort(events.begin(),events.end(),compare);\\n      \\n      for(int i=0;i<n;i++)\\n      {\\n          dp[i][1]=events[i][2];\\n      }\\n        \\n        for(int i=1;i<=K;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                \\n                 int l=binarysearch(events,j);\\n                 \\n                       if(l!=-1)\\n                      dp[j][i]=max(dp[j][i],dp[l][i-1]+events[j][2]);\\n                    if(j>0)\\n                      dp[j][i]=max(dp[j][i],dp[j-1][i]);\\n                  \\n                \\n              \\n                \\n               \\n                \\n                \\n            }\\n                \\n        }\\n      int maxi=INT_MIN;\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<=K;j++)\\n            {\\n              \\n                maxi=max(maxi,dp[i][j]);\\n                \\n                \\n            }\\n           \\n    \\n        }\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052760,
                "title": "top-down-dp-binary-search-solution",
                "content": "This problem is a slight variation of the weighted job scheduling problem.\\n\\nFirst we sort our events array in increasing order of their starting time(we can also solve the problem by sorting the events by finishing time). This step helps us in avoiding the overlap efficiently.\\n\\nLet dp[index][k] indicate the maximum value we can acheive given that we are starting from \"index\" and can attend atmost k more events.\\n\\nAt each step, we have two options,\\n1) Either we don\\'t attend this event.\\n2) Or we can consider this event, add it\\'s value to our answer and then call the function from the first index which does not overlap with our current index. This step(calculation of next immediate non-overlapping index)  can be done in O(logN) time since the events array is sorted according to the start time. \\n\\nFollowing is the C++ code of the above logic,\\n```\\nclass Solution {\\npublic:\\n    int binsearch(vector<vector<int>> &events,int ftime,int index)\\n    {   \\n        int n = events.size();\\n        int low = index+1;\\n        int high = n-1;\\n        \\n        int ans = n;\\n        \\n        while(low<=high)\\n        {\\n            int mid = (low+high)/2;\\n            if(events[mid][0]>ftime)\\n            {\\n                ans=min(ans,mid);\\n                high = mid-1;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n        return ans;\\n    }\\n    int recfun(int index,int k,vector<vector<int>> &events,vector<vector<int> > &dp)\\n    {\\n        if(index==(int)events.size())return 0;\\n        \\n        if(k==0)\\n            return 0;\\n        \\n        if(dp[index][k]!=-1)\\n            return dp[index][k];\\n        \\n        int res = 0;\\n        int next = binsearch(events,events[index][1],index);\\n        res = max(recfun(index+1,k,events,dp),events[index][2]+recfun(next,k-1,events,dp));\\n        return dp[index][k]=res;\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        \\n        int n = events.size();\\n        vector<vector<int> > dp(n+5,vector<int>(k+4,-1));\\n        sort(events.begin(),events.end());\\n        return recfun(0,k,events,dp);\\n    }\\n};\\n```\\nDo upvote if you guys find this post helpful.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int binsearch(vector<vector<int>> &events,int ftime,int index)\\n    {   \\n        int n = events.size();\\n        int low = index+1;\\n        int high = n-1;\\n        \\n        int ans = n;\\n        \\n        while(low<=high)\\n        {\\n            int mid = (low+high)/2;\\n            if(events[mid][0]>ftime)\\n            {\\n                ans=min(ans,mid);\\n                high = mid-1;\\n            }\\n            else\\n                low = mid+1;\\n        }\\n        return ans;\\n    }\\n    int recfun(int index,int k,vector<vector<int>> &events,vector<vector<int> > &dp)\\n    {\\n        if(index==(int)events.size())return 0;\\n        \\n        if(k==0)\\n            return 0;\\n        \\n        if(dp[index][k]!=-1)\\n            return dp[index][k];\\n        \\n        int res = 0;\\n        int next = binsearch(events,events[index][1],index);\\n        res = max(recfun(index+1,k,events,dp),events[index][2]+recfun(next,k-1,events,dp));\\n        return dp[index][k]=res;\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        \\n        int n = events.size();\\n        vector<vector<int> > dp(n+5,vector<int>(k+4,-1));\\n        sort(events.begin(),events.end());\\n        return recfun(0,k,events,dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1052562,
                "title": "dp-solution-c",
                "content": "The question is just a variant of 2-dim KnapSack Problem. But the crutial idea here was to find the lower bound which would not overlap with the current range. I found out that using lower_bound and some tricks (was shocking that nklogn solution got accepted but anyways).\\nHere is the source code, feel free to comment below if you have any query\\n```\\nbool comp2(vector<int> &v1, vector<int> &v2){\\n    return v1[1] < v2[1];\\n}\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        vector<vector<int>> low;\\n        vector<int> high(n);\\n        low = events;\\n        for(int i = 0 ; i < n ; i++) high[i] = events[i][1];\\n        // high = events[1];\\n        sort(low.begin(), low.end(), comp2);\\n        sort(high.begin(), high.end());\\n        int p1 = 0; \\n        int p2 = 0;\\n        for(int val:high) cout << val<<\\' \\';\\n        cout << endl;\\n        vector<vector<int> > dp(n+1, vector<int>(k+1,0));\\n        for(int i = 1 ; i  < n+1; i++){\\n            for(int j = 1 ; j  < k+1 ; j++){\\n                int l = lower_bound(high.begin(), high.end(), low[i-1][0]) - high.begin();\\n                // cout << l<<\\' \\'<<i<<\\' \\'<<j<< endl;\\n                dp[i][j] = max(dp[i-1][j], low[i-1][2] + dp[l][j-1]);\\n                // cout << \"ZZ\"<< endl;\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nbool comp2(vector<int> &v1, vector<int> &v2){\\n    return v1[1] < v2[1];\\n}\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        vector<vector<int>> low;\\n        vector<int> high(n);\\n        low = events;\\n        for(int i = 0 ; i < n ; i++) high[i] = events[i][1];\\n        // high = events[1];\\n        sort(low.begin(), low.end(), comp2);\\n        sort(high.begin(), high.end());\\n        int p1 = 0; \\n        int p2 = 0;\\n        for(int val:high) cout << val<<\\' \\';\\n        cout << endl;\\n        vector<vector<int> > dp(n+1, vector<int>(k+1,0));\\n        for(int i = 1 ; i  < n+1; i++){\\n            for(int j = 1 ; j  < k+1 ; j++){\\n                int l = lower_bound(high.begin(), high.end(), low[i-1][0]) - high.begin();\\n                // cout << l<<\\' \\'<<i<<\\' \\'<<j<< endl;\\n                dp[i][j] = max(dp[i-1][j], low[i-1][2] + dp[l][j-1]);\\n                // cout << \"ZZ\"<< endl;\\n            }\\n        }\\n        return dp[n][k];\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4099910,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<vector<int>>& events,int k,int i){\\n        if(i >= events.size() || k == 0)\\n            return 0;\\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        int start = i+1;\\n        int end = events.size()-1;\\n        int nextIndex = end+1;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            if(events[i][1] < events[mid][0]){\\n                nextIndex = mid;\\n                end = mid - 1;\\n            }\\n            else\\n                start = mid + 1;\\n        }\\n        int take = events[i][2] + solve(events,k-1,nextIndex);\\n        int notTake = solve(events,k,i+1);\\n        return dp[i][k] = max(take,notTake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        dp = vector<vector<int>>(events.size(),vector<int>(k+1,-1));\\n        sort(events.begin(),events.end());\\n        return solve(events,k,0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>>dp;\\n    int solve(vector<vector<int>>& events,int k,int i){\\n        if(i >= events.size() || k == 0)\\n            return 0;\\n        if(dp[i][k] != -1)\\n            return dp[i][k];\\n        int start = i+1;\\n        int end = events.size()-1;\\n        int nextIndex = end+1;\\n        while(start <= end){\\n            int mid = start + (end - start)/2;\\n            if(events[i][1] < events[mid][0]){\\n                nextIndex = mid;\\n                end = mid - 1;\\n            }\\n            else\\n                start = mid + 1;\\n        }\\n        int take = events[i][2] + solve(events,k-1,nextIndex);\\n        int notTake = solve(events,k,i+1);\\n        return dp[i][k] = max(take,notTake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        dp = vector<vector<int>>(events.size(),vector<int>(k+1,-1));\\n        sort(events.begin(),events.end());\\n        return solve(events,k,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078142,
                "title": "simple-taken-nottaken-approach-of-dp-java",
                "content": "# To remove the Time Limit , instead of using linear search we can use binary search to find the next valid task after when we take a certain task\\n# Also we can precompute the next valid task for every taken task this can further reduce find function calling overhead\\u2705\\n\\n# Code\\n```\\nclass Solution {\\n    int n;\\n    int memo[][];\\n     int nextEventIndex[];\\n    public int maxValue(int[][] events, int k) {\\n        n=events.length;\\n        nextEventIndex=new int[n];\\n        Arrays.sort(events,(a,b)->Integer.compare(a[0],b[0]));\\n        memo=new int[n+1][k+1];\\n        precomputeNextEventIndex(events);\\n        for(int mem[]:memo)Arrays.fill(mem,-1);\\n        return solve(events,k,0);\\n        \\n    }\\n    public int solve(int[][]events,int k,int indx){\\n         if(indx>=n)return memo[indx][k]=0;\\n\\n         if(k==0)return memo[indx][k]=0;\\n         if(memo[indx][k]!=-1)return memo[indx][k];\\n\\n        int take=events[indx][2]+solve(events,k-1,nextEventIndex[indx]);\\n        int nottake=solve(events,k,indx+1);\\n\\n        return memo[indx][k]=Math.max(take,nottake);\\n    }\\n    // public int find(int[][]events,int target){\\n    //     for(int i=0;i<n;i++){\\n    //         if(events[i][0]>target)return i;\\n    //     }\\n    //     return n;\\n    // }\\n\\n    public void precomputeNextEventIndex(int[][] events) {\\n         for (int i = 0; i < n; i++) {\\n            int end = events[i][1];\\n            int left = i + 1;\\n            int right = n - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                if (events[mid][0] > end) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            nextEventIndex[i] = right + 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\n    int n;\\n    int memo[][];\\n     int nextEventIndex[];\\n    public int maxValue(int[][] events, int k) {\\n        n=events.length;\\n        nextEventIndex=new int[n];\\n        Arrays.sort(events,(a,b)->Integer.compare(a[0],b[0]));\\n        memo=new int[n+1][k+1];\\n        precomputeNextEventIndex(events);\\n        for(int mem[]:memo)Arrays.fill(mem,-1);\\n        return solve(events,k,0);\\n        \\n    }\\n    public int solve(int[][]events,int k,int indx){\\n         if(indx>=n)return memo[indx][k]=0;\\n\\n         if(k==0)return memo[indx][k]=0;\\n         if(memo[indx][k]!=-1)return memo[indx][k];\\n\\n        int take=events[indx][2]+solve(events,k-1,nextEventIndex[indx]);\\n        int nottake=solve(events,k,indx+1);\\n\\n        return memo[indx][k]=Math.max(take,nottake);\\n    }\\n    // public int find(int[][]events,int target){\\n    //     for(int i=0;i<n;i++){\\n    //         if(events[i][0]>target)return i;\\n    //     }\\n    //     return n;\\n    // }\\n\\n    public void precomputeNextEventIndex(int[][] events) {\\n         for (int i = 0; i < n; i++) {\\n            int end = events[i][1];\\n            int left = i + 1;\\n            int right = n - 1;\\n            while (left <= right) {\\n                int mid = left + (right - left) / 2;\\n                if (events[mid][0] > end) {\\n                    right = mid - 1;\\n                } else {\\n                    left = mid + 1;\\n                }\\n            }\\n            nextEventIndex[i] = right + 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041225,
                "title": "simple-dp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo get the max value, we can choose to attend or not attend each event. We don\\'t know which so we have to pick the best value possible by picking each event. This falls into ending type dp. Since the events can overlap we want to pick events as close together as possible without overlapping. So we have to sort the events (start, end) time pairs.\\n\\nDP steps:\\n\\n1. Form: form 2, ending form\\n2. dp meaning: dp(i, k) = max profits that can be made from events[i..n] if we attend event i with k events left.\\n3. dp transition: dp(i, k) = max(value[i] + dp(next(i), k-1), dp(i+1, k)) where next(i) means the smallest index event that we can visit after visiting i. We take it or we don\\'t take it, and if we don\\'t take it we can consider taking or not taking the i+1 element.\\n4. tc check: for next index of i we need to find the next element we can pick from the sorted array. We can do this beforehand and save the next indices separately or do it inside the recursion. inside binary search TC = nk(1 + log(n)) ~ nklogn. outside binary search TC = nk + nlogn. So outside can be better, and definitely cleaner.\\n5. Base case: For i >= n or k <= 0 we can return 0. The answer we want is rec(0,k)\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> times;\\n    vector<int> next_start;\\n    vector<long long> values;\\n    vector<vector<long long>> dp;\\n    int n;\\n\\n    long long rec(int start, int k)\\n    {\\n        if(start >= n || k <= 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(dp[start][k] != -1)\\n        {\\n            return dp[start][k];\\n        }\\n\\n        long long ans = max(values[start] + rec(next_start[start], k-1), rec(start+1, k));\\n\\n        return dp[start][k] = ans;\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n\\n        n = events.size();\\n\\n        dp.assign(n, vector<long long>(k+1, -1));\\n\\n        for(int i = 0; i<events.size(); i++)\\n        {\\n            times.push_back({events[i][0], events[i][1]});\\n            values.push_back({events[i][2]});\\n        }\\n\\n        for(int i = 0; i<events.size(); i++)\\n        {\\n            int end = times[i].second;\\n\\n            int lo = 0;\\n            int hi = n-1;\\n            int ans = n;\\n\\n            while(lo <= hi)\\n            {\\n                int mid = lo + (hi - lo)/2;\\n                if(end < times[mid].first)\\n                {\\n                    ans = mid;\\n                    hi = mid-1;\\n                }\\n                else\\n                {\\n                    lo = mid+1;\\n                }\\n            }\\n\\n            next_start.push_back(ans);\\n        }\\n\\n        rec(0, k);\\n\\n        return dp[0][k];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<pair<int,int>> times;\\n    vector<int> next_start;\\n    vector<long long> values;\\n    vector<vector<long long>> dp;\\n    int n;\\n\\n    long long rec(int start, int k)\\n    {\\n        if(start >= n || k <= 0)\\n        {\\n            return 0;\\n        }\\n\\n        if(dp[start][k] != -1)\\n        {\\n            return dp[start][k];\\n        }\\n\\n        long long ans = max(values[start] + rec(next_start[start], k-1), rec(start+1, k));\\n\\n        return dp[start][k] = ans;\\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n\\n        n = events.size();\\n\\n        dp.assign(n, vector<long long>(k+1, -1));\\n\\n        for(int i = 0; i<events.size(); i++)\\n        {\\n            times.push_back({events[i][0], events[i][1]});\\n            values.push_back({events[i][2]});\\n        }\\n\\n        for(int i = 0; i<events.size(); i++)\\n        {\\n            int end = times[i].second;\\n\\n            int lo = 0;\\n            int hi = n-1;\\n            int ans = n;\\n\\n            while(lo <= hi)\\n            {\\n                int mid = lo + (hi - lo)/2;\\n                if(end < times[mid].first)\\n                {\\n                    ans = mid;\\n                    hi = mid-1;\\n                }\\n                else\\n                {\\n                    lo = mid+1;\\n                }\\n            }\\n\\n            next_start.push_back(ans);\\n        }\\n\\n        rec(0, k);\\n\\n        return dp[0][k];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011990,
                "title": "top-down-brute-force-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort()\\n        n = len(events)\\n        @cache\\n        def dp(index, startTime, k):\\n            if index == n or k == 0:\\n                return 0\\n            #can take event or skip event\\n            ans = dp(index+1, startTime, k)\\n            if events[index][0] >= startTime and k > 0:\\n                ans = max(ans, events[index][2] + dp(index+1, events[index][1]+1, k-1))\\n            return ans\\n        return dp(0, 0, k)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxValue(self, events: List[List[int]], k: int) -> int:\\n        events.sort()\\n        n = len(events)\\n        @cache\\n        def dp(index, startTime, k):\\n            if index == n or k == 0:\\n                return 0\\n            #can take event or skip event\\n            ans = dp(index+1, startTime, k)\\n            if events[index][0] >= startTime and k > 0:\\n                ans = max(ans, events[index][2] + dp(index+1, events[index][1]+1, k-1))\\n            return ans\\n        return dp(0, 0, k)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4003645,
                "title": "2d-dp-and-binary-search-c-o-k-n-log-n",
                "content": "# Intuition\\nThis is 2D DP problem. If we are at event j and we can chose i events to maximise value then we can either not choose event j and move to the next event j+1 and number of chosen events is still i or we can choose j and move to the next non-overlapping event m and number of chosen events is i-1:\\n\\ndp[i][j] = max{ dp[i][j+1], dp[i-1][m] + events[j][value] }\\n\\nInitial conditions are: dp[i][n] = 0, i = 0, 1, ... k and they represent empty list of events for all possible number of events we can choose.\\n\\n# Approach\\nWe need to populate 2D array of maximum sums of event values: \\ndp[i][j], i = 0, ... k, j = 0, ... n and dp[i][n] = 0, i = 0, 1, ... k.\\n\\nSort events by start time. Populate dp[i][j] as follows: i = 1, ... k, j = n-1, ... 0.\\n\\nGiven event j we can find the next overalpping event m by a modified binary search to find upper boundary for a given target in a sorted array:\\n\\n```\\nint s = j + 1;\\nint e = n - 1;\\nint target = events[j][1];\\nint m = n;\\n\\nwhile (s <= e) {\\n    int mid = s + (e - s) / 2;\\n\\n    if (target < events[mid][0]) {\\n        e = mid - 1;\\n        m = mid;\\n    } else {\\n        s = mid + 1;\\n    }\\n}\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n*log(n)) + O(k*n*log(n)) = O(k*n*log(n))$$\\n\\n- Space complexity:\\n$$O(n*k)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<int>> dp(k + 1, vector<int>(n + 1));\\n\\n        for (int i = 1; i <= k; i++) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                dp[i][j] = dp[i][j + 1];\\n                \\n                int s = j + 1;\\n                int e = n - 1;\\n                int target = events[j][1];\\n                int m = n;\\n\\n                while (s <= e) {\\n                    int mid = s + (e - s) / 2;\\n\\n                    if (target < events[mid][0]) {\\n                        e = mid - 1;\\n                        m = mid;\\n                    } else {\\n                        s = mid + 1;\\n                    }\\n                }\\n\\n                dp[i][j] = max(dp[i][j], dp[i-1][m] + events[j][2]);\\n            }\\n        }\\n\\n        return dp[k][0];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nint s = j + 1;\\nint e = n - 1;\\nint target = events[j][1];\\nint m = n;\\n\\nwhile (s <= e) {\\n    int mid = s + (e - s) / 2;\\n\\n    if (target < events[mid][0]) {\\n        e = mid - 1;\\n        m = mid;\\n    } else {\\n        s = mid + 1;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<int>> dp(k + 1, vector<int>(n + 1));\\n\\n        for (int i = 1; i <= k; i++) {\\n            for (int j = n - 1; j >= 0; j--) {\\n                dp[i][j] = dp[i][j + 1];\\n                \\n                int s = j + 1;\\n                int e = n - 1;\\n                int target = events[j][1];\\n                int m = n;\\n\\n                while (s <= e) {\\n                    int mid = s + (e - s) / 2;\\n\\n                    if (target < events[mid][0]) {\\n                        e = mid - 1;\\n                        m = mid;\\n                    } else {\\n                        s = mid + 1;\\n                    }\\n                }\\n\\n                dp[i][j] = max(dp[i][j], dp[i-1][m] + events[j][2]);\\n            }\\n        }\\n\\n        return dp[k][0];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3957020,
                "title": "best-solution-c",
                "content": "```\\n#define vvi vector<vector<int>>\\nclass Solution {\\npublic:\\n    int find(int prev, vvi& e){\\n        int next_i = e.size();\\n        int low = prev, high = e.size()-1;\\n        \\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            if(e[mid][0] > e[prev][1]){\\n                next_i = mid;\\n                high = mid-1;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return next_i;\\n    }\\n    \\n    int solve(int i, vvi& e, int k, vvi&dp){\\n        if(i >= e.size()) return 0;\\n        if(k <= 0) return 0;\\n        if(dp[i][k] != -1) return dp[i][k];\\n        \\n        int notTake = solve(i+1, e, k, dp);\\n        \\n        int next_i = find(i, e);\\n        int take = e[i][2] + solve(next_i, e, k-1, dp);\\n        \\n        return dp[i][k] = max(notTake, take);\\n    }\\n    \\n    int maxValue(vvi& e, int k){\\n        int n = e.size();\\n        vvi dp(n+1, vector<int>(k+1, -1));\\n        sort(e.begin(), e.end());\\n        return solve(0, e, k, dp);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming",
                    "Binary Tree"
                ],
                "code": "```\\n#define vvi vector<vector<int>>\\nclass Solution {\\npublic:\\n    int find(int prev, vvi& e){\\n        int next_i = e.size();\\n        int low = prev, high = e.size()-1;\\n        \\n        while(low <= high){\\n            int mid = low + (high - low)/2;\\n            if(e[mid][0] > e[prev][1]){\\n                next_i = mid;\\n                high = mid-1;\\n            }else{\\n                low = mid+1;\\n            }\\n        }\\n        return next_i;\\n    }\\n    \\n    int solve(int i, vvi& e, int k, vvi&dp){\\n        if(i >= e.size()) return 0;\\n        if(k <= 0) return 0;\\n        if(dp[i][k] != -1) return dp[i][k];\\n        \\n        int notTake = solve(i+1, e, k, dp);\\n        \\n        int next_i = find(i, e);\\n        int take = e[i][2] + solve(next_i, e, k-1, dp);\\n        \\n        return dp[i][k] = max(notTake, take);\\n    }\\n    \\n    int maxValue(vvi& e, int k){\\n        int n = e.size();\\n        vvi dp(n+1, vector<int>(k+1, -1));\\n        sort(e.begin(), e.end());\\n        return solve(0, e, k, dp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3946383,
                "title": "c-solution-classical-dp-approach",
                "content": "Exactly similar to https://leetcode.com/problems/maximum-profit-in-job-scheduling/ apart from the condition that we can perform atmax k events and we can\\'t pick an event if it\\'s start time is same as the current event\\'s end time.\\nNote:\\nWe could have directly used upper_bound to find next_time instead of nextJobTime function.\\n\\nTime complexity-O(nklogn) \\nSpace complexity-O(nk)\\n```\\nclass Solution {\\n    private:\\n    int nextJobTime(int low,int high,int target,vector<vector<int>>& events){\\n        int ans=events.size();\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(events[mid][0]>=target){\\n                ans=mid;\\n                high=mid-1;\\n            }\\n            else\\n                low=mid+1;\\n        }\\n        return ans;\\n    }\\n    int func(int ind,int n,vector<vector<int>>& events,int k,vector<vector<int>>& dp){\\n        if(k==0 || ind==n)\\n            return 0;\\n        if(dp[ind][k]!=-1)\\n            return dp[ind][k];\\n        int next_time=nextJobTime(ind+1,n-1,events[ind][1]+1,events); \\n        int pick=events[ind][2]+func(next_time,n,events,k-1,dp); // If we pick the event,we need to find an event whose start time is greater than the current event\\'s end time\\n        int not_pick=func(ind+1,n,events,k,dp);// if we don\\'t pick the event,we can directly move to the next index\\n        return dp[ind][k]=max(pick,not_pick);\\n    }\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n=events.size();\\n        sort(events.begin(),events.end());\\n        vector<vector<int>>dp(n+1,vector<int>(k+1,-1));\\n        return func(0,n,events,k,dp);\\n    }\\n};",
                "solutionTags": [
                    "Recursion",
                    "Memoization",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n    private:\\n    int nextJobTime(int low,int high,int target,vector<vector<int>>& events){\\n        int ans=events.size();\\n        while(low<=high){\\n            int mid=low+(high-low)/2;\\n            if(events[mid][0]>=target){\\n                ans=mid;\\n                high=mid-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3940706,
                "title": "easy-and-simple-2d-dp-using-upper-bound",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        vector<vector<int>> dp(n+1 ,vector<int>(k+1,-1));\\n        sort(events.begin(), events.end());\\n        vector<int> start;\\n        for(int i=0; i<n; i++){\\n            start.push_back(events[i][0]);\\n        }\\n        return solve(0, start, k, events, dp);\\n    }\\n    int solve(int idx, vector<int>& start, int k, vector<vector<int>>& events, vector<vector<int>>& dp){\\n        int n = events.size();\\n        if(idx>=n || k==0)\\n            return 0; \\n        if(dp[idx][k]!=-1)\\n            return dp[idx][k];\\n\\n        int npick = solve(idx+1, start, k, events, dp);\\n        \\n        int end = events[idx][1];\\n        int ub = upper_bound(start.begin(), start.end(), end) - start.begin();\\n        int pick = events[idx][2] + solve(ub, start, k-1, events, dp);\\n        \\n        \\n        return dp[idx][k] = max(npick, pick);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        vector<vector<int>> dp(n+1 ,vector<int>(k+1,-1));\\n        sort(events.begin(), events.end());\\n        vector<int> start;\\n        for(int i=0; i<n; i++){\\n            start.push_back(events[i][0]);\\n        }\\n        return solve(0, start, k, events, dp);\\n    }\\n    int solve(int idx, vector<int>& start, int k, vector<vector<int>>& events, vector<vector<int>>& dp){\\n        int n = events.size();\\n        if(idx>=n || k==0)\\n            return 0; \\n        if(dp[idx][k]!=-1)\\n            return dp[idx][k];\\n\\n        int npick = solve(idx+1, start, k, events, dp);\\n        \\n        int end = events[idx][1];\\n        int ub = upper_bound(start.begin(), start.end(), end) - start.begin();\\n        int pick = events[idx][2] + solve(ub, start, k-1, events, dp);\\n        \\n        \\n        return dp[idx][k] = max(npick, pick);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3894517,
                "title": "my-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int maxValue(vector<vector<int>>& events, int k) {\\n    // dp[i][k] := max sum of events[i:] w/ max k # of attendance\\n    dp.resize(events.size(), vector<int>(k + 1, -1));\\n    sort(events.begin(), events.end());\\n    return maxValue(events, 0, k);\\n  }\\n\\n private:\\n  vector<vector<int>> dp;\\n\\n  int maxValue(const vector<vector<int>>& e, int i, int k) {\\n    if (k == 0 || i == e.size())\\n      return 0;\\n    if (dp[i][k] != -1)\\n      return dp[i][k];\\n\\n    // Binary search events to find the first index j s.t. e[j][0] > e[i][1]\\n    const auto it =\\n        upper_bound(e.begin() + i, e.end(), e[i][1],\\n                    [](int end, const auto& a) { return a[0] > end; });\\n    const int j = distance(e.begin(), it);\\n    return dp[i][k] =\\n               max(e[i][2] + maxValue(e, j, k - 1), maxValue(e, i + 1, k));\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int maxValue(vector<vector<int>>& events, int k) {\\n    // dp[i][k] := max sum of events[i:] w/ max k # of attendance\\n    dp.resize(events.size(), vector<int>(k + 1, -1));\\n    sort(events.begin(), events.end());\\n    return maxValue(events, 0, k);\\n  }\\n\\n private:\\n  vector<vector<int>> dp;\\n\\n  int maxValue(const vector<vector<int>>& e, int i, int k) {\\n    if (k == 0 || i == e.size())\\n      return 0;\\n    if (dp[i][k] != -1)\\n      return dp[i][k];\\n\\n    // Binary search events to find the first index j s.t. e[j][0] > e[i][1]\\n    const auto it =\\n        upper_bound(e.begin() + i, e.end(), e[i][1],\\n                    [](int end, const auto& a) { return a[0] > end; });\\n    const int j = distance(e.begin(), it);\\n    return dp[i][k] =\\n               max(e[i][2] + maxValue(e, j, k - 1), maxValue(e, i + 1, k));\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3884005,
                "title": "bottom-up-dp-recursive-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n\\n        Arrays.sort(events, (event1, event2) -> event1[0] - event2[0]);\\n        int[][] dp = new int[k + 1][n + 1];\\n\\n        for (int currentIndex = n - 1; currentIndex >=0; currentIndex--) {\\n            for (int count = 1; count <= k; count++) {\\n                int next = binarySearch(events, events[currentIndex][1]);\\n                dp[count][currentIndex] = Math.max(dp[count][currentIndex + 1],\\n                    events[currentIndex][2] + dp[count - 1][next]);\\n            }\\n        }\\n\\n        return dp[k][0];\\n        // return helper(0, k, events);\\n    }\\n\\n    private int helper(int i, int remainingEvents, int[][] events) {\\n        \\n        if (i == events.length) {\\n            return 0;\\n        }\\n\\n        \\n        if (remainingEvents == 0) {\\n            return 0;\\n        }\\n\\n        int include = Integer.MIN_VALUE;\\n        int exclude = Integer.MIN_VALUE;\\n\\n        //Include\\n            int next = binarySearch(events, events[i][1]);\\n            if (next > i)\\n                include = events[i][2] + helper(next, remainingEvents - 1, events);\\n        //Exclude\\n        exclude = helper(i + 1, remainingEvents, events);\\n        int result = Math.max(exclude, include);\\n        return result;\\n    }\\n\\n    private int binarySearch(int[][] events, int day) {\\n        int left = 0;\\n        int right = events.length;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (events[mid][0] <= day) {\\n                left = mid + 1;\\n            }\\n            else {\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxValue(int[][] events, int k) {\\n        int n = events.length;\\n\\n        Arrays.sort(events, (event1, event2) -> event1[0] - event2[0]);\\n        int[][] dp = new int[k + 1][n + 1];\\n\\n        for (int currentIndex = n - 1; currentIndex >=0; currentIndex--) {\\n            for (int count = 1; count <= k; count++) {\\n                int next = binarySearch(events, events[currentIndex][1]);\\n                dp[count][currentIndex] = Math.max(dp[count][currentIndex + 1],\\n                    events[currentIndex][2] + dp[count - 1][next]);\\n            }\\n        }\\n\\n        return dp[k][0];\\n        // return helper(0, k, events);\\n    }\\n\\n    private int helper(int i, int remainingEvents, int[][] events) {\\n        \\n        if (i == events.length) {\\n            return 0;\\n        }\\n\\n        \\n        if (remainingEvents == 0) {\\n            return 0;\\n        }\\n\\n        int include = Integer.MIN_VALUE;\\n        int exclude = Integer.MIN_VALUE;\\n\\n        //Include\\n            int next = binarySearch(events, events[i][1]);\\n            if (next > i)\\n                include = events[i][2] + helper(next, remainingEvents - 1, events);\\n        //Exclude\\n        exclude = helper(i + 1, remainingEvents, events);\\n        int result = Math.max(exclude, include);\\n        return result;\\n    }\\n\\n    private int binarySearch(int[][] events, int day) {\\n        int left = 0;\\n        int right = events.length;\\n\\n        while (left < right) {\\n            int mid = left + (right - left) / 2;\\n            if (events[mid][0] <= day) {\\n                left = mid + 1;\\n            }\\n            else {\\n                right = mid;\\n            }\\n        }\\n\\n        return left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862547,
                "title": "c-easy-to-understand-memoisation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis is similar to take-not-take approach commonly used in DP to solve subsequence related problems. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind a recursive solution first. After seeing the constraints, it can be made out that a memoisation solution would be accepted. Sorting the events array based on start time helps us to execute the pick-or-not-pick approach correctly. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int,unordered_map<int,unordered_map<int,int>>> mp;\\n\\n    int rec(int index, int end, vector<vector<int>>& events, int k){\\n            if(k == 0)\\n                return 0;\\n            \\n            if(index >= events.size())\\n                return 0;\\n            \\n            if(mp.find(index)!= mp.end() && mp[index].find(end)!= mp[index].end() && \\n            mp[index][end].find(k) != mp[index][end].end())\\n                return mp[index][end][k];\\n\\n            int take = 0,notTake=0;\\n            if(events[index][0] > end){\\n                take = events[index][2] + rec(index + 1, events[index][1], events, k-1);\\n            }\\n\\n            notTake = rec(index + 1, end, events, k);\\n            return mp[index][end][k] = max(take, notTake);\\n\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        return rec(0, 0, events, k);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int,unordered_map<int,unordered_map<int,int>>> mp;\\n\\n    int rec(int index, int end, vector<vector<int>>& events, int k){\\n            if(k == 0)\\n                return 0;\\n            \\n            if(index >= events.size())\\n                return 0;\\n            \\n            if(mp.find(index)!= mp.end() && mp[index].find(end)!= mp[index].end() && \\n            mp[index][end].find(k) != mp[index][end].end())\\n                return mp[index][end][k];\\n\\n            int take = 0,notTake=0;\\n            if(events[index][0] > end){\\n                take = events[index][2] + rec(index + 1, events[index][1], events, k-1);\\n            }\\n\\n            notTake = rec(index + 1, end, events, k);\\n            return mp[index][end][k] = max(take, notTake);\\n\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        return rec(0, 0, events, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1939736,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970444,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970384,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970577,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970549,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970409,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970340,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970337,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970366,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970585,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1939736,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970444,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970384,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970577,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970549,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970409,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970340,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970337,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970366,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970585,
                "content": [
                    {
                        "username": "shrthk",
                        "content": "...if i ever have to sift through 10^6 events deciding which events will provide the best value, i\\'d simply quit."
                    },
                    {
                        "username": "z3eg",
                        "content": "having to plan 2739726 years ahead is also kinda intimidating ngl"
                    },
                    {
                        "username": "daring-calf",
                        "content": "Problems like this are the reason that I have no time to attend my life\\'s events."
                    },
                    {
                        "username": "binocular",
                        "content": "\\u5468\\u672B\\u4E0D\\u5237Leetcode\\u5E72\\u4EC0\\u4E48\\u3010\\u72D7\\u5934"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@dev-null0](/dev-null0) I agree with you, this was a rather sweet question in a sea of otherwise weird weekend HARD\\'s. Btw, you and I have almost similar streak pattern, it\\'s good to find you in DCC chats then and now \\uD83C\\uDF7B"
                    },
                    {
                        "username": "dev-null0",
                        "content": "This one wasn\\'t too bad, standard dynamic programming question.\\n\\nBut I agree, leetcode is way too much of a grind, especially on weekends..."
                    },
                    {
                        "username": "Baymax_",
                        "content": "Lol, well said"
                    },
                    {
                        "username": "gmk92lc",
                        "content": "\\'we would like to not hire you\\' ... "
                    },
                    {
                        "username": "poundppx",
                        "content": "bro hit me like a mf uhhhhh"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Here's a detailed hint to guide you towards solving the problem. Let's make it fun! \n\nThink of this problem as a variation of a standard question where either you choose or you don't choose.  Here, you have the power to select the events that maximize your profit. \n\nTo approach this problem:\n\n1. Keep track of the last index you chose, initially set to -1.  If you're wondering why we need this, it's because we don't have any event chosen yet \n\n2. For each event, compare its start time with the end time of the last chosen index. If the start time is greater, it means the event is compatible with the previously chosen events. You can consider picking it, XD! Otherwise, skip it and move on to the next event. \n\n3. Storing the last chosen index can be a bit \"eww\" when it comes to three-dimensional memoization. But no worries, we have a solution! Let's invite binary search's upper_bound here! When you choose an index, find the index via upper_bound where the start time is greater than the end time.  Then, call the recursion function on that index to process the remaining events. \n\n4. Don't forget to handle the base cases too! When k (the number of events you can attend) becomes less than or equal to 0, it means no more events can be chosen. Time to celebrate!  Also, remember to check if you've reached the end of the events vector.\n\nNow it's time to code! Implement this approach and try solving the problem yourself. Good luck! \n\nDo upvote if it helped you :)\n"
                    },
                    {
                        "username": "oops_moment",
                        "content": "Wow! I\\'m truly grateful for all the upvotes and support. Thank you so much, everyone."
                    },
                    {
                        "username": "ay8182",
                        "content": "I really liked your explanation although i had to see your solution. I couldn\\'t figure out how to write that upperbound func thanks for that."
                    },
                    {
                        "username": "parasmn4",
                        "content": "When employer can not say \\'No\\' directly - "
                    },
                    {
                        "username": "neembu_mirch",
                        "content": "the problem is hard until you notice k*event.length <=10^6"
                    },
                    {
                        "username": "Balerii",
                        "content": "Omg thanks. I was trying to solve it for a few hours questioning my intelegence because I was sure it shouldnt be possible."
                    },
                    {
                        "username": "lcs2020002",
                        "content": "[@suren-yeager](/suren-yeager) can u share ur implementation"
                    },
                    {
                        "username": "suren-yeager",
                        "content": "[@mandaviyahimanshu](/mandaviyahimanshu) i did (k, maxDay) and got RTE !!"
                    },
                    {
                        "username": "mandaviyahimanshu",
                        "content": "[@raghavgoel18](/raghavgoel18) it signify  that we use dp with two variable parameter (k,ind) which has  TC of k*maxind, so this will not give TLE."
                    },
                    {
                        "username": "raghavgoel18",
                        "content": "what does that signify ? can you please elaborate\\n"
                    },
                    {
                        "username": "21Cash",
                        "content": "Ayo, my man here"
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "A Google and DE Shaw OA today + Hard question for streak + tomorrow contest\\n=> O(N<sup>4</sup>) complexity weekend :("
                    },
                    {
                        "username": "aryangoel971",
                        "content": "#GAMEON "
                    },
                    {
                        "username": "avneets2103",
                        "content": "NSUT pal\\n"
                    },
                    {
                        "username": "a8hi",
                        "content": "good luck!\\n"
                    },
                    {
                        "username": "pushkarwaykole123",
                        "content": "Out of just curiosity do Google hire on campus in NSUT?"
                    },
                    {
                        "username": "aditya3435",
                        "content": "[@kianyanglee](/kianyanglee) \\nDE Shaw is a company and OA stands for Online Assessment."
                    },
                    {
                        "username": "the_only_1sh",
                        "content": "[@kianyanglee](/kianyanglee) A company that hires Software Engineers and gives high packages. They work on finance related product."
                    },
                    {
                        "username": "kianyanglee",
                        "content": "What\\'s  DE Shaw OA ?\\n"
                    },
                    {
                        "username": "aceanojjj",
                        "content": "Looks like a DP weekend y\\'all ! \\uD83E\\uDD79"
                    },
                    {
                        "username": "anwendeng",
                        "content": "This question is marked as hard, but the DP part is not so hard !! The recursive relation is not hard to find. A memoized recursion is doable!"
                    },
                    {
                        "username": "Leaderboard",
                        "content": "[@anwendeng](/anwendeng) Interestingly, I didn\\'t even have to use binary search. Optimising for k = 1 was enough to put my solution in the 94th percentile for time."
                    },
                    {
                        "username": "anwendeng",
                        "content": "[@divyanshub120130](/divyanshub120130)\nThe crucial  part is here, using binary search to find next[i], Hopefully this hint is useful.\n ```\n    int j = next[i];\n    int attend_i = events[i][2] + dp[j][k-1];\n    int skip_i = dp[i+1][k];\n    dp[i][k]=max(attend_i, skip_i);\n```"
                    },
                    {
                        "username": "divyanshub120130",
                        "content": "how is DP easy for you can you tell me ? , i really want help . cant understand how "
                    },
                    {
                        "username": "DhavalAr",
                        "content": "Can we sort the events based on their end time? If yes, so please tell when & in what type of problems we sort events based on start time & when based on end time."
                    },
                    {
                        "username": "DhavalAr",
                        "content": "[@psionl0](/psionl0) but we can use sorting based on end time if we change the logic"
                    },
                    {
                        "username": "psionl0",
                        "content": "We sort the events based on their start times then do a binary search to find the first event whose start time is beyond the end time of the current event."
                    }
                ]
            },
            {
                "id": 1970708,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\'  (other two variables \\'idx\\' and \\'k\\') in recursion function for checking if the current event do not overlap with the previous event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "percy_98",
                        "content": "Thank you for leaving this comment, I  was getting this intuition but was not sure why  I was getting WA for same recursion method when memorized "
                    },
                    {
                        "username": "Baymax_",
                        "content": "Just like in many other problems that involves \\'Binary search\\', even in this one also the Linear search approach is beating Binary search \\uD83D\\uDE05\\nTest cases may need a re-visit"
                    },
                    {
                        "username": "feng3245",
                        "content": "Title is wrong... question is clearly not about maximum number of event that can be attended... Clearly it\\'s K... "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The given problem named `Maximum Number of Events That Can Be Attended II` is a problem in continuation to the problem `Maximum Number of Events That Can Be Attended`. In the part 1, you just have to find the \\'maximum number of events that can be attended\\' where the events don\\'t have a value (or you can say that all events are equally valued). But this question ,part 2, has these values with the events, and this time the goal is to find the maximum values you can obtain and not the maximum number of events you can attend. But for some reason they didn\\'t bother to change the name."
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Saturday ruined successfully \\uD83D\\uDC80"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can also try this ->\n[maximum-number-of-events-that-can-be-attended](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/description/)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good luck for HARD weekend"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "it\\'s weekend fellas .."
                    },
                    {
                        "username": "percy_98",
                        "content": "I was able to solve this  partially but this is such a good problem "
                    },
                    {
                        "username": "Veloscocity",
                        "content": "Why would you add new testcases that TLE working solutions?"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is pretty easy. Shouldn\\'t be marked hard. Maybe medium, maybe easy. "
                    }
                ]
            },
            {
                "id": 1970579,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\'  (other two variables \\'idx\\' and \\'k\\') in recursion function for checking if the current event do not overlap with the previous event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "percy_98",
                        "content": "Thank you for leaving this comment, I  was getting this intuition but was not sure why  I was getting WA for same recursion method when memorized "
                    },
                    {
                        "username": "Baymax_",
                        "content": "Just like in many other problems that involves \\'Binary search\\', even in this one also the Linear search approach is beating Binary search \\uD83D\\uDE05\\nTest cases may need a re-visit"
                    },
                    {
                        "username": "feng3245",
                        "content": "Title is wrong... question is clearly not about maximum number of event that can be attended... Clearly it\\'s K... "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The given problem named `Maximum Number of Events That Can Be Attended II` is a problem in continuation to the problem `Maximum Number of Events That Can Be Attended`. In the part 1, you just have to find the \\'maximum number of events that can be attended\\' where the events don\\'t have a value (or you can say that all events are equally valued). But this question ,part 2, has these values with the events, and this time the goal is to find the maximum values you can obtain and not the maximum number of events you can attend. But for some reason they didn\\'t bother to change the name."
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Saturday ruined successfully \\uD83D\\uDC80"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can also try this ->\n[maximum-number-of-events-that-can-be-attended](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/description/)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good luck for HARD weekend"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "it\\'s weekend fellas .."
                    },
                    {
                        "username": "percy_98",
                        "content": "I was able to solve this  partially but this is such a good problem "
                    },
                    {
                        "username": "Veloscocity",
                        "content": "Why would you add new testcases that TLE working solutions?"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is pretty easy. Shouldn\\'t be marked hard. Maybe medium, maybe easy. "
                    }
                ]
            },
            {
                "id": 1970354,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\'  (other two variables \\'idx\\' and \\'k\\') in recursion function for checking if the current event do not overlap with the previous event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "percy_98",
                        "content": "Thank you for leaving this comment, I  was getting this intuition but was not sure why  I was getting WA for same recursion method when memorized "
                    },
                    {
                        "username": "Baymax_",
                        "content": "Just like in many other problems that involves \\'Binary search\\', even in this one also the Linear search approach is beating Binary search \\uD83D\\uDE05\\nTest cases may need a re-visit"
                    },
                    {
                        "username": "feng3245",
                        "content": "Title is wrong... question is clearly not about maximum number of event that can be attended... Clearly it\\'s K... "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The given problem named `Maximum Number of Events That Can Be Attended II` is a problem in continuation to the problem `Maximum Number of Events That Can Be Attended`. In the part 1, you just have to find the \\'maximum number of events that can be attended\\' where the events don\\'t have a value (or you can say that all events are equally valued). But this question ,part 2, has these values with the events, and this time the goal is to find the maximum values you can obtain and not the maximum number of events you can attend. But for some reason they didn\\'t bother to change the name."
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Saturday ruined successfully \\uD83D\\uDC80"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can also try this ->\n[maximum-number-of-events-that-can-be-attended](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/description/)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good luck for HARD weekend"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "it\\'s weekend fellas .."
                    },
                    {
                        "username": "percy_98",
                        "content": "I was able to solve this  partially but this is such a good problem "
                    },
                    {
                        "username": "Veloscocity",
                        "content": "Why would you add new testcases that TLE working solutions?"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is pretty easy. Shouldn\\'t be marked hard. Maybe medium, maybe easy. "
                    }
                ]
            },
            {
                "id": 1970685,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\'  (other two variables \\'idx\\' and \\'k\\') in recursion function for checking if the current event do not overlap with the previous event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "percy_98",
                        "content": "Thank you for leaving this comment, I  was getting this intuition but was not sure why  I was getting WA for same recursion method when memorized "
                    },
                    {
                        "username": "Baymax_",
                        "content": "Just like in many other problems that involves \\'Binary search\\', even in this one also the Linear search approach is beating Binary search \\uD83D\\uDE05\\nTest cases may need a re-visit"
                    },
                    {
                        "username": "feng3245",
                        "content": "Title is wrong... question is clearly not about maximum number of event that can be attended... Clearly it\\'s K... "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The given problem named `Maximum Number of Events That Can Be Attended II` is a problem in continuation to the problem `Maximum Number of Events That Can Be Attended`. In the part 1, you just have to find the \\'maximum number of events that can be attended\\' where the events don\\'t have a value (or you can say that all events are equally valued). But this question ,part 2, has these values with the events, and this time the goal is to find the maximum values you can obtain and not the maximum number of events you can attend. But for some reason they didn\\'t bother to change the name."
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Saturday ruined successfully \\uD83D\\uDC80"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can also try this ->\n[maximum-number-of-events-that-can-be-attended](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/description/)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good luck for HARD weekend"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "it\\'s weekend fellas .."
                    },
                    {
                        "username": "percy_98",
                        "content": "I was able to solve this  partially but this is such a good problem "
                    },
                    {
                        "username": "Veloscocity",
                        "content": "Why would you add new testcases that TLE working solutions?"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is pretty easy. Shouldn\\'t be marked hard. Maybe medium, maybe easy. "
                    }
                ]
            },
            {
                "id": 1970462,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\'  (other two variables \\'idx\\' and \\'k\\') in recursion function for checking if the current event do not overlap with the previous event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "percy_98",
                        "content": "Thank you for leaving this comment, I  was getting this intuition but was not sure why  I was getting WA for same recursion method when memorized "
                    },
                    {
                        "username": "Baymax_",
                        "content": "Just like in many other problems that involves \\'Binary search\\', even in this one also the Linear search approach is beating Binary search \\uD83D\\uDE05\\nTest cases may need a re-visit"
                    },
                    {
                        "username": "feng3245",
                        "content": "Title is wrong... question is clearly not about maximum number of event that can be attended... Clearly it\\'s K... "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The given problem named `Maximum Number of Events That Can Be Attended II` is a problem in continuation to the problem `Maximum Number of Events That Can Be Attended`. In the part 1, you just have to find the \\'maximum number of events that can be attended\\' where the events don\\'t have a value (or you can say that all events are equally valued). But this question ,part 2, has these values with the events, and this time the goal is to find the maximum values you can obtain and not the maximum number of events you can attend. But for some reason they didn\\'t bother to change the name."
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Saturday ruined successfully \\uD83D\\uDC80"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can also try this ->\n[maximum-number-of-events-that-can-be-attended](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/description/)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good luck for HARD weekend"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "it\\'s weekend fellas .."
                    },
                    {
                        "username": "percy_98",
                        "content": "I was able to solve this  partially but this is such a good problem "
                    },
                    {
                        "username": "Veloscocity",
                        "content": "Why would you add new testcases that TLE working solutions?"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is pretty easy. Shouldn\\'t be marked hard. Maybe medium, maybe easy. "
                    }
                ]
            },
            {
                "id": 1970394,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\'  (other two variables \\'idx\\' and \\'k\\') in recursion function for checking if the current event do not overlap with the previous event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "percy_98",
                        "content": "Thank you for leaving this comment, I  was getting this intuition but was not sure why  I was getting WA for same recursion method when memorized "
                    },
                    {
                        "username": "Baymax_",
                        "content": "Just like in many other problems that involves \\'Binary search\\', even in this one also the Linear search approach is beating Binary search \\uD83D\\uDE05\\nTest cases may need a re-visit"
                    },
                    {
                        "username": "feng3245",
                        "content": "Title is wrong... question is clearly not about maximum number of event that can be attended... Clearly it\\'s K... "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The given problem named `Maximum Number of Events That Can Be Attended II` is a problem in continuation to the problem `Maximum Number of Events That Can Be Attended`. In the part 1, you just have to find the \\'maximum number of events that can be attended\\' where the events don\\'t have a value (or you can say that all events are equally valued). But this question ,part 2, has these values with the events, and this time the goal is to find the maximum values you can obtain and not the maximum number of events you can attend. But for some reason they didn\\'t bother to change the name."
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Saturday ruined successfully \\uD83D\\uDC80"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can also try this ->\n[maximum-number-of-events-that-can-be-attended](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/description/)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good luck for HARD weekend"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "it\\'s weekend fellas .."
                    },
                    {
                        "username": "percy_98",
                        "content": "I was able to solve this  partially but this is such a good problem "
                    },
                    {
                        "username": "Veloscocity",
                        "content": "Why would you add new testcases that TLE working solutions?"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is pretty easy. Shouldn\\'t be marked hard. Maybe medium, maybe easy. "
                    }
                ]
            },
            {
                "id": 1970332,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\'  (other two variables \\'idx\\' and \\'k\\') in recursion function for checking if the current event do not overlap with the previous event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "percy_98",
                        "content": "Thank you for leaving this comment, I  was getting this intuition but was not sure why  I was getting WA for same recursion method when memorized "
                    },
                    {
                        "username": "Baymax_",
                        "content": "Just like in many other problems that involves \\'Binary search\\', even in this one also the Linear search approach is beating Binary search \\uD83D\\uDE05\\nTest cases may need a re-visit"
                    },
                    {
                        "username": "feng3245",
                        "content": "Title is wrong... question is clearly not about maximum number of event that can be attended... Clearly it\\'s K... "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The given problem named `Maximum Number of Events That Can Be Attended II` is a problem in continuation to the problem `Maximum Number of Events That Can Be Attended`. In the part 1, you just have to find the \\'maximum number of events that can be attended\\' where the events don\\'t have a value (or you can say that all events are equally valued). But this question ,part 2, has these values with the events, and this time the goal is to find the maximum values you can obtain and not the maximum number of events you can attend. But for some reason they didn\\'t bother to change the name."
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Saturday ruined successfully \\uD83D\\uDC80"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can also try this ->\n[maximum-number-of-events-that-can-be-attended](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/description/)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good luck for HARD weekend"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "it\\'s weekend fellas .."
                    },
                    {
                        "username": "percy_98",
                        "content": "I was able to solve this  partially but this is such a good problem "
                    },
                    {
                        "username": "Veloscocity",
                        "content": "Why would you add new testcases that TLE working solutions?"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is pretty easy. Shouldn\\'t be marked hard. Maybe medium, maybe easy. "
                    }
                ]
            },
            {
                "id": 2057719,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\'  (other two variables \\'idx\\' and \\'k\\') in recursion function for checking if the current event do not overlap with the previous event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "percy_98",
                        "content": "Thank you for leaving this comment, I  was getting this intuition but was not sure why  I was getting WA for same recursion method when memorized "
                    },
                    {
                        "username": "Baymax_",
                        "content": "Just like in many other problems that involves \\'Binary search\\', even in this one also the Linear search approach is beating Binary search \\uD83D\\uDE05\\nTest cases may need a re-visit"
                    },
                    {
                        "username": "feng3245",
                        "content": "Title is wrong... question is clearly not about maximum number of event that can be attended... Clearly it\\'s K... "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The given problem named `Maximum Number of Events That Can Be Attended II` is a problem in continuation to the problem `Maximum Number of Events That Can Be Attended`. In the part 1, you just have to find the \\'maximum number of events that can be attended\\' where the events don\\'t have a value (or you can say that all events are equally valued). But this question ,part 2, has these values with the events, and this time the goal is to find the maximum values you can obtain and not the maximum number of events you can attend. But for some reason they didn\\'t bother to change the name."
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Saturday ruined successfully \\uD83D\\uDC80"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can also try this ->\n[maximum-number-of-events-that-can-be-attended](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/description/)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good luck for HARD weekend"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "it\\'s weekend fellas .."
                    },
                    {
                        "username": "percy_98",
                        "content": "I was able to solve this  partially but this is such a good problem "
                    },
                    {
                        "username": "Veloscocity",
                        "content": "Why would you add new testcases that TLE working solutions?"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is pretty easy. Shouldn\\'t be marked hard. Maybe medium, maybe easy. "
                    }
                ]
            },
            {
                "id": 2035700,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\'  (other two variables \\'idx\\' and \\'k\\') in recursion function for checking if the current event do not overlap with the previous event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "percy_98",
                        "content": "Thank you for leaving this comment, I  was getting this intuition but was not sure why  I was getting WA for same recursion method when memorized "
                    },
                    {
                        "username": "Baymax_",
                        "content": "Just like in many other problems that involves \\'Binary search\\', even in this one also the Linear search approach is beating Binary search \\uD83D\\uDE05\\nTest cases may need a re-visit"
                    },
                    {
                        "username": "feng3245",
                        "content": "Title is wrong... question is clearly not about maximum number of event that can be attended... Clearly it\\'s K... "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The given problem named `Maximum Number of Events That Can Be Attended II` is a problem in continuation to the problem `Maximum Number of Events That Can Be Attended`. In the part 1, you just have to find the \\'maximum number of events that can be attended\\' where the events don\\'t have a value (or you can say that all events are equally valued). But this question ,part 2, has these values with the events, and this time the goal is to find the maximum values you can obtain and not the maximum number of events you can attend. But for some reason they didn\\'t bother to change the name."
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Saturday ruined successfully \\uD83D\\uDC80"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can also try this ->\n[maximum-number-of-events-that-can-be-attended](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/description/)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good luck for HARD weekend"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "it\\'s weekend fellas .."
                    },
                    {
                        "username": "percy_98",
                        "content": "I was able to solve this  partially but this is such a good problem "
                    },
                    {
                        "username": "Veloscocity",
                        "content": "Why would you add new testcases that TLE working solutions?"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is pretty easy. Shouldn\\'t be marked hard. Maybe medium, maybe easy. "
                    }
                ]
            },
            {
                "id": 1980341,
                "content": [
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\'  (other two variables \\'idx\\' and \\'k\\') in recursion function for checking if the current event do not overlap with the previous event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "percy_98",
                        "content": "Thank you for leaving this comment, I  was getting this intuition but was not sure why  I was getting WA for same recursion method when memorized "
                    },
                    {
                        "username": "Baymax_",
                        "content": "Just like in many other problems that involves \\'Binary search\\', even in this one also the Linear search approach is beating Binary search \\uD83D\\uDE05\\nTest cases may need a re-visit"
                    },
                    {
                        "username": "feng3245",
                        "content": "Title is wrong... question is clearly not about maximum number of event that can be attended... Clearly it\\'s K... "
                    },
                    {
                        "username": "Ebad1001",
                        "content": "The given problem named `Maximum Number of Events That Can Be Attended II` is a problem in continuation to the problem `Maximum Number of Events That Can Be Attended`. In the part 1, you just have to find the \\'maximum number of events that can be attended\\' where the events don\\'t have a value (or you can say that all events are equally valued). But this question ,part 2, has these values with the events, and this time the goal is to find the maximum values you can obtain and not the maximum number of events you can attend. But for some reason they didn\\'t bother to change the name."
                    },
                    {
                        "username": "imguptaharsh",
                        "content": "Saturday ruined successfully \\uD83D\\uDC80"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "You can also try this ->\n[maximum-number-of-events-that-can-be-attended](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended/description/)"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "good luck for HARD weekend"
                    },
                    {
                        "username": "Adhiraj-MNNIT",
                        "content": "it\\'s weekend fellas .."
                    },
                    {
                        "username": "percy_98",
                        "content": "I was able to solve this  partially but this is such a good problem "
                    },
                    {
                        "username": "Veloscocity",
                        "content": "Why would you add new testcases that TLE working solutions?"
                    },
                    {
                        "username": "gpersonnat",
                        "content": "This problem is pretty easy. Shouldn\\'t be marked hard. Maybe medium, maybe easy. "
                    }
                ]
            },
            {
                "id": 1974193,
                "content": [
                    {
                        "username": "rohitnehara",
                        "content": "Damn those constraints "
                    },
                    {
                        "username": "khushi3",
                        "content": "It is it only me who find the table diagram in the problem misleading"
                    },
                    {
                        "username": "mahesh105",
                        "content": "No, It actually states boundary of events as per deadline and their value. It clearly helps to know the overlapping events ."
                    },
                    {
                        "username": "anmolasahay27",
                        "content": "Can someone help me figure out why my code failing for the following case\n\nclass Solution {\npublic:\n    #define ll long long\n    vector<vector<int>> events;\n    int n;\n    int inf=1e9;\n    vector <vector<int>> dp;\n\n    int rec(int ind, int k,int pind)\n    {\n        if(k<=0)\n        return 0;\n\n        if(ind==n)\n        return 0;\n\n        if(ind==n-1)\n        {\n            int ans=0;\n            if(pind==-1)\n            ans=max(ans,events[ind][2]);\n            else if(events[pind][1]<=events[ind][0])\n            {\n                ans=max(ans,events[ind][2]);\n            }\n            return ans;\n        }\n\n        if(dp[ind][k]!=-1)\n        return dp[ind][k];\n\n        int ans=0;\n\n        ans=max(ans,rec(ind+1,k,pind));\n\n        if(pind==-1)\n        ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        else if(events[pind][1]<=events[ind][0])\n        {\n            ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        }\n\n        return dp[ind][k]=ans;\n\n    }\n    int maxValue(vector<vector<int>>& event, int k) {\n        events=event;\n        sort(events.begin(),events.end());\n        n=events.size();\n\n        for(int i=0;i<n;i++)\n        {\n            events[i][0]--;\n        }\n        dp.assign(n+5,vector <int>(k+5,-1));\n\n        return rec(0,k,-1);\n\n    }\n};\n\ntest case failing : [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]]"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Just use take not take concept ----:)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Finally figured it out. \n\nUse a heapq to record (endtime, # of events, and its max) will work for me!\n\n[here](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/solutions/3770203/python-dp-heapq-640-ms-100/)"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bye bye streak!"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? It is as the Hints mentioned, sort by start time, select, not select\\n```\\nclass Solution {\\n    int ret = 0;\\n\\n   public:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end(), [](vector<int>& lhs, vector<int>& rhs) { return lhs[0] < rhs[0]; });\\n        helper(events, k, 0, 0);\\n        return ret;\\n    }\\n    void helper(const vector<vector<int>>& events, int k, int startidx, int sum) {\\n        if (k <= 0) return;\\n        if (startidx >= events.size()) return;\\n        // don\\'t select\\n        helper(events, k, startidx + 1, sum);\\n        // select\\n        sum += events[startidx][2];\\n        ret = max(ret, sum);\\n        int end = events[startidx][1];\\n\\n        // binary search next startidx\\n        auto it = upper_bound(events.begin() + startidx + 1, events.end(), end,\\n                              [](int end, const vector<int>& lhs) { return lhs[0] > end; });\\n        if (it == events.end()) return;\\n        int newstart = std::distance(events.begin(), it);\\n        helper(events, k - 1, newstart, sum);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "R4Ks",
                        "content": "the hint was very helpful ngl"
                    },
                    {
                        "username": "wajahatx1",
                        "content": "Honestly this one was easier than maximum number of events 1\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "I spent a long time trying to find an algorithm that could be adapted to solve this.\\n\\nThen I decided to go straight to recursive DP, just to see how slow would it go, and not only it got accepted, but by beating 85% of other solutions.\\n\\nDon\\'t be me. Be smart. :)\\n\\nGo straight for a recursive DP :)"
                    }
                ]
            },
            {
                "id": 1972212,
                "content": [
                    {
                        "username": "rohitnehara",
                        "content": "Damn those constraints "
                    },
                    {
                        "username": "khushi3",
                        "content": "It is it only me who find the table diagram in the problem misleading"
                    },
                    {
                        "username": "mahesh105",
                        "content": "No, It actually states boundary of events as per deadline and their value. It clearly helps to know the overlapping events ."
                    },
                    {
                        "username": "anmolasahay27",
                        "content": "Can someone help me figure out why my code failing for the following case\n\nclass Solution {\npublic:\n    #define ll long long\n    vector<vector<int>> events;\n    int n;\n    int inf=1e9;\n    vector <vector<int>> dp;\n\n    int rec(int ind, int k,int pind)\n    {\n        if(k<=0)\n        return 0;\n\n        if(ind==n)\n        return 0;\n\n        if(ind==n-1)\n        {\n            int ans=0;\n            if(pind==-1)\n            ans=max(ans,events[ind][2]);\n            else if(events[pind][1]<=events[ind][0])\n            {\n                ans=max(ans,events[ind][2]);\n            }\n            return ans;\n        }\n\n        if(dp[ind][k]!=-1)\n        return dp[ind][k];\n\n        int ans=0;\n\n        ans=max(ans,rec(ind+1,k,pind));\n\n        if(pind==-1)\n        ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        else if(events[pind][1]<=events[ind][0])\n        {\n            ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        }\n\n        return dp[ind][k]=ans;\n\n    }\n    int maxValue(vector<vector<int>>& event, int k) {\n        events=event;\n        sort(events.begin(),events.end());\n        n=events.size();\n\n        for(int i=0;i<n;i++)\n        {\n            events[i][0]--;\n        }\n        dp.assign(n+5,vector <int>(k+5,-1));\n\n        return rec(0,k,-1);\n\n    }\n};\n\ntest case failing : [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]]"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Just use take not take concept ----:)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Finally figured it out. \n\nUse a heapq to record (endtime, # of events, and its max) will work for me!\n\n[here](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/solutions/3770203/python-dp-heapq-640-ms-100/)"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bye bye streak!"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? It is as the Hints mentioned, sort by start time, select, not select\\n```\\nclass Solution {\\n    int ret = 0;\\n\\n   public:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end(), [](vector<int>& lhs, vector<int>& rhs) { return lhs[0] < rhs[0]; });\\n        helper(events, k, 0, 0);\\n        return ret;\\n    }\\n    void helper(const vector<vector<int>>& events, int k, int startidx, int sum) {\\n        if (k <= 0) return;\\n        if (startidx >= events.size()) return;\\n        // don\\'t select\\n        helper(events, k, startidx + 1, sum);\\n        // select\\n        sum += events[startidx][2];\\n        ret = max(ret, sum);\\n        int end = events[startidx][1];\\n\\n        // binary search next startidx\\n        auto it = upper_bound(events.begin() + startidx + 1, events.end(), end,\\n                              [](int end, const vector<int>& lhs) { return lhs[0] > end; });\\n        if (it == events.end()) return;\\n        int newstart = std::distance(events.begin(), it);\\n        helper(events, k - 1, newstart, sum);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "R4Ks",
                        "content": "the hint was very helpful ngl"
                    },
                    {
                        "username": "wajahatx1",
                        "content": "Honestly this one was easier than maximum number of events 1\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "I spent a long time trying to find an algorithm that could be adapted to solve this.\\n\\nThen I decided to go straight to recursive DP, just to see how slow would it go, and not only it got accepted, but by beating 85% of other solutions.\\n\\nDon\\'t be me. Be smart. :)\\n\\nGo straight for a recursive DP :)"
                    }
                ]
            },
            {
                "id": 1971624,
                "content": [
                    {
                        "username": "rohitnehara",
                        "content": "Damn those constraints "
                    },
                    {
                        "username": "khushi3",
                        "content": "It is it only me who find the table diagram in the problem misleading"
                    },
                    {
                        "username": "mahesh105",
                        "content": "No, It actually states boundary of events as per deadline and their value. It clearly helps to know the overlapping events ."
                    },
                    {
                        "username": "anmolasahay27",
                        "content": "Can someone help me figure out why my code failing for the following case\n\nclass Solution {\npublic:\n    #define ll long long\n    vector<vector<int>> events;\n    int n;\n    int inf=1e9;\n    vector <vector<int>> dp;\n\n    int rec(int ind, int k,int pind)\n    {\n        if(k<=0)\n        return 0;\n\n        if(ind==n)\n        return 0;\n\n        if(ind==n-1)\n        {\n            int ans=0;\n            if(pind==-1)\n            ans=max(ans,events[ind][2]);\n            else if(events[pind][1]<=events[ind][0])\n            {\n                ans=max(ans,events[ind][2]);\n            }\n            return ans;\n        }\n\n        if(dp[ind][k]!=-1)\n        return dp[ind][k];\n\n        int ans=0;\n\n        ans=max(ans,rec(ind+1,k,pind));\n\n        if(pind==-1)\n        ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        else if(events[pind][1]<=events[ind][0])\n        {\n            ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        }\n\n        return dp[ind][k]=ans;\n\n    }\n    int maxValue(vector<vector<int>>& event, int k) {\n        events=event;\n        sort(events.begin(),events.end());\n        n=events.size();\n\n        for(int i=0;i<n;i++)\n        {\n            events[i][0]--;\n        }\n        dp.assign(n+5,vector <int>(k+5,-1));\n\n        return rec(0,k,-1);\n\n    }\n};\n\ntest case failing : [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]]"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Just use take not take concept ----:)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Finally figured it out. \n\nUse a heapq to record (endtime, # of events, and its max) will work for me!\n\n[here](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/solutions/3770203/python-dp-heapq-640-ms-100/)"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bye bye streak!"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? It is as the Hints mentioned, sort by start time, select, not select\\n```\\nclass Solution {\\n    int ret = 0;\\n\\n   public:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end(), [](vector<int>& lhs, vector<int>& rhs) { return lhs[0] < rhs[0]; });\\n        helper(events, k, 0, 0);\\n        return ret;\\n    }\\n    void helper(const vector<vector<int>>& events, int k, int startidx, int sum) {\\n        if (k <= 0) return;\\n        if (startidx >= events.size()) return;\\n        // don\\'t select\\n        helper(events, k, startidx + 1, sum);\\n        // select\\n        sum += events[startidx][2];\\n        ret = max(ret, sum);\\n        int end = events[startidx][1];\\n\\n        // binary search next startidx\\n        auto it = upper_bound(events.begin() + startidx + 1, events.end(), end,\\n                              [](int end, const vector<int>& lhs) { return lhs[0] > end; });\\n        if (it == events.end()) return;\\n        int newstart = std::distance(events.begin(), it);\\n        helper(events, k - 1, newstart, sum);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "R4Ks",
                        "content": "the hint was very helpful ngl"
                    },
                    {
                        "username": "wajahatx1",
                        "content": "Honestly this one was easier than maximum number of events 1\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "I spent a long time trying to find an algorithm that could be adapted to solve this.\\n\\nThen I decided to go straight to recursive DP, just to see how slow would it go, and not only it got accepted, but by beating 85% of other solutions.\\n\\nDon\\'t be me. Be smart. :)\\n\\nGo straight for a recursive DP :)"
                    }
                ]
            },
            {
                "id": 1971613,
                "content": [
                    {
                        "username": "rohitnehara",
                        "content": "Damn those constraints "
                    },
                    {
                        "username": "khushi3",
                        "content": "It is it only me who find the table diagram in the problem misleading"
                    },
                    {
                        "username": "mahesh105",
                        "content": "No, It actually states boundary of events as per deadline and their value. It clearly helps to know the overlapping events ."
                    },
                    {
                        "username": "anmolasahay27",
                        "content": "Can someone help me figure out why my code failing for the following case\n\nclass Solution {\npublic:\n    #define ll long long\n    vector<vector<int>> events;\n    int n;\n    int inf=1e9;\n    vector <vector<int>> dp;\n\n    int rec(int ind, int k,int pind)\n    {\n        if(k<=0)\n        return 0;\n\n        if(ind==n)\n        return 0;\n\n        if(ind==n-1)\n        {\n            int ans=0;\n            if(pind==-1)\n            ans=max(ans,events[ind][2]);\n            else if(events[pind][1]<=events[ind][0])\n            {\n                ans=max(ans,events[ind][2]);\n            }\n            return ans;\n        }\n\n        if(dp[ind][k]!=-1)\n        return dp[ind][k];\n\n        int ans=0;\n\n        ans=max(ans,rec(ind+1,k,pind));\n\n        if(pind==-1)\n        ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        else if(events[pind][1]<=events[ind][0])\n        {\n            ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        }\n\n        return dp[ind][k]=ans;\n\n    }\n    int maxValue(vector<vector<int>>& event, int k) {\n        events=event;\n        sort(events.begin(),events.end());\n        n=events.size();\n\n        for(int i=0;i<n;i++)\n        {\n            events[i][0]--;\n        }\n        dp.assign(n+5,vector <int>(k+5,-1));\n\n        return rec(0,k,-1);\n\n    }\n};\n\ntest case failing : [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]]"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Just use take not take concept ----:)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Finally figured it out. \n\nUse a heapq to record (endtime, # of events, and its max) will work for me!\n\n[here](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/solutions/3770203/python-dp-heapq-640-ms-100/)"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bye bye streak!"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? It is as the Hints mentioned, sort by start time, select, not select\\n```\\nclass Solution {\\n    int ret = 0;\\n\\n   public:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end(), [](vector<int>& lhs, vector<int>& rhs) { return lhs[0] < rhs[0]; });\\n        helper(events, k, 0, 0);\\n        return ret;\\n    }\\n    void helper(const vector<vector<int>>& events, int k, int startidx, int sum) {\\n        if (k <= 0) return;\\n        if (startidx >= events.size()) return;\\n        // don\\'t select\\n        helper(events, k, startidx + 1, sum);\\n        // select\\n        sum += events[startidx][2];\\n        ret = max(ret, sum);\\n        int end = events[startidx][1];\\n\\n        // binary search next startidx\\n        auto it = upper_bound(events.begin() + startidx + 1, events.end(), end,\\n                              [](int end, const vector<int>& lhs) { return lhs[0] > end; });\\n        if (it == events.end()) return;\\n        int newstart = std::distance(events.begin(), it);\\n        helper(events, k - 1, newstart, sum);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "R4Ks",
                        "content": "the hint was very helpful ngl"
                    },
                    {
                        "username": "wajahatx1",
                        "content": "Honestly this one was easier than maximum number of events 1\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "I spent a long time trying to find an algorithm that could be adapted to solve this.\\n\\nThen I decided to go straight to recursive DP, just to see how slow would it go, and not only it got accepted, but by beating 85% of other solutions.\\n\\nDon\\'t be me. Be smart. :)\\n\\nGo straight for a recursive DP :)"
                    }
                ]
            },
            {
                "id": 1971528,
                "content": [
                    {
                        "username": "rohitnehara",
                        "content": "Damn those constraints "
                    },
                    {
                        "username": "khushi3",
                        "content": "It is it only me who find the table diagram in the problem misleading"
                    },
                    {
                        "username": "mahesh105",
                        "content": "No, It actually states boundary of events as per deadline and their value. It clearly helps to know the overlapping events ."
                    },
                    {
                        "username": "anmolasahay27",
                        "content": "Can someone help me figure out why my code failing for the following case\n\nclass Solution {\npublic:\n    #define ll long long\n    vector<vector<int>> events;\n    int n;\n    int inf=1e9;\n    vector <vector<int>> dp;\n\n    int rec(int ind, int k,int pind)\n    {\n        if(k<=0)\n        return 0;\n\n        if(ind==n)\n        return 0;\n\n        if(ind==n-1)\n        {\n            int ans=0;\n            if(pind==-1)\n            ans=max(ans,events[ind][2]);\n            else if(events[pind][1]<=events[ind][0])\n            {\n                ans=max(ans,events[ind][2]);\n            }\n            return ans;\n        }\n\n        if(dp[ind][k]!=-1)\n        return dp[ind][k];\n\n        int ans=0;\n\n        ans=max(ans,rec(ind+1,k,pind));\n\n        if(pind==-1)\n        ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        else if(events[pind][1]<=events[ind][0])\n        {\n            ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        }\n\n        return dp[ind][k]=ans;\n\n    }\n    int maxValue(vector<vector<int>>& event, int k) {\n        events=event;\n        sort(events.begin(),events.end());\n        n=events.size();\n\n        for(int i=0;i<n;i++)\n        {\n            events[i][0]--;\n        }\n        dp.assign(n+5,vector <int>(k+5,-1));\n\n        return rec(0,k,-1);\n\n    }\n};\n\ntest case failing : [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]]"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Just use take not take concept ----:)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Finally figured it out. \n\nUse a heapq to record (endtime, # of events, and its max) will work for me!\n\n[here](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/solutions/3770203/python-dp-heapq-640-ms-100/)"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bye bye streak!"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? It is as the Hints mentioned, sort by start time, select, not select\\n```\\nclass Solution {\\n    int ret = 0;\\n\\n   public:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end(), [](vector<int>& lhs, vector<int>& rhs) { return lhs[0] < rhs[0]; });\\n        helper(events, k, 0, 0);\\n        return ret;\\n    }\\n    void helper(const vector<vector<int>>& events, int k, int startidx, int sum) {\\n        if (k <= 0) return;\\n        if (startidx >= events.size()) return;\\n        // don\\'t select\\n        helper(events, k, startidx + 1, sum);\\n        // select\\n        sum += events[startidx][2];\\n        ret = max(ret, sum);\\n        int end = events[startidx][1];\\n\\n        // binary search next startidx\\n        auto it = upper_bound(events.begin() + startidx + 1, events.end(), end,\\n                              [](int end, const vector<int>& lhs) { return lhs[0] > end; });\\n        if (it == events.end()) return;\\n        int newstart = std::distance(events.begin(), it);\\n        helper(events, k - 1, newstart, sum);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "R4Ks",
                        "content": "the hint was very helpful ngl"
                    },
                    {
                        "username": "wajahatx1",
                        "content": "Honestly this one was easier than maximum number of events 1\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "I spent a long time trying to find an algorithm that could be adapted to solve this.\\n\\nThen I decided to go straight to recursive DP, just to see how slow would it go, and not only it got accepted, but by beating 85% of other solutions.\\n\\nDon\\'t be me. Be smart. :)\\n\\nGo straight for a recursive DP :)"
                    }
                ]
            },
            {
                "id": 1971484,
                "content": [
                    {
                        "username": "rohitnehara",
                        "content": "Damn those constraints "
                    },
                    {
                        "username": "khushi3",
                        "content": "It is it only me who find the table diagram in the problem misleading"
                    },
                    {
                        "username": "mahesh105",
                        "content": "No, It actually states boundary of events as per deadline and their value. It clearly helps to know the overlapping events ."
                    },
                    {
                        "username": "anmolasahay27",
                        "content": "Can someone help me figure out why my code failing for the following case\n\nclass Solution {\npublic:\n    #define ll long long\n    vector<vector<int>> events;\n    int n;\n    int inf=1e9;\n    vector <vector<int>> dp;\n\n    int rec(int ind, int k,int pind)\n    {\n        if(k<=0)\n        return 0;\n\n        if(ind==n)\n        return 0;\n\n        if(ind==n-1)\n        {\n            int ans=0;\n            if(pind==-1)\n            ans=max(ans,events[ind][2]);\n            else if(events[pind][1]<=events[ind][0])\n            {\n                ans=max(ans,events[ind][2]);\n            }\n            return ans;\n        }\n\n        if(dp[ind][k]!=-1)\n        return dp[ind][k];\n\n        int ans=0;\n\n        ans=max(ans,rec(ind+1,k,pind));\n\n        if(pind==-1)\n        ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        else if(events[pind][1]<=events[ind][0])\n        {\n            ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        }\n\n        return dp[ind][k]=ans;\n\n    }\n    int maxValue(vector<vector<int>>& event, int k) {\n        events=event;\n        sort(events.begin(),events.end());\n        n=events.size();\n\n        for(int i=0;i<n;i++)\n        {\n            events[i][0]--;\n        }\n        dp.assign(n+5,vector <int>(k+5,-1));\n\n        return rec(0,k,-1);\n\n    }\n};\n\ntest case failing : [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]]"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Just use take not take concept ----:)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Finally figured it out. \n\nUse a heapq to record (endtime, # of events, and its max) will work for me!\n\n[here](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/solutions/3770203/python-dp-heapq-640-ms-100/)"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bye bye streak!"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? It is as the Hints mentioned, sort by start time, select, not select\\n```\\nclass Solution {\\n    int ret = 0;\\n\\n   public:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end(), [](vector<int>& lhs, vector<int>& rhs) { return lhs[0] < rhs[0]; });\\n        helper(events, k, 0, 0);\\n        return ret;\\n    }\\n    void helper(const vector<vector<int>>& events, int k, int startidx, int sum) {\\n        if (k <= 0) return;\\n        if (startidx >= events.size()) return;\\n        // don\\'t select\\n        helper(events, k, startidx + 1, sum);\\n        // select\\n        sum += events[startidx][2];\\n        ret = max(ret, sum);\\n        int end = events[startidx][1];\\n\\n        // binary search next startidx\\n        auto it = upper_bound(events.begin() + startidx + 1, events.end(), end,\\n                              [](int end, const vector<int>& lhs) { return lhs[0] > end; });\\n        if (it == events.end()) return;\\n        int newstart = std::distance(events.begin(), it);\\n        helper(events, k - 1, newstart, sum);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "R4Ks",
                        "content": "the hint was very helpful ngl"
                    },
                    {
                        "username": "wajahatx1",
                        "content": "Honestly this one was easier than maximum number of events 1\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "I spent a long time trying to find an algorithm that could be adapted to solve this.\\n\\nThen I decided to go straight to recursive DP, just to see how slow would it go, and not only it got accepted, but by beating 85% of other solutions.\\n\\nDon\\'t be me. Be smart. :)\\n\\nGo straight for a recursive DP :)"
                    }
                ]
            },
            {
                "id": 1971475,
                "content": [
                    {
                        "username": "rohitnehara",
                        "content": "Damn those constraints "
                    },
                    {
                        "username": "khushi3",
                        "content": "It is it only me who find the table diagram in the problem misleading"
                    },
                    {
                        "username": "mahesh105",
                        "content": "No, It actually states boundary of events as per deadline and their value. It clearly helps to know the overlapping events ."
                    },
                    {
                        "username": "anmolasahay27",
                        "content": "Can someone help me figure out why my code failing for the following case\n\nclass Solution {\npublic:\n    #define ll long long\n    vector<vector<int>> events;\n    int n;\n    int inf=1e9;\n    vector <vector<int>> dp;\n\n    int rec(int ind, int k,int pind)\n    {\n        if(k<=0)\n        return 0;\n\n        if(ind==n)\n        return 0;\n\n        if(ind==n-1)\n        {\n            int ans=0;\n            if(pind==-1)\n            ans=max(ans,events[ind][2]);\n            else if(events[pind][1]<=events[ind][0])\n            {\n                ans=max(ans,events[ind][2]);\n            }\n            return ans;\n        }\n\n        if(dp[ind][k]!=-1)\n        return dp[ind][k];\n\n        int ans=0;\n\n        ans=max(ans,rec(ind+1,k,pind));\n\n        if(pind==-1)\n        ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        else if(events[pind][1]<=events[ind][0])\n        {\n            ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        }\n\n        return dp[ind][k]=ans;\n\n    }\n    int maxValue(vector<vector<int>>& event, int k) {\n        events=event;\n        sort(events.begin(),events.end());\n        n=events.size();\n\n        for(int i=0;i<n;i++)\n        {\n            events[i][0]--;\n        }\n        dp.assign(n+5,vector <int>(k+5,-1));\n\n        return rec(0,k,-1);\n\n    }\n};\n\ntest case failing : [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]]"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Just use take not take concept ----:)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Finally figured it out. \n\nUse a heapq to record (endtime, # of events, and its max) will work for me!\n\n[here](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/solutions/3770203/python-dp-heapq-640-ms-100/)"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bye bye streak!"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? It is as the Hints mentioned, sort by start time, select, not select\\n```\\nclass Solution {\\n    int ret = 0;\\n\\n   public:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end(), [](vector<int>& lhs, vector<int>& rhs) { return lhs[0] < rhs[0]; });\\n        helper(events, k, 0, 0);\\n        return ret;\\n    }\\n    void helper(const vector<vector<int>>& events, int k, int startidx, int sum) {\\n        if (k <= 0) return;\\n        if (startidx >= events.size()) return;\\n        // don\\'t select\\n        helper(events, k, startidx + 1, sum);\\n        // select\\n        sum += events[startidx][2];\\n        ret = max(ret, sum);\\n        int end = events[startidx][1];\\n\\n        // binary search next startidx\\n        auto it = upper_bound(events.begin() + startidx + 1, events.end(), end,\\n                              [](int end, const vector<int>& lhs) { return lhs[0] > end; });\\n        if (it == events.end()) return;\\n        int newstart = std::distance(events.begin(), it);\\n        helper(events, k - 1, newstart, sum);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "R4Ks",
                        "content": "the hint was very helpful ngl"
                    },
                    {
                        "username": "wajahatx1",
                        "content": "Honestly this one was easier than maximum number of events 1\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "I spent a long time trying to find an algorithm that could be adapted to solve this.\\n\\nThen I decided to go straight to recursive DP, just to see how slow would it go, and not only it got accepted, but by beating 85% of other solutions.\\n\\nDon\\'t be me. Be smart. :)\\n\\nGo straight for a recursive DP :)"
                    }
                ]
            },
            {
                "id": 1971383,
                "content": [
                    {
                        "username": "rohitnehara",
                        "content": "Damn those constraints "
                    },
                    {
                        "username": "khushi3",
                        "content": "It is it only me who find the table diagram in the problem misleading"
                    },
                    {
                        "username": "mahesh105",
                        "content": "No, It actually states boundary of events as per deadline and their value. It clearly helps to know the overlapping events ."
                    },
                    {
                        "username": "anmolasahay27",
                        "content": "Can someone help me figure out why my code failing for the following case\n\nclass Solution {\npublic:\n    #define ll long long\n    vector<vector<int>> events;\n    int n;\n    int inf=1e9;\n    vector <vector<int>> dp;\n\n    int rec(int ind, int k,int pind)\n    {\n        if(k<=0)\n        return 0;\n\n        if(ind==n)\n        return 0;\n\n        if(ind==n-1)\n        {\n            int ans=0;\n            if(pind==-1)\n            ans=max(ans,events[ind][2]);\n            else if(events[pind][1]<=events[ind][0])\n            {\n                ans=max(ans,events[ind][2]);\n            }\n            return ans;\n        }\n\n        if(dp[ind][k]!=-1)\n        return dp[ind][k];\n\n        int ans=0;\n\n        ans=max(ans,rec(ind+1,k,pind));\n\n        if(pind==-1)\n        ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        else if(events[pind][1]<=events[ind][0])\n        {\n            ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        }\n\n        return dp[ind][k]=ans;\n\n    }\n    int maxValue(vector<vector<int>>& event, int k) {\n        events=event;\n        sort(events.begin(),events.end());\n        n=events.size();\n\n        for(int i=0;i<n;i++)\n        {\n            events[i][0]--;\n        }\n        dp.assign(n+5,vector <int>(k+5,-1));\n\n        return rec(0,k,-1);\n\n    }\n};\n\ntest case failing : [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]]"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Just use take not take concept ----:)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Finally figured it out. \n\nUse a heapq to record (endtime, # of events, and its max) will work for me!\n\n[here](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/solutions/3770203/python-dp-heapq-640-ms-100/)"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bye bye streak!"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? It is as the Hints mentioned, sort by start time, select, not select\\n```\\nclass Solution {\\n    int ret = 0;\\n\\n   public:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end(), [](vector<int>& lhs, vector<int>& rhs) { return lhs[0] < rhs[0]; });\\n        helper(events, k, 0, 0);\\n        return ret;\\n    }\\n    void helper(const vector<vector<int>>& events, int k, int startidx, int sum) {\\n        if (k <= 0) return;\\n        if (startidx >= events.size()) return;\\n        // don\\'t select\\n        helper(events, k, startidx + 1, sum);\\n        // select\\n        sum += events[startidx][2];\\n        ret = max(ret, sum);\\n        int end = events[startidx][1];\\n\\n        // binary search next startidx\\n        auto it = upper_bound(events.begin() + startidx + 1, events.end(), end,\\n                              [](int end, const vector<int>& lhs) { return lhs[0] > end; });\\n        if (it == events.end()) return;\\n        int newstart = std::distance(events.begin(), it);\\n        helper(events, k - 1, newstart, sum);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "R4Ks",
                        "content": "the hint was very helpful ngl"
                    },
                    {
                        "username": "wajahatx1",
                        "content": "Honestly this one was easier than maximum number of events 1\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "I spent a long time trying to find an algorithm that could be adapted to solve this.\\n\\nThen I decided to go straight to recursive DP, just to see how slow would it go, and not only it got accepted, but by beating 85% of other solutions.\\n\\nDon\\'t be me. Be smart. :)\\n\\nGo straight for a recursive DP :)"
                    }
                ]
            },
            {
                "id": 1971287,
                "content": [
                    {
                        "username": "rohitnehara",
                        "content": "Damn those constraints "
                    },
                    {
                        "username": "khushi3",
                        "content": "It is it only me who find the table diagram in the problem misleading"
                    },
                    {
                        "username": "mahesh105",
                        "content": "No, It actually states boundary of events as per deadline and their value. It clearly helps to know the overlapping events ."
                    },
                    {
                        "username": "anmolasahay27",
                        "content": "Can someone help me figure out why my code failing for the following case\n\nclass Solution {\npublic:\n    #define ll long long\n    vector<vector<int>> events;\n    int n;\n    int inf=1e9;\n    vector <vector<int>> dp;\n\n    int rec(int ind, int k,int pind)\n    {\n        if(k<=0)\n        return 0;\n\n        if(ind==n)\n        return 0;\n\n        if(ind==n-1)\n        {\n            int ans=0;\n            if(pind==-1)\n            ans=max(ans,events[ind][2]);\n            else if(events[pind][1]<=events[ind][0])\n            {\n                ans=max(ans,events[ind][2]);\n            }\n            return ans;\n        }\n\n        if(dp[ind][k]!=-1)\n        return dp[ind][k];\n\n        int ans=0;\n\n        ans=max(ans,rec(ind+1,k,pind));\n\n        if(pind==-1)\n        ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        else if(events[pind][1]<=events[ind][0])\n        {\n            ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        }\n\n        return dp[ind][k]=ans;\n\n    }\n    int maxValue(vector<vector<int>>& event, int k) {\n        events=event;\n        sort(events.begin(),events.end());\n        n=events.size();\n\n        for(int i=0;i<n;i++)\n        {\n            events[i][0]--;\n        }\n        dp.assign(n+5,vector <int>(k+5,-1));\n\n        return rec(0,k,-1);\n\n    }\n};\n\ntest case failing : [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]]"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Just use take not take concept ----:)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Finally figured it out. \n\nUse a heapq to record (endtime, # of events, and its max) will work for me!\n\n[here](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/solutions/3770203/python-dp-heapq-640-ms-100/)"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bye bye streak!"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? It is as the Hints mentioned, sort by start time, select, not select\\n```\\nclass Solution {\\n    int ret = 0;\\n\\n   public:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end(), [](vector<int>& lhs, vector<int>& rhs) { return lhs[0] < rhs[0]; });\\n        helper(events, k, 0, 0);\\n        return ret;\\n    }\\n    void helper(const vector<vector<int>>& events, int k, int startidx, int sum) {\\n        if (k <= 0) return;\\n        if (startidx >= events.size()) return;\\n        // don\\'t select\\n        helper(events, k, startidx + 1, sum);\\n        // select\\n        sum += events[startidx][2];\\n        ret = max(ret, sum);\\n        int end = events[startidx][1];\\n\\n        // binary search next startidx\\n        auto it = upper_bound(events.begin() + startidx + 1, events.end(), end,\\n                              [](int end, const vector<int>& lhs) { return lhs[0] > end; });\\n        if (it == events.end()) return;\\n        int newstart = std::distance(events.begin(), it);\\n        helper(events, k - 1, newstart, sum);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "R4Ks",
                        "content": "the hint was very helpful ngl"
                    },
                    {
                        "username": "wajahatx1",
                        "content": "Honestly this one was easier than maximum number of events 1\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "I spent a long time trying to find an algorithm that could be adapted to solve this.\\n\\nThen I decided to go straight to recursive DP, just to see how slow would it go, and not only it got accepted, but by beating 85% of other solutions.\\n\\nDon\\'t be me. Be smart. :)\\n\\nGo straight for a recursive DP :)"
                    }
                ]
            },
            {
                "id": 1971236,
                "content": [
                    {
                        "username": "rohitnehara",
                        "content": "Damn those constraints "
                    },
                    {
                        "username": "khushi3",
                        "content": "It is it only me who find the table diagram in the problem misleading"
                    },
                    {
                        "username": "mahesh105",
                        "content": "No, It actually states boundary of events as per deadline and their value. It clearly helps to know the overlapping events ."
                    },
                    {
                        "username": "anmolasahay27",
                        "content": "Can someone help me figure out why my code failing for the following case\n\nclass Solution {\npublic:\n    #define ll long long\n    vector<vector<int>> events;\n    int n;\n    int inf=1e9;\n    vector <vector<int>> dp;\n\n    int rec(int ind, int k,int pind)\n    {\n        if(k<=0)\n        return 0;\n\n        if(ind==n)\n        return 0;\n\n        if(ind==n-1)\n        {\n            int ans=0;\n            if(pind==-1)\n            ans=max(ans,events[ind][2]);\n            else if(events[pind][1]<=events[ind][0])\n            {\n                ans=max(ans,events[ind][2]);\n            }\n            return ans;\n        }\n\n        if(dp[ind][k]!=-1)\n        return dp[ind][k];\n\n        int ans=0;\n\n        ans=max(ans,rec(ind+1,k,pind));\n\n        if(pind==-1)\n        ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        else if(events[pind][1]<=events[ind][0])\n        {\n            ans=max(ans,rec(ind+1,k-1,ind)+events[ind][2]);\n        }\n\n        return dp[ind][k]=ans;\n\n    }\n    int maxValue(vector<vector<int>>& event, int k) {\n        events=event;\n        sort(events.begin(),events.end());\n        n=events.size();\n\n        for(int i=0;i<n;i++)\n        {\n            events[i][0]--;\n        }\n        dp.assign(n+5,vector <int>(k+5,-1));\n\n        return rec(0,k,-1);\n\n    }\n};\n\ntest case failing : [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]]"
                    },
                    {
                        "username": "yash_raileet",
                        "content": "Just use take not take concept ----:)"
                    },
                    {
                        "username": "czjnbb",
                        "content": "Finally figured it out. \n\nUse a heapq to record (endtime, # of events, and its max) will work for me!\n\n[here](https://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/solutions/3770203/python-dp-heapq-640-ms-100/)"
                    },
                    {
                        "username": "jaggz01",
                        "content": "Bye bye streak!"
                    },
                    {
                        "username": "uniqs",
                        "content": "why my code not working? It is as the Hints mentioned, sort by start time, select, not select\\n```\\nclass Solution {\\n    int ret = 0;\\n\\n   public:\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end(), [](vector<int>& lhs, vector<int>& rhs) { return lhs[0] < rhs[0]; });\\n        helper(events, k, 0, 0);\\n        return ret;\\n    }\\n    void helper(const vector<vector<int>>& events, int k, int startidx, int sum) {\\n        if (k <= 0) return;\\n        if (startidx >= events.size()) return;\\n        // don\\'t select\\n        helper(events, k, startidx + 1, sum);\\n        // select\\n        sum += events[startidx][2];\\n        ret = max(ret, sum);\\n        int end = events[startidx][1];\\n\\n        // binary search next startidx\\n        auto it = upper_bound(events.begin() + startidx + 1, events.end(), end,\\n                              [](int end, const vector<int>& lhs) { return lhs[0] > end; });\\n        if (it == events.end()) return;\\n        int newstart = std::distance(events.begin(), it);\\n        helper(events, k - 1, newstart, sum);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "R4Ks",
                        "content": "the hint was very helpful ngl"
                    },
                    {
                        "username": "wajahatx1",
                        "content": "Honestly this one was easier than maximum number of events 1\\n"
                    },
                    {
                        "username": "nandoaires",
                        "content": "I spent a long time trying to find an algorithm that could be adapted to solve this.\\n\\nThen I decided to go straight to recursive DP, just to see how slow would it go, and not only it got accepted, but by beating 85% of other solutions.\\n\\nDon\\'t be me. Be smart. :)\\n\\nGo straight for a recursive DP :)"
                    }
                ]
            },
            {
                "id": 1971193,
                "content": [
                    {
                        "username": "shresthamanxil",
                        "content": "what category does this question fall into?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I\\'d say DP, it\\'s most like a knap sack problem. You can see the tags at the bottom here"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Can anyone Help why this fails at second test case\n\n ```\nclass Solution {\npublic:\n    int fun(int i, vector<vector<int>>& eve, int k, int prevEnd, vector<vector<int>>& dp) {\n        if(i == eve.size())   return 0;\n        if(dp[i][k] != -1) return dp[i][k];\n        int take = 0;\n        if(k > 0 && prevEnd < eve[i][0]) {\n            take = eve[i][2] + fun(i + 1, eve, k - 1, eve[i][1], dp);\n        }\n        int notTake = fun(i + 1, eve, k, prevEnd, dp);\n        return dp[i][k] = max(take, notTake);\n    }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n = events.size();\n        sort(events.begin(), events.end());\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1));\n        return fun(0, events, k, -1, dp);\n    }\n};\n```"
                    },
                    {
                        "username": "vanshajduggal1234",
                        "content": "[@saudkhan07](/saudkhan07)  You also need to take prev element into account"
                    },
                    {
                        "username": "saudkhan07",
                        "content": "Did you figure it out. I am also stuck at the same place.\\n"
                    },
                    {
                        "username": "had0uken",
                        "content": "Yep, this is definitely the end of my strick ) "
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good one, similar to this one [projects]( https://cses.fi/problemset/task/1140)\nonly difference is limit of k events. and that makes this one even better "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I went with a 2D DP approach where the states are `[k , maxi]` where maxi is the last day value and got RTE :_(\\n\\nI\\'ve been encountering a lotta problems in the recent days where my solution\\'s logic is correct and has an acceptable T.C but fails in S.C !!"
                    },
                    {
                        "username": "amanmishra_20",
                        "content": "Here in this my code i just used map of pair of pairs for storing states.Rest is take or not take. 64/67 test cases passed succesfully. On test case 65 giving tle. Can someone tell me what to optimize a little bit more in this code??\\n\\nclass Solution {\\npublic:\\n    int fun(vector<int>& s,vector<int>& e,vector<int>& v,int i,int ans,int le,int k,map<pair<pair<int,int>,pair<int,int>>,int>& m){\\n         if(i==s.size())return ans;\\n         if(k==0)return ans;\\n         int take=-1,ntake=-1;\\n         if(s[i]>le){\\n             if(m.find({{i+1,ans+v[i]},{e[i],k-1}})!=m.end())\\n             take=m[{{i+1,ans+v[i]},{e[i],k-1}}];\\n             else take=fun(s,e,v,i+1,ans+v[i],e[i],k-1,m);\\n         }\\n         if(m.find({{i+1,ans},{le,k}})!=m.end())\\n             ntake=m[{{i+1,ans},{le,k}}];\\n             else ntake=fun(s,e,v,i+1,ans,le,k,m);\\n         return m[{{i,ans},{le,k}}]=max(take,ntake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        map<pair<pair<int,int>,pair<int,int>>,int>m;\\n        sort(events.begin(),events.end(),[&](vector<int>v1,vector<int>v2){\\n              if(v1[0]<v2[0])return true;\\n              else if(v1[0]==v2[0])return v1[1]<=v2[1];\\n              else return false;\\n        });\\n        vector<int>s,e,v;\\n        for(int i=0;i<events.size();i++){\\n            s.push_back(events[i][0]);\\n            e.push_back(events[i][1]);\\n            v.push_back(events[i][2]);\\n        }\\n        return fun(s,e,v,0,0,-1,k,m);\\n    }\\n};"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "Can anyone tell me what i am doing wrong\\n `class Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>> &events, int k, int ind, vector<vector<int>> &dp){\\n        int n = events.size();\\n        if(ind>=n || k<=0)\\n            return 0;\\n        if(dp[ind][k]!=-1)\\n            return dp[ind][k];\\n        for(int i=ind+1; i<n; i++){\\n            if(events[i][0]>events[ind][1])\\n                break;\\n        }\\n        return dp[ind][k] = max(events[ind][2]+dfs(events, k-1, ind+1, dp), dfs(events, k, ind+1, dp));      \\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        int n = events.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        return dfs(events, k, 0, dp);\\n    }\\n};`"
                    },
                    {
                        "username": "ironblade",
                        "content": "again and again runtime \\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14"
                    },
                    {
                        "username": "atharva_777",
                        "content": "I think Leetcode\\'s problem setting team and problem description team has a serious issues \\uD83D\\uDE02"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "[[1,1,1],[2,2,2],[3,3,3],[4,4,4]] , k = 3\\n\\nin this testcase , my vscode is giving the correct answer  9  but leetcode is giving 7. how it is possible ?"
                    }
                ]
            },
            {
                "id": 1971175,
                "content": [
                    {
                        "username": "shresthamanxil",
                        "content": "what category does this question fall into?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I\\'d say DP, it\\'s most like a knap sack problem. You can see the tags at the bottom here"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Can anyone Help why this fails at second test case\n\n ```\nclass Solution {\npublic:\n    int fun(int i, vector<vector<int>>& eve, int k, int prevEnd, vector<vector<int>>& dp) {\n        if(i == eve.size())   return 0;\n        if(dp[i][k] != -1) return dp[i][k];\n        int take = 0;\n        if(k > 0 && prevEnd < eve[i][0]) {\n            take = eve[i][2] + fun(i + 1, eve, k - 1, eve[i][1], dp);\n        }\n        int notTake = fun(i + 1, eve, k, prevEnd, dp);\n        return dp[i][k] = max(take, notTake);\n    }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n = events.size();\n        sort(events.begin(), events.end());\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1));\n        return fun(0, events, k, -1, dp);\n    }\n};\n```"
                    },
                    {
                        "username": "vanshajduggal1234",
                        "content": "[@saudkhan07](/saudkhan07)  You also need to take prev element into account"
                    },
                    {
                        "username": "saudkhan07",
                        "content": "Did you figure it out. I am also stuck at the same place.\\n"
                    },
                    {
                        "username": "had0uken",
                        "content": "Yep, this is definitely the end of my strick ) "
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good one, similar to this one [projects]( https://cses.fi/problemset/task/1140)\nonly difference is limit of k events. and that makes this one even better "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I went with a 2D DP approach where the states are `[k , maxi]` where maxi is the last day value and got RTE :_(\\n\\nI\\'ve been encountering a lotta problems in the recent days where my solution\\'s logic is correct and has an acceptable T.C but fails in S.C !!"
                    },
                    {
                        "username": "amanmishra_20",
                        "content": "Here in this my code i just used map of pair of pairs for storing states.Rest is take or not take. 64/67 test cases passed succesfully. On test case 65 giving tle. Can someone tell me what to optimize a little bit more in this code??\\n\\nclass Solution {\\npublic:\\n    int fun(vector<int>& s,vector<int>& e,vector<int>& v,int i,int ans,int le,int k,map<pair<pair<int,int>,pair<int,int>>,int>& m){\\n         if(i==s.size())return ans;\\n         if(k==0)return ans;\\n         int take=-1,ntake=-1;\\n         if(s[i]>le){\\n             if(m.find({{i+1,ans+v[i]},{e[i],k-1}})!=m.end())\\n             take=m[{{i+1,ans+v[i]},{e[i],k-1}}];\\n             else take=fun(s,e,v,i+1,ans+v[i],e[i],k-1,m);\\n         }\\n         if(m.find({{i+1,ans},{le,k}})!=m.end())\\n             ntake=m[{{i+1,ans},{le,k}}];\\n             else ntake=fun(s,e,v,i+1,ans,le,k,m);\\n         return m[{{i,ans},{le,k}}]=max(take,ntake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        map<pair<pair<int,int>,pair<int,int>>,int>m;\\n        sort(events.begin(),events.end(),[&](vector<int>v1,vector<int>v2){\\n              if(v1[0]<v2[0])return true;\\n              else if(v1[0]==v2[0])return v1[1]<=v2[1];\\n              else return false;\\n        });\\n        vector<int>s,e,v;\\n        for(int i=0;i<events.size();i++){\\n            s.push_back(events[i][0]);\\n            e.push_back(events[i][1]);\\n            v.push_back(events[i][2]);\\n        }\\n        return fun(s,e,v,0,0,-1,k,m);\\n    }\\n};"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "Can anyone tell me what i am doing wrong\\n `class Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>> &events, int k, int ind, vector<vector<int>> &dp){\\n        int n = events.size();\\n        if(ind>=n || k<=0)\\n            return 0;\\n        if(dp[ind][k]!=-1)\\n            return dp[ind][k];\\n        for(int i=ind+1; i<n; i++){\\n            if(events[i][0]>events[ind][1])\\n                break;\\n        }\\n        return dp[ind][k] = max(events[ind][2]+dfs(events, k-1, ind+1, dp), dfs(events, k, ind+1, dp));      \\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        int n = events.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        return dfs(events, k, 0, dp);\\n    }\\n};`"
                    },
                    {
                        "username": "ironblade",
                        "content": "again and again runtime \\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14"
                    },
                    {
                        "username": "atharva_777",
                        "content": "I think Leetcode\\'s problem setting team and problem description team has a serious issues \\uD83D\\uDE02"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "[[1,1,1],[2,2,2],[3,3,3],[4,4,4]] , k = 3\\n\\nin this testcase , my vscode is giving the correct answer  9  but leetcode is giving 7. how it is possible ?"
                    }
                ]
            },
            {
                "id": 1971151,
                "content": [
                    {
                        "username": "shresthamanxil",
                        "content": "what category does this question fall into?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I\\'d say DP, it\\'s most like a knap sack problem. You can see the tags at the bottom here"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Can anyone Help why this fails at second test case\n\n ```\nclass Solution {\npublic:\n    int fun(int i, vector<vector<int>>& eve, int k, int prevEnd, vector<vector<int>>& dp) {\n        if(i == eve.size())   return 0;\n        if(dp[i][k] != -1) return dp[i][k];\n        int take = 0;\n        if(k > 0 && prevEnd < eve[i][0]) {\n            take = eve[i][2] + fun(i + 1, eve, k - 1, eve[i][1], dp);\n        }\n        int notTake = fun(i + 1, eve, k, prevEnd, dp);\n        return dp[i][k] = max(take, notTake);\n    }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n = events.size();\n        sort(events.begin(), events.end());\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1));\n        return fun(0, events, k, -1, dp);\n    }\n};\n```"
                    },
                    {
                        "username": "vanshajduggal1234",
                        "content": "[@saudkhan07](/saudkhan07)  You also need to take prev element into account"
                    },
                    {
                        "username": "saudkhan07",
                        "content": "Did you figure it out. I am also stuck at the same place.\\n"
                    },
                    {
                        "username": "had0uken",
                        "content": "Yep, this is definitely the end of my strick ) "
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good one, similar to this one [projects]( https://cses.fi/problemset/task/1140)\nonly difference is limit of k events. and that makes this one even better "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I went with a 2D DP approach where the states are `[k , maxi]` where maxi is the last day value and got RTE :_(\\n\\nI\\'ve been encountering a lotta problems in the recent days where my solution\\'s logic is correct and has an acceptable T.C but fails in S.C !!"
                    },
                    {
                        "username": "amanmishra_20",
                        "content": "Here in this my code i just used map of pair of pairs for storing states.Rest is take or not take. 64/67 test cases passed succesfully. On test case 65 giving tle. Can someone tell me what to optimize a little bit more in this code??\\n\\nclass Solution {\\npublic:\\n    int fun(vector<int>& s,vector<int>& e,vector<int>& v,int i,int ans,int le,int k,map<pair<pair<int,int>,pair<int,int>>,int>& m){\\n         if(i==s.size())return ans;\\n         if(k==0)return ans;\\n         int take=-1,ntake=-1;\\n         if(s[i]>le){\\n             if(m.find({{i+1,ans+v[i]},{e[i],k-1}})!=m.end())\\n             take=m[{{i+1,ans+v[i]},{e[i],k-1}}];\\n             else take=fun(s,e,v,i+1,ans+v[i],e[i],k-1,m);\\n         }\\n         if(m.find({{i+1,ans},{le,k}})!=m.end())\\n             ntake=m[{{i+1,ans},{le,k}}];\\n             else ntake=fun(s,e,v,i+1,ans,le,k,m);\\n         return m[{{i,ans},{le,k}}]=max(take,ntake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        map<pair<pair<int,int>,pair<int,int>>,int>m;\\n        sort(events.begin(),events.end(),[&](vector<int>v1,vector<int>v2){\\n              if(v1[0]<v2[0])return true;\\n              else if(v1[0]==v2[0])return v1[1]<=v2[1];\\n              else return false;\\n        });\\n        vector<int>s,e,v;\\n        for(int i=0;i<events.size();i++){\\n            s.push_back(events[i][0]);\\n            e.push_back(events[i][1]);\\n            v.push_back(events[i][2]);\\n        }\\n        return fun(s,e,v,0,0,-1,k,m);\\n    }\\n};"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "Can anyone tell me what i am doing wrong\\n `class Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>> &events, int k, int ind, vector<vector<int>> &dp){\\n        int n = events.size();\\n        if(ind>=n || k<=0)\\n            return 0;\\n        if(dp[ind][k]!=-1)\\n            return dp[ind][k];\\n        for(int i=ind+1; i<n; i++){\\n            if(events[i][0]>events[ind][1])\\n                break;\\n        }\\n        return dp[ind][k] = max(events[ind][2]+dfs(events, k-1, ind+1, dp), dfs(events, k, ind+1, dp));      \\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        int n = events.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        return dfs(events, k, 0, dp);\\n    }\\n};`"
                    },
                    {
                        "username": "ironblade",
                        "content": "again and again runtime \\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14"
                    },
                    {
                        "username": "atharva_777",
                        "content": "I think Leetcode\\'s problem setting team and problem description team has a serious issues \\uD83D\\uDE02"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "[[1,1,1],[2,2,2],[3,3,3],[4,4,4]] , k = 3\\n\\nin this testcase , my vscode is giving the correct answer  9  but leetcode is giving 7. how it is possible ?"
                    }
                ]
            },
            {
                "id": 1971124,
                "content": [
                    {
                        "username": "shresthamanxil",
                        "content": "what category does this question fall into?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I\\'d say DP, it\\'s most like a knap sack problem. You can see the tags at the bottom here"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Can anyone Help why this fails at second test case\n\n ```\nclass Solution {\npublic:\n    int fun(int i, vector<vector<int>>& eve, int k, int prevEnd, vector<vector<int>>& dp) {\n        if(i == eve.size())   return 0;\n        if(dp[i][k] != -1) return dp[i][k];\n        int take = 0;\n        if(k > 0 && prevEnd < eve[i][0]) {\n            take = eve[i][2] + fun(i + 1, eve, k - 1, eve[i][1], dp);\n        }\n        int notTake = fun(i + 1, eve, k, prevEnd, dp);\n        return dp[i][k] = max(take, notTake);\n    }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n = events.size();\n        sort(events.begin(), events.end());\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1));\n        return fun(0, events, k, -1, dp);\n    }\n};\n```"
                    },
                    {
                        "username": "vanshajduggal1234",
                        "content": "[@saudkhan07](/saudkhan07)  You also need to take prev element into account"
                    },
                    {
                        "username": "saudkhan07",
                        "content": "Did you figure it out. I am also stuck at the same place.\\n"
                    },
                    {
                        "username": "had0uken",
                        "content": "Yep, this is definitely the end of my strick ) "
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good one, similar to this one [projects]( https://cses.fi/problemset/task/1140)\nonly difference is limit of k events. and that makes this one even better "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I went with a 2D DP approach where the states are `[k , maxi]` where maxi is the last day value and got RTE :_(\\n\\nI\\'ve been encountering a lotta problems in the recent days where my solution\\'s logic is correct and has an acceptable T.C but fails in S.C !!"
                    },
                    {
                        "username": "amanmishra_20",
                        "content": "Here in this my code i just used map of pair of pairs for storing states.Rest is take or not take. 64/67 test cases passed succesfully. On test case 65 giving tle. Can someone tell me what to optimize a little bit more in this code??\\n\\nclass Solution {\\npublic:\\n    int fun(vector<int>& s,vector<int>& e,vector<int>& v,int i,int ans,int le,int k,map<pair<pair<int,int>,pair<int,int>>,int>& m){\\n         if(i==s.size())return ans;\\n         if(k==0)return ans;\\n         int take=-1,ntake=-1;\\n         if(s[i]>le){\\n             if(m.find({{i+1,ans+v[i]},{e[i],k-1}})!=m.end())\\n             take=m[{{i+1,ans+v[i]},{e[i],k-1}}];\\n             else take=fun(s,e,v,i+1,ans+v[i],e[i],k-1,m);\\n         }\\n         if(m.find({{i+1,ans},{le,k}})!=m.end())\\n             ntake=m[{{i+1,ans},{le,k}}];\\n             else ntake=fun(s,e,v,i+1,ans,le,k,m);\\n         return m[{{i,ans},{le,k}}]=max(take,ntake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        map<pair<pair<int,int>,pair<int,int>>,int>m;\\n        sort(events.begin(),events.end(),[&](vector<int>v1,vector<int>v2){\\n              if(v1[0]<v2[0])return true;\\n              else if(v1[0]==v2[0])return v1[1]<=v2[1];\\n              else return false;\\n        });\\n        vector<int>s,e,v;\\n        for(int i=0;i<events.size();i++){\\n            s.push_back(events[i][0]);\\n            e.push_back(events[i][1]);\\n            v.push_back(events[i][2]);\\n        }\\n        return fun(s,e,v,0,0,-1,k,m);\\n    }\\n};"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "Can anyone tell me what i am doing wrong\\n `class Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>> &events, int k, int ind, vector<vector<int>> &dp){\\n        int n = events.size();\\n        if(ind>=n || k<=0)\\n            return 0;\\n        if(dp[ind][k]!=-1)\\n            return dp[ind][k];\\n        for(int i=ind+1; i<n; i++){\\n            if(events[i][0]>events[ind][1])\\n                break;\\n        }\\n        return dp[ind][k] = max(events[ind][2]+dfs(events, k-1, ind+1, dp), dfs(events, k, ind+1, dp));      \\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        int n = events.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        return dfs(events, k, 0, dp);\\n    }\\n};`"
                    },
                    {
                        "username": "ironblade",
                        "content": "again and again runtime \\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14"
                    },
                    {
                        "username": "atharva_777",
                        "content": "I think Leetcode\\'s problem setting team and problem description team has a serious issues \\uD83D\\uDE02"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "[[1,1,1],[2,2,2],[3,3,3],[4,4,4]] , k = 3\\n\\nin this testcase , my vscode is giving the correct answer  9  but leetcode is giving 7. how it is possible ?"
                    }
                ]
            },
            {
                "id": 1971005,
                "content": [
                    {
                        "username": "shresthamanxil",
                        "content": "what category does this question fall into?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I\\'d say DP, it\\'s most like a knap sack problem. You can see the tags at the bottom here"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Can anyone Help why this fails at second test case\n\n ```\nclass Solution {\npublic:\n    int fun(int i, vector<vector<int>>& eve, int k, int prevEnd, vector<vector<int>>& dp) {\n        if(i == eve.size())   return 0;\n        if(dp[i][k] != -1) return dp[i][k];\n        int take = 0;\n        if(k > 0 && prevEnd < eve[i][0]) {\n            take = eve[i][2] + fun(i + 1, eve, k - 1, eve[i][1], dp);\n        }\n        int notTake = fun(i + 1, eve, k, prevEnd, dp);\n        return dp[i][k] = max(take, notTake);\n    }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n = events.size();\n        sort(events.begin(), events.end());\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1));\n        return fun(0, events, k, -1, dp);\n    }\n};\n```"
                    },
                    {
                        "username": "vanshajduggal1234",
                        "content": "[@saudkhan07](/saudkhan07)  You also need to take prev element into account"
                    },
                    {
                        "username": "saudkhan07",
                        "content": "Did you figure it out. I am also stuck at the same place.\\n"
                    },
                    {
                        "username": "had0uken",
                        "content": "Yep, this is definitely the end of my strick ) "
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good one, similar to this one [projects]( https://cses.fi/problemset/task/1140)\nonly difference is limit of k events. and that makes this one even better "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I went with a 2D DP approach where the states are `[k , maxi]` where maxi is the last day value and got RTE :_(\\n\\nI\\'ve been encountering a lotta problems in the recent days where my solution\\'s logic is correct and has an acceptable T.C but fails in S.C !!"
                    },
                    {
                        "username": "amanmishra_20",
                        "content": "Here in this my code i just used map of pair of pairs for storing states.Rest is take or not take. 64/67 test cases passed succesfully. On test case 65 giving tle. Can someone tell me what to optimize a little bit more in this code??\\n\\nclass Solution {\\npublic:\\n    int fun(vector<int>& s,vector<int>& e,vector<int>& v,int i,int ans,int le,int k,map<pair<pair<int,int>,pair<int,int>>,int>& m){\\n         if(i==s.size())return ans;\\n         if(k==0)return ans;\\n         int take=-1,ntake=-1;\\n         if(s[i]>le){\\n             if(m.find({{i+1,ans+v[i]},{e[i],k-1}})!=m.end())\\n             take=m[{{i+1,ans+v[i]},{e[i],k-1}}];\\n             else take=fun(s,e,v,i+1,ans+v[i],e[i],k-1,m);\\n         }\\n         if(m.find({{i+1,ans},{le,k}})!=m.end())\\n             ntake=m[{{i+1,ans},{le,k}}];\\n             else ntake=fun(s,e,v,i+1,ans,le,k,m);\\n         return m[{{i,ans},{le,k}}]=max(take,ntake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        map<pair<pair<int,int>,pair<int,int>>,int>m;\\n        sort(events.begin(),events.end(),[&](vector<int>v1,vector<int>v2){\\n              if(v1[0]<v2[0])return true;\\n              else if(v1[0]==v2[0])return v1[1]<=v2[1];\\n              else return false;\\n        });\\n        vector<int>s,e,v;\\n        for(int i=0;i<events.size();i++){\\n            s.push_back(events[i][0]);\\n            e.push_back(events[i][1]);\\n            v.push_back(events[i][2]);\\n        }\\n        return fun(s,e,v,0,0,-1,k,m);\\n    }\\n};"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "Can anyone tell me what i am doing wrong\\n `class Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>> &events, int k, int ind, vector<vector<int>> &dp){\\n        int n = events.size();\\n        if(ind>=n || k<=0)\\n            return 0;\\n        if(dp[ind][k]!=-1)\\n            return dp[ind][k];\\n        for(int i=ind+1; i<n; i++){\\n            if(events[i][0]>events[ind][1])\\n                break;\\n        }\\n        return dp[ind][k] = max(events[ind][2]+dfs(events, k-1, ind+1, dp), dfs(events, k, ind+1, dp));      \\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        int n = events.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        return dfs(events, k, 0, dp);\\n    }\\n};`"
                    },
                    {
                        "username": "ironblade",
                        "content": "again and again runtime \\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14"
                    },
                    {
                        "username": "atharva_777",
                        "content": "I think Leetcode\\'s problem setting team and problem description team has a serious issues \\uD83D\\uDE02"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "[[1,1,1],[2,2,2],[3,3,3],[4,4,4]] , k = 3\\n\\nin this testcase , my vscode is giving the correct answer  9  but leetcode is giving 7. how it is possible ?"
                    }
                ]
            },
            {
                "id": 1970951,
                "content": [
                    {
                        "username": "shresthamanxil",
                        "content": "what category does this question fall into?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I\\'d say DP, it\\'s most like a knap sack problem. You can see the tags at the bottom here"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Can anyone Help why this fails at second test case\n\n ```\nclass Solution {\npublic:\n    int fun(int i, vector<vector<int>>& eve, int k, int prevEnd, vector<vector<int>>& dp) {\n        if(i == eve.size())   return 0;\n        if(dp[i][k] != -1) return dp[i][k];\n        int take = 0;\n        if(k > 0 && prevEnd < eve[i][0]) {\n            take = eve[i][2] + fun(i + 1, eve, k - 1, eve[i][1], dp);\n        }\n        int notTake = fun(i + 1, eve, k, prevEnd, dp);\n        return dp[i][k] = max(take, notTake);\n    }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n = events.size();\n        sort(events.begin(), events.end());\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1));\n        return fun(0, events, k, -1, dp);\n    }\n};\n```"
                    },
                    {
                        "username": "vanshajduggal1234",
                        "content": "[@saudkhan07](/saudkhan07)  You also need to take prev element into account"
                    },
                    {
                        "username": "saudkhan07",
                        "content": "Did you figure it out. I am also stuck at the same place.\\n"
                    },
                    {
                        "username": "had0uken",
                        "content": "Yep, this is definitely the end of my strick ) "
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good one, similar to this one [projects]( https://cses.fi/problemset/task/1140)\nonly difference is limit of k events. and that makes this one even better "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I went with a 2D DP approach where the states are `[k , maxi]` where maxi is the last day value and got RTE :_(\\n\\nI\\'ve been encountering a lotta problems in the recent days where my solution\\'s logic is correct and has an acceptable T.C but fails in S.C !!"
                    },
                    {
                        "username": "amanmishra_20",
                        "content": "Here in this my code i just used map of pair of pairs for storing states.Rest is take or not take. 64/67 test cases passed succesfully. On test case 65 giving tle. Can someone tell me what to optimize a little bit more in this code??\\n\\nclass Solution {\\npublic:\\n    int fun(vector<int>& s,vector<int>& e,vector<int>& v,int i,int ans,int le,int k,map<pair<pair<int,int>,pair<int,int>>,int>& m){\\n         if(i==s.size())return ans;\\n         if(k==0)return ans;\\n         int take=-1,ntake=-1;\\n         if(s[i]>le){\\n             if(m.find({{i+1,ans+v[i]},{e[i],k-1}})!=m.end())\\n             take=m[{{i+1,ans+v[i]},{e[i],k-1}}];\\n             else take=fun(s,e,v,i+1,ans+v[i],e[i],k-1,m);\\n         }\\n         if(m.find({{i+1,ans},{le,k}})!=m.end())\\n             ntake=m[{{i+1,ans},{le,k}}];\\n             else ntake=fun(s,e,v,i+1,ans,le,k,m);\\n         return m[{{i,ans},{le,k}}]=max(take,ntake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        map<pair<pair<int,int>,pair<int,int>>,int>m;\\n        sort(events.begin(),events.end(),[&](vector<int>v1,vector<int>v2){\\n              if(v1[0]<v2[0])return true;\\n              else if(v1[0]==v2[0])return v1[1]<=v2[1];\\n              else return false;\\n        });\\n        vector<int>s,e,v;\\n        for(int i=0;i<events.size();i++){\\n            s.push_back(events[i][0]);\\n            e.push_back(events[i][1]);\\n            v.push_back(events[i][2]);\\n        }\\n        return fun(s,e,v,0,0,-1,k,m);\\n    }\\n};"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "Can anyone tell me what i am doing wrong\\n `class Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>> &events, int k, int ind, vector<vector<int>> &dp){\\n        int n = events.size();\\n        if(ind>=n || k<=0)\\n            return 0;\\n        if(dp[ind][k]!=-1)\\n            return dp[ind][k];\\n        for(int i=ind+1; i<n; i++){\\n            if(events[i][0]>events[ind][1])\\n                break;\\n        }\\n        return dp[ind][k] = max(events[ind][2]+dfs(events, k-1, ind+1, dp), dfs(events, k, ind+1, dp));      \\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        int n = events.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        return dfs(events, k, 0, dp);\\n    }\\n};`"
                    },
                    {
                        "username": "ironblade",
                        "content": "again and again runtime \\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14"
                    },
                    {
                        "username": "atharva_777",
                        "content": "I think Leetcode\\'s problem setting team and problem description team has a serious issues \\uD83D\\uDE02"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "[[1,1,1],[2,2,2],[3,3,3],[4,4,4]] , k = 3\\n\\nin this testcase , my vscode is giving the correct answer  9  but leetcode is giving 7. how it is possible ?"
                    }
                ]
            },
            {
                "id": 1970925,
                "content": [
                    {
                        "username": "shresthamanxil",
                        "content": "what category does this question fall into?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I\\'d say DP, it\\'s most like a knap sack problem. You can see the tags at the bottom here"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Can anyone Help why this fails at second test case\n\n ```\nclass Solution {\npublic:\n    int fun(int i, vector<vector<int>>& eve, int k, int prevEnd, vector<vector<int>>& dp) {\n        if(i == eve.size())   return 0;\n        if(dp[i][k] != -1) return dp[i][k];\n        int take = 0;\n        if(k > 0 && prevEnd < eve[i][0]) {\n            take = eve[i][2] + fun(i + 1, eve, k - 1, eve[i][1], dp);\n        }\n        int notTake = fun(i + 1, eve, k, prevEnd, dp);\n        return dp[i][k] = max(take, notTake);\n    }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n = events.size();\n        sort(events.begin(), events.end());\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1));\n        return fun(0, events, k, -1, dp);\n    }\n};\n```"
                    },
                    {
                        "username": "vanshajduggal1234",
                        "content": "[@saudkhan07](/saudkhan07)  You also need to take prev element into account"
                    },
                    {
                        "username": "saudkhan07",
                        "content": "Did you figure it out. I am also stuck at the same place.\\n"
                    },
                    {
                        "username": "had0uken",
                        "content": "Yep, this is definitely the end of my strick ) "
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good one, similar to this one [projects]( https://cses.fi/problemset/task/1140)\nonly difference is limit of k events. and that makes this one even better "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I went with a 2D DP approach where the states are `[k , maxi]` where maxi is the last day value and got RTE :_(\\n\\nI\\'ve been encountering a lotta problems in the recent days where my solution\\'s logic is correct and has an acceptable T.C but fails in S.C !!"
                    },
                    {
                        "username": "amanmishra_20",
                        "content": "Here in this my code i just used map of pair of pairs for storing states.Rest is take or not take. 64/67 test cases passed succesfully. On test case 65 giving tle. Can someone tell me what to optimize a little bit more in this code??\\n\\nclass Solution {\\npublic:\\n    int fun(vector<int>& s,vector<int>& e,vector<int>& v,int i,int ans,int le,int k,map<pair<pair<int,int>,pair<int,int>>,int>& m){\\n         if(i==s.size())return ans;\\n         if(k==0)return ans;\\n         int take=-1,ntake=-1;\\n         if(s[i]>le){\\n             if(m.find({{i+1,ans+v[i]},{e[i],k-1}})!=m.end())\\n             take=m[{{i+1,ans+v[i]},{e[i],k-1}}];\\n             else take=fun(s,e,v,i+1,ans+v[i],e[i],k-1,m);\\n         }\\n         if(m.find({{i+1,ans},{le,k}})!=m.end())\\n             ntake=m[{{i+1,ans},{le,k}}];\\n             else ntake=fun(s,e,v,i+1,ans,le,k,m);\\n         return m[{{i,ans},{le,k}}]=max(take,ntake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        map<pair<pair<int,int>,pair<int,int>>,int>m;\\n        sort(events.begin(),events.end(),[&](vector<int>v1,vector<int>v2){\\n              if(v1[0]<v2[0])return true;\\n              else if(v1[0]==v2[0])return v1[1]<=v2[1];\\n              else return false;\\n        });\\n        vector<int>s,e,v;\\n        for(int i=0;i<events.size();i++){\\n            s.push_back(events[i][0]);\\n            e.push_back(events[i][1]);\\n            v.push_back(events[i][2]);\\n        }\\n        return fun(s,e,v,0,0,-1,k,m);\\n    }\\n};"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "Can anyone tell me what i am doing wrong\\n `class Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>> &events, int k, int ind, vector<vector<int>> &dp){\\n        int n = events.size();\\n        if(ind>=n || k<=0)\\n            return 0;\\n        if(dp[ind][k]!=-1)\\n            return dp[ind][k];\\n        for(int i=ind+1; i<n; i++){\\n            if(events[i][0]>events[ind][1])\\n                break;\\n        }\\n        return dp[ind][k] = max(events[ind][2]+dfs(events, k-1, ind+1, dp), dfs(events, k, ind+1, dp));      \\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        int n = events.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        return dfs(events, k, 0, dp);\\n    }\\n};`"
                    },
                    {
                        "username": "ironblade",
                        "content": "again and again runtime \\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14"
                    },
                    {
                        "username": "atharva_777",
                        "content": "I think Leetcode\\'s problem setting team and problem description team has a serious issues \\uD83D\\uDE02"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "[[1,1,1],[2,2,2],[3,3,3],[4,4,4]] , k = 3\\n\\nin this testcase , my vscode is giving the correct answer  9  but leetcode is giving 7. how it is possible ?"
                    }
                ]
            },
            {
                "id": 1970916,
                "content": [
                    {
                        "username": "shresthamanxil",
                        "content": "what category does this question fall into?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I\\'d say DP, it\\'s most like a knap sack problem. You can see the tags at the bottom here"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Can anyone Help why this fails at second test case\n\n ```\nclass Solution {\npublic:\n    int fun(int i, vector<vector<int>>& eve, int k, int prevEnd, vector<vector<int>>& dp) {\n        if(i == eve.size())   return 0;\n        if(dp[i][k] != -1) return dp[i][k];\n        int take = 0;\n        if(k > 0 && prevEnd < eve[i][0]) {\n            take = eve[i][2] + fun(i + 1, eve, k - 1, eve[i][1], dp);\n        }\n        int notTake = fun(i + 1, eve, k, prevEnd, dp);\n        return dp[i][k] = max(take, notTake);\n    }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n = events.size();\n        sort(events.begin(), events.end());\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1));\n        return fun(0, events, k, -1, dp);\n    }\n};\n```"
                    },
                    {
                        "username": "vanshajduggal1234",
                        "content": "[@saudkhan07](/saudkhan07)  You also need to take prev element into account"
                    },
                    {
                        "username": "saudkhan07",
                        "content": "Did you figure it out. I am also stuck at the same place.\\n"
                    },
                    {
                        "username": "had0uken",
                        "content": "Yep, this is definitely the end of my strick ) "
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good one, similar to this one [projects]( https://cses.fi/problemset/task/1140)\nonly difference is limit of k events. and that makes this one even better "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I went with a 2D DP approach where the states are `[k , maxi]` where maxi is the last day value and got RTE :_(\\n\\nI\\'ve been encountering a lotta problems in the recent days where my solution\\'s logic is correct and has an acceptable T.C but fails in S.C !!"
                    },
                    {
                        "username": "amanmishra_20",
                        "content": "Here in this my code i just used map of pair of pairs for storing states.Rest is take or not take. 64/67 test cases passed succesfully. On test case 65 giving tle. Can someone tell me what to optimize a little bit more in this code??\\n\\nclass Solution {\\npublic:\\n    int fun(vector<int>& s,vector<int>& e,vector<int>& v,int i,int ans,int le,int k,map<pair<pair<int,int>,pair<int,int>>,int>& m){\\n         if(i==s.size())return ans;\\n         if(k==0)return ans;\\n         int take=-1,ntake=-1;\\n         if(s[i]>le){\\n             if(m.find({{i+1,ans+v[i]},{e[i],k-1}})!=m.end())\\n             take=m[{{i+1,ans+v[i]},{e[i],k-1}}];\\n             else take=fun(s,e,v,i+1,ans+v[i],e[i],k-1,m);\\n         }\\n         if(m.find({{i+1,ans},{le,k}})!=m.end())\\n             ntake=m[{{i+1,ans},{le,k}}];\\n             else ntake=fun(s,e,v,i+1,ans,le,k,m);\\n         return m[{{i,ans},{le,k}}]=max(take,ntake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        map<pair<pair<int,int>,pair<int,int>>,int>m;\\n        sort(events.begin(),events.end(),[&](vector<int>v1,vector<int>v2){\\n              if(v1[0]<v2[0])return true;\\n              else if(v1[0]==v2[0])return v1[1]<=v2[1];\\n              else return false;\\n        });\\n        vector<int>s,e,v;\\n        for(int i=0;i<events.size();i++){\\n            s.push_back(events[i][0]);\\n            e.push_back(events[i][1]);\\n            v.push_back(events[i][2]);\\n        }\\n        return fun(s,e,v,0,0,-1,k,m);\\n    }\\n};"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "Can anyone tell me what i am doing wrong\\n `class Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>> &events, int k, int ind, vector<vector<int>> &dp){\\n        int n = events.size();\\n        if(ind>=n || k<=0)\\n            return 0;\\n        if(dp[ind][k]!=-1)\\n            return dp[ind][k];\\n        for(int i=ind+1; i<n; i++){\\n            if(events[i][0]>events[ind][1])\\n                break;\\n        }\\n        return dp[ind][k] = max(events[ind][2]+dfs(events, k-1, ind+1, dp), dfs(events, k, ind+1, dp));      \\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        int n = events.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        return dfs(events, k, 0, dp);\\n    }\\n};`"
                    },
                    {
                        "username": "ironblade",
                        "content": "again and again runtime \\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14"
                    },
                    {
                        "username": "atharva_777",
                        "content": "I think Leetcode\\'s problem setting team and problem description team has a serious issues \\uD83D\\uDE02"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "[[1,1,1],[2,2,2],[3,3,3],[4,4,4]] , k = 3\\n\\nin this testcase , my vscode is giving the correct answer  9  but leetcode is giving 7. how it is possible ?"
                    }
                ]
            },
            {
                "id": 1970912,
                "content": [
                    {
                        "username": "shresthamanxil",
                        "content": "what category does this question fall into?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I\\'d say DP, it\\'s most like a knap sack problem. You can see the tags at the bottom here"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Can anyone Help why this fails at second test case\n\n ```\nclass Solution {\npublic:\n    int fun(int i, vector<vector<int>>& eve, int k, int prevEnd, vector<vector<int>>& dp) {\n        if(i == eve.size())   return 0;\n        if(dp[i][k] != -1) return dp[i][k];\n        int take = 0;\n        if(k > 0 && prevEnd < eve[i][0]) {\n            take = eve[i][2] + fun(i + 1, eve, k - 1, eve[i][1], dp);\n        }\n        int notTake = fun(i + 1, eve, k, prevEnd, dp);\n        return dp[i][k] = max(take, notTake);\n    }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n = events.size();\n        sort(events.begin(), events.end());\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1));\n        return fun(0, events, k, -1, dp);\n    }\n};\n```"
                    },
                    {
                        "username": "vanshajduggal1234",
                        "content": "[@saudkhan07](/saudkhan07)  You also need to take prev element into account"
                    },
                    {
                        "username": "saudkhan07",
                        "content": "Did you figure it out. I am also stuck at the same place.\\n"
                    },
                    {
                        "username": "had0uken",
                        "content": "Yep, this is definitely the end of my strick ) "
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good one, similar to this one [projects]( https://cses.fi/problemset/task/1140)\nonly difference is limit of k events. and that makes this one even better "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I went with a 2D DP approach where the states are `[k , maxi]` where maxi is the last day value and got RTE :_(\\n\\nI\\'ve been encountering a lotta problems in the recent days where my solution\\'s logic is correct and has an acceptable T.C but fails in S.C !!"
                    },
                    {
                        "username": "amanmishra_20",
                        "content": "Here in this my code i just used map of pair of pairs for storing states.Rest is take or not take. 64/67 test cases passed succesfully. On test case 65 giving tle. Can someone tell me what to optimize a little bit more in this code??\\n\\nclass Solution {\\npublic:\\n    int fun(vector<int>& s,vector<int>& e,vector<int>& v,int i,int ans,int le,int k,map<pair<pair<int,int>,pair<int,int>>,int>& m){\\n         if(i==s.size())return ans;\\n         if(k==0)return ans;\\n         int take=-1,ntake=-1;\\n         if(s[i]>le){\\n             if(m.find({{i+1,ans+v[i]},{e[i],k-1}})!=m.end())\\n             take=m[{{i+1,ans+v[i]},{e[i],k-1}}];\\n             else take=fun(s,e,v,i+1,ans+v[i],e[i],k-1,m);\\n         }\\n         if(m.find({{i+1,ans},{le,k}})!=m.end())\\n             ntake=m[{{i+1,ans},{le,k}}];\\n             else ntake=fun(s,e,v,i+1,ans,le,k,m);\\n         return m[{{i,ans},{le,k}}]=max(take,ntake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        map<pair<pair<int,int>,pair<int,int>>,int>m;\\n        sort(events.begin(),events.end(),[&](vector<int>v1,vector<int>v2){\\n              if(v1[0]<v2[0])return true;\\n              else if(v1[0]==v2[0])return v1[1]<=v2[1];\\n              else return false;\\n        });\\n        vector<int>s,e,v;\\n        for(int i=0;i<events.size();i++){\\n            s.push_back(events[i][0]);\\n            e.push_back(events[i][1]);\\n            v.push_back(events[i][2]);\\n        }\\n        return fun(s,e,v,0,0,-1,k,m);\\n    }\\n};"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "Can anyone tell me what i am doing wrong\\n `class Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>> &events, int k, int ind, vector<vector<int>> &dp){\\n        int n = events.size();\\n        if(ind>=n || k<=0)\\n            return 0;\\n        if(dp[ind][k]!=-1)\\n            return dp[ind][k];\\n        for(int i=ind+1; i<n; i++){\\n            if(events[i][0]>events[ind][1])\\n                break;\\n        }\\n        return dp[ind][k] = max(events[ind][2]+dfs(events, k-1, ind+1, dp), dfs(events, k, ind+1, dp));      \\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        int n = events.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        return dfs(events, k, 0, dp);\\n    }\\n};`"
                    },
                    {
                        "username": "ironblade",
                        "content": "again and again runtime \\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14"
                    },
                    {
                        "username": "atharva_777",
                        "content": "I think Leetcode\\'s problem setting team and problem description team has a serious issues \\uD83D\\uDE02"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "[[1,1,1],[2,2,2],[3,3,3],[4,4,4]] , k = 3\\n\\nin this testcase , my vscode is giving the correct answer  9  but leetcode is giving 7. how it is possible ?"
                    }
                ]
            },
            {
                "id": 1970865,
                "content": [
                    {
                        "username": "shresthamanxil",
                        "content": "what category does this question fall into?"
                    },
                    {
                        "username": "Mister_CK",
                        "content": "I\\'d say DP, it\\'s most like a knap sack problem. You can see the tags at the bottom here"
                    },
                    {
                        "username": "harsh_negi_07",
                        "content": "Can anyone Help why this fails at second test case\n\n ```\nclass Solution {\npublic:\n    int fun(int i, vector<vector<int>>& eve, int k, int prevEnd, vector<vector<int>>& dp) {\n        if(i == eve.size())   return 0;\n        if(dp[i][k] != -1) return dp[i][k];\n        int take = 0;\n        if(k > 0 && prevEnd < eve[i][0]) {\n            take = eve[i][2] + fun(i + 1, eve, k - 1, eve[i][1], dp);\n        }\n        int notTake = fun(i + 1, eve, k, prevEnd, dp);\n        return dp[i][k] = max(take, notTake);\n    }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n = events.size();\n        sort(events.begin(), events.end());\n        vector<vector<int>> dp(n + 1, vector<int>(k + 1, -1));\n        return fun(0, events, k, -1, dp);\n    }\n};\n```"
                    },
                    {
                        "username": "vanshajduggal1234",
                        "content": "[@saudkhan07](/saudkhan07)  You also need to take prev element into account"
                    },
                    {
                        "username": "saudkhan07",
                        "content": "Did you figure it out. I am also stuck at the same place.\\n"
                    },
                    {
                        "username": "had0uken",
                        "content": "Yep, this is definitely the end of my strick ) "
                    },
                    {
                        "username": "LikeTheSun",
                        "content": "this is good one, similar to this one [projects]( https://cses.fi/problemset/task/1140)\nonly difference is limit of k events. and that makes this one even better "
                    },
                    {
                        "username": "suren-yeager",
                        "content": "I went with a 2D DP approach where the states are `[k , maxi]` where maxi is the last day value and got RTE :_(\\n\\nI\\'ve been encountering a lotta problems in the recent days where my solution\\'s logic is correct and has an acceptable T.C but fails in S.C !!"
                    },
                    {
                        "username": "amanmishra_20",
                        "content": "Here in this my code i just used map of pair of pairs for storing states.Rest is take or not take. 64/67 test cases passed succesfully. On test case 65 giving tle. Can someone tell me what to optimize a little bit more in this code??\\n\\nclass Solution {\\npublic:\\n    int fun(vector<int>& s,vector<int>& e,vector<int>& v,int i,int ans,int le,int k,map<pair<pair<int,int>,pair<int,int>>,int>& m){\\n         if(i==s.size())return ans;\\n         if(k==0)return ans;\\n         int take=-1,ntake=-1;\\n         if(s[i]>le){\\n             if(m.find({{i+1,ans+v[i]},{e[i],k-1}})!=m.end())\\n             take=m[{{i+1,ans+v[i]},{e[i],k-1}}];\\n             else take=fun(s,e,v,i+1,ans+v[i],e[i],k-1,m);\\n         }\\n         if(m.find({{i+1,ans},{le,k}})!=m.end())\\n             ntake=m[{{i+1,ans},{le,k}}];\\n             else ntake=fun(s,e,v,i+1,ans,le,k,m);\\n         return m[{{i,ans},{le,k}}]=max(take,ntake);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        map<pair<pair<int,int>,pair<int,int>>,int>m;\\n        sort(events.begin(),events.end(),[&](vector<int>v1,vector<int>v2){\\n              if(v1[0]<v2[0])return true;\\n              else if(v1[0]==v2[0])return v1[1]<=v2[1];\\n              else return false;\\n        });\\n        vector<int>s,e,v;\\n        for(int i=0;i<events.size();i++){\\n            s.push_back(events[i][0]);\\n            e.push_back(events[i][1]);\\n            v.push_back(events[i][2]);\\n        }\\n        return fun(s,e,v,0,0,-1,k,m);\\n    }\\n};"
                    },
                    {
                        "username": "Krish-Gupta",
                        "content": "Can anyone tell me what i am doing wrong\\n `class Solution {\\npublic:\\n\\n    int dfs(vector<vector<int>> &events, int k, int ind, vector<vector<int>> &dp){\\n        int n = events.size();\\n        if(ind>=n || k<=0)\\n            return 0;\\n        if(dp[ind][k]!=-1)\\n            return dp[ind][k];\\n        for(int i=ind+1; i<n; i++){\\n            if(events[i][0]>events[ind][1])\\n                break;\\n        }\\n        return dp[ind][k] = max(events[ind][2]+dfs(events, k-1, ind+1, dp), dfs(events, k, ind+1, dp));      \\n    }\\n\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        int n = events.size();\\n        vector<vector<int>> dp(n+1, vector<int>(k+1, -1));\\n        return dfs(events, k, 0, dp);\\n    }\\n};`"
                    },
                    {
                        "username": "ironblade",
                        "content": "again and again runtime \\uD83D\\uDE14\\uD83D\\uDE14\\uD83D\\uDE14"
                    },
                    {
                        "username": "atharva_777",
                        "content": "I think Leetcode\\'s problem setting team and problem description team has a serious issues \\uD83D\\uDE02"
                    },
                    {
                        "username": "rohit_neemwal",
                        "content": "[[1,1,1],[2,2,2],[3,3,3],[4,4,4]] , k = 3\\n\\nin this testcase , my vscode is giving the correct answer  9  but leetcode is giving 7. how it is possible ?"
                    }
                ]
            },
            {
                "id": 1970812,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I think leetcode prepare us for placement"
                    },
                    {
                        "username": "Popat_lal",
                        "content": "This recursive is running test cases but the memoization is not running properly where i am going wrong ? Please tell TIA\\n\\n```\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k ){\\n    if(i==events.size()|| k==0) return 0;\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k);\\n    return max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k);\\n    }\\n}; \\n\\n-------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\\n    if(i==events.size()|| k==0) return 0;\\n    if(dp[i][k]!=-1) return dp[i][k];\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k,dp);\\n    return dp[i][k]=max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bruh_",
                        "content": "My code looks very similar to yours (esp the memoisation part) \nI had the same doubt- why is memoisation giving wrong ans?\n\nHere's my understanding- \n--> We need to return dp[i][k] only when events[i][0]>prev_end (only in this kind of approach.. not in binary search kond of approach)\n      you'll be able to understand why we need to do like this only if you dry run on this testcase\n     [[1,2,4],[2,3,10],[3,4,3]] , k=2; \nPlease do explain me if you understand the reason better!!! \n\nYour code worked after reordering in the following way- \n```\nclass Solution {\npublic:\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\n    if(i==events.size()|| k==0) return 0;\n    int take=0;\n    if(events[i][0]<=prev){\n        return solve(i+1,events,prev,k,dp); //the code fails if we try memoising here .. couldnot figure out this reason \n    } \n    if(dp[i][k]!=-1) return dp[i][k];\n\n    take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\n    int nottake=solve(i+1,events,prev,k,dp);\n    return dp[i][k]=max(take,nottake);\n}\n    int maxValue(vector<vector<int>>& events, int k) {\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\n        sort(events.begin(), events.end());\n        return solve(0,events,0,k,dp);\n    }\n};\n```\n\n"
                    },
                    {
                        "username": "Saphal",
                        "content": "Any way 3D dp will give TLE"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "there are 3 changing parameters i.e i,prev,k and you are using 2D dp thats why the error\\n"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "why are people complaining its just straight out Knapsack problem..replace the sack weight with number of events and find max"
                    },
                    {
                        "username": "amitpanwar02705",
                        "content": "can anyone tell me why my solution is giving wrong answer for this case [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]], k = 3 ,\\n`class Solution {\\npublic:\\n    int helper(int ind, vector<vector<int>> &arr, int k){\\n        // base case\\n        if(k == 0 || ind == arr.size()) return 0;\\n\\n        // recusive conditions\\n        int cur_val = arr[ind][2];\\n        for(int i = ind+1; i < arr.size(); i++){\\n            if(arr[i][0] > arr[ind][1])\\n            cur_val = max(cur_val,arr[ind][2] + helper(i,arr,k-1));\\n        }\\n        return cur_val;\\n    }\\n    int maxValue(vector<vector<int>>& arr, int k) {\\n        sort(arr.begin(),arr.end(), [](auto &a, auto &b){\\n            return a[0] < b[0];\\n        });\\n        int n = arr.size();\\n        vector<int> start_time(n,0);\\n        for(int i = 0 ; i < n ;i++){\\n            start_time[i] = arr[i][0];\\n        }\\n        int ans = 0 ;\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        for(int i = n-1; i >= 0 ; i--){\\n            for(int j = 1 ; j <= k ;j ++){\\n                auto check = upper_bound(start_time.begin(),start_time.end(),arr[i][1]);\\n                if(check != start_time.end()){\\n                    dp[i][j] = arr[i][2] + dp[check-start_time.begin()][j-1];\\n                }\\n                else dp[i][j] = arr[i][2];\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Who else thinks Expected Time and Space complexity must be mentioned?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "guys if you are struck look at hints :)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.\"\n\nDont you think this line is contradicting in Example 1,, Figure shown is wrong"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@om_golhani](/om_golhani) Event 0 ends on day 2 and Event 2 starts on the same day."
                    },
                    {
                        "username": "om_golhani",
                        "content": "I think It is correct, The possible sequences of events are as follows : \\n1. Event0 -> Event1 : Event0 starts at day1 and ends at day2 as well as Event1 starts at day3 and ends at day4.\\n2. Event2 : Event2 starts at day2 and ends at day3.\\n\\nThere is no such situation in which we are taking  events where one of them starts and the other ends on the same day."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "easy gg"
                    },
                    {
                        "username": "moiezgul",
                        "content": "my brain is lagging over here...."
                    },
                    {
                        "username": "santanusen",
                        "content": "Strangely, my iterative solution is 10 times slower than the recursive solution. Not sure why. Can someone please help me understand what is lacking in the iterative solution -\\n\\nhttps://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/submissions/994852068/\\n"
                    }
                ]
            },
            {
                "id": 1970786,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I think leetcode prepare us for placement"
                    },
                    {
                        "username": "Popat_lal",
                        "content": "This recursive is running test cases but the memoization is not running properly where i am going wrong ? Please tell TIA\\n\\n```\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k ){\\n    if(i==events.size()|| k==0) return 0;\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k);\\n    return max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k);\\n    }\\n}; \\n\\n-------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\\n    if(i==events.size()|| k==0) return 0;\\n    if(dp[i][k]!=-1) return dp[i][k];\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k,dp);\\n    return dp[i][k]=max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bruh_",
                        "content": "My code looks very similar to yours (esp the memoisation part) \nI had the same doubt- why is memoisation giving wrong ans?\n\nHere's my understanding- \n--> We need to return dp[i][k] only when events[i][0]>prev_end (only in this kind of approach.. not in binary search kond of approach)\n      you'll be able to understand why we need to do like this only if you dry run on this testcase\n     [[1,2,4],[2,3,10],[3,4,3]] , k=2; \nPlease do explain me if you understand the reason better!!! \n\nYour code worked after reordering in the following way- \n```\nclass Solution {\npublic:\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\n    if(i==events.size()|| k==0) return 0;\n    int take=0;\n    if(events[i][0]<=prev){\n        return solve(i+1,events,prev,k,dp); //the code fails if we try memoising here .. couldnot figure out this reason \n    } \n    if(dp[i][k]!=-1) return dp[i][k];\n\n    take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\n    int nottake=solve(i+1,events,prev,k,dp);\n    return dp[i][k]=max(take,nottake);\n}\n    int maxValue(vector<vector<int>>& events, int k) {\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\n        sort(events.begin(), events.end());\n        return solve(0,events,0,k,dp);\n    }\n};\n```\n\n"
                    },
                    {
                        "username": "Saphal",
                        "content": "Any way 3D dp will give TLE"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "there are 3 changing parameters i.e i,prev,k and you are using 2D dp thats why the error\\n"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "why are people complaining its just straight out Knapsack problem..replace the sack weight with number of events and find max"
                    },
                    {
                        "username": "amitpanwar02705",
                        "content": "can anyone tell me why my solution is giving wrong answer for this case [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]], k = 3 ,\\n`class Solution {\\npublic:\\n    int helper(int ind, vector<vector<int>> &arr, int k){\\n        // base case\\n        if(k == 0 || ind == arr.size()) return 0;\\n\\n        // recusive conditions\\n        int cur_val = arr[ind][2];\\n        for(int i = ind+1; i < arr.size(); i++){\\n            if(arr[i][0] > arr[ind][1])\\n            cur_val = max(cur_val,arr[ind][2] + helper(i,arr,k-1));\\n        }\\n        return cur_val;\\n    }\\n    int maxValue(vector<vector<int>>& arr, int k) {\\n        sort(arr.begin(),arr.end(), [](auto &a, auto &b){\\n            return a[0] < b[0];\\n        });\\n        int n = arr.size();\\n        vector<int> start_time(n,0);\\n        for(int i = 0 ; i < n ;i++){\\n            start_time[i] = arr[i][0];\\n        }\\n        int ans = 0 ;\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        for(int i = n-1; i >= 0 ; i--){\\n            for(int j = 1 ; j <= k ;j ++){\\n                auto check = upper_bound(start_time.begin(),start_time.end(),arr[i][1]);\\n                if(check != start_time.end()){\\n                    dp[i][j] = arr[i][2] + dp[check-start_time.begin()][j-1];\\n                }\\n                else dp[i][j] = arr[i][2];\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Who else thinks Expected Time and Space complexity must be mentioned?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "guys if you are struck look at hints :)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.\"\n\nDont you think this line is contradicting in Example 1,, Figure shown is wrong"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@om_golhani](/om_golhani) Event 0 ends on day 2 and Event 2 starts on the same day."
                    },
                    {
                        "username": "om_golhani",
                        "content": "I think It is correct, The possible sequences of events are as follows : \\n1. Event0 -> Event1 : Event0 starts at day1 and ends at day2 as well as Event1 starts at day3 and ends at day4.\\n2. Event2 : Event2 starts at day2 and ends at day3.\\n\\nThere is no such situation in which we are taking  events where one of them starts and the other ends on the same day."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "easy gg"
                    },
                    {
                        "username": "moiezgul",
                        "content": "my brain is lagging over here...."
                    },
                    {
                        "username": "santanusen",
                        "content": "Strangely, my iterative solution is 10 times slower than the recursive solution. Not sure why. Can someone please help me understand what is lacking in the iterative solution -\\n\\nhttps://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/submissions/994852068/\\n"
                    }
                ]
            },
            {
                "id": 1970761,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I think leetcode prepare us for placement"
                    },
                    {
                        "username": "Popat_lal",
                        "content": "This recursive is running test cases but the memoization is not running properly where i am going wrong ? Please tell TIA\\n\\n```\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k ){\\n    if(i==events.size()|| k==0) return 0;\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k);\\n    return max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k);\\n    }\\n}; \\n\\n-------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\\n    if(i==events.size()|| k==0) return 0;\\n    if(dp[i][k]!=-1) return dp[i][k];\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k,dp);\\n    return dp[i][k]=max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bruh_",
                        "content": "My code looks very similar to yours (esp the memoisation part) \nI had the same doubt- why is memoisation giving wrong ans?\n\nHere's my understanding- \n--> We need to return dp[i][k] only when events[i][0]>prev_end (only in this kind of approach.. not in binary search kond of approach)\n      you'll be able to understand why we need to do like this only if you dry run on this testcase\n     [[1,2,4],[2,3,10],[3,4,3]] , k=2; \nPlease do explain me if you understand the reason better!!! \n\nYour code worked after reordering in the following way- \n```\nclass Solution {\npublic:\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\n    if(i==events.size()|| k==0) return 0;\n    int take=0;\n    if(events[i][0]<=prev){\n        return solve(i+1,events,prev,k,dp); //the code fails if we try memoising here .. couldnot figure out this reason \n    } \n    if(dp[i][k]!=-1) return dp[i][k];\n\n    take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\n    int nottake=solve(i+1,events,prev,k,dp);\n    return dp[i][k]=max(take,nottake);\n}\n    int maxValue(vector<vector<int>>& events, int k) {\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\n        sort(events.begin(), events.end());\n        return solve(0,events,0,k,dp);\n    }\n};\n```\n\n"
                    },
                    {
                        "username": "Saphal",
                        "content": "Any way 3D dp will give TLE"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "there are 3 changing parameters i.e i,prev,k and you are using 2D dp thats why the error\\n"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "why are people complaining its just straight out Knapsack problem..replace the sack weight with number of events and find max"
                    },
                    {
                        "username": "amitpanwar02705",
                        "content": "can anyone tell me why my solution is giving wrong answer for this case [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]], k = 3 ,\\n`class Solution {\\npublic:\\n    int helper(int ind, vector<vector<int>> &arr, int k){\\n        // base case\\n        if(k == 0 || ind == arr.size()) return 0;\\n\\n        // recusive conditions\\n        int cur_val = arr[ind][2];\\n        for(int i = ind+1; i < arr.size(); i++){\\n            if(arr[i][0] > arr[ind][1])\\n            cur_val = max(cur_val,arr[ind][2] + helper(i,arr,k-1));\\n        }\\n        return cur_val;\\n    }\\n    int maxValue(vector<vector<int>>& arr, int k) {\\n        sort(arr.begin(),arr.end(), [](auto &a, auto &b){\\n            return a[0] < b[0];\\n        });\\n        int n = arr.size();\\n        vector<int> start_time(n,0);\\n        for(int i = 0 ; i < n ;i++){\\n            start_time[i] = arr[i][0];\\n        }\\n        int ans = 0 ;\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        for(int i = n-1; i >= 0 ; i--){\\n            for(int j = 1 ; j <= k ;j ++){\\n                auto check = upper_bound(start_time.begin(),start_time.end(),arr[i][1]);\\n                if(check != start_time.end()){\\n                    dp[i][j] = arr[i][2] + dp[check-start_time.begin()][j-1];\\n                }\\n                else dp[i][j] = arr[i][2];\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Who else thinks Expected Time and Space complexity must be mentioned?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "guys if you are struck look at hints :)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.\"\n\nDont you think this line is contradicting in Example 1,, Figure shown is wrong"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@om_golhani](/om_golhani) Event 0 ends on day 2 and Event 2 starts on the same day."
                    },
                    {
                        "username": "om_golhani",
                        "content": "I think It is correct, The possible sequences of events are as follows : \\n1. Event0 -> Event1 : Event0 starts at day1 and ends at day2 as well as Event1 starts at day3 and ends at day4.\\n2. Event2 : Event2 starts at day2 and ends at day3.\\n\\nThere is no such situation in which we are taking  events where one of them starts and the other ends on the same day."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "easy gg"
                    },
                    {
                        "username": "moiezgul",
                        "content": "my brain is lagging over here...."
                    },
                    {
                        "username": "santanusen",
                        "content": "Strangely, my iterative solution is 10 times slower than the recursive solution. Not sure why. Can someone please help me understand what is lacking in the iterative solution -\\n\\nhttps://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/submissions/994852068/\\n"
                    }
                ]
            },
            {
                "id": 1970753,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I think leetcode prepare us for placement"
                    },
                    {
                        "username": "Popat_lal",
                        "content": "This recursive is running test cases but the memoization is not running properly where i am going wrong ? Please tell TIA\\n\\n```\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k ){\\n    if(i==events.size()|| k==0) return 0;\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k);\\n    return max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k);\\n    }\\n}; \\n\\n-------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\\n    if(i==events.size()|| k==0) return 0;\\n    if(dp[i][k]!=-1) return dp[i][k];\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k,dp);\\n    return dp[i][k]=max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bruh_",
                        "content": "My code looks very similar to yours (esp the memoisation part) \nI had the same doubt- why is memoisation giving wrong ans?\n\nHere's my understanding- \n--> We need to return dp[i][k] only when events[i][0]>prev_end (only in this kind of approach.. not in binary search kond of approach)\n      you'll be able to understand why we need to do like this only if you dry run on this testcase\n     [[1,2,4],[2,3,10],[3,4,3]] , k=2; \nPlease do explain me if you understand the reason better!!! \n\nYour code worked after reordering in the following way- \n```\nclass Solution {\npublic:\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\n    if(i==events.size()|| k==0) return 0;\n    int take=0;\n    if(events[i][0]<=prev){\n        return solve(i+1,events,prev,k,dp); //the code fails if we try memoising here .. couldnot figure out this reason \n    } \n    if(dp[i][k]!=-1) return dp[i][k];\n\n    take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\n    int nottake=solve(i+1,events,prev,k,dp);\n    return dp[i][k]=max(take,nottake);\n}\n    int maxValue(vector<vector<int>>& events, int k) {\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\n        sort(events.begin(), events.end());\n        return solve(0,events,0,k,dp);\n    }\n};\n```\n\n"
                    },
                    {
                        "username": "Saphal",
                        "content": "Any way 3D dp will give TLE"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "there are 3 changing parameters i.e i,prev,k and you are using 2D dp thats why the error\\n"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "why are people complaining its just straight out Knapsack problem..replace the sack weight with number of events and find max"
                    },
                    {
                        "username": "amitpanwar02705",
                        "content": "can anyone tell me why my solution is giving wrong answer for this case [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]], k = 3 ,\\n`class Solution {\\npublic:\\n    int helper(int ind, vector<vector<int>> &arr, int k){\\n        // base case\\n        if(k == 0 || ind == arr.size()) return 0;\\n\\n        // recusive conditions\\n        int cur_val = arr[ind][2];\\n        for(int i = ind+1; i < arr.size(); i++){\\n            if(arr[i][0] > arr[ind][1])\\n            cur_val = max(cur_val,arr[ind][2] + helper(i,arr,k-1));\\n        }\\n        return cur_val;\\n    }\\n    int maxValue(vector<vector<int>>& arr, int k) {\\n        sort(arr.begin(),arr.end(), [](auto &a, auto &b){\\n            return a[0] < b[0];\\n        });\\n        int n = arr.size();\\n        vector<int> start_time(n,0);\\n        for(int i = 0 ; i < n ;i++){\\n            start_time[i] = arr[i][0];\\n        }\\n        int ans = 0 ;\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        for(int i = n-1; i >= 0 ; i--){\\n            for(int j = 1 ; j <= k ;j ++){\\n                auto check = upper_bound(start_time.begin(),start_time.end(),arr[i][1]);\\n                if(check != start_time.end()){\\n                    dp[i][j] = arr[i][2] + dp[check-start_time.begin()][j-1];\\n                }\\n                else dp[i][j] = arr[i][2];\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Who else thinks Expected Time and Space complexity must be mentioned?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "guys if you are struck look at hints :)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.\"\n\nDont you think this line is contradicting in Example 1,, Figure shown is wrong"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@om_golhani](/om_golhani) Event 0 ends on day 2 and Event 2 starts on the same day."
                    },
                    {
                        "username": "om_golhani",
                        "content": "I think It is correct, The possible sequences of events are as follows : \\n1. Event0 -> Event1 : Event0 starts at day1 and ends at day2 as well as Event1 starts at day3 and ends at day4.\\n2. Event2 : Event2 starts at day2 and ends at day3.\\n\\nThere is no such situation in which we are taking  events where one of them starts and the other ends on the same day."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "easy gg"
                    },
                    {
                        "username": "moiezgul",
                        "content": "my brain is lagging over here...."
                    },
                    {
                        "username": "santanusen",
                        "content": "Strangely, my iterative solution is 10 times slower than the recursive solution. Not sure why. Can someone please help me understand what is lacking in the iterative solution -\\n\\nhttps://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/submissions/994852068/\\n"
                    }
                ]
            },
            {
                "id": 1970741,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I think leetcode prepare us for placement"
                    },
                    {
                        "username": "Popat_lal",
                        "content": "This recursive is running test cases but the memoization is not running properly where i am going wrong ? Please tell TIA\\n\\n```\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k ){\\n    if(i==events.size()|| k==0) return 0;\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k);\\n    return max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k);\\n    }\\n}; \\n\\n-------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\\n    if(i==events.size()|| k==0) return 0;\\n    if(dp[i][k]!=-1) return dp[i][k];\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k,dp);\\n    return dp[i][k]=max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bruh_",
                        "content": "My code looks very similar to yours (esp the memoisation part) \nI had the same doubt- why is memoisation giving wrong ans?\n\nHere's my understanding- \n--> We need to return dp[i][k] only when events[i][0]>prev_end (only in this kind of approach.. not in binary search kond of approach)\n      you'll be able to understand why we need to do like this only if you dry run on this testcase\n     [[1,2,4],[2,3,10],[3,4,3]] , k=2; \nPlease do explain me if you understand the reason better!!! \n\nYour code worked after reordering in the following way- \n```\nclass Solution {\npublic:\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\n    if(i==events.size()|| k==0) return 0;\n    int take=0;\n    if(events[i][0]<=prev){\n        return solve(i+1,events,prev,k,dp); //the code fails if we try memoising here .. couldnot figure out this reason \n    } \n    if(dp[i][k]!=-1) return dp[i][k];\n\n    take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\n    int nottake=solve(i+1,events,prev,k,dp);\n    return dp[i][k]=max(take,nottake);\n}\n    int maxValue(vector<vector<int>>& events, int k) {\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\n        sort(events.begin(), events.end());\n        return solve(0,events,0,k,dp);\n    }\n};\n```\n\n"
                    },
                    {
                        "username": "Saphal",
                        "content": "Any way 3D dp will give TLE"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "there are 3 changing parameters i.e i,prev,k and you are using 2D dp thats why the error\\n"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "why are people complaining its just straight out Knapsack problem..replace the sack weight with number of events and find max"
                    },
                    {
                        "username": "amitpanwar02705",
                        "content": "can anyone tell me why my solution is giving wrong answer for this case [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]], k = 3 ,\\n`class Solution {\\npublic:\\n    int helper(int ind, vector<vector<int>> &arr, int k){\\n        // base case\\n        if(k == 0 || ind == arr.size()) return 0;\\n\\n        // recusive conditions\\n        int cur_val = arr[ind][2];\\n        for(int i = ind+1; i < arr.size(); i++){\\n            if(arr[i][0] > arr[ind][1])\\n            cur_val = max(cur_val,arr[ind][2] + helper(i,arr,k-1));\\n        }\\n        return cur_val;\\n    }\\n    int maxValue(vector<vector<int>>& arr, int k) {\\n        sort(arr.begin(),arr.end(), [](auto &a, auto &b){\\n            return a[0] < b[0];\\n        });\\n        int n = arr.size();\\n        vector<int> start_time(n,0);\\n        for(int i = 0 ; i < n ;i++){\\n            start_time[i] = arr[i][0];\\n        }\\n        int ans = 0 ;\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        for(int i = n-1; i >= 0 ; i--){\\n            for(int j = 1 ; j <= k ;j ++){\\n                auto check = upper_bound(start_time.begin(),start_time.end(),arr[i][1]);\\n                if(check != start_time.end()){\\n                    dp[i][j] = arr[i][2] + dp[check-start_time.begin()][j-1];\\n                }\\n                else dp[i][j] = arr[i][2];\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Who else thinks Expected Time and Space complexity must be mentioned?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "guys if you are struck look at hints :)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.\"\n\nDont you think this line is contradicting in Example 1,, Figure shown is wrong"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@om_golhani](/om_golhani) Event 0 ends on day 2 and Event 2 starts on the same day."
                    },
                    {
                        "username": "om_golhani",
                        "content": "I think It is correct, The possible sequences of events are as follows : \\n1. Event0 -> Event1 : Event0 starts at day1 and ends at day2 as well as Event1 starts at day3 and ends at day4.\\n2. Event2 : Event2 starts at day2 and ends at day3.\\n\\nThere is no such situation in which we are taking  events where one of them starts and the other ends on the same day."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "easy gg"
                    },
                    {
                        "username": "moiezgul",
                        "content": "my brain is lagging over here...."
                    },
                    {
                        "username": "santanusen",
                        "content": "Strangely, my iterative solution is 10 times slower than the recursive solution. Not sure why. Can someone please help me understand what is lacking in the iterative solution -\\n\\nhttps://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/submissions/994852068/\\n"
                    }
                ]
            },
            {
                "id": 1970722,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I think leetcode prepare us for placement"
                    },
                    {
                        "username": "Popat_lal",
                        "content": "This recursive is running test cases but the memoization is not running properly where i am going wrong ? Please tell TIA\\n\\n```\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k ){\\n    if(i==events.size()|| k==0) return 0;\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k);\\n    return max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k);\\n    }\\n}; \\n\\n-------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\\n    if(i==events.size()|| k==0) return 0;\\n    if(dp[i][k]!=-1) return dp[i][k];\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k,dp);\\n    return dp[i][k]=max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bruh_",
                        "content": "My code looks very similar to yours (esp the memoisation part) \nI had the same doubt- why is memoisation giving wrong ans?\n\nHere's my understanding- \n--> We need to return dp[i][k] only when events[i][0]>prev_end (only in this kind of approach.. not in binary search kond of approach)\n      you'll be able to understand why we need to do like this only if you dry run on this testcase\n     [[1,2,4],[2,3,10],[3,4,3]] , k=2; \nPlease do explain me if you understand the reason better!!! \n\nYour code worked after reordering in the following way- \n```\nclass Solution {\npublic:\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\n    if(i==events.size()|| k==0) return 0;\n    int take=0;\n    if(events[i][0]<=prev){\n        return solve(i+1,events,prev,k,dp); //the code fails if we try memoising here .. couldnot figure out this reason \n    } \n    if(dp[i][k]!=-1) return dp[i][k];\n\n    take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\n    int nottake=solve(i+1,events,prev,k,dp);\n    return dp[i][k]=max(take,nottake);\n}\n    int maxValue(vector<vector<int>>& events, int k) {\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\n        sort(events.begin(), events.end());\n        return solve(0,events,0,k,dp);\n    }\n};\n```\n\n"
                    },
                    {
                        "username": "Saphal",
                        "content": "Any way 3D dp will give TLE"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "there are 3 changing parameters i.e i,prev,k and you are using 2D dp thats why the error\\n"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "why are people complaining its just straight out Knapsack problem..replace the sack weight with number of events and find max"
                    },
                    {
                        "username": "amitpanwar02705",
                        "content": "can anyone tell me why my solution is giving wrong answer for this case [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]], k = 3 ,\\n`class Solution {\\npublic:\\n    int helper(int ind, vector<vector<int>> &arr, int k){\\n        // base case\\n        if(k == 0 || ind == arr.size()) return 0;\\n\\n        // recusive conditions\\n        int cur_val = arr[ind][2];\\n        for(int i = ind+1; i < arr.size(); i++){\\n            if(arr[i][0] > arr[ind][1])\\n            cur_val = max(cur_val,arr[ind][2] + helper(i,arr,k-1));\\n        }\\n        return cur_val;\\n    }\\n    int maxValue(vector<vector<int>>& arr, int k) {\\n        sort(arr.begin(),arr.end(), [](auto &a, auto &b){\\n            return a[0] < b[0];\\n        });\\n        int n = arr.size();\\n        vector<int> start_time(n,0);\\n        for(int i = 0 ; i < n ;i++){\\n            start_time[i] = arr[i][0];\\n        }\\n        int ans = 0 ;\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        for(int i = n-1; i >= 0 ; i--){\\n            for(int j = 1 ; j <= k ;j ++){\\n                auto check = upper_bound(start_time.begin(),start_time.end(),arr[i][1]);\\n                if(check != start_time.end()){\\n                    dp[i][j] = arr[i][2] + dp[check-start_time.begin()][j-1];\\n                }\\n                else dp[i][j] = arr[i][2];\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Who else thinks Expected Time and Space complexity must be mentioned?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "guys if you are struck look at hints :)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.\"\n\nDont you think this line is contradicting in Example 1,, Figure shown is wrong"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@om_golhani](/om_golhani) Event 0 ends on day 2 and Event 2 starts on the same day."
                    },
                    {
                        "username": "om_golhani",
                        "content": "I think It is correct, The possible sequences of events are as follows : \\n1. Event0 -> Event1 : Event0 starts at day1 and ends at day2 as well as Event1 starts at day3 and ends at day4.\\n2. Event2 : Event2 starts at day2 and ends at day3.\\n\\nThere is no such situation in which we are taking  events where one of them starts and the other ends on the same day."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "easy gg"
                    },
                    {
                        "username": "moiezgul",
                        "content": "my brain is lagging over here...."
                    },
                    {
                        "username": "santanusen",
                        "content": "Strangely, my iterative solution is 10 times slower than the recursive solution. Not sure why. Can someone please help me understand what is lacking in the iterative solution -\\n\\nhttps://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/submissions/994852068/\\n"
                    }
                ]
            },
            {
                "id": 1970720,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I think leetcode prepare us for placement"
                    },
                    {
                        "username": "Popat_lal",
                        "content": "This recursive is running test cases but the memoization is not running properly where i am going wrong ? Please tell TIA\\n\\n```\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k ){\\n    if(i==events.size()|| k==0) return 0;\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k);\\n    return max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k);\\n    }\\n}; \\n\\n-------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\\n    if(i==events.size()|| k==0) return 0;\\n    if(dp[i][k]!=-1) return dp[i][k];\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k,dp);\\n    return dp[i][k]=max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bruh_",
                        "content": "My code looks very similar to yours (esp the memoisation part) \nI had the same doubt- why is memoisation giving wrong ans?\n\nHere's my understanding- \n--> We need to return dp[i][k] only when events[i][0]>prev_end (only in this kind of approach.. not in binary search kond of approach)\n      you'll be able to understand why we need to do like this only if you dry run on this testcase\n     [[1,2,4],[2,3,10],[3,4,3]] , k=2; \nPlease do explain me if you understand the reason better!!! \n\nYour code worked after reordering in the following way- \n```\nclass Solution {\npublic:\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\n    if(i==events.size()|| k==0) return 0;\n    int take=0;\n    if(events[i][0]<=prev){\n        return solve(i+1,events,prev,k,dp); //the code fails if we try memoising here .. couldnot figure out this reason \n    } \n    if(dp[i][k]!=-1) return dp[i][k];\n\n    take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\n    int nottake=solve(i+1,events,prev,k,dp);\n    return dp[i][k]=max(take,nottake);\n}\n    int maxValue(vector<vector<int>>& events, int k) {\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\n        sort(events.begin(), events.end());\n        return solve(0,events,0,k,dp);\n    }\n};\n```\n\n"
                    },
                    {
                        "username": "Saphal",
                        "content": "Any way 3D dp will give TLE"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "there are 3 changing parameters i.e i,prev,k and you are using 2D dp thats why the error\\n"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "why are people complaining its just straight out Knapsack problem..replace the sack weight with number of events and find max"
                    },
                    {
                        "username": "amitpanwar02705",
                        "content": "can anyone tell me why my solution is giving wrong answer for this case [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]], k = 3 ,\\n`class Solution {\\npublic:\\n    int helper(int ind, vector<vector<int>> &arr, int k){\\n        // base case\\n        if(k == 0 || ind == arr.size()) return 0;\\n\\n        // recusive conditions\\n        int cur_val = arr[ind][2];\\n        for(int i = ind+1; i < arr.size(); i++){\\n            if(arr[i][0] > arr[ind][1])\\n            cur_val = max(cur_val,arr[ind][2] + helper(i,arr,k-1));\\n        }\\n        return cur_val;\\n    }\\n    int maxValue(vector<vector<int>>& arr, int k) {\\n        sort(arr.begin(),arr.end(), [](auto &a, auto &b){\\n            return a[0] < b[0];\\n        });\\n        int n = arr.size();\\n        vector<int> start_time(n,0);\\n        for(int i = 0 ; i < n ;i++){\\n            start_time[i] = arr[i][0];\\n        }\\n        int ans = 0 ;\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        for(int i = n-1; i >= 0 ; i--){\\n            for(int j = 1 ; j <= k ;j ++){\\n                auto check = upper_bound(start_time.begin(),start_time.end(),arr[i][1]);\\n                if(check != start_time.end()){\\n                    dp[i][j] = arr[i][2] + dp[check-start_time.begin()][j-1];\\n                }\\n                else dp[i][j] = arr[i][2];\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Who else thinks Expected Time and Space complexity must be mentioned?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "guys if you are struck look at hints :)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.\"\n\nDont you think this line is contradicting in Example 1,, Figure shown is wrong"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@om_golhani](/om_golhani) Event 0 ends on day 2 and Event 2 starts on the same day."
                    },
                    {
                        "username": "om_golhani",
                        "content": "I think It is correct, The possible sequences of events are as follows : \\n1. Event0 -> Event1 : Event0 starts at day1 and ends at day2 as well as Event1 starts at day3 and ends at day4.\\n2. Event2 : Event2 starts at day2 and ends at day3.\\n\\nThere is no such situation in which we are taking  events where one of them starts and the other ends on the same day."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "easy gg"
                    },
                    {
                        "username": "moiezgul",
                        "content": "my brain is lagging over here...."
                    },
                    {
                        "username": "santanusen",
                        "content": "Strangely, my iterative solution is 10 times slower than the recursive solution. Not sure why. Can someone please help me understand what is lacking in the iterative solution -\\n\\nhttps://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/submissions/994852068/\\n"
                    }
                ]
            },
            {
                "id": 1970712,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I think leetcode prepare us for placement"
                    },
                    {
                        "username": "Popat_lal",
                        "content": "This recursive is running test cases but the memoization is not running properly where i am going wrong ? Please tell TIA\\n\\n```\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k ){\\n    if(i==events.size()|| k==0) return 0;\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k);\\n    return max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k);\\n    }\\n}; \\n\\n-------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\\n    if(i==events.size()|| k==0) return 0;\\n    if(dp[i][k]!=-1) return dp[i][k];\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k,dp);\\n    return dp[i][k]=max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bruh_",
                        "content": "My code looks very similar to yours (esp the memoisation part) \nI had the same doubt- why is memoisation giving wrong ans?\n\nHere's my understanding- \n--> We need to return dp[i][k] only when events[i][0]>prev_end (only in this kind of approach.. not in binary search kond of approach)\n      you'll be able to understand why we need to do like this only if you dry run on this testcase\n     [[1,2,4],[2,3,10],[3,4,3]] , k=2; \nPlease do explain me if you understand the reason better!!! \n\nYour code worked after reordering in the following way- \n```\nclass Solution {\npublic:\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\n    if(i==events.size()|| k==0) return 0;\n    int take=0;\n    if(events[i][0]<=prev){\n        return solve(i+1,events,prev,k,dp); //the code fails if we try memoising here .. couldnot figure out this reason \n    } \n    if(dp[i][k]!=-1) return dp[i][k];\n\n    take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\n    int nottake=solve(i+1,events,prev,k,dp);\n    return dp[i][k]=max(take,nottake);\n}\n    int maxValue(vector<vector<int>>& events, int k) {\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\n        sort(events.begin(), events.end());\n        return solve(0,events,0,k,dp);\n    }\n};\n```\n\n"
                    },
                    {
                        "username": "Saphal",
                        "content": "Any way 3D dp will give TLE"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "there are 3 changing parameters i.e i,prev,k and you are using 2D dp thats why the error\\n"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "why are people complaining its just straight out Knapsack problem..replace the sack weight with number of events and find max"
                    },
                    {
                        "username": "amitpanwar02705",
                        "content": "can anyone tell me why my solution is giving wrong answer for this case [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]], k = 3 ,\\n`class Solution {\\npublic:\\n    int helper(int ind, vector<vector<int>> &arr, int k){\\n        // base case\\n        if(k == 0 || ind == arr.size()) return 0;\\n\\n        // recusive conditions\\n        int cur_val = arr[ind][2];\\n        for(int i = ind+1; i < arr.size(); i++){\\n            if(arr[i][0] > arr[ind][1])\\n            cur_val = max(cur_val,arr[ind][2] + helper(i,arr,k-1));\\n        }\\n        return cur_val;\\n    }\\n    int maxValue(vector<vector<int>>& arr, int k) {\\n        sort(arr.begin(),arr.end(), [](auto &a, auto &b){\\n            return a[0] < b[0];\\n        });\\n        int n = arr.size();\\n        vector<int> start_time(n,0);\\n        for(int i = 0 ; i < n ;i++){\\n            start_time[i] = arr[i][0];\\n        }\\n        int ans = 0 ;\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        for(int i = n-1; i >= 0 ; i--){\\n            for(int j = 1 ; j <= k ;j ++){\\n                auto check = upper_bound(start_time.begin(),start_time.end(),arr[i][1]);\\n                if(check != start_time.end()){\\n                    dp[i][j] = arr[i][2] + dp[check-start_time.begin()][j-1];\\n                }\\n                else dp[i][j] = arr[i][2];\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Who else thinks Expected Time and Space complexity must be mentioned?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "guys if you are struck look at hints :)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.\"\n\nDont you think this line is contradicting in Example 1,, Figure shown is wrong"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@om_golhani](/om_golhani) Event 0 ends on day 2 and Event 2 starts on the same day."
                    },
                    {
                        "username": "om_golhani",
                        "content": "I think It is correct, The possible sequences of events are as follows : \\n1. Event0 -> Event1 : Event0 starts at day1 and ends at day2 as well as Event1 starts at day3 and ends at day4.\\n2. Event2 : Event2 starts at day2 and ends at day3.\\n\\nThere is no such situation in which we are taking  events where one of them starts and the other ends on the same day."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "easy gg"
                    },
                    {
                        "username": "moiezgul",
                        "content": "my brain is lagging over here...."
                    },
                    {
                        "username": "santanusen",
                        "content": "Strangely, my iterative solution is 10 times slower than the recursive solution. Not sure why. Can someone please help me understand what is lacking in the iterative solution -\\n\\nhttps://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/submissions/994852068/\\n"
                    }
                ]
            },
            {
                "id": 1970702,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I think leetcode prepare us for placement"
                    },
                    {
                        "username": "Popat_lal",
                        "content": "This recursive is running test cases but the memoization is not running properly where i am going wrong ? Please tell TIA\\n\\n```\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k ){\\n    if(i==events.size()|| k==0) return 0;\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k);\\n    return max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k);\\n    }\\n}; \\n\\n-------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\\n    if(i==events.size()|| k==0) return 0;\\n    if(dp[i][k]!=-1) return dp[i][k];\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k,dp);\\n    return dp[i][k]=max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bruh_",
                        "content": "My code looks very similar to yours (esp the memoisation part) \nI had the same doubt- why is memoisation giving wrong ans?\n\nHere's my understanding- \n--> We need to return dp[i][k] only when events[i][0]>prev_end (only in this kind of approach.. not in binary search kond of approach)\n      you'll be able to understand why we need to do like this only if you dry run on this testcase\n     [[1,2,4],[2,3,10],[3,4,3]] , k=2; \nPlease do explain me if you understand the reason better!!! \n\nYour code worked after reordering in the following way- \n```\nclass Solution {\npublic:\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\n    if(i==events.size()|| k==0) return 0;\n    int take=0;\n    if(events[i][0]<=prev){\n        return solve(i+1,events,prev,k,dp); //the code fails if we try memoising here .. couldnot figure out this reason \n    } \n    if(dp[i][k]!=-1) return dp[i][k];\n\n    take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\n    int nottake=solve(i+1,events,prev,k,dp);\n    return dp[i][k]=max(take,nottake);\n}\n    int maxValue(vector<vector<int>>& events, int k) {\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\n        sort(events.begin(), events.end());\n        return solve(0,events,0,k,dp);\n    }\n};\n```\n\n"
                    },
                    {
                        "username": "Saphal",
                        "content": "Any way 3D dp will give TLE"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "there are 3 changing parameters i.e i,prev,k and you are using 2D dp thats why the error\\n"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "why are people complaining its just straight out Knapsack problem..replace the sack weight with number of events and find max"
                    },
                    {
                        "username": "amitpanwar02705",
                        "content": "can anyone tell me why my solution is giving wrong answer for this case [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]], k = 3 ,\\n`class Solution {\\npublic:\\n    int helper(int ind, vector<vector<int>> &arr, int k){\\n        // base case\\n        if(k == 0 || ind == arr.size()) return 0;\\n\\n        // recusive conditions\\n        int cur_val = arr[ind][2];\\n        for(int i = ind+1; i < arr.size(); i++){\\n            if(arr[i][0] > arr[ind][1])\\n            cur_val = max(cur_val,arr[ind][2] + helper(i,arr,k-1));\\n        }\\n        return cur_val;\\n    }\\n    int maxValue(vector<vector<int>>& arr, int k) {\\n        sort(arr.begin(),arr.end(), [](auto &a, auto &b){\\n            return a[0] < b[0];\\n        });\\n        int n = arr.size();\\n        vector<int> start_time(n,0);\\n        for(int i = 0 ; i < n ;i++){\\n            start_time[i] = arr[i][0];\\n        }\\n        int ans = 0 ;\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        for(int i = n-1; i >= 0 ; i--){\\n            for(int j = 1 ; j <= k ;j ++){\\n                auto check = upper_bound(start_time.begin(),start_time.end(),arr[i][1]);\\n                if(check != start_time.end()){\\n                    dp[i][j] = arr[i][2] + dp[check-start_time.begin()][j-1];\\n                }\\n                else dp[i][j] = arr[i][2];\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Who else thinks Expected Time and Space complexity must be mentioned?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "guys if you are struck look at hints :)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.\"\n\nDont you think this line is contradicting in Example 1,, Figure shown is wrong"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@om_golhani](/om_golhani) Event 0 ends on day 2 and Event 2 starts on the same day."
                    },
                    {
                        "username": "om_golhani",
                        "content": "I think It is correct, The possible sequences of events are as follows : \\n1. Event0 -> Event1 : Event0 starts at day1 and ends at day2 as well as Event1 starts at day3 and ends at day4.\\n2. Event2 : Event2 starts at day2 and ends at day3.\\n\\nThere is no such situation in which we are taking  events where one of them starts and the other ends on the same day."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "easy gg"
                    },
                    {
                        "username": "moiezgul",
                        "content": "my brain is lagging over here...."
                    },
                    {
                        "username": "santanusen",
                        "content": "Strangely, my iterative solution is 10 times slower than the recursive solution. Not sure why. Can someone please help me understand what is lacking in the iterative solution -\\n\\nhttps://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/submissions/994852068/\\n"
                    }
                ]
            },
            {
                "id": 1970684,
                "content": [
                    {
                        "username": "Ashwini_Tiwari",
                        "content": "I think leetcode prepare us for placement"
                    },
                    {
                        "username": "Popat_lal",
                        "content": "This recursive is running test cases but the memoization is not running properly where i am going wrong ? Please tell TIA\\n\\n```\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k ){\\n    if(i==events.size()|| k==0) return 0;\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k);\\n    return max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k);\\n    }\\n}; \\n\\n-------------------------------------------------------------------------------------------------------------------------------------------------\\n\\n\\n\\nclass Solution {\\npublic:\\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\\n    if(i==events.size()|| k==0) return 0;\\n    if(dp[i][k]!=-1) return dp[i][k];\\n    int take=0;\\n    if(events[i][0]>prev) take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\\n    int nottake=solve(i+1,events,prev,k,dp);\\n    return dp[i][k]=max(take,nottake);\\n}\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\\n        sort(events.begin(), events.end());\\n        return solve(0,events,0,k,dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "bruh_",
                        "content": "My code looks very similar to yours (esp the memoisation part) \nI had the same doubt- why is memoisation giving wrong ans?\n\nHere's my understanding- \n--> We need to return dp[i][k] only when events[i][0]>prev_end (only in this kind of approach.. not in binary search kond of approach)\n      you'll be able to understand why we need to do like this only if you dry run on this testcase\n     [[1,2,4],[2,3,10],[3,4,3]] , k=2; \nPlease do explain me if you understand the reason better!!! \n\nYour code worked after reordering in the following way- \n```\nclass Solution {\npublic:\nint solve(int i,vector<vector<int>>& events,int prev, int k, vector<vector<int>>&dp ){\n    if(i==events.size()|| k==0) return 0;\n    int take=0;\n    if(events[i][0]<=prev){\n        return solve(i+1,events,prev,k,dp); //the code fails if we try memoising here .. couldnot figure out this reason \n    } \n    if(dp[i][k]!=-1) return dp[i][k];\n\n    take=solve(i+1,events,events[i][1],k-1,dp)+events[i][2];\n    int nottake=solve(i+1,events,prev,k,dp);\n    return dp[i][k]=max(take,nottake);\n}\n    int maxValue(vector<vector<int>>& events, int k) {\n        vector<vector<int>>dp(events.size()+1, vector<int>(k+1,-1));\n        sort(events.begin(), events.end());\n        return solve(0,events,0,k,dp);\n    }\n};\n```\n\n"
                    },
                    {
                        "username": "Saphal",
                        "content": "Any way 3D dp will give TLE"
                    },
                    {
                        "username": "Hritik__k",
                        "content": "there are 3 changing parameters i.e i,prev,k and you are using 2D dp thats why the error\\n"
                    },
                    {
                        "username": "pinakibanerjee2001",
                        "content": "why are people complaining its just straight out Knapsack problem..replace the sack weight with number of events and find max"
                    },
                    {
                        "username": "amitpanwar02705",
                        "content": "can anyone tell me why my solution is giving wrong answer for this case [[1,3,4],[2,4,1],[1,1,4],[3,5,1],[2,5,5]], k = 3 ,\\n`class Solution {\\npublic:\\n    int helper(int ind, vector<vector<int>> &arr, int k){\\n        // base case\\n        if(k == 0 || ind == arr.size()) return 0;\\n\\n        // recusive conditions\\n        int cur_val = arr[ind][2];\\n        for(int i = ind+1; i < arr.size(); i++){\\n            if(arr[i][0] > arr[ind][1])\\n            cur_val = max(cur_val,arr[ind][2] + helper(i,arr,k-1));\\n        }\\n        return cur_val;\\n    }\\n    int maxValue(vector<vector<int>>& arr, int k) {\\n        sort(arr.begin(),arr.end(), [](auto &a, auto &b){\\n            return a[0] < b[0];\\n        });\\n        int n = arr.size();\\n        vector<int> start_time(n,0);\\n        for(int i = 0 ; i < n ;i++){\\n            start_time[i] = arr[i][0];\\n        }\\n        int ans = 0 ;\\n        vector<vector<int>> dp(n+1,vector<int>(k+1,0));\\n        for(int i = n-1; i >= 0 ; i--){\\n            for(int j = 1 ; j <= k ;j ++){\\n                auto check = upper_bound(start_time.begin(),start_time.end(),arr[i][1]);\\n                if(check != start_time.end()){\\n                    dp[i][j] = arr[i][2] + dp[check-start_time.begin()][j-1];\\n                }\\n                else dp[i][j] = arr[i][2];\\n                ans = max(ans, dp[i][j]);\\n            }\\n        }\\n        return ans;\\n    }\\n};`"
                    },
                    {
                        "username": "mahesh105",
                        "content": "Who else thinks Expected Time and Space complexity must be mentioned?"
                    },
                    {
                        "username": "shivasaineelam",
                        "content": "guys if you are struck look at hints :)"
                    },
                    {
                        "username": "garvitagrawal_02",
                        "content": "\"Note that the end day is inclusive: that is, you cannot attend two events where one of them starts and the other ends on the same day.\"\n\nDont you think this line is contradicting in Example 1,, Figure shown is wrong"
                    },
                    {
                        "username": "psionl0",
                        "content": "[@om_golhani](/om_golhani) Event 0 ends on day 2 and Event 2 starts on the same day."
                    },
                    {
                        "username": "om_golhani",
                        "content": "I think It is correct, The possible sequences of events are as follows : \\n1. Event0 -> Event1 : Event0 starts at day1 and ends at day2 as well as Event1 starts at day3 and ends at day4.\\n2. Event2 : Event2 starts at day2 and ends at day3.\\n\\nThere is no such situation in which we are taking  events where one of them starts and the other ends on the same day."
                    },
                    {
                        "username": "rajeshsingh505",
                        "content": "easy gg"
                    },
                    {
                        "username": "moiezgul",
                        "content": "my brain is lagging over here...."
                    },
                    {
                        "username": "santanusen",
                        "content": "Strangely, my iterative solution is 10 times slower than the recursive solution. Not sure why. Can someone please help me understand what is lacking in the iterative solution -\\n\\nhttps://leetcode.com/problems/maximum-number-of-events-that-can-be-attended-ii/submissions/994852068/\\n"
                    }
                ]
            },
            {
                "id": 1970666,
                "content": [
                    {
                        "username": "its_Vivek",
                        "content": "Its kinda hard but dp gang assemble!!! we can do it using dp and memoizatin quickly."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sorting + Knapsack"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i thought we cant use 2d dp bcoz of tle \\uD83D\\uDE2D"
                    },
                    {
                        "username": "rahul2001dogra",
                        "content": "Tried 3d DP, gave Memory Limit Exceeded. Is there any way to make this work??\\n```\\nclass Solution {\\npublic:\\n    int f(int idx, int prev, int k, vector<vector<int>>& events, vector<vector<vector<int>>>& dp) {\\n        if(idx == events.size() || k == 0) return 0;\\n        if(dp[idx][prev+1][k] != -1) dp[idx][prev+1][k];\\n        int skip = f(idx+1, prev, k, events, dp);\\n        int take = 0;\\n        if(prev == -1 || events[prev][1] < events[idx][0]){\\n            take = events[idx][2] + f(idx+1, idx, k-1, events, dp);\\n        }\\n\\n        return dp[idx][prev+1][k] = max(take, skip);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n+1, vector<int>(k+1, -1)));\\n        return f(0, -1, k, events, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\' in recursion function for checking if the current event do not overlap with the prev event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "Use unorderedmap in place of dp vector \n\nunordered_map<int,unordered_map<int,unordered_map<int,int>>>dp;\n  \n   int f(int i,int prev,vector<vector<int>>&v,int k,int d)\n   {\n       if(i==v.size() || d>=k)return 0;\n       int pick=0,npick=0;\n       if(dp.count(i) and dp[i].count(prev+1) and dp[i][prev+1].count(k)) return dp[i][prev+1][d];\n       if((prev==-1 || v[i][0]>v[prev][1]) )\n       pick=v[i][2]+f(i+1,i,v,k,d+1);\n       npick=f(i+1,prev,v,k,d);\n       return dp[i][prev+1][d]=max(pick,npick);\n   }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n=events.size();\n        sort(events.begin(),events.end());   \n        return f(0,-1,events,k,0);\n    }\n\nBut this give TLE"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "0/1 Knapsack ??"
                    },
                    {
                        "username": "a8hi",
                        "content": "recursion was not that hard , here comes the hard part"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is O(n * n * k) accepted for this problem? Event faster than 90%"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Test cases in this and many other \\'Binary Search\\' problems are weak. Linear search approach beats many of the Binary search approach in all these problems"
                    },
                    {
                        "username": "code__HARD",
                        "content": "0/1 Knapsack "
                    },
                    {
                        "username": "Taswell",
                        "content": "i suck"
                    },
                    {
                        "username": "echen5503",
                        "content": "ah.\\n"
                    }
                ]
            },
            {
                "id": 1970635,
                "content": [
                    {
                        "username": "its_Vivek",
                        "content": "Its kinda hard but dp gang assemble!!! we can do it using dp and memoizatin quickly."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sorting + Knapsack"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i thought we cant use 2d dp bcoz of tle \\uD83D\\uDE2D"
                    },
                    {
                        "username": "rahul2001dogra",
                        "content": "Tried 3d DP, gave Memory Limit Exceeded. Is there any way to make this work??\\n```\\nclass Solution {\\npublic:\\n    int f(int idx, int prev, int k, vector<vector<int>>& events, vector<vector<vector<int>>>& dp) {\\n        if(idx == events.size() || k == 0) return 0;\\n        if(dp[idx][prev+1][k] != -1) dp[idx][prev+1][k];\\n        int skip = f(idx+1, prev, k, events, dp);\\n        int take = 0;\\n        if(prev == -1 || events[prev][1] < events[idx][0]){\\n            take = events[idx][2] + f(idx+1, idx, k-1, events, dp);\\n        }\\n\\n        return dp[idx][prev+1][k] = max(take, skip);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n+1, vector<int>(k+1, -1)));\\n        return f(0, -1, k, events, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\' in recursion function for checking if the current event do not overlap with the prev event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "Use unorderedmap in place of dp vector \n\nunordered_map<int,unordered_map<int,unordered_map<int,int>>>dp;\n  \n   int f(int i,int prev,vector<vector<int>>&v,int k,int d)\n   {\n       if(i==v.size() || d>=k)return 0;\n       int pick=0,npick=0;\n       if(dp.count(i) and dp[i].count(prev+1) and dp[i][prev+1].count(k)) return dp[i][prev+1][d];\n       if((prev==-1 || v[i][0]>v[prev][1]) )\n       pick=v[i][2]+f(i+1,i,v,k,d+1);\n       npick=f(i+1,prev,v,k,d);\n       return dp[i][prev+1][d]=max(pick,npick);\n   }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n=events.size();\n        sort(events.begin(),events.end());   \n        return f(0,-1,events,k,0);\n    }\n\nBut this give TLE"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "0/1 Knapsack ??"
                    },
                    {
                        "username": "a8hi",
                        "content": "recursion was not that hard , here comes the hard part"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is O(n * n * k) accepted for this problem? Event faster than 90%"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Test cases in this and many other \\'Binary Search\\' problems are weak. Linear search approach beats many of the Binary search approach in all these problems"
                    },
                    {
                        "username": "code__HARD",
                        "content": "0/1 Knapsack "
                    },
                    {
                        "username": "Taswell",
                        "content": "i suck"
                    },
                    {
                        "username": "echen5503",
                        "content": "ah.\\n"
                    }
                ]
            },
            {
                "id": 1970620,
                "content": [
                    {
                        "username": "its_Vivek",
                        "content": "Its kinda hard but dp gang assemble!!! we can do it using dp and memoizatin quickly."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sorting + Knapsack"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i thought we cant use 2d dp bcoz of tle \\uD83D\\uDE2D"
                    },
                    {
                        "username": "rahul2001dogra",
                        "content": "Tried 3d DP, gave Memory Limit Exceeded. Is there any way to make this work??\\n```\\nclass Solution {\\npublic:\\n    int f(int idx, int prev, int k, vector<vector<int>>& events, vector<vector<vector<int>>>& dp) {\\n        if(idx == events.size() || k == 0) return 0;\\n        if(dp[idx][prev+1][k] != -1) dp[idx][prev+1][k];\\n        int skip = f(idx+1, prev, k, events, dp);\\n        int take = 0;\\n        if(prev == -1 || events[prev][1] < events[idx][0]){\\n            take = events[idx][2] + f(idx+1, idx, k-1, events, dp);\\n        }\\n\\n        return dp[idx][prev+1][k] = max(take, skip);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n+1, vector<int>(k+1, -1)));\\n        return f(0, -1, k, events, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\' in recursion function for checking if the current event do not overlap with the prev event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "Use unorderedmap in place of dp vector \n\nunordered_map<int,unordered_map<int,unordered_map<int,int>>>dp;\n  \n   int f(int i,int prev,vector<vector<int>>&v,int k,int d)\n   {\n       if(i==v.size() || d>=k)return 0;\n       int pick=0,npick=0;\n       if(dp.count(i) and dp[i].count(prev+1) and dp[i][prev+1].count(k)) return dp[i][prev+1][d];\n       if((prev==-1 || v[i][0]>v[prev][1]) )\n       pick=v[i][2]+f(i+1,i,v,k,d+1);\n       npick=f(i+1,prev,v,k,d);\n       return dp[i][prev+1][d]=max(pick,npick);\n   }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n=events.size();\n        sort(events.begin(),events.end());   \n        return f(0,-1,events,k,0);\n    }\n\nBut this give TLE"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "0/1 Knapsack ??"
                    },
                    {
                        "username": "a8hi",
                        "content": "recursion was not that hard , here comes the hard part"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is O(n * n * k) accepted for this problem? Event faster than 90%"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Test cases in this and many other \\'Binary Search\\' problems are weak. Linear search approach beats many of the Binary search approach in all these problems"
                    },
                    {
                        "username": "code__HARD",
                        "content": "0/1 Knapsack "
                    },
                    {
                        "username": "Taswell",
                        "content": "i suck"
                    },
                    {
                        "username": "echen5503",
                        "content": "ah.\\n"
                    }
                ]
            },
            {
                "id": 1970603,
                "content": [
                    {
                        "username": "its_Vivek",
                        "content": "Its kinda hard but dp gang assemble!!! we can do it using dp and memoizatin quickly."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sorting + Knapsack"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i thought we cant use 2d dp bcoz of tle \\uD83D\\uDE2D"
                    },
                    {
                        "username": "rahul2001dogra",
                        "content": "Tried 3d DP, gave Memory Limit Exceeded. Is there any way to make this work??\\n```\\nclass Solution {\\npublic:\\n    int f(int idx, int prev, int k, vector<vector<int>>& events, vector<vector<vector<int>>>& dp) {\\n        if(idx == events.size() || k == 0) return 0;\\n        if(dp[idx][prev+1][k] != -1) dp[idx][prev+1][k];\\n        int skip = f(idx+1, prev, k, events, dp);\\n        int take = 0;\\n        if(prev == -1 || events[prev][1] < events[idx][0]){\\n            take = events[idx][2] + f(idx+1, idx, k-1, events, dp);\\n        }\\n\\n        return dp[idx][prev+1][k] = max(take, skip);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n+1, vector<int>(k+1, -1)));\\n        return f(0, -1, k, events, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\' in recursion function for checking if the current event do not overlap with the prev event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "Use unorderedmap in place of dp vector \n\nunordered_map<int,unordered_map<int,unordered_map<int,int>>>dp;\n  \n   int f(int i,int prev,vector<vector<int>>&v,int k,int d)\n   {\n       if(i==v.size() || d>=k)return 0;\n       int pick=0,npick=0;\n       if(dp.count(i) and dp[i].count(prev+1) and dp[i][prev+1].count(k)) return dp[i][prev+1][d];\n       if((prev==-1 || v[i][0]>v[prev][1]) )\n       pick=v[i][2]+f(i+1,i,v,k,d+1);\n       npick=f(i+1,prev,v,k,d);\n       return dp[i][prev+1][d]=max(pick,npick);\n   }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n=events.size();\n        sort(events.begin(),events.end());   \n        return f(0,-1,events,k,0);\n    }\n\nBut this give TLE"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "0/1 Knapsack ??"
                    },
                    {
                        "username": "a8hi",
                        "content": "recursion was not that hard , here comes the hard part"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is O(n * n * k) accepted for this problem? Event faster than 90%"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Test cases in this and many other \\'Binary Search\\' problems are weak. Linear search approach beats many of the Binary search approach in all these problems"
                    },
                    {
                        "username": "code__HARD",
                        "content": "0/1 Knapsack "
                    },
                    {
                        "username": "Taswell",
                        "content": "i suck"
                    },
                    {
                        "username": "echen5503",
                        "content": "ah.\\n"
                    }
                ]
            },
            {
                "id": 1970558,
                "content": [
                    {
                        "username": "its_Vivek",
                        "content": "Its kinda hard but dp gang assemble!!! we can do it using dp and memoizatin quickly."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sorting + Knapsack"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i thought we cant use 2d dp bcoz of tle \\uD83D\\uDE2D"
                    },
                    {
                        "username": "rahul2001dogra",
                        "content": "Tried 3d DP, gave Memory Limit Exceeded. Is there any way to make this work??\\n```\\nclass Solution {\\npublic:\\n    int f(int idx, int prev, int k, vector<vector<int>>& events, vector<vector<vector<int>>>& dp) {\\n        if(idx == events.size() || k == 0) return 0;\\n        if(dp[idx][prev+1][k] != -1) dp[idx][prev+1][k];\\n        int skip = f(idx+1, prev, k, events, dp);\\n        int take = 0;\\n        if(prev == -1 || events[prev][1] < events[idx][0]){\\n            take = events[idx][2] + f(idx+1, idx, k-1, events, dp);\\n        }\\n\\n        return dp[idx][prev+1][k] = max(take, skip);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n+1, vector<int>(k+1, -1)));\\n        return f(0, -1, k, events, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\' in recursion function for checking if the current event do not overlap with the prev event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "Use unorderedmap in place of dp vector \n\nunordered_map<int,unordered_map<int,unordered_map<int,int>>>dp;\n  \n   int f(int i,int prev,vector<vector<int>>&v,int k,int d)\n   {\n       if(i==v.size() || d>=k)return 0;\n       int pick=0,npick=0;\n       if(dp.count(i) and dp[i].count(prev+1) and dp[i][prev+1].count(k)) return dp[i][prev+1][d];\n       if((prev==-1 || v[i][0]>v[prev][1]) )\n       pick=v[i][2]+f(i+1,i,v,k,d+1);\n       npick=f(i+1,prev,v,k,d);\n       return dp[i][prev+1][d]=max(pick,npick);\n   }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n=events.size();\n        sort(events.begin(),events.end());   \n        return f(0,-1,events,k,0);\n    }\n\nBut this give TLE"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "0/1 Knapsack ??"
                    },
                    {
                        "username": "a8hi",
                        "content": "recursion was not that hard , here comes the hard part"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is O(n * n * k) accepted for this problem? Event faster than 90%"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Test cases in this and many other \\'Binary Search\\' problems are weak. Linear search approach beats many of the Binary search approach in all these problems"
                    },
                    {
                        "username": "code__HARD",
                        "content": "0/1 Knapsack "
                    },
                    {
                        "username": "Taswell",
                        "content": "i suck"
                    },
                    {
                        "username": "echen5503",
                        "content": "ah.\\n"
                    }
                ]
            },
            {
                "id": 1970552,
                "content": [
                    {
                        "username": "its_Vivek",
                        "content": "Its kinda hard but dp gang assemble!!! we can do it using dp and memoizatin quickly."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sorting + Knapsack"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i thought we cant use 2d dp bcoz of tle \\uD83D\\uDE2D"
                    },
                    {
                        "username": "rahul2001dogra",
                        "content": "Tried 3d DP, gave Memory Limit Exceeded. Is there any way to make this work??\\n```\\nclass Solution {\\npublic:\\n    int f(int idx, int prev, int k, vector<vector<int>>& events, vector<vector<vector<int>>>& dp) {\\n        if(idx == events.size() || k == 0) return 0;\\n        if(dp[idx][prev+1][k] != -1) dp[idx][prev+1][k];\\n        int skip = f(idx+1, prev, k, events, dp);\\n        int take = 0;\\n        if(prev == -1 || events[prev][1] < events[idx][0]){\\n            take = events[idx][2] + f(idx+1, idx, k-1, events, dp);\\n        }\\n\\n        return dp[idx][prev+1][k] = max(take, skip);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n+1, vector<int>(k+1, -1)));\\n        return f(0, -1, k, events, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\' in recursion function for checking if the current event do not overlap with the prev event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "Use unorderedmap in place of dp vector \n\nunordered_map<int,unordered_map<int,unordered_map<int,int>>>dp;\n  \n   int f(int i,int prev,vector<vector<int>>&v,int k,int d)\n   {\n       if(i==v.size() || d>=k)return 0;\n       int pick=0,npick=0;\n       if(dp.count(i) and dp[i].count(prev+1) and dp[i][prev+1].count(k)) return dp[i][prev+1][d];\n       if((prev==-1 || v[i][0]>v[prev][1]) )\n       pick=v[i][2]+f(i+1,i,v,k,d+1);\n       npick=f(i+1,prev,v,k,d);\n       return dp[i][prev+1][d]=max(pick,npick);\n   }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n=events.size();\n        sort(events.begin(),events.end());   \n        return f(0,-1,events,k,0);\n    }\n\nBut this give TLE"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "0/1 Knapsack ??"
                    },
                    {
                        "username": "a8hi",
                        "content": "recursion was not that hard , here comes the hard part"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is O(n * n * k) accepted for this problem? Event faster than 90%"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Test cases in this and many other \\'Binary Search\\' problems are weak. Linear search approach beats many of the Binary search approach in all these problems"
                    },
                    {
                        "username": "code__HARD",
                        "content": "0/1 Knapsack "
                    },
                    {
                        "username": "Taswell",
                        "content": "i suck"
                    },
                    {
                        "username": "echen5503",
                        "content": "ah.\\n"
                    }
                ]
            },
            {
                "id": 1970511,
                "content": [
                    {
                        "username": "its_Vivek",
                        "content": "Its kinda hard but dp gang assemble!!! we can do it using dp and memoizatin quickly."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sorting + Knapsack"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i thought we cant use 2d dp bcoz of tle \\uD83D\\uDE2D"
                    },
                    {
                        "username": "rahul2001dogra",
                        "content": "Tried 3d DP, gave Memory Limit Exceeded. Is there any way to make this work??\\n```\\nclass Solution {\\npublic:\\n    int f(int idx, int prev, int k, vector<vector<int>>& events, vector<vector<vector<int>>>& dp) {\\n        if(idx == events.size() || k == 0) return 0;\\n        if(dp[idx][prev+1][k] != -1) dp[idx][prev+1][k];\\n        int skip = f(idx+1, prev, k, events, dp);\\n        int take = 0;\\n        if(prev == -1 || events[prev][1] < events[idx][0]){\\n            take = events[idx][2] + f(idx+1, idx, k-1, events, dp);\\n        }\\n\\n        return dp[idx][prev+1][k] = max(take, skip);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n+1, vector<int>(k+1, -1)));\\n        return f(0, -1, k, events, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\' in recursion function for checking if the current event do not overlap with the prev event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "Use unorderedmap in place of dp vector \n\nunordered_map<int,unordered_map<int,unordered_map<int,int>>>dp;\n  \n   int f(int i,int prev,vector<vector<int>>&v,int k,int d)\n   {\n       if(i==v.size() || d>=k)return 0;\n       int pick=0,npick=0;\n       if(dp.count(i) and dp[i].count(prev+1) and dp[i][prev+1].count(k)) return dp[i][prev+1][d];\n       if((prev==-1 || v[i][0]>v[prev][1]) )\n       pick=v[i][2]+f(i+1,i,v,k,d+1);\n       npick=f(i+1,prev,v,k,d);\n       return dp[i][prev+1][d]=max(pick,npick);\n   }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n=events.size();\n        sort(events.begin(),events.end());   \n        return f(0,-1,events,k,0);\n    }\n\nBut this give TLE"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "0/1 Knapsack ??"
                    },
                    {
                        "username": "a8hi",
                        "content": "recursion was not that hard , here comes the hard part"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is O(n * n * k) accepted for this problem? Event faster than 90%"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Test cases in this and many other \\'Binary Search\\' problems are weak. Linear search approach beats many of the Binary search approach in all these problems"
                    },
                    {
                        "username": "code__HARD",
                        "content": "0/1 Knapsack "
                    },
                    {
                        "username": "Taswell",
                        "content": "i suck"
                    },
                    {
                        "username": "echen5503",
                        "content": "ah.\\n"
                    }
                ]
            },
            {
                "id": 1970508,
                "content": [
                    {
                        "username": "its_Vivek",
                        "content": "Its kinda hard but dp gang assemble!!! we can do it using dp and memoizatin quickly."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sorting + Knapsack"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i thought we cant use 2d dp bcoz of tle \\uD83D\\uDE2D"
                    },
                    {
                        "username": "rahul2001dogra",
                        "content": "Tried 3d DP, gave Memory Limit Exceeded. Is there any way to make this work??\\n```\\nclass Solution {\\npublic:\\n    int f(int idx, int prev, int k, vector<vector<int>>& events, vector<vector<vector<int>>>& dp) {\\n        if(idx == events.size() || k == 0) return 0;\\n        if(dp[idx][prev+1][k] != -1) dp[idx][prev+1][k];\\n        int skip = f(idx+1, prev, k, events, dp);\\n        int take = 0;\\n        if(prev == -1 || events[prev][1] < events[idx][0]){\\n            take = events[idx][2] + f(idx+1, idx, k-1, events, dp);\\n        }\\n\\n        return dp[idx][prev+1][k] = max(take, skip);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n+1, vector<int>(k+1, -1)));\\n        return f(0, -1, k, events, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\' in recursion function for checking if the current event do not overlap with the prev event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "Use unorderedmap in place of dp vector \n\nunordered_map<int,unordered_map<int,unordered_map<int,int>>>dp;\n  \n   int f(int i,int prev,vector<vector<int>>&v,int k,int d)\n   {\n       if(i==v.size() || d>=k)return 0;\n       int pick=0,npick=0;\n       if(dp.count(i) and dp[i].count(prev+1) and dp[i][prev+1].count(k)) return dp[i][prev+1][d];\n       if((prev==-1 || v[i][0]>v[prev][1]) )\n       pick=v[i][2]+f(i+1,i,v,k,d+1);\n       npick=f(i+1,prev,v,k,d);\n       return dp[i][prev+1][d]=max(pick,npick);\n   }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n=events.size();\n        sort(events.begin(),events.end());   \n        return f(0,-1,events,k,0);\n    }\n\nBut this give TLE"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "0/1 Knapsack ??"
                    },
                    {
                        "username": "a8hi",
                        "content": "recursion was not that hard , here comes the hard part"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is O(n * n * k) accepted for this problem? Event faster than 90%"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Test cases in this and many other \\'Binary Search\\' problems are weak. Linear search approach beats many of the Binary search approach in all these problems"
                    },
                    {
                        "username": "code__HARD",
                        "content": "0/1 Knapsack "
                    },
                    {
                        "username": "Taswell",
                        "content": "i suck"
                    },
                    {
                        "username": "echen5503",
                        "content": "ah.\\n"
                    }
                ]
            },
            {
                "id": 1970463,
                "content": [
                    {
                        "username": "its_Vivek",
                        "content": "Its kinda hard but dp gang assemble!!! we can do it using dp and memoizatin quickly."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sorting + Knapsack"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i thought we cant use 2d dp bcoz of tle \\uD83D\\uDE2D"
                    },
                    {
                        "username": "rahul2001dogra",
                        "content": "Tried 3d DP, gave Memory Limit Exceeded. Is there any way to make this work??\\n```\\nclass Solution {\\npublic:\\n    int f(int idx, int prev, int k, vector<vector<int>>& events, vector<vector<vector<int>>>& dp) {\\n        if(idx == events.size() || k == 0) return 0;\\n        if(dp[idx][prev+1][k] != -1) dp[idx][prev+1][k];\\n        int skip = f(idx+1, prev, k, events, dp);\\n        int take = 0;\\n        if(prev == -1 || events[prev][1] < events[idx][0]){\\n            take = events[idx][2] + f(idx+1, idx, k-1, events, dp);\\n        }\\n\\n        return dp[idx][prev+1][k] = max(take, skip);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n+1, vector<int>(k+1, -1)));\\n        return f(0, -1, k, events, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\' in recursion function for checking if the current event do not overlap with the prev event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "Use unorderedmap in place of dp vector \n\nunordered_map<int,unordered_map<int,unordered_map<int,int>>>dp;\n  \n   int f(int i,int prev,vector<vector<int>>&v,int k,int d)\n   {\n       if(i==v.size() || d>=k)return 0;\n       int pick=0,npick=0;\n       if(dp.count(i) and dp[i].count(prev+1) and dp[i][prev+1].count(k)) return dp[i][prev+1][d];\n       if((prev==-1 || v[i][0]>v[prev][1]) )\n       pick=v[i][2]+f(i+1,i,v,k,d+1);\n       npick=f(i+1,prev,v,k,d);\n       return dp[i][prev+1][d]=max(pick,npick);\n   }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n=events.size();\n        sort(events.begin(),events.end());   \n        return f(0,-1,events,k,0);\n    }\n\nBut this give TLE"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "0/1 Knapsack ??"
                    },
                    {
                        "username": "a8hi",
                        "content": "recursion was not that hard , here comes the hard part"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is O(n * n * k) accepted for this problem? Event faster than 90%"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Test cases in this and many other \\'Binary Search\\' problems are weak. Linear search approach beats many of the Binary search approach in all these problems"
                    },
                    {
                        "username": "code__HARD",
                        "content": "0/1 Knapsack "
                    },
                    {
                        "username": "Taswell",
                        "content": "i suck"
                    },
                    {
                        "username": "echen5503",
                        "content": "ah.\\n"
                    }
                ]
            },
            {
                "id": 1970365,
                "content": [
                    {
                        "username": "its_Vivek",
                        "content": "Its kinda hard but dp gang assemble!!! we can do it using dp and memoizatin quickly."
                    },
                    {
                        "username": "saklanishubham15",
                        "content": "Sorting + Knapsack"
                    },
                    {
                        "username": "dumb_me",
                        "content": "i thought we cant use 2d dp bcoz of tle \\uD83D\\uDE2D"
                    },
                    {
                        "username": "rahul2001dogra",
                        "content": "Tried 3d DP, gave Memory Limit Exceeded. Is there any way to make this work??\\n```\\nclass Solution {\\npublic:\\n    int f(int idx, int prev, int k, vector<vector<int>>& events, vector<vector<vector<int>>>& dp) {\\n        if(idx == events.size() || k == 0) return 0;\\n        if(dp[idx][prev+1][k] != -1) dp[idx][prev+1][k];\\n        int skip = f(idx+1, prev, k, events, dp);\\n        int take = 0;\\n        if(prev == -1 || events[prev][1] < events[idx][0]){\\n            take = events[idx][2] + f(idx+1, idx, k-1, events, dp);\\n        }\\n\\n        return dp[idx][prev+1][k] = max(take, skip);\\n    }\\n    int maxValue(vector<vector<int>>& events, int k) {\\n        int n = events.size();\\n        sort(events.begin(), events.end());\\n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n+1, vector<int>(k+1, -1)));\\n        return f(0, -1, k, events, dp);\\n    }\\n};\\n```"
                    },
                    {
                        "username": "om_golhani",
                        "content": "Here we are using the binary search Algorithm to find the next possible event after current event as because if we iteratively do this then we have to maintain third variable \\'prev_end\\' in recursion function for checking if the current event do not overlap with the prev event and then for memoization/Tabulation We would have to maintain a 3D table to store the states of each variable which would cost much memory and may give Memory Limit Exceeded (MLE) error."
                    },
                    {
                        "username": "Naveen_somireddy",
                        "content": "Use unorderedmap in place of dp vector \n\nunordered_map<int,unordered_map<int,unordered_map<int,int>>>dp;\n  \n   int f(int i,int prev,vector<vector<int>>&v,int k,int d)\n   {\n       if(i==v.size() || d>=k)return 0;\n       int pick=0,npick=0;\n       if(dp.count(i) and dp[i].count(prev+1) and dp[i][prev+1].count(k)) return dp[i][prev+1][d];\n       if((prev==-1 || v[i][0]>v[prev][1]) )\n       pick=v[i][2]+f(i+1,i,v,k,d+1);\n       npick=f(i+1,prev,v,k,d);\n       return dp[i][prev+1][d]=max(pick,npick);\n   }\n    int maxValue(vector<vector<int>>& events, int k) {\n        int n=events.size();\n        sort(events.begin(),events.end());   \n        return f(0,-1,events,k,0);\n    }\n\nBut this give TLE"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "0/1 Knapsack ??"
                    },
                    {
                        "username": "a8hi",
                        "content": "recursion was not that hard , here comes the hard part"
                    },
                    {
                        "username": "_aka5h",
                        "content": "Why is O(n * n * k) accepted for this problem? Event faster than 90%"
                    },
                    {
                        "username": "Baymax_",
                        "content": "Test cases in this and many other \\'Binary Search\\' problems are weak. Linear search approach beats many of the Binary search approach in all these problems"
                    },
                    {
                        "username": "code__HARD",
                        "content": "0/1 Knapsack "
                    },
                    {
                        "username": "Taswell",
                        "content": "i suck"
                    },
                    {
                        "username": "echen5503",
                        "content": "ah.\\n"
                    }
                ]
            }
        ]
    }
]