[
    {
        "title": "Range Sum Query - Immutable",
        "question_content": "Given an integer array nums, handle multiple queries of the following type:\n\n\tCalculate the sum of the elements of nums between indices left and right inclusive where left <= right.\n\nImplement the NumArray class:\n\n\tNumArray(int[] nums) Initializes the object with the integer array nums.\n\tint sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).\n\n&nbsp;\nExample 1:\n\nInput\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\nOutput\n[null, 1, -1, -3]\nExplanation\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n\n&nbsp;\nConstraints:\n\n\t1 <= nums.length <= 104\n\t-105 <= nums[i] <= 105\n\t0 <= left <= right < nums.length\n\tAt most 104 calls will be made to sumRange.",
        "solutions": [
            {
                "id": 75192,
                "title": "java-simple-o-n-init-and-o-1-query-solution",
                "content": "public class NumArray {\\n\\n    int[] nums;\\n    \\n    public NumArray(int[] nums) {\\n        for(int i = 1; i < nums.length; i++)\\n            nums[i] += nums[i - 1];\\n        \\n        this.nums = nums;\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        if(i == 0)\\n            return nums[j];\\n        \\n        return nums[j] - nums[i - 1];\\n    }\\n}",
                "solutionTags": [],
                "code": "public class NumArray {\\n\\n    int[] nums;\\n    \\n    public NumArray(int[] nums) {\\n        for(int i = 1; i < nums.length; i++)\\n            nums[i] += nums[i - 1];\\n        \\n        this.nums = nums;\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        if(i == 0)\\n            return nums[j];\\n        \\n        return nums[j] - nums[i - 1];\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 1406465,
                "title": "c-java-python-prefix-sum-clean-concise-o-1-space",
                "content": "**Idea**\\n- This problem is quite easy since our operations are just query `sumRange` without update values in `nums` on the way (Immutable).\\n- So we just pre-calculated the prefix sum of `nums` array, where `preSum[i]` is sum of `nums[0..i]`, so the result of `sumRange(left, right)` are:\\n\\t- If `left = 0` then return `preSum[right]`\\n\\t- Else return `preSum[right] - preSum[left-1]`.\\n- The advance version of this problem is [307. Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/) where we can update the values in `nums` dynamically (Mutable).\\n\\n<iframe src=\"https://leetcode.com/playground/hqJuDsAL/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\n**Complexity**\\n- Time: \\n\\t- Constructor: O(N)\\n\\t- sumRange(left, right): `O(1)`\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "solutionTags": [],
                "code": "**Idea**\\n- This problem is quite easy since our operations are just query `sumRange` without update values in `nums` on the way (Immutable).\\n- So we just pre-calculated the prefix sum of `nums` array, where `preSum[i]` is sum of `nums[0..i]`, so the result of `sumRange(left, right)` are:\\n\\t- If `left = 0` then return `preSum[right]`\\n\\t- Else return `preSum[right] - preSum[left-1]`.\\n- The advance version of this problem is [307. Range Sum Query - Mutable](https://leetcode.com/problems/range-sum-query-mutable/) where we can update the values in `nums` dynamically (Mutable).\\n\\n<iframe src=\"https://leetcode.com/playground/hqJuDsAL/shared\" frameBorder=\"0\" width=\"100%\" height=\"300\"></iframe>\\n\\n**Complexity**\\n- Time: \\n\\t- Constructor: O(N)\\n\\t- sumRange(left, right): `O(1)`\\n- Space: `O(1)`\\n\\nIf you think this **post is useful**, I\\'m happy if you **give a vote**. Any **questions or discussions are welcome!** Thank a lot.",
                "codeTag": "Unknown"
            },
            {
                "id": 75184,
                "title": "5-lines-c-4-lines-python",
                "content": "The idea is fairly straightforward: create an array `accu` that stores the accumulated sum for `nums` such that `accu[i] = nums[0] + ... + nums[i - 1]` in the initializer of `NumArray`. Then just return `accu[j + 1] - accu[i]` in `sumRange`. You may try the example in the problem statement to convince yourself of this idea.\\n\\nThe code is as follows.\\n\\n----------\\n**C++**\\n\\n    class NumArray {\\n    public:\\n        NumArray(vector<int> &nums) {\\n            accu.push_back(0);\\n            for (int num : nums)\\n                accu.push_back(accu.back() + num);\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return accu[j + 1] - accu[i];\\n        }\\n    private:\\n        vector<int> accu;\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2); \\n\\n----------\\n**Python**\\n\\n    class NumArray(object):\\n        def __init__(self, nums):\\n            \"\"\"\\n            initialize your data structure here.\\n            :type nums: List[int]\\n            \"\"\"\\n            self.accu = [0]\\n            for num in nums: \\n                self.accu += self.accu[-1] + num,\\n    \\n        def sumRange(self, i, j):\\n            \"\"\"\\n            sum of elements nums[i..j], inclusive.\\n            :type i: int \\n            :type j: int\\n            :rtype: int \\n            \"\"\"\\n            return self.accu[j + 1] - self.accu[i]\\n    \\n    \\n    # Your NumArray object will be instantiated and called as such:\\n    # numArray = NumArray(nums)\\n    # numArray.sumRange(0, 1)\\n    # numArray.sumRange(1, 2)",
                "solutionTags": [
                    "C++",
                    "Array"
                ],
                "code": "The idea is fairly straightforward: create an array `accu` that stores the accumulated sum for `nums` such that `accu[i] = nums[0] + ... + nums[i - 1]` in the initializer of `NumArray`. Then just return `accu[j + 1] - accu[i]` in `sumRange`. You may try the example in the problem statement to convince yourself of this idea.\\n\\nThe code is as follows.\\n\\n----------\\n**C++**\\n\\n    class NumArray {\\n    public:\\n        NumArray(vector<int> &nums) {\\n            accu.push_back(0);\\n            for (int num : nums)\\n                accu.push_back(accu.back() + num);\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return accu[j + 1] - accu[i];\\n        }\\n    private:\\n        vector<int> accu;\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2); \\n\\n----------\\n**Python**\\n\\n    class NumArray(object):\\n        def __init__(self, nums):\\n            \"\"\"\\n            initialize your data structure here.\\n            :type nums: List[int]\\n            \"\"\"\\n            self.accu = [0]\\n            for num in nums: \\n                self.accu += self.accu[-1] + num,\\n    \\n        def sumRange(self, i, j):\\n            \"\"\"\\n            sum of elements nums[i..j], inclusive.\\n            :type i: int \\n            :type j: int\\n            :rtype: int \\n            \"\"\"\\n            return self.accu[j + 1] - self.accu[i]\\n    \\n    \\n    # Your NumArray object will be instantiated and called as such:\\n    # numArray = NumArray(nums)\\n    # numArray.sumRange(0, 1)\\n    # numArray.sumRange(1, 2)",
                "codeTag": "Java"
            },
            {
                "id": 75194,
                "title": "explanation-with-images",
                "content": "\\n![SumQuery](/assets/uploads/files/1503631407822-sumquery-1-resized.jpg) \\n\\nThe Image above represents the following \\nAll these are for the input array [-2,0,3,-5,2,-1]\\nThe inout array and the 0 based index ( highlighted in yellow ) are shown. \\n\\nIdea is to represent this array in a n*n matrix where n is the size of the initial array.\\n\\nThere are 2 ways of doing this representation. Table 1 show one way\\nIn Table 1 , note the following \\n- Diagonal represents the original array. so arr[i][j] = nuts[i]\\n- The values in the next column come from the previous column \\n   row 0, col 0 = Since there is no column before it, nothing to do\\n   row 1, col 1 = This is a diagonal, so we already know its value \\n   row 0, col 1 = row 0 , col 0 + row 1, col1\\n  \\n  row 2, col 2 = Diagonal value , so its same as nums[2]\\n  row 1, col2 = row1,col1 + row2,col2 \\n  row 0,col 2 = row0, col2 + row2, col2\\n\\nYou get the idea \\n\\nHere is the code. \\n\\n```\\n\\n    private int[][] ints;\\n    public NumArray(int[] nums) {\\n        ints = new int[nums.length][nums.length];\\n        populate(nums);\\n    }\\n\\n    private void populate(int[] nums){\\n        for (int i=0; i < nums.length; i++){\\n            ints[i][i] = nums[i];\\n\\n            for (int j= i-1; j >=0; j--){\\n                ints[j][i] = ints[j][i-1] + ints[i][i];\\n            }\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        \\n        return ints[i][j];\\n    }\\n```\\n\\nThe issue is that this uses n*n matrix space and its still a O(n2) due to initial population of array \\n\\nBut, the idea to expand the problem to get a better understanding. Thats how the mind works, right ;)\\n\\nKey thing to notice above are these things \\n1. The table was build from the fact the diagonal has the same values as the input array.\\n2. The table was build bottom up, as in, from the diagonal value to the rows above it and this was done for each column. \\n3. After the n*n matrix is build, take a look at the first row. It sure looks like a cumulative array. Nice!! Now knowing this , we can start to optimize the solution. \\n\\nNext, lets look at TABLE 2\\nBased on the discoveries of TABLE1 , we use those to build table 2\\n1. We know that if we can get a cumulative array , represented by first row, then the rest of the table can be build. \\n2. To build from row 0 to all the other rows, we would have to go top ( row 0 ) to bottom. Do this for every column, like it was done in TABLE 1\\n\\nThe last column in the table shows the example, which follows the following rule \\n\\nrow0 - represents the cumulative array , lets call it cArr\\n\\nval(i,j) = cArr(j) - cArr(i)\\n\\nThats it, this means, that there is no need to build a n*n array if we know the cumulative Array \\n\\nNow the code is easy \\n\\n```\\npublic class NumArray {\\nint[] nums;\\n\\npublic NumArray(int[] nums) {\\n    for(int i = 1; i < nums.length; i++)\\n        nums[i] += nums[i - 1];\\n    \\n    this.nums = nums;\\n}\\n\\npublic int sumRange(int i, int j) {\\n    if(i == 0)\\n        return nums[j];\\n    \\n    return nums[j] - nums[i - 1];\\n}\\n}\\n```\\n\\nI have seen a lot of people post a similar solution for this problem, and they look like geniuses. I spend about 4 hours on this problem from start to finish. Thats a long time and with this article I want to say that, it does take time, initially. So if you are seeing this problem or similar problems and its taking you time to come up with a solution, its ok. Take you time, because with that time, your wirings in the brain are also changing and that change is slow and long process. \\nSecond point I want to make is that, when solving problems like these, expand the problem, even if expansion of the problem is using extra space along with additional time. So expansion of a problem is causing both Time And Space complexity to increase. ... And thats Ok, because with the expansion of the problem, you will discover new things , and you can build on top of those new things a optimal solution. This type of thinking process goes a long way during interviews. \\nImagine if  you got this problem during Google interview. If you start by expanding the problem ... which atleast solves the problem and then you optimize it. I say, you are hired.",
                "solutionTags": [],
                "code": "```\\n\\n    private int[][] ints;\\n    public NumArray(int[] nums) {\\n        ints = new int[nums.length][nums.length];\\n        populate(nums);\\n    }\\n\\n    private void populate(int[] nums){\\n        for (int i=0; i < nums.length; i++){\\n            ints[i][i] = nums[i];\\n\\n            for (int j= i-1; j >=0; j--){\\n                ints[j][i] = ints[j][i-1] + ints[i][i];\\n            }\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        \\n        return ints[i][j];\\n    }\\n```\n```\\npublic class NumArray {\\nint[] nums;\\n\\npublic NumArray(int[] nums) {\\n    for(int i = 1; i < nums.length; i++)\\n        nums[i] += nums[i - 1];\\n    \\n    this.nums = nums;\\n}\\n\\npublic int sumRange(int i, int j) {\\n    if(i == 0)\\n        return nums[j];\\n    \\n    return nums[j] - nums[i - 1];\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75303,
                "title": "c-o-1-queries-just-2-extra-lines-of-code",
                "content": "    class NumArray {\\n    public:\\n        NumArray(vector<int> &nums) : psum(nums.size()+1, 0) {\\n            partial_sum( nums.begin(), nums.end(), psum.begin()+1);\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return psum[j+1] - psum[i];\\n        }\\n    private:\\n        vector<int> psum;    \\n    };",
                "solutionTags": [],
                "code": "    class NumArray {\\n    public:\\n        NumArray(vector<int> &nums) : psum(nums.size()+1, 0) {\\n            partial_sum( nums.begin(), nums.end(), psum.begin()+1);\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return psum[j+1] - psum[i];\\n        }\\n    private:\\n        vector<int> psum;    \\n    };",
                "codeTag": "Java"
            },
            {
                "id": 75200,
                "title": "a-very-short-python-solution",
                "content": "    class NumArray(object):\\n        def __init__(self, nums):\\n            self.dp = nums\\n            for i in xrange(1, len(nums)):\\n                self.dp[i] += self.dp[i-1]\\n    \\n        def sumRange(self, i, j):\\n            return self.dp[j] - (self.dp[i-1] if i > 0 else 0)",
                "solutionTags": [],
                "code": "    class NumArray(object):\\n        def __init__(self, nums):\\n            self.dp = nums\\n            for i in xrange(1, len(nums)):\\n                self.dp[i] += self.dp[i-1]\\n    \\n        def sumRange(self, i, j):\\n            return self.dp[j] - (self.dp[i-1] if i > 0 else 0)",
                "codeTag": "Java"
            },
            {
                "id": 597654,
                "title": "easy-to-understand-faster-simple-python-solution",
                "content": "```\\n    def __init__(self, nums: List[int]):\\n        self.sum = []\\n        sum_till = 0\\n        for i in nums:\\n            sum_till += i\\n            self.sum.append(sum_till)\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        if i > 0 and j > 0:\\n            return self.sum[j] - self.sum[i - 1]\\n        else:\\n            return self.sum[i or j]\\n        \\n\\n```\\n\\n**I hope that you\\'ve found the solution useful.**\\n*In that case, please do upvote and encourage me to on my quest to document all leetcode problems\\uD83D\\uDE03*\\nPS: Search for **mrmagician** tag in the discussion, if I have solved it, You will find it there\\uD83D\\uDE38",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n    def __init__(self, nums: List[int]):\\n        self.sum = []\\n        sum_till = 0\\n        for i in nums:\\n            sum_till += i\\n            self.sum.append(sum_till)\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        if i > 0 and j > 0:\\n            return self.sum[j] - self.sum[i - 1]\\n        else:\\n            return self.sum[i or j]\\n        \\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1406509,
                "title": "range-sum-query-immutable-prefix-sum-c-python-java",
                "content": "**SOLUTION**\\n`In C++`\\n```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n        for (int i = 1; i < nums.size(); i++)\\n            vec[i] = nums[i] + vec[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if (i == 0) return vec[j];\\n        return vec[j] - vec[i-1];\\n    }\\nprivate:\\n    vector<int> vec;\\n};\\n```\\n`In Python3`\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.preSum = nums\\n        for i in range(len(nums)-1):\\n            self.preSum[i+1] += self.preSum[i]\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left == 0: return self.preSum[right]\\n        return self.preSum[right] - self.preSum[left-1]\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```\\n`In JAVA`\\n```\\nclass NumArray {\\n    int[] sum ;\\n    public NumArray(int[] nums) {\\n        sum = new int[nums.length];\\n        sum[0]=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            sum[i]=sum[i-1]+nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        if(left==0)\\n            return sum[right];\\n        return sum[right]-sum[left-1];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```\\n**Complexity**\\n* Time:\\n\\t* Constructor: O(N) \\n\\t* sumRange(left, right): O(1)\\n* Space: O(1)\\n",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n        for (int i = 1; i < nums.size(); i++)\\n            vec[i] = nums[i] + vec[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if (i == 0) return vec[j];\\n        return vec[j] - vec[i-1];\\n    }\\nprivate:\\n    vector<int> vec;\\n};\\n```\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.preSum = nums\\n        for i in range(len(nums)-1):\\n            self.preSum[i+1] += self.preSum[i]\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left == 0: return self.preSum[right]\\n        return self.preSum[right] - self.preSum[left-1]\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```\n```\\nclass NumArray {\\n    int[] sum ;\\n    public NumArray(int[] nums) {\\n        sum = new int[nums.length];\\n        sum[0]=nums[0];\\n        for(int i=1;i<nums.length;i++) {\\n            sum[i]=sum[i-1]+nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        if(left==0)\\n            return sum[right];\\n        return sum[right]-sum[left-1];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406464,
                "title": "python-accumulate-oneliner-explained",
                "content": "In this problem we are given tha our nums are immutable, that is we do not need to support operation for changing them. So, what we need to do is to precalculate some information, such that we can quickly compute sums in range. This information is cumulative sums: if we calculate all of them we can compute sum in any range as difference of two cumulative sums.\\n\\n#### Complexity\\nIt is just `O(n)` for time and space for initialization and `O(1)` time and space for query.\\n\\n#### Code\\n```python\\nclass NumArray:\\n    def __init__(self, nums):\\n        self.arr = [0] + list(accumulate(nums))\\n        \\n    def sumRange(self, left, right):\\n        return self.arr[right + 1] - self.arr[left]\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [],
                "code": "```python\\nclass NumArray:\\n    def __init__(self, nums):\\n        self.arr = [0] + list(accumulate(nums))\\n        \\n    def sumRange(self, left, right):\\n        return self.arr[right + 1] - self.arr[left]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1494994,
                "title": "java-tc-init-o-n-sumrange-o-1-using-prefix-sum",
                "content": "```java\\n/**\\n * Using a prefix sum array\\n *\\n * prefixSum[i] = prefixSum[i-1] + nums[i-1]. Length of prefixSum array is 1 +\\n * length of input array.\\n *\\n * sumRange(1,3) = prefixSum[3+1] - prefixSum[1]\\n *\\n * Time Complexity: NumArray() -> O(N). sumRange() -> O(1)\\n *\\n * Space Complexity: O(N) (Can be O(1) if allowed to modify nums array)\\n *\\n * N = Length of input array.\\n */\\nclass NumArray {\\n\\n    int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        prefixSum = new int[nums.length + 1];\\n\\n        for (int i = 1; i <= nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left < 0 || right >= prefixSum.length - 1) {\\n            throw new IndexOutOfBoundsException(\"Input indices are out of bounds\");\\n        }\\n\\n        // Here both left and right are inclusive.\\n        // right maps to right+1 in prefixSum. left maps to left+1 in prefixSum.\\n        // To get the result subtract the prefixSum before left index from prefixSum at\\n        // right index.\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```java\\n/**\\n * Using a prefix sum array\\n *\\n * prefixSum[i] = prefixSum[i-1] + nums[i-1]. Length of prefixSum array is 1 +\\n * length of input array.\\n *\\n * sumRange(1,3) = prefixSum[3+1] - prefixSum[1]\\n *\\n * Time Complexity: NumArray() -> O(N). sumRange() -> O(1)\\n *\\n * Space Complexity: O(N) (Can be O(1) if allowed to modify nums array)\\n *\\n * N = Length of input array.\\n */\\nclass NumArray {\\n\\n    int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        prefixSum = new int[nums.length + 1];\\n\\n        for (int i = 1; i <= nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left < 0 || right >= prefixSum.length - 1) {\\n            throw new IndexOutOfBoundsException(\"Input indices are out of bounds\");\\n        }\\n\\n        // Here both left and right are inclusive.\\n        // right maps to right+1 in prefixSum. left maps to left+1 in prefixSum.\\n        // To get the result subtract the prefixSum before left index from prefixSum at\\n        // right index.\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75190,
                "title": "my-java-3ms-solution",
                "content": "    public class NumArray {\\n        private int[] sums;\\n    \\n        public NumArray(int[] nums) {\\n            if(nums.length != 0){\\n                sums = new int[nums.length];\\n            \\n                sums[0] = nums[0];\\n                for(int i=1; i<nums.length; i++){\\n                    sums[i] = nums[i] + sums[i-1];\\n                }\\n            }\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            return i==0 ? sums[j] : sums[j]-sums[i-1];\\n        }\\n    }",
                "solutionTags": [],
                "code": "    public class NumArray {\\n        private int[] sums;\\n    \\n        public NumArray(int[] nums) {\\n            if(nums.length != 0){\\n                sums = new int[nums.length];\\n            \\n                sums[0] = nums[0];\\n                for(int i=1; i<nums.length; i++){\\n                    sums[i] = nums[i] + sums[i-1];\\n                }\\n            }\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            return i==0 ? sums[j] : sums[j]-sums[i-1];\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 75308,
                "title": "javascript-solution",
                "content": "    function NumArray(nums) {\\n      this.sums = [];\\n      var sum = 0;\\n      for (var i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        this.sums.push(sum);\\n      }\\n    }\\n    \\n    NumArray.prototype.sumRange = function(i, j) {\\n      return this.sums[j] - (i > 0 ? this.sums[i - 1] : 0);\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function NumArray(nums) {\\n      this.sums = [];\\n      var sum = 0;\\n      for (var i = 0; i < nums.length; i++) {\\n        sum += nums[i];\\n        this.sums.push(sum);\\n      }\\n    }\\n    \\n    NumArray.prototype.sumRange = function(i, j) {\\n      return this.sums[j] - (i > 0 ? this.sums[i - 1] : 0);\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 75278,
                "title": "my-3ms-clean-java-dp-solution-may-help-u",
                "content": "    public class NumArray {\\n        \\n        private static int[] sum;\\n    \\n    \\tpublic NumArray(int[] nums) {\\n    \\t\\tfor (int i = 1; i < nums.length; ++i)\\n    \\t\\t\\tnums[i] += nums[i - 1];\\n    \\t\\tthis.sum = nums;\\n    \\t}\\n    \\n    \\tpublic int sumRange(int i, int j) {\\n    \\t\\treturn sum[j] - (i == 0 ? 0 : sum[i - 1]);\\n    \\t}\\n    }",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "    public class NumArray {\\n        \\n        private static int[] sum;\\n    \\n    \\tpublic NumArray(int[] nums) {\\n    \\t\\tfor (int i = 1; i < nums.length; ++i)\\n    \\t\\t\\tnums[i] += nums[i - 1];\\n    \\t\\tthis.sum = nums;\\n    \\t}\\n    \\n    \\tpublic int sumRange(int i, int j) {\\n    \\t\\treturn sum[j] - (i == 0 ? 0 : sum[i - 1]);\\n    \\t}\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 75314,
                "title": "solutions-using-binary-indexed-tree-and-segment-tree",
                "content": " Binary Indexed Tree, O(lgn) modify, O(lgn) query\\n\\n    public class NumArray {\\n        \\n        int[] tree;\\n        \\n        public NumArray(int[] nums) {\\n            tree = new int[nums.length + 1];\\n            for (int i = 0; i < nums.length; i++) {\\n                int j = i + 1;\\n                while (j < nums.length + 1) {\\n                    tree[j] += nums[i];\\n                    j += lowBit(j);\\n                }\\n            }\\n        }\\n        \\n        public int sumRange(int i, int j) {\\n            return getSum(j + 1) - getSum(i);\\n        }\\n        \\n        private int getSum(int i) {\\n            int sum = 0;\\n            while (i > 0) {\\n                sum += tree[i];\\n                i -= lowBit(i);\\n            }\\n            return sum;\\n        }\\n        \\n        private int lowBit(int x) {\\n            return x&(-x);\\n        }\\n    }\\n\\n\\nSegment Tree, O(n) build, O(lgn) modify, O(lgn) query\\n\\n    public class NumArray {\\n    \\n        SegmentTreeNode root;\\n        public NumArray(int[] nums) {\\n            if (nums.length == 0) return;\\n            root = buildTree(nums, 0, nums.length - 1);\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            return query(root, i, j);\\n        }\\n        \\n        private int query(SegmentTreeNode node, int start, int end) {\\n            int mid = node.start + ((node.end - node.start) >> 1);\\n            if (start <= node.start && end >= node.end) {\\n                return node.sum;\\n            } else if (end <= mid) {\\n                return query(node.left, start, end);\\n            } else if (start > mid) {\\n                return query(node.right, start, end);\\n            } else if (start <= mid && end > mid) {\\n                return query(node.left, start, mid) + query(node.right, mid + 1, end);\\n            }\\n            return 0;\\n        }\\n        \\n        private SegmentTreeNode buildTree(int[] nums, int l, int r) {\\n            if (l == r) {\\n                return new SegmentTreeNode(l, r, nums[l]);\\n            }\\n            int mid = l + ((r - l) >> 1);\\n            SegmentTreeNode leftNode = buildTree(nums, l, mid);\\n            SegmentTreeNode rightNode = buildTree(nums, mid + 1, r);\\n            SegmentTreeNode node = new SegmentTreeNode(l, r, leftNode.sum + rightNode.sum);\\n            node.left = leftNode;\\n            node.right = rightNode;\\n            return node;\\n        }\\n        \\n        class SegmentTreeNode {\\n            int start, end, sum;\\n            SegmentTreeNode left, right;\\n            public SegmentTreeNode(int s, int e, int val) {\\n                start = s;\\n                end = e;\\n                sum = val;\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": " Binary Indexed Tree, O(lgn) modify, O(lgn) query\\n\\n    public class NumArray {\\n        \\n        int[] tree;\\n        \\n        public NumArray(int[] nums) {\\n            tree = new int[nums.length + 1];\\n            for (int i = 0; i < nums.length; i++) {\\n                int j = i + 1;\\n                while (j < nums.length + 1) {\\n                    tree[j] += nums[i];\\n                    j += lowBit(j);\\n                }\\n            }\\n        }\\n        \\n        public int sumRange(int i, int j) {\\n            return getSum(j + 1) - getSum(i);\\n        }\\n        \\n        private int getSum(int i) {\\n            int sum = 0;\\n            while (i > 0) {\\n                sum += tree[i];\\n                i -= lowBit(i);\\n            }\\n            return sum;\\n        }\\n        \\n        private int lowBit(int x) {\\n            return x&(-x);\\n        }\\n    }\\n\\n\\nSegment Tree, O(n) build, O(lgn) modify, O(lgn) query\\n\\n    public class NumArray {\\n    \\n        SegmentTreeNode root;\\n        public NumArray(int[] nums) {\\n            if (nums.length == 0) return;\\n            root = buildTree(nums, 0, nums.length - 1);\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            return query(root, i, j);\\n        }\\n        \\n        private int query(SegmentTreeNode node, int start, int end) {\\n            int mid = node.start + ((node.end - node.start) >> 1);\\n            if (start <= node.start && end >= node.end) {\\n                return node.sum;\\n            } else if (end <= mid) {\\n                return query(node.left, start, end);\\n            } else if (start > mid) {\\n                return query(node.right, start, end);\\n            } else if (start <= mid && end > mid) {\\n                return query(node.left, start, mid) + query(node.right, mid + 1, end);\\n            }\\n            return 0;\\n        }\\n        \\n        private SegmentTreeNode buildTree(int[] nums, int l, int r) {\\n            if (l == r) {\\n                return new SegmentTreeNode(l, r, nums[l]);\\n            }\\n            int mid = l + ((r - l) >> 1);\\n            SegmentTreeNode leftNode = buildTree(nums, l, mid);\\n            SegmentTreeNode rightNode = buildTree(nums, mid + 1, r);\\n            SegmentTreeNode node = new SegmentTreeNode(l, r, leftNode.sum + rightNode.sum);\\n            node.left = leftNode;\\n            node.right = rightNode;\\n            return node;\\n        }\\n        \\n        class SegmentTreeNode {\\n            int start, end, sum;\\n            SegmentTreeNode left, right;\\n            public SegmentTreeNode(int s, int e, int val) {\\n                start = s;\\n                end = e;\\n                sum = val;\\n            }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1406518,
                "title": "c-easy-clean-solution-using-prefix-sums",
                "content": "**Solution:**\\n\\nApproach\\n1. First calculate prefix sums array for the given array `nums`.\\n2. Now, your task is to find sum of elements from `left to right`.\\n3. If `left == 0`, means we need to directly return sum at the index `pref[right]`.\\n4. Otherwise, just return the difference of sums at `pref[right] - pref[left - 1]`.\\n\\nExample:\\n`ar = [-2, 0, 3, -5, 2, -1]`\\n`range = [0, 2], [2, 5]`\\n\\n`Prefix Sums Array = [-2,-2,1,-4,-2,-3]`\\n\\n`Output:`\\nFor query 1, `left == 0`, return prefix sum at index right. `Print pref[2] = 1`\\nFor query 2, `left != 0`, return pref[right] - pref[left - 1]. `Print pref[5] - pref[1] = -1`\\n\\n```\\nclass NumArray {\\npublic:\\n    vector<int> pref;\\n    NumArray(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\tpref.clear();\\n        for(int i = 0; i < n; i++){\\n            if(i == 0)\\n                pref.push_back(nums[i]);\\n            else\\n                pref.push_back(nums[i] + pref[i - 1]);\\n        }\\n    }  \\n    int sumRange(int left, int right) {\\n        if(left == 0)\\n            return pref[right];\\n        return pref[right] - pref[left - 1]; \\n    }\\n};\\n```\\n\\n**Feel free to share your ideas or any improvements as well.**",
                "solutionTags": [
                    "C",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> pref;\\n    NumArray(vector<int>& nums) {\\n        int n = nums.size();\\n\\t\\tpref.clear();\\n        for(int i = 0; i < n; i++){\\n            if(i == 0)\\n                pref.push_back(nums[i]);\\n            else\\n                pref.push_back(nums[i] + pref[i - 1]);\\n        }\\n    }  \\n    int sumRange(int left, int right) {\\n        if(left == 0)\\n            return pref[right];\\n        return pref[right] - pref[left - 1]; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75315,
                "title": "c-simple-solution-o-n-to-build-o-1-to-query",
                "content": "Use a vector to store the sum from 0 to i.\\n\\n    class NumArray {\\n    public:\\n        vector<int> memo = {0};\\n        NumArray(vector<int> &nums) {\\n            int summ = 0;\\n            for (int n : nums) {\\n                summ += n;\\n                memo.push_back(summ);\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return memo[j+1] - memo[i];\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "Use a vector to store the sum from 0 to i.\\n\\n    class NumArray {\\n    public:\\n        vector<int> memo = {0};\\n        NumArray(vector<int> &nums) {\\n            int summ = 0;\\n            for (int n : nums) {\\n                summ += n;\\n                memo.push_back(summ);\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return memo[j+1] - memo[i];\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 75309,
                "title": "java-solution-using-sum-array-built-in-constructor",
                "content": "    public class NumArray {\\n        int[] sum;\\n        public NumArray(int[] nums) {\\n            sum = new int[nums.length];\\n            if(nums.length>0)sum[0]=nums[0];\\n            for(int i=1; i<nums.length; i++){\\n                sum[i]=sum[i-1]+nums[i];\\n            }\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            if(i==0)return sum[j];\\n            return sum[j]-sum[i-1];\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public class NumArray {\\n        int[] sum;\\n        public NumArray(int[] nums) {\\n            sum = new int[nums.length];\\n            if(nums.length>0)sum[0]=nums[0];\\n            for(int i=1; i<nums.length; i++){\\n                sum[i]=sum[i-1]+nums[i];\\n            }\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            if(i==0)return sum[j];\\n            return sum[j]-sum[i-1];\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2381014,
                "title": "short-and-simple-javascript-solution",
                "content": "Found this solution helpful? Consider showing support by upvoting this post.\\nHave a question? Kindly leave a comment below.\\nThank you and happy hacking!\\n```\\nvar NumArray = function(nums) {\\n    this.nums = nums;\\n};\\n\\nNumArray.prototype.sumRange = function(left, right) {\\n    let sum = 0;\\n    for(let i = left; i <= right; i++) sum += this.nums[i]\\n    return sum\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar NumArray = function(nums) {\\n    this.nums = nums;\\n};\\n\\nNumArray.prototype.sumRange = function(left, right) {\\n    let sum = 0;\\n    for(let i = left; i <= right; i++) sum += this.nums[i]\\n    return sum\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 511735,
                "title": "python-js-go-c-by-prefix-sum-with-explanation",
                "content": "Python sol. with O(n) init, O(1) query by prefix sum. \\n\\n[\\u4E2D\\u6587\\u89E3\\u984C\\u6587\\u7AE0](https://vocus.cc/article/6511745dfd89780001d072c3)\\n\\n[\\u4E2D\\u6587\\u89E3\\u984C\\u5F71\\u7247\\nTutorial video in Chinese](https://youtu.be/HHFnsTqE2sA)\\n\\n---\\n\\nHint:\\n#1.\\nThink of the concept of dynamic programming, and **look-up table**.\\n\\n#2.\\nSince **input array**, *nums*, is **immutable**, we can build a **prefix sum table** to **speed up range sum query** later.\\n\\n---\\n\\nRecurrence relationship:\\nLet *S* denotes the **prefix sum table**\\n*S*[ *0* ] = *nums*[ *0* ]\\n*S*[ *i* ] = *S*[ *i - 1* ] + *nums*[ *i* ] for every *i* = 1, 2, 3, ..., n\\n\\nRange sum Query:\\nQuery( *i*, *j* ) = *S*[ *j* ], if *i* =0\\nQuery( *i*, *j* ) = *S*[ *j* ] - *S*[ *i* -1 ], otherwise.\\n\\n---\\n\\nAlgorithm:\\n\\nStep_#1:\\nBuild the prefix sum table based on recurrence relationship, during initialization in O(n).\\n\\nStep_#2:\\nHandle incoming range sum query by index lookup in prefix sum table, in O(1).\\n\\n---\\n\\n\\n```Python []\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        \\n        self.size = len(nums)\\n        \\n\\n        # build prefix sum table when input nums is valid\\n        self.s = [ 0 for _ in range(self.size) ]\\n\\n        self.s[0] = nums[0]\\n\\n        # s[k] = nums[0] + ... + nums[k]\\n        # s[k] = s[k-1] + nums[k]\\n        for k in range(1,self.size):\\n            self.s[k] = self.s[ k-1 ] + nums[ k ]\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        \\n\\n        # lookup table from prefix sum table, s\\n        if left == 0:\\n            return self.s[ right ]\\n        else:\\n            return self.s[ right ]-self.s[ left-1 ]\\n```\\n```Javascript []\\nvar NumArray = function(nums) {\\n    \\n    this.size = nums.length;\\n    this.prefixSum = Array( nums.legnth ).fill( 0 );\\n    \\n    this.prefixSum[0] = nums[0];\\n    \\n    for( let i = 1; i < this.size ; i++ ){\\n        this.prefixSum[i] = this.prefixSum[i-1] + nums[i];\\n    }\\n    \\n    \\n};\\n\\n/** \\n * @param {number} left \\n * @param {number} right\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function(left, right) {\\n    \\n    // lookup table from prefixSum\\n    if( left == 0 ){\\n        return this.prefixSum[right];\\n    }else{\\n        return this.prefixSum[right] - this.prefixSum[left-1];\\n    }\\n    \\n    \\n};\\n```\\n```Go []\\ntype NumArray struct {\\n    size int;\\n    prefixTable []int;\\n}\\n\\n\\nfunc Constructor(nums []int) NumArray {\\n    \\n    numArray := new(NumArray)\\n    \\n    numArray.size = len(nums)\\n    \\n    // build prefix sum table\\n    numArray.prefixTable = make( []int, len(nums) )\\n    \\n    numArray.prefixTable[0] = nums[0]\\n    \\n    for k := 1 ; k < numArray.size ; k++{\\n        numArray.prefixTable[k] = numArray.prefixTable[k-1] + nums[k]\\n    }\\n    \\n    return *numArray\\n}\\n\\n\\nfunc (this *NumArray) SumRange(left int, right int) int {\\n    \\n    if left == 0 {\\n        return this.prefixTable[right]\\n    }else{\\n        return this.prefixTable[right] - this.prefixTable[left-1]\\n    }\\n    \\n}\\n```\\n```C++ []\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        \\n        size = nums.size();\\n        \\n        // build prefix sum table \\n        prefixSum = vector<int>(size, 0);\\n\\n        prefixSum[0] = nums[0];\\n\\n        for( int k = 1; k < size ; k++){\\n            prefixSum[k] = prefixSum[k-1] + nums[k];\\n        }\\n\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        \\n        // lookup table from prefixSum\\n        if( left == 0 ){\\n            return prefixSum[right];\\n        \\n        }else{\\n            return prefixSum[right] - prefixSum[left-1];    \\n        }\\n        \\n    }\\nprivate:\\n    int size;\\n    vector<int> prefixSum;\\n};\\n```\\n\\n---\\n\\nComplexity analysis:\\n\\nTime complexity: O(n)\\nO(n) : building of prefix sum table, s.\\n\\nO(1) : each single range sum query.\\n\\n---\\n\\nSpace complexity: O(n)\\n\\nO(n) : size of prefix sum table, s.\\n\\n\\n---\\n\\nReference:\\n\\n[1] [OpenGenius: Prefix sum array](https://iq.opengenus.org/prefix-sum-array/)\\n\\n---\\n\\nRelated leetcode challenge:\\n\\n[Leetcode #304 Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/)\\n\\n[Leetcode #1352 Product of the Last K Numbers](https://leetcode.com/problems/product-of-the-last-k-numbers/)",
                "solutionTags": [
                    "C++",
                    "Python",
                    "C",
                    "JavaScript",
                    "Go",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```Python []\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        \\n        self.size = len(nums)\\n        \\n\\n        # build prefix sum table when input nums is valid\\n        self.s = [ 0 for _ in range(self.size) ]\\n\\n        self.s[0] = nums[0]\\n\\n        # s[k] = nums[0] + ... + nums[k]\\n        # s[k] = s[k-1] + nums[k]\\n        for k in range(1,self.size):\\n            self.s[k] = self.s[ k-1 ] + nums[ k ]\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        \\n\\n        # lookup table from prefix sum table, s\\n        if left == 0:\\n            return self.s[ right ]\\n        else:\\n            return self.s[ right ]-self.s[ left-1 ]\\n```\n```Javascript []\\nvar NumArray = function(nums) {\\n    \\n    this.size = nums.length;\\n    this.prefixSum = Array( nums.legnth ).fill( 0 );\\n    \\n    this.prefixSum[0] = nums[0];\\n    \\n    for( let i = 1; i < this.size ; i++ ){\\n        this.prefixSum[i] = this.prefixSum[i-1] + nums[i];\\n    }\\n    \\n    \\n};\\n\\n/** \\n * @param {number} left \\n * @param {number} right\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function(left, right) {\\n    \\n    // lookup table from prefixSum\\n    if( left == 0 ){\\n        return this.prefixSum[right];\\n    }else{\\n        return this.prefixSum[right] - this.prefixSum[left-1];\\n    }\\n    \\n    \\n};\\n```\n```Go []\\ntype NumArray struct {\\n    size int;\\n    prefixTable []int;\\n}\\n\\n\\nfunc Constructor(nums []int) NumArray {\\n    \\n    numArray := new(NumArray)\\n    \\n    numArray.size = len(nums)\\n    \\n    // build prefix sum table\\n    numArray.prefixTable = make( []int, len(nums) )\\n    \\n    numArray.prefixTable[0] = nums[0]\\n    \\n    for k := 1 ; k < numArray.size ; k++{\\n        numArray.prefixTable[k] = numArray.prefixTable[k-1] + nums[k]\\n    }\\n    \\n    return *numArray\\n}\\n\\n\\nfunc (this *NumArray) SumRange(left int, right int) int {\\n    \\n    if left == 0 {\\n        return this.prefixTable[right]\\n    }else{\\n        return this.prefixTable[right] - this.prefixTable[left-1]\\n    }\\n    \\n}\\n```\n```C++ []\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        \\n        size = nums.size();\\n        \\n        // build prefix sum table \\n        prefixSum = vector<int>(size, 0);\\n\\n        prefixSum[0] = nums[0];\\n\\n        for( int k = 1; k < size ; k++){\\n            prefixSum[k] = prefixSum[k-1] + nums[k];\\n        }\\n\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        \\n        // lookup table from prefixSum\\n        if( left == 0 ){\\n            return prefixSum[right];\\n        \\n        }else{\\n            return prefixSum[right] - prefixSum[left-1];    \\n        }\\n        \\n    }\\nprivate:\\n    int size;\\n    vector<int> prefixSum;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75265,
                "title": "java-concise-solution-without-if",
                "content": "    public class NumArray {\\n\\t\\n\\tint[] table;\\n\\n    public NumArray(int[] nums) {\\n        int sum = 0;\\n        table = new int[nums.length + 1];\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n        \\tsum = sum + nums[i];\\n        \\ttable[i + 1] = sum;\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        return table[j + 1] - table[i];\\n    }\\n    }",
                "solutionTags": [],
                "code": "    public class NumArray {\\n\\t\\n\\tint[] table;\\n\\n    public NumArray(int[] nums) {\\n        int sum = 0;\\n        table = new int[nums.length + 1];\\n        for(int i = 0; i < nums.length; i++)\\n        {\\n        \\tsum = sum + nums[i];\\n        \\ttable[i + 1] = sum;\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        return table[j + 1] - table[i];\\n    }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3398350,
                "title": "range-sum-query-immutable-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass NumArray {\\npublic:\\n    vector<int> arr;\\n    NumArray(vector<int>& nums) {\\n        arr.push_back(nums[0]);\\n        for(int i=1 ; i<nums.size() ; i++)\\n        {\\n            arr.push_back(nums[i]+arr[i-1]);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0)\\n            return arr[right];\\n        else\\n            return arr[right]-arr[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/792a2ee3-fa92-4936-9a87-216cd9a9ac02_1682613207.1269994.jpeg)",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> arr;\\n    NumArray(vector<int>& nums) {\\n        arr.push_back(nums[0]);\\n        for(int i=1 ; i<nums.size() ; i++)\\n        {\\n            arr.push_back(nums[i]+arr[i-1]);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0)\\n            return arr[right];\\n        else\\n            return arr[right]-arr[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406906,
                "title": "easy-c-solution-prefix-sum",
                "content": "```\\nclass NumArray {\\npublic:\\n    vector<int> a;\\n    NumArray(vector<int>& nums) {\\n        for(int i = 0;i < (int)nums.size(); i++){\\n            if(i==0)a.push_back(nums[i]);\\n            else a.push_back(nums[i]+a.back());\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int v = a[right];\\n        if(left == 0)return v;\\n        return v-a[left-1];\\n        \\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```\\n**Questions/ Discussions are welcome.**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> a;\\n    NumArray(vector<int>& nums) {\\n        for(int i = 0;i < (int)nums.size(); i++){\\n            if(i==0)a.push_back(nums[i]);\\n            else a.push_back(nums[i]+a.back());\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int v = a[right];\\n        if(left == 0)return v;\\n        return v-a[left-1];\\n        \\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187825,
                "title": "python-4-liner",
                "content": "```\\nclass NumArray:\\n\\n    def __init__(self, nums):\\n        self.nums = nums\\n        for i in range(1, len(nums)):\\n            self.nums[i] += self.nums[i - 1]\\n        \\n\\n    def sumRange(self, i, j):\\n        return self.nums[j] - self.nums[i - 1] if i else self.nums[j]\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums):\\n        self.nums = nums\\n        for i in range(1, len(nums)):\\n            self.nums[i] += self.nums[i - 1]\\n        \\n\\n    def sumRange(self, i, j):\\n        return self.nums[j] - self.nums[i - 1] if i else self.nums[j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75258,
                "title": "beat-100-c-solution",
                "content": "\\n\\nclass NumArray {\\n\\n    private:\\n    vector<int> data;\\npublic:\\n    \\n    NumArray(vector<int> &nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            data.push_back(sum);\\n        }\\n    }\\n\\n    int sumRange(int i, int j) {\\n        if(i==0)\\n            return data[j];\\n        else\\n            return data[j]-data[i-1];\\n    }\\n};\\n\\n\\n// Your NumArray object will be instantiated and called as such:\\n// NumArray numArray(nums);\\n// numArray.sumRange(0, 1);\\n// numArray.sumRange(1, 2);",
                "solutionTags": [],
                "code": "\\n\\nclass NumArray {\\n\\n    private:\\n    vector<int> data;\\npublic:\\n    \\n    NumArray(vector<int> &nums) {\\n        int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            data.push_back(sum);\\n        }\\n    }\\n\\n    int sumRange(int i, int j) {\\n        if(i==0)\\n            return data[j];\\n        else\\n            return data[j]-data[i-1];\\n    }\\n};\\n\\n\\n// Your NumArray object will be instantiated and called as such:\\n// NumArray numArray(nums);\\n// numArray.sumRange(0, 1);\\n// numArray.sumRange(1, 2);",
                "codeTag": "Java"
            },
            {
                "id": 75266,
                "title": "simple-python-solution-use-dict",
                "content": "    class NumArray(object):\\n        def __init__(self, nums):\\n            \"\"\"\\n            initialize your data structure here.\\n            :type nums: List[int]\\n            \"\"\"\\n            self.dc = {-1:0}\\n            for i,v in enumerate(nums):\\n                self.dc[i] = self.dc[i-1] + v\\n    \\n        def sumRange(self, i, j):\\n            \"\"\"\\n            sum of elements nums[i..j], inclusive.\\n            :type i: int\\n            :type j: int\\n            :rtype: int\\n            \"\"\"\\n            return self.dc[j]-self.dc[i-1]",
                "solutionTags": [],
                "code": "    class NumArray(object):\\n        def __init__(self, nums):\\n            \"\"\"\\n            initialize your data structure here.\\n            :type nums: List[int]\\n            \"\"\"\\n            self.dc = {-1:0}\\n            for i,v in enumerate(nums):\\n                self.dc[i] = self.dc[i-1] + v\\n    \\n        def sumRange(self, i, j):\\n            \"\"\"\\n            sum of elements nums[i..j], inclusive.\\n            :type i: int\\n            :type j: int\\n            :rtype: int\\n            \"\"\"\\n            return self.dc[j]-self.dc[i-1]",
                "codeTag": "Java"
            },
            {
                "id": 2129952,
                "title": "0ms-1liner-100-fastest-solution-explained-o-n-time-complexity-o-n-space-complexity",
                "content": "(Note: This is part of a series of Leetcode solution explanations. If you like this solution or find it useful, ***please upvote*** this post.)\\n***Take care brother, peace, love!***\\n\\n```\\n```\\n\\nThe best result for the code below is ***0ms / 38.2MB*** (beats 92.04% / 24.00%).\\n* *** Java ***\\n\\n```\\n\\n/**\\n * Using a prefix sum array\\n *\\n * prefixSum[i] = prefixSum[i-1] + nums[i-1]. Length of prefixSum array is 1 +\\n * length of input array.\\n *\\n * sumRange(1,3) = prefixSum[3+1] - prefixSum[1]\\n *\\n * Time Complexity: NumArray() -> O(N). sumRange() -> O(1)\\n *\\n * Space Complexity: O(N) (Can be O(1) if allowed to modify nums array)\\n *\\n * N = Length of input array.\\n */\\nclass NumArray {\\n\\n    int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        prefixSum = new int[nums.length + 1];\\n\\n        for (int i = 1; i <= nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left < 0 || right >= prefixSum.length - 1) {\\n            throw new IndexOutOfBoundsException(\"Input indices are out of bounds\");\\n        }\\n\\n        // Here both left and right are inclusive.\\n        // right maps to right+1 in prefixSum. left maps to left+1 in prefixSum.\\n        // To get the result subtract the prefixSum before left index from prefixSum at\\n        // right index.\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n}\\n\\n```\\n\\n```\\n```\\n\\n```\\n```\\n\\n***\"Open your eyes. Expect us.\" - \\uD835\\uDCD0\\uD835\\uDCF7\\uD835\\uDCF8\\uD835\\uDCF7\\uD835\\uDD02\\uD835\\uDCF6\\uD835\\uDCF8\\uD835\\uDCFE\\uD835\\uDCFC***\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "C",
                    "JavaScript",
                    "Kotlin",
                    "PHP"
                ],
                "code": "```\\n```\n```\\n\\n/**\\n * Using a prefix sum array\\n *\\n * prefixSum[i] = prefixSum[i-1] + nums[i-1]. Length of prefixSum array is 1 +\\n * length of input array.\\n *\\n * sumRange(1,3) = prefixSum[3+1] - prefixSum[1]\\n *\\n * Time Complexity: NumArray() -> O(N). sumRange() -> O(1)\\n *\\n * Space Complexity: O(N) (Can be O(1) if allowed to modify nums array)\\n *\\n * N = Length of input array.\\n */\\nclass NumArray {\\n\\n    int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        if (nums == null) {\\n            throw new IllegalArgumentException(\"Input is null\");\\n        }\\n\\n        prefixSum = new int[nums.length + 1];\\n\\n        for (int i = 1; i <= nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left < 0 || right >= prefixSum.length - 1) {\\n            throw new IndexOutOfBoundsException(\"Input indices are out of bounds\");\\n        }\\n\\n        // Here both left and right are inclusive.\\n        // right maps to right+1 in prefixSum. left maps to left+1 in prefixSum.\\n        // To get the result subtract the prefixSum before left index from prefixSum at\\n        // right index.\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n}\\n\\n```\n```\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75286,
                "title": "java-easy-version-to-understand",
                "content": "        int[] nums;\\n\\tint[] sum;\\n\\n\\tpublic NumArray(int[] nums) {\\n\\t    if(nums==null||nums.length==0)\\n\\t    return;\\n\\t\\tthis.nums = nums;\\n\\t\\tint len = nums.length;\\n\\t\\tsum = new int[len];\\n\\t\\tsum[0] = nums[0];\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tsum[i] = sum[i - 1] + nums[i];\\n\\t}\\n\\n\\tpublic int sumRange(int i, int j) {\\n\\n\\t\\treturn sum[j] - sum[i] + nums[i];\\n\\t}",
                "solutionTags": [],
                "code": "        int[] nums;\\n\\tint[] sum;\\n\\n\\tpublic NumArray(int[] nums) {\\n\\t    if(nums==null||nums.length==0)\\n\\t    return;\\n\\t\\tthis.nums = nums;\\n\\t\\tint len = nums.length;\\n\\t\\tsum = new int[len];\\n\\t\\tsum[0] = nums[0];\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tsum[i] = sum[i - 1] + nums[i];\\n\\t}\\n\\n\\tpublic int sumRange(int i, int j) {\\n\\n\\t\\treturn sum[j] - sum[i] + nums[i];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 3585378,
                "title": "easiest-c-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(1)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray {\\npublic:\\nvector<int>a;\\n    NumArray(vector<int>& nums) {\\n        a.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        a.push_back(nums[i]+a[i-1]);\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0 )\\n        return a[right];\\n        \\n        return a[right]-a[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Design",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\nvector<int>a;\\n    NumArray(vector<int>& nums) {\\n        a.push_back(nums[0]);\\n        for(int i=1;i<nums.size();i++)\\n        a.push_back(nums[i]+a[i-1]);\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0 )\\n        return a[right];\\n        \\n        return a[right]-a[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406467,
                "title": "c-simple-and-clean-explained-solution-o-1-query",
                "content": "**Idea:**\\nWe create an array to keep the accumulated sum for nums.\\nThe array looks like this: vec[i] = nums[0] + nums[1] + ... + nums[i].\\nThen, for the query [i, j], we just return vec[j] - vec[i-1].\\n**Example:**\\nnums = [-2, 0, 3, -5, 2, -1]\\nvec = [-2, -2, 1, -4, -2, -3]\\nquery = [2, 5]: (-3) - (-2) = -1\\n```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n        for (int i = 1; i < nums.size(); i++)\\n            vec[i] = nums[i] + vec[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if (i == 0) return vec[j];\\n        return vec[j] - vec[i-1];\\n    }\\nprivate:\\n    vector<int> vec;\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n        for (int i = 1; i < nums.size(); i++)\\n            vec[i] = nums[i] + vec[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if (i == 0) return vec[j];\\n        return vec[j] - vec[i-1];\\n    }\\nprivate:\\n    vector<int> vec;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1223399,
                "title": "easiest-python-solution",
                "content": "\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return sum(self.nums[left:right+1])\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return sum(self.nums[left:right+1])\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)",
                "codeTag": "Java"
            },
            {
                "id": 3439382,
                "title": "java",
                "content": "# Code\\n```\\nclass NumArray {\\n    private int[] sumArray;\\n    public NumArray(int[] nums) {\\n        sumArray = new int[nums.length + 1];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            sumArray[i + 1] = sumArray[i] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return sumArray[right + 1] - sumArray[left];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n    private int[] sumArray;\\n    public NumArray(int[] nums) {\\n        sumArray = new int[nums.length + 1];\\n\\n        for (int i = 0; i < nums.length; i++) {\\n            sumArray[i + 1] = sumArray[i] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return sumArray[right + 1] - sumArray[left];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238729,
                "title": "303-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n- We define a NumArray class with two methods: __init__ and sumRange.\\n- In __init__, we compute the prefix sums of the input nums array and store them in a prefix_sum list. We initialize the prefix_sum list with 0\\'s and then loop through nums, adding each element to the corresponding index in prefix_sum. This gives us the cumulative sum up to each index in nums. Note that we add an extra 0 to the beginning of prefix_sum to simplify the code for sumRange.\\n- In sumRange, we return the sum of the elements between left and right by subtracting the prefix sums at left and right+1. This is because prefix_sum[right+1] gives us the sum of the elements up to index right, while prefix_sum[left] gives us the sum of the elements up to index left-1. By subtracting these two values, we get the sum of the elements between left and right.\\n\\nThis solution has a time complexity of O(1) for each call to sumRange, since we only need to perform two constant-time operations: two lookups in the prefix_sum list and a subtraction. The space complexity is O(n), where n is the length of the input array, since we need to store the prefix_sum list.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_sum = [0] * (len(nums) + 1)\\n        for i in range(len(nums)):\\n            self.prefix_sum[i + 1] = self.prefix_sum[i] + nums[i]\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Design",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_sum = [0] * (len(nums) + 1)\\n        for i in range(len(nums)):\\n            self.prefix_sum[i + 1] = self.prefix_sum[i] + nums[i]\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407777,
                "title": "simple-python-approach-brute-force-prefix-sum",
                "content": "The initial idea I got after understanding the way was to brute force my way through it. This included using the array provided and returning the sum of the elements.\\n```\\nclass NumArray(object):\\n    def __init__(self, nums):\\n        self.arr=nums\\n\\n    def sumRange(self, left, right):\\n        return(sum(self.arr[left:right+1]))\\n```\\nAfter the solution passed I noticed that the execution time was really high and there must be a way to solve this question in O(1) time. A concept synonymous with addition in an array is \\' prefix sum\\' . \\n\\n The overall time complexity will be greatly reduced as only the \\'__init__\\' function will need a O(N) time complexity for creation , while the \\'sumRange\\' function being called multiple times will have O(1) time.\\n \\n Here is the implementation with comments:\\n```\\nclass NumArray(object):\\n    def __init__(self, nums):\\n        l=[nums[0]] #store first element of the array to start prefix sum\\n        for i in range(1,len(nums)):\\n            l.append(l[i-1]+nums[i]) #implement prefix sum for each element\\n        self.arr=l       \\n\\n    def sumRange(self, left, right):\\n        if(left!=0): #Apply the logic of prefix sum to get the sum of elements between and including left and right.\\n            return(self.arr[right]-self.arr[left-1]) \\n        else: #in case left is 0,the sum in the \\'right\\' position will give the total sum required\\n            return(self.arr[right])\\n```\\nDo leave an **upvote** if you found my way of thinking useful! Thank you for the reading my first post on leetcode.",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray(object):\\n    def __init__(self, nums):\\n        self.arr=nums\\n\\n    def sumRange(self, left, right):\\n        return(sum(self.arr[left:right+1]))\\n```\n```\\nclass NumArray(object):\\n    def __init__(self, nums):\\n        l=[nums[0]] #store first element of the array to start prefix sum\\n        for i in range(1,len(nums)):\\n            l.append(l[i-1]+nums[i]) #implement prefix sum for each element\\n        self.arr=l       \\n\\n    def sumRange(self, left, right):\\n        if(left!=0): #Apply the logic of prefix sum to get the sum of elements between and including left and right.\\n            return(self.arr[right]-self.arr[left-1]) \\n        else: #in case left is 0,the sum in the \\'right\\' position will give the total sum required\\n            return(self.arr[right])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1309366,
                "title": "simple-and-concise-c-solution",
                "content": "**If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.**\\n```\\nclass NumArray {\\npublic:\\n    vector<int> v;\\n    NumArray(vector<int>& nums) {\\n        int n=nums.size();\\n        v.resize(n);\\n        v[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n           v[i]=v[i-1]+nums[i]; \\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0)\\n            return v[right];\\n       \\n        else\\n             return v[right]-v[left-1];\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> v;\\n    NumArray(vector<int>& nums) {\\n        int n=nums.size();\\n        v.resize(n);\\n        v[0]=nums[0];\\n        for(int i=1;i<nums.size();i++)\\n        {\\n           v[i]=v[i-1]+nums[i]; \\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0)\\n            return v[right];\\n       \\n        else\\n             return v[right]-v[left-1];\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 989549,
                "title": "python-solution-using-prefix-sum",
                "content": "Hello guys. Hope you all are safe\\uD83D\\uDE0A\\uD83D\\uDE0A\\nRuntime: 80 ms, faster than 61.24% of Python3 online submissions for Range Sum Query - Immutable.\\nMemory Usage: 17.9 MB, less than 16.27% of Python3 online submissions for Range Sum Query - Immutable.\\n\\nSuggestions are most welcome.\\n```\\n    def __init__(self, array: List[int]):\\n        # prefix sum\\n        self.nums = array[:]  \\n        for i in range(1,len(self.nums)):\\n            self.nums[i] = self.nums[i]+self.nums[i-1]\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        if i == 0:\\n            return self.nums[j]        \\n        return(self.nums[j] - self.nums[i-1])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\n    def __init__(self, array: List[int]):\\n        # prefix sum\\n        self.nums = array[:]  \\n        for i in range(1,len(self.nums)):\\n            self.nums[i] = self.nums[i]+self.nums[i-1]\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        if i == 0:\\n            return self.nums[j]        \\n        return(self.nums[j] - self.nums[i-1])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 75284,
                "title": "my-clear-cpp-code",
                "content": "    class NumArray {\\n    public:\\n    \\n        vector<int> sums;\\n        \\n        NumArray(vector<int> &nums) \\n        {\\n            sums = vector<int>(nums.size()+1, 0);\\n            \\n            for(int i=0; i < nums.size(); i++)\\n                sums[i+1] = nums[i] + sums[i];\\n        }\\n    \\n        int sumRange(int i, int j) \\n        {\\n            if(sums.size() == 1) return sums[0];\\n            return sums[j+1] - sums[i];\\n        }\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "solutionTags": [],
                "code": "    class NumArray {\\n    public:\\n    \\n        vector<int> sums;\\n        \\n        NumArray(vector<int> &nums) \\n        {\\n            sums = vector<int>(nums.size()+1, 0);\\n            \\n            for(int i=0; i < nums.size(); i++)\\n                sums[i+1] = nums[i] + sums[i];\\n        }\\n    \\n        int sumRange(int i, int j) \\n        {\\n            if(sums.size() == 1) return sums[0];\\n            return sums[j+1] - sums[i];\\n        }\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "codeTag": "Java"
            },
            {
                "id": 75319,
                "title": "share-my-python-solution-o-n-for-init-and-o-1-for-query",
                "content": "Use an extra element for summation so we don't need to check boundary condition in the query.\\n\\n    class NumArray(object):\\n        def __init__(self, nums):\\n            \"\"\"\\n            initialize your data structure here.\\n            :type nums: List[int]\\n            \"\"\"\\n            self.sums = [0] * (len(nums) + 1)\\n            for i in xrange(len(nums)):\\n                self.sums[i+1] = self.sums[i] + nums[i]\\n    \\n        def sumRange(self, i, j):\\n            \"\"\"\\n            sum of elements nums[i..j], inclusive.\\n            :type i: int\\n            :type j: int\\n            :rtype: int\\n            \"\"\"\\n            return self.sums[j+1] - self.sums[i]",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "Use an extra element for summation so we don't need to check boundary condition in the query.\\n\\n    class NumArray(object):\\n        def __init__(self, nums):\\n            \"\"\"\\n            initialize your data structure here.\\n            :type nums: List[int]\\n            \"\"\"\\n            self.sums = [0] * (len(nums) + 1)\\n            for i in xrange(len(nums)):\\n                self.sums[i+1] = self.sums[i] + nums[i]\\n    \\n        def sumRange(self, i, j):\\n            \"\"\"\\n            sum of elements nums[i..j], inclusive.\\n            :type i: int\\n            :type j: int\\n            :rtype: int\\n            \"\"\"\\n            return self.sums[j+1] - self.sums[i]",
                "codeTag": "Java"
            },
            {
                "id": 75324,
                "title": "accepted-c-solution",
                "content": "    struct NumArray {\\n        int size;\\n        int *sum;\\n};\\n\\n    \\n/** Initialize your data structure here. */\\n\\n    struct NumArray* NumArrayCreate(int* nums, int numsSize) {\\n        struct NumArray *array;\\n        int i;\\n\\n        array = (struct NumArray*)calloc(1, sizeof(struct NumArray));\\n        array->sum = (int *) calloc(numsSize+1, sizeof(int));\\n        array->size = numsSize;\\n        array->sum[0] = 0;\\n        for(i = 0; i < numsSize; i++){\\n                array->sum[i+1] = nums[i] + array->sum[i];\\n        }\\n        return array;\\n}\\n\\n     int sumRange(struct NumArray* numArray, int i, int j)\\n    {\\n        int sum = 0;\\n        if(!numArray)\\n                return 0;\\n        sum = numArray->sum[j+1] - numArray->sum[i];\\n        return sum;\\n}\\n\\n\\n    /** Deallocates memory previously allocated for the data structure. */\\n    void NumArrayFree(struct NumArray* numArray) {\\n        free(numArray->sum);\\n        free(numArray);\\n}",
                "solutionTags": [],
                "code": "    struct NumArray {\\n        int size;\\n        int *sum;\\n};\\n\\n    \\n/** Initialize your data structure here. */\\n\\n    struct NumArray* NumArrayCreate(int* nums, int numsSize) {\\n        struct NumArray *array;\\n        int i;\\n\\n        array = (struct NumArray*)calloc(1, sizeof(struct NumArray));\\n        array->sum = (int *) calloc(numsSize+1, sizeof(int));\\n        array->size = numsSize;\\n        array->sum[0] = 0;\\n        for(i = 0; i < numsSize; i++){\\n                array->sum[i+1] = nums[i] + array->sum[i];\\n        }\\n        return array;\\n}\\n\\n     int sumRange(struct NumArray* numArray, int i, int j)\\n    {\\n        int sum = 0;\\n        if(!numArray)\\n                return 0;\\n        sum = numArray->sum[j+1] - numArray->sum[i];\\n        return sum;\\n}\\n\\n\\n    /** Deallocates memory previously allocated for the data structure. */\\n    void NumArrayFree(struct NumArray* numArray) {\\n        free(numArray->sum);\\n        free(numArray);\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 75342,
                "title": "my-simple-short-python-solution",
                "content": "    class NumArray(object):\\n        def __init__(self, nums):\\n            self.dp = [0]+nums[:]\\n            for i in xrange(1, len(nums)+1):\\n                self.dp[i] += self.dp[i-1]\\n\\n        def sumRange(self, i, j):\\n            return self.dp[j+1]-self.dp[i]",
                "solutionTags": [],
                "code": "    class NumArray(object):\\n        def __init__(self, nums):\\n            self.dp = [0]+nums[:]\\n            for i in xrange(1, len(nums)+1):\\n                self.dp[i] += self.dp[i-1]\\n\\n        def sumRange(self, i, j):\\n            return self.dp[j+1]-self.dp[i]",
                "codeTag": "Java"
            },
            {
                "id": 2640650,
                "title": "java-easiest-solution",
                "content": "```\\nclass NumArray {\\n    private int arr[];\\n    public NumArray(int[] nums) {\\n        this.arr = nums;\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        for(int i = left;i<=right;i++)\\n            sum += this.arr[i];\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n    private int arr[];\\n    public NumArray(int[] nums) {\\n        this.arr = nums;\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        for(int i = left;i<=right;i++)\\n            sum += this.arr[i];\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2141522,
                "title": "java-javascript-python-beginner-friendly-solutions",
                "content": "**Java**\\n```\\nclass NumArray {\\n\\n    int[] arr;\\n    public NumArray(int[] nums) {\\n        this.arr = nums;\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        while(left<=right){\\n            sum += this.arr[left++];\\n        }\\n        return sum;\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar NumArray = function(nums) {\\n    this.arr = nums\\n};\\n\\nNumArray.prototype.sumRange = function(left, right) {\\n    let sum = 0\\n    while( left <= right){\\n        sum += this.arr[left++]\\n    }\\n    return sum\\n};\\n```\\n**Python**\\n```\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.arr = nums\\n        \\n    def sumRange(self, left, right):\\n        return sum(self.arr[left : right+1])\\n```",
                "solutionTags": [
                    "Java",
                    "Python",
                    "JavaScript"
                ],
                "code": "```\\nclass NumArray {\\n\\n    int[] arr;\\n    public NumArray(int[] nums) {\\n        this.arr = nums;\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        while(left<=right){\\n            sum += this.arr[left++];\\n        }\\n        return sum;\\n    }\\n}\\n```\n```\\nvar NumArray = function(nums) {\\n    this.arr = nums\\n};\\n\\nNumArray.prototype.sumRange = function(left, right) {\\n    let sum = 0\\n    while( left <= right){\\n        sum += this.arr[left++]\\n    }\\n    return sum\\n};\\n```\n```\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.arr = nums\\n        \\n    def sumRange(self, left, right):\\n        return sum(self.arr[left : right+1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2114601,
                "title": "c-easy-to-understand",
                "content": "```\\nclass NumArray {\\n    private:\\n    vector<int>v;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        \\n        \\n        for(int i=1;i<nums.size();i++){\\n            nums[i]=nums[i]+nums[i-1];\\n        }\\n        v = nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n       \\n        return v[right]-((left!=0)?v[left-1]:0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    private:\\n    vector<int>v;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        \\n        \\n        for(int i=1;i<nums.size();i++){\\n            nums[i]=nums[i]+nums[i-1];\\n        }\\n        v = nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n       \\n        return v[right]-((left!=0)?v[left-1]:0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 797665,
                "title": "c-simple-and-clean-solution-using-prefix-sum",
                "content": "```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n        for (int i=1; i<nums.size(); i++)\\n            vec[i] = nums[i]+vec[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if (i == 0) return vec[j];\\n        return vec[j]-vec[i-1];\\n    }\\nprivate:\\n    vector<int> vec;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n        for (int i=1; i<nums.size(); i++)\\n            vec[i] = nums[i]+vec[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if (i == 0) return vec[j];\\n        return vec[j]-vec[i-1];\\n    }\\nprivate:\\n    vector<int> vec;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265043,
                "title": "c-template-remove-reference-on-vector",
                "content": "It may seem obvious to many, as of March 30 the given c++ temlpate will fail at compile time, unless `vector<int>&` is changed to `vector<int>`.",
                "solutionTags": [],
                "code": "It may seem obvious to many, as of March 30 the given c++ temlpate will fail at compile time, unless `vector<int>&` is changed to `vector<int>`.",
                "codeTag": "Unknown"
            },
            {
                "id": 75305,
                "title": "accepted-java-range-sum-query-solution",
                "content": "\\npublic class NumArray {\\n\\n    int[] nums;\\n    int[] numSum;\\n\\n    public NumArray(int[] nums) {\\n        this.nums = nums;\\n        numSum = new int[nums.length + 1];\\n        numSum[0] = 0;\\n        for(int i = 1; i < numSum.length; i++){\\n            numSum[i] = numSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        if(i < 0 || j >= nums.length){\\n            return 0;\\n        }\\n        \\n        return numSum[j + 1] - numSum[i];\\n    }\\n}",
                "solutionTags": [],
                "code": "\\npublic class NumArray {\\n\\n    int[] nums;\\n    int[] numSum;\\n\\n    public NumArray(int[] nums) {\\n        this.nums = nums;\\n        numSum = new int[nums.length + 1];\\n        numSum[0] = 0;\\n        for(int i = 1; i < numSum.length; i++){\\n            numSum[i] = numSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        if(i < 0 || j >= nums.length){\\n            return 0;\\n        }\\n        \\n        return numSum[j + 1] - numSum[i];\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 3593362,
                "title": "beats-93-in-runtime-entire-problem-explained-in-detail-commented-code",
                "content": "# Explanation of the problem:\\nNums array given:\\n![nums arr.png](https://assets.leetcode.com/users/images/02f65ba1-7592-46bb-baa5-26a1a197da30_1685803697.891482.png)\\n\\n\\nPrefix sum array:\\n![prefix sum arr.png](https://assets.leetcode.com/users/images/4005752d-3699-4663-912d-89ab289bd7fc_1685803707.6904702.png)\\n\\n\\nHere we can see that the prefix array contains the sum up till every index given(right index)\\n\\nfor ex: right index given = 5 left index = 0\\nNow at the 5th index of prefix sum we have 4\\nHence the sum will be 4.\\n\\nfor ex: right index = 5 left index = 3\\nsum = 4-(0)=4\\nhere we subtracted the value at the 5th index that is 4 and the sum value of every element till the 3rd index excluding the sum at the 3rd index. (that is left index \\u2013 1) \\n\\n\\n# Code\\n```\\nvar NumArray = function(nums) {\\n    \\n    this.size = nums.length; //stores length of array\\n    this.prefixSum = Array( nums.length ).fill( 0 );//empty array\\n    this.prefixSum[0] = nums[0];//first value of prefix sum is the same as that of the first element of nums\\n    \\n    for( let i = 1; i < this.size ; i++ ){//traverse from left to right of array nums\\n        this.prefixSum[i] = this.prefixSum[i-1] + nums[i];\\n        /*stores sum of current value(nums) + previous sum value \\n        at the index before it(prefixsum)*/\\n    }\\n    \\n    \\n};\\n\\n/** \\n * @param {number} left \\n * @param {number} right\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function(left, right) {\\n    \\n    if( left == 0 ){\\n        /* if left index isnt mentioned then we return the \\n        sum up till the right index from the prefix sum array */\\n        return this.prefixSum[right];\\n    }else{\\n        //if the left index is given, then return the sum up \\n        //till the right index minus the value of prefix sum at \\n        //the index before the given left index i.e. value \\n        //at the (left - 1) index\\n        return this.prefixSum[right] - this.prefixSum[left-1];\\n    }\\n    \\n    \\n};\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "Segment Tree",
                    "Prefix Sum"
                ],
                "code": "# Explanation of the problem:\\nNums array given:\\n![nums arr.png](https://assets.leetcode.com/users/images/02f65ba1-7592-46bb-baa5-26a1a197da30_1685803697.891482.png)\\n\\n\\nPrefix sum array:\\n![prefix sum arr.png](https://assets.leetcode.com/users/images/4005752d-3699-4663-912d-89ab289bd7fc_1685803707.6904702.png)\\n\\n\\nHere we can see that the prefix array contains the sum up till every index given(right index)\\n\\nfor ex: right index given = 5 left index = 0\\nNow at the 5th index of prefix sum we have 4\\nHence the sum will be 4.\\n\\nfor ex: right index = 5 left index = 3\\nsum = 4-(0)=4\\nhere we subtracted the value at the 5th index that is 4 and the sum value of every element till the 3rd index excluding the sum at the 3rd index. (that is left index \\u2013 1) \\n\\n\\n# Code\\n```\\nvar NumArray = function(nums) {\\n    \\n    this.size = nums.length; //stores length of array\\n    this.prefixSum = Array( nums.length ).fill( 0 );//empty array\\n    this.prefixSum[0] = nums[0];//first value of prefix sum is the same as that of the first element of nums\\n    \\n    for( let i = 1; i < this.size ; i++ ){//traverse from left to right of array nums\\n        this.prefixSum[i] = this.prefixSum[i-1] + nums[i];\\n        /*stores sum of current value(nums) + previous sum value \\n        at the index before it(prefixsum)*/\\n    }\\n    \\n    \\n};\\n\\n/** \\n * @param {number} left \\n * @param {number} right\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function(left, right) {\\n    \\n    if( left == 0 ){\\n        /* if left index isnt mentioned then we return the \\n        sum up till the right index from the prefix sum array */\\n        return this.prefixSum[right];\\n    }else{\\n        //if the left index is given, then return the sum up \\n        //till the right index minus the value of prefix sum at \\n        //the index before the given left index i.e. value \\n        //at the (left - 1) index\\n        return this.prefixSum[right] - this.prefixSum[left-1];\\n    }\\n    \\n    \\n};\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3478350,
                "title": "java-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray {\\n    int num[];\\n    public NumArray(int[] nums) {\\n        num=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            num[i]=nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        int sum=0;\\n        for(int i=left;i<=right;i++)\\n        sum+=num[i];\\n        return sum;\\n    }\\n\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n    int num[];\\n    public NumArray(int[] nums) {\\n        num=new int[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            num[i]=nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        int sum=0;\\n        for(int i=left;i<=right;i++)\\n        sum+=num[i];\\n        return sum;\\n    }\\n\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206578,
                "title": "efficient-range-sum-query-using-prefix-sum-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem requires us to find the sum of the elements of nums between indices left and right inclusive. This can be achieved by creating a prefix sum array, which stores the sum of the elements up to that index. By subtracting the prefix sum of the left index - 1 from the prefix sum of the right index, we can obtain the sum of the elements between the two indices.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe can initialize the prefix sum array with 0\\'s, with a length of 1 greater than the length of the input array. We then iterate through the input array and store the cumulative sum up to that index in the prefix sum array.\\n\\nTo find the sum between the left and right indices, we return the difference between the prefix sum of the right index + 1 and the prefix sum of the left index.\\n# Complexity\\n- Time complexity:  $$O(n)$$ for initializing the prefix sum array, where $$n$$ is the length of the input array. Each sumRange query can be answered in $$O(1)$$ time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$ O(n)$$ for storing the prefix sum array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_sum = [0] * (len(nums) + 1)\\n        for i in range(1, len(nums) + 1):\\n            self.prefix_sum[i] = self.prefix_sum[i-1] + nums[i-1]\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix_sum[right+1] - self.prefix_sum[left]\\n        \\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Design",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_sum = [0] * (len(nums) + 1)\\n        for i in range(1, len(nums) + 1):\\n            self.prefix_sum[i] = self.prefix_sum[i-1] + nums[i-1]\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix_sum[right+1] - self.prefix_sum[left]\\n        \\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147205,
                "title": "beats-85-tc-o-n-sc-o-n-prefix-sum-4-lines-code-easy-understanding",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Traversing same arrey each time ,so use Prefix sum,to minimise TC.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Prefix Sum\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass NumArray {\\npublic:\\nvector<int> v;\\n    NumArray(vector<int>& nums) {\\n       v.push_back(nums[0]);\\n       for(int i=1;i<nums.size();i++)\\n            v.push_back(nums[i]+v[i-1]);\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0) return v[right];\\n        return v[right]-v[left-1];\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Prefix Sum"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->Traversing same arrey each time ,so use Prefix sum,to minimise TC.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->Prefix Sum\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n# Code\\n```\\nclass NumArray {\\npublic:\\nvector<int> v;\\n    NumArray(vector<int>& nums) {\\n       v.push_back(nums[0]);\\n       for(int i=1;i<nums.size();i++)\\n            v.push_back(nums[i]+v[i-1]);\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0) return v[right];\\n        return v[right]-v[left-1];\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 2921730,
                "title": "beats-99-93-of-the-python-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use a prefix sum array for this problem.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity of building the prefix_array is $$O(n)$$ but you\\'ll get your answer for sumRange() function within $$O(1)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace complexity is $$O(n)$$ as we have used extra space for building the prefix array.\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_array = [nums[0]]\\n        for i in range(1,len(nums)):\\n            self.prefix_array.append(nums[i]+self.prefix_array[-1])\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left == 0:\\n            return self.prefix_array[right]\\n        return self.prefix_array[right]-self.prefix_array[left-1]\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_array = [nums[0]]\\n        for i in range(1,len(nums)):\\n            self.prefix_array.append(nums[i]+self.prefix_array[-1])\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left == 0:\\n            return self.prefix_array[right]\\n        return self.prefix_array[right]-self.prefix_array[left-1]\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2843255,
                "title": "java-2-solutions-naive-prefix-sum-easy",
                "content": "### **Please Upvote** :D\\n##### 1. Naive solution:\\n```\\nclass NumArray {\\n    private int[] arr;\\n\\n    public NumArray(int[] nums) {\\n        this.arr = nums;\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        for (int i = left; i <= right; i++) {\\n            sum += arr[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n\\n// TC: O(k * n), SC: O(n)\\n// let k be the number of calls made to sumRange()\\n```\\n##### 2. Using prefix-sum:\\n```\\nclass NumArray {\\n    private int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        prefixSum = new int[nums.length + 1];\\n\\n        for (int i = 1; i <= nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n// sumRange() runs on O(1) time complexity\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    private int[] arr;\\n\\n    public NumArray(int[] nums) {\\n        this.arr = nums;\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        for (int i = left; i <= right; i++) {\\n            sum += arr[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n\\n// TC: O(k * n), SC: O(n)\\n// let k be the number of calls made to sumRange()\\n```\n```\\nclass NumArray {\\n    private int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        prefixSum = new int[nums.length + 1];\\n\\n        for (int i = 1; i <= nums.length; i++) {\\n            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n// sumRange() runs on O(1) time complexity\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2376804,
                "title": "c-easy-to-understand-self-explaintory",
                "content": "![image](https://assets.leetcode.com/users/images/de134498-9b51-42d3-8c94-db11083a8696_1659589326.830725.png)\\n\\n\\tclass NumArray {\\n\\tpublic:\\n\\t\\tvector<int>arr;\\n\\t\\tNumArray(vector<int>& nums) {\\n\\t\\t\\tarr=nums;\\n\\t\\t}\\n\\n\\t\\tint sumRange(int left, int right) {\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=left;i<=right;i++) sum+=arr[i];\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/de134498-9b51-42d3-8c94-db11083a8696_1659589326.830725.png)\\n\\n\\tclass NumArray {\\n\\tpublic:\\n\\t\\tvector<int>arr;\\n\\t\\tNumArray(vector<int>& nums) {\\n\\t\\t\\tarr=nums;\\n\\t\\t}\\n\\n\\t\\tint sumRange(int left, int right) {\\n\\t\\t\\tint sum=0;\\n\\t\\t\\tfor(int i=left;i<=right;i++) sum+=arr[i];\\n\\t\\t\\treturn sum;\\n\\t\\t}\\n\\t};",
                "codeTag": "Java"
            },
            {
                "id": 2204819,
                "title": "segment-tree-implementation",
                "content": "```\\nclass NumArray {\\npublic:\\n    int n;\\n    vector<int> seg;\\n    \\n    int getSum(int index, int segStart, int segEnd, int queryStart, int queryEnd){ //index - index of current segement, \\n        //segStart and segEnd - range of values this segment has summed up\\n        //queryStart queryEnd - query left and right indexs\\n        \\n        if(queryStart<=segStart && queryEnd>=segEnd){//if our seg completely overlaps with the query range\\n            return seg[index];\\n        }\\n        \\n        if(segStart>queryEnd || segEnd<queryStart){// our segment does not overlap with the queryrange\\n            return 0;\\n        }\\n        \\n        //if it overlaps partially we will break down the segment down again\\n        int mid = segStart + (segEnd-segStart)/2;\\n        int ans = getSum(index*2+1, segStart, mid, queryStart, queryEnd) + \\n            getSum(index*2+2, mid+1, segEnd, queryStart, queryEnd); //searching in left and right\\n        return ans;\\n        // return 0;\\n        \\n    }\\n    \\n    int constructSegementTree(vector<int>&nums, int index, int start, int end){\\n        if(start == end){ // leaf node\\n            seg[index] = nums[start];\\n            // cout<<seg[index]<<endl;\\n            return seg[index];\\n        }\\n        \\n        //we will divide the array into two parts and recursively store the total sum in our node\\n        \\n        int mid = start+(end-start)/2;\\n        seg[index] = constructSegementTree(nums, 2*index+1, start, mid); //left sise\\n        seg[index] += constructSegementTree(nums, 2*index+2, mid+1, end); //right sise\\n        // cout<<seg[index]<<endl;\\n        return seg[index]; //return the sum store in this node as this is the sum of the subpart of its parent node.\\n    }\\n    \\n    NumArray(vector<int>& nums) {\\n        n = nums.size();\\n        \\n        int x = ceil(log2(n));//height of the segment tree\\n        int size = 2 * (int)(pow(2, x)) - 1; //size of segment tree\\n        \\n        seg.resize(size, 0);\\n        \\n        constructSegementTree(nums, 0, 0, n-1);\\n        // for(auto i: seg){\\n        //     cout<<i<<\" \";\\n        // }cout<<endl;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return getSum(0, 0, n-1, left, right);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    int n;\\n    vector<int> seg;\\n    \\n    int getSum(int index, int segStart, int segEnd, int queryStart, int queryEnd){ //index - index of current segement, \\n        //segStart and segEnd - range of values this segment has summed up\\n        //queryStart queryEnd - query left and right indexs\\n        \\n        if(queryStart<=segStart && queryEnd>=segEnd){//if our seg completely overlaps with the query range\\n            return seg[index];\\n        }\\n        \\n        if(segStart>queryEnd || segEnd<queryStart){// our segment does not overlap with the queryrange\\n            return 0;\\n        }\\n        \\n        //if it overlaps partially we will break down the segment down again\\n        int mid = segStart + (segEnd-segStart)/2;\\n        int ans = getSum(index*2+1, segStart, mid, queryStart, queryEnd) + \\n            getSum(index*2+2, mid+1, segEnd, queryStart, queryEnd); //searching in left and right\\n        return ans;\\n        // return 0;\\n        \\n    }\\n    \\n    int constructSegementTree(vector<int>&nums, int index, int start, int end){\\n        if(start == end){ // leaf node\\n            seg[index] = nums[start];\\n            // cout<<seg[index]<<endl;\\n            return seg[index];\\n        }\\n        \\n        //we will divide the array into two parts and recursively store the total sum in our node\\n        \\n        int mid = start+(end-start)/2;\\n        seg[index] = constructSegementTree(nums, 2*index+1, start, mid); //left sise\\n        seg[index] += constructSegementTree(nums, 2*index+2, mid+1, end); //right sise\\n        // cout<<seg[index]<<endl;\\n        return seg[index]; //return the sum store in this node as this is the sum of the subpart of its parent node.\\n    }\\n    \\n    NumArray(vector<int>& nums) {\\n        n = nums.size();\\n        \\n        int x = ceil(log2(n));//height of the segment tree\\n        int size = 2 * (int)(pow(2, x)) - 1; //size of segment tree\\n        \\n        seg.resize(size, 0);\\n        \\n        constructSegementTree(nums, 0, 0, n-1);\\n        // for(auto i: seg){\\n        //     cout<<i<<\" \";\\n        // }cout<<endl;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return getSum(0, 0, n-1, left, right);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2105767,
                "title": "java-easy-solution-o-1-query",
                "content": "```\\nclass NumArray {\\n    int ar[];\\n\\n    public NumArray(int[] nums) {\\n        int len = nums.length;\\n        ar = new int[len];\\n        ar[0] = nums[0];\\n        for (int i = 1; i < len; i++) {\\n            ar[i] = ar[i - 1] + nums[i];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left == 0)\\n            return ar[right];\\n        else\\n            return (ar[right] - ar[left - 1]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    int ar[];\\n\\n    public NumArray(int[] nums) {\\n        int len = nums.length;\\n        ar = new int[len];\\n        ar[0] = nums[0];\\n        for (int i = 1; i < len; i++) {\\n            ar[i] = ar[i - 1] + nums[i];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left == 0)\\n            return ar[right];\\n        else\\n            return (ar[right] - ar[left - 1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2028445,
                "title": "simple-and-straightforward-c-solution-with-algorithm-o-n",
                "content": "**Algorithm**\\n\\n* Create a struct with array pointer.\\n* Copy all the elements of nums to NumArray arr.\\n* Sum the elements from left to right(inclusive).\\n* Free NumArray arr and NumArray.\\n\\nTime Complexity: O(n) | Space Complexity: O(n)\\n\\n**Code**\\n\\n```\\ntypedef struct {\\n    int *arr;\\n} NumArray;\\n\\n\\nNumArray* numArrayCreate(int* nums, int numsSize) {\\n    NumArray* ptr = (NumArray*)malloc(sizeof(NumArray));\\n    ptr->arr = (int*)malloc(sizeof(int)*numsSize);\\n    for(int i=0; i<numsSize; i++){\\n        ptr->arr[i] = nums[i];\\n    }\\n    return ptr;\\n}\\n\\nint numArraySumRange(NumArray* obj, int left, int right) {\\n  int sum = 0;\\n    for(int i=left; i<=right; i++){\\n        sum+= obj->arr[i];\\n    }\\n    return sum;\\n}\\n\\nvoid numArrayFree(NumArray* obj) {\\n    free(obj->arr);\\n    free(obj);\\n}\\n```\\n**Please upvote if it helped you.**\\n*Feel free to ask any questions/query if any.*",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\ntypedef struct {\\n    int *arr;\\n} NumArray;\\n\\n\\nNumArray* numArrayCreate(int* nums, int numsSize) {\\n    NumArray* ptr = (NumArray*)malloc(sizeof(NumArray));\\n    ptr->arr = (int*)malloc(sizeof(int)*numsSize);\\n    for(int i=0; i<numsSize; i++){\\n        ptr->arr[i] = nums[i];\\n    }\\n    return ptr;\\n}\\n\\nint numArraySumRange(NumArray* obj, int left, int right) {\\n  int sum = 0;\\n    for(int i=left; i<=right; i++){\\n        sum+= obj->arr[i];\\n    }\\n    return sum;\\n}\\n\\nvoid numArrayFree(NumArray* obj) {\\n    free(obj->arr);\\n    free(obj);\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1852571,
                "title": "find-prefix-sum-and-answer-the-query-c",
                "content": "```\\nclass NumArray {\\nprivate:    \\n    vector<int> arr;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        int sum = 0;\\n        for(auto &it : nums){\\n            sum += it;\\n            arr.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int r = arr[right];\\n        int l = 0;\\n        if(left != 0) l = arr[left-1];\\n        int ans = r - l;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\nprivate:    \\n    vector<int> arr;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        int sum = 0;\\n        for(auto &it : nums){\\n            sum += it;\\n            arr.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int r = arr[right];\\n        int l = 0;\\n        if(left != 0) l = arr[left-1];\\n        int ans = r - l;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1778944,
                "title": "java-simple-solution-with-explanation",
                "content": "### Please upvote if you like the solution\\n\\n```\\nclass NumArray {\\n\\n\\n    /****\\n     *                *****  Approach - 1   ******\\n     *\\n     * By keeping the sum value till that position\\n     *\\n     *             Input : [-2,  0,  3, -5,  2, -1]\\n     * sumTillPosition  : [-2, -2,  1, -4, -2, -3]\\n     *\\n     * Now there are two cases\\n     * case-1 :  if (left == 0) in that case  return sumTillPosition of the right side\\n     *           sumTillPosition[right];\\n     *\\n     * Case-2 : For other cases\\n     *          subtract sumTillPosition of the (left - 1) side   from  sumTillPosition of the right side\\n     *          return sumTillPosition[right] - sumTillPosition[left - 1];\\n     */\\n    int[] sumTillPosition;\\n\\n    public NumArray(int[] nums) {\\n        sumTillPosition = new int[nums.length];\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            sumTillPosition[i] = sum;\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left == 0) {\\n            return sumTillPosition[right];\\n        }\\n        return sumTillPosition[right] - sumTillPosition[left - 1];\\n    }\\n\\n\\n    /**\\n     *                 *****  Approach - 2   ******\\n     *\\n     * By keeping two array\\n     * 1. Sum value of its left\\n     * 2. Sum value of its right\\n     *\\n     * For an example\\n     * Input : [-2, 0, 3, -5, 2, -1]\\n     * Left  : [0, -2, -2, 1, -4, -2]\\n     * Right : [-1, -1, -4, 1, -1, 0]\\n     *\\n     * Now if we have this precomputed arrays we can get the range sum by subtracting the leftSideSum & rightSideSum\\n     * resultedSum = totalSum - (leftSideSum[left] + rightSideSum[right]);\\n     */\\n\\n    /*\\n\\n    int[] leftSideSum;\\n    int[] rightSideSum;\\n    int totalSum = 0;\\n    public NumArray(int[] nums) {\\n\\n        leftSideSum = new int[nums.length];\\n        rightSideSum = new int[nums.length];\\n\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            leftSideSum[i] = sum;\\n            sum += nums[i];\\n        }\\n        totalSum = sum;\\n\\n        sum = 0;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            rightSideSum[i] = sum;\\n            sum += nums[i];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        return totalSum - (leftSideSum[left] + rightSideSum[right]);\\n    }\\n    */\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n\\n\\n    /****\\n     *                *****  Approach - 1   ******\\n     *\\n     * By keeping the sum value till that position\\n     *\\n     *             Input : [-2,  0,  3, -5,  2, -1]\\n     * sumTillPosition  : [-2, -2,  1, -4, -2, -3]\\n     *\\n     * Now there are two cases\\n     * case-1 :  if (left == 0) in that case  return sumTillPosition of the right side\\n     *           sumTillPosition[right];\\n     *\\n     * Case-2 : For other cases\\n     *          subtract sumTillPosition of the (left - 1) side   from  sumTillPosition of the right side\\n     *          return sumTillPosition[right] - sumTillPosition[left - 1];\\n     */\\n    int[] sumTillPosition;\\n\\n    public NumArray(int[] nums) {\\n        sumTillPosition = new int[nums.length];\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            sum += nums[i];\\n            sumTillPosition[i] = sum;\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if (left == 0) {\\n            return sumTillPosition[right];\\n        }\\n        return sumTillPosition[right] - sumTillPosition[left - 1];\\n    }\\n\\n\\n    /**\\n     *                 *****  Approach - 2   ******\\n     *\\n     * By keeping two array\\n     * 1. Sum value of its left\\n     * 2. Sum value of its right\\n     *\\n     * For an example\\n     * Input : [-2, 0, 3, -5, 2, -1]\\n     * Left  : [0, -2, -2, 1, -4, -2]\\n     * Right : [-1, -1, -4, 1, -1, 0]\\n     *\\n     * Now if we have this precomputed arrays we can get the range sum by subtracting the leftSideSum & rightSideSum\\n     * resultedSum = totalSum - (leftSideSum[left] + rightSideSum[right]);\\n     */\\n\\n    /*\\n\\n    int[] leftSideSum;\\n    int[] rightSideSum;\\n    int totalSum = 0;\\n    public NumArray(int[] nums) {\\n\\n        leftSideSum = new int[nums.length];\\n        rightSideSum = new int[nums.length];\\n\\n        int sum = 0;\\n        for (int i = 0; i < nums.length; i++) {\\n            leftSideSum[i] = sum;\\n            sum += nums[i];\\n        }\\n        totalSum = sum;\\n\\n        sum = 0;\\n        for (int i = nums.length - 1; i >= 0; i--) {\\n            rightSideSum[i] = sum;\\n            sum += nums[i];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        return totalSum - (leftSideSum[left] + rightSideSum[right]);\\n    }\\n    */\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1655756,
                "title": "c-easy-to-understand-2-approaches",
                "content": "**Naive approach**\\n```\\nclass NumArray {\\npublic:\\n    vector<int> v;\\n    NumArray(vector<int>& nums) {\\n        v=nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n      int sum=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            sum+=v[i];\\n        }\\n        return sum;\\n    }\\n};\\n```\\n**Prefix sum approach**\\n```\\nclass NumArray {\\npublic:\\n    vector<int> v;\\n    NumArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            v.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left-1>=0)\\n        return v[right]-v[left-1];\\n        else\\n        return v[right];\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> v;\\n    NumArray(vector<int>& nums) {\\n        v=nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n      int sum=0;\\n        for(int i=left;i<=right;i++)\\n        {\\n            sum+=v[i];\\n        }\\n        return sum;\\n    }\\n};\\n```\n```\\nclass NumArray {\\npublic:\\n    vector<int> v;\\n    NumArray(vector<int>& nums) {\\n        int n=nums.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            sum+=nums[i];\\n            v.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left-1>=0)\\n        return v[right]-v[left-1];\\n        else\\n        return v[right];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1493472,
                "title": "python-prefix-sum-with-explanation",
                "content": "#### Think it this way:\\n#### prefix[i] = num[0] +...+ num[i]\\n#### sumRange(left, right) = num[left] +...+ num[right] = prefix[right] - prefix[left-1]\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        \\n        self.prefix = {-1:0}\\n        for i,num in enumerate(nums):\\n            self.prefix[i] = self.prefix[i-1]+num\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix[right] - self.prefix[left-1]\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        \\n        self.prefix = {-1:0}\\n        for i,num in enumerate(nums):\\n            self.prefix[i] = self.prefix[i-1]+num\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix[right] - self.prefix[left-1]\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1370375,
                "title": "java-prefix-sum-technique-full-explanation-100-faster",
                "content": "Prefix sum is a very vital tool  to minimize the repeated calculation done in an array and thus reduces the time complexity of your program.\\n\\n**What is prefix sum ?**\\nSuppose you are given an array, A = { 2 , 6 , 5 , 8 , 7 , 1 }. Let us define a new array PA[ ], size of which is same as the size of array A. The element at the ith index of the array PA will contain the sum of all the elements from A[0] to A[i], i.e :\\n```\\n\\nPA[0] = A[0]\\n PA[1] = A[0] + A[1]\\n PA[2] = A[0] + A[1] + A[2]\\n\\t .\\n\\t .\\n\\t .\\n PA[i] = A[0] + A[1] + A[2] + ........ + A[i]\\n\\t .\\n\\t .\\n\\t .\\n PA[N-1] = A[0] + A[1] + A[2] + ......... + A[N-1]\\n```\\n\\nSo, the prefix array of the given array A will be , PA [ ] = { 2 , 8 , 13 , 21 , 28 , 29 }\\n\\n**Creating Prefix array**\\nPrefix array can easily be constructed by travelling the array A once. This can be done by using the formula :\\nPA[ i ] = PA [ i \\u2212 1 ] + A[i]\\nHere i varies from 1 to N \\u2212 1. PA[ 0 ] is initialize to A[ 0 ] before the loop starts.\\n\\n**Advantage**\\nSuppose you are said to calculate the sum of first K elements of the array A. It is fine if you have to do the given task once, but if you are asked repeatedly to find the sum of first K elements of the array A (note : K may vary from 0 to N-1 ) then it may take lot of time. But if we construct prefix array of the given array then we can answer the query in O( 1 ) time by just printing PA[ K \\u2212 1 ].\\n\\nNow suppose you are asked to calculate the sum of elements of array A from index L to index R ( L \\u2264 R) i.e, you have to calculate the summation of the series A[ L ] + A[ L + 1 ] + ........ + A [ R ], if you are asked to calculate once then it is fine but if you have to repeatedly calculate then prefix array would be a better option. We can answer the query in O( 1 ) time by just printing, PA[ R ] \\u2212 PA[ L \\u2212 1 ].\\nExplanation\\n\\u2003\\u2003\\u2003\\u2003 PA[ R ] = A[ 0 ] + A [ 1 ] + A[ 2 ] + ....... + A[ L-1 ] + A[ L ] + ........ + A[ R ] (note L \\u2264 R)\\n\\u2003\\u2003\\u2003\\u2003 PA[ L-1 ] = A[ 0 ] + A [ 1 ] + A[ 2 ] + ....... + A[ L \\u2212 1 ]\\n\\nsubstracting PA[ R ] by PA[ L \\u2212 1 ] we get:\\n\\n\\u2003\\u2003\\u2003\\u2003 PA[ R ] \\u2212 PA[ L \\u2212 1] = A[ L ] + ........ + A[ R ]\\n\\n**Properties**\\nIf the given array A has all non-negative numbers the the prefix array constructed will be sorted in non-descending order.\\n\\n**Solution**\\n\\n```\\nclass NumArray {\\n    \\n    int[] num;\\n    public NumArray(int[] nums) {\\n        num = nums;\\n        for (int i = 1; i < nums.length; i++) {\\n            num[i] += num[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        return left == 0 ? num[right] : num[right] - num[left - 1];\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\n\\nPA[0] = A[0]\\n PA[1] = A[0] + A[1]\\n PA[2] = A[0] + A[1] + A[2]\\n\\t .\\n\\t .\\n\\t .\\n PA[i] = A[0] + A[1] + A[2] + ........ + A[i]\\n\\t .\\n\\t .\\n\\t .\\n PA[N-1] = A[0] + A[1] + A[2] + ......... + A[N-1]\\n```\n```\\nclass NumArray {\\n    \\n    int[] num;\\n    public NumArray(int[] nums) {\\n        num = nums;\\n        for (int i = 1; i < nums.length; i++) {\\n            num[i] += num[i - 1];\\n        }\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        return left == 0 ? num[right] : num[right] - num[left - 1];\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 702265,
                "title": "go",
                "content": "```\\ntype NumArray struct {\\n    sum []int\\n}\\n\\n\\nfunc Constructor(nums []int) NumArray {\\n    if len(nums) == 0 {\\n        return NumArray{}\\n    }\\n    \\n    sum := make([]int, len(nums) + 1)\\n    sum[0], sum[1] = 0, nums[0]\\n    for i := 2; i < len(sum); i++ {\\n        sum[i] = sum[i - 1] + nums[i - 1]\\n    }\\n    return NumArray{sum: sum}\\n}\\n\\n\\nfunc (this *NumArray) SumRange(i int, j int) int {\\n    \\n    return this.sum[j + 1] - this.sum[i]\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype NumArray struct {\\n    sum []int\\n}\\n\\n\\nfunc Constructor(nums []int) NumArray {\\n    if len(nums) == 0 {\\n        return NumArray{}\\n    }\\n    \\n    sum := make([]int, len(nums) + 1)\\n    sum[0], sum[1] = 0, nums[0]\\n    for i := 2; i < len(sum); i++ {\\n        sum[i] = sum[i - 1] + nums[i - 1]\\n    }\\n    return NumArray{sum: sum}\\n}\\n\\n\\nfunc (this *NumArray) SumRange(i int, j int) int {\\n    \\n    return this.sum[j + 1] - this.sum[i]\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 696259,
                "title": "c-segment-tree-solution",
                "content": "```\\nclass NumArray {\\npublic:\\n    int n;\\n    vector<int>seg;\\n    \\n    int query(int index,int low,int high,int l,int r)\\n    {\\n        if(low>=l && high<=r)\\n        {\\n            return seg[index];\\n        }\\n        if(high<l || low>r)\\n            return 0;\\n        int mid=(low+high)/2;\\n        int left=query(2*index+1,low,mid,l,r);\\n        int right=query(2*index+2,mid+1,high,l,r);\\n        return left+right;\\n    }\\n    \\n    void build(int index,int low,int high,vector<int>&nums)\\n    {\\n        if(low==high)\\n        {\\n            seg[index]=nums[low];\\n            return;\\n        }\\n        int mid=(low+high)/2;\\n        build(2*index+1,low,mid,nums);\\n        build(2*index+2,mid+1,high,nums);\\n        seg[index]=seg[2*index+1]+seg[2*index+2];\\n    }\\n    \\n    \\n    NumArray(vector<int>& nums) {\\n        n=nums.size();\\n        if(n==0)\\n            return ;\\n        seg.resize(4*n);\\n        build(0,0,n-1,nums);\\n        \\n    }\\n    \\n    int sumRange(int i, int j) {\\n        return query(0,0,n-1,i,j);\\n        \\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(i,j);\\n */",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    int n;\\n    vector<int>seg;\\n    \\n    int query(int index,int low,int high,int l,int r)\\n    {\\n        if(low>=l && high<=r)\\n        {\\n            return seg[index];\\n        }\\n        if(high<l || low>r)\\n            return 0;\\n        int mid=(low+high)/2;\\n        int left=query(2*index+1,low,mid,l,r);\\n        int right=query(2*index+2,mid+1,high,l,r);\\n        return left+right;\\n    }\\n    \\n    void build(int index,int low,int high,vector<int>&nums)\\n    {\\n        if(low==high)\\n        {\\n            seg[index]=nums[low];\\n            return;\\n        }\\n        int mid=(low+high)/2;\\n        build(2*index+1,low,mid,nums);\\n        build(2*index+2,mid+1,high,nums);\\n        seg[index]=seg[2*index+1]+seg[2*index+2];\\n    }\\n    \\n    \\n    NumArray(vector<int>& nums) {\\n        n=nums.size();\\n        if(n==0)\\n            return ;\\n        seg.resize(4*n);\\n        build(0,0,n-1,nums);\\n        \\n    }\\n    \\n    int sumRange(int i, int j) {\\n        return query(0,0,n-1,i,j);\\n        \\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(i,j);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 75188,
                "title": "7-lines-c-dp",
                "content": "And my [7 lines DP solution](https://discuss.leetcode.com/topic/104453/7-lines-c-dp) for the [304. Range Sum Query 2D - Immutable](https://leetcode.com/problems/range-sum-query-2d-immutable/description/).\\n```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int> nums) {\\n        int sum = 0;\\n        for(auto x: nums){\\n            sum += x;\\n            dp.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        return i == 0 ? dp[j] : dp[j] - dp[i - 1];\\n    }\\n    \\nprivate:\\n    vector<int>dp;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int> nums) {\\n        int sum = 0;\\n        for(auto x: nums){\\n            sum += x;\\n            dp.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        return i == 0 ? dp[j] : dp[j] - dp[i - 1];\\n    }\\n    \\nprivate:\\n    vector<int>dp;\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75244,
                "title": "c-beats-100-solutions",
                "content": "    class NumArray {\\n    public:\\n        map<int,int> mp;\\n        NumArray(vector<int> &nums) {\\n            mp[-1] = 0;\\n            int sum = 0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                sum += nums[i];\\n                mp[i] = sum;\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return (mp[j]-mp[i-1]);\\n        }\\n    };",
                "solutionTags": [],
                "code": "    class NumArray {\\n    public:\\n        map<int,int> mp;\\n        NumArray(vector<int> &nums) {\\n            mp[-1] = 0;\\n            int sum = 0;\\n            for(int i=0;i<nums.size();i++)\\n            {\\n                sum += nums[i];\\n                mp[i] = sum;\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return (mp[j]-mp[i-1]);\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 75271,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "    class NumArray {\\n        vector<int> sums;\\n    public:\\n        NumArray(vector<int> &nums) {\\n            sums.resize(nums.size()+1, 0);\\n            for(int i=1; i<=nums.size(); i++){\\n                sums[i]=sums[i-1]+nums[i-1];\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return sums[j+1]-sums[i];\\n        }\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "solutionTags": [],
                "code": "    class NumArray {\\n        vector<int> sums;\\n    public:\\n        NumArray(vector<int> &nums) {\\n            sums.resize(nums.size()+1, 0);\\n            for(int i=1; i<=nums.size(); i++){\\n                sums[i]=sums[i-1]+nums[i-1];\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return sums[j+1]-sums[i];\\n        }\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "codeTag": "Java"
            },
            {
                "id": 75317,
                "title": "c-solution-with-accumulated-sum-array",
                "content": "    class NumArray {\\n    public:\\n        NumArray(vector<int> &nums) {\\n        int accum=0;\\n        for(int i=0;i<nums.size();i++)\\n            {\\n            accum+=nums[i];\\n            _acarray.push_back(accum);\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            if(i==0)\\n                return (_acarray[j]);\\n            else \\n                return (_acarray[j]-_acarray[i-1]);\\n        }\\n        \\n    private:\\n        vector<int> _acarray;\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "solutionTags": [],
                "code": "    class NumArray {\\n    public:\\n        NumArray(vector<int> &nums) {\\n        int accum=0;\\n        for(int i=0;i<nums.size();i++)\\n            {\\n            accum+=nums[i];\\n            _acarray.push_back(accum);\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            if(i==0)\\n                return (_acarray[j]);\\n            else \\n                return (_acarray[j]-_acarray[i-1]);\\n        }\\n        \\n    private:\\n        vector<int> _acarray;\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "codeTag": "Java"
            },
            {
                "id": 75326,
                "title": "a-ruby-solution",
                "content": "    class NumArray\\n    \\n      def initialize(nums)\\n        @sum = [s = 0] + nums.map { |n| s += n }\\n      end\\n    \\n      def sum_range(i, j)\\n        @sum[j + 1] - @sum[i]\\n      end\\n    \\n    end",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "    class NumArray\\n    \\n      def initialize(nums)\\n        @sum = [s = 0] + nums.map { |n| s += n }\\n      end\\n    \\n      def sum_range(i, j)\\n        @sum[j + 1] - @sum[i]\\n      end\\n    \\n    end",
                "codeTag": "Java"
            },
            {
                "id": 3371852,
                "title": "python-o-1-solution-beats-97-85",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        arr = [nums[0]]\\n        for i in range(1,len(nums)):\\n            arr.append(arr[-1]+nums[i])\\n        self.arr = arr\\n\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left == 0:\\n            return self.arr[right]\\n        return self.arr[right] - self.arr[left - 1]\\n        \\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n\\n\\n\\n\"\"\"\\ngiven n>= j > i >0\\nprefix_sum(i,j) = prefix_sum(0,j) - prefix_sum(0,i)\\nwe need to itilaze a prefix_sum\\n\\n\\n\"\"\"\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        arr = [nums[0]]\\n        for i in range(1,len(nums)):\\n            arr.append(arr[-1]+nums[i])\\n        self.arr = arr\\n\\n        \\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left == 0:\\n            return self.arr[right]\\n        return self.arr[right] - self.arr[left - 1]\\n        \\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n\\n\\n\\n\"\"\"\\ngiven n>= j > i >0\\nprefix_sum(i,j) = prefix_sum(0,j) - prefix_sum(0,i)\\nwe need to itilaze a prefix_sum\\n\\n\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3061568,
                "title": "java-prefix-sum-solution",
                "content": "# Intuition\\nUse prefix sum to precalculate range sum.\\n\\n# Approach\\nUse prefix sum to precalculate range sum.\\n\\n# Complexity\\n- Time complexity:\\nO(1)\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass NumArray {\\n\\n    private int[] prefixSum;\\n    public NumArray(int[] nums) {\\n        prefixSum = new int[nums.length];\\n\\n        for(int i=0; i < nums.length ; i++) {\\n            prefixSum[i] = nums[i];\\n            if(i > 0) prefixSum[i] += prefixSum[i-1];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return prefixSum[right] - (left > 0 ? prefixSum[left-1] : 0);\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n\\n    private int[] prefixSum;\\n    public NumArray(int[] nums) {\\n        prefixSum = new int[nums.length];\\n\\n        for(int i=0; i < nums.length ; i++) {\\n            prefixSum[i] = nums[i];\\n            if(i > 0) prefixSum[i] += prefixSum[i-1];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return prefixSum[right] - (left > 0 ? prefixSum[left-1] : 0);\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3059374,
                "title": "prefixsum-approach",
                "content": "# Complexity\\n- Time complexity: O(1) - to process each query\\n\\n- Space complexity: O(n) - to store prefix sum\\n\\n# Code\\n```\\nclass NumArray {\\n    int[] n;\\n    public NumArray(int[] nums) {\\n        n=new int[nums.length];\\n        n[0]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            n[i]=nums[i]+n[i-1];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        if(left==0){\\n            return n[right];\\n        }\\n        else{\\n            return n[right]-n[left-1];\\n        }\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    int[] n;\\n    public NumArray(int[] nums) {\\n        n=new int[nums.length];\\n        n[0]=nums[0];\\n        for(int i=1;i<nums.length;i++){\\n            n[i]=nums[i]+n[i-1];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        if(left==0){\\n            return n[right];\\n        }\\n        else{\\n            return n[right]-n[left-1];\\n        }\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3054764,
                "title": "in-o-1-find-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray {\\n    int prefixArray[] = null;\\n    public NumArray(int[] nums) {\\n        int sum = 0; int n = nums.length;\\n        prefixArray = new int[n];\\n        for(int i = 0;i<n;i++){\\n            sum+=nums[i];\\n            prefixArray[i] = sum;\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        if(left>0) return (prefixArray[right]-prefixArray[left-1]);\\n         return prefixArray[right];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n    int prefixArray[] = null;\\n    public NumArray(int[] nums) {\\n        int sum = 0; int n = nums.length;\\n        prefixArray = new int[n];\\n        for(int i = 0;i<n;i++){\\n            sum+=nums[i];\\n            prefixArray[i] = sum;\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        if(left>0) return (prefixArray[right]-prefixArray[left-1]);\\n         return prefixArray[right];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2932581,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass NumArray {\\npublic:\\n    int pref[10005];\\n    NumArray(vector<int>& nums) {\\n        for(int i=0; i<nums.size(); i++) pref[i+1] = pref[i] + nums[i];\\n    }  \\n    int sumRange(int left, int right) {\\n        return pref[right + 1] - pref[left];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    int pref[10005];\\n    NumArray(vector<int>& nums) {\\n        for(int i=0; i<nums.size(); i++) pref[i+1] = pref[i] + nums[i];\\n    }  \\n    int sumRange(int left, int right) {\\n        return pref[right + 1] - pref[left];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2844575,
                "title": "c-using-prefix-sum",
                "content": "# Please Upvote if Usefull , means lot.\\n**Intutuion** \\n* Just Use Prefix Sum .\\n```\\nclass NumArray {\\npublic:\\n    vector< int>  sum;\\n    NumArray(vector<int>& a) {\\n        sum.resize(a.size()+1,0);\\n        for( int i=1;i<=a.size();i++){\\n            sum[i]+=sum[i-1]+a[i-1];\\n        }\\n    }\\n    \\n    int sumRange(int l, int r) {\\n        return sum[r+1]-sum[l];\\n    }\\n        \\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector< int>  sum;\\n    NumArray(vector<int>& a) {\\n        sum.resize(a.size()+1,0);\\n        for( int i=1;i<=a.size();i++){\\n            sum[i]+=sum[i-1]+a[i-1];\\n        }\\n    }\\n    \\n    int sumRange(int l, int r) {\\n        return sum[r+1]-sum[l];\\n    }\\n        \\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2360797,
                "title": "c-easy-solution",
                "content": "```\\nclass NumArray {\\npublic:\\n    vector<int> ans;\\n    int sum=0;\\n    NumArray(vector<int>& nums) \\n    {\\n        ans=nums;\\n        sum=accumulate(ans.begin(),ans.end(),0);\\n    }\\n    \\n    int sumRange(int left, int right) \\n    {\\n        int res=sum;\\n        for(int i=0;i<left;i++)\\n            res-=ans[i];\\n        \\n        for(int i=right+1;i<ans.size();i++)\\n            res-=ans[i];\\n        \\n        return res;\\n    }\\n};\\n```\\nPlease upvote if you like the solution :)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> ans;\\n    int sum=0;\\n    NumArray(vector<int>& nums) \\n    {\\n        ans=nums;\\n        sum=accumulate(ans.begin(),ans.end(),0);\\n    }\\n    \\n    int sumRange(int left, int right) \\n    {\\n        int res=sum;\\n        for(int i=0;i<left;i++)\\n            res-=ans[i];\\n        \\n        for(int i=right+1;i<ans.size();i++)\\n            res-=ans[i];\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2105239,
                "title": "easy-c-dp-method-beginner-friendly",
                "content": "**Code:**\\n\\n```\\nclass NumArray {\\npublic:\\n    vector<int> sumMat; // DP array\\n    NumArray(vector<int>& nums) {\\n        int n = nums.size(), prefix=nums[0];\\n        sumMat = vector<int>(n+1);\\n        sumMat[0]=0; sumMat[1]=nums[0];\\n        \\n        for (int i=1; i<n; i++){\\n            prefix+=nums[i];\\n            sumMat[i+1]=prefix;\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return (sumMat[right+1]-sumMat[left]);\\n    }\\n};\\n```\\n\\n**Hit Upvote, if my solution helped you!**\\n*Feel Free to reach me out for any help!*\\n \\n**Happy Learning!** \\uD83D\\uDD25\\uD83C\\uDFAF",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> sumMat; // DP array\\n    NumArray(vector<int>& nums) {\\n        int n = nums.size(), prefix=nums[0];\\n        sumMat = vector<int>(n+1);\\n        sumMat[0]=0; sumMat[1]=nums[0];\\n        \\n        for (int i=1; i<n; i++){\\n            prefix+=nums[i];\\n            sumMat[i+1]=prefix;\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return (sumMat[right+1]-sumMat[left]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830909,
                "title": "easy-c-solution-prefix-sum",
                "content": "**Try this one**\\nany suggession for imrpovments in it??\\n```\\nclass NumArray {\\npublic:\\n    vector<int>vec;\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int sum=0;\\n        for(int i=left;i<=right;i++){\\n            sum+=vec[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int>vec;\\n    NumArray(vector<int>& nums) {\\n        vec = nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int sum=0;\\n        for(int i=left;i<=right;i++){\\n            sum+=vec[i];\\n        }\\n        return sum;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237877,
                "title": "c-solution",
                "content": "```\\npublic class NumArray {\\n    \\n    // runningSum[i]: sum of nums[0,i]\\n    private int[] runningSum;\\n\\n\\t// O(N)\\n    public NumArray(int[] nums) {\\n        \\n        runningSum = new int[nums.Length];\\n        runningSum[0] = nums[0];\\n        for(int i = 1; i < nums.Length; i++)\\n            runningSum[i] = runningSum[i - 1] + nums[i];\\n    }\\n    \\n\\t// O(1)\\n    public int SumRange(int left, int right) {\\n       \\n        // sum[i,j] = runningSum[0,j] - runningSum[0,i-1]       \\n        return left == 0? runningSum[right] : runningSum[right] - runningSum[left - 1];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class NumArray {\\n    \\n    // runningSum[i]: sum of nums[0,i]\\n    private int[] runningSum;\\n\\n\\t// O(N)\\n    public NumArray(int[] nums) {\\n        \\n        runningSum = new int[nums.Length];\\n        runningSum[0] = nums[0];\\n        for(int i = 1; i < nums.Length; i++)\\n            runningSum[i] = runningSum[i - 1] + nums[i];\\n    }\\n    \\n\\t// O(1)\\n    public int SumRange(int left, int right) {\\n       \\n        // sum[i,j] = runningSum[0,j] - runningSum[0,i-1]       \\n        return left == 0? runningSum[right] : runningSum[right] - runningSum[left - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1141638,
                "title": "java-dynamic-programming-prefix-sum-array-beats-100-init-o-n-sumrange-o-1",
                "content": "\\n\\tint[] prefixSum;\\n\\t\\n\\t// O(nums.length)\\n\\tpublic NumArray(int[] nums) {\\n\\t\\tint len = nums.length;\\n\\t\\tprefixSum = new int[len];\\n\\t\\tprefixSum[0] = nums[0];\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tprefixSum[i] = prefixSum[i - 1] + nums[i];\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic int sumRange(int left, int right) {\\n\\t\\treturn (left == 0) ? prefixSum[right] : prefixSum[right] - prefixSum[left - 1];\\n\\t}",
                "solutionTags": [],
                "code": "\\n\\tint[] prefixSum;\\n\\t\\n\\t// O(nums.length)\\n\\tpublic NumArray(int[] nums) {\\n\\t\\tint len = nums.length;\\n\\t\\tprefixSum = new int[len];\\n\\t\\tprefixSum[0] = nums[0];\\n\\t\\tfor (int i = 1; i < len; i++)\\n\\t\\t\\tprefixSum[i] = prefixSum[i - 1] + nums[i];\\n\\t}\\n\\n\\t// O(1)\\n\\tpublic int sumRange(int left, int right) {\\n\\t\\treturn (left == 0) ? prefixSum[right] : prefixSum[right] - prefixSum[left - 1];\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 846086,
                "title": "java-clean-code-dynamic-programming-technique-o-1-time-complexity",
                "content": "```\\nclass NumArray {\\n    \\n    int[] dp;\\n\\n    public NumArray(int[] nums) {\\n        \\n        if (nums.length == 0) {\\n            return;\\n        }\\n        \\n        dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            dp[i] = dp[i - 1] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        \\n        int beforeSum = i == 0 ? 0 : dp[i - 1];\\n        return dp[j] - beforeSum;\\n    }\\n}\\n```\\n\\nPlease help to **UPVOTE** if this post is useful for you.\\nIf you have any questions, feel free to comment below.\\n**HAPPY CODING :)\\nLOVE CODING :)**\\n\\n",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\n    \\n    int[] dp;\\n\\n    public NumArray(int[] nums) {\\n        \\n        if (nums.length == 0) {\\n            return;\\n        }\\n        \\n        dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        \\n        for (int i = 1; i < nums.length; i++) {\\n            dp[i] = dp[i - 1] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        \\n        int beforeSum = i == 0 ? 0 : dp[i - 1];\\n        return dp[j] - beforeSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 655347,
                "title": "java-segment-tree",
                "content": "**DP solution o(1) time per query**\\n**Space = O(n)**\\n```\\nclass NumArray {\\n    int dp[] ;\\n    public NumArray(int[] nums) {\\n        if( nums.length == 0)   return;\\n        dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        for(int i = 1 ;i < nums.length; i++){\\n            dp[i] = dp[i-1] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        if( i == 0)\\n            return dp[j];\\n        return dp[j] - dp[i-1];\\n    }\\n}\\n\\n\\n\\n```\\n\\n**Segment Tree solution O(logN) time per query**\\n**Space = O(n)**\\n```\\nclass NumArray {\\n    int tree[];\\n    int n;\\n    int build(int L, int R, int pos, int [] nums){\\n        if (L == R){\\n            tree[pos] = nums[L];\\n            return tree[pos];\\n        }\\n        int mid = (L + R )/2;\\n        tree[pos] = build(L, mid, pos*2, nums) + build(mid+1, R, pos*2+1, nums);\\n        return tree[pos];\\n        \\n    }\\n    public NumArray(int[] nums) {\\n        \\n        n = nums.length;\\n        if( n == 0) return;\\n        if( (n &(n-1)) == 0){\\n            tree = new int[2 * n];\\n        }\\n        else{\\n            int count = 0;\\n            int n1 = n;\\n            while( n1 > 0){\\n                count++;\\n                n1 >>= 1;\\n            }\\n            tree = new int[ 2 *( 1 <<count)];\\n            \\n        }\\n        build(0, n-1, 1, nums);\\n    }\\n    \\n    int find(int st, int end, int L, int R, int pos){\\n        if( end < L || R < st)\\n            return 0;\\n        if( st <= L && R <= end )\\n            return tree[pos];\\n        int mid = (L + R) /2;\\n        return find(st, end, L, mid, pos*2) + find(st, end, mid+1, R, pos*2+1);\\n    }\\n    public int sumRange(int i, int j) {\\n        \\n        return find(i, j , 0 , n-1,1);\\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass NumArray {\\n    int dp[] ;\\n    public NumArray(int[] nums) {\\n        if( nums.length == 0)   return;\\n        dp = new int[nums.length];\\n        dp[0] = nums[0];\\n        for(int i = 1 ;i < nums.length; i++){\\n            dp[i] = dp[i-1] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        if( i == 0)\\n            return dp[j];\\n        return dp[j] - dp[i-1];\\n    }\\n}\\n\\n\\n\\n```\n```\\nclass NumArray {\\n    int tree[];\\n    int n;\\n    int build(int L, int R, int pos, int [] nums){\\n        if (L == R){\\n            tree[pos] = nums[L];\\n            return tree[pos];\\n        }\\n        int mid = (L + R )/2;\\n        tree[pos] = build(L, mid, pos*2, nums) + build(mid+1, R, pos*2+1, nums);\\n        return tree[pos];\\n        \\n    }\\n    public NumArray(int[] nums) {\\n        \\n        n = nums.length;\\n        if( n == 0) return;\\n        if( (n &(n-1)) == 0){\\n            tree = new int[2 * n];\\n        }\\n        else{\\n            int count = 0;\\n            int n1 = n;\\n            while( n1 > 0){\\n                count++;\\n                n1 >>= 1;\\n            }\\n            tree = new int[ 2 *( 1 <<count)];\\n            \\n        }\\n        build(0, n-1, 1, nums);\\n    }\\n    \\n    int find(int st, int end, int L, int R, int pos){\\n        if( end < L || R < st)\\n            return 0;\\n        if( st <= L && R <= end )\\n            return tree[pos];\\n        int mid = (L + R) /2;\\n        return find(st, end, L, mid, pos*2) + find(st, end, mid+1, R, pos*2+1);\\n    }\\n    public int sumRange(int i, int j) {\\n        \\n        return find(i, j , 0 , n-1,1);\\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 638181,
                "title": "java-sparse-tabla",
                "content": "```\\nclass NumArray {\\n    int sparse[][];\\n    int A[];\\n    public NumArray(int[] A) {\\n        this.A=A;\\n        sparse=new int[A.length][31];\\n        for(int i=0;i<A.length;i++){\\n            sparse[i][0]=A[i];\\n        }\\n        for(int j=1;j<=30;j++){\\n            for(int i=0;i+(1<<j)<=A.length;i++){\\n                sparse[i][j]=sparse[i][j-1]+sparse[i+(1<<(j-1))][j-1];\\n            }\\n        }\\n    }\\n    public int sumRange(int L, int R) {\\n        int sum = 0;\\n        for (int j = 30; j >= 0; j--) {\\n            if (L+(1 << j) <= R+1) {// check if in range\\n                sum += sparse[L][j];\\n                L+=1<< j;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(i,j);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\n    int sparse[][];\\n    int A[];\\n    public NumArray(int[] A) {\\n        this.A=A;\\n        sparse=new int[A.length][31];\\n        for(int i=0;i<A.length;i++){\\n            sparse[i][0]=A[i];\\n        }\\n        for(int j=1;j<=30;j++){\\n            for(int i=0;i+(1<<j)<=A.length;i++){\\n                sparse[i][j]=sparse[i][j-1]+sparse[i+(1<<(j-1))][j-1];\\n            }\\n        }\\n    }\\n    public int sumRange(int L, int R) {\\n        int sum = 0;\\n        for (int j = 30; j >= 0; j--) {\\n            if (L+(1 << j) <= R+1) {// check if in range\\n                sum += sparse[L][j];\\n                L+=1<< j;\\n            }\\n        }\\n        return sum;\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(i,j);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 438454,
                "title": "very-simple-and-straight-forward-ruby-dp-solution",
                "content": "```\\ndef initialize(nums)\\n  @sum_cache = []\\n  sum = 0\\n  nums.each_with_index { |num, i|\\n\\tsum += num\\n\\t@sum_cache[i] = sum\\n  }\\nend\\n\\ndef sum_range(i, j)\\n  i == 0 ? @sum_cache[j] : @sum_cache[j] - @sum_cache[i-1]\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Dynamic Programming"
                ],
                "code": "```\\ndef initialize(nums)\\n  @sum_cache = []\\n  sum = 0\\n  nums.each_with_index { |num, i|\\n\\tsum += num\\n\\t@sum_cache[i] = sum\\n  }\\nend\\n\\ndef sum_range(i, j)\\n  i == 0 ? @sum_cache[j] : @sum_cache[j] - @sum_cache[i-1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 417809,
                "title": "simple-dp-based-solution-easy-to-understand",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar NumArray = function(nums) {\\n    this.nums = []\\n    let sum = 0;\\n    nums.forEach((val, i) => {\\n        sum+=val\\n        this.nums.push(sum)\\n    \\n    });\\n};\\n\\n/** \\n * @param {number} i \\n * @param {number} j\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function(i, j) {\\n    let nums = this.nums;\\n    return nums[j] - (nums[i-1] || 0);\\n};\\n\\n/** \\n * Your NumArray object will be instantiated and called as such:\\n * var obj = new NumArray(nums)\\n * var param_1 = obj.sumRange(i,j)\\n */\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar NumArray = function(nums) {\\n    this.nums = []\\n    let sum = 0;\\n    nums.forEach((val, i) => {\\n        sum+=val\\n        this.nums.push(sum)\\n    \\n    });\\n};\\n\\n/** \\n * @param {number} i \\n * @param {number} j\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function(i, j) {\\n    let nums = this.nums;\\n    return nums[j] - (nums[i-1] || 0);\\n};\\n\\n/** \\n * Your NumArray object will be instantiated and called as such:\\n * var obj = new NumArray(nums)\\n * var param_1 = obj.sumRange(i,j)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 75253,
                "title": "java-accepted-solution",
                "content": "\\npublic class NumArray {\\n    List list = new ArrayList<Integer>();\\n    \\n    public NumArray(int[] nums) {\\n       //int[] num = new int[nums.length];\\n       if(nums.length == 0)\\n        return;\\n       list.add(0, nums[0]);\\n       for (int i=1; i<nums.length; i++){\\n           list.add(i, ((int)list.get(i-1) + nums[i]));\\n       }\\n    }\\n\\n\\n    public int sumRange(int i, int j) {\\n        if(i==0)\\n            return ((int)list.get(j));\\n        return ((int)list.get(j) - (int)list.get(i-1));\\n    }\\n}",
                "solutionTags": [],
                "code": "\\npublic class NumArray {\\n    List list = new ArrayList<Integer>();\\n    \\n    public NumArray(int[] nums) {\\n       //int[] num = new int[nums.length];\\n       if(nums.length == 0)\\n        return;\\n       list.add(0, nums[0]);\\n       for (int i=1; i<nums.length; i++){\\n           list.add(i, ((int)list.get(i-1) + nums[i]));\\n       }\\n    }\\n\\n\\n    public int sumRange(int i, int j) {\\n        if(i==0)\\n            return ((int)list.get(j));\\n        return ((int)list.get(j) - (int)list.get(i-1));\\n    }\\n}",
                "codeTag": "Java"
            },
            {
                "id": 75280,
                "title": "java-accepted-solution",
                "content": "    public class NumArray {\\n    \\n        public NumArray(int[] nums) {\\n            int n = nums.length;\\n            if (n == 0) return;\\n            sum = new int[n];\\n            sum[0] = nums[0];\\n            for (int i = 1; i < n; i++) {\\n                sum[i] += sum[i-1] + nums[i];\\n            }\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            if (sum == null) return 0;\\n            if (i == 0) \\n                return sum[j];\\n            else \\n                return sum[j] - sum[i-1];\\n        }\\n        int[] sum;\\n    }",
                "solutionTags": [
                    "Array"
                ],
                "code": "    public class NumArray {\\n    \\n        public NumArray(int[] nums) {\\n            int n = nums.length;\\n            if (n == 0) return;\\n            sum = new int[n];\\n            sum[0] = nums[0];\\n            for (int i = 1; i < n; i++) {\\n                sum[i] += sum[i-1] + nums[i];\\n            }\\n        }\\n    \\n        public int sumRange(int i, int j) {\\n            if (sum == null) return 0;\\n            if (i == 0) \\n                return sum[j];\\n            else \\n                return sum[j] - sum[i-1];\\n        }\\n        int[] sum;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 75227,
                "title": "dynamic-programming-bottom-up-approach-java-with-explanation",
                "content": "public class NumArray {\\n\\n    private int sum[][];\\n    \\n    public NumArray(int[] nums) {\\n        int n = nums.length;\\n        sum = new int[n][n];\\n\\n        //init the base case\\n        for (int i = 0; i < n; i++) {\\n            sum[i][i] = nums[i];\\n        }\\n\\n        // using dp, go diagonally and process all sums, O(n^2) time with O(n^2) space.\\n        for (int i = 0, d = 0; i < n; i++, d = 0) {\\n            for (int j = i + 1; j < n; j++, d++) {\\n                // current location equals the previous sum on the top left plus the nums[d].\\n                sum[d][j] = sum[d + 1][j] + sum[d][d];\\n            }\\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        return sum[i][j]; //O(1)\\n    }\\n\\n}\\n\\nI'm just posting this here in case anyone wanted to see a bottom up dynamic programming approach.\\n\\nI initially thought about this because I related it to subset-sum which is an NP-Complete problem.\\n\\nSince the problem mentioned dynamic programming, I started off with a bottom up approach instead of using memoization. \\n\\nIt has a O(n^2) init runtime/space. O(1) query.\\n\\nI saw other better solutions with O(n) init runtime/space and O(1) query.\\n\\nThis solution generates this 2d array:\\n\\n    -2 -2  1 -4 -2 -3\\n     0  0  3 -2  0 -1 \\n     0  0  3 -2  0 -1 \\n     0  0  0 -5 -3 -4 \\n     0  0  0  0  2  1 \\n     0  0  0  0  0 -1 \\n\\n    -2,  0,  3, -5,  2, -1\\n       -2,  3, -2, -3, 1\\n          1,  1,  0, -4 \\n            -4,  0, -1\\n              -2, -1\\n                -3",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "public class NumArray {\\n\\n    private int sum[][];\\n    \\n    public NumArray(int[] nums) {\\n        int n = nums.length;\\n        sum = new int[n][n];\\n\\n        //init the base case\\n        for (int i = 0; i < n; i++) {\\n            sum[i][i] = nums[i];\\n        }\\n\\n        // using dp, go diagonally and process all sums, O(n^2) time with O(n^2) space.\\n        for (int i = 0, d = 0; i < n; i++, d = 0) {\\n            for (int j = i + 1; j < n; j++, d++) {\\n                // current location equals the previous sum on the top left plus the nums[d].\\n                sum[d][j] = sum[d + 1][j] + sum[d][d];\\n            }\\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        return sum[i][j]; //O(1)\\n    }\\n\\n}\\n\\nI'm just posting this here in case anyone wanted to see a bottom up dynamic programming approach.\\n\\nI initially thought about this because I related it to subset-sum which is an NP-Complete problem.\\n\\nSince the problem mentioned dynamic programming, I started off with a bottom up approach instead of using memoization. \\n\\nIt has a O(n^2) init runtime/space. O(1) query.\\n\\nI saw other better solutions with O(n) init runtime/space and O(1) query.\\n\\nThis solution generates this 2d array:\\n\\n    -2 -2  1 -4 -2 -3\\n     0  0  3 -2  0 -1 \\n     0  0  3 -2  0 -1 \\n     0  0  0 -5 -3 -4 \\n     0  0  0  0  2  1 \\n     0  0  0  0  0 -1 \\n\\n    -2,  0,  3, -5,  2, -1\\n       -2,  3, -2, -3, 1\\n          1,  1,  0, -4 \\n            -4,  0, -1\\n              -2, -1\\n                -3",
                "codeTag": "Java"
            },
            {
                "id": 75292,
                "title": "accepted-python-solution",
                "content": "This solution is not a O(N) look at the comment \"# No O(N) cause\", i don't know why, can't use \"nums[0]\" before loop, i got error out of range, so stranger!\\n    \\n    def __init__(self, nums):\\n        \"\"\"\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        \"\"\"\\n        self.lists = [0]\\n        # error out of range when use nums[0] here\\n        # nums[0]\\n        for i, n in enumerate(nums):\\n            # No O(N) cause\\n            if i == 0:\\n                self.lists.append(nums[i])\\n            else:\\n                self.lists.append(self.lists[i] + n)\\n            \\n    def sumRange(self, i, j):\\n        \"\"\"\\n        sum of elements nums[i..j], inclusive.\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.lists[j+1] - self.lists[i]",
                "solutionTags": [
                    "Python"
                ],
                "code": "This solution is not a O(N) look at the comment \"# No O(N) cause\", i don't know why, can't use \"nums[0]\" before loop, i got error out of range, so stranger!\\n    \\n    def __init__(self, nums):\\n        \"\"\"\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        \"\"\"\\n        self.lists = [0]\\n        # error out of range when use nums[0] here\\n        # nums[0]\\n        for i, n in enumerate(nums):\\n            # No O(N) cause\\n            if i == 0:\\n                self.lists.append(nums[i])\\n            else:\\n                self.lists.append(self.lists[i] + n)\\n            \\n    def sumRange(self, i, j):\\n        \"\"\"\\n        sum of elements nums[i..j], inclusive.\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.lists[j+1] - self.lists[i]",
                "codeTag": "Python3"
            },
            {
                "id": 75327,
                "title": "c-java-python-o-n-build-o-1-query",
                "content": "The problem is easy. The array is not changing therefore we don't need a Binary Indexed Tree or Segment Tree. Prefix sums can do the trick perfectly.\\n\\nOne argument is that reusing the nums array for underlying data structure is not a good idea. We should allocate new memory to store the sums in the constructor.\\n\\n**Java**\\n\\n    private int[] sums;\\n\\n    public NumArray(int[] nums) {\\n        sums = new int[nums.length + 1];\\n        for (int i = 0; i < nums.length; ++i)\\n            sums[i + 1] = sums[i] + nums[i];\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        return sums[j + 1] - sums[i];\\n    }\\n\\n**Java with ArrayList**\\n\\n    private List<Integer> sums = new ArrayList<>(Collections.singletonList(0));\\n\\n    public NumArray(int[] nums) {\\n        for (int x : nums)\\n            sums.add(sums.get(sums.size() - 1) + x);\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        return sums.get(j + 1) - sums.get(i);\\n    }\\n\\n\\n**C++**\\n\\n    vector<int> sums = {0};\\n    NumArray(vector<int> &nums) {\\n        for (auto x: nums)\\n            sums.push_back(sums.back() + x);\\n    }\\n    int sumRange(int i, int j) {\\n        return sums[j + 1] - sums[i];\\n    }\\n\\n**Python**\\n\\n    def __init__(self, nums):\\n        self.sums = [0]\\n        for x in nums:\\n            self.sums.append(self.sums[-1] + x)\\n\\n    def sumRange(self, i, j):\\n        return self.sums[j + 1] - self.sums[i]",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "The problem is easy. The array is not changing therefore we don't need a Binary Indexed Tree or Segment Tree. Prefix sums can do the trick perfectly.\\n\\nOne argument is that reusing the nums array for underlying data structure is not a good idea. We should allocate new memory to store the sums in the constructor.\\n\\n**Java**\\n\\n    private int[] sums;\\n\\n    public NumArray(int[] nums) {\\n        sums = new int[nums.length + 1];\\n        for (int i = 0; i < nums.length; ++i)\\n            sums[i + 1] = sums[i] + nums[i];\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        return sums[j + 1] - sums[i];\\n    }\\n\\n**Java with ArrayList**\\n\\n    private List<Integer> sums = new ArrayList<>(Collections.singletonList(0));\\n\\n    public NumArray(int[] nums) {\\n        for (int x : nums)\\n            sums.add(sums.get(sums.size() - 1) + x);\\n    }\\n\\n    public int sumRange(int i, int j) {\\n        return sums.get(j + 1) - sums.get(i);\\n    }\\n\\n\\n**C++**\\n\\n    vector<int> sums = {0};\\n    NumArray(vector<int> &nums) {\\n        for (auto x: nums)\\n            sums.push_back(sums.back() + x);\\n    }\\n    int sumRange(int i, int j) {\\n        return sums[j + 1] - sums[i];\\n    }\\n\\n**Python**\\n\\n    def __init__(self, nums):\\n        self.sums = [0]\\n        for x in nums:\\n            self.sums.append(self.sums[-1] + x)\\n\\n    def sumRange(self, i, j):\\n        return self.sums[j + 1] - self.sums[i]",
                "codeTag": "Python3"
            },
            {
                "id": 4015571,
                "title": "prefix-sum-solution-with-step-by-step-explanation",
                "content": "# Intuition\\nFor this problem we would use prefix sum.\\n\\n# Approach\\nIn class NumArray we declare prefix array field, and in constructor we initiate it and calculaye prefix sum for nums array. In sumRange method we just return difference between right prfix sum and left.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> we iterate once for nums array\\n\\n- Space complexity:\\nO(n) -> we create prefix sum array of nums length + 1\\n# Code\\n```\\nclass NumArray {\\n    // declare prefix array field\\n    int[] prefix;\\n    public NumArray(int[] nums) {\\n        // initialize prefix sum array with nums length + 1\\n        prefix = new int[nums.length + 1];\\n        // iterate over nums array\\n        for(int i = 0; i < nums.length; i++) {\\n            // calculate prefix sum on each iteration\\n            prefix[i + 1] = prefix[i] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        // return difference between right and left prefix sum\\n        return prefix[right + 1] - prefix[left];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    // declare prefix array field\\n    int[] prefix;\\n    public NumArray(int[] nums) {\\n        // initialize prefix sum array with nums length + 1\\n        prefix = new int[nums.length + 1];\\n        // iterate over nums array\\n        for(int i = 0; i < nums.length; i++) {\\n            // calculate prefix sum on each iteration\\n            prefix[i + 1] = prefix[i] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        // return difference between right and left prefix sum\\n        return prefix[right + 1] - prefix[left];\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3684449,
                "title": "c-using-prefix-sum-t-c-o-n-o-1-s-c-o-n",
                "content": "```\\nclass NumArray {\\n    \\n    /*\\n        Time Complexity : O(N) + O(1)\\n        Space Complexity : O(N)\\n    */\\n    \\nprivate:\\n    vector<int> prefixSum;\\n    \\npublic:\\n    NumArray(vector<int>& nums) {\\n        prefixSum.resize(nums.size());\\n        \\n        prefixSum[0] = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left == 0){\\n            return prefixSum[right];\\n        }\\n        \\n        return prefixSum[right] - prefixSum[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    \\n    /*\\n        Time Complexity : O(N) + O(1)\\n        Space Complexity : O(N)\\n    */\\n    \\nprivate:\\n    vector<int> prefixSum;\\n    \\npublic:\\n    NumArray(vector<int>& nums) {\\n        prefixSum.resize(nums.size());\\n        \\n        prefixSum[0] = nums[0];\\n        \\n        for(int i=1; i<nums.size(); i++){\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left == 0){\\n            return prefixSum[right];\\n        }\\n        \\n        return prefixSum[right] - prefixSum[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3605565,
                "title": "clean-code-using-prefix-sum-beats-97-13",
                "content": "## ***Please Upvote my solution, if you find it helpful ;)***\\n\\n# Intuition\\nThe problem requires calculating the sum of elements within a given range repeatedly. To optimize the time complexity, we can precompute the prefix sum array. This array will store the cumulative sum of elements up to each index. Then, to calculate the sum within a range, we can subtract the prefix sum at the starting index from the prefix sum at the ending index.\\n\\n# Approach\\n1. In the constructor, we initialize an array called answer to store the prefix sums of the input array.\\n1. We iterate over the input array and calculate the prefix sum at each index by adding the current element to the prefix sum of the previous index.\\n1. To calculate the range sum between left and right, we subtract the prefix sum at index left-1 from the prefix sum at index right.\\n1. If left is 0, we return the prefix sum at index right directly since there is no prefix sum before index 0.\\n1. Finally, we return the calculated range sum.\\n\\n# Complexity\\n- Time complexity:\\nThe initialization step in the constructor takes $$O(n)$$ time, where n is the length of the input array. Each range sum query in the sumRange method takes $$O(1)$$ time since it involves only constant-time subtractions.\\n- Space complexity:\\nThe space complexity is $$O(n)$$ since we use an additional array answer to store the prefix sums, where n is the length of the input array.\\n# Code\\n```\\nclass NumArray {\\n    int[] answer;\\n    \\n    public NumArray(int[] nums) {\\n        answer = new int[nums.length];\\n        int n = nums.length;\\n        answer[0] = nums[0];\\n        \\n        // Calculate prefix sums for the input array\\n        for (int i = 1; i < n; i++) {\\n            answer[i] = nums[i] + answer[i - 1];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        // Calculate the range sum using prefix sums\\n        \\n        if (left == 0) {\\n            return answer[right];\\n        }\\n        return answer[right] - answer[left - 1];\\n    }\\n}\\n```\\n***Please Upvote my solution, if you find it helpful ;)***\\n![6a87bc25-d70b-424f-9e60-7da6f345b82a_1673875931.8933976.jpeg](https://assets.leetcode.com/users/images/8d695c6c-86d8-4a70-8d9e-19496759655d_1686068201.7162793.jpeg)\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    int[] answer;\\n    \\n    public NumArray(int[] nums) {\\n        answer = new int[nums.length];\\n        int n = nums.length;\\n        answer[0] = nums[0];\\n        \\n        // Calculate prefix sums for the input array\\n        for (int i = 1; i < n; i++) {\\n            answer[i] = nums[i] + answer[i - 1];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        // Calculate the range sum using prefix sums\\n        \\n        if (left == 0) {\\n            return answer[right];\\n        }\\n        return answer[right] - answer[left - 1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057568,
                "title": "dart-solution",
                "content": "# Code\\n```\\nclass NumArray {\\n  List<int> arr = [];\\n\\n  NumArray(List<int> nums) {\\n    List<int> sums = [];\\n    var currentSum = 0;\\n    for (var num in nums) {\\n      currentSum += num;\\n      sums.add(currentSum);\\n    }\\n    arr = sums;\\n  }\\n\\n  int sumRange(int left, int right) {\\n    if (left == 0) {\\n      return arr[right];\\n    }\\n    return arr[right] - arr[left - 1];\\n  }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = NumArray(nums);\\n * int param1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass NumArray {\\n  List<int> arr = [];\\n\\n  NumArray(List<int> nums) {\\n    List<int> sums = [];\\n    var currentSum = 0;\\n    for (var num in nums) {\\n      currentSum += num;\\n      sums.add(currentSum);\\n    }\\n    arr = sums;\\n  }\\n\\n  int sumRange(int left, int right) {\\n    if (left == 0) {\\n      return arr[right];\\n    }\\n    return arr[right] - arr[left - 1];\\n  }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = NumArray(nums);\\n * int param1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3019454,
                "title": "accepted-swift",
                "content": "```\\nclass NumArray {\\n    \\n    private let nums: [Int]\\n\\n    init(_ nums: [Int]) {\\n        self.nums = nums\\n    }\\n    \\n    func sumRange(_ left: Int, _ right: Int) -> Int {\\n        nums[left...right].reduce(0, +)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass NumArray {\\n    \\n    private let nums: [Int]\\n\\n    init(_ nums: [Int]) {\\n        self.nums = nums\\n    }\\n    \\n    func sumRange(_ left: Int, _ right: Int) -> Int {\\n        nums[left...right].reduce(0, +)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2916819,
                "title": "easy-to-understand-c-solution-prefix-sum-na-ve-approach",
                "content": "## Code: Na\\xEFve Approach\\n```\\nclass NumArray {\\npublic:\\n    vector<int> nums;\\n    NumArray(vector<int>& nums) {\\n        for (auto val: nums){\\n            (this->nums).push_back(val);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int sum=0;\\n        for (int i= left; i<=right; i++)sum+= nums[i];\\n        return sum;\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```\\n### Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n---\\n\\n\\n## Code: Prefix Sum\\n```\\nclass NumArray {\\nprivate:\\n    vector<int> pref;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        pref.push_back(nums[0]);\\n        for (int i=1; i<nums.size(); i++){\\n            pref.push_back(pref[i-1]+nums[i]);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if (left==0){\\n            return pref[right];\\n        }\\n        return pref[right]-pref[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```\\n\\n### Complexity\\n- Time complexity: O(1) for call, O(N) on initialisation\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Design",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> nums;\\n    NumArray(vector<int>& nums) {\\n        for (auto val: nums){\\n            (this->nums).push_back(val);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        int sum=0;\\n        for (int i= left; i<=right; i++)sum+= nums[i];\\n        return sum;\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```\n```\\nclass NumArray {\\nprivate:\\n    vector<int> pref;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        pref.push_back(nums[0]);\\n        for (int i=1; i<nums.size(); i++){\\n            pref.push_back(pref[i-1]+nums[i]);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if (left==0){\\n            return pref[right];\\n        }\\n        return pref[right]-pref[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2826445,
                "title": "java-simple-solution",
                "content": "# Code\\n```\\nclass NumArray {\\n    int[] arr;\\n    public NumArray(int[] nums) {\\n        arr = nums;\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        for (int i = left; i <= right; i++) sum += arr[i];\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n    int[] arr;\\n    public NumArray(int[] nums) {\\n        arr = nums;\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        int sum = 0;\\n        for (int i = left; i <= right; i++) sum += arr[i];\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812741,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n\\n   class NumArray { \\npublic:\\n    vector<int>& preSum; \\n    \\n    NumArray(vector<int>& nums) : preSum(nums) {\\n        for (int i = 1; i < preSum.size(); ++i)\\n            preSum[i] += preSum[i-1]; \\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if (left == 0) return preSum[right];\\n        return preSum[right] - preSum[left-1];\\n    }\\n};\\n\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\n   class NumArray { \\npublic:\\n    vector<int>& preSum; \\n    \\n    NumArray(vector<int>& nums) : preSum(nums) {\\n        for (int i = 1; i < preSum.size(); ++i)\\n            preSum[i] += preSum[i-1]; \\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if (left == 0) return preSum[right];\\n        return preSum[right] - preSum[left-1];\\n    }\\n};\\n\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698174,
                "title": "typescript-prefix-sum",
                "content": "# Intuition\\nhave a way to cache query, since the question says the query function would have a lot of hits\\n\\n\\n# Approach\\nCreate pre-calculated sums (prefix-sum) and use that to derive sums for each query\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ for creation \\n$$O(1)$$ for query \\n \\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass NumArray {\\n    private nums : number[];\\n    private prefixSum: number[];\\n    constructor(nums: number[]) {\\n        this.nums = nums;\\n        this.prefixSum = [0]\\n        // num --> [-2,0,3,-5,2,-1]\\n        // prefixSum --> [0,-2,-2,1,-4,-2,-3]\\n        for(let i = 0; i < nums.length;i++){\\n            this.prefixSum[i+1] = this.prefixSum[i] + this.nums[i]\\n        }\\n    }\\n\\n    sumRange(left: number, right: number): number {\\n        return  this.prefixSum[right+1] -  this.prefixSum[left]\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * var obj = new NumArray(nums)\\n * var param_1 = obj.sumRange(left,right)\\n */\\n```",
                "solutionTags": [
                    "TypeScript",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    private nums : number[];\\n    private prefixSum: number[];\\n    constructor(nums: number[]) {\\n        this.nums = nums;\\n        this.prefixSum = [0]\\n        // num --> [-2,0,3,-5,2,-1]\\n        // prefixSum --> [0,-2,-2,1,-4,-2,-3]\\n        for(let i = 0; i < nums.length;i++){\\n            this.prefixSum[i+1] = this.prefixSum[i] + this.nums[i]\\n        }\\n    }\\n\\n    sumRange(left: number, right: number): number {\\n        return  this.prefixSum[right+1] -  this.prefixSum[left]\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * var obj = new NumArray(nums)\\n * var param_1 = obj.sumRange(left,right)\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2576594,
                "title": "c-solution",
                "content": "class NumArray {\\npublic: vector<int>nums;\\n    NumArray(vector<int>& nums) {\\n        this->nums = nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return accumulate(this->nums.begin()+left, this->nums.begin()+right+1, 0);\\n    }\\n};\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "class NumArray {\\npublic: vector<int>nums;\\n    NumArray(vector<int>& nums) {\\n        this->nums = nums;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return accumulate(this->nums.begin()+left, this->nums.begin()+right+1, 0);\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 2474605,
                "title": "javascript-straightforward-class-solution",
                "content": "```\\nclass NumArray {\\n    data = [];\\n\\n    constructor(numbers) {\\n        this.data = numbers;\\n    }\\n\\n    sumRange(left, right) {\\n        let sum = 0;\\n\\n        for (let i = left; i <= right; i++) {\\n            sum += this.data[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass NumArray {\\n    data = [];\\n\\n    constructor(numbers) {\\n        this.data = numbers;\\n    }\\n\\n    sumRange(left, right) {\\n        let sum = 0;\\n\\n        for (let i = left; i <= right; i++) {\\n            sum += this.data[i];\\n        }\\n\\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401393,
                "title": "python-easy-one-liner-solution-beats-90",
                "content": "**Python Easy One liner Solution**\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return sum(self.nums[left:right+1])\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return sum(self.nums[left:right+1])\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2326150,
                "title": "range-sum-query-using-segment-tree-cpp-solution",
                "content": "![image](https://assets.leetcode.com/users/images/a566658d-e90f-4ad7-8547-a1c7cc153b78_1658650817.0123808.jpeg)\\n![image](https://assets.leetcode.com/users/images/ca86eb8e-29d7-4cdb-b2c8-dd0cbb7bf95b_1658650780.442661.jpeg)\\n```\\nclass NumArray {\\npublic:\\n    vector<int> seg;\\n    int n;\\n    void build(int index,vector<int>& nums,int l,int r){\\n        if(l==r){\\n            seg[index] = nums[l];\\n            return;\\n        }\\n        int mid = (l+r)/2;\\n        build(2*index+1,nums,l,mid);\\n        build(2*index+2,nums,mid+1,r);\\n        seg[index] = seg[2*index+1]+seg[2*index+2];\\n    }\\n    int getSum(int index,int sl,int sr,int l,int r){\\n        if(sr<l or sl>r) return 0;//no over-lap\\n        if(sl>=l and sr<=r) return seg[index];//completly overlap\\n        //partial overlap\\n        int mid = (sl+sr)/2;\\n        int left = getSum(2*index+1,sl,mid,l,r);\\n        int right = getSum(2*index+2,mid+1,sr,l,r);\\n        return left+right;\\n    }\\n    NumArray(vector<int>& nums) {\\n        n = nums.size();\\n        seg.resize(n*4);\\n        build(0,nums,0,n-1);\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return getSum(0,0,n-1,left,right);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> seg;\\n    int n;\\n    void build(int index,vector<int>& nums,int l,int r){\\n        if(l==r){\\n            seg[index] = nums[l];\\n            return;\\n        }\\n        int mid = (l+r)/2;\\n        build(2*index+1,nums,l,mid);\\n        build(2*index+2,nums,mid+1,r);\\n        seg[index] = seg[2*index+1]+seg[2*index+2];\\n    }\\n    int getSum(int index,int sl,int sr,int l,int r){\\n        if(sr<l or sl>r) return 0;//no over-lap\\n        if(sl>=l and sr<=r) return seg[index];//completly overlap\\n        //partial overlap\\n        int mid = (sl+sr)/2;\\n        int left = getSum(2*index+1,sl,mid,l,r);\\n        int right = getSum(2*index+2,mid+1,sr,l,r);\\n        return left+right;\\n    }\\n    NumArray(vector<int>& nums) {\\n        n = nums.size();\\n        seg.resize(n*4);\\n        build(0,nums,0,n-1);\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return getSum(0,0,n-1,left,right);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2212693,
                "title": "python-simple-python-solution-using-two-approach",
                "content": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# First Solution Using Prefix Sum -\\n\\tclass NumArray:\\n\\n\\t\\tdef __init__(self, nums: List[int]):\\n\\t\\t\\tself.nums = nums\\n\\t\\t\\tif len(self.nums) == 0:\\n\\t\\t\\t\\treturn None\\n\\n\\t\\t\\tself.dp = [0]*(len(self.nums))\\n\\t\\t\\ts = 0\\n\\t\\t\\tj = 0\\n\\t\\t\\tfor i in self.nums:\\n\\t\\t\\t\\ts = s + i\\n\\t\\t\\t\\tself.dp[j] = s\\n\\t\\t\\t\\tj = j + 1\\n\\n\\t\\tdef sumRange(self, i: int, j: int) -> int:\\n\\t\\t\\tif i == 0:\\n\\t\\t\\t\\treturn self.dp[j]\\n\\t\\t\\treturn self.dp[j] - self.dp[i-1]\\n\\n# Second Solution -\\n\\n\\tclass NumArray:\\n\\n\\t\\tdef __init__(self, nums: List[int]):\\n\\n\\t\\t\\tself.array = nums\\n\\n\\t\\tdef sumRange(self, left: int, right: int) -> int:\\n\\n\\t\\t\\tresult = sum(self.array[left:right+1])\\n\\n\\t\\t\\treturn result",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "# If you like the solution, please upvote! \\uD83D\\uDD3C\\uD83D\\uDE4F\\n# First Solution Using Prefix Sum -\\n\\tclass NumArray:\\n\\n\\t\\tdef __init__(self, nums: List[int]):\\n\\t\\t\\tself.nums = nums\\n\\t\\t\\tif len(self.nums) == 0:\\n\\t\\t\\t\\treturn None\\n\\n\\t\\t\\tself.dp = [0]*(len(self.nums))\\n\\t\\t\\ts = 0\\n\\t\\t\\tj = 0\\n\\t\\t\\tfor i in self.nums:\\n\\t\\t\\t\\ts = s + i\\n\\t\\t\\t\\tself.dp[j] = s\\n\\t\\t\\t\\tj = j + 1\\n\\n\\t\\tdef sumRange(self, i: int, j: int) -> int:\\n\\t\\t\\tif i == 0:\\n\\t\\t\\t\\treturn self.dp[j]\\n\\t\\t\\treturn self.dp[j] - self.dp[i-1]\\n\\n# Second Solution -\\n\\n\\tclass NumArray:\\n\\n\\t\\tdef __init__(self, nums: List[int]):\\n\\n\\t\\t\\tself.array = nums\\n\\n\\t\\tdef sumRange(self, left: int, right: int) -> int:\\n\\n\\t\\t\\tresult = sum(self.array[left:right+1])\\n\\n\\t\\t\\treturn result",
                "codeTag": "Java"
            },
            {
                "id": 2105333,
                "title": "c-prefix-sum",
                "content": "```\\nclass NumArray {\\npublic:\\n    vector<int> sum;\\n    NumArray(vector<int>& nums) {\\n        int total=0;\\n        sum.emplace_back(0);\\n        for(auto i: nums){\\n            total += i;\\n            sum.emplace_back(total);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return sum[right+1] - sum[left];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> sum;\\n    NumArray(vector<int>& nums) {\\n        int total=0;\\n        sum.emplace_back(0);\\n        for(auto i: nums){\\n            total += i;\\n            sum.emplace_back(total);\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return sum[right+1] - sum[left];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1986451,
                "title": "java-optimized-solution-using-prefix-sum-approach",
                "content": "\\nclass NumArray {\\n\\n    private int[] nums;\\n    private int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        this.nums=nums;\\n        this.prefixSum= calculatePrefixSum();\\n    }\\n\\n    private int[] calculatePrefixSum(){\\n        int[] arr = new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+= nums[i];\\n            arr[i]=sum;\\n        }\\n        return arr;\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if(left>0){\\n            return prefixSum[right]-prefixSum[left-1];\\n        } else{\\n            return prefixSum[right];\\n        }\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "\\nclass NumArray {\\n\\n    private int[] nums;\\n    private int[] prefixSum;\\n\\n    public NumArray(int[] nums) {\\n        this.nums=nums;\\n        this.prefixSum= calculatePrefixSum();\\n    }\\n\\n    private int[] calculatePrefixSum(){\\n        int[] arr = new int[nums.length];\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+= nums[i];\\n            arr[i]=sum;\\n        }\\n        return arr;\\n    }\\n\\n    public int sumRange(int left, int right) {\\n        if(left>0){\\n            return prefixSum[right]-prefixSum[left-1];\\n        } else{\\n            return prefixSum[right];\\n        }\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 1924208,
                "title": "c-segment-tree",
                "content": "Did this in segment tree just for practicing. Prefix sum would be faster.\\n```\\nclass NumArray {\\npublic:\\n    vector<int> seg;\\n    int size;\\n    NumArray(vector<int>& nums) {\\n        size = nums.size();\\n        seg.resize(size*4, 0);\\n        \\n        build(nums, 0, 0, size-1);\\n    }\\n    \\n    void build(vector<int>& nums, int v, int left, int right){\\n        if(left==right){\\n            seg[v]=nums[left];\\n        }else{\\n            int mid = left+(right-left)/2;\\n            build(nums, 2*v+1, left, mid);\\n            build(nums, 2*v+2, mid+1, right);\\n            seg[v]=seg[v*2+1]+seg[v*2+2];\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return sum(left, right, 0, 0, size-1);\\n    }\\n    \\n    int sum(int left, int right, int v, int l, int r){\\n        if(left>right){\\n            return 0;\\n        }\\n        if(l==left && r==right){\\n            return seg[v];\\n        }\\n        \\n        int mid=l+(r-l)/2;\\n        \\n        return sum(left, min(right, mid), v*2+1, l, mid)+sum(max(mid+1, left), right, v*2+2, mid+1, r);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> seg;\\n    int size;\\n    NumArray(vector<int>& nums) {\\n        size = nums.size();\\n        seg.resize(size*4, 0);\\n        \\n        build(nums, 0, 0, size-1);\\n    }\\n    \\n    void build(vector<int>& nums, int v, int left, int right){\\n        if(left==right){\\n            seg[v]=nums[left];\\n        }else{\\n            int mid = left+(right-left)/2;\\n            build(nums, 2*v+1, left, mid);\\n            build(nums, 2*v+2, mid+1, right);\\n            seg[v]=seg[v*2+1]+seg[v*2+2];\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return sum(left, right, 0, 0, size-1);\\n    }\\n    \\n    int sum(int left, int right, int v, int l, int r){\\n        if(left>right){\\n            return 0;\\n        }\\n        if(l==left && r==right){\\n            return seg[v];\\n        }\\n        \\n        int mid=l+(r-l)/2;\\n        \\n        return sum(left, min(right, mid), v*2+1, l, mid)+sum(max(mid+1, left), right, v*2+2, mid+1, r);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1831760,
                "title": "rust",
                "content": "```rust\\nstruct NumArray {\\n    prev_sum: Vec<i32>,\\n}\\n\\n/**\\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl NumArray {\\n    fn new(nums: Vec<i32>) -> Self {\\n        let mut prev_sum = vec![0; nums.len() + 1];\\n        for i in 0..nums.len() {\\n            prev_sum[i + 1] = prev_sum[i] + nums[i];\\n        }\\n        Self { prev_sum }\\n    }\\n\\n    fn sum_range(&self, left: i32, right: i32) -> i32 {\\n        self.prev_sum[right as usize + 1] - self.prev_sum[left as usize]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nstruct NumArray {\\n    prev_sum: Vec<i32>,\\n}\\n\\n/**\\n * `&self` means the method takes an immutable reference.\\n * If you need a mutable reference, change it to `&mut self` instead.\\n */\\nimpl NumArray {\\n    fn new(nums: Vec<i32>) -> Self {\\n        let mut prev_sum = vec![0; nums.len() + 1];\\n        for i in 0..nums.len() {\\n            prev_sum[i + 1] = prev_sum[i] + nums[i];\\n        }\\n        Self { prev_sum }\\n    }\\n\\n    fn sum_range(&self, left: i32, right: i32) -> i32 {\\n        self.prev_sum[right as usize + 1] - self.prev_sum[left as usize]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1786869,
                "title": "prefix-sum-python",
                "content": "```\\ndef __init__(self, nums: List[int]):\\n        self.prefixSum = [nums[0]]  \\n        #Creating Prefix Sum array \\n        # To avoid traversing array for each query \\n        for i in range(1,len(nums)):\\n            self.prefixSum.append(self.prefixSum[i-1] + nums[i])\\n            \\n    def sumRange(self, L: int, R: int) -> int:\\n        # if L==0 return prefixSum[right]\\n        # else prefixSum[right]- prefixSum[left-1] beacuse to avoid prefix sum of element from the starting of the array\\n        return self.prefixSum[R] - self.prefixSum[L-1] if L>0 else self.prefixSum[R] \\n",
                "solutionTags": [],
                "code": "```\\ndef __init__(self, nums: List[int]):\\n        self.prefixSum = [nums[0]]  \\n        #Creating Prefix Sum array \\n        # To avoid traversing array for each query \\n        for i in range(1,len(nums)):\\n            self.prefixSum.append(self.prefixSum[i-1] + nums[i])\\n            \\n    def sumRange(self, L: int, R: int) -> int:\\n        # if L==0 return prefixSum[right]\\n        # else prefixSum[right]- prefixSum[left-1] beacuse to avoid prefix sum of element from the starting of the array\\n        return self.prefixSum[R] - self.prefixSum[L-1] if L>0 else self.prefixSum[R] \\n",
                "codeTag": "Python3"
            },
            {
                "id": 1767181,
                "title": "c-prefix-sum-method-with-detailed-explanation",
                "content": "The idea of the Prefix Sum array can be applied here. We accumulate the values of nums[i] into a new vector arr such that arr[i] carries the sum of values in the range[0,i] (i.e. inclusively).\\n\\nHence, given a range [left, right] whose sum we want, we can use this property of the prefix sum. The sum of values from nums[left] to nums[right] (inclusive) can be computed by the difference `arr[right] - arr[left-1]`.\\n\\n**Why arr[left-1], and not just arr[left]?**\\n`arr[right]` will be storing the sum of values from [0,right]. `arr[left]` will be storing the sum of values from [0,left]. Now, we just want to remove the accumulated sum from elements before left (which will render us the sum of elements in range [left,right]).\\n\\nIf we subtract `arr[left]`, then we will also be removing the value `nums[left]` from the total sum because `arr[left] = nums[0] + nums[1] + .... + nums[left]`. Hence, we rather subtract `arr[left-1]`, meaning we remove only values uptil `nums[left-1]`, and not `nums[left]` as well.\\n\\nHence, `arr[right] - arr[left] = nums[left] + nums[left+1] + .... + nums[right]`.\\n```\\nclass NumArray {\\npublic:\\n\\tvector<int>& arr; // by reference rather than by copy (hence memory is now O(1))\\n    \\n    NumArray(vector<int>& nums) : arr(nums) {\\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            arr[i] = arr[i-1] + nums[i];\\n        }\\n    }\\n\\t\\n    int sumRange(int left, int right) {\\n        if(left == 0) return arr[right];\\n        \\n        return arr[right] - arr[left-1];\\n        // we do \\'left-1\\' because arr[left] will also include the val of nums[left]\\n        // and hence we will end up subtracting that value as well, whereas we just\\n        // wanted to remove values uptil nums[left-1].\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n\\tvector<int>& arr; // by reference rather than by copy (hence memory is now O(1))\\n    \\n    NumArray(vector<int>& nums) : arr(nums) {\\n        for(int i = 1; i < nums.size(); i++)\\n        {\\n            arr[i] = arr[i-1] + nums[i];\\n        }\\n    }\\n\\t\\n    int sumRange(int left, int right) {\\n        if(left == 0) return arr[right];\\n        \\n        return arr[right] - arr[left-1];\\n        // we do \\'left-1\\' because arr[left] will also include the val of nums[left]\\n        // and hence we will end up subtracting that value as well, whereas we just\\n        // wanted to remove values uptil nums[left-1].\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1765551,
                "title": "presum-list-python3",
                "content": "Construct the instance takes O(N), but the sumRange is O(1), given that sumRange would be called multiple times, it is worth it to pre-calculated the presum list. The first element is zero becuase the sum before the 0 index num is zero,\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        accu_sum = 0\\n        self._pre_sum = [0,]\\n        for num in nums:\\n            accu_sum += num\\n            self._pre_sum.append(accu_sum)\\n            \\n    def sumRange(self, left: int, right: int) -> int:\\n        return self._pre_sum[right+1] - self._pre_sum[left]\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        accu_sum = 0\\n        self._pre_sum = [0,]\\n        for num in nums:\\n            accu_sum += num\\n            self._pre_sum.append(accu_sum)\\n            \\n    def sumRange(self, left: int, right: int) -> int:\\n        return self._pre_sum[right+1] - self._pre_sum[left]\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1540785,
                "title": "c-easy",
                "content": "```\\nclass NumArray {\\npublic:\\n    vector<int>s;\\n    NumArray(vector<int>& nums) {\\n        s=nums;\\n        for(int i=1;i<nums.size();i++)s[i]=s[i-1]+nums[i];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(!left) return s[right];\\n        return s[right]-s[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int>s;\\n    NumArray(vector<int>& nums) {\\n        s=nums;\\n        for(int i=1;i<nums.size();i++)s[i]=s[i-1]+nums[i];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(!left) return s[right];\\n        return s[right]-s[left-1];\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1489427,
                "title": "java-fastest-easiest",
                "content": "```\\nclass NumArray {\\n    int sums[];\\n    public NumArray(int[] nums) {\\n      this.prefix=new int[nums.length];\\n      fillPrefixArr(nums);  \\n    }\\n    public void fillPrefixArr(int []nums){\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            this.sums[i]=sum;\\n        }\\n    }\\n    public int sumRange(int left, int right) {\\n                      //this will give the sum of range\\n    //sum of higher range - sum of (lower range-1)(bcoz we also need lower range\\'s element)\\n        return left> 0 ?sums[right]-sums[left-1]:sums[right];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n    int sums[];\\n    public NumArray(int[] nums) {\\n      this.prefix=new int[nums.length];\\n      fillPrefixArr(nums);  \\n    }\\n    public void fillPrefixArr(int []nums){\\n        int sum=0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            this.sums[i]=sum;\\n        }\\n    }\\n    public int sumRange(int left, int right) {\\n                      //this will give the sum of range\\n    //sum of higher range - sum of (lower range-1)(bcoz we also need lower range\\'s element)\\n        return left> 0 ?sums[right]-sums[left-1]:sums[right];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1426429,
                "title": "faster-than-100-java-solutions-prefix-sum",
                "content": "\\n```\\nclass NumArray {\\n    \\n    int[] arr;\\n    \\n    public NumArray(int[] nums) {\\n        arr= new int[nums.length+1];\\n        int j=1;\\n        for(int i: nums){\\n            arr[j]=arr[j-1]+i;\\n            j++;\\n        }    \\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return arr[right+1]-arr[left];\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\n    \\n    int[] arr;\\n    \\n    public NumArray(int[] nums) {\\n        arr= new int[nums.length+1];\\n        int j=1;\\n        for(int i: nums){\\n            arr[j]=arr[j-1]+i;\\n            j++;\\n        }    \\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return arr[right+1]-arr[left];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417475,
                "title": "python-o-n-space-o-1-tc-using-prefix-sums",
                "content": "*idea*:\\nCalculating the sum from i to j, is the same as calculating the difference between sum[0:j] - sum[0:i], where the elements of i and j are inclusive\\n\\nWith that idea, we can implement it by pre calculating an array, the holds the SumSoFar from 0 up to the current index.\\ne.g\\nnums = [1,2,3,4]\\npreFixSum = [0,1,3,6,10] \\n\\nwhen i = 1, and j =2\\nsumrange of nums[1]+nums[2] = prefixSum[2+1]-prefixsum[1] = 6-1 = 5\\n\\n\\n```python\\nclass NumArray:\\n    \\n    nums = None\\n    prefixSum = None\\n    \\n    def __init__(self, nums: List[int]):\\n        self.nums = nums.copy()\\n        self.prefixSum = [0] * (len(nums)+1)\\n        currentsum=0\\n        for i in range(0,len(nums)):\\n            currentsum+=nums[i]\\n            self.prefixSum[i+1] = currentsum\\n            \\n            \\'\\'\\'\\n            [1,2,3,4]\\n            [0,1,3,6,10] prefix\\n            [1,3] = prefix[right+1] - prefix[1] = 10-1 = 5\\n            \\'\\'\\'\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefixSum[right+1] - self.prefixSum[left]\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass NumArray:\\n    \\n    nums = None\\n    prefixSum = None\\n    \\n    def __init__(self, nums: List[int]):\\n        self.nums = nums.copy()\\n        self.prefixSum = [0] * (len(nums)+1)\\n        currentsum=0\\n        for i in range(0,len(nums)):\\n            currentsum+=nums[i]\\n            self.prefixSum[i+1] = currentsum\\n            \\n            \\'\\'\\'\\n            [1,2,3,4]\\n            [0,1,3,6,10] prefix\\n            [1,3] = prefix[right+1] - prefix[1] = 10-1 = 5\\n            \\'\\'\\'\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefixSum[right+1] - self.prefixSum[left]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407479,
                "title": "segment-tree-solution-20-ms-17-2mb",
                "content": "```\\nclass NumArray {\\npublic:\\n    int* tree;\\n    int size;\\n\\n    NumArray(vector<int>& nums) {\\n        // build\\n        size = nums.size();\\n        init_tree(size);\\n\\n        build_tree(nums, 1, 0, nums.size()-1);\\n    }\\n\\n    void init_tree(int size) {\\n        tree = new int[4*size];\\n    }\\n\\n    void build_tree(vector<int>& nums, int node, int b, int e) {\\n        // sum from b till e will be in tree[node]\\n\\n        if (b == e) {\\n            tree[node] = nums[b];\\n            return;\\n        }\\n\\n        int mid = (b+e)/2;\\n        int left = 2*node;\\n        int right = 2*node+1;\\n\\n        build_tree(nums, left, b, mid);\\n        build_tree(nums, right, mid+1, e);\\n\\n        // fetch sum from subordinate nodes\\n        tree[node] = tree[left]+tree[right];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        // query\\n        int ans = query(1, 0, size-1, left, right);\\n\\n        return ans;\\n    }\\n\\n    int query(int node, int b, int e, int i, int j) {\\n        // current node contains sum from index b to index e\\n        // looking for the sum from index i to index j\\n\\n        // this node contains the range sum that is not included in desired range\\n        if (i > e or j < b) return 0;\\n\\n        // this node contains the range sum that is a subrange of the desired range\\n        if (i <= b and e <= j) return tree[node];\\n\\n        // oterwise go to the subordinate nodes\\n        int mid = (b+e)/2;\\n        int left = 2*node;\\n        int right = 2*node+1;\\n\\n        int ret1 = query(left, b, mid, i, j);\\n        int ret2 = query(right, mid+1, e, i, j);\\n\\n        // return the sum got from the subordinate nodes\\n        return ret1+ret2;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    int* tree;\\n    int size;\\n\\n    NumArray(vector<int>& nums) {\\n        // build\\n        size = nums.size();\\n        init_tree(size);\\n\\n        build_tree(nums, 1, 0, nums.size()-1);\\n    }\\n\\n    void init_tree(int size) {\\n        tree = new int[4*size];\\n    }\\n\\n    void build_tree(vector<int>& nums, int node, int b, int e) {\\n        // sum from b till e will be in tree[node]\\n\\n        if (b == e) {\\n            tree[node] = nums[b];\\n            return;\\n        }\\n\\n        int mid = (b+e)/2;\\n        int left = 2*node;\\n        int right = 2*node+1;\\n\\n        build_tree(nums, left, b, mid);\\n        build_tree(nums, right, mid+1, e);\\n\\n        // fetch sum from subordinate nodes\\n        tree[node] = tree[left]+tree[right];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        // query\\n        int ans = query(1, 0, size-1, left, right);\\n\\n        return ans;\\n    }\\n\\n    int query(int node, int b, int e, int i, int j) {\\n        // current node contains sum from index b to index e\\n        // looking for the sum from index i to index j\\n\\n        // this node contains the range sum that is not included in desired range\\n        if (i > e or j < b) return 0;\\n\\n        // this node contains the range sum that is a subrange of the desired range\\n        if (i <= b and e <= j) return tree[node];\\n\\n        // oterwise go to the subordinate nodes\\n        int mid = (b+e)/2;\\n        int left = 2*node;\\n        int right = 2*node+1;\\n\\n        int ret1 = query(left, b, mid, i, j);\\n        int ret2 = query(right, mid+1, e, i, j);\\n\\n        // return the sum got from the subordinate nodes\\n        return ret1+ret2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407220,
                "title": "java-solution",
                "content": "```\\nclass NumArray {\\n    // solution 1 naive approach\\n//     List<Integer> list = new ArrayList<>();\\n//     public NumArray(int[] nums) {\\n//         for(int i=0;i<nums.length;i++)\\n//             list.add(nums[i]);\\n//     }\\n    \\n//     public int sumRange(int left, int right) {\\n//         int sum=0;\\n//         for(int i=left;i<=right;i++){\\n//             sum = sum + list.get(i);\\n//         }\\n//         return sum;\\n//     }\\n    \\n    // solution 2 using prefix sum\\n    int[] prefixSum = null;\\n    public NumArray(int[] nums) {\\n        prefixSum = new int[nums.length + 1];\\n        for(int i=0;i<nums.length;i++){\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n    \\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\n    // solution 1 naive approach\\n//     List<Integer> list = new ArrayList<>();\\n//     public NumArray(int[] nums) {\\n//         for(int i=0;i<nums.length;i++)\\n//             list.add(nums[i]);\\n//     }\\n    \\n//     public int sumRange(int left, int right) {\\n//         int sum=0;\\n//         for(int i=left;i<=right;i++){\\n//             sum = sum + list.get(i);\\n//         }\\n//         return sum;\\n//     }\\n    \\n    // solution 2 using prefix sum\\n    int[] prefixSum = null;\\n    public NumArray(int[] nums) {\\n        prefixSum = new int[nums.length + 1];\\n        for(int i=0;i<nums.length;i++){\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        return prefixSum[right + 1] - prefixSum[left];\\n    }\\n    \\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.sumRange(left,right);\\n */\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407112,
                "title": "kotlin-o-1-query-o-n-space-solution",
                "content": "```\\nclass NumArray(nums: IntArray) {\\n\\n    val accSum = IntArray(nums.size + 1).also {\\n        for (i in 1..it.lastIndex) {\\n            it[i] = it[i - 1] + nums[i - 1]\\n        }\\n    }\\n\\n    fun sumRange(left: Int, right: Int): Int {\\n        return accSum[right + 1] - accSum[left]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass NumArray(nums: IntArray) {\\n\\n    val accSum = IntArray(nums.size + 1).also {\\n        for (i in 1..it.lastIndex) {\\n            it[i] = it[i - 1] + nums[i - 1]\\n        }\\n    }\\n\\n    fun sumRange(left: Int, right: Int): Int {\\n        return accSum[right + 1] - accSum[left]\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406810,
                "title": "simple-o-n-and-o-1-query",
                "content": "```\\nclass NumArray {\\npublic:\\n    vector<int> pref;\\n    NumArray(vector<int>& nums) {\\n        pref.resize(nums.size() + 1);\\n        pref[0] = nums[0];\\n        \\n        for(int i = 1; i <nums.size(); i++)\\n            pref[i] = pref[i-1] + nums[i];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left == 0)\\n        return pref[right];\\n        else\\n        return pref[right] - pref[left - 1];\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> pref;\\n    NumArray(vector<int>& nums) {\\n        pref.resize(nums.size() + 1);\\n        pref[0] = nums[0];\\n        \\n        for(int i = 1; i <nums.size(); i++)\\n            pref[i] = pref[i-1] + nums[i];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left == 0)\\n        return pref[right];\\n        else\\n        return pref[right] - pref[left - 1];\\n    }\\n};\\n",
                "codeTag": "Java"
            },
            {
                "id": 1406806,
                "title": "python3-a-neat-clean-segment-tree-solution",
                "content": "***CODE***\\n```\\nclass NumArray:\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        self.n = len(self.nums)\\n        self.tree = [0]*4*self.n  # why 4? check the reference!\\n        self.build(1, 0, self.n-1)\\n\\t\\n    # builds the segment tree, x is curr index, l is left and r is right\\n    def build(self, x, l, r):\\n        if l == r: \\n            self.tree[x] = self.nums[l]\\n        else:\\n            m = (l+r)//2\\n            self.build(2*x, l, m)\\n            self.build(2*x+1, m+1, r)\\n            self.tree[x] = self.tree[x*2]+self.tree[x*2+1]\\n\\n    # tl and tr are target left and target right\\n\\tdef _sum(self, x, l, r, tl, tr):\\n        if tl > tr:\\n            return 0\\n        if l == tl and r == tr:\\n            return self.tree[x]\\n        m = (l+r)//2\\n        return self._sum(x*2, l, m, tl, min(m, tr)) + self._sum(x*2+1, m+1, r, max(m+1, tl), tr)\\n\\n        \\n    def sumRange(self, left: int, right: int) -> int:\\n        return self._sum(1, 0, self.n-1, left, right)\\n```\\n***COMPLEXITY ANALYSIS***\\n- Time to build segment tree: `O(N)` for `4*N` nodes.\\n- Time to query segment tree: `O(logN)`, since that gives the height.\\n- Space to build the segment tree: `O(N)` for `4*N` nodes.\\n- Space to query segment tree: `O(1)`. No additional space required.\\n\\nReference: https://cp-algorithms.com/data_structures/segment_tree.html\\n\\n**Upvote if you find this helpful!**",
                "solutionTags": [
                    "Python3",
                    "Tree"
                ],
                "code": "```\\nclass NumArray:\\n    def __init__(self, nums: List[int]):\\n        self.nums = nums\\n        self.n = len(self.nums)\\n        self.tree = [0]*4*self.n  # why 4? check the reference!\\n        self.build(1, 0, self.n-1)\\n\\t\\n    # builds the segment tree, x is curr index, l is left and r is right\\n    def build(self, x, l, r):\\n        if l == r: \\n            self.tree[x] = self.nums[l]\\n        else:\\n            m = (l+r)//2\\n            self.build(2*x, l, m)\\n            self.build(2*x+1, m+1, r)\\n            self.tree[x] = self.tree[x*2]+self.tree[x*2+1]\\n\\n    # tl and tr are target left and target right\\n\\tdef _sum(self, x, l, r, tl, tr):\\n        if tl > tr:\\n            return 0\\n        if l == tl and r == tr:\\n            return self.tree[x]\\n        m = (l+r)//2\\n        return self._sum(x*2, l, m, tl, min(m, tr)) + self._sum(x*2+1, m+1, r, max(m+1, tl), tr)\\n\\n        \\n    def sumRange(self, left: int, right: int) -> int:\\n        return self._sum(1, 0, self.n-1, left, right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1406673,
                "title": "python3",
                "content": "```\\ndef __init__(self, nums: List[int]):\\n        self.nums=nums\\n        self.pre=list(accumulate(nums))  #creates prefix array\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left ==0:\\n            return self.pre[right]\\n        return self.pre[right] - self.pre[left-1]",
                "solutionTags": [],
                "code": "```\\ndef __init__(self, nums: List[int]):\\n        self.nums=nums\\n        self.pre=list(accumulate(nums))  #creates prefix array\\n    def sumRange(self, left: int, right: int) -> int:\\n        if left ==0:\\n            return self.pre[right]\\n        return self.pre[right] - self.pre[left-1]",
                "codeTag": "Python3"
            },
            {
                "id": 1406493,
                "title": "easy-prefix-sum-ac-solution",
                "content": "```\\nclass NumArray {\\npublic:\\n    vector<int>v;\\n    NumArray(vector<int>& nums) {\\n     int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            v.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        return v[j]-(i==0? 0 : v[i-1]);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int>v;\\n    NumArray(vector<int>& nums) {\\n     int sum=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            sum+=nums[i];\\n            v.push_back(sum);\\n        }\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        return v[j]-(i==0? 0 : v[i-1]);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1362066,
                "title": "python-prefix-sum-solution",
                "content": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_sum = [0] + list(accumulate(nums))\\n        \\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix_sum = [0] + list(accumulate(nums))\\n        \\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.prefix_sum[right + 1] - self.prefix_sum[left]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281986,
                "title": "java-running-sum-solution-beats-100-in-time",
                "content": "```\\nclass NumArray {\\n\\n    int[] sum;\\n    public NumArray(int[] nums) {\\n        this.sum = new int[nums.length];\\n        sum[0] = nums[0];\\n        for(int i = 1;i<nums.length;i++)\\n            sum[i] = sum[i-1] + nums[i];\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        \\n        int leftVal = 0;\\n        if(left - 1 >=0 )\\n            leftVal = sum[left - 1];\\n        return sum[right] - leftVal;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass NumArray {\\n\\n    int[] sum;\\n    public NumArray(int[] nums) {\\n        this.sum = new int[nums.length];\\n        sum[0] = nums[0];\\n        for(int i = 1;i<nums.length;i++)\\n            sum[i] = sum[i-1] + nums[i];\\n    }\\n    \\n    public int sumRange(int left, int right) {\\n        \\n        int leftVal = 0;\\n        if(left - 1 >=0 )\\n            leftVal = sum[left - 1];\\n        return sum[right] - leftVal;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1245308,
                "title": "prefix-sum-js-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar NumArray = function (nums) {\\n  this.prefixSumArr = new Array(nums.length);\\n  let prefixSum = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    prefixSum += nums[i];\\n    this.prefixSumArr[i] = prefixSum;\\n  }\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function (left, right) {\\n  if (left < 0 || right > this.prefixSumArr.length - 1) {\\n    return null;\\n  }\\n  return left > 0\\n    ? this.prefixSumArr[right] - this.prefixSumArr[left - 1]\\n    : this.prefixSumArr[right];\\n    // T.C: O(1)\\n    // S.C: O(1)\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * var obj = new NumArray(nums)\\n * var param_1 = obj.sumRange(left,right)\\n */\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n */\\nvar NumArray = function (nums) {\\n  this.prefixSumArr = new Array(nums.length);\\n  let prefixSum = 0;\\n  for (let i = 0; i < nums.length; i++) {\\n    prefixSum += nums[i];\\n    this.prefixSumArr[i] = prefixSum;\\n  }\\n    // T.C: O(N)\\n    // S.C: O(N)\\n};\\n\\n/**\\n * @param {number} left\\n * @param {number} right\\n * @return {number}\\n */\\nNumArray.prototype.sumRange = function (left, right) {\\n  if (left < 0 || right > this.prefixSumArr.length - 1) {\\n    return null;\\n  }\\n  return left > 0\\n    ? this.prefixSumArr[right] - this.prefixSumArr[left - 1]\\n    : this.prefixSumArr[right];\\n    // T.C: O(1)\\n    // S.C: O(1)\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * var obj = new NumArray(nums)\\n * var param_1 = obj.sumRange(left,right)\\n */\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1204526,
                "title": "c-constant-time-result-solution-explained-100-time-80-space",
                "content": "This problem, similarly to its [older brother](https://leetcode.com/problems/range-sum-query-2d-immutable/) (solution [here](https://leetcode.com/problems/range-sum-query-2d-immutable/discuss/1204583/)), can be tempting for a brute force approach, but if we know how many queries we are going to get, we might realise it is not the best approach.\\n\\nWe could instead store in memory when we initialise not a trivial copy of the input vector/array, as naively thought before, but one with already partially made work: each cell would be equal to the sum of all the elements up to there (current one included) from the original vector/array.\\n\\nTo do so, we will declare just one class variable, `store`, as a reference to our new array that we will create in the constructor and populate as mentioned above.\\n\\nNow, given for example an initial input of `{3,4,0,1,2}`, `store` will contain `{3,7,7,8,10}`.\\n\\nWhy do we want to do this?\\n\\nBecause summing all the numbers in a range is relative expensive (linear time) and want to do it as little as possible.\\n\\nTo obtain sums from `left` to `right` (included), we might then just retrieve the sum of all the elements up to `right` and then remove the sum  of all the elements up to `left` (excluded), provided `left` is not `0`.\\n\\nIn our example before, given `left == 2` and. `right == 4`, we will just have to return `10` (sum of all the elements up to index `4`, included) minus `7` (sum of all the elements up to index. `2`, excluded).\\n\\nAnd that is precisely what we do in our `sumRange` method, with surprisingly good performance :)\\n\\nThe code:\\n\\n```cpp\\nclass NumArray {\\n    int *store;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        store = new int[nums.size()];\\n        for (int i = 0, lmt = nums.size(), tmp = 0; i < lmt; i++) store[i] = tmp += nums[i];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return store[right] - (left ? store[left - 1] : 0);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Memoization"
                ],
                "code": "```cpp\\nclass NumArray {\\n    int *store;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        store = new int[nums.size()];\\n        for (int i = 0, lmt = nums.size(), tmp = 0; i < lmt; i++) store[i] = tmp += nums[i];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return store[right] - (left ? store[left - 1] : 0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1135014,
                "title": "c",
                "content": "```\\npublic class NumArray {\\n\\n    private int[] Numbers {get; set;}\\n    \\n    public NumArray(int[] nums) {\\n        Numbers = nums;\\n    }\\n    \\n    public int SumRange(int left, int right) {\\n        \\n        if (left < 0)\\n        {\\n            return 0;\\n        }\\n        \\n        if (right > Numbers.Length)\\n        {\\n            return 0;\\n        }\\n        \\n        int result = 0;\\n        for(int i = left; i <= right ; i++)\\n        {\\n            result += Numbers[i];\\n        }\\n        return result;\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.SumRange(left,right);\\n */\\n ```",
                "solutionTags": [],
                "code": "```\\npublic class NumArray {\\n\\n    private int[] Numbers {get; set;}\\n    \\n    public NumArray(int[] nums) {\\n        Numbers = nums;\\n    }\\n    \\n    public int SumRange(int left, int right) {\\n        \\n        if (left < 0)\\n        {\\n            return 0;\\n        }\\n        \\n        if (right > Numbers.Length)\\n        {\\n            return 0;\\n        }\\n        \\n        int result = 0;\\n        for(int i = left; i <= right ; i++)\\n        {\\n            result += Numbers[i];\\n        }\\n        return result;\\n    }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = new NumArray(nums);\\n * int param_1 = obj.SumRange(left,right);\\n */\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1107723,
                "title": "c-explained-prefix-sum-approach",
                "content": "Code has been commented below:\\n```\\nclass NumArray {\\n    vector<int> sum; // vector to store the sum of elements upto particular index\\npublic:\\n    NumArray(vector<int>& nums) {\\n// we loop the nums vector store the sum of elements upto that particular index\\n    for(int i=0;i<nums.size();i++){\\n        if(i==0)sum.push_back(nums[0]); // if first element jsut store the element\\n        else \\n            sum.push_back(nums[i]+sum[i-1]);// else we store the sum upto current index starting drom index 0\\n    }\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if(i==0)return sum[j];//if i==0 then we return the sum of elements upto index j\\n        else   //else to get the sum in b/w index i & j we subtract the sum upto index i-1 from sum upto index j\\n            return sum[j]-sum[i-1];\\n    }\\n};\\n ```\\n Do upvote if explanaton was useful :)",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\n    vector<int> sum; // vector to store the sum of elements upto particular index\\npublic:\\n    NumArray(vector<int>& nums) {\\n// we loop the nums vector store the sum of elements upto that particular index\\n    for(int i=0;i<nums.size();i++){\\n        if(i==0)sum.push_back(nums[0]); // if first element jsut store the element\\n        else \\n            sum.push_back(nums[i]+sum[i-1]);// else we store the sum upto current index starting drom index 0\\n    }\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        if(i==0)return sum[j];//if i==0 then we return the sum of elements upto index j\\n        else   //else to get the sum in b/w index i & j we subtract the sum upto index i-1 from sum upto index j\\n            return sum[j]-sum[i-1];\\n    }\\n};\\n ```",
                "codeTag": "Java"
            },
            {
                "id": 1090411,
                "title": "c-16ms-99-timeo1-spaceo1-in-place",
                "content": "Runtime: 16 ms, faster than 97.54% of C++ online submissions for Range Sum Query - Immutable.\\nMemory Usage: 16.9 MB, less than 94.51% of C++ online submissions for Range Sum Query - Immutable.\\n```\\nclass NumArray {\\npublic:\\n  vector<int> *p;                                 //pointer to vector <int>\\n  NumArray(vector<int> &nums) {\\n    for(int i = 1; i < nums.size(); i++) nums[i] += nums[i-1];      //transform vector as vector of previous sum\\n    p = &nums;                                    //retain pointer to vector nums\\n  }\\n    \\n  int sumRange(int i, int j) {                    //fetch sum in range\\n    return (*p)[j] - (i ? (*p)[i-1] : 0);\\n  }\\n};\\n```\\n\\n**more readable code**\\nRuntime: 16 ms, faster than 98.68% of C++ online submissions for Range Sum Query - Immutable.\\nMemory Usage: 17 MB, less than 85.00% of C++ online submissions for Range Sum Query - Immutable.\\n```\\nclass NumArray {\\npublic:\\n  vector<int> *p;                                 //pointer to vector <int>\\n  NumArray(vector<int>& nums) {\\n    for(int i = 1; i < nums.size(); i++) nums[i] += nums[i-1];      //transform vector as vector of previous sum\\n    p = &nums;                                    //retain pointer to vector nums\\n  }\\n    \\n  int sumRange(int i, int j) {                    //fetch sum in range\\n    if(i == 0) return p->operator[](j);\\n    else return p->operator[](j) - p->operator[](i-1);\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass NumArray {\\npublic:\\n  vector<int> *p;                                 //pointer to vector <int>\\n  NumArray(vector<int> &nums) {\\n    for(int i = 1; i < nums.size(); i++) nums[i] += nums[i-1];      //transform vector as vector of previous sum\\n    p = &nums;                                    //retain pointer to vector nums\\n  }\\n    \\n  int sumRange(int i, int j) {                    //fetch sum in range\\n    return (*p)[j] - (i ? (*p)[i-1] : 0);\\n  }\\n};\\n```\n```\\nclass NumArray {\\npublic:\\n  vector<int> *p;                                 //pointer to vector <int>\\n  NumArray(vector<int>& nums) {\\n    for(int i = 1; i < nums.size(); i++) nums[i] += nums[i-1];      //transform vector as vector of previous sum\\n    p = &nums;                                    //retain pointer to vector nums\\n  }\\n    \\n  int sumRange(int i, int j) {                    //fetch sum in range\\n    if(i == 0) return p->operator[](j);\\n    else return p->operator[](j) - p->operator[](i-1);\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1086197,
                "title": "python",
                "content": "```\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums = nums\\n        self.prefix = [0]\\n        for i in self.nums:\\n            self.prefix.append(self.prefix[-1] + i)\\n            \\n        \\n    def sumRange(self, i, j):\\n        \"\"\"\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.prefix[j+1] - self.prefix[i]\\n        \\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(i,j)",
                "solutionTags": [],
                "code": "```\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums = nums\\n        self.prefix = [0]\\n        for i in self.nums:\\n            self.prefix.append(self.prefix[-1] + i)\\n            \\n        \\n    def sumRange(self, i, j):\\n        \"\"\"\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.prefix[j+1] - self.prefix[i]\\n        \\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(i,j)",
                "codeTag": "Java"
            },
            {
                "id": 837788,
                "title": "very-simple-c-solution",
                "content": "```\\nclass NumArray {\\npublic:\\n    vector<int> sum;\\n    NumArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sum.resize(n);\\n        sum = nums;\\n        for(int i = 1; i<n; i++)\\n            sum[i] += sum[i-1];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return left == 0 ? sum[right] : sum[right]-sum[left-1];\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    vector<int> sum;\\n    NumArray(vector<int>& nums) {\\n        int n = nums.size();\\n        sum.resize(n);\\n        sum = nums;\\n        for(int i = 1; i<n; i++)\\n            sum[i] += sum[i-1];\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        return left == 0 ? sum[right] : sum[right]-sum[left-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 776556,
                "title": "python3-prefix-sum",
                "content": "without leading 0 \\n\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i-1]\\n        self.prefix = nums\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        ans = self.prefix[j]\\n        if i: ans -= self.prefix[i-1]\\n        return ans \\n```\\n\\nwith leading 0 which indeed simplifies the query. \\n\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix = [0]\\n        for x in nums: self.prefix.append(self.prefix[-1] + x)\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        return self.prefix[j+1] - self.prefix[i]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        for i in range(1, len(nums)):\\n            nums[i] += nums[i-1]\\n        self.prefix = nums\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        ans = self.prefix[j]\\n        if i: ans -= self.prefix[i-1]\\n        return ans \\n```\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.prefix = [0]\\n        for x in nums: self.prefix.append(self.prefix[-1] + x)\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        return self.prefix[j+1] - self.prefix[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 696140,
                "title": "100-faster-in-java",
                "content": "```\\nclass NumArray {\\n  \\n    public int[] numss;\\n    public NumArray(int[] nums) {\\n      numss = new int[nums.length];\\n      int sum = 0; int i = 0;\\n      for (int n: nums) {\\n        sum += nums[i]; numss[i] = sum;\\n        i++;\\n      }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        if (i == 0) { return numss[j]; } else { return numss[j]-numss[i-1]; }\\n    }\\n}\\n",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\n  \\n    public int[] numss;\\n    public NumArray(int[] nums) {\\n      numss = new int[nums.length];\\n      int sum = 0; int i = 0;\\n      for (int n: nums) {\\n        sum += nums[i]; numss[i] = sum;\\n        i++;\\n      }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        if (i == 0) { return numss[j]; } else { return numss[j]-numss[i-1]; }\\n    }\\n}\\n",
                "codeTag": "Java"
            },
            {
                "id": 662198,
                "title": "small-python3-solution-o-n-time-for-init-o-1-for-query",
                "content": "Also, since I don\\'t want to modify the original array, the space complexity for `__init__` is also O(n).\\n\\n```\\nclass NumArray:\\n    def __init__(self, nums: List[int]):\\n        self.cumulative = [0]\\n        for num in nums:\\n            self.cumulative.append(\\n                self.cumulative[-1]+num)\\n\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        return self.cumulative[j+1] - self.cumulative[i]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass NumArray:\\n    def __init__(self, nums: List[int]):\\n        self.cumulative = [0]\\n        for num in nums:\\n            self.cumulative.append(\\n                self.cumulative[-1]+num)\\n\\n\\n    def sumRange(self, i: int, j: int) -> int:\\n        return self.cumulative[j+1] - self.cumulative[i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 396097,
                "title": "easy-c-solution-20ms-beats-99",
                "content": "Runtime: 20 ms, faster than 99.94% of C++ online submissions for Range Sum Query - Immutable.\\nMemory Usage: 17.1 MB, less than 100.00% of C++ online submissions for Range Sum Query - Immutable.\\n\\n```\\nclass NumArray {\\n    vector<int> sum;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        \\n        sum.resize(nums.size()+1);\\n        for(int i=1; i<=nums.size(); i++)\\n            sum[i] = sum[i-1] + nums[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        \\n        return (sum[j+1] - sum[i]);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(i,j);\\n */",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "Runtime: 20 ms, faster than 99.94% of C++ online submissions for Range Sum Query - Immutable.\\nMemory Usage: 17.1 MB, less than 100.00% of C++ online submissions for Range Sum Query - Immutable.\\n\\n```\\nclass NumArray {\\n    vector<int> sum;\\npublic:\\n    NumArray(vector<int>& nums) {\\n        \\n        sum.resize(nums.size()+1);\\n        for(int i=1; i<=nums.size(); i++)\\n            sum[i] = sum[i-1] + nums[i-1];\\n    }\\n    \\n    int sumRange(int i, int j) {\\n        \\n        return (sum[j+1] - sum[i]);\\n    }\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(i,j);\\n */",
                "codeTag": "Java"
            },
            {
                "id": 211387,
                "title": "python-3-60-ms",
                "content": "```\\nclass NumArray:\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums=nums;\\n        for i in range(1,len(nums)):\\n            nums[i]=nums[i]+nums[i-1];\\n        \\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        num=self.nums;\\n        if(i==0):\\n            return num[j];\\n        return num[j]-num[i-1]\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(i,j)\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums=nums;\\n        for i in range(1,len(nums)):\\n            nums[i]=nums[i]+nums[i-1];\\n        \\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        num=self.nums;\\n        if(i==0):\\n            return num[j];\\n        return num[j]-num[i-1]\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(i,j)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 136385,
                "title": "python-o-n-time-o-n-space-solution-beats-97",
                "content": "```\\nclass NumArray:\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.val = {-1:0}\\n        for i in range(len(nums)):\\n            self.val[i] = self.val[i-1] + nums[i]\\n        \\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.val[j] - self.val[i-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        :type nums: List[int]\\n        \"\"\"\\n        self.val = {-1:0}\\n        for i in range(len(nums)):\\n            self.val[i] = self.val[i-1] + nums[i]\\n        \\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.val[j] - self.val[i-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75186,
                "title": "easy-to-understand-java-solution-o-n-process-time-o-1-query-time",
                "content": "```\\nclass NumArray {\\n    \\n    int[] arr;\\n    \\n    public NumArray(int[] nums) {\\n        arr = new int[nums.length];\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            arr[i]= sum;    \\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        \\n        if(i==0)\\n            return arr[j];\\n        \\n        return arr[j]-arr[i-1];\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\n    \\n    int[] arr;\\n    \\n    public NumArray(int[] nums) {\\n        arr = new int[nums.length];\\n        int sum = 0;\\n        for(int i=0;i<nums.length;i++){\\n            sum+=nums[i];\\n            arr[i]= sum;    \\n        }\\n    }\\n    \\n    public int sumRange(int i, int j) {\\n        \\n        if(i==0)\\n            return arr[j];\\n        \\n        return arr[j]-arr[i-1];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 75259,
                "title": "cpp-solution-which-beats-100-submissions-easy-to-understand",
                "content": "    class NumArray {\\n    public:\\n        vector<int> nums_;\\n        NumArray(vector<int> &nums) {\\n            nums_.push_back(0);\\n            for (int i = 0; i < nums.size(); i++)\\n                nums_.push_back(nums_.back() + nums[i]);\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return nums_[j + 1] - nums_[i];\\n        }\\n    };",
                "solutionTags": [],
                "code": "    class NumArray {\\n    public:\\n        vector<int> nums_;\\n        NumArray(vector<int> &nums) {\\n            nums_.push_back(0);\\n            for (int i = 0; i < nums.size(); i++)\\n                nums_.push_back(nums_.back() + nums[i]);\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            return nums_[j + 1] - nums_[i];\\n        }\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 75269,
                "title": "simple-and-easy-solution",
                "content": "class NumArray {\\n\\n    vector<int> mat;\\npublic:\\n\\n    NumArray(vector<int> &nums) {\\n        int size=nums.size(),i;\\n        mat.resize(size+1);\\n        mat[0]=0;\\n        for(i=1;i<=size;i++){\\n            mat[i]=mat[i-1]+nums[i-1];\\n        }\\n    }\\n\\n    int sumRange(int i, int j) {\\n        return mat[j+1] - mat[i];\\n    }\\n};",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class NumArray {\\n\\n    vector<int> mat;\\npublic:\\n\\n    NumArray(vector<int> &nums) {\\n        int size=nums.size(),i;\\n        mat.resize(size+1);\\n        mat[0]=0;\\n        for(i=1;i<=size;i++){\\n            mat[i]=mat[i-1]+nums[i-1];\\n        }\\n    }\\n\\n    int sumRange(int i, int j) {\\n        return mat[j+1] - mat[i];\\n    }\\n};",
                "codeTag": "Java"
            },
            {
                "id": 75282,
                "title": "easy-to-understand-python-solution-o-n-runtime-o-n-space",
                "content": "    def __init__(self, nums):\\n        \"\"\"\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums = nums\\n        self.sumList = []\\n        sum = 0\\n        for index in range(len(nums)):\\n            sum += nums[index]\\n            (self.sumList).append(sum)\\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        sum of elements nums[i..j], inclusive.\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.sumList[j] - self.sumList[i] + self.nums[i]",
                "solutionTags": [],
                "code": "    def __init__(self, nums):\\n        \"\"\"\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums = nums\\n        self.sumList = []\\n        sum = 0\\n        for index in range(len(nums)):\\n            sum += nums[index]\\n            (self.sumList).append(sum)\\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        sum of elements nums[i..j], inclusive.\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return self.sumList[j] - self.sumList[i] + self.nums[i]",
                "codeTag": "Python3"
            },
            {
                "id": 75283,
                "title": "why-is-this-solution-exceeding-the-time-limit",
                "content": "\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums=nums\\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        sum of elements nums[i..j], inclusive.\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return sum(self.nums[i:j+1])",
                "solutionTags": [],
                "code": "\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        \"\"\"\\n        initialize your data structure here.\\n        :type nums: List[int]\\n        \"\"\"\\n        self.nums=nums\\n\\n    def sumRange(self, i, j):\\n        \"\"\"\\n        sum of elements nums[i..j], inclusive.\\n        :type i: int\\n        :type j: int\\n        :rtype: int\\n        \"\"\"\\n        return sum(self.nums[i:j+1])",
                "codeTag": "Java"
            },
            {
                "id": 75290,
                "title": "sharing-my-585ms-c-solution",
                "content": "    class NumArray {\\n    private:\\n        vector<int> sums;\\n    public:\\n        NumArray(vector<int> &nums) {\\n            int n = nums.size();\\n            sums.resize(n, 0);\\n            int sum = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                sums[i] = sum + nums[i];\\n                sum = sums[i];\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            if(i==0)\\n                return sums[j];\\n            else\\n                return (sums[j] - sums[i-1]);\\n        }\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "solutionTags": [
                    "C++"
                ],
                "code": "    class NumArray {\\n    private:\\n        vector<int> sums;\\n    public:\\n        NumArray(vector<int> &nums) {\\n            int n = nums.size();\\n            sums.resize(n, 0);\\n            int sum = 0;\\n            for(int i=0; i<n; i++)\\n            {\\n                sums[i] = sum + nums[i];\\n                sum = sums[i];\\n            }\\n        }\\n    \\n        int sumRange(int i, int j) {\\n            if(i==0)\\n                return sums[j];\\n            else\\n                return (sums[j] - sums[i-1]);\\n        }\\n    };\\n    \\n    \\n    // Your NumArray object will be instantiated and called as such:\\n    // NumArray numArray(nums);\\n    // numArray.sumRange(0, 1);\\n    // numArray.sumRange(1, 2);",
                "codeTag": "Java"
            },
            {
                "id": 4063582,
                "title": "python3-single-line-code",
                "content": "\\n\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=nums\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return sum(self.nums[left:right+1])\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=nums\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return sum(self.nums[left:right+1])\\n\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3837269,
                "title": "o-1-space-complexity-answer-using-initializer-list",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the numbers of queries are large. It will be very inefficient to iterate over the array and calculate the sum for each query separately. We have to devise the solution so that we can get the answer of the query in constant time. We will be storing the sum upto a particular index in prefix sum Array. We will be using the prefix sum array to calculate the sum for the given range.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the reference of the vector is already given in the NumaArray constructor so we will take advantage of it, we will not create a copy instead we will create a vector<int> reference and we will initialize that reference with the argument reference of Numarray so it will be O(1) space complexity and we can initialize the vector<int> reference in initializer list which I have done like this in my code \" NumArray(vector<int>& nums) : prefixSum(nums) \" you can learn more about initializer list if you are getting confused just go and learn about it for once from GFG article it will help you alot in future\\n\\n\\nprefixSum[] = Array stores the sum (A[0]+A[1]+....A[i]) at index i.\\n example prefixSum[i]=prefixSum[i-1]+prefixSum[i-2]+.......prefixSum[0];\\n    or\\n prefixSum[0]=prefixSum[0];\\n prefixSum[1]=prefixSum[1]+prefixSum[0];\\n prefixSum[2]=prefixSum[2]+prefixSum[1];\\n\\n\\n \\n if l == 0 :\\n    sum(l,r) = prefixSum[r]\\n else :\\n    sum(l,r) = prefixSum[r] - prefixSum[l-1]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass NumArray {\\npublic:\\n    vector<int>&prefixSum;\\n    NumArray(vector<int>& nums) : prefixSum(nums){\\n        for(int i=1;i<prefixSum.size();i++)\\n        {\\n          prefixSum[i]+=prefixSum[i-1];\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0)\\n        {\\n          return prefixSum[right];\\n        }\\n        return prefixSum[right]-prefixSum[left-1];\\n    }\\n};\\n<!-- kindly upvote if you liked my solution -->",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIf the numbers of queries are large. It will be very inefficient to iterate over the array and calculate the sum for each query separately. We have to devise the solution so that we can get the answer of the query in constant time. We will be storing the sum upto a particular index in prefix sum Array. We will be using the prefix sum array to calculate the sum for the given range.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAs the reference of the vector is already given in the NumaArray constructor so we will take advantage of it, we will not create a copy instead we will create a vector<int> reference and we will initialize that reference with the argument reference of Numarray so it will be O(1) space complexity and we can initialize the vector<int> reference in initializer list which I have done like this in my code \" NumArray(vector<int>& nums) : prefixSum(nums) \" you can learn more about initializer list if you are getting confused just go and learn about it for once from GFG article it will help you alot in future\\n\\n\\nprefixSum[] = Array stores the sum (A[0]+A[1]+....A[i]) at index i.\\n example prefixSum[i]=prefixSum[i-1]+prefixSum[i-2]+.......prefixSum[0];\\n    or\\n prefixSum[0]=prefixSum[0];\\n prefixSum[1]=prefixSum[1]+prefixSum[0];\\n prefixSum[2]=prefixSum[2]+prefixSum[1];\\n\\n\\n \\n if l == 0 :\\n    sum(l,r) = prefixSum[r]\\n else :\\n    sum(l,r) = prefixSum[r] - prefixSum[l-1]\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass NumArray {\\npublic:\\n    vector<int>&prefixSum;\\n    NumArray(vector<int>& nums) : prefixSum(nums){\\n        for(int i=1;i<prefixSum.size();i++)\\n        {\\n          prefixSum[i]+=prefixSum[i-1];\\n        }\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if(left==0)\\n        {\\n          return prefixSum[right];\\n        }\\n        return prefixSum[right]-prefixSum[left-1];\\n    }\\n};\\n<!-- kindly upvote if you liked my solution -->",
                "codeTag": "Java"
            },
            {
                "id": 3363767,
                "title": "c-prefix-sum-solution",
                "content": "# Intuition\\nTo avoid iterate the array every time that the SumRange() method is called we can have the running totals, take the total of the right index and substact the total of the left index\\n\\n# Approach\\nPrefix sum, with an additional index at the left side to have a value of zero and avoid checking for index 0.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ constructor, and $$O(1)$$ the SumRange() method\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\npublic class NumArray {\\n\\n    private int[] _nums;\\n\\n    public NumArray(int[] nums) {\\n        var n = nums.Length;\\n        _nums = new int[n+1];\\n        for (int i = 0; i < n; i++) _nums[i+1] = _nums[i] + nums[i];\\n    }\\n    \\n    public int SumRange(int left, int right) {\\n        return _nums[right+1] - _nums[left];\\n    }\\n}\\n```\\n![image.png](https://assets.leetcode.com/users/images/0d0898ec-1f4b-4f4d-8e7c-d74de6d20dfd_1680305281.5864549.png)\\n",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class NumArray {\\n\\n    private int[] _nums;\\n\\n    public NumArray(int[] nums) {\\n        var n = nums.Length;\\n        _nums = new int[n+1];\\n        for (int i = 0; i < n; i++) _nums[i+1] = _nums[i] + nums[i];\\n    }\\n    \\n    public int SumRange(int left, int right) {\\n        return _nums[right+1] - _nums[left];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233210,
                "title": "rust-0ms-o-1-query-o-n-space",
                "content": "I chain a 1 size array with 0 to the nums iter to create the monotonic array.\\nI use scan to sum it up. This avoids checking if left is OOB when calculating sum.\\n\\n# Code\\n```\\nstruct NumArray {\\n    monotonic_stack: Vec<i32>,\\n}\\n\\nimpl NumArray {\\n\\n    fn new(nums: Vec<i32>) -> Self {\\n        Self {\\n            monotonic_stack: [0].iter().chain(nums.iter())\\n                .scan(0,|state,val|{\\n                    *state += val;\\n                    Some(*state)\\n                }).collect::<Vec<i32>>(),\\n        }\\n    }\\n    \\n    fn sum_range(&self, left: i32, right: i32) -> i32 {\\n        self.monotonic_stack[(right+1) as usize] - self.monotonic_stack[left as usize]\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct NumArray {\\n    monotonic_stack: Vec<i32>,\\n}\\n\\nimpl NumArray {\\n\\n    fn new(nums: Vec<i32>) -> Self {\\n        Self {\\n            monotonic_stack: [0].iter().chain(nums.iter())\\n                .scan(0,|state,val|{\\n                    *state += val;\\n                    Some(*state)\\n                }).collect::<Vec<i32>>(),\\n        }\\n    }\\n    \\n    fn sum_range(&self, left: i32, right: i32) -> i32 {\\n        self.monotonic_stack[(right+1) as usize] - self.monotonic_stack[left as usize]\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3102283,
                "title": "using-accumulate-range-sum-query",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=[0]+list(accumulate(nums))\\n        print(self.nums)\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.nums[right+1]-self.nums[left]\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=[0]+list(accumulate(nums))\\n        print(self.nums)\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        return self.nums[right+1]-self.nums[left]\\n\\n# Your NumArray object will be instantiated and called as such:\\n# obj = NumArray(nums)\\n# param_1 = obj.sumRange(left,right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3022478,
                "title": "simple-clear-and-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass NumArray {\\n  List<int> arr = [];\\n\\n  NumArray(List<int> nums) {\\n    arr = nums;\\n  }\\n\\n  int sumRange(int left, int right) {\\n    int sum = 0;\\n    for (int i = left; i <= right; i++) sum += arr[i];\\n    return sum;\\n  }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = NumArray(nums);\\n * int param1 = obj.sumRange(left,right);\\n */\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass NumArray {\\n  List<int> arr = [];\\n\\n  NumArray(List<int> nums) {\\n    arr = nums;\\n  }\\n\\n  int sumRange(int left, int right) {\\n    int sum = 0;\\n    for (int i = left; i <= right; i++) sum += arr[i];\\n    return sum;\\n  }\\n}\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray obj = NumArray(nums);\\n * int param1 = obj.sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3014293,
                "title": "swift-solution-beats-99",
                "content": "# Dummy solution\\n```\\nclass NumArray {\\n    private let nums: [Int]\\n\\n    init(_ nums: [Int]) {\\n        self.nums = nums\\n    }\\n    \\n    func sumRange(_ left: Int, _ right: Int) -> Int {\\n        return nums[left...right].reduce(0, +)\\n    }\\n}\\n```\\n## Complexity\\n- Time complexity: $$O(n)$$ - each run we need to count sum for given range without any caching\\n\\n- Space complexity: $$O(1)$$ - because Swift stores a reference to given array instead of its copy.\\n\\n\\n# Optimized solution\\n```\\nclass NumArray {\\n    private let sumArray: [Int]\\n\\n    init(_ nums: [Int]) {\\n        var sum: Int = 0\\n        self.sumArray = nums.map { num in\\n            sum += num;\\n            return sum\\n        }\\n    }\\n    \\n    func sumRange(_ left: Int, _ right: Int) -> Int {\\n        if left == 0 { \\n            return sumArray[right] \\n        } else {\\n            return sumArray[right] - sumArray[left - 1]\\n        }\\n    }\\n}\\n```\\n## Complexity\\n- Time complexity: $$O(1)$$ - need to access dictionary\\'s value.\\n\\n- Space complexity: $$O(n)$$ - creating new array of the same size as the given one.\\n### Please upwote if you like the solution)",
                "solutionTags": [
                    "Swift",
                    "Prefix Sum"
                ],
                "code": "```\\nclass NumArray {\\n    private let nums: [Int]\\n\\n    init(_ nums: [Int]) {\\n        self.nums = nums\\n    }\\n    \\n    func sumRange(_ left: Int, _ right: Int) -> Int {\\n        return nums[left...right].reduce(0, +)\\n    }\\n}\\n```\n```\\nclass NumArray {\\n    private let sumArray: [Int]\\n\\n    init(_ nums: [Int]) {\\n        var sum: Int = 0\\n        self.sumArray = nums.map { num in\\n            sum += num;\\n            return sum\\n        }\\n    }\\n    \\n    func sumRange(_ left: Int, _ right: Int) -> Int {\\n        if left == 0 { \\n            return sumArray[right] \\n        } else {\\n            return sumArray[right] - sumArray[left - 1]\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2634640,
                "title": "easy-understanding-python-solution",
                "content": "class NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=nums\\n        self.pre=nums\\n        for i in range(len(self.pre)-1):\\n            self.pre[i+1]+=self.pre[i]\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        self.left=left\\n        self.right=right\\n        if self.left:\\n            return self.pre[right]-self.pre[left-1]\\n        else:\\n            return self.pre[right]",
                "solutionTags": [],
                "code": "class NumArray:\\n\\n    def __init__(self, nums: List[int]):\\n        self.nums=nums\\n        self.pre=nums\\n        for i in range(len(self.pre)-1):\\n            self.pre[i+1]+=self.pre[i]\\n\\n    def sumRange(self, left: int, right: int) -> int:\\n        self.left=left\\n        self.right=right\\n        if self.left:\\n            return self.pre[right]-self.pre[left-1]\\n        else:\\n            return self.pre[right]",
                "codeTag": "Java"
            },
            {
                "id": 2585302,
                "title": "c-solution-98-83-time-72-52-space-o-n-time-space",
                "content": "```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        int i, sum{}, size = nums.size();\\n        for (i = 0; i < size; ++i) {\\n            sum+=nums[i];\\n            _acum.emplace_back(sum);\\n        }\\n        return;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if (left > 0) {\\n            return _acum[right]-_acum[left-1];\\n        } else {\\n            return _acum[right];\\n        }\\n    }\\nprivate:\\n    vector<int> _acum;\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "solutionTags": [],
                "code": "```\\nclass NumArray {\\npublic:\\n    NumArray(vector<int>& nums) {\\n        int i, sum{}, size = nums.size();\\n        for (i = 0; i < size; ++i) {\\n            sum+=nums[i];\\n            _acum.emplace_back(sum);\\n        }\\n        return;\\n    }\\n    \\n    int sumRange(int left, int right) {\\n        if (left > 0) {\\n            return _acum[right]-_acum[left-1];\\n        } else {\\n            return _acum[right];\\n        }\\n    }\\nprivate:\\n    vector<int> _acum;\\n};\\n\\n/**\\n * Your NumArray object will be instantiated and called as such:\\n * NumArray* obj = new NumArray(nums);\\n * int param_1 = obj->sumRange(left,right);\\n */\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1567951,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1569065,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1572637,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1569188,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2009514,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1572524,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1571554,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2061827,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1776188,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759585,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1567951,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1569065,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1572637,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1569188,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2009514,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1572524,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1571554,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 2061827,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1776188,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            },
            {
                "id": 1759585,
                "content": [
                    {
                        "username": "zakcoder",
                        "content": "The title says it all... how is Java achieving such speeds...?"
                    },
                    {
                        "username": "ZhaoMai",
                        "content": "There are a couple of designs in discuss: sum array, segment tree, binary indexed tree.\\nThe problem is tagged with DP. Why?"
                    },
                    {
                        "username": "sandagolcea",
                        "content": "because you can do a DP-like array of previous sums, so you don't recalculate the sum at each point."
                    },
                    {
                        "username": "M416",
                        "content": "![image](https://assets.leetcode.com/users/m416/image_1556083639.png)\\n"
                    },
                    {
                        "username": "heg816",
                        "content": "You need to declare your vector within the class. When you don't, the instances of the class call upon the same bit of memory (i.e., everytime you call the class, the newest will try to overwrite the last version.) You can either have 'a' as a member or make sure to clear the data at the begining of NumArray, but this isn't best practice if that data needs to be accessed later."
                    },
                    {
                        "username": "MarsMarting",
                        "content": "I've been playing around with the code in C++ and I noticed a couple of things:\n\n* People in the top ranking (for C++ at least) are not checking their bounds as they should. \n* I tested my code by arranging the checks so as to return faster and found that if I return as soon as 'i = 0' without bound checking 'j' my time goes from 169ms down to 33ms.\n\nI think this is wrong and the test cases should reflect that. The problem gives you a function that takes index i and index j as parameters of type \"int.\" I may not be your interviewer (in fact I'm unemployed) moreover, if I see no checks for bounds especially with a signed index params that is a red flag. \n\nJust a few thoughts. \nCheers and if you're like me, good luck in your technical screenings.\nMars."
                    },
                    {
                        "username": "meShivangi",
                        "content": " `class NumArray {\n    \n    int[] nums;\n    public NumArray(int[] nums) {\n       this.nums = nums;\n    }\n    \n    public int sumRange(int left, int right) {\n        int sum = 0;\n        while(left<=right){\n        sum += nums[left];\n        left++;\n        }\n        return sum;\n    }\n}`\n\nThis is my solution and it passed all test case . But I do not understand why people are using DP or writing very extraordinary code  . Am I doing something wrong ?"
                    },
                    {
                        "username": "asaurabh",
                        "content": "I think that\\'s because the ques is more about how you address - \"At most 10^4 calls will be made to sumRange.\" One of the way would be to trade space for speed & store some state that allows you to return responses faster. Hint - self.CumulativeSum[i] = nums[i] + self.CumulativeSum[i-1] i.e. not really a \\'typical\\' coding problem."
                    },
                    {
                        "username": "priyanshu054",
                        "content": "Now, I understood why we use \\'this\\' keyword"
                    },
                    {
                        "username": "user0026X",
                        "content": "I think people try to optimize, so solution won\\'t calculate same queries multiple times. "
                    },
                    {
                        "username": "dpwang",
                        "content": "Why this question\\'s topic  is DP?"
                    },
                    {
                        "username": "rakeshks7",
                        "content": "Because segment trees use pre-calculated values of ranges instead of calculating for each range"
                    },
                    {
                        "username": "ElementNotFoundException",
                        "content": "The solution is to store accumulated sums into a state vector. But is that really dynamic programming or there is some other solution?"
                    },
                    {
                        "username": "dmitrytrager",
                        "content": "For Elixir version I can see following input in test case:\\n[\"NumArray\",\"sumRange\"]\\n[[[-1]],[0,0]]\\n\\nThis is not correct.\\nIf the task here is to implement the NumArray class, then test case should call `init_` function with `nums` and then call `sumRange`. But not to pass function or \"class\" names as strings.\\n\\nPlease fix test cases"
                    },
                    {
                        "username": "charant587",
                        "content": "why cant this be the answer?\\n\\nclass NumArray(object):\\n\\n    def __init__(self, nums):\\n        self.nums=nums\\n        \\n\\n    def sumRange(self, left, right):\\n        return sum(self.nums[left:right+1])\\n"
                    },
                    {
                        "username": "scottwillard9698",
                        "content": "It looks like the input from LeetCode is a two-dimensional list. to get the sum you'd have to access the first list within the NumArray. Therefore return sum(self.nums[0][left:right+1]) or something similar"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    }
                ]
            }
        ]
    },
    {
        "title": "Parse Lisp Expression",
        "question_content": "<p>You are given a string expression representing a Lisp-like expression to return the integer value of.</p>\n\n<p>The syntax for these expressions is given as follows.</p>\n\n<ul>\n\t<li>An expression is either an integer, let expression, add expression, mult expression, or an assigned variable. Expressions always evaluate to a single integer.</li>\n\t<li>(An integer could be positive or negative.)</li>\n\t<li>A let expression takes the form <code>&quot;(let v<sub>1</sub> e<sub>1</sub> v<sub>2</sub> e<sub>2</sub> ... v<sub>n</sub> e<sub>n</sub> expr)&quot;</code>, where let is always the string <code>&quot;let&quot;</code>, then there are one or more pairs of alternating variables and expressions, meaning that the first variable <code>v<sub>1</sub></code> is assigned the value of the expression <code>e<sub>1</sub></code>, the second variable <code>v<sub>2</sub></code> is assigned the value of the expression <code>e<sub>2</sub></code>, and so on sequentially; and then the value of this let expression is the value of the expression <code>expr</code>.</li>\n\t<li>An add expression takes the form <code>&quot;(add e<sub>1</sub> e<sub>2</sub>)&quot;</code> where add is always the string <code>&quot;add&quot;</code>, there are always two expressions <code>e<sub>1</sub></code>, <code>e<sub>2</sub></code> and the result is the addition of the evaluation of <code>e<sub>1</sub></code> and the evaluation of <code>e<sub>2</sub></code>.</li>\n\t<li>A mult expression takes the form <code>&quot;(mult e<sub>1</sub> e<sub>2</sub>)&quot;</code> where mult is always the string <code>&quot;mult&quot;</code>, there are always two expressions <code>e<sub>1</sub></code>, <code>e<sub>2</sub></code> and the result is the multiplication of the evaluation of e1 and the evaluation of e2.</li>\n\t<li>For this question, we will use a smaller subset of variable names. A variable starts with a lowercase letter, then zero or more lowercase letters or digits. Additionally, for your convenience, the names <code>&quot;add&quot;</code>, <code>&quot;let&quot;</code>, and <code>&quot;mult&quot;</code> are protected and will never be used as variable names.</li>\n\t<li>Finally, there is the concept of scope. When an expression of a variable name is evaluated, within the context of that evaluation, the innermost scope (in terms of parentheses) is checked first for the value of that variable, and then outer scopes are checked sequentially. It is guaranteed that every expression is legal. Please see the examples for more details on the scope.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;(let x 2 (mult x (let x 3 y 4 (add x y))))&quot;\n<strong>Output:</strong> 14\n<strong>Explanation:</strong> In the expression (add x y), when checking for the value of the variable x,\nwe check from the innermost scope to the outermost in the context of the variable we are trying to evaluate.\nSince x = 3 is found first, the value of x is 3.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;(let x 3 x 2 x)&quot;\n<strong>Output:</strong> 2\n<strong>Explanation:</strong> Assignment in let statements is processed sequentially.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> expression = &quot;(let x 1 y 2 x (add x y) (add x y))&quot;\n<strong>Output:</strong> 5\n<strong>Explanation:</strong> The first (add x y) evaluates as 3, and is assigned to x.\nThe second (add x y) evaluates as 3+2 = 5.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= expression.length &lt;= 2000</code></li>\n\t<li>There are no leading or trailing spaces in <code>expression</code>.</li>\n\t<li>All tokens are separated by a single space in <code>expression</code>.</li>\n\t<li>The answer and all intermediate calculations of that answer are guaranteed to fit in a <strong>32-bit</strong> integer.</li>\n\t<li>The expression is guaranteed to be legal and evaluate to an integer.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 113902,
                "title": "a-clean-java-solution",
                "content": "```\\npublic int evaluate(String expression) {\\n    return eval(expression, new HashMap<>());\\n}\\nprivate int eval(String exp, Map<String, Integer> parent) {\\n    if (exp.charAt(0) != '(') {\\n        // just a number or a symbol\\n        if (Character.isDigit(exp.charAt(0)) || exp.charAt(0) == '-')\\n            return Integer.parseInt(exp);\\n        return parent.get(exp);\\n    }\\n    // create a new scope, add add all the previous values to it\\n    Map<String, Integer> map = new HashMap<>();\\n    map.putAll(parent);\\n    List<String> tokens = parse(exp.substring(exp.charAt(1) == 'm' ? 6 : 5, exp.length() - 1));\\n    if (exp.startsWith(\"(a\")) { // add\\n        return eval(tokens.get(0), map) + eval(tokens.get(1), map);\\n    } else if (exp.startsWith(\"(m\")) { // mult\\n        return eval(tokens.get(0), map) * eval(tokens.get(1), map);\\n    } else { // let\\n        for (int i = 0; i < tokens.size() - 2; i += 2)\\n            map.put(tokens.get(i), eval(tokens.get(i + 1), map));\\n        return eval(tokens.get(tokens.size() - 1), map);\\n    }\\n}\\nprivate List<String> parse(String str) {\\n    // seperate the values between two parentheses\\n    List<String> res = new ArrayList<>();\\n    int par = 0;\\n    StringBuilder sb = new StringBuilder();\\n    for (char c: str.toCharArray()) {\\n        if (c == '(') par++;\\n        if (c == ')') par--;\\n        if (par == 0 && c == ' ') {\\n            res.add(new String(sb));\\n            sb = new StringBuilder();\\n        } else {\\n            sb.append(c);\\n        }\\n    }\\n    if (sb.length() > 0) res.add(new String(sb));\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int evaluate(String expression) {\\n    return eval(expression, new HashMap<>());\\n}\\nprivate int eval(String exp, Map<String, Integer> parent) {\\n    if (exp.charAt(0) != '(') {\\n        // just a number or a symbol\\n        if (Character.isDigit(exp.charAt(0)) || exp.charAt(0) == '-')\\n            return Integer.parseInt(exp);\\n        return parent.get(exp);\\n    }\\n    // create a new scope, add add all the previous values to it\\n    Map<String, Integer> map = new HashMap<>();\\n    map.putAll(parent);\\n    List<String> tokens = parse(exp.substring(exp.charAt(1) == 'm' ? 6 : 5, exp.length() - 1));\\n    if (exp.startsWith(\"(a\")) { // add\\n        return eval(tokens.get(0), map) + eval(tokens.get(1), map);\\n    } else if (exp.startsWith(\"(m\")) { // mult\\n        return eval(tokens.get(0), map) * eval(tokens.get(1), map);\\n    } else { // let\\n        for (int i = 0; i < tokens.size() - 2; i += 2)\\n            map.put(tokens.get(i), eval(tokens.get(i + 1), map));\\n        return eval(tokens.get(tokens.size() - 1), map);\\n    }\\n}\\nprivate List<String> parse(String str) {\\n    // seperate the values between two parentheses\\n    List<String> res = new ArrayList<>();\\n    int par = 0;\\n    StringBuilder sb = new StringBuilder();\\n    for (char c: str.toCharArray()) {\\n        if (c == '(') par++;\\n        if (c == ')') par--;\\n        if (par == 0 && c == ' ') {\\n            res.add(new String(sb));\\n            sb = new StringBuilder();\\n        } else {\\n            sb.append(c);\\n        }\\n    }\\n    if (sb.length() > 0) res.add(new String(sb));\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109709,
                "title": "python-solution-using-stacks",
                "content": "Using a stack, when encountering '(', save the current tokens and variable states in the stack.\\n```\\ndef evaluate(self, expression):\\n    st, d, tokens = [], {}, ['']\\n\\n    def getval(x):\\n        return d.get(x, x)\\n\\n    def evaluate(tokens):\\n        if tokens[0] in ('add', 'mult'):\\n            tmp = map(int, map(getval, tokens[1:]))\\n            return str(tmp[0] + tmp[1] if tokens[0] == 'add' else tmp[0] * tmp[1])\\n        else: #let\\n            for i in xrange(1, len(tokens)-1, 2):\\n                if tokens[i+1]:\\n                    d[tokens[i]] = getval(tokens[i+1])\\n            return getval(tokens[-1])\\n\\n    for c in expression:\\n        if c == '(':\\n            if tokens[0] == 'let':\\n                evaluate(tokens)\\n            st.append((tokens, dict(d)))\\n            tokens =  ['']\\n        elif c == ' ':\\n            tokens.append('')\\n        elif c == ')':\\n            val = evaluate(tokens)\\n            tokens, d = st.pop()\\n            tokens[-1] += val\\n        else:\\n            tokens[-1] += c\\n    return int(tokens[0])\\n```",
                "solutionTags": [],
                "code": "```\\ndef evaluate(self, expression):\\n    st, d, tokens = [], {}, ['']\\n\\n    def getval(x):\\n        return d.get(x, x)\\n\\n    def evaluate(tokens):\\n        if tokens[0] in ('add', 'mult'):\\n            tmp = map(int, map(getval, tokens[1:]))\\n            return str(tmp[0] + tmp[1] if tokens[0] == 'add' else tmp[0] * tmp[1])\\n        else: #let\\n            for i in xrange(1, len(tokens)-1, 2):\\n                if tokens[i+1]:\\n                    d[tokens[i]] = getval(tokens[i+1])\\n            return getval(tokens[-1])\\n\\n    for c in expression:\\n        if c == '(':\\n            if tokens[0] == 'let':\\n                evaluate(tokens)\\n            st.append((tokens, dict(d)))\\n            tokens =  ['']\\n        elif c == ' ':\\n            tokens.append('')\\n        elif c == ')':\\n            val = evaluate(tokens)\\n            tokens, d = st.pop()\\n            tokens[-1] += val\\n        else:\\n            tokens[-1] += c\\n    return int(tokens[0])\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 109718,
                "title": "java-modularized-solution",
                "content": "These type of problems are notorious for their complex and intertwined nature. A modularized approach would certainly help to clarify the problem. So here is how I would divide the original problem into different modules.\\n\\n1. For an input string `expression`, we have the function `evaluate` to resolve its value.\\n\\n2. The input `expression` must be one of the following three types of expressions -- `add`, `mult` and `let`. Correspondingly we will have three functions to evaluate each of them --`evaluateAdd`, `evaluateMult` and `evaluateLet`.\\n\\n3. All the three types of expressions can be thought of as composed by **operands**, where each operand can be an integer, a variable or another expression of the three types mentioned above (note the expression will be enclosed in parentheses).\\n\\n* An `add` expression contains `2` operands and is evaluated to be the sum of the two operands.\\n\\n* A `mult` expression also contains `2` operands and is evaluated to be the product of the two operands.\\n\\n* A `let` expression contains `2m + 1` operands and is evaluated to be the value of the last operand. The first `m` pairs of operands correspond to `m` assignments. For each pair, the first operand is a variable while the second can be an integer, a variable or another expression. **To simulate the assignment operations**, we will maintain a `HashMap`, which maps the variable to the assigned values (this also implies the `evaluate` function in step 1 should be delegated to a subroutine with an additional `HashMap` parameter). **To simulate the concept of scope**, the assigned values will be placed in a stack. Whenever the `let` expression returns, all assignments performed within it become invalid and should be popped out of the stack.\\n\\n4. From the analyses above, given an expression `e`, we need to identify its constituent operands. We will have two functions serving for this purpose.\\n\\n* `getOperand`: this function will obtain the string representation of the operand starting from the specified `offset` into the expression `e`. It will distinguish the three types of operands -- an integer, a variable or another expression (of type `add`, `mult` or `let`).\\n\\n* `evaluateOperand`: this function will evaluate the operand string obtained above. For an operand of integer type, it will parse the string as an integer; for an operand of variable type, it will look up its value in the hash map; for an operand of expression type, it will recursively call the `evaluate` function to resolve its value.\\n\\nPutting everything together, here is the modularized solution:\\n\\n```\\npublic int evaluate(String expression) {\\n    return evaluate(expression, new HashMap<>());\\n}\\n\\nprivate int evaluate(String e, Map<String, Deque<Integer>> map) {\\n    char c = e.charAt(1);          // the expression must start with \"(add \" or \"(mult \" or \"(let \". \\n        \\n    if (c == 'a') {                // \"add\" expression\\n        return evaluateAdd(e, map);\\n    } else if (c == 'm') {         // \"mult\" expression\\n        return evaluateMult(e, map);\\n    } else if (c == 'l') {         // \"let\" expression\\n        return evaluateLet(e, map);\\n    } else {\\n        return 0;                  // illegal expression so return 0\\n    }\\n}\\n    \\nprivate int evaluateAdd(String e, Map<String, Deque<Integer>> map) {\\n    int offset = 5;      // the expression starts with \"(add \", so offset starts at 5.\\n    String o1 = getOperand(e, offset);  // 1st operand\\n        \\n    offset += o1.length() + 1;\\n    String o2 = getOperand(e, offset);  // 2nd operand\\n        \\n    return evaluateOperand(o1, map) + evaluateOperand(o2, map);\\n}\\n    \\nprivate int evaluateMult(String e, Map<String, Deque<Integer>> map) {\\n    int offset = 6;      // the expression starts with \"(mult \", so offset starts at 6.\\n    String o1 = getOperand(e, offset);  // 1st operand\\n        \\n    offset += o1.length() + 1;\\n    String o2 = getOperand(e, offset);  // 2nd operand\\n        \\n    return evaluateOperand(o1, map) * evaluateOperand(o2, map);\\n}\\n    \\nprivate int evaluateLet(String e, Map<String, Deque<Integer>> map) {\\n    List<String> variables = new ArrayList<>();  // list of variables assigned in this \"let\" expression\\n    int res = 0;     // the result of this \"let\" expression\\n    int offset = 5;  // the expression starts with \"(let \", so offset starts at 5.\\n        \\n    while (offset < e.length()) {\\n        String o1 = getOperand(e, offset);  // 1st operand\\n        offset += o1.length() + 1;\\n            \\n        String o2 = getOperand(e, offset);  // 2nd operand\\n            \\n        if (o2 == null) {\\n            res = evaluateOperand(o1, map); // if 2nd operand is null, we reached the last operand\\n            break;\\n        }\\n            \\n        offset += o2.length() + 1;\\n\\n        variables.add(o1);  // record the variable\\n        \\n        if (!map.containsKey(o1)) map.put(o1, new ArrayDeque<>());\\n        \\n        map.get(o1).offerFirst(evaluateOperand(o2, map));  // do the assignment\\n    }\\n    \\n    // pop out assigned values before returning from this \"let\" expression\\n    for (int i = variables.size() - 1; i >= 0; i--) {\\n        String variable = variables.get(i);\\n        Deque<Integer> stack = map.get(variable);\\n        stack.pollFirst();\\n        if (stack.isEmpty()) map.remove(variable);\\n    }\\n        \\n    return res;\\n}\\n    \\nprivate String getOperand(String e, int offset) {\\n    if (offset >= e.length()) return null;  // invalid offset\\n    \\n    char c = e.charAt(offset);\\n    int start = offset;\\n        \\n    if (c == '-' || Character.isDigit(c)) {  // operand is an integer\\n        if (c == '-') offset++;\\n        while (offset < e.length() && Character.isDigit(e.charAt(offset))) offset++;\\n            \\n    } else if (Character.isLowerCase(c)) {  // operand is a variable\\n        while (offset < e.length() && Character.isLetterOrDigit(e.charAt(offset))) offset++;\\n            \\n    } else {                                // operand is another expression enclosed in parentheses\\n        for (int cnt = 0; offset < e.length();) {\\n            c = e.charAt(offset++);\\n            if (c == '(') cnt++;\\n            if (c == ')') cnt--;\\n            if (cnt == 0) break;\\n        }\\n    }\\n        \\n    return e.substring(start, offset);\\n}\\n    \\nprivate int evaluateOperand(String e, Map<String, Deque<Integer>> map) {\\n    char c = e.charAt(0);\\n        \\n    if (c == '-' || Character.isDigit(c)) {  // operand is an integer so parse it\\n        return Integer.parseInt(e);\\n            \\n    } else if (Character.isLowerCase(c)) {  // operand is a variable so look it up\\n        return map.get(e).peekFirst();\\n            \\n    } else {                               // operand is another expression so evaluate it recursively\\n        return evaluate(e, map);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic int evaluate(String expression) {\\n    return evaluate(expression, new HashMap<>());\\n}\\n\\nprivate int evaluate(String e, Map<String, Deque<Integer>> map) {\\n    char c = e.charAt(1);          // the expression must start with \"(add \" or \"(mult \" or \"(let \". \\n        \\n    if (c == 'a') {                // \"add\" expression\\n        return evaluateAdd(e, map);\\n    } else if (c == 'm') {         // \"mult\" expression\\n        return evaluateMult(e, map);\\n    } else if (c == 'l') {         // \"let\" expression\\n        return evaluateLet(e, map);\\n    } else {\\n        return 0;                  // illegal expression so return 0\\n    }\\n}\\n    \\nprivate int evaluateAdd(String e, Map<String, Deque<Integer>> map) {\\n    int offset = 5;      // the expression starts with \"(add \", so offset starts at 5.\\n    String o1 = getOperand(e, offset);  // 1st operand\\n        \\n    offset += o1.length() + 1;\\n    String o2 = getOperand(e, offset);  // 2nd operand\\n        \\n    return evaluateOperand(o1, map) + evaluateOperand(o2, map);\\n}\\n    \\nprivate int evaluateMult(String e, Map<String, Deque<Integer>> map) {\\n    int offset = 6;      // the expression starts with \"(mult \", so offset starts at 6.\\n    String o1 = getOperand(e, offset);  // 1st operand\\n        \\n    offset += o1.length() + 1;\\n    String o2 = getOperand(e, offset);  // 2nd operand\\n        \\n    return evaluateOperand(o1, map) * evaluateOperand(o2, map);\\n}\\n    \\nprivate int evaluateLet(String e, Map<String, Deque<Integer>> map) {\\n    List<String> variables = new ArrayList<>();  // list of variables assigned in this \"let\" expression\\n    int res = 0;     // the result of this \"let\" expression\\n    int offset = 5;  // the expression starts with \"(let \", so offset starts at 5.\\n        \\n    while (offset < e.length()) {\\n        String o1 = getOperand(e, offset);  // 1st operand\\n        offset += o1.length() + 1;\\n            \\n        String o2 = getOperand(e, offset);  // 2nd operand\\n            \\n        if (o2 == null) {\\n            res = evaluateOperand(o1, map); // if 2nd operand is null, we reached the last operand\\n            break;\\n        }\\n            \\n        offset += o2.length() + 1;\\n\\n        variables.add(o1);  // record the variable\\n        \\n        if (!map.containsKey(o1)) map.put(o1, new ArrayDeque<>());\\n        \\n        map.get(o1).offerFirst(evaluateOperand(o2, map));  // do the assignment\\n    }\\n    \\n    // pop out assigned values before returning from this \"let\" expression\\n    for (int i = variables.size() - 1; i >= 0; i--) {\\n        String variable = variables.get(i);\\n        Deque<Integer> stack = map.get(variable);\\n        stack.pollFirst();\\n        if (stack.isEmpty()) map.remove(variable);\\n    }\\n        \\n    return res;\\n}\\n    \\nprivate String getOperand(String e, int offset) {\\n    if (offset >= e.length()) return null;  // invalid offset\\n    \\n    char c = e.charAt(offset);\\n    int start = offset;\\n        \\n    if (c == '-' || Character.isDigit(c)) {  // operand is an integer\\n        if (c == '-') offset++;\\n        while (offset < e.length() && Character.isDigit(e.charAt(offset))) offset++;\\n            \\n    } else if (Character.isLowerCase(c)) {  // operand is a variable\\n        while (offset < e.length() && Character.isLetterOrDigit(e.charAt(offset))) offset++;\\n            \\n    } else {                                // operand is another expression enclosed in parentheses\\n        for (int cnt = 0; offset < e.length();) {\\n            c = e.charAt(offset++);\\n            if (c == '(') cnt++;\\n            if (c == ')') cnt--;\\n            if (cnt == 0) break;\\n        }\\n    }\\n        \\n    return e.substring(start, offset);\\n}\\n    \\nprivate int evaluateOperand(String e, Map<String, Deque<Integer>> map) {\\n    char c = e.charAt(0);\\n        \\n    if (c == '-' || Character.isDigit(c)) {  // operand is an integer so parse it\\n        return Integer.parseInt(e);\\n            \\n    } else if (Character.isLowerCase(c)) {  // operand is a variable so look it up\\n        return map.get(e).peekFirst();\\n            \\n    } else {                               // operand is another expression so evaluate it recursively\\n        return evaluate(e, map);\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109721,
                "title": "c-recursion-solution-with-explaination",
                "content": "If the expression is a variable, we look up in the map and return the variable value. If the expression is a value, we simply return its value.\\n\\nFor the \"let\" case, we first get the variable name, and the following expression. Then we evaluate the expression, and use a map to assign the expression value to the variable. For example, consider \"(let x (add 2 3) x)\", the variable is \"x\", and we evaluate the expression \"(add 2 3)\", and assign x = 5. For the last \"x\", we recursively call the help function, and get its value 5.\\n\\nFor the \"add\" case, we evaluate the value of the first expression, and the second expression, and add them together. For example, consider \"(add (add 2 3) (add 3 4))\", the first expression is \"(add 2 3)\", and the second expression is \"(add 3 4)\". We get 5 after evaluating \"(add 2 3)\", and get 7 after evaluating \"(add 3 4)\", and we will return 12.\\n\\nThe \"mult\" case is similar to the \"add\" case.\\n\\n```\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        unordered_map<string,int> myMap;\\n        return help(expression,myMap);\\n    }\\n    \\n    int help(string expression,unordered_map<string,int> myMap) {\\n        if ((expression[0] == '-') || (expression[0] >= '0' && expression[0] <= '9'))\\n            return stoi(expression);\\n        else if (expression[0] != '(')\\n            return myMap[expression];\\n        //to get rid of the first '(' and the last ')'\\n        string s = expression.substr(1,expression.size()-2);\\n        int start = 0;\\n        string word = parse(s,start);\\n        if (word == \"let\") {\\n            while (true) {\\n                string variable = parse(s,start);\\n                //if there is no more expression, simply evaluate the variable\\n                if (start > s.size())\\n                    return help(variable,myMap);\\n                string temp = parse(s,start);\\n                myMap[variable] = help(temp,myMap);                    \\n            }\\n        }\\n        else if (word == \"add\") \\n            return help(parse(s,start),myMap) + help(parse(s,start),myMap);\\n        else if (word == \"mult\") \\n            return help(parse(s,start),myMap) * help(parse(s,start),myMap);\\n    }\\n    \\n    //function to seperate each expression\\n    string parse(string &s,int &start) {\\n        int end = start+1, temp = start, count = 1;\\n        if (s[start] == '(') {\\n            while (count != 0) {\\n                if (s[end] == '(')\\n                    count++;\\n                else if (s[end] == ')')\\n                    count--;\\n                end++;\\n            }\\n        }\\n        else {\\n            while (end < s.size() && s[end] != ' ')\\n                end++;\\n        }\\n        start = end+1;\\n        return s.substr(temp,end-temp);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        unordered_map<string,int> myMap;\\n        return help(expression,myMap);\\n    }\\n    \\n    int help(string expression,unordered_map<string,int> myMap) {\\n        if ((expression[0] == '-') || (expression[0] >= '0' && expression[0] <= '9'))\\n            return stoi(expression);\\n        else if (expression[0] != '(')\\n            return myMap[expression];\\n        //to get rid of the first '(' and the last ')'\\n        string s = expression.substr(1,expression.size()-2);\\n        int start = 0;\\n        string word = parse(s,start);\\n        if (word == \"let\") {\\n            while (true) {\\n                string variable = parse(s,start);\\n                //if there is no more expression, simply evaluate the variable\\n                if (start > s.size())\\n                    return help(variable,myMap);\\n                string temp = parse(s,start);\\n                myMap[variable] = help(temp,myMap);                    \\n            }\\n        }\\n        else if (word == \"add\") \\n            return help(parse(s,start),myMap) + help(parse(s,start),myMap);\\n        else if (word == \"mult\") \\n            return help(parse(s,start),myMap) * help(parse(s,start),myMap);\\n    }\\n    \\n    //function to seperate each expression\\n    string parse(string &s,int &start) {\\n        int end = start+1, temp = start, count = 1;\\n        if (s[start] == '(') {\\n            while (count != 0) {\\n                if (s[end] == '(')\\n                    count++;\\n                else if (s[end] == ')')\\n                    count--;\\n                end++;\\n            }\\n        }\\n        else {\\n            while (end < s.size() && s[end] != ' ')\\n                end++;\\n        }\\n        start = end+1;\\n        return s.substr(temp,end-temp);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 197821,
                "title": "recursive-descent-parser-grammar-ll-2-and-building-the-ast-out-of-the-input-in-o-n",
                "content": "Same logical as with any parser -> find the grammar first. The grammr for this restricted lisp is rather easy and is already stated in the problem.\\n\\n**Grammar (LL(2))**\\n\\n    expr          := let_expr | add_expr | mult_expr | var | int\\n    let_expr      := \\'(\\' \\'let\\' var_expr_list expr \\')\\'\\n    var_expr_list := var expr var_expr_list | var expr\\n    add_expr      := \\'(\\' \\'add\\' expr expr \\')\\'\\n    mult_expr     := \\'(\\' \\'mult\\' expr expr \\')\\'\\n    var           := [a-z]([a-zA-Z]|\\\\d)*\\n    int           := \\\\d+\\n\\nThe Grammar is LL(2), because 1 lookahead token is not enough to figure out which production to resolve. E.g. for input `(add 1 2)`  we get tokens `[(, let, 1, 2]`. So by reading first token `(` we can not figure out what rule we should apply.\\n\\n---\\nAfter having the Grammar all we need is to convert this into recursive descent parser. This is fairly straight-forward. All we need is to create a function for every production.\\n\\nWe also need the lexing phase -> splitting hte input stream into a stream of tokens. This way we don\\'t need to move idx and check the char on that index and do some crazy things. Just use regex for it. Since we know all possible tokens, just join them together with \"|\" (or/alternate) symbol to pick either of them. \\n\\nEvaluation is a little bit tricky because of passing the context (could have also been done with the help of attributed grammar), but still no magic algorithm.\\n\\nThe result is easy to use, understand and extend Lisp Parser and Evaluator\\n\\n```\\nimport re\\n\\nclass Number(object):\\n    def __init__(self, val): self.val = int(val)\\n    def eval(self, vars_map): return self.val\\n\\nclass Variable(object):\\n    def __init__(self, id): self.id = id\\n    def eval(self, var_map): return var_map[self.id]\\n    def __hash__(self): return hash(self.id)\\n    def __repr__(self): return self.id\\n\\nclass Add(object):\\n    def __init__(self, a, b):\\n        self.a = a\\n        self.b = b\\n    \\n    def eval(self, var_map): return self.a.eval(var_map) + self.b.eval(var_map)\\n\\nclass Mult(object):\\n    def __init__(self, a, b):\\n        self.a = a\\n        self.b = b\\n    \\n    def eval(self, var_map): return self.a.eval(var_map) * self.b.eval(var_map)\\n    \\nclass Let(object):\\n    def __init__(self, var_list, child_expr):\\n        self.var_list = var_list\\n        self.child_expr = child_expr\\n    \\n    def eval(self, var_map):\\n        new_map = dict(var_map)\\n        \\n        for var,expr in self.var_list:\\n            new_map[var.id] = expr.eval(new_map)\\n        \\n        return self.child_expr.eval(new_map)\\n    \\nclass LispParser(object):\\n    def lookahead(self, offset=0): return self.tokens[self.idx+offset]\\n    \\n    def consume(self):\\n        token = self.lookahead()\\n        self.idx += 1\\n        return token\\n    \\n    def parse(self, tokens):\\n        self.tokens = tokens\\n        self.idx = 0\\n        return self.parse_expr()\\n    \\n    def parse_expr(self):\\n        lookahead = self.lookahead()\\n        \\n        if lookahead == \\'(\\':\\n            lookahead = self.lookahead(offset=1)\\n            \\n            if lookahead == \"let\":\\n                return self.parse_let_expr()\\n            elif lookahead == \"add\":\\n                return self.parse_add_expr()\\n            elif lookahead == \"mult\":\\n                return self.parse_mult_expr()\\n            else:\\n                print \"ERROR\"\\n                # shouldn\\'t happen -> parse error\\n            \\n        elif lookahead[0].isalpha():\\n            return Variable(self.consume())\\n        else:\\n            return Number(self.consume())\\n        \\n    def parse_let_expr(self):\\n        self.consume() # \\'(\\'\\n        self.consume() # \\'let\\'\\n        \\n        var_map = self.parse_var_expr_list()\\n        child_expr = self.parse_expr()\\n        \\n        self.consume() # \\')\\'\\n        return Let(var_map, child_expr)\\n    \\n    def parse_var_expr_list(self):\\n        vars = []\\n        \\n        while self.lookahead() != \\'(\\' and (self.idx+1 < len(self.tokens) and self.lookahead(offset=1) != \\')\\'):\\n            var = Variable(self.consume())\\n            expr = self.parse_expr()\\n            vars.append([var, expr])\\n\\n        return vars\\n    \\n    def parse_add_expr(self):\\n        self.consume() # \"(\"\\n        self.consume() # \"add\"\\n        \\n        a,b = self.parse_expr(),self.parse_expr()\\n        self.consume() # \")\"\\n\\n        return Add(a,b)\\n    \\n    def parse_mult_expr(self):\\n        self.consume() # \"(\"\\n        self.consume() # \"mult\"\\n        \\n        a,b = self.parse_expr(),self.parse_expr()\\n        self.consume() # \")\"\\n\\n        return Mult(a,b)\\n        \\nclass Solution(object):\\n    def evaluate(self, expression):\\n        token_classes = [\\n            \"\\\\(\",\\n            \"\\\\)\",\\n            \"let\",\\n            \"add\",\\n            \"mult\",\\n            \"[a-z][a-z0-9]*\", # var\\n            \"\\\\d+|\\\\-\\\\d+\" # int\\n        ]\\n        \\n        def scan(): return re.findall(\"|\".join(token_classes), expression)\\n        \\n        parser = LispParser()\\n        tokens = scan()\\n        return parser.parse(tokens).eval({})\\n```",
                "solutionTags": [],
                "code": "```\\nimport re\\n\\nclass Number(object):\\n    def __init__(self, val): self.val = int(val)\\n    def eval(self, vars_map): return self.val\\n\\nclass Variable(object):\\n    def __init__(self, id): self.id = id\\n    def eval(self, var_map): return var_map[self.id]\\n    def __hash__(self): return hash(self.id)\\n    def __repr__(self): return self.id\\n\\nclass Add(object):\\n    def __init__(self, a, b):\\n        self.a = a\\n        self.b = b\\n    \\n    def eval(self, var_map): return self.a.eval(var_map) + self.b.eval(var_map)\\n\\nclass Mult(object):\\n    def __init__(self, a, b):\\n        self.a = a\\n        self.b = b\\n    \\n    def eval(self, var_map): return self.a.eval(var_map) * self.b.eval(var_map)\\n    \\nclass Let(object):\\n    def __init__(self, var_list, child_expr):\\n        self.var_list = var_list\\n        self.child_expr = child_expr\\n    \\n    def eval(self, var_map):\\n        new_map = dict(var_map)\\n        \\n        for var,expr in self.var_list:\\n            new_map[var.id] = expr.eval(new_map)\\n        \\n        return self.child_expr.eval(new_map)\\n    \\nclass LispParser(object):\\n    def lookahead(self, offset=0): return self.tokens[self.idx+offset]\\n    \\n    def consume(self):\\n        token = self.lookahead()\\n        self.idx += 1\\n        return token\\n    \\n    def parse(self, tokens):\\n        self.tokens = tokens\\n        self.idx = 0\\n        return self.parse_expr()\\n    \\n    def parse_expr(self):\\n        lookahead = self.lookahead()\\n        \\n        if lookahead == \\'(\\':\\n            lookahead = self.lookahead(offset=1)\\n            \\n            if lookahead == \"let\":\\n                return self.parse_let_expr()\\n            elif lookahead == \"add\":\\n                return self.parse_add_expr()\\n            elif lookahead == \"mult\":\\n                return self.parse_mult_expr()\\n            else:\\n                print \"ERROR\"\\n                # shouldn\\'t happen -> parse error\\n            \\n        elif lookahead[0].isalpha():\\n            return Variable(self.consume())\\n        else:\\n            return Number(self.consume())\\n        \\n    def parse_let_expr(self):\\n        self.consume() # \\'(\\'\\n        self.consume() # \\'let\\'\\n        \\n        var_map = self.parse_var_expr_list()\\n        child_expr = self.parse_expr()\\n        \\n        self.consume() # \\')\\'\\n        return Let(var_map, child_expr)\\n    \\n    def parse_var_expr_list(self):\\n        vars = []\\n        \\n        while self.lookahead() != \\'(\\' and (self.idx+1 < len(self.tokens) and self.lookahead(offset=1) != \\')\\'):\\n            var = Variable(self.consume())\\n            expr = self.parse_expr()\\n            vars.append([var, expr])\\n\\n        return vars\\n    \\n    def parse_add_expr(self):\\n        self.consume() # \"(\"\\n        self.consume() # \"add\"\\n        \\n        a,b = self.parse_expr(),self.parse_expr()\\n        self.consume() # \")\"\\n\\n        return Add(a,b)\\n    \\n    def parse_mult_expr(self):\\n        self.consume() # \"(\"\\n        self.consume() # \"mult\"\\n        \\n        a,b = self.parse_expr(),self.parse_expr()\\n        self.consume() # \")\"\\n\\n        return Mult(a,b)\\n        \\nclass Solution(object):\\n    def evaluate(self, expression):\\n        token_classes = [\\n            \"\\\\(\",\\n            \"\\\\)\",\\n            \"let\",\\n            \"add\",\\n            \"mult\",\\n            \"[a-z][a-z0-9]*\", # var\\n            \"\\\\d+|\\\\-\\\\d+\" # int\\n        ]\\n        \\n        def scan(): return re.findall(\"|\".join(token_classes), expression)\\n        \\n        parser = LispParser()\\n        tokens = scan()\\n        return parser.parse(tokens).eval({})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191901,
                "title": "the-most-concise-python-implementation-to-achieve-true-o-n-time-complexity",
                "content": "\"\"\"\\nThis is the most concise Python implementation to achieve TRUE O(N) time complexity. Most the other posts aren\\'t really O(N); they copy and paste the dictionary/namingspace in each recursive call, which leads to O(N^2) in total.\\nI use the variables = collections.defaultdict(list) structure to represent variable scope.\\n\\nIdea:\\n    1. add or mult is trival.\\n    2. For each value/expression, we call a recursive function to solve it for us.\\n    3. Once we detected a \\'let\\' expression, we keep doing the assignment vi<=ei until the last single term, where vi is a variable name and ei is a value or expression.\\n        It\\'s a bit tricky to detect the last single term, see line <1>.\\n    4. When we have processed a let expression, we need to delete all the local variables. See line <2>\\n    5. A deque data structure is used to model the tokens.\\n\"\"\"\\n```\\nclass Solution:\\n    def evaluate(self, expression):\\n        tokens = collections.deque(expression.replace(\\'(\\', \\' ( \\').replace(\\')\\', \\' ) \\').split())\\n        variables = collections.defaultdict(list)\\n\\n        def recur(tokens):\\n            stack = []\\n            x = tokens.popleft()\\n            if x != \\'(\\': # This is a value or variable name\\n                try: return int(x)\\n                except: return variables[x][-1]\\n            \\n            # Else this is an complex expression\\n            command = tokens.popleft()\\n            if command == \\'let\\':\\n                while tokens:\\n                    if tokens[0] == \\'(\\' or tokens[1] == \\')\\': # This is the last token of let expression; line <1>\\n                        value = recur(tokens)\\n                        tokens.popleft() # get rid of endding )\\n                        while stack: variables[stack.pop()].pop() # Clean up; remove all local defined variables; line <2>\\n                        return value\\n                    \\n                    # The current t=tokens[0] is a variable name\\n                    var = tokens.popleft()\\n                    value = recur(tokens)\\n                    stack.append(var)\\n                    variables[var].append(value)\\n            else:\\n                if command == \\'add\\': result = recur(tokens) + recur(tokens)\\n                else: result = recur(tokens) * recur(tokens)\\n                tokens.popleft() # get rid of endding )\\n                return result\\n        return recur(tokens)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, expression):\\n        tokens = collections.deque(expression.replace(\\'(\\', \\' ( \\').replace(\\')\\', \\' ) \\').split())\\n        variables = collections.defaultdict(list)\\n\\n        def recur(tokens):\\n            stack = []\\n            x = tokens.popleft()\\n            if x != \\'(\\': # This is a value or variable name\\n                try: return int(x)\\n                except: return variables[x][-1]\\n            \\n            # Else this is an complex expression\\n            command = tokens.popleft()\\n            if command == \\'let\\':\\n                while tokens:\\n                    if tokens[0] == \\'(\\' or tokens[1] == \\')\\': # This is the last token of let expression; line <1>\\n                        value = recur(tokens)\\n                        tokens.popleft() # get rid of endding )\\n                        while stack: variables[stack.pop()].pop() # Clean up; remove all local defined variables; line <2>\\n                        return value\\n                    \\n                    # The current t=tokens[0] is a variable name\\n                    var = tokens.popleft()\\n                    value = recur(tokens)\\n                    stack.append(var)\\n                    variables[var].append(value)\\n            else:\\n                if command == \\'add\\': result = recur(tokens) + recur(tokens)\\n                else: result = recur(tokens) * recur(tokens)\\n                tokens.popleft() # get rid of endding )\\n                return result\\n        return recur(tokens)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109730,
                "title": "4-lines",
                "content": "    def evaluate(self, expression):\\n        add, mult = '({}+{})'.format, '({}*{})'.format\\n        let = lambda *a: 'next(' + a[-1] + ''.join(map(' for {} in [{}]'.format, a[:-1:2], a[1::2])) + ')'\\n        e = re.sub(r\"\\\\('(\\\\w+)' \", r'\\\\1(', re.sub('([^ ()]+)', r\"'\\\\1'\", expression)).replace(' ', ', ')\\n        return eval(eval(e))\\n\\nI turn an expression like  \\n`(let x 1 y 2 x (add x y) (mult x y))`\\ninto an expression like  \\n`let('x', '1', 'y', '2', 'x', add('x', 'y'), mult('x', 'y'))`\\nwhich evaluates to the expression  \\n`next((x*y) for x in [1] for y in [2] for x in [(x+y)])`\\nwhich evaluates to the desired output.",
                "solutionTags": [],
                "code": "    def evaluate(self, expression):\\n        add, mult = '({}+{})'.format, '({}*{})'.format\\n        let = lambda *a: 'next(' + a[-1] + ''.join(map(' for {} in [{}]'.format, a[:-1:2], a[1::2])) + ')'\\n        e = re.sub(r\"\\\\('(\\\\w+)' \", r'\\\\1(', re.sub('([^ ()]+)', r\"'\\\\1'\", expression)).replace(' ', ', ')\\n        return eval(eval(e))\\n\\nI turn an expression like  \\n`(let x 1 y 2 x (add x y) (mult x y))`\\ninto an expression like  \\n`let('x', '1', 'y', '2', 'x', add('x', 'y'), mult('x', 'y'))`\\nwhich evaluates to the expression  \\n`next((x*y) for x in [1] for y in [2] for x in [(x+y)])`\\nwhich evaluates to the desired output.",
                "codeTag": "Python3"
            },
            {
                "id": 165118,
                "title": "java-solution-with-detailed-explanation",
                "content": "The general idea is that we want to parse this level of the parenthesis, and recurse down clauses on this level.  At every depth we create a new map that is a deep copy of it\\'s parent since we may overwrite variables for this depth.  Once we have only a single variable, it\\'s either a number or a variable.  If it\\'s a variable we return the mapping (will be it\\'s parents mapping).  If it\\'s a number we return the number.\\n\\nMore detailed explanation:\\n1. We check whether it\\'s a single variable or not by checking if the first character is a ( because a clause will always start with a (\\n2. If it\\'s not a (, we already know this is a single element. We check to see if it\\'s a number by seeing if it leads with a digit or a - sign (for negative numbers), if it is we return the number otherwise we return the mapping.\\n3. We make a deep copy of the parent Hashmap\\n4. We remove the ( and ) by excluding the first and last character, \\nthen Parse to generate the tokens by splitting the string by spaces, but leaving clauses of ( ) alone as a whole token, so we only split if the number of open parenthesis is 0.\\n5. if the first character is an a then we return recurse on the 2nd token + recurse on the 3rd token (the first token is the add instruction)\\n6. if the first character is a m then we return recurse on the 2nd token * recurse on the 3rd token (first token is the mult instruction)\\n7. otherwise it\\'s a let:\\n  a.we go through each set of two token and assign the first token to the recurse of the 2nd token (since it may be a clause) from 1 to n-1 where n is the number of tokens\\n\\tb. we return the recurse of the last token.\\n\\nNote: We recurse every time when a token may be a clause to resolve the clause, therefore the only time we return a single variable is the beginning\\n\\n\\n\\n```\\nclass Solution {\\n    public int evaluate(String expression) {\\n        return calc(expression,new HashMap<>());\\n    }\\n    private int calc(String expr, Map<String,Integer> parent){\\n        if(expr.charAt(0)!=\\'(\\'){\\n            if(Character.isDigit(expr.charAt(0))||expr.charAt(0)==\\'-\\'){\\n                //this is a single number so return it\\n                return Integer.parseInt(expr);\\n            }\\n            else{\\n                //this is a single variable so return it\\n                return parent.get(expr);\\n            }\\n        }\\n        //remove the )\\n        String s = expr.substring(1,expr.length()-1);\\n        char c = s.charAt(0);\\n        Map<String,Integer> map = new HashMap<>();\\n        map.putAll(parent);\\n        List<String> tokens = parse(s);\\n        if(c==\\'a\\'){\\n            return calc(tokens.get(1),map) + calc(tokens.get(2),map);\\n        }\\n        else if(c==\\'m\\'){\\n            return calc(tokens.get(1),map)*calc(tokens.get(2),map);\\n        }\\n        else{\\n            //let statement\\n            for(int i=1; i<tokens.size()-1;i+=2){\\n                map.put(tokens.get(i),calc(tokens.get(i+1),map));\\n            }\\n            return calc(tokens.get(tokens.size()-1),map);\\n        }\\n    }\\n    //The first argument will always be the command (add, etc.) returns a list of the parameters, either single elements or clauses on this         level\\n    private List<String> parse(String s){\\n        int open = 0;\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<s.length();++i){\\n            char c = s.charAt(i);\\n            if(c==\\'(\\'){\\n                ++open;\\n            }\\n            else if(c==\\')\\'){\\n                --open;\\n            }\\n            if(open==0 && c==\\' \\'){\\n                res.add(sb.toString());\\n                sb = new StringBuilder();\\n            }\\n            else{\\n                sb.append(c);\\n            }\\n        }\\n        if(sb.length()>0){\\n            res.add(sb.toString());\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int evaluate(String expression) {\\n        return calc(expression,new HashMap<>());\\n    }\\n    private int calc(String expr, Map<String,Integer> parent){\\n        if(expr.charAt(0)!=\\'(\\'){\\n            if(Character.isDigit(expr.charAt(0))||expr.charAt(0)==\\'-\\'){\\n                //this is a single number so return it\\n                return Integer.parseInt(expr);\\n            }\\n            else{\\n                //this is a single variable so return it\\n                return parent.get(expr);\\n            }\\n        }\\n        //remove the )\\n        String s = expr.substring(1,expr.length()-1);\\n        char c = s.charAt(0);\\n        Map<String,Integer> map = new HashMap<>();\\n        map.putAll(parent);\\n        List<String> tokens = parse(s);\\n        if(c==\\'a\\'){\\n            return calc(tokens.get(1),map) + calc(tokens.get(2),map);\\n        }\\n        else if(c==\\'m\\'){\\n            return calc(tokens.get(1),map)*calc(tokens.get(2),map);\\n        }\\n        else{\\n            //let statement\\n            for(int i=1; i<tokens.size()-1;i+=2){\\n                map.put(tokens.get(i),calc(tokens.get(i+1),map));\\n            }\\n            return calc(tokens.get(tokens.size()-1),map);\\n        }\\n    }\\n    //The first argument will always be the command (add, etc.) returns a list of the parameters, either single elements or clauses on this         level\\n    private List<String> parse(String s){\\n        int open = 0;\\n        List<String> res = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<s.length();++i){\\n            char c = s.charAt(i);\\n            if(c==\\'(\\'){\\n                ++open;\\n            }\\n            else if(c==\\')\\'){\\n                --open;\\n            }\\n            if(open==0 && c==\\' \\'){\\n                res.add(sb.toString());\\n                sb = new StringBuilder();\\n            }\\n            else{\\n                sb.append(c);\\n            }\\n        }\\n        if(sb.length()>0){\\n            res.add(sb.toString());\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 116917,
                "title": "c-easiest-shortest-o-n-v-i-a-stringstream",
                "content": "```\nclass Solution {\npublic:\n    \n    stringstream ss;\n    unordered_map<string, vector<int>> var;\n    int UNUSED = 1337;\n\n    int evaluate(string s0) {\n        string s;\n        for(char c : s0) s.append(c == '(' ? \" ( \" : c == ')' ? \" ) \" : string(1, c)); \n        ss = stringstream(s);\n        return solve().second;\n    }\n\n    pair<string, int> solve(){\n        string t; ss >> t;\n        int ret;\n        if(t == \"(\"){\n            string op; ss >> op;\n            if(op == \"add\" || op == \"mult\"){\n                auto op1 = solve(), op2 = solve();\n                string discard; ss >> discard;\n                ret = op == \"add\" ? op1.second+op2.second : op1.second*op2.second;\n            } else {\n                vector<string> assign;\n                pair<string, int> l, r;\n                while(true){\n                    l = solve(), r = solve(), ret = l.second;\n                    if(r.first == \")\") break;\n                    var[l.first].push_back(r.second);\n                    assign.push_back(l.first);\n                }\n                for(string a : assign) var[a].pop_back();\n            }\n        }\n        else if(t == \")\") ret = UNUSED;\n        else if(isalpha(t.front())) ret = var[t].empty() ? UNUSED : var[t].back();\n        else ret = stoi(t);\n        return {t, ret};\n    }   \n};\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\npublic:\n    \n    stringstream ss;\n    unordered_map<string, vector<int>> var;\n    int UNUSED = 1337;\n\n    int evaluate(string s0) {\n        string s;\n        for(char c : s0) s.append(c == '(' ? \" ( \" : c == ')' ? \" ) \" : string(1, c)); \n        ss = stringstream(s);\n        return solve().second;\n    }\n\n    pair<string, int> solve(){\n        string t; ss >> t;\n        int ret;\n        if(t == \"(\"){\n            string op; ss >> op;\n            if(op == \"add\" || op == \"mult\"){\n                auto op1 = solve(), op2 = solve();\n                string discard; ss >> discard;\n                ret = op == \"add\" ? op1.second+op2.second : op1.second*op2.second;\n            } else {\n                vector<string> assign;\n                pair<string, int> l, r;\n                while(true){\n                    l = solve(), r = solve(), ret = l.second;\n                    if(r.first == \")\") break;\n                    var[l.first].push_back(r.second);\n                    assign.push_back(l.first);\n                }\n                for(string a : assign) var[a].pop_back();\n            }\n        }\n        else if(t == \")\") ret = UNUSED;\n        else if(isalpha(t.front())) ret = var[t].empty() ? UNUSED : var[t].back();\n        else ret = stoi(t);\n        return {t, ret};\n    }   \n};\n```",
                "codeTag": "Java"
            },
            {
                "id": 109715,
                "title": "c-concise-top-down-parser",
                "content": "```\\nclass Solution {\\npublic:\\n  int evaluate(string expression) {\\n    int i = 0;\\n    return parse(expression, expression.size(), i, {});\\n  }\\n\\n  int parse(string& s, int n, int& i, unordered_map<string, int> m) {\\n    int res = 0;\\n    if (s[i] == '(') ++i;\\n    if (s.substr(i, 3) == \"add\") { // add expr\\n      i += 4;\\n      int left = parse(s, n, i, m);\\n      ++i;\\n      int right = parse(s, n, i, m);\\n      res = left + right;\\n    } else if (s.substr(i, 4) == \"mult\") { // mult expr\\n      i += 5;\\n      int left = parse(s, n, i, m);\\n      ++i;\\n      int right = parse(s, n, i, m);\\n      res = left * right;\\n    } else if (s.substr(i, 3) == \"let\") { // let expr\\n      i += 4;\\n      while (i < n && s[i] != ')') {\\n        string var;\\n        if (isalpha(s[i])) while (i < n && isalnum(s[i])) var += s[i++];\\n        else { res = parse(s, n, i, m); break; }\\n        if (s[i] == ' ') {\\n          ++i;\\n          m[var] = parse(s, n, i, m);\\n          ++i;\\n        } else if (s[i] == ')') res = m[var];\\n      }\\n    } else if (isalpha(s[i])) { // assigned expr\\n      string var;\\n      while (i < n && isalnum(s[i])) var += s[i++];\\n      res = m[var];\\n    } else { // integer expr\\n      int sign = 1;\\n      if (s[i] == '-') { sign = -1; ++i; }\\n      while (i < n && isdigit(s[i])) res = res*10 + s[i++]-'0';\\n      res *= sign;\\n    }\\n    if (s[i] == ')') ++i;\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  int evaluate(string expression) {\\n    int i = 0;\\n    return parse(expression, expression.size(), i, {});\\n  }\\n\\n  int parse(string& s, int n, int& i, unordered_map<string, int> m) {\\n    int res = 0;\\n    if (s[i] == '(') ++i;\\n    if (s.substr(i, 3) == \"add\") { // add expr\\n      i += 4;\\n      int left = parse(s, n, i, m);\\n      ++i;\\n      int right = parse(s, n, i, m);\\n      res = left + right;\\n    } else if (s.substr(i, 4) == \"mult\") { // mult expr\\n      i += 5;\\n      int left = parse(s, n, i, m);\\n      ++i;\\n      int right = parse(s, n, i, m);\\n      res = left * right;\\n    } else if (s.substr(i, 3) == \"let\") { // let expr\\n      i += 4;\\n      while (i < n && s[i] != ')') {\\n        string var;\\n        if (isalpha(s[i])) while (i < n && isalnum(s[i])) var += s[i++];\\n        else { res = parse(s, n, i, m); break; }\\n        if (s[i] == ' ') {\\n          ++i;\\n          m[var] = parse(s, n, i, m);\\n          ++i;\\n        } else if (s[i] == ')') res = m[var];\\n      }\\n    } else if (isalpha(s[i])) { // assigned expr\\n      string var;\\n      while (i < n && isalnum(s[i])) var += s[i++];\\n      res = m[var];\\n    } else { // integer expr\\n      int sign = 1;\\n      if (s[i] == '-') { sign = -1; ++i; }\\n      while (i < n && isdigit(s[i])) res = res*10 + s[i++]-'0';\\n      res *= sign;\\n    }\\n    if (s[i] == ')') ++i;\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 435137,
                "title": "c-short-and-readable-with-comments",
                "content": "```\\n    int i=0; //index of vector\\n    vector<string> vs; //splitted string without spaces, ex.: (add 1 2) = {\"(\",\"add\",\"1\",\"2\",\")\"}\\n\\n    //get value - expression, integer or variable\\n    int getval(unordered_map<string,int> &hm){\\n        if(vs[i]==\"(\") return rec(hm);\\n        string s=vs[i++];\\n        return isalpha(s[0]) ? hm[s]:stoi(s); //handle variable or integer\\n    }\\n    //handle expression\\n    int rec(unordered_map<string,int> hm){\\n        int ans=0;\\n        i++; //pass \\'(\\'\\n        string op = vs[i++];\\n        if(op==\"let\"){\\n            while(vs[i]!=\"(\" && vs[i+1]!=\")\"){\\n                string var = vs[i++]; //variable name\\n                hm[var] = getval(hm); //variable value\\n            }\\n            ans = getval(hm);\\n        } else if(op==\"add\") ans=getval(hm)+getval(hm);\\n        else if(op==\"mult\") ans=getval(hm)*getval(hm);\\n        i++; //pass \\')\\'\\n        return ans;\\n    }\\n    \\n    int evaluate(string s) {\\n        unordered_map<string,int> hm;\\n        for(int j=0, st=0;j<s.size();++j){\\n            if(s[j]==\\')\\' || s[j]==\\'(\\' || s[j]==\\' \\'){\\n                if(st!=j) vs.push_back(s.substr(st,j-st)); //push operator, integer or variable\\n                if(s[j]!=\\' \\') vs.push_back(s.substr(j,1)); //push \"(\" or \")\"\\n                st=j+1;\\n            }\\n        }\\n        return rec(hm);\\n    }",
                "solutionTags": [],
                "code": "```\\n    int i=0; //index of vector\\n    vector<string> vs; //splitted string without spaces, ex.: (add 1 2) = {\"(\",\"add\",\"1\",\"2\",\")\"}\\n\\n    //get value - expression, integer or variable\\n    int getval(unordered_map<string,int> &hm){\\n        if(vs[i]==\"(\") return rec(hm);\\n        string s=vs[i++];\\n        return isalpha(s[0]) ? hm[s]:stoi(s); //handle variable or integer\\n    }\\n    //handle expression\\n    int rec(unordered_map<string,int> hm){\\n        int ans=0;\\n        i++; //pass \\'(\\'\\n        string op = vs[i++];\\n        if(op==\"let\"){\\n            while(vs[i]!=\"(\" && vs[i+1]!=\")\"){\\n                string var = vs[i++]; //variable name\\n                hm[var] = getval(hm); //variable value\\n            }\\n            ans = getval(hm);\\n        } else if(op==\"add\") ans=getval(hm)+getval(hm);\\n        else if(op==\"mult\") ans=getval(hm)*getval(hm);\\n        i++; //pass \\')\\'\\n        return ans;\\n    }\\n    \\n    int evaluate(string s) {\\n        unordered_map<string,int> hm;\\n        for(int j=0, st=0;j<s.size();++j){\\n            if(s[j]==\\')\\' || s[j]==\\'(\\' || s[j]==\\' \\'){\\n                if(st!=j) vs.push_back(s.substr(st,j-st)); //push operator, integer or variable\\n                if(s[j]!=\\' \\') vs.push_back(s.substr(j,1)); //push \"(\" or \")\"\\n                st=j+1;\\n            }\\n        }\\n        return rec(hm);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 191812,
                "title": "my-python-stack-solution",
                "content": "* We split string and iterate over every item where opening brackets stick to expression\\n* We initialize scopes with empty dictionary where we store assigned values.\\n* If item starts with \"(\", it is an expression (like let, mult, and add) and we append new array to items array.\\n\\t\\t* If it is \"let\" expression, that defines new scope so we append new dictionary to scopes array.\\n* If item ends with \")\", we should process current items group.\\n\\t* If current group is \"add\", we define item as addition of 2 numbers (items[-1][1], items[-1][-1])\\n\\t* If current group is \"mult\", we define item as multiplication of 2 numbers (items[-1][1], items[-1][-1]),\\n\\t* If current group is \"let\", we define item as items[-1][-1]\\n\\t\\t* If item is defined in current scope, we define item as scopes[-1][exp]) \\n\\t\\t* We remove(pop) current scope because we are closing current \"let\" group.\\n\\t* We remove(pop) current items group\\n* If item defined in current scope and current group is \"mult\" or \"add\" (items[-1][0] != \"let\") or \"let\" and last item in the group is a variable (len(items[-1]) % 2 == 0), we define item as scopes[-1][exp]\\n* We append current item to scopes if it defines last item in the \"let\" group as a number\\n* We append current item to current items group\\n* Finally we will return our result in the \"root\" group as int(items[-1][-1])\\n```\\nclass Solution:\\n    def evaluate(self, expression):\\n        scopes, items = [{}], [[\"root\"]]\\n        for item in expression.replace(\")\", \" )\").split():\\n            if item[0] == \"(\":\\n                items.append([item[1:]])\\n                if item[1:] == \"let\":\\n                    scopes.append(dict(scopes[-1]))\\n                continue\\n            elif item == \")\": \\n                if items[-1][0] == \"add\":\\n                    item = str(int(items[-1][1]) + int(items[-1][-1]))\\n                elif items[-1][0] == \"mult\":\\n                    item = str(int(items[-1][1]) * int(items[-1][-1]))\\n                else:\\n                    item = items[-1][-1]\\n                    if item in scopes[-1]:\\n                        item = scopes[-1][item]\\n                    scopes.pop()\\n                items.pop()\\n            if item in scopes[-1] and (items[-1][0] != \"let\" or len(items[-1]) % 2 == 0):\\n                item = scopes[-1][item]\\n            if items[-1][0] == \"let\" and item.lstrip(\"-\").isdigit():\\n                scopes[-1][items[-1][-1]] = item\\n            items[-1].append(item)\\n        return int(items[-1][-1])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, expression):\\n        scopes, items = [{}], [[\"root\"]]\\n        for item in expression.replace(\")\", \" )\").split():\\n            if item[0] == \"(\":\\n                items.append([item[1:]])\\n                if item[1:] == \"let\":\\n                    scopes.append(dict(scopes[-1]))\\n                continue\\n            elif item == \")\": \\n                if items[-1][0] == \"add\":\\n                    item = str(int(items[-1][1]) + int(items[-1][-1]))\\n                elif items[-1][0] == \"mult\":\\n                    item = str(int(items[-1][1]) * int(items[-1][-1]))\\n                else:\\n                    item = items[-1][-1]\\n                    if item in scopes[-1]:\\n                        item = scopes[-1][item]\\n                    scopes.pop()\\n                items.pop()\\n            if item in scopes[-1] and (items[-1][0] != \"let\" or len(items[-1]) % 2 == 0):\\n                item = scopes[-1][item]\\n            if items[-1][0] == \"let\" and item.lstrip(\"-\").isdigit():\\n                scopes[-1][items[-1][-1]] = item\\n            items[-1].append(item)\\n        return int(items[-1][-1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 185069,
                "title": "python-one-pass-recursive-descending-ll2-parser",
                "content": "The trick here is the ```(let var val var val ... expr)```\\nwe have to look at the second token to determine whether the next token is a expr or a var.\\n\\n```\\nclass Solution(object):\\n    def evaluate(self, expr):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: int\\n        \"\"\"\\n        def tokenizer(expr):\\n            return expr.replace(\\'(\\', \\'( \\').replace(\\')\\', \\' )\\').split()\\n\\n        def eva(tokens, env):\\n            if tokens[0] != \\'(\\':\\n                if tokens[0][0] in \\'-1234567890\\':\\n                    return int(tokens.popleft())\\n                else:\\n                    return env[tokens.popleft()]\\n            else:\\n                # (let|add|mul ...)))))\\n                tokens.popleft()\\n                if tokens[0] in (\\'add\\', \\'mult\\'):\\n                    op = tokens.popleft()\\n                    a, b = eva(tokens, env), eva(tokens, env)\\n                    val = a + b if op == \\'add\\' else a * b\\n                else: # let\\n                    tokens.popleft()\\n                    local = env.copy()\\n                    while tokens[0] != \\'(\\' and tokens[1] != \\')\\': # here we peek the second token\\n                        var = tokens.popleft()\\n                        local[var] = eva(tokens, local)\\n                    val = eva(tokens, local)\\n\\n                # skip the matching )\\n                tokens.popleft()\\n                return val\\n\\n        tokens = collections.deque(tokenizer(expr))\\n        env = {}\\n\\n        return eva(tokens, env)\\n```",
                "solutionTags": [],
                "code": "```(let var val var val ... expr)```\n```\\nclass Solution(object):\\n    def evaluate(self, expr):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: int\\n        \"\"\"\\n        def tokenizer(expr):\\n            return expr.replace(\\'(\\', \\'( \\').replace(\\')\\', \\' )\\').split()\\n\\n        def eva(tokens, env):\\n            if tokens[0] != \\'(\\':\\n                if tokens[0][0] in \\'-1234567890\\':\\n                    return int(tokens.popleft())\\n                else:\\n                    return env[tokens.popleft()]\\n            else:\\n                # (let|add|mul ...)))))\\n                tokens.popleft()\\n                if tokens[0] in (\\'add\\', \\'mult\\'):\\n                    op = tokens.popleft()\\n                    a, b = eva(tokens, env), eva(tokens, env)\\n                    val = a + b if op == \\'add\\' else a * b\\n                else: # let\\n                    tokens.popleft()\\n                    local = env.copy()\\n                    while tokens[0] != \\'(\\' and tokens[1] != \\')\\': # here we peek the second token\\n                        var = tokens.popleft()\\n                        local[var] = eva(tokens, local)\\n                    val = eva(tokens, local)\\n\\n                # skip the matching )\\n                tokens.popleft()\\n                return val\\n\\n        tokens = collections.deque(tokenizer(expr))\\n        env = {}\\n\\n        return eva(tokens, env)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 760315,
                "title": "python-solution-with-state-machine-and-stack-lr",
                "content": "Here is my solution in Python with state machine and stack.\\nThere are 4 states:\\n state 0 - expect let, add or mult\\n state 1 - expect operand1 for add or mult\\n state 2 - expect operand2 for add or mult\\n state 3 - expect varName or expr for let\\n state 4 - expect varValue or \\')\\' for let\\n```\\nclass Solution:\\n    def evaluate(self, E: str) -> int:\\n        def isdigit(x):\\n            return x[0].isdigit() or x[0] == \\'-\\'\\n\\n        parsed_input = []\\n        cur = []\\n        for x in E:\\n            if x == \\' \\':\\n                if cur:\\n                    parsed_input.append(\\'\\'.join(cur))\\n                    cur = []\\n            elif x == \\'(\\':\\n                continue\\n            elif x == \\')\\':\\n                if cur:\\n                    parsed_input.append(\\'\\'.join(cur))\\n                    cur = []\\n                parsed_input.append(x)\\n            else:\\n                cur.append(x)\\n        # possible inputs: add, mult, let, number, varname or \\')\\'\\n        # possible states:\\n        # state 0 - wait let, add or mult\\n        # state 1 - wait operand1 for add or mult\\n        # state 2 - wait operand2 for add or mult\\n        # state 3 - wait varName or expr for let\\n        # state 4 - wait varValue or \\')\\' for let\\n        stack = []\\n        vars = []\\n        state = 0\\n        for x in parsed_input:\\n            if x == \\'let\\':\\n                stack.append((state, \\'let\\'))\\n                if vars:\\n                    vars.append(dict(vars[-1]))\\n                else:\\n                    vars.append(dict())\\n                state = 3\\n            elif x in [\\'add\\', \\'mult\\']:\\n                stack.append((state, x))\\n                state = 1\\n            elif x == \\')\\':\\n                prev_state, value = stack.pop()\\n                if prev_state == 2:\\n                    a = stack.pop()[1]\\n                    state, op = stack.pop()\\n                    if op == \\'add\\':\\n                        stack.append((state, a+value))\\n                    elif op == \\'mult\\':\\n                        stack.append((state, a*value))\\n                    else:\\n                        raise Exception(\"Wrong op: \" + op)\\n                elif prev_state == 3:\\n                    orig_state, lt = stack.pop()\\n                    if lt != \\'let\\':\\n                        raise Exception(\"expect let, got: \" + op)\\n                    stack.append((orig_state, value))\\n                    if orig_state == 1:\\n                        state = 2\\n                    vars.pop()\\n                elif prev_state == 1:\\n                    if value == \\'let\\':\\n                        stack.append((prev_state, vars[-1][cur_var]))\\n                    else:\\n                        stack.append((prev_state, value))\\n                    state = 2\\n                elif prev_state == 0:\\n                    if value == \\'let\\':\\n                        stack.append((prev_state, vars[-1][cur_var]))\\n                    else:\\n                        stack.append((prev_state, value))\\n                    state = prev_state\\n                elif prev_state == 4:\\n                    vars[-1][cur_var] = value\\n                    state = 3\\n                else:\\n                    raise Exception(\"Non implemented for state: \" + str(prev_state))\\n            elif state == 1:\\n                if x[0].islower():\\n                    stack.append((state, vars[-1][x]))\\n                    state = 2\\n                elif isdigit(x):\\n                    stack.append((state, int(x)))\\n                    state = 2\\n                else:\\n                    raise Exception(\\'Waiting first operand instead got: \\' + x)\\n            elif state == 2:\\n                if x[0].islower():\\n                    stack.append((state, vars[-1][x]))\\n                elif isdigit(x):\\n                    stack.append((state, int(x)))\\n                else:\\n                    raise Exception(\\'Waiting second operand instead got: \\' + x)\\n                a, b = stack.pop()[1], stack.pop()[1]\\n                state, op = stack.pop()\\n                if op == \\'add\\':\\n                    stack.append((state, a+b))\\n                elif op == \\'mult\\':\\n                    stack.append((state, a*b))\\n                else:\\n                    raise Exception(\"Waited add or mult, instead got: \" + x)\\n            elif state == 3:\\n                if x[0].islower():\\n                    cur_var = x\\n                    state = 4\\n                elif isdigit(x):\\n                    state = stack.pop()[0]\\n                    stack.append((state, int(x)))\\n                else: \\n                    raise Exception(\"Waited var_name or digit for let instead got: \" + x)\\n            elif state == 4:\\n                if x[0].islower():\\n                    vars[-1][cur_var] = vars[-1][x]\\n                    state = 3\\n                elif isdigit(x):\\n                    vars[-1][cur_var] = int(x)\\n                    state = 3\\n                elif x == \\')\\':\\n                    state = stack.pop()[0]\\n                    stack.append(state, vars[-1][cur_var])\\n                else:\\n                    raise Exception(\"Waited var_value or digit or ) but got: \" + x)\\n        print(\"PARSED: \" + str(parsed_input))\\n        print(\"STACK: \" + str(stack))\\n        return stack.pop()[1]\\n\\n\\n# print(Solution().evaluate(\\'(add 1 2)\\')) # 3\\n# print(Solution().evaluate(\\'(mult 3 (add 2 3))\\')) # 15\\n# print(Solution().evaluate(\\'(let x 2 (mult x 5))\\')) # 10\\n# print(Solution().evaluate(\\'(let x 2 (mult x (let x 3 y 4 (add x y))))\\')) # 14\\n# print(Solution().evaluate(\\'(let x 3 x 2 x)\\')) # 2\\n# print(Solution().evaluate(\\'(let x 1 y 2 x (add x y) (add x y))\\')) # 5\\n# print(Solution().evaluate(\\'(let x 2 (add (let x 3 (let x 4 x)) x))\\')) # 6\\n# print(Solution().evaluate(\\'(let a1 3 b2 (add a1 1) b2)\\')) # 4\\n# print(Solution().evaluate(\"(let x 2 (mult (let x 3 y 4 (add x y)) x))\")) # 14\\n# print(Solution().evaluate(\"(let x 7 -12)\")) # -12\\nprint(Solution().evaluate(\"(let var 78 b 77 (let c 33 (add c (mult var 66))))\")) # 5181\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, E: str) -> int:\\n        def isdigit(x):\\n            return x[0].isdigit() or x[0] == \\'-\\'\\n\\n        parsed_input = []\\n        cur = []\\n        for x in E:\\n            if x == \\' \\':\\n                if cur:\\n                    parsed_input.append(\\'\\'.join(cur))\\n                    cur = []\\n            elif x == \\'(\\':\\n                continue\\n            elif x == \\')\\':\\n                if cur:\\n                    parsed_input.append(\\'\\'.join(cur))\\n                    cur = []\\n                parsed_input.append(x)\\n            else:\\n                cur.append(x)\\n        # possible inputs: add, mult, let, number, varname or \\')\\'\\n        # possible states:\\n        # state 0 - wait let, add or mult\\n        # state 1 - wait operand1 for add or mult\\n        # state 2 - wait operand2 for add or mult\\n        # state 3 - wait varName or expr for let\\n        # state 4 - wait varValue or \\')\\' for let\\n        stack = []\\n        vars = []\\n        state = 0\\n        for x in parsed_input:\\n            if x == \\'let\\':\\n                stack.append((state, \\'let\\'))\\n                if vars:\\n                    vars.append(dict(vars[-1]))\\n                else:\\n                    vars.append(dict())\\n                state = 3\\n            elif x in [\\'add\\', \\'mult\\']:\\n                stack.append((state, x))\\n                state = 1\\n            elif x == \\')\\':\\n                prev_state, value = stack.pop()\\n                if prev_state == 2:\\n                    a = stack.pop()[1]\\n                    state, op = stack.pop()\\n                    if op == \\'add\\':\\n                        stack.append((state, a+value))\\n                    elif op == \\'mult\\':\\n                        stack.append((state, a*value))\\n                    else:\\n                        raise Exception(\"Wrong op: \" + op)\\n                elif prev_state == 3:\\n                    orig_state, lt = stack.pop()\\n                    if lt != \\'let\\':\\n                        raise Exception(\"expect let, got: \" + op)\\n                    stack.append((orig_state, value))\\n                    if orig_state == 1:\\n                        state = 2\\n                    vars.pop()\\n                elif prev_state == 1:\\n                    if value == \\'let\\':\\n                        stack.append((prev_state, vars[-1][cur_var]))\\n                    else:\\n                        stack.append((prev_state, value))\\n                    state = 2\\n                elif prev_state == 0:\\n                    if value == \\'let\\':\\n                        stack.append((prev_state, vars[-1][cur_var]))\\n                    else:\\n                        stack.append((prev_state, value))\\n                    state = prev_state\\n                elif prev_state == 4:\\n                    vars[-1][cur_var] = value\\n                    state = 3\\n                else:\\n                    raise Exception(\"Non implemented for state: \" + str(prev_state))\\n            elif state == 1:\\n                if x[0].islower():\\n                    stack.append((state, vars[-1][x]))\\n                    state = 2\\n                elif isdigit(x):\\n                    stack.append((state, int(x)))\\n                    state = 2\\n                else:\\n                    raise Exception(\\'Waiting first operand instead got: \\' + x)\\n            elif state == 2:\\n                if x[0].islower():\\n                    stack.append((state, vars[-1][x]))\\n                elif isdigit(x):\\n                    stack.append((state, int(x)))\\n                else:\\n                    raise Exception(\\'Waiting second operand instead got: \\' + x)\\n                a, b = stack.pop()[1], stack.pop()[1]\\n                state, op = stack.pop()\\n                if op == \\'add\\':\\n                    stack.append((state, a+b))\\n                elif op == \\'mult\\':\\n                    stack.append((state, a*b))\\n                else:\\n                    raise Exception(\"Waited add or mult, instead got: \" + x)\\n            elif state == 3:\\n                if x[0].islower():\\n                    cur_var = x\\n                    state = 4\\n                elif isdigit(x):\\n                    state = stack.pop()[0]\\n                    stack.append((state, int(x)))\\n                else: \\n                    raise Exception(\"Waited var_name or digit for let instead got: \" + x)\\n            elif state == 4:\\n                if x[0].islower():\\n                    vars[-1][cur_var] = vars[-1][x]\\n                    state = 3\\n                elif isdigit(x):\\n                    vars[-1][cur_var] = int(x)\\n                    state = 3\\n                elif x == \\')\\':\\n                    state = stack.pop()[0]\\n                    stack.append(state, vars[-1][cur_var])\\n                else:\\n                    raise Exception(\"Waited var_value or digit or ) but got: \" + x)\\n        print(\"PARSED: \" + str(parsed_input))\\n        print(\"STACK: \" + str(stack))\\n        return stack.pop()[1]\\n\\n\\n# print(Solution().evaluate(\\'(add 1 2)\\')) # 3\\n# print(Solution().evaluate(\\'(mult 3 (add 2 3))\\')) # 15\\n# print(Solution().evaluate(\\'(let x 2 (mult x 5))\\')) # 10\\n# print(Solution().evaluate(\\'(let x 2 (mult x (let x 3 y 4 (add x y))))\\')) # 14\\n# print(Solution().evaluate(\\'(let x 3 x 2 x)\\')) # 2\\n# print(Solution().evaluate(\\'(let x 1 y 2 x (add x y) (add x y))\\')) # 5\\n# print(Solution().evaluate(\\'(let x 2 (add (let x 3 (let x 4 x)) x))\\')) # 6\\n# print(Solution().evaluate(\\'(let a1 3 b2 (add a1 1) b2)\\')) # 4\\n# print(Solution().evaluate(\"(let x 2 (mult (let x 3 y 4 (add x y)) x))\")) # 14\\n# print(Solution().evaluate(\"(let x 7 -12)\")) # -12\\nprint(Solution().evaluate(\"(let var 78 b 77 (let c 33 (add c (mult var 66))))\")) # 5181\\n```",
                "codeTag": "Java"
            },
            {
                "id": 231791,
                "title": "yet-another-recursive-descent-parser-rust-0ms",
                "content": "Guessing that no one else is really using Rust since I keep getting \"beats 100% in time and memory (0ms, ~700Kb)\".\\n\\nThis is a pretty verbose solution that creates a zero-copy `Token` `Iterator` from the original string. The `Iterator` is then unravelled, and the `peek` method is used to determine if the var we\\'re looking at in a let expression is a declaration or an expression. The `Environment` is a mapping from var to `Vec<i32>`; at the start of a let we push the variables as we\\'re evaluating definitions and at the end of the let we pop them all.\\n\\n```\\nimpl Solution {\\n    pub fn evaluate(expression: String) -> i32 {\\n        let mut tokens = Tokens::new(expression.as_str());\\n        let mut env = Environment::new();\\n        eval(&mut tokens, &mut env)\\n    }\\n}\\n\\nuse std::collections::HashMap;\\n\\nfn eval<\\'a>(tokens: &mut Tokens<\\'a>, env: &mut Environment<\\'a>) -> i32 {\\n    match tokens.next().unwrap() {\\n        Token::Num(n) => n,\\n        Token::Var(v) => env.get(v),\\n        Token::Start => match tokens.next().unwrap() {\\n            Token::Add => {\\n                let left = eval(tokens, env);\\n                let right = eval(tokens, env);\\n                let res = left + right;\\n                assert_eq!(Token::End, tokens.next().unwrap());\\n                res\\n            }\\n            Token::Mul => {\\n                let left = eval(tokens, env);\\n                let right = eval(tokens, env);\\n                let res = left * right;\\n                assert_eq!(Token::End, tokens.next().unwrap());\\n                res\\n            }\\n            Token::Let => {\\n                let mut vars_to_pop = vec![];\\n                loop {\\n                    match tokens.peek().unwrap() {\\n                        Token::Var(v) => {\\n                            tokens.next().unwrap();\\n                            if tokens.peek().unwrap() == Token::End {\\n                                let res = env.get(v);\\n                                for var in vars_to_pop {\\n                                    env.pop(var);\\n                                }\\n                                assert_eq!(Token::End, tokens.next().unwrap());\\n                                return res;\\n                            } else {\\n                                let val = eval(tokens, env);\\n                                env.put(v, val);\\n                                vars_to_pop.push(v);\\n                            }\\n                        }\\n                        _ => {\\n                            let res = eval(tokens, env);\\n                            for var in vars_to_pop {\\n                                env.pop(var);\\n                            }\\n                            assert_eq!(Token::End, tokens.next().unwrap());\\n                            return res;\\n                        }\\n                    }\\n                }\\n            }\\n            _ => panic!(\"Invalid expr after \\'(\\'\"),\\n        },\\n        _ => panic!(\"Invalid start of expression\"),\\n    }\\n}\\n\\nstruct Tokens<\\'a> {\\n    expr: &\\'a [u8],\\n    start: usize,\\n    end: usize,\\n}\\n\\n#[derive(Debug, PartialEq, Eq)]\\nenum Token<\\'a> {\\n    Start,\\n    End,\\n    Add,\\n    Mul,\\n    Let,\\n    Num(i32),\\n    Var(&\\'a [u8]),\\n}\\n\\nimpl<\\'a> Tokens<\\'a> {\\n    fn new(expr: &\\'a str) -> Self {\\n        Tokens {\\n            expr: expr.as_bytes(),\\n            start: 0,\\n            end: 0,\\n        }\\n    }\\n\\n    fn peek(&mut self) -> Option<Token<\\'a>> {\\n        let start = self.start;\\n        let end = self.end;\\n        let res = self.next();\\n        self.start = start;\\n        self.end = end;\\n        res\\n    }\\n}\\n\\nimpl<\\'a> Iterator for Tokens<\\'a> {\\n    type Item = Token<\\'a>;\\n\\n    fn next(&mut self) -> Option<Self::Item> {\\n        if self.end == self.expr.len() {\\n            return None;\\n        }\\n        while self.expr[self.end] == b\\' \\' {\\n            self.end += 1;\\n            if self.end == self.expr.len() {\\n                return None;\\n            }\\n        }\\n        self.start = self.end;\\n        self.end += 1;\\n        match self.expr[self.start] {\\n            b\\'(\\' => return Some(Token::Start),\\n            b\\')\\' => return Some(Token::End),\\n            _ => {}\\n        }\\n        while !(self.expr[self.end] == b\\' \\' || self.expr[self.end] == b\\')\\') {\\n            self.end += 1;\\n            if self.end == self.expr.len() {\\n                return None;\\n            }\\n        }\\n        if self.expr[self.start] == b\\'-\\'\\n            || (self.expr[self.start] >= b\\'0\\' && self.expr[self.start] <= b\\'9\\')\\n        {\\n            let as_str = unsafe { std::str::from_utf8_unchecked(&self.expr[self.start..self.end]) };\\n            return Some(Token::Num(as_str.parse::<i32>().unwrap()));\\n        }\\n        let token = match &self.expr[self.start..self.end] {\\n            b\"mult\" => Token::Mul,\\n            b\"add\" => Token::Add,\\n            b\"let\" => Token::Let,\\n            var => Token::Var(var),\\n        };\\n        Some(token)\\n    }\\n}\\n\\nstruct Environment<\\'a> {\\n    vars: HashMap<&\\'a [u8], Vec<i32>>,\\n}\\n\\nimpl<\\'a> Environment<\\'a> {\\n    fn new() -> Self {\\n        Environment {\\n            vars: HashMap::new(),\\n        }\\n    }\\n\\n    fn get(&self, var: &[u8]) -> i32 {\\n        self.vars.get(var).map(|v| v[v.len() - 1]).unwrap()\\n    }\\n\\n    fn put(&mut self, var: &\\'a [u8], val: i32) {\\n        let entry = self.vars.entry(var).or_insert(vec![]);\\n        (*entry).push(val);\\n    }\\n\\n    fn pop(&mut self, var: &[u8]) {\\n        self.vars.get_mut(var).map(|v| v.pop().unwrap()).unwrap();\\n    }\\n}\\n#[test]\\nfn tokenize() {\\n    let expr = \"(let x (add 1 2) y2 (mult 4 7))\";\\n    let tokens = Tokens::new(expr);\\n    assert_eq!(\\n        tokens.collect::<Vec<_>>(),\\n        vec![\\n            Token::Start,\\n            Token::Let,\\n            Token::Var(b\"x\"),\\n            Token::Start,\\n            Token::Add,\\n            Token::Num(1),\\n            Token::Num(2),\\n            Token::End,\\n            Token::Var(b\"y2\"),\\n            Token::Start,\\n            Token::Mul,\\n            Token::Num(4),\\n            Token::Num(7),\\n            Token::End,\\n            Token::End,\\n        ]\\n    );\\n}\\n\\n#[test]\\nfn test_add() {\\n    assert_eq!(3, Solution::evaluate(\"(add 1 2)\".into()));\\n}\\n\\n#[test]\\nfn test_mul() {\\n    assert_eq!(15, Solution::evaluate(\"(mult 3 (add 2 3))\".into()));\\n}\\n\\n#[test]\\nfn test_let() {\\n    assert_eq!(10, Solution::evaluate(\"(let x 2 (mult x 5))\".into()));\\n}\\n\\n#[test]\\nfn test_let_scope() {\\n    assert_eq!(\\n        14,\\n        Solution::evaluate(\"(let x 2 (mult x (let x 3 y 4 (add x y))))\".into())\\n    );\\n}\\n\\n#[test]\\nfn test_let_scope_2() {\\n    assert_eq!(\\n        6,\\n        Solution::evaluate(\"(let x 2 (add (let x 3 (let x 4 x)) x))\".into())\\n    );\\n}\\n\\n#[test]\\nfn test_let_linear() {\\n    assert_eq!(2, Solution::evaluate(\"(let x 3 x 2 x)\".into()));\\n}\\n\\n#[test]\\nfn test_hard() {\\n    assert_eq!(\\n        -8055,\\n        Solution::evaluate(\"(let a -122 b 0 (add (add 1 -4) (mult a 66)))\".into())\\n    );\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimpl Solution {\\n    pub fn evaluate(expression: String) -> i32 {\\n        let mut tokens = Tokens::new(expression.as_str());\\n        let mut env = Environment::new();\\n        eval(&mut tokens, &mut env)\\n    }\\n}\\n\\nuse std::collections::HashMap;\\n\\nfn eval<\\'a>(tokens: &mut Tokens<\\'a>, env: &mut Environment<\\'a>) -> i32 {\\n    match tokens.next().unwrap() {\\n        Token::Num(n) => n,\\n        Token::Var(v) => env.get(v),\\n        Token::Start => match tokens.next().unwrap() {\\n            Token::Add => {\\n                let left = eval(tokens, env);\\n                let right = eval(tokens, env);\\n                let res = left + right;\\n                assert_eq!(Token::End, tokens.next().unwrap());\\n                res\\n            }\\n            Token::Mul => {\\n                let left = eval(tokens, env);\\n                let right = eval(tokens, env);\\n                let res = left * right;\\n                assert_eq!(Token::End, tokens.next().unwrap());\\n                res\\n            }\\n            Token::Let => {\\n                let mut vars_to_pop = vec![];\\n                loop {\\n                    match tokens.peek().unwrap() {\\n                        Token::Var(v) => {\\n                            tokens.next().unwrap();\\n                            if tokens.peek().unwrap() == Token::End {\\n                                let res = env.get(v);\\n                                for var in vars_to_pop {\\n                                    env.pop(var);\\n                                }\\n                                assert_eq!(Token::End, tokens.next().unwrap());\\n                                return res;\\n                            } else {\\n                                let val = eval(tokens, env);\\n                                env.put(v, val);\\n                                vars_to_pop.push(v);\\n                            }\\n                        }\\n                        _ => {\\n                            let res = eval(tokens, env);\\n                            for var in vars_to_pop {\\n                                env.pop(var);\\n                            }\\n                            assert_eq!(Token::End, tokens.next().unwrap());\\n                            return res;\\n                        }\\n                    }\\n                }\\n            }\\n            _ => panic!(\"Invalid expr after \\'(\\'\"),\\n        },\\n        _ => panic!(\"Invalid start of expression\"),\\n    }\\n}\\n\\nstruct Tokens<\\'a> {\\n    expr: &\\'a [u8],\\n    start: usize,\\n    end: usize,\\n}\\n\\n#[derive(Debug, PartialEq, Eq)]\\nenum Token<\\'a> {\\n    Start,\\n    End,\\n    Add,\\n    Mul,\\n    Let,\\n    Num(i32),\\n    Var(&\\'a [u8]),\\n}\\n\\nimpl<\\'a> Tokens<\\'a> {\\n    fn new(expr: &\\'a str) -> Self {\\n        Tokens {\\n            expr: expr.as_bytes(),\\n            start: 0,\\n            end: 0,\\n        }\\n    }\\n\\n    fn peek(&mut self) -> Option<Token<\\'a>> {\\n        let start = self.start;\\n        let end = self.end;\\n        let res = self.next();\\n        self.start = start;\\n        self.end = end;\\n        res\\n    }\\n}\\n\\nimpl<\\'a> Iterator for Tokens<\\'a> {\\n    type Item = Token<\\'a>;\\n\\n    fn next(&mut self) -> Option<Self::Item> {\\n        if self.end == self.expr.len() {\\n            return None;\\n        }\\n        while self.expr[self.end] == b\\' \\' {\\n            self.end += 1;\\n            if self.end == self.expr.len() {\\n                return None;\\n            }\\n        }\\n        self.start = self.end;\\n        self.end += 1;\\n        match self.expr[self.start] {\\n            b\\'(\\' => return Some(Token::Start),\\n            b\\')\\' => return Some(Token::End),\\n            _ => {}\\n        }\\n        while !(self.expr[self.end] == b\\' \\' || self.expr[self.end] == b\\')\\') {\\n            self.end += 1;\\n            if self.end == self.expr.len() {\\n                return None;\\n            }\\n        }\\n        if self.expr[self.start] == b\\'-\\'\\n            || (self.expr[self.start] >= b\\'0\\' && self.expr[self.start] <= b\\'9\\')\\n        {\\n            let as_str = unsafe { std::str::from_utf8_unchecked(&self.expr[self.start..self.end]) };\\n            return Some(Token::Num(as_str.parse::<i32>().unwrap()));\\n        }\\n        let token = match &self.expr[self.start..self.end] {\\n            b\"mult\" => Token::Mul,\\n            b\"add\" => Token::Add,\\n            b\"let\" => Token::Let,\\n            var => Token::Var(var),\\n        };\\n        Some(token)\\n    }\\n}\\n\\nstruct Environment<\\'a> {\\n    vars: HashMap<&\\'a [u8], Vec<i32>>,\\n}\\n\\nimpl<\\'a> Environment<\\'a> {\\n    fn new() -> Self {\\n        Environment {\\n            vars: HashMap::new(),\\n        }\\n    }\\n\\n    fn get(&self, var: &[u8]) -> i32 {\\n        self.vars.get(var).map(|v| v[v.len() - 1]).unwrap()\\n    }\\n\\n    fn put(&mut self, var: &\\'a [u8], val: i32) {\\n        let entry = self.vars.entry(var).or_insert(vec![]);\\n        (*entry).push(val);\\n    }\\n\\n    fn pop(&mut self, var: &[u8]) {\\n        self.vars.get_mut(var).map(|v| v.pop().unwrap()).unwrap();\\n    }\\n}\\n#[test]\\nfn tokenize() {\\n    let expr = \"(let x (add 1 2) y2 (mult 4 7))\";\\n    let tokens = Tokens::new(expr);\\n    assert_eq!(\\n        tokens.collect::<Vec<_>>(),\\n        vec![\\n            Token::Start,\\n            Token::Let,\\n            Token::Var(b\"x\"),\\n            Token::Start,\\n            Token::Add,\\n            Token::Num(1),\\n            Token::Num(2),\\n            Token::End,\\n            Token::Var(b\"y2\"),\\n            Token::Start,\\n            Token::Mul,\\n            Token::Num(4),\\n            Token::Num(7),\\n            Token::End,\\n            Token::End,\\n        ]\\n    );\\n}\\n\\n#[test]\\nfn test_add() {\\n    assert_eq!(3, Solution::evaluate(\"(add 1 2)\".into()));\\n}\\n\\n#[test]\\nfn test_mul() {\\n    assert_eq!(15, Solution::evaluate(\"(mult 3 (add 2 3))\".into()));\\n}\\n\\n#[test]\\nfn test_let() {\\n    assert_eq!(10, Solution::evaluate(\"(let x 2 (mult x 5))\".into()));\\n}\\n\\n#[test]\\nfn test_let_scope() {\\n    assert_eq!(\\n        14,\\n        Solution::evaluate(\"(let x 2 (mult x (let x 3 y 4 (add x y))))\".into())\\n    );\\n}\\n\\n#[test]\\nfn test_let_scope_2() {\\n    assert_eq!(\\n        6,\\n        Solution::evaluate(\"(let x 2 (add (let x 3 (let x 4 x)) x))\".into())\\n    );\\n}\\n\\n#[test]\\nfn test_let_linear() {\\n    assert_eq!(2, Solution::evaluate(\"(let x 3 x 2 x)\".into()));\\n}\\n\\n#[test]\\nfn test_hard() {\\n    assert_eq!(\\n        -8055,\\n        Solution::evaluate(\"(let a -122 b 0 (add (add 1 -4) (mult a 66)))\".into())\\n    );\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109724,
                "title": "recursive-python-with-inline-comments",
                "content": "`symbols` is a key-value map of variables to its values, called a symbol table in compilers. In each call to `_evaluate`, we clone the current symbol table for overwriting without affecting the parent scope.\\n\\n```\\nclass Solution(object):\\n    def evaluate(self, expression):\\n        import re\\n        tokens = list(filter(lambda c: c.strip(), re.split('(\\\\(|\\\\)|-?\\\\w+)', expression)))\\n        INTEGER_REGEX = '^-?\\\\d+$'\\n        VARIABLE_REGEX = '^[a-z][a-z0-9]*'\\n        self.i = 0\\n        def _evaluate(symbols):\\n            symbols = symbols.copy() # Don't affect parent scope values.\\n            token = tokens[self.i]\\n            # Integer.\\n            if re.search(INTEGER_REGEX, token):\\n                return int(token)\\n            # Variable. Look up symbol table and return value.\\n            if re.search(VARIABLE_REGEX, token):\\n                return symbols[token]\\n            # Operator - let/add/mult expression.\\n            if token == '(':\\n                self.i += 1\\n                op = tokens[self.i]\\n                self.i += 1\\n                if op == 'let':\\n                    variable = None\\n                    while tokens[self.i] != ')':\\n                        if not variable:\\n                            # Test whether it is a variable.\\n                            if re.search(VARIABLE_REGEX, tokens[self.i]):\\n                                variable = tokens[self.i]\\n                            else:\\n                                variable = _evaluate(symbols)\\n                        else:\\n                            symbols[variable] = _evaluate(symbols)\\n                            variable = None\\n                        self.i += 1\\n                    # If result is a variable, look up variable table and convert into a value.\\n                    if re.search(VARIABLE_REGEX, str(variable)):\\n                        variable = symbols[variable]\\n                    return variable\\n                # Binary operators - add/mult\\n                left = _evaluate(symbols)\\n                self.i += 1\\n                right = _evaluate(symbols)\\n                self.i += 1 # Closing bracket\\n                if op == 'add':\\n                    return left + right\\n                elif op == 'mult':\\n                    return left * right\\n        return _evaluate({})\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def evaluate(self, expression):\\n        import re\\n        tokens = list(filter(lambda c: c.strip(), re.split('(\\\\(|\\\\)|-?\\\\w+)', expression)))\\n        INTEGER_REGEX = '^-?\\\\d+$'\\n        VARIABLE_REGEX = '^[a-z][a-z0-9]*'\\n        self.i = 0\\n        def _evaluate(symbols):\\n            symbols = symbols.copy() # Don't affect parent scope values.\\n            token = tokens[self.i]\\n            # Integer.\\n            if re.search(INTEGER_REGEX, token):\\n                return int(token)\\n            # Variable. Look up symbol table and return value.\\n            if re.search(VARIABLE_REGEX, token):\\n                return symbols[token]\\n            # Operator - let/add/mult expression.\\n            if token == '(':\\n                self.i += 1\\n                op = tokens[self.i]\\n                self.i += 1\\n                if op == 'let':\\n                    variable = None\\n                    while tokens[self.i] != ')':\\n                        if not variable:\\n                            # Test whether it is a variable.\\n                            if re.search(VARIABLE_REGEX, tokens[self.i]):\\n                                variable = tokens[self.i]\\n                            else:\\n                                variable = _evaluate(symbols)\\n                        else:\\n                            symbols[variable] = _evaluate(symbols)\\n                            variable = None\\n                        self.i += 1\\n                    # If result is a variable, look up variable table and convert into a value.\\n                    if re.search(VARIABLE_REGEX, str(variable)):\\n                        variable = symbols[variable]\\n                    return variable\\n                # Binary operators - add/mult\\n                left = _evaluate(symbols)\\n                self.i += 1\\n                right = _evaluate(symbols)\\n                self.i += 1 # Closing bracket\\n                if op == 'add':\\n                    return left + right\\n                elif op == 'mult':\\n                    return left * right\\n        return _evaluate({})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109711,
                "title": "cannot-understand-this-example",
                "content": "Here is an example from the problem.\\n\\nInput: ```(let x 2 (add (let x 3 (let x 4 x)) x))```\\nOutput: 6\\nExplanation: Even though (let x 4 x) has a deeper scope, it is ***outside the context***\\nof the final x in the add-expression.  That final x will equal 2.\\n\\nWhat does \"outside the context\" mean? What context?\\n\\nI rewrote the expression here as ```(let x0 2 (add (let x1 3 (let x2 4 x3)) x4))```.\\nJust suppose x0,x1,x2,x3,x4 are all x.\\n\\nx0=2, x1=3, x2=4, x3=x2=4, what is x4? \\nI knew the expression ```(let x1 3 (let x2 4 x3))``` is x3 (x3=4).  Why is x4 not from the innermost scope x3 (x3=4), but from the outer scope x0 (x0=2). I thought inner scope was checked first. Did i misunderstand something?",
                "solutionTags": [],
                "code": "```(let x 2 (add (let x 3 (let x 4 x)) x))```\n```(let x0 2 (add (let x1 3 (let x2 4 x3)) x4))```\n```(let x1 3 (let x2 4 x3))```",
                "codeTag": "Unknown"
            },
            {
                "id": 2405529,
                "title": "racket-makes-this-one-easy",
                "content": "Used Racket (and cheated a bit by using its built-in s-expression reader) with a recursive expression evaluator: Using an immutable hash table for the symbol table means not having to worry about nested bindings to the same identifier.\\n\\n```scheme\\n(define (length-at-least lst len)\\n  (cond\\n    [(null? lst) (= len 0)]\\n    [(= len 0) #t]\\n    [else (length-at-least (cdr lst) (- len 1))]))\\n\\n(define (evaluate-sexpr sexpr env)\\n  (match sexpr\\n    [(list-rest \\'let id val rest)\\n     (let ([new-env (hash-set env id (evaluate-sexpr val env))])\\n       (if (length-at-least rest 3)\\n           (evaluate-sexpr (cons \\'let rest) new-env)\\n           (evaluate-sexpr (car rest) new-env)))]\\n    [(list \\'add subexpr1 subexpr2)\\n     (+ (evaluate-sexpr subexpr1 env) (evaluate-sexpr subexpr2 env))]\\n    [(list \\'mult subexpr1 subexpr2)\\n     (* (evaluate-sexpr subexpr1 env) (evaluate-sexpr subexpr2 env))]\\n    [(? integer? literal) literal]\\n    [(? symbol? id) (hash-ref env id)]))\\n\\n(define/contract (evaluate expression)\\n  (-> string? exact-integer?)\\n  (evaluate-sexpr (with-input-from-string expression read) (hasheq)))\\n```",
                "solutionTags": [],
                "code": "```scheme\\n(define (length-at-least lst len)\\n  (cond\\n    [(null? lst) (= len 0)]\\n    [(= len 0) #t]\\n    [else (length-at-least (cdr lst) (- len 1))]))\\n\\n(define (evaluate-sexpr sexpr env)\\n  (match sexpr\\n    [(list-rest \\'let id val rest)\\n     (let ([new-env (hash-set env id (evaluate-sexpr val env))])\\n       (if (length-at-least rest 3)\\n           (evaluate-sexpr (cons \\'let rest) new-env)\\n           (evaluate-sexpr (car rest) new-env)))]\\n    [(list \\'add subexpr1 subexpr2)\\n     (+ (evaluate-sexpr subexpr1 env) (evaluate-sexpr subexpr2 env))]\\n    [(list \\'mult subexpr1 subexpr2)\\n     (* (evaluate-sexpr subexpr1 env) (evaluate-sexpr subexpr2 env))]\\n    [(? integer? literal) literal]\\n    [(? symbol? id) (hash-ref env id)]))\\n\\n(define/contract (evaluate expression)\\n  (-> string? exact-integer?)\\n  (evaluate-sexpr (with-input-from-string expression read) (hasheq)))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2149196,
                "title": "python3-solution",
                "content": "```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        stack = []\\n        parenEnd = {}\\n        \\n        # Get the end parenthesis location \\n        for idx, ch in enumerate(expression):\\n            if ch == \\'(\\':\\n                stack.append(idx)\\n            if ch == \\')\\':\\n                parenEnd[stack.pop()] = idx\\n\\n        # Parses the expression into a list, each new sublist is a set of parenthesis\\n        # Example: \\n        # Input: \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"\\n        # Output: [\\'let\\', \\'x\\', \\'2\\', [\\'mult\\', \\'x\\', [\\'let\\', \\'x\\', \\'3\\', \\'y\\', \\'4\\', [\\'add\\', \\'x\\', \\'y\\']]]]\\n        def parse(lo, hi):\\n            arr = []\\n            word = []\\n\\n            i = lo\\n            while i < hi:\\n                if expression[i] == \\'(\\':\\n                    arr.append(parse(i + 1, parenEnd[i]))\\n                    i = parenEnd[i]\\n                elif expression[i] == \\' \\' or expression[i] == \\')\\' and word != []:\\n                    if \\'\\'.join(word) != \\'\\':\\n                        arr.append(\\'\\'.join(word))\\n                    word = []\\n                    i += 1\\n                elif expression[i] != \\')\\':\\n                    word.append(expression[i])\\n                    i += 1\\n                else:\\n                    i += 1\\n\\n\\n            if word != []:\\n                arr.append(\\'\\'.join(word))\\n\\n            return arr\\n\\n        # Change string expression into the list expression\\n        expressionList = parse(1, len(expression) - 1)\\n\\n        # Eval expression with starting scope (variables)\\n        return self.genEval(expressionList, {})\\n    \\n    def genEval(self, expression, scope):\\n        if type(expression) != list:\\n            # If expression is just a variable or int\\n            try:\\n                return int(expression)\\n            except:\\n                return scope[expression]\\n        else:\\n            if expression[0] == \\'let\\':\\n                # Remove \"let\" from expression list\\n                expression = expression[1:]\\n                \\n                # This loop updates the scope (variables)\\n                while len(expression) > 2:\\n                    scope = self.letEval(expression, scope.copy())\\n                    expression = expression[2:]\\n                    \\n                # Return the last value\\n                return self.genEval(expression[0], scope.copy())\\n                \\n            if expression[0] == \\'add\\':\\n                return self.addEval(expression, scope.copy())\\n                \\n            if expression[0] == \\'mult\\':\\n                return self.multEval(expression, scope.copy())\\n\\n\\n    \\n    def letEval(self, expression, scope):\\n        scope[expression[0]] = self.genEval(expression[1], scope)\\n        return scope\\n    \\n    def addEval(self, expression, scope):\\n        return self.genEval(expression[1], scope) + self.genEval(expression[2], scope)\\n    \\n    def multEval(self, expression, scope):\\n        return self.genEval(expression[1], scope) * self.genEval(expression[2], scope)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        stack = []\\n        parenEnd = {}\\n        \\n        # Get the end parenthesis location \\n        for idx, ch in enumerate(expression):\\n            if ch == \\'(\\':\\n                stack.append(idx)\\n            if ch == \\')\\':\\n                parenEnd[stack.pop()] = idx\\n\\n        # Parses the expression into a list, each new sublist is a set of parenthesis\\n        # Example: \\n        # Input: \"(let x 2 (mult x (let x 3 y 4 (add x y))))\"\\n        # Output: [\\'let\\', \\'x\\', \\'2\\', [\\'mult\\', \\'x\\', [\\'let\\', \\'x\\', \\'3\\', \\'y\\', \\'4\\', [\\'add\\', \\'x\\', \\'y\\']]]]\\n        def parse(lo, hi):\\n            arr = []\\n            word = []\\n\\n            i = lo\\n            while i < hi:\\n                if expression[i] == \\'(\\':\\n                    arr.append(parse(i + 1, parenEnd[i]))\\n                    i = parenEnd[i]\\n                elif expression[i] == \\' \\' or expression[i] == \\')\\' and word != []:\\n                    if \\'\\'.join(word) != \\'\\':\\n                        arr.append(\\'\\'.join(word))\\n                    word = []\\n                    i += 1\\n                elif expression[i] != \\')\\':\\n                    word.append(expression[i])\\n                    i += 1\\n                else:\\n                    i += 1\\n\\n\\n            if word != []:\\n                arr.append(\\'\\'.join(word))\\n\\n            return arr\\n\\n        # Change string expression into the list expression\\n        expressionList = parse(1, len(expression) - 1)\\n\\n        # Eval expression with starting scope (variables)\\n        return self.genEval(expressionList, {})\\n    \\n    def genEval(self, expression, scope):\\n        if type(expression) != list:\\n            # If expression is just a variable or int\\n            try:\\n                return int(expression)\\n            except:\\n                return scope[expression]\\n        else:\\n            if expression[0] == \\'let\\':\\n                # Remove \"let\" from expression list\\n                expression = expression[1:]\\n                \\n                # This loop updates the scope (variables)\\n                while len(expression) > 2:\\n                    scope = self.letEval(expression, scope.copy())\\n                    expression = expression[2:]\\n                    \\n                # Return the last value\\n                return self.genEval(expression[0], scope.copy())\\n                \\n            if expression[0] == \\'add\\':\\n                return self.addEval(expression, scope.copy())\\n                \\n            if expression[0] == \\'mult\\':\\n                return self.multEval(expression, scope.copy())\\n\\n\\n    \\n    def letEval(self, expression, scope):\\n        scope[expression[0]] = self.genEval(expression[1], scope)\\n        return scope\\n    \\n    def addEval(self, expression, scope):\\n        return self.genEval(expression[1], scope) + self.genEval(expression[2], scope)\\n    \\n    def multEval(self, expression, scope):\\n        return self.genEval(expression[1], scope) * self.genEval(expression[2], scope)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048344,
                "title": "a-small-interpreter-in-racket",
                "content": "This small interpreter parse the input string into S-expr, then interpret (evaluate) it.\\n\\n```\\nparser -> evaluater\\n```\\n\\nHere I wrote two solutions.\\nThe first use Racket builtin reader. The second use hand-written parser.\\n\\nSolution with Racket builtin S-expr reader\\n\\n```scheme\\n(define/contract (evaluate expression)\\n  (-> string? exact-integer?)\\n  ; builtin-functions\\n  (eval-form (list (cons \\'add (lambda (x y) (+ x y)))\\n                   (cons \\'mult (lambda (x y) (* x y))))\\n             (expr->form expression)))\\n\\n;; parser ;;\\n\\n; use Racket builtin reader\\n(define (expr->form s)\\n  (read (open-input-string s)))\\n\\n;; evaluator ;;\\n\\n(define (eval-form env form)\\n  (cond [(number? form) form]\\n        [(symbol? form) (env-get env form)]\\n        [(eq? (car form) \\'let) (eval-let env form)]\\n        [else (eval-call env form)]))\\n\\n(define (env-get env symbol)\\n  (cdr (assq symbol env)))\\n\\n(define (eval-let env form)\\n  (define (rec env form)\\n    (if (null? (cdr form)) (eval-form env (car form))\\n        (rec (cons (cons (car form) (eval-form env (cadr form)))\\n                   env)\\n             (cddr form))))\\n  (rec env (cdr form)))\\n\\n(define (eval-call env form)\\n  (apply (eval-form env (car form))\\n         (map (lambda (f) (eval-form env f))\\n              (cdr form))))\\n```\\n\\nA hand-written parser (copy paste to replace `expr->form` procedure above)\\n\\n```scheme\\n(define (expr->form s)\\n  (result.form (read-expr (string->list s))))\\n\\n; expr = list | atom\\n(define (read-expr lst)\\n  (let ([rl (read-list lst)])\\n    (if rl rl (read-atom lst))))\\n\\n; list = \"(\", expr+, \")\"\\n(define (read-list lst)\\n  (if (or (null? lst)\\n          (not (char=? (car lst) #\\\\()))\\n      (make-empty-result)\\n      (let ([res (repeat+ (cdr lst) read-expr)])\\n        (make-result (ignore-space (cdr (member #\\\\) (result.remain res))))\\n                     (result.form res)))))\\n\\n; atom = char+, delimiter\\n; delimiter = \" \" | \")\"\\n(define (read-atom lst)\\n  (let-values ([(atom remain)\\n                (splitf-at lst (lambda (c)\\n                                 (not (or (char=? c #\\\\space)\\n                                          (char=? c #\\\\))))))])\\n    (if (null? atom)\\n        (make-empty-result)\\n        (make-result (ignore-space remain)\\n                     (transform-atom (list->string atom))))))\\n\\n(define (transform-atom atom)\\n  (if (pair? atom)\\n      (map transform-atom atom)\\n      (if (char-lower-case? (string-ref atom 0))\\n          (string->symbol atom)\\n          (string->integer atom))))\\n\\n; result data structure ;\\n\\n(define (make-result lst form) (cons form lst))\\n\\n(define (make-empty-result) #f)\\n\\n(define (result-empty? res)\\n  (eq? res #f))\\n\\n(define (result.remain res)\\n  (if (pair? res)\\n    (cdr res)\\n    #f))\\n\\n(define (result.form res)\\n  (if (pair? res)\\n    (car res)\\n    #f))\\n\\n; helpers ;\\n\\n; one or multiple repeats\\n(define (repeat+ lst read1)\\n  (define (next lst res)\\n    (if (null? lst)\\n        (make-result lst (reverse res))\\n        (let ([r (read1 lst)])\\n          (if (result-empty? r)\\n            (make-result lst (reverse res))\\n            (next (result.remain r) (cons (result.form r) res))))))\\n  (next lst \\'()))\\n\\n(define (ignore-space lst)\\n  (if (and (not (null? lst)) \\n           (char=? (car lst) #\\\\space))\\n      (cdr lst)\\n      lst))\\n\\n(define (string->integer s)\\n  (define (char->int c)\\n    (- (char->integer c)\\n       (char->integer #\\\\0)))\\n\\n  (define (list->positive lst)\\n    (for/fold ([int 0])\\n              ([c lst])\\n      (+ (* int 10) (char->int c))))\\n\\n  (let ([lst (string->list s)])\\n    (if (char=? #\\\\- (car lst)) \\n        (- (list->positive (cdr lst)))\\n        (list->positive lst))))\\n```",
                "solutionTags": [
                    "Racket"
                ],
                "code": "```\\nparser -> evaluater\\n```\n```scheme\\n(define/contract (evaluate expression)\\n  (-> string? exact-integer?)\\n  ; builtin-functions\\n  (eval-form (list (cons \\'add (lambda (x y) (+ x y)))\\n                   (cons \\'mult (lambda (x y) (* x y))))\\n             (expr->form expression)))\\n\\n;; parser ;;\\n\\n; use Racket builtin reader\\n(define (expr->form s)\\n  (read (open-input-string s)))\\n\\n;; evaluator ;;\\n\\n(define (eval-form env form)\\n  (cond [(number? form) form]\\n        [(symbol? form) (env-get env form)]\\n        [(eq? (car form) \\'let) (eval-let env form)]\\n        [else (eval-call env form)]))\\n\\n(define (env-get env symbol)\\n  (cdr (assq symbol env)))\\n\\n(define (eval-let env form)\\n  (define (rec env form)\\n    (if (null? (cdr form)) (eval-form env (car form))\\n        (rec (cons (cons (car form) (eval-form env (cadr form)))\\n                   env)\\n             (cddr form))))\\n  (rec env (cdr form)))\\n\\n(define (eval-call env form)\\n  (apply (eval-form env (car form))\\n         (map (lambda (f) (eval-form env f))\\n              (cdr form))))\\n```\n```scheme\\n(define (expr->form s)\\n  (result.form (read-expr (string->list s))))\\n\\n; expr = list | atom\\n(define (read-expr lst)\\n  (let ([rl (read-list lst)])\\n    (if rl rl (read-atom lst))))\\n\\n; list = \"(\", expr+, \")\"\\n(define (read-list lst)\\n  (if (or (null? lst)\\n          (not (char=? (car lst) #\\\\()))\\n      (make-empty-result)\\n      (let ([res (repeat+ (cdr lst) read-expr)])\\n        (make-result (ignore-space (cdr (member #\\\\) (result.remain res))))\\n                     (result.form res)))))\\n\\n; atom = char+, delimiter\\n; delimiter = \" \" | \")\"\\n(define (read-atom lst)\\n  (let-values ([(atom remain)\\n                (splitf-at lst (lambda (c)\\n                                 (not (or (char=? c #\\\\space)\\n                                          (char=? c #\\\\))))))])\\n    (if (null? atom)\\n        (make-empty-result)\\n        (make-result (ignore-space remain)\\n                     (transform-atom (list->string atom))))))\\n\\n(define (transform-atom atom)\\n  (if (pair? atom)\\n      (map transform-atom atom)\\n      (if (char-lower-case? (string-ref atom 0))\\n          (string->symbol atom)\\n          (string->integer atom))))\\n\\n; result data structure ;\\n\\n(define (make-result lst form) (cons form lst))\\n\\n(define (make-empty-result) #f)\\n\\n(define (result-empty? res)\\n  (eq? res #f))\\n\\n(define (result.remain res)\\n  (if (pair? res)\\n    (cdr res)\\n    #f))\\n\\n(define (result.form res)\\n  (if (pair? res)\\n    (car res)\\n    #f))\\n\\n; helpers ;\\n\\n; one or multiple repeats\\n(define (repeat+ lst read1)\\n  (define (next lst res)\\n    (if (null? lst)\\n        (make-result lst (reverse res))\\n        (let ([r (read1 lst)])\\n          (if (result-empty? r)\\n            (make-result lst (reverse res))\\n            (next (result.remain r) (cons (result.form r) res))))))\\n  (next lst \\'()))\\n\\n(define (ignore-space lst)\\n  (if (and (not (null? lst)) \\n           (char=? (car lst) #\\\\space))\\n      (cdr lst)\\n      lst))\\n\\n(define (string->integer s)\\n  (define (char->int c)\\n    (- (char->integer c)\\n       (char->integer #\\\\0)))\\n\\n  (define (list->positive lst)\\n    (for/fold ([int 0])\\n              ([c lst])\\n      (+ (* int 10) (char->int c))))\\n\\n  (let ([lst (string->list s)])\\n    (if (char=? #\\\\- (car lst)) \\n        (- (list->positive (cdr lst)))\\n        (list->positive lst))))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1752865,
                "title": "javascript-recursive-descent-parser-solution",
                "content": "Recursive Descent Parser in JavaScript. Firstly split the input string into tokens with the lexical analysis, and then start parsing process.\\n\\n```\\nclass Lexer {\\n  constructor(s) {\\n    this.tokens = [];\\n    this.idx = 0;\\n    this.tokenize(s);\\n  }\\n  \\n  tokenize(s) {\\n    let i = 0;\\n  \\n    while (i < s.length) {\\n      const c = s[i];\\n      if (/(\\\\(|\\\\))/.test(c)) {\\n        this.tokens.push(c);\\n        i++;\\n      } else if (c == \\'-\\') {\\n        i++;\\n        let num = \\'\\';\\n        while (/\\\\d/.test(s[i])) {\\n          num += s[i];\\n          i++;\\n        }\\n        this.tokens.push(Number(num) * -1);\\n      } else if (/\\\\d/.test(s[i])) {\\n        let num = \\'\\';\\n        while (/\\\\d/.test(s[i])) {\\n          num += s[i];\\n          i++;\\n        }\\n        this.tokens.push(Number(num));\\n      } else if (/[a-z]/.test(s[i])) {\\n        let variable = \\'\\';\\n        while (/([a-z]|[0-9])/.test(s[i])) {\\n          variable += s[i];\\n          i++;\\n        }\\n        this.tokens.push(variable);\\n      } else {\\n        i++;      \\n      }\\n    }\\n  }\\n  \\n  read() {\\n    return this.tokens[this.idx];\\n  }\\n  \\n  readNext() {\\n    return this.tokens[this.idx + 1];\\n  }\\n  \\n  next() {\\n    return this.tokens[this.idx++];\\n  }\\n}\\n\\nclass Parser {\\n  constructor(lex) {\\n    this.lex = lex;\\n    this.variables = {};\\n  }\\n  \\n  expression(vars) {\\n    vars = Object.assign({}, vars);\\n    if (this.lex.read() == \\'(\\') {\\n      this.lex.next();\\n      let result = this.expr(vars);\\n      this.lex.next();\\n      return result;\\n    }\\n    return this.expr(vars);\\n  }\\n  \\n  expr(vars) {\\n    if (this.lex.read() == \\'add\\') {\\n      this.lex.next();\\n      return this.expression(vars) + this.expression(vars);\\n    }\\n    if (this.lex.read() == \\'mult\\') {\\n      this.lex.next();\\n      return this.expression(vars) * this.expression(vars);\\n    }\\n    if (this.lex.read() == \\'let\\') {\\n      return this.let(vars);\\n    }\\n    return this.term(vars);\\n  }\\n  \\n  term(vars) {\\n    if (/^\\\\-*\\\\d+/.test(this.lex.read())) {\\n      return this.lex.next();\\n    }\\n    return vars[this.lex.next()];\\n  }\\n  \\n  isVar() {\\n    if ([\\'(\\', \\')\\', \\'add\\', \\'let\\', \\'mult\\'].includes(this.lex.read())) {\\n      return false;\\n    }\\n    if (/^\\\\-*\\\\d+/.test(this.lex.read())) {\\n      return false;\\n    }\\n    return true;\\n  }\\n  \\n  let(vars) {\\n    this.lex.next();\\n    vars = vars || {};\\n    while (this.isVar() && this.lex.readNext() !== \\')\\') {\\n      vars[this.lex.next()] = this.expression(vars);\\n    }\\n    return this.expression(vars);\\n  }\\n}\\n\\n/**\\n * @param {string} expression\\n * @return {number}\\n */\\nvar evaluate = function(expression) {\\n  const lex = new Lexer(expression);\\n  const parser = new Parser(lex);\\n  \\n  return parser.expression();\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nclass Lexer {\\n  constructor(s) {\\n    this.tokens = [];\\n    this.idx = 0;\\n    this.tokenize(s);\\n  }\\n  \\n  tokenize(s) {\\n    let i = 0;\\n  \\n    while (i < s.length) {\\n      const c = s[i];\\n      if (/(\\\\(|\\\\))/.test(c)) {\\n        this.tokens.push(c);\\n        i++;\\n      } else if (c == \\'-\\') {\\n        i++;\\n        let num = \\'\\';\\n        while (/\\\\d/.test(s[i])) {\\n          num += s[i];\\n          i++;\\n        }\\n        this.tokens.push(Number(num) * -1);\\n      } else if (/\\\\d/.test(s[i])) {\\n        let num = \\'\\';\\n        while (/\\\\d/.test(s[i])) {\\n          num += s[i];\\n          i++;\\n        }\\n        this.tokens.push(Number(num));\\n      } else if (/[a-z]/.test(s[i])) {\\n        let variable = \\'\\';\\n        while (/([a-z]|[0-9])/.test(s[i])) {\\n          variable += s[i];\\n          i++;\\n        }\\n        this.tokens.push(variable);\\n      } else {\\n        i++;      \\n      }\\n    }\\n  }\\n  \\n  read() {\\n    return this.tokens[this.idx];\\n  }\\n  \\n  readNext() {\\n    return this.tokens[this.idx + 1];\\n  }\\n  \\n  next() {\\n    return this.tokens[this.idx++];\\n  }\\n}\\n\\nclass Parser {\\n  constructor(lex) {\\n    this.lex = lex;\\n    this.variables = {};\\n  }\\n  \\n  expression(vars) {\\n    vars = Object.assign({}, vars);\\n    if (this.lex.read() == \\'(\\') {\\n      this.lex.next();\\n      let result = this.expr(vars);\\n      this.lex.next();\\n      return result;\\n    }\\n    return this.expr(vars);\\n  }\\n  \\n  expr(vars) {\\n    if (this.lex.read() == \\'add\\') {\\n      this.lex.next();\\n      return this.expression(vars) + this.expression(vars);\\n    }\\n    if (this.lex.read() == \\'mult\\') {\\n      this.lex.next();\\n      return this.expression(vars) * this.expression(vars);\\n    }\\n    if (this.lex.read() == \\'let\\') {\\n      return this.let(vars);\\n    }\\n    return this.term(vars);\\n  }\\n  \\n  term(vars) {\\n    if (/^\\\\-*\\\\d+/.test(this.lex.read())) {\\n      return this.lex.next();\\n    }\\n    return vars[this.lex.next()];\\n  }\\n  \\n  isVar() {\\n    if ([\\'(\\', \\')\\', \\'add\\', \\'let\\', \\'mult\\'].includes(this.lex.read())) {\\n      return false;\\n    }\\n    if (/^\\\\-*\\\\d+/.test(this.lex.read())) {\\n      return false;\\n    }\\n    return true;\\n  }\\n  \\n  let(vars) {\\n    this.lex.next();\\n    vars = vars || {};\\n    while (this.isVar() && this.lex.readNext() !== \\')\\') {\\n      vars[this.lex.next()] = this.expression(vars);\\n    }\\n    return this.expression(vars);\\n  }\\n}\\n\\n/**\\n * @param {string} expression\\n * @return {number}\\n */\\nvar evaluate = function(expression) {\\n  const lex = new Lexer(expression);\\n  const parser = new Parser(lex);\\n  \\n  return parser.expression();\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1586785,
                "title": "python3-3-solutions",
                "content": "**Both methods have similar run time**\\n\\n##### 1\\nThe idea is to parse each expressions from outer scopes to inner scopes and return in reverse. (Or parse top to bottom and return in reverse, by thinking of it as a tree). Eech expression is returned its value in one recursion. \\n- On-the-fly variables are stored in a global dictionary `var`. Python dict is mutable so just pass it down to each recursion. The scope of `var` are preserved by restoring its outer scope values after inner scopes updated it and before it retured (by using a local `tmpvar` only tracking updated variables). \\n- downside is this is NOT exactly one pass of the `expression` parsing. In each recursion, each expression will be reparsed. \\n- each expression type of `mult`, `add`, `let` has to be treated as individual cases, making code a bit complicated.\\n\\n```python\\nclass Solution:\\n    def evaluate(self, expr: str) -> int:\\n        def eval(expr, var):\\n            if expr[0] != \\'(\\': \\n                return int(var.get(expr, expr))\\n\\n            opt, opens, exprs, tmpvar = expr[1:expr.find(\\' \\')], 0, [], {}\\n            for ch in expr[len(opt)+1:]:\\n                opens += (ch == \\'(\\') - (ch == \\')\\')\\n                if opens < 0:\\n                    if opt == \\'add\\':\\n                        return eval(exprs[0], var) + eval(exprs[1], var)\\n                    if opt == \\'mult\\':\\n                        return eval(exprs[0], var) * eval(exprs[1], var)\\n                    \\n                    _ = eval(exprs[-1], var)\\n                    for k in tmpvar: var[k] = tmpvar[k]  # restore outer scope variable values\\n                    return _\\n                \\n                if ch == \\' \\' and opens == 0:\\n                    if opt == \\'let\\' and len(exprs) // 2:\\n                        if exprs[-2] in var.keys(): tmpvar[exprs[-2]] = var[exprs[-2]]  # variable values updated in inner scope\\n                        var[exprs[-2]] = eval(exprs[-1], var)\\n                        exprs = []\\n                    exprs.append(\\'\\')\\n                else:\\n                    exprs[-1] += ch\\n                    \\n        return eval(expr, {})\\n```\\n\\n##### 2\\na more well structrued version\\n```python\\n    def evaluate(self, expr: str) -> int:\\n        \\'\\'\\'\\n        expression: (oprator factor1, factor2, ...)\\n        factor:  var | num | expression\\n        var: alnum starting with lowercase letter\\n        num: integer\\n        \\'\\'\\'\\n        self.d = []  # leveled variables\\n        tokens = deque(list(expr))\\n        return self.parse_expr(tokens)\\n    \\n    def parse_expr(self, tokens):\\n        tokens.popleft()  # \\'(\\'\\n        opr = self.parse_factor(tokens)\\n        if opr == \\'let\\':\\n            self.d += {},\\n            var = self.parse_factor(tokens)\\n            while tokens[0] != \\')\\':\\n                val = self.parse_factor(tokens)\\n                self.d[-1][var] = self.d[-1].get(val, val)\\n                var = self.parse_factor(tokens)\\n            ans = self.d[-1].get(var, var)\\n            self.d.pop()\\n        elif opr == \\'add\\':\\n            lhs = self.parse_factor(tokens)\\n            rhs = self.parse_factor(tokens)\\n            ans = self.lookup(lhs) + self.lookup(rhs)\\n        else:  # mult\\n            lhs = self.parse_factor(tokens)\\n            rhs = self.parse_factor(tokens)\\n            ans = self.lookup(lhs) * self.lookup(rhs)\\n        tokens.popleft()  # \\')\\'\\n        return ans\\n    \\n    def lookup(self, factor):\\n        for d in self.d[::-1]:\\n            if factor in d:\\n                return d[factor]\\n        return factor\\n    \\n    def parse_factor(self, tokens):\\n        if tokens[0] == \\'(\\':\\n            factor = self.parse_expr(tokens)\\n            if tokens[0] == \\' \\':\\n                tokens.popleft()  # \\' \\'\\n            return factor\\n        \\n        factor = \\'\\'\\n        while tokens[0] not in (\\' \\', \\')\\'):\\n            factor += tokens.popleft()\\n        if tokens[0] == \\' \\':\\n            tokens.popleft()  #  \\' \\'\\n        if factor.isdigit() or factor[0] == \\'-\\' and factor[1:].isdigit():\\n            return int(factor)\\n        return factor\\n```\\n\\n\\n##### 3\\nSame idea.  Using stack, you parse expression from start to end, store each passed expression along with variables at that state in the stack, pop and return each expression value in reverse. \\n- you only need exactly one pass of the whole `expression` this time.\\n- you however need additional space to store expression and variables at each state, since this is not recursion.\\n- when it starts to return expression value in reverse, `let` expression has to be re-evaluated where some of its variable evaluation will be redundant.\\n\\nThis code is directly **copied** from [@sherlock321](https://leetcode.com/problems/parse-lisp-expression/discuss/109709/python-solution-using-stacks.) with few edits. \\n\\n```\\nclass Solution:\\n    def evaluate(self, expression):\\n        def getval(x):\\n            return d.get(x, x)\\n\\n        def eval(tokens):\\n            if tokens[0] in (\\'add\\', \\'mult\\'):\\n                tmp = list(map(int, map(getval, tokens[1:])))\\n                return str(tmp[0] + tmp[1] if tokens[0] == \\'add\\' else tmp[0] * tmp[1])\\n            else: #let\\n                for i in range(1, len(tokens)-1, 2):\\n                    if tokens[i+1]:\\n                        d[tokens[i]] = getval(tokens[i+1])\\n                return getval(tokens[-1])\\n            \\n        st, d, tokens = [], {}, [\\'\\']\\n        for c in expression:\\n            if c == \\'(\\':\\n                if tokens[0] == \\'let\\':\\n                    eval(tokens)\\n                st.append((tokens, dict(d)))\\n                tokens =  [\\'\\']\\n            elif c == \\' \\':\\n                tokens.append(\\'\\')\\n            elif c == \\')\\':\\n                val = eval(tokens)\\n                tokens, d = st.pop()\\n                tokens[-1] += val\\n            else:\\n                tokens[-1] += c\\n        return int(tokens[0])\\n                    \\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def evaluate(self, expr: str) -> int:\\n        def eval(expr, var):\\n            if expr[0] != \\'(\\': \\n                return int(var.get(expr, expr))\\n\\n            opt, opens, exprs, tmpvar = expr[1:expr.find(\\' \\')], 0, [], {}\\n            for ch in expr[len(opt)+1:]:\\n                opens += (ch == \\'(\\') - (ch == \\')\\')\\n                if opens < 0:\\n                    if opt == \\'add\\':\\n                        return eval(exprs[0], var) + eval(exprs[1], var)\\n                    if opt == \\'mult\\':\\n                        return eval(exprs[0], var) * eval(exprs[1], var)\\n                    \\n                    _ = eval(exprs[-1], var)\\n                    for k in tmpvar: var[k] = tmpvar[k]  # restore outer scope variable values\\n                    return _\\n                \\n                if ch == \\' \\' and opens == 0:\\n                    if opt == \\'let\\' and len(exprs) // 2:\\n                        if exprs[-2] in var.keys(): tmpvar[exprs[-2]] = var[exprs[-2]]  # variable values updated in inner scope\\n                        var[exprs[-2]] = eval(exprs[-1], var)\\n                        exprs = []\\n                    exprs.append(\\'\\')\\n                else:\\n                    exprs[-1] += ch\\n                    \\n        return eval(expr, {})\\n```\n```python\\n    def evaluate(self, expr: str) -> int:\\n        \\'\\'\\'\\n        expression: (oprator factor1, factor2, ...)\\n        factor:  var | num | expression\\n        var: alnum starting with lowercase letter\\n        num: integer\\n        \\'\\'\\'\\n        self.d = []  # leveled variables\\n        tokens = deque(list(expr))\\n        return self.parse_expr(tokens)\\n    \\n    def parse_expr(self, tokens):\\n        tokens.popleft()  # \\'(\\'\\n        opr = self.parse_factor(tokens)\\n        if opr == \\'let\\':\\n            self.d += {},\\n            var = self.parse_factor(tokens)\\n            while tokens[0] != \\')\\':\\n                val = self.parse_factor(tokens)\\n                self.d[-1][var] = self.d[-1].get(val, val)\\n                var = self.parse_factor(tokens)\\n            ans = self.d[-1].get(var, var)\\n            self.d.pop()\\n        elif opr == \\'add\\':\\n            lhs = self.parse_factor(tokens)\\n            rhs = self.parse_factor(tokens)\\n            ans = self.lookup(lhs) + self.lookup(rhs)\\n        else:  # mult\\n            lhs = self.parse_factor(tokens)\\n            rhs = self.parse_factor(tokens)\\n            ans = self.lookup(lhs) * self.lookup(rhs)\\n        tokens.popleft()  # \\')\\'\\n        return ans\\n    \\n    def lookup(self, factor):\\n        for d in self.d[::-1]:\\n            if factor in d:\\n                return d[factor]\\n        return factor\\n    \\n    def parse_factor(self, tokens):\\n        if tokens[0] == \\'(\\':\\n            factor = self.parse_expr(tokens)\\n            if tokens[0] == \\' \\':\\n                tokens.popleft()  # \\' \\'\\n            return factor\\n        \\n        factor = \\'\\'\\n        while tokens[0] not in (\\' \\', \\')\\'):\\n            factor += tokens.popleft()\\n        if tokens[0] == \\' \\':\\n            tokens.popleft()  #  \\' \\'\\n        if factor.isdigit() or factor[0] == \\'-\\' and factor[1:].isdigit():\\n            return int(factor)\\n        return factor\\n```\n```\\nclass Solution:\\n    def evaluate(self, expression):\\n        def getval(x):\\n            return d.get(x, x)\\n\\n        def eval(tokens):\\n            if tokens[0] in (\\'add\\', \\'mult\\'):\\n                tmp = list(map(int, map(getval, tokens[1:])))\\n                return str(tmp[0] + tmp[1] if tokens[0] == \\'add\\' else tmp[0] * tmp[1])\\n            else: #let\\n                for i in range(1, len(tokens)-1, 2):\\n                    if tokens[i+1]:\\n                        d[tokens[i]] = getval(tokens[i+1])\\n                return getval(tokens[-1])\\n            \\n        st, d, tokens = [], {}, [\\'\\']\\n        for c in expression:\\n            if c == \\'(\\':\\n                if tokens[0] == \\'let\\':\\n                    eval(tokens)\\n                st.append((tokens, dict(d)))\\n                tokens =  [\\'\\']\\n            elif c == \\' \\':\\n                tokens.append(\\'\\')\\n            elif c == \\')\\':\\n                val = eval(tokens)\\n                tokens, d = st.pop()\\n                tokens[-1] += val\\n            else:\\n                tokens[-1] += c\\n        return int(tokens[0])\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1457888,
                "title": "python-template-solution-for-all-calculator-stuff-no-stack",
                "content": "```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        # 9/11/2021 another exercise for compiler parsing\\n        # following the style from: http://norvig.com/lispy.html\\n        # similar to many others like 726. \\n        # once you ar familiar with this recursive idea, you are good.\\n        \\n        # you can use this and 726 as the templates for all calculator stuff\\n\\t\\t\\n\\t\\t# tokenize returns something like this:\\n\\t\\t# [\\'let\\', \\'x\\', \\'1\\', \\'y\\', \\'2\\', \\'x\\', [\\'add\\', \\'x\\', \\'y\\'], [\\'add\\', \\'x\\', \\'y\\']]\\n        def tokenize(string):\\n            return string.replace(\\'(\\', \\' ( \\').replace(\\')\\', \\' ) \\').split()\\n        \\n        # parse from left\\n        def parse_tokens(tokens):\\n            if not tokens:\\n                raise ValueError(\\'Tokens are empty\\')\\n                \\n            token = tokens.pop(0) \\n            if token == \\')\\':\\n                raise ValueError(\\'Invalid tokens\\')\\n            \\n            if token == \\'(\\':\\n                ret = []\\n                \\n                while tokens[0] != \\')\\':\\n                    ret.append(parse_tokens(tokens))\\n                \\n                tokens.pop(0) # discard the last \\')\\'\\n                return ret\\n            else:\\n                return token\\n            \\n        print(parse_tokens(tokenize(expression)))\\n        \\n        def eval(tokens, parent_env_map):\\n            if isinstance(tokens, str):\\n                if tokens.isnumeric() or tokens.startswith(\\'-\\'):\\n                    return int(tokens)\\n                else:\\n                    return parent_env_map[tokens]\\n\\n            token = tokens[0]\\n            \\n            if token == \\'let\\':\\n                env_map = dict(parent_env_map)\\n                for i in range(2, len(tokens)-1, 2):\\n                    if isinstance(tokens[i], list):\\n                        env_map[tokens[i-1]] = eval(tokens[i], env_map)\\n                    elif tokens[i].isnumeric() or tokens[i].startswith(\\'-\\'):\\n                        env_map[tokens[i-1]] = int(tokens[i])\\n                    else:\\n                        env_map[tokens[i-1]] = env_map[tokens[i]]\\n                return eval(tokens[-1], env_map)\\n            elif token == \\'mult\\':\\n                (_, x, y) = tokens\\n                return eval(x, parent_env_map) * eval(y, parent_env_map)\\n            else:\\n                (_, x, y) = tokens\\n                return eval(x, parent_env_map) + eval(y, parent_env_map)\\n                \\n        return eval(parse_tokens(tokenize(expression)), {})\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        # 9/11/2021 another exercise for compiler parsing\\n        # following the style from: http://norvig.com/lispy.html\\n        # similar to many others like 726. \\n        # once you ar familiar with this recursive idea, you are good.\\n        \\n        # you can use this and 726 as the templates for all calculator stuff\\n\\t\\t\\n\\t\\t# tokenize returns something like this:\\n\\t\\t# [\\'let\\', \\'x\\', \\'1\\', \\'y\\', \\'2\\', \\'x\\', [\\'add\\', \\'x\\', \\'y\\'], [\\'add\\', \\'x\\', \\'y\\']]\\n        def tokenize(string):\\n            return string.replace(\\'(\\', \\' ( \\').replace(\\')\\', \\' ) \\').split()\\n        \\n        # parse from left\\n        def parse_tokens(tokens):\\n            if not tokens:\\n                raise ValueError(\\'Tokens are empty\\')\\n                \\n            token = tokens.pop(0) \\n            if token == \\')\\':\\n                raise ValueError(\\'Invalid tokens\\')\\n            \\n            if token == \\'(\\':\\n                ret = []\\n                \\n                while tokens[0] != \\')\\':\\n                    ret.append(parse_tokens(tokens))\\n                \\n                tokens.pop(0) # discard the last \\')\\'\\n                return ret\\n            else:\\n                return token\\n            \\n        print(parse_tokens(tokenize(expression)))\\n        \\n        def eval(tokens, parent_env_map):\\n            if isinstance(tokens, str):\\n                if tokens.isnumeric() or tokens.startswith(\\'-\\'):\\n                    return int(tokens)\\n                else:\\n                    return parent_env_map[tokens]\\n\\n            token = tokens[0]\\n            \\n            if token == \\'let\\':\\n                env_map = dict(parent_env_map)\\n                for i in range(2, len(tokens)-1, 2):\\n                    if isinstance(tokens[i], list):\\n                        env_map[tokens[i-1]] = eval(tokens[i], env_map)\\n                    elif tokens[i].isnumeric() or tokens[i].startswith(\\'-\\'):\\n                        env_map[tokens[i-1]] = int(tokens[i])\\n                    else:\\n                        env_map[tokens[i-1]] = env_map[tokens[i]]\\n                return eval(tokens[-1], env_map)\\n            elif token == \\'mult\\':\\n                (_, x, y) = tokens\\n                return eval(x, parent_env_map) * eval(y, parent_env_map)\\n            else:\\n                (_, x, y) = tokens\\n                return eval(x, parent_env_map) + eval(y, parent_env_map)\\n                \\n        return eval(parse_tokens(tokenize(expression)), {})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 198009,
                "title": "yet-another-python3-solution",
                "content": "Adopted from Norvig\\'s awesome code: http://norvig.com/lispy.html\\n\\n```\\nfrom operator import add, mul\\nfrom collections import deque\\n\\nclass Solution:\\n    def evaluate(self, expression):\\n\\n        def scan(s):\\n            # TODO: more efficient tokenization.\\n            return s.replace(\\'(\\', \\' ( \\').replace(\\')\\', \\' ) \\').split()\\n        \\n        def parse(tokens):\\n            # returns list, int, or str. \\n            # TODO: wrap in classes for type safety.\\n            tok = tokens.popleft()\\n            if tok == \\'(\\':\\n                L = []\\n                while tokens[0] != \\')\\':\\n                    L.append(parse(tokens))\\n                tokens.popleft() # pop \\')\\'\\n                return L\\n            else:\\n                try: return int(tok)\\n                except ValueError: return tok\\n        \\n        def ast(s):\\n            return parse(deque(scan(s)))\\n        \\n        def eval(e):\\n            if not isinstance(e, list):\\n                if isinstance(e, int):\\n                    return e\\n                else: # str var.\\n                    for scope in reversed(env):\\n                        if e in scope: return scope[e]\\n            else: # e is list.\\n                env.append({}) # since all ops require recursive call, add ht.\\n                if e[0] in [\\'add\\', \\'mult\\']:\\n                    op = add if e[0] == \\'add\\' else mul\\n                    res = op(eval(e[1]), eval(e[2]))\\n                else:\\n                    for i in range(2, len(e), 2): # to prevent index out of range, set i as snd operand\\'s idx.\\n                        env[-1][e[i-1]] = eval(e[i])\\n                    res = eval(e[-1])\\n                env.pop()\\n                return res\\n\\n        env = [] # kept as global var to rm snd arg in eval().\\n        syntax_tree = ast(expression)\\n        print(syntax_tree)\\n        return eval(syntax_tree)\\n```",
                "solutionTags": [],
                "code": "```\\nfrom operator import add, mul\\nfrom collections import deque\\n\\nclass Solution:\\n    def evaluate(self, expression):\\n\\n        def scan(s):\\n            # TODO: more efficient tokenization.\\n            return s.replace(\\'(\\', \\' ( \\').replace(\\')\\', \\' ) \\').split()\\n        \\n        def parse(tokens):\\n            # returns list, int, or str. \\n            # TODO: wrap in classes for type safety.\\n            tok = tokens.popleft()\\n            if tok == \\'(\\':\\n                L = []\\n                while tokens[0] != \\')\\':\\n                    L.append(parse(tokens))\\n                tokens.popleft() # pop \\')\\'\\n                return L\\n            else:\\n                try: return int(tok)\\n                except ValueError: return tok\\n        \\n        def ast(s):\\n            return parse(deque(scan(s)))\\n        \\n        def eval(e):\\n            if not isinstance(e, list):\\n                if isinstance(e, int):\\n                    return e\\n                else: # str var.\\n                    for scope in reversed(env):\\n                        if e in scope: return scope[e]\\n            else: # e is list.\\n                env.append({}) # since all ops require recursive call, add ht.\\n                if e[0] in [\\'add\\', \\'mult\\']:\\n                    op = add if e[0] == \\'add\\' else mul\\n                    res = op(eval(e[1]), eval(e[2]))\\n                else:\\n                    for i in range(2, len(e), 2): # to prevent index out of range, set i as snd operand\\'s idx.\\n                        env[-1][e[i-1]] = eval(e[i])\\n                    res = eval(e[-1])\\n                env.pop()\\n                return res\\n\\n        env = [] # kept as global var to rm snd arg in eval().\\n        syntax_tree = ast(expression)\\n        print(syntax_tree)\\n        return eval(syntax_tree)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109727,
                "title": "java-16-ms-regression-solution-with-explanation",
                "content": "The code I wrote is so ugly, yet the idea besides it is very simple:\\n \\nIn a whole view, the code implements a regression idea: From an outer expression to an inner expression. We call eval(String exp, Map<Integer, Integer> upper) function regressively every time when we face a Lisp expression inside an outer Lisp function so that we could ignore the detail to deal with it.\\n\\nLet's explain the most two ugly implementations I took, though I have no idea to beautify it.\\n\\n\\nExplanation 1: The function readNext(String exp, int low){}\\n\\nThis function is used to do a simple work: to get the next  expression name/Variable/ Value/expresion. I implemented it so long since the expression name ends with a space, yet the expression ends when the '(' and ')' match. I want to return the current position as well as the nextStr, however only one variable is allowed to return, So I have to make nextStr global.\\n\\n\\nExplantion 2: The use of upperMap in eval(String exp, Map<String, Integer> upperMap){\\n      ...\\n     Map<String, Integer> map = new HashMap<>();\\n     map.putAll(upperMap);\\n     ...\\n}\\n\\n\\nLet's look at the testing case:\\n```\\nInput: (let x 2 (add (let x 3 (let x 4 x)) x))\\nOutput: 6\\nExplanation: Even though (let x 4 x) has a deeper scope, it is outside the context\\nof the final x in the add-expression.  That final x will equal 2.\\n```\\nPeople tend to return the output 8 since the inner expression \"(let x 4 x))\" has changed variable x to 4. The right logic is that the HashMap outside the inner expression will have effects in the inner one, yet the inner expression cannot affect the HashMap of outside expression\\n\\n\\nHere is the accepted code:\\n```\\nclass Solution {\\n    String nextStr = \"\";\\n    public int evaluate(String exp){\\n        return eval(exp.substring(1, exp.length() - 1), new HashMap<>());\\n    }\\n    \\n    public int eval(String exp, Map<String, Integer> upperMap) {\\n        int pos = 0;\\n        int len = exp.length() - 1;\\n        Map<String, Integer> map = new HashMap<>();\\n        map.putAll(upperMap);\\n        \\n        pos = readNext(exp, pos);\\n        \\n        if(nextStr.equals(\"add\")){\\n            \\n            pos = readNext(exp, pos);\\n            // we have to consider if nextStr a number, a variable or a expression\\n            int left = nextStr.indexOf(\"(\") == -1 ? map.containsKey(nextStr) ? map.get(nextStr) : Integer.parseInt(nextStr) : eval(nextStr.substring(1, nextStr.length() - 1), map);\\n            \\n            pos = readNext(exp, pos);\\n            int right = nextStr.indexOf(\"(\") == -1 ? map.containsKey(nextStr) ? map.get(nextStr) : Integer.parseInt(nextStr) : eval(nextStr.substring(1, nextStr.length() - 1), map);\\n            \\n            return left + right;\\n        }\\n        \\n        else if(nextStr.equals(\"mult\")){\\n            \\n            pos = readNext(exp, pos);\\n            int left = nextStr.indexOf(\"(\") == -1 ? map.containsKey(nextStr) ? map.get(nextStr) : Integer.parseInt(nextStr) : eval(nextStr.substring(1, nextStr.length() - 1), map);\\n            \\n            pos = readNext(exp, pos);\\n            int right = nextStr.indexOf(\"(\") == -1 ? map.containsKey(nextStr) ? map.get(nextStr) : Integer.parseInt(nextStr) : eval(nextStr.substring(1, nextStr.length() - 1), map);\\n            \\n            return left * right;\\n        }\\n        else{\\n            \\n            pos = readNext(exp, pos);\\n            // read the next Str one time, if there pos doesn't reach len, it means we are still in the process of assignment. Since if pos < len, we still have the next str (of nextStr) to match with nextStr\\n            while(pos < len){\\n                String var = nextStr;\\n                \\n                pos = readNext(exp, pos);\\n                int val = nextStr.indexOf(\"(\") == -1 ? map.containsKey(nextStr) ? map.get(nextStr) : Integer.parseInt(nextStr) : eval(nextStr.substring(1, nextStr.length() - 1), map);\\n                \\n                map.put(var, val);\\n                pos = readNext(exp, pos);\\n            }\\n            \\n            return nextStr.indexOf(\"(\") == -1 ? map.containsKey(nextStr) ? map.get(nextStr) : Integer.parseInt(nextStr) : eval(nextStr.substring(1, nextStr.length() - 1), map);\\n        }\\n    }\\n\\n    // read the next expression/variable/value\\n    public int readNext(String exp, int pos){\\n        int len = exp.length();\\n        int tmp = pos;\\n        int cnt = 0;\\n        // deal with expression\\n        if(exp.charAt(pos) == '('){\\n            pos++; cnt++;\\n            for(; pos < len; pos++){\\n                char ch = exp.charAt(pos);\\n                if(cnt == 0){\\n                    break;\\n                }\\n                if(ch == '('){\\n                    cnt++;\\n                }\\n                else if(ch == ')'){\\n                    cnt--;\\n                }  \\n            }\\n        }\\n        // deal with variable or value\\n        else{\\n            for(; pos < len; pos++){\\n                char ch = exp.charAt(pos);\\n                if(ch == ' ' || ch == ')'){\\n                    break;\\n                }\\n            }    \\n        }\\n        \\n        nextStr = exp.substring(tmp, pos);\\n        return pos + 1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nInput: (let x 2 (add (let x 3 (let x 4 x)) x))\\nOutput: 6\\nExplanation: Even though (let x 4 x) has a deeper scope, it is outside the context\\nof the final x in the add-expression.  That final x will equal 2.\\n```\n```\\nclass Solution {\\n    String nextStr = \"\";\\n    public int evaluate(String exp){\\n        return eval(exp.substring(1, exp.length() - 1), new HashMap<>());\\n    }\\n    \\n    public int eval(String exp, Map<String, Integer> upperMap) {\\n        int pos = 0;\\n        int len = exp.length() - 1;\\n        Map<String, Integer> map = new HashMap<>();\\n        map.putAll(upperMap);\\n        \\n        pos = readNext(exp, pos);\\n        \\n        if(nextStr.equals(\"add\")){\\n            \\n            pos = readNext(exp, pos);\\n            // we have to consider if nextStr a number, a variable or a expression\\n            int left = nextStr.indexOf(\"(\") == -1 ? map.containsKey(nextStr) ? map.get(nextStr) : Integer.parseInt(nextStr) : eval(nextStr.substring(1, nextStr.length() - 1), map);\\n            \\n            pos = readNext(exp, pos);\\n            int right = nextStr.indexOf(\"(\") == -1 ? map.containsKey(nextStr) ? map.get(nextStr) : Integer.parseInt(nextStr) : eval(nextStr.substring(1, nextStr.length() - 1), map);\\n            \\n            return left + right;\\n        }\\n        \\n        else if(nextStr.equals(\"mult\")){\\n            \\n            pos = readNext(exp, pos);\\n            int left = nextStr.indexOf(\"(\") == -1 ? map.containsKey(nextStr) ? map.get(nextStr) : Integer.parseInt(nextStr) : eval(nextStr.substring(1, nextStr.length() - 1), map);\\n            \\n            pos = readNext(exp, pos);\\n            int right = nextStr.indexOf(\"(\") == -1 ? map.containsKey(nextStr) ? map.get(nextStr) : Integer.parseInt(nextStr) : eval(nextStr.substring(1, nextStr.length() - 1), map);\\n            \\n            return left * right;\\n        }\\n        else{\\n            \\n            pos = readNext(exp, pos);\\n            // read the next Str one time, if there pos doesn't reach len, it means we are still in the process of assignment. Since if pos < len, we still have the next str (of nextStr) to match with nextStr\\n            while(pos < len){\\n                String var = nextStr;\\n                \\n                pos = readNext(exp, pos);\\n                int val = nextStr.indexOf(\"(\") == -1 ? map.containsKey(nextStr) ? map.get(nextStr) : Integer.parseInt(nextStr) : eval(nextStr.substring(1, nextStr.length() - 1), map);\\n                \\n                map.put(var, val);\\n                pos = readNext(exp, pos);\\n            }\\n            \\n            return nextStr.indexOf(\"(\") == -1 ? map.containsKey(nextStr) ? map.get(nextStr) : Integer.parseInt(nextStr) : eval(nextStr.substring(1, nextStr.length() - 1), map);\\n        }\\n    }\\n\\n    // read the next expression/variable/value\\n    public int readNext(String exp, int pos){\\n        int len = exp.length();\\n        int tmp = pos;\\n        int cnt = 0;\\n        // deal with expression\\n        if(exp.charAt(pos) == '('){\\n            pos++; cnt++;\\n            for(; pos < len; pos++){\\n                char ch = exp.charAt(pos);\\n                if(cnt == 0){\\n                    break;\\n                }\\n                if(ch == '('){\\n                    cnt++;\\n                }\\n                else if(ch == ')'){\\n                    cnt--;\\n                }  \\n            }\\n        }\\n        // deal with variable or value\\n        else{\\n            for(; pos < len; pos++){\\n                char ch = exp.charAt(pos);\\n                if(ch == ' ' || ch == ')'){\\n                    break;\\n                }\\n            }    \\n        }\\n        \\n        nextStr = exp.substring(tmp, pos);\\n        return pos + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3445653,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        unordered_map<string, int> map;\\n        int idx = 0;\\n        return eval(expression, idx, map);\\n    }\\n    int eval(const string& exp, int& idx, const unordered_map<string, int>& map){\\n        int result;\\n        idx++;\\n        int end = exp.find(\\' \\', idx);\\n        const string op = exp.substr(idx, end - idx);\\n        idx = end + 1;\\n        if(op == \"add\" || op == \"mult\"){\\n            const int v1 = parse_and_eval(exp, idx, map);\\n            const int v2 = parse_and_eval(exp, idx, map);\\n            result = op == \"add\" ? v1 + v2 : v1 * v2;\\n        }else{\\n            unordered_map<string, int> new_map = map;\\n            while(exp[idx] != \\'(\\'){\\n                end = idx;\\n                while(exp[end] != \\' \\' && exp[end] != \\')\\') ++end;\\n                if(exp[end] == \\')\\') break;\\n                const string var = exp.substr(idx, end - idx);\\n                idx = end + 1;\\n                const int val = parse_and_eval(exp, idx, new_map);\\n                new_map[var] = val;\\n            }\\n            result = parse_and_eval(exp, idx, new_map);\\n        }\\n        idx++;\\n        return result;\\n    }\\n    int parse_and_eval(const string& exp, int& idx, const unordered_map<string, int>& map){\\n        int result;\\n        if(exp[idx] == \\'(\\'){\\n            result = eval(exp, idx, map);\\n            if(exp[idx] == \\' \\') ++idx;\\n        }else{\\n            int end = idx;\\n            while(exp[end] != \\' \\' && exp[end] != \\')\\') ++end;\\n            if(exp[idx] == \\'-\\' || (exp[idx] >= \\'0\\' && exp[idx] <= \\'9\\'))\\n                result = stoi(exp.substr(idx, end - idx));\\n            else\\n                result = map.at(exp.substr(idx, end - idx));\\n            idx = exp[end] == \\' \\' ? end + 1 : end;\\n        }\\n        return result;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        \\n        tokens = deque(expression.replace(\\'(\\',\\'( \\').replace(\\')\\',\\' )\\').split())\\n        \\n        def eva(tokens,env):\\n            \\n            if tokens[0] != \\'(\\':\\n                if tokens[0][0] in \\'-1234567890\\':\\n                    return int(tokens.popleft())\\n                else:\\n                    return env[tokens.popleft()]\\n            else:\\n                tokens.popleft()\\n                if tokens[0] in (\\'add\\', \\'mult\\'):\\n                    op = tokens.popleft()\\n                    a, b = eva(tokens, env), eva(tokens, env)\\n                    val = a + b if op == \\'add\\' else a * b\\n                else:\\n                    tokens.popleft()\\n                    local = env.copy()\\n                    while tokens[0] != \\'(\\' and tokens[1] != \\')\\':\\n                        var = tokens.popleft()\\n                        local[var] = eva(tokens, local)\\n                    val = eva(tokens, local)\\n                tokens.popleft()\\n                return val\\n            \\n        return eva(tokens,{})\\n```\\n\\n```Java []\\nclass Solution {\\n    String expression;\\n    int index;\\n    HashMap<String,Deque<Integer>> scope; \\n    public int evaluate(String expression) {\\n        this.expression=expression;\\n        index=0;\\n        scope=new HashMap<>();\\n        return evaluate();\\n    }\\n    private int evaluate(){\\n        if(expression.charAt(index)==\\'(\\'){\\n            index++;\\n            char begin=expression.charAt(index);\\n            int ret;\\n            if(begin==\\'l\\'){\\n                index += 4;\\n                ArrayList<String> vars=new ArrayList<>();\\n                while(true){\\n                    if(!Character.isLowerCase(expression.charAt(index))){\\n                        ret=evaluate();\\n                        break;\\n                    }\\n                    String var=parseVar();\\n                    if(expression.charAt(index)==\\')\\'){\\n                        ret=scope.get(var).peek();\\n                        break;\\n                    }\\n                    vars.add(var);\\n                    index++;\\n                    int e=evaluate();\\n                    scope.putIfAbsent(var, new LinkedList<>());\\n                    scope.get(var).push(e);\\n                    index++;\\n                }\\n                for (String var : vars) {\\n                    scope.get(var).pop();\\n                }\\n            } else if(begin==\\'a\\') {\\n                index += 4;\\n                int v1 = evaluate();\\n                index++;\\n                int v2 = evaluate();\\n                ret = v1+v2;\\n            } else {\\n                index += 5;\\n                int v1 = evaluate();\\n                index++;\\n                int v2 = evaluate();\\n                ret =  v1*v2;\\n            }\\n            index++;\\n            return ret;\\n        } else {\\n            if(Character.isLowerCase(expression.charAt(index))){\\n                String var=parseVar();\\n                return scope.get(var).peek();\\n            } else {\\n                return parseInt();\\n            }\\n        }\\n    }\\n    private int parseInt(){\\n        boolean negative=false;\\n        if(expression.charAt(index)==\\'-\\'){\\n            negative=true;\\n            index++;\\n        }\\n        int ret=0;\\n        while(Character.isDigit(expression.charAt(index))){\\n            ret*=10;\\n            ret+=expression.charAt(index)-\\'0\\';\\n            index++;\\n        }\\n        if(negative) return -ret;\\n        return ret;\\n    }\\n    private String parseVar(){\\n        StringBuilder sb=new StringBuilder();\\n        char c=expression.charAt(index);\\n        while(c!=\\' \\' && c!=\\')\\'){\\n            sb.append(c);\\n            c=expression.charAt(++index);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        unordered_map<string, int> map;\\n        int idx = 0;\\n        return eval(expression, idx, map);\\n    }\\n    int eval(const string& exp, int& idx, const unordered_map<string, int>& map){\\n        int result;\\n        idx++;\\n        int end = exp.find(\\' \\', idx);\\n        const string op = exp.substr(idx, end - idx);\\n        idx = end + 1;\\n        if(op == \"add\" || op == \"mult\"){\\n            const int v1 = parse_and_eval(exp, idx, map);\\n            const int v2 = parse_and_eval(exp, idx, map);\\n            result = op == \"add\" ? v1 + v2 : v1 * v2;\\n        }else{\\n            unordered_map<string, int> new_map = map;\\n            while(exp[idx] != \\'(\\'){\\n                end = idx;\\n                while(exp[end] != \\' \\' && exp[end] != \\')\\') ++end;\\n                if(exp[end] == \\')\\') break;\\n                const string var = exp.substr(idx, end - idx);\\n                idx = end + 1;\\n                const int val = parse_and_eval(exp, idx, new_map);\\n                new_map[var] = val;\\n            }\\n            result = parse_and_eval(exp, idx, new_map);\\n        }\\n        idx++;\\n        return result;\\n    }\\n    int parse_and_eval(const string& exp, int& idx, const unordered_map<string, int>& map){\\n        int result;\\n        if(exp[idx] == \\'(\\'){\\n            result = eval(exp, idx, map);\\n            if(exp[idx] == \\' \\') ++idx;\\n        }else{\\n            int end = idx;\\n            while(exp[end] != \\' \\' && exp[end] != \\')\\') ++end;\\n            if(exp[idx] == \\'-\\' || (exp[idx] >= \\'0\\' && exp[idx] <= \\'9\\'))\\n                result = stoi(exp.substr(idx, end - idx));\\n            else\\n                result = map.at(exp.substr(idx, end - idx));\\n            idx = exp[end] == \\' \\' ? end + 1 : end;\\n        }\\n        return result;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        \\n        tokens = deque(expression.replace(\\'(\\',\\'( \\').replace(\\')\\',\\' )\\').split())\\n        \\n        def eva(tokens,env):\\n            \\n            if tokens[0] != \\'(\\':\\n                if tokens[0][0] in \\'-1234567890\\':\\n                    return int(tokens.popleft())\\n                else:\\n                    return env[tokens.popleft()]\\n            else:\\n                tokens.popleft()\\n                if tokens[0] in (\\'add\\', \\'mult\\'):\\n                    op = tokens.popleft()\\n                    a, b = eva(tokens, env), eva(tokens, env)\\n                    val = a + b if op == \\'add\\' else a * b\\n                else:\\n                    tokens.popleft()\\n                    local = env.copy()\\n                    while tokens[0] != \\'(\\' and tokens[1] != \\')\\':\\n                        var = tokens.popleft()\\n                        local[var] = eva(tokens, local)\\n                    val = eva(tokens, local)\\n                tokens.popleft()\\n                return val\\n            \\n        return eva(tokens,{})\\n```\n```Java []\\nclass Solution {\\n    String expression;\\n    int index;\\n    HashMap<String,Deque<Integer>> scope; \\n    public int evaluate(String expression) {\\n        this.expression=expression;\\n        index=0;\\n        scope=new HashMap<>();\\n        return evaluate();\\n    }\\n    private int evaluate(){\\n        if(expression.charAt(index)==\\'(\\'){\\n            index++;\\n            char begin=expression.charAt(index);\\n            int ret;\\n            if(begin==\\'l\\'){\\n                index += 4;\\n                ArrayList<String> vars=new ArrayList<>();\\n                while(true){\\n                    if(!Character.isLowerCase(expression.charAt(index))){\\n                        ret=evaluate();\\n                        break;\\n                    }\\n                    String var=parseVar();\\n                    if(expression.charAt(index)==\\')\\'){\\n                        ret=scope.get(var).peek();\\n                        break;\\n                    }\\n                    vars.add(var);\\n                    index++;\\n                    int e=evaluate();\\n                    scope.putIfAbsent(var, new LinkedList<>());\\n                    scope.get(var).push(e);\\n                    index++;\\n                }\\n                for (String var : vars) {\\n                    scope.get(var).pop();\\n                }\\n            } else if(begin==\\'a\\') {\\n                index += 4;\\n                int v1 = evaluate();\\n                index++;\\n                int v2 = evaluate();\\n                ret = v1+v2;\\n            } else {\\n                index += 5;\\n                int v1 = evaluate();\\n                index++;\\n                int v2 = evaluate();\\n                ret =  v1*v2;\\n            }\\n            index++;\\n            return ret;\\n        } else {\\n            if(Character.isLowerCase(expression.charAt(index))){\\n                String var=parseVar();\\n                return scope.get(var).peek();\\n            } else {\\n                return parseInt();\\n            }\\n        }\\n    }\\n    private int parseInt(){\\n        boolean negative=false;\\n        if(expression.charAt(index)==\\'-\\'){\\n            negative=true;\\n            index++;\\n        }\\n        int ret=0;\\n        while(Character.isDigit(expression.charAt(index))){\\n            ret*=10;\\n            ret+=expression.charAt(index)-\\'0\\';\\n            index++;\\n        }\\n        if(negative) return -ret;\\n        return ret;\\n    }\\n    private String parseVar(){\\n        StringBuilder sb=new StringBuilder();\\n        char c=expression.charAt(index);\\n        while(c!=\\' \\' && c!=\\')\\'){\\n            sb.append(c);\\n            c=expression.charAt(++index);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149086,
                "title": "best-explained-solution",
                "content": "\\n```\\nclass Context {\\n  unordered_map<string_view, int> _map;\\n  const Context *_parent{};\\n  public:\\n  Context(const Context *parent) : _parent{parent}\\n  {\\n    ;\\n  }\\n  const Context* Parent() const { return _parent; }\\n  int GetValue(const string_view &key) const\\n  {\\n    auto it = _map.find(key);\\n    if (it != _map.end()) return it->second;\\n    if (_parent) return _parent->GetValue(key);\\n    assert(0);\\n    return numeric_limits<int>::min();\\n  }\\n  void AddValue(const string_view &key, int val) {\\n    auto [it, isInserted] = _map.emplace(key, val);\\n    if (!isInserted) it->second = val;\\n  }\\n};\\nclass Solution {\\n  string_view symbol(string_view &expr) {\\n    string_view ret;\\n    if (expr.empty() || !isalpha(expr[0])) {\\n      return ret;\\n    }\\n    auto pos = expr.find_first_of(\" )\");\\n    assert(pos != string_view::npos);\\n    ret = expr.substr(0, pos);\\n    expr.remove_prefix(pos);\\n    return ret;\\n  }\\n  int evaluate(string_view &expr, Context *context) {\\n    assert(!expr.empty());\\n    if (expr[0] == \\'(\\') {\\n      assert(expr.length() >= 4);\\n      if (expr.substr(0, 4) == \"(add\") {\\n        assert(expr.length() > 4);\\n        expr.remove_prefix(4);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int l = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int r = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\')\\');\\n        expr.remove_prefix(1);\\n        return l + r;\\n      }\\n      if (expr.substr(0, 4) == \"(mul\") {\\n        assert(expr.length() > 5);\\n        expr.remove_prefix(5);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int l = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int r = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\')\\');\\n        expr.remove_prefix(1);\\n        return l * r;\\n      }\\n      if (expr.substr(0, 4) == \"(let\") {\\n        assert(expr.length() > 4);\\n        expr.remove_prefix(4);\\n        Context nc(context);\\n        while (1) {\\n          assert(!expr.empty() && expr[0] == \\' \\');\\n          expr.remove_prefix(1);\\n          string_view sym = symbol(expr);\\n          assert(!expr.empty());\\n          if (sym.empty() || expr[0] == \\')\\') {\\n            int ret{};\\n            if (sym.empty()) {\\n              ret = evaluate(expr, &nc);\\n            } else {\\n              ret = nc.GetValue(sym);\\n            }\\n            assert(!expr.empty() && expr[0] == \\')\\');\\n            expr.remove_prefix(1);\\n            return ret;\\n          }\\n          assert(!expr.empty() && expr[0] == \\' \\');\\n          expr.remove_prefix(1);\\n          int value = evaluate(expr, &nc);\\n          nc.AddValue(sym, value);\\n        }\\n        assert(0);\\n      }\\n    } \\n    if (isdigit(expr[0]) || expr[0] == \\'-\\') {\\n      auto pos = expr.find_first_not_of(\"-0123456789\");\\n      auto len = min(expr.length(), pos);\\n      int num;\\n      if (auto [ptr, ec] = from_chars(expr.data(), expr.data()+len, num); ec == errc()) {\\n        expr.remove_prefix(len);\\n      } else {\\n        assert(0);\\n      }\\n      return num;\\n    }\\n    if (isalpha(expr[0])) {\\n      string_view sym = symbol(expr);\\n      assert(!expr.empty() && (expr[0] == \\' \\' || expr[0] == \\')\\'));\\n      return context->GetValue(sym);\\n    }\\n    assert(0);\\n    return numeric_limits<int>::min();\\n  }\\npublic:\\n    int evaluate(string expression) {\\n      string_view expr(expression);\\n      Context context(nullptr);\\n      return evaluate(expr, &context);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ruby",
                    "Bash",
                    "Go",
                    "Scala",
                    "Kotlin"
                ],
                "code": "```\\nclass Context {\\n  unordered_map<string_view, int> _map;\\n  const Context *_parent{};\\n  public:\\n  Context(const Context *parent) : _parent{parent}\\n  {\\n    ;\\n  }\\n  const Context* Parent() const { return _parent; }\\n  int GetValue(const string_view &key) const\\n  {\\n    auto it = _map.find(key);\\n    if (it != _map.end()) return it->second;\\n    if (_parent) return _parent->GetValue(key);\\n    assert(0);\\n    return numeric_limits<int>::min();\\n  }\\n  void AddValue(const string_view &key, int val) {\\n    auto [it, isInserted] = _map.emplace(key, val);\\n    if (!isInserted) it->second = val;\\n  }\\n};\\nclass Solution {\\n  string_view symbol(string_view &expr) {\\n    string_view ret;\\n    if (expr.empty() || !isalpha(expr[0])) {\\n      return ret;\\n    }\\n    auto pos = expr.find_first_of(\" )\");\\n    assert(pos != string_view::npos);\\n    ret = expr.substr(0, pos);\\n    expr.remove_prefix(pos);\\n    return ret;\\n  }\\n  int evaluate(string_view &expr, Context *context) {\\n    assert(!expr.empty());\\n    if (expr[0] == \\'(\\') {\\n      assert(expr.length() >= 4);\\n      if (expr.substr(0, 4) == \"(add\") {\\n        assert(expr.length() > 4);\\n        expr.remove_prefix(4);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int l = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int r = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\')\\');\\n        expr.remove_prefix(1);\\n        return l + r;\\n      }\\n      if (expr.substr(0, 4) == \"(mul\") {\\n        assert(expr.length() > 5);\\n        expr.remove_prefix(5);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int l = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int r = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\')\\');\\n        expr.remove_prefix(1);\\n        return l * r;\\n      }\\n      if (expr.substr(0, 4) == \"(let\") {\\n        assert(expr.length() > 4);\\n        expr.remove_prefix(4);\\n        Context nc(context);\\n        while (1) {\\n          assert(!expr.empty() && expr[0] == \\' \\');\\n          expr.remove_prefix(1);\\n          string_view sym = symbol(expr);\\n          assert(!expr.empty());\\n          if (sym.empty() || expr[0] == \\')\\') {\\n            int ret{};\\n            if (sym.empty()) {\\n              ret = evaluate(expr, &nc);\\n            } else {\\n              ret = nc.GetValue(sym);\\n            }\\n            assert(!expr.empty() && expr[0] == \\')\\');\\n            expr.remove_prefix(1);\\n            return ret;\\n          }\\n          assert(!expr.empty() && expr[0] == \\' \\');\\n          expr.remove_prefix(1);\\n          int value = evaluate(expr, &nc);\\n          nc.AddValue(sym, value);\\n        }\\n        assert(0);\\n      }\\n    } \\n    if (isdigit(expr[0]) || expr[0] == \\'-\\') {\\n      auto pos = expr.find_first_not_of(\"-0123456789\");\\n      auto len = min(expr.length(), pos);\\n      int num;\\n      if (auto [ptr, ec] = from_chars(expr.data(), expr.data()+len, num); ec == errc()) {\\n        expr.remove_prefix(len);\\n      } else {\\n        assert(0);\\n      }\\n      return num;\\n    }\\n    if (isalpha(expr[0])) {\\n      string_view sym = symbol(expr);\\n      assert(!expr.empty() && (expr[0] == \\' \\' || expr[0] == \\')\\'));\\n      return context->GetValue(sym);\\n    }\\n    assert(0);\\n    return numeric_limits<int>::min();\\n  }\\npublic:\\n    int evaluate(string expression) {\\n      string_view expr(expression);\\n      Context context(nullptr);\\n      return evaluate(expr, &context);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2698962,
                "title": "c-fsa-parser-o-n",
                "content": "Runtime: 10 ms, faster than 72.06% of C++ online submissions for Parse Lisp Expression.\\nMemory Usage: 13.2 MB, less than 60.29% of C++ online submissions for Parse Lisp Expression.\\n\\n```\\nenum State {\\n    COMMAND,\\n    LHS,\\n    RHS\\n};\\n\\nclass Solution {\\n    bool isAlpha(string &buffer) {\\n        return buffer[0] >= \\'a\\';\\n    }\\n\\n    int getValue(string &buffer, unordered_map<string, int> &variables) {\\n        if (isAlpha(buffer)) return variables[buffer];\\n        return stoi(buffer);\\n    }\\n\\n    // {return, scope_end}\\n    pair<int, int> evaluate(string &expr, int start_index, unordered_map<string, int> variables) {\\n        int open_parenthesis = 1, numeric_buffer, cursor = start_index;\\n        string cmd_buffer, lhs_buffer, buffer;\\n        State current_state = COMMAND;\\n\\n        while (open_parenthesis) {\\n            switch (current_state) {\\n                case COMMAND: {\\n                    if (expr[cursor] != \\' \\') cmd_buffer += expr[cursor++];\\n                    else current_state = LHS;\\n                    break;\\n                }\\n                case LHS: {\\n                    if (expr[cursor] == \\' \\' && lhs_buffer.empty()) ++cursor;\\n                    else if (expr[cursor] == \\'(\\' || expr[cursor] == \\' \\' || expr[cursor] == \\')\\') {\\n                        if (expr[cursor] == \\'(\\') {\\n                            auto result = evaluate(expr, cursor + 1, variables);\\n                            cursor = result.second;\\n                            numeric_buffer = result.first;\\n                            lhs_buffer = to_string(numeric_buffer);\\n                        } else\\n                            numeric_buffer = getValue(lhs_buffer, variables);\\n                        current_state = RHS;\\n                        if (expr[cursor] == \\')\\') --open_parenthesis;\\n                        ++cursor;\\n                    } else lhs_buffer += expr[cursor++];\\n                    break;\\n                }\\n                case RHS: {\\n                    if (expr[cursor] == \\' \\' && buffer.empty()) ++cursor;\\n                    else if (expr[cursor] == \\'(\\' || expr[cursor] == \\' \\' || expr[cursor] == \\')\\') {\\n                        if (expr[cursor] == \\'(\\') {\\n                            auto result = evaluate(expr, cursor + 1, variables);\\n                            cursor = result.second;\\n                            numeric_buffer = result.first;\\n                        } else\\n                            numeric_buffer = getValue(buffer, variables);\\n\\n                        if (cmd_buffer == \"let\" && isAlpha(lhs_buffer))\\n                            variables[lhs_buffer] = numeric_buffer;\\n                        else if (cmd_buffer == \"mult\")\\n                            numeric_buffer *= getValue(lhs_buffer, variables);\\n                        else\\n                            numeric_buffer += getValue(lhs_buffer, variables);\\n                        current_state = LHS;\\n                        lhs_buffer.clear();\\n                        buffer.clear();\\n                        if (expr[cursor] == \\')\\') --open_parenthesis;\\n                        ++cursor;\\n                    } else buffer += expr[cursor++];\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return {numeric_buffer, cursor};\\n    }\\n\\npublic:\\n    int evaluate(string expression) {\\n        unordered_map<string, int> variables;\\n        return evaluate(expression, 1, variables).first;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nenum State {\\n    COMMAND,\\n    LHS,\\n    RHS\\n};\\n\\nclass Solution {\\n    bool isAlpha(string &buffer) {\\n        return buffer[0] >= \\'a\\';\\n    }\\n\\n    int getValue(string &buffer, unordered_map<string, int> &variables) {\\n        if (isAlpha(buffer)) return variables[buffer];\\n        return stoi(buffer);\\n    }\\n\\n    // {return, scope_end}\\n    pair<int, int> evaluate(string &expr, int start_index, unordered_map<string, int> variables) {\\n        int open_parenthesis = 1, numeric_buffer, cursor = start_index;\\n        string cmd_buffer, lhs_buffer, buffer;\\n        State current_state = COMMAND;\\n\\n        while (open_parenthesis) {\\n            switch (current_state) {\\n                case COMMAND: {\\n                    if (expr[cursor] != \\' \\') cmd_buffer += expr[cursor++];\\n                    else current_state = LHS;\\n                    break;\\n                }\\n                case LHS: {\\n                    if (expr[cursor] == \\' \\' && lhs_buffer.empty()) ++cursor;\\n                    else if (expr[cursor] == \\'(\\' || expr[cursor] == \\' \\' || expr[cursor] == \\')\\') {\\n                        if (expr[cursor] == \\'(\\') {\\n                            auto result = evaluate(expr, cursor + 1, variables);\\n                            cursor = result.second;\\n                            numeric_buffer = result.first;\\n                            lhs_buffer = to_string(numeric_buffer);\\n                        } else\\n                            numeric_buffer = getValue(lhs_buffer, variables);\\n                        current_state = RHS;\\n                        if (expr[cursor] == \\')\\') --open_parenthesis;\\n                        ++cursor;\\n                    } else lhs_buffer += expr[cursor++];\\n                    break;\\n                }\\n                case RHS: {\\n                    if (expr[cursor] == \\' \\' && buffer.empty()) ++cursor;\\n                    else if (expr[cursor] == \\'(\\' || expr[cursor] == \\' \\' || expr[cursor] == \\')\\') {\\n                        if (expr[cursor] == \\'(\\') {\\n                            auto result = evaluate(expr, cursor + 1, variables);\\n                            cursor = result.second;\\n                            numeric_buffer = result.first;\\n                        } else\\n                            numeric_buffer = getValue(buffer, variables);\\n\\n                        if (cmd_buffer == \"let\" && isAlpha(lhs_buffer))\\n                            variables[lhs_buffer] = numeric_buffer;\\n                        else if (cmd_buffer == \"mult\")\\n                            numeric_buffer *= getValue(lhs_buffer, variables);\\n                        else\\n                            numeric_buffer += getValue(lhs_buffer, variables);\\n                        current_state = LHS;\\n                        lhs_buffer.clear();\\n                        buffer.clear();\\n                        if (expr[cursor] == \\')\\') --open_parenthesis;\\n                        ++cursor;\\n                    } else buffer += expr[cursor++];\\n                    break;\\n                }\\n            }\\n        }\\n\\n        return {numeric_buffer, cursor};\\n    }\\n\\npublic:\\n    int evaluate(string expression) {\\n        unordered_map<string, int> variables;\\n        return evaluate(expression, 1, variables).first;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2048231,
                "title": "rust-solution",
                "content": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    fn parse(expressions: &mut Vec<&str>, variables: HashMap<String, i32>) -> Option<i32> {\\n        let mut variables = variables;\\n        let mut result = None;\\n        while let Some(expression) = expressions.pop() {\\n            match expression {\\n                \")\" => {\\n                    return result;\\n                }\\n                \"(\" => {\\n                    return Self::parse(expressions, variables.clone());\\n                }\\n                \"add\" => {\\n                    let a = Self::parse(expressions, variables.clone()).unwrap();\\n                    let b = Self::parse(expressions, variables.clone()).unwrap();\\n                    result = Some(a + b);\\n                }\\n                \"mult\" => {\\n                    let a = Self::parse(expressions, variables.clone()).unwrap();\\n                    let b = Self::parse(expressions, variables.clone()).unwrap();\\n                    result = Some(a * b);\\n                }\\n                \"let\" => {\\n                    let mut name = None;\\n                    let mut let_result = None;\\n                    while \")\" != expressions[expressions.len() - 1] {\\n                        if name.is_none() {\\n                            name = Some(expressions[expressions.len() - 1]);\\n                            let_result = Self::parse(expressions, variables.clone());\\n                            continue;\\n                        }\\n                        if name.is_some() {\\n                            if expressions[expressions.len() - 1] == \")\" {\\n                                break;\\n                            }\\n                            if let Some(val) = Self::parse(expressions, variables.clone()) {\\n                                variables.insert(name.unwrap().to_string(), val);\\n                                name = None;\\n                                let_result = None;\\n                                continue;\\n                            } else {\\n                                break;\\n                            }\\n                        }\\n                    }\\n                    result = let_result;\\n                }\\n                c if c.parse::<i32>().is_ok() => {\\n                    return Some(c.parse::<i32>().unwrap());\\n                }\\n                _ => {\\n                    return variables.get(expression).cloned();\\n                }\\n            }\\n        }\\n        None\\n    }\\n    pub fn evaluate(expression: String) -> i32 {\\n        let mut expression = expression;\\n        expression = expression.replace(\"(\", \" ( \");\\n        expression = expression.replace(\")\", \" ) \");\\n\\n        Self::parse(\\n            &mut expression.split_whitespace().rev().collect::<Vec<&str>>(),\\n            HashMap::new(),\\n        )\\n        .unwrap()\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    fn parse(expressions: &mut Vec<&str>, variables: HashMap<String, i32>) -> Option<i32> {\\n        let mut variables = variables;\\n        let mut result = None;\\n        while let Some(expression) = expressions.pop() {\\n            match expression {\\n                \")\" => {\\n                    return result;\\n                }\\n                \"(\" => {\\n                    return Self::parse(expressions, variables.clone());\\n                }\\n                \"add\" => {\\n                    let a = Self::parse(expressions, variables.clone()).unwrap();\\n                    let b = Self::parse(expressions, variables.clone()).unwrap();\\n                    result = Some(a + b);\\n                }\\n                \"mult\" => {\\n                    let a = Self::parse(expressions, variables.clone()).unwrap();\\n                    let b = Self::parse(expressions, variables.clone()).unwrap();\\n                    result = Some(a * b);\\n                }\\n                \"let\" => {\\n                    let mut name = None;\\n                    let mut let_result = None;\\n                    while \")\" != expressions[expressions.len() - 1] {\\n                        if name.is_none() {\\n                            name = Some(expressions[expressions.len() - 1]);\\n                            let_result = Self::parse(expressions, variables.clone());\\n                            continue;\\n                        }\\n                        if name.is_some() {\\n                            if expressions[expressions.len() - 1] == \")\" {\\n                                break;\\n                            }\\n                            if let Some(val) = Self::parse(expressions, variables.clone()) {\\n                                variables.insert(name.unwrap().to_string(), val);\\n                                name = None;\\n                                let_result = None;\\n                                continue;\\n                            } else {\\n                                break;\\n                            }\\n                        }\\n                    }\\n                    result = let_result;\\n                }\\n                c if c.parse::<i32>().is_ok() => {\\n                    return Some(c.parse::<i32>().unwrap());\\n                }\\n                _ => {\\n                    return variables.get(expression).cloned();\\n                }\\n            }\\n        }\\n        None\\n    }\\n    pub fn evaluate(expression: String) -> i32 {\\n        let mut expression = expression;\\n        expression = expression.replace(\"(\", \" ( \");\\n        expression = expression.replace(\")\", \" ) \");\\n\\n        Self::parse(\\n            &mut expression.split_whitespace().rev().collect::<Vec<&str>>(),\\n            HashMap::new(),\\n        )\\n        .unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1875013,
                "title": "modern-c-piecing-together-little-abstractions-0ms-100-prcntle-perf-memory",
                "content": "If I were the interviewer, I would use this to gauge a candidate\\'s ability to solve a complex problem by piecing together smaller abstractions (even if the candidate doesn\\'t solve the problem in entirety in 30 mins) i.e. this to me is a low level design question.\\n\\nI wouldn\\'t be expecting an unreadable \\'one function\\' solution here which would backfire especially if the interviewer decides to extend the question to validate the correctness of the input against the grammar.\\n\\nIt  is much easier to attempt this in python though (in an interview setting).\\n\\n# Intuition\\n1. Every nested scope represented by a \\'(\\' will result in an element being pushed to an evaluation stack.\\n2. Each scope is evaluated when its corresponding \\')\\' is met.\\n3. After a scope is evaluated, its result is popped from stack and handed over to the prior scope represented by the new top of the stack.\\n4. Whenever the expression ends, the result must be on top of the stack.\\n\\n# Notes\\n1. With careful handling, we can make the parser a single forward pass - including handling expression errors and providing diagnostics to debug them if needed.\\n2. The solutions that use recursion can thrash stack on very large expressions. In practice expressions may be deeply nested when they are auto generated.\\n\\n```\\nnamespace lisp\\n{\\n\\nclass Integer;\\nclass Variable;\\nclass VariableRef;\\nclass LetExpr;\\nclass AddExpr;\\nclass MultExpr;\\n\\nclass Expression;\\n\\nclass Integer\\n{\\npublic:\\n    \\n    Integer(int value_arg)\\n        : value(value_arg)\\n    {}\\n    \\n    void add(Expression& expr)\\n    {\\n        assert(false);\\n    }\\n    \\n    bool complete() const noexcept\\n    {\\n        return true;\\n    }\\n    \\n    int compute() noexcept\\n    {\\n        return value;\\n    }\\n    \\nprivate:\\n    int value;\\n};\\n\\nclass Variable\\n{\\npublic:\\n    Variable(std::string_view name_arg)\\n        : expr(nullptr),\\n          name(name_arg)\\n    {}\\n\\n    void add(Expression& expr_arg);\\n   \\n    bool complete() const noexcept\\n    {\\n        return expr;\\n    }\\n    \\n    int compute() noexcept\\n    {\\n        assert(expr);\\n        return value;\\n    }\\n    \\n    const std::string_view name;\\nprivate:  \\n    Expression* expr{nullptr};\\n    int value;\\n};\\n\\nclass VariableRef\\n{\\npublic:\\n    VariableRef(Variable& var_arg)\\n        : var(var_arg)\\n    {}\\n    \\n    void add(Expression&) noexcept\\n    {\\n        assert(false);\\n    }\\n    \\n    int compute() noexcept\\n    {\\n        return var.compute();\\n    }\\n    \\n    bool complete() const noexcept\\n    {\\n        return var.complete();\\n    }\\nprivate:\\n    Variable& var;\\n};\\n\\nclass LetExpr\\n{\\npublic:\\n    \\n    void add(Expression& expr_arg);\\n    \\n    bool complete() const noexcept\\n    {\\n        return expr;\\n    }\\n    \\n    int compute() noexcept;\\nprivate:\\n    //std::vector<Variable*> vars; // Important to correctly model the problem and to validate correctness but not required for this question\\n    Expression* expr{nullptr};\\n};\\n\\nclass BinaryOp\\n{\\nprotected:\\n    Expression* first_expr{nullptr};\\n    Expression* second_expr{nullptr};\\n    \\npublic:\\n    void add(Expression& expr_arg) noexcept;\\n    \\n    bool complete() const noexcept\\n    {\\n        return first_expr && second_expr;\\n    }\\n};\\n\\nstruct AddExpr : public BinaryOp\\n{\\n    int compute() noexcept;\\n};\\n\\nstruct MultExpr : public BinaryOp\\n{\\n    int compute() noexcept;\\n};\\n\\nstruct Expression\\n{\\n    using ExpressionT = std::variant<Integer, Variable, VariableRef, LetExpr, AddExpr, MultExpr>;\\n    \\n    Expression(ExpressionT const& expr_arg)\\n        : expr(expr_arg)\\n    {}\\n    \\n    Expression(ExpressionT&& expr_arg)\\n        : expr(std::move(expr_arg))\\n    {}\\n    \\n    void add(Expression& expr_arg)\\n    {\\n        std::visit([&expr_arg](auto& concrete_expr) { concrete_expr.add(expr_arg); }, expr);\\n    }\\n    \\n    int compute() noexcept\\n    {\\n        return std::visit([](auto& concrete_expr) noexcept {return concrete_expr.compute();}, expr);\\n    }\\n    \\n    bool complete() const noexcept\\n    {\\n        return std::visit([](auto& concrete_expr) noexcept {return concrete_expr.complete();}, expr);\\n    }\\n    \\n    ExpressionT expr;\\n};\\n\\ninline void Variable::add(Expression& expr_arg)\\n{\\n    expr = &expr_arg;\\n    value = expr->compute();\\n}\\n\\ninline void LetExpr::add(Expression& expr_arg)\\n{\\n    if(!std::holds_alternative<Variable>(expr_arg.expr))\\n    {\\n        expr = &expr_arg;\\n    }\\n}\\n\\ninline int LetExpr::compute() noexcept\\n{\\n    assert(complete());\\n    return expr->compute();\\n}\\n\\ninline void BinaryOp::add(Expression& expr_arg) noexcept\\n{\\n    assert(!(first_expr && second_expr));\\n    \\n    if(!first_expr) first_expr = &expr_arg;\\n    else if(!second_expr) second_expr = &expr_arg;\\n}\\n\\ninline int AddExpr::compute() noexcept\\n{\\n    assert(complete());\\n    return first_expr->compute() + second_expr->compute();\\n}\\n\\ninline int MultExpr::compute() noexcept\\n{\\n    assert(complete());\\n    return first_expr->compute() * second_expr->compute();\\n}\\n\\n// The boring part - is a quick rough impl - surely could be improved\\ninline std::tuple<std::string_view, std::size_t, bool> next_token(std::string_view buff)\\n{\\n    int start_index = 0;\\n    auto consumed = 0ul;\\n    for(auto ch: buff)\\n    {\\n        assert(ch != \\')\\');\\n        if(ch != \\' \\' && ch != \\'(\\') break;\\n        ++consumed;\\n        ++start_index;\\n    }\\n    buff.remove_prefix(start_index);\\n    \\n    int end_index = 0;\\n    bool end_of_expr = false;\\n    for(auto ch: buff)\\n    {\\n        ++consumed;\\n        if(ch == \\' \\') break;\\n        if(ch == \\')\\')\\n        {\\n            end_of_expr = true;\\n            break;\\n        }\\n        ++end_index;\\n    }\\n    \\n    for(auto ch : buff.substr(end_index + 1))\\n    {\\n        if(ch != \\' \\' && ch != \\')\\') break;\\n        ++consumed;\\n    }  \\n    buff.remove_suffix(buff.size() - end_index);\\n    \\n    return {buff, consumed, end_of_expr};\\n}\\n\\ninline std::tuple<int, bool> integer(std::string_view token) noexcept\\n{\\n    int result;\\n    auto [ptr, ec] = std::from_chars(token.begin(), token.end(), result);\\n    if(ptr == token.end() && (ec == std::errc()))\\n    {\\n        return {result, true};\\n    }\\n    return {result, false};\\n}\\n\\nusing Variables = std::unordered_map<std::string_view, VariableRef>;\\nVariableRef find_var(std::string_view var_name, std::vector<Variables>& vars_by_scope)\\n{\\n    using namespace std::string_view_literals;\\n    static Variable temp(\"\"sv);\\n    for(auto r_iter=vars_by_scope.rbegin(); r_iter != vars_by_scope.rend(); ++r_iter)\\n    {\\n        if(auto iter = r_iter->find(var_name);\\n           iter != r_iter->end() && iter->second.complete())\\n        {\\n            return iter->second;\\n        }\\n    }\\n    assert(false && \"always a valid reference as per the question\");\\n    return VariableRef(temp);\\n}\\n\\nvoid eval_stack(std::stack<Expression*>& parse_stack, std::vector<Variables>& vars_by_scope)\\n{\\n    while((parse_stack.size() > 1) && parse_stack.top()->complete()) // complete() == true means we can now hand it over the expression before it\\n    {\\n        auto* expr = parse_stack.top();\\n        if(std::holds_alternative<LetExpr>(expr->expr))\\n        {\\n            vars_by_scope.pop_back();\\n        }\\n        else if(std::holds_alternative<Variable>(expr->expr))\\n        {\\n            auto& var = std::get<Variable>(expr->expr);\\n            vars_by_scope.back().erase(var.name); // (let x 3 x 2 x) -> we need the second \\'x\\'.\\n            vars_by_scope.back().emplace(var.name, var);\\n        }\\n        parse_stack.pop();\\n        parse_stack.top()->add(*expr);\\n    }\\n}\\n\\nint parse(std::string_view buff)\\n{\\n     std::deque<Expression>  expressions; // the container to hold every expression in heap\\n\\t std::stack<Expression*> parse_stack; // evaluation stack\\n     std::vector<Variables>  vars_by_scope;\\n    \\n    while(!buff.empty())\\n    {\\n        auto [token, consumed, eoe] = next_token(buff); // eoe = end of expression\\n\\t\\t\\n        using namespace std::string_view_literals;\\n        if(token == \"let\"sv)\\n        {\\n            expressions.emplace_back(LetExpr{});\\n            vars_by_scope.emplace_back(Variables{}); // create a new scope\\n        }\\n        else if(token == \"mult\"sv)\\n        {\\n            expressions.emplace_back(MultExpr{});\\n        }\\n        else if(token == \"add\"sv)\\n        {\\n            expressions.emplace_back(AddExpr{});\\n        }\\n        else if(auto [int_val, is_int] = integer(token);\\n                is_int)\\n        {\\n            expressions.emplace_back(Integer{int_val});\\n        }\\n        else if(std::holds_alternative<LetExpr>(parse_stack.top()->expr) && !eoe) // Variable Initialization\\n        {\\n            expressions.emplace_back(Variable{token});\\n        }\\n        else // VariableRef\\n        {\\n            expressions.emplace_back(find_var(token, vars_by_scope));\\n        }\\n        parse_stack.emplace(&(expressions.back()));\\n        eval_stack(parse_stack, vars_by_scope);\\n        buff.remove_prefix(consumed);\\n    }\\n    assert(parse_stack.size() == 1);\\n    return parse_stack.top()->compute();\\n}\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int evaluate(string expression)\\n    {\\n        // Actual implementation just refers to the original\\n        // string. It never makes a copy of even a substring\\n        // or a token. That\\'s why the space usage is so low.\\n        // This also means no unnecessary string allocations\\n        // on heap.\\n        //\\n        // Even though the implementation looks long, it\\'s\\n        // extremely light and fast with no hacks -\\n        // 100 percentile perf and memory.\\n        //\\n        // It demonstrates the power of zero cost abstractions\\n        // in modern C++. Of course there is plenty of room for improvements.\\n        //\\n        // Both the evaluation stack and container holding\\n        // expressions/results are on heap.\\n        // There is no risk of stack overflows no matter the\\n        // length of input expression.\\n        return lisp::parse(std::string_view(expression));    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nnamespace lisp\\n{\\n\\nclass Integer;\\nclass Variable;\\nclass VariableRef;\\nclass LetExpr;\\nclass AddExpr;\\nclass MultExpr;\\n\\nclass Expression;\\n\\nclass Integer\\n{\\npublic:\\n    \\n    Integer(int value_arg)\\n        : value(value_arg)\\n    {}\\n    \\n    void add(Expression& expr)\\n    {\\n        assert(false);\\n    }\\n    \\n    bool complete() const noexcept\\n    {\\n        return true;\\n    }\\n    \\n    int compute() noexcept\\n    {\\n        return value;\\n    }\\n    \\nprivate:\\n    int value;\\n};\\n\\nclass Variable\\n{\\npublic:\\n    Variable(std::string_view name_arg)\\n        : expr(nullptr),\\n          name(name_arg)\\n    {}\\n\\n    void add(Expression& expr_arg);\\n   \\n    bool complete() const noexcept\\n    {\\n        return expr;\\n    }\\n    \\n    int compute() noexcept\\n    {\\n        assert(expr);\\n        return value;\\n    }\\n    \\n    const std::string_view name;\\nprivate:  \\n    Expression* expr{nullptr};\\n    int value;\\n};\\n\\nclass VariableRef\\n{\\npublic:\\n    VariableRef(Variable& var_arg)\\n        : var(var_arg)\\n    {}\\n    \\n    void add(Expression&) noexcept\\n    {\\n        assert(false);\\n    }\\n    \\n    int compute() noexcept\\n    {\\n        return var.compute();\\n    }\\n    \\n    bool complete() const noexcept\\n    {\\n        return var.complete();\\n    }\\nprivate:\\n    Variable& var;\\n};\\n\\nclass LetExpr\\n{\\npublic:\\n    \\n    void add(Expression& expr_arg);\\n    \\n    bool complete() const noexcept\\n    {\\n        return expr;\\n    }\\n    \\n    int compute() noexcept;\\nprivate:\\n    //std::vector<Variable*> vars; // Important to correctly model the problem and to validate correctness but not required for this question\\n    Expression* expr{nullptr};\\n};\\n\\nclass BinaryOp\\n{\\nprotected:\\n    Expression* first_expr{nullptr};\\n    Expression* second_expr{nullptr};\\n    \\npublic:\\n    void add(Expression& expr_arg) noexcept;\\n    \\n    bool complete() const noexcept\\n    {\\n        return first_expr && second_expr;\\n    }\\n};\\n\\nstruct AddExpr : public BinaryOp\\n{\\n    int compute() noexcept;\\n};\\n\\nstruct MultExpr : public BinaryOp\\n{\\n    int compute() noexcept;\\n};\\n\\nstruct Expression\\n{\\n    using ExpressionT = std::variant<Integer, Variable, VariableRef, LetExpr, AddExpr, MultExpr>;\\n    \\n    Expression(ExpressionT const& expr_arg)\\n        : expr(expr_arg)\\n    {}\\n    \\n    Expression(ExpressionT&& expr_arg)\\n        : expr(std::move(expr_arg))\\n    {}\\n    \\n    void add(Expression& expr_arg)\\n    {\\n        std::visit([&expr_arg](auto& concrete_expr) { concrete_expr.add(expr_arg); }, expr);\\n    }\\n    \\n    int compute() noexcept\\n    {\\n        return std::visit([](auto& concrete_expr) noexcept {return concrete_expr.compute();}, expr);\\n    }\\n    \\n    bool complete() const noexcept\\n    {\\n        return std::visit([](auto& concrete_expr) noexcept {return concrete_expr.complete();}, expr);\\n    }\\n    \\n    ExpressionT expr;\\n};\\n\\ninline void Variable::add(Expression& expr_arg)\\n{\\n    expr = &expr_arg;\\n    value = expr->compute();\\n}\\n\\ninline void LetExpr::add(Expression& expr_arg)\\n{\\n    if(!std::holds_alternative<Variable>(expr_arg.expr))\\n    {\\n        expr = &expr_arg;\\n    }\\n}\\n\\ninline int LetExpr::compute() noexcept\\n{\\n    assert(complete());\\n    return expr->compute();\\n}\\n\\ninline void BinaryOp::add(Expression& expr_arg) noexcept\\n{\\n    assert(!(first_expr && second_expr));\\n    \\n    if(!first_expr) first_expr = &expr_arg;\\n    else if(!second_expr) second_expr = &expr_arg;\\n}\\n\\ninline int AddExpr::compute() noexcept\\n{\\n    assert(complete());\\n    return first_expr->compute() + second_expr->compute();\\n}\\n\\ninline int MultExpr::compute() noexcept\\n{\\n    assert(complete());\\n    return first_expr->compute() * second_expr->compute();\\n}\\n\\n// The boring part - is a quick rough impl - surely could be improved\\ninline std::tuple<std::string_view, std::size_t, bool> next_token(std::string_view buff)\\n{\\n    int start_index = 0;\\n    auto consumed = 0ul;\\n    for(auto ch: buff)\\n    {\\n        assert(ch != \\')\\');\\n        if(ch != \\' \\' && ch != \\'(\\') break;\\n        ++consumed;\\n        ++start_index;\\n    }\\n    buff.remove_prefix(start_index);\\n    \\n    int end_index = 0;\\n    bool end_of_expr = false;\\n    for(auto ch: buff)\\n    {\\n        ++consumed;\\n        if(ch == \\' \\') break;\\n        if(ch == \\')\\')\\n        {\\n            end_of_expr = true;\\n            break;\\n        }\\n        ++end_index;\\n    }\\n    \\n    for(auto ch : buff.substr(end_index + 1))\\n    {\\n        if(ch != \\' \\' && ch != \\')\\') break;\\n        ++consumed;\\n    }  \\n    buff.remove_suffix(buff.size() - end_index);\\n    \\n    return {buff, consumed, end_of_expr};\\n}\\n\\ninline std::tuple<int, bool> integer(std::string_view token) noexcept\\n{\\n    int result;\\n    auto [ptr, ec] = std::from_chars(token.begin(), token.end(), result);\\n    if(ptr == token.end() && (ec == std::errc()))\\n    {\\n        return {result, true};\\n    }\\n    return {result, false};\\n}\\n\\nusing Variables = std::unordered_map<std::string_view, VariableRef>;\\nVariableRef find_var(std::string_view var_name, std::vector<Variables>& vars_by_scope)\\n{\\n    using namespace std::string_view_literals;\\n    static Variable temp(\"\"sv);\\n    for(auto r_iter=vars_by_scope.rbegin(); r_iter != vars_by_scope.rend(); ++r_iter)\\n    {\\n        if(auto iter = r_iter->find(var_name);\\n           iter != r_iter->end() && iter->second.complete())\\n        {\\n            return iter->second;\\n        }\\n    }\\n    assert(false && \"always a valid reference as per the question\");\\n    return VariableRef(temp);\\n}\\n\\nvoid eval_stack(std::stack<Expression*>& parse_stack, std::vector<Variables>& vars_by_scope)\\n{\\n    while((parse_stack.size() > 1) && parse_stack.top()->complete()) // complete() == true means we can now hand it over the expression before it\\n    {\\n        auto* expr = parse_stack.top();\\n        if(std::holds_alternative<LetExpr>(expr->expr))\\n        {\\n            vars_by_scope.pop_back();\\n        }\\n        else if(std::holds_alternative<Variable>(expr->expr))\\n        {\\n            auto& var = std::get<Variable>(expr->expr);\\n            vars_by_scope.back().erase(var.name); // (let x 3 x 2 x) -> we need the second \\'x\\'.\\n            vars_by_scope.back().emplace(var.name, var);\\n        }\\n        parse_stack.pop();\\n        parse_stack.top()->add(*expr);\\n    }\\n}\\n\\nint parse(std::string_view buff)\\n{\\n     std::deque<Expression>  expressions; // the container to hold every expression in heap\\n\\t std::stack<Expression*> parse_stack; // evaluation stack\\n     std::vector<Variables>  vars_by_scope;\\n    \\n    while(!buff.empty())\\n    {\\n        auto [token, consumed, eoe] = next_token(buff); // eoe = end of expression\\n\\t\\t\\n        using namespace std::string_view_literals;\\n        if(token == \"let\"sv)\\n        {\\n            expressions.emplace_back(LetExpr{});\\n            vars_by_scope.emplace_back(Variables{}); // create a new scope\\n        }\\n        else if(token == \"mult\"sv)\\n        {\\n            expressions.emplace_back(MultExpr{});\\n        }\\n        else if(token == \"add\"sv)\\n        {\\n            expressions.emplace_back(AddExpr{});\\n        }\\n        else if(auto [int_val, is_int] = integer(token);\\n                is_int)\\n        {\\n            expressions.emplace_back(Integer{int_val});\\n        }\\n        else if(std::holds_alternative<LetExpr>(parse_stack.top()->expr) && !eoe) // Variable Initialization\\n        {\\n            expressions.emplace_back(Variable{token});\\n        }\\n        else // VariableRef\\n        {\\n            expressions.emplace_back(find_var(token, vars_by_scope));\\n        }\\n        parse_stack.emplace(&(expressions.back()));\\n        eval_stack(parse_stack, vars_by_scope);\\n        buff.remove_prefix(consumed);\\n    }\\n    assert(parse_stack.size() == 1);\\n    return parse_stack.top()->compute();\\n}\\n\\n}\\n\\nclass Solution {\\npublic:\\n    int evaluate(string expression)\\n    {\\n        // Actual implementation just refers to the original\\n        // string. It never makes a copy of even a substring\\n        // or a token. That\\'s why the space usage is so low.\\n        // This also means no unnecessary string allocations\\n        // on heap.\\n        //\\n        // Even though the implementation looks long, it\\'s\\n        // extremely light and fast with no hacks -\\n        // 100 percentile perf and memory.\\n        //\\n        // It demonstrates the power of zero cost abstractions\\n        // in modern C++. Of course there is plenty of room for improvements.\\n        //\\n        // Both the evaluation stack and container holding\\n        // expressions/results are on heap.\\n        // There is no risk of stack overflows no matter the\\n        // length of input expression.\\n        return lisp::parse(std::string_view(expression));    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1856126,
                "title": "parse-list-expr-runs-faster",
                "content": "```\\nobject Solution {\\n  def evaluate(expression: String): Int = {\\n    Expression(expression).evaluate()\\n  }\\n}\\ntrait Expression {\\n  def evaluate(context: Map[Expression, Expression] = Map()): Int\\n}\\n\\nsealed case class Const(num: Int) extends Expression {\\n  override def evaluate(context: Map[Expression, Expression] = Map()): Int = num\\n}\\n\\nsealed case class Vari(name: String) extends Expression {\\n  override def evaluate(context: Map[Expression, Expression] = Map()): Int = context(Vari(name)).evaluate()\\n}\\n\\nsealed case class Mul(left: Expression, right: Expression) extends Expression {\\n  override def evaluate(context: Map[Expression, Expression] = Map()): Int = left.evaluate(context) * right.evaluate(context)\\n}\\n\\nsealed case class Add(left: Expression, right: Expression) extends Expression {\\n  override def evaluate(context: Map[Expression, Expression] = Map()): Int = left.evaluate(context) + right.evaluate(context)\\n}\\n\\nsealed case class Let(context: List[(Expression, Expression)], expr: Expression) extends Expression {\\n  override def evaluate(contextNew: Map[Expression, Expression] = Map()): Int = {\\n    def loop(con: List[(Expression, Expression)], acc: Map[Expression, Expression] = Map()): Map[Expression, Expression] = con match {\\n      case a :: tail => loop(tail, acc + (a._1 -> Const(a._2.evaluate(contextNew ++ acc))))\\n      case Nil => acc\\n    }\\n    expr.evaluate(contextNew ++ loop(context))\\n  }\\n}\\nobject Expression {\\n  def apply(expression: String): Expression = expression match {\\n    case _ if expression.startsWith(\"(let\") => Let(expression)\\n    case _ if expression.startsWith(\"(mul\") => Mul(expression)\\n    case _ if expression.startsWith(\"(add\") => Add(expression)\\n    case _ => scala.util.Try(Const.apply(expression).asInstanceOf[Expression]).orElse(scala.util.Try(Vari.apply(expression))).get\\n  }\\n\\n  def parse(chars: String, index: Int = 0, valu: String, acc: List[Expression]): List[Expression] = {\\n    if (index == chars.length) return (if (valu.trim.isEmpty) acc else Expression.apply(valu) :: acc).reverse\\n    chars(index) match {\\n      case \\'(\\' =>\\n        val endIndex = Util.getMatching(chars, index) + 1\\n        parse(chars, endIndex, \"\", Expression.apply(chars.substring(index, endIndex)) :: acc)\\n      case \\' \\' =>\\n        parse(chars, index + 1, \"\", if (valu.trim.nonEmpty) Expression.apply(valu) :: acc else acc)\\n      case a => parse(chars, index + 1, valu + a, acc)\\n    }\\n  }\\n}\\n\\nobject Const {\\n  def apply(expr: String): Const = {Const(expr.toInt)}\\n}\\n\\nobject Add {\\n  def apply(expression: String): Expression = {\\n    val str = expression.substring(expression.indexOf(\\'(\\') + 1, expression.lastIndexOf(\\')\\')).trim\\n    val strCont = str.replaceFirst(\"add\", \"\").trim\\n    val comp = Expression.parse(strCont, 0, \"\", Nil)\\n    Add(comp.head, comp(1))\\n  }\\n}\\n\\nobject Mul {\\n  def apply(expression: String): Expression = {\\n    val str = expression.substring(expression.indexOf(\\'(\\') + 1, expression.lastIndexOf(\\')\\')).trim\\n    val strCont = str.replaceFirst(\"mult\", \"\").trim\\n    val comp = Expression.parse(strCont, 0, \"\", Nil)\\n    Mul(comp.head, comp(1))\\n  }\\n}\\n\\nobject Let {\\n  def apply(expression: String): Expression = {\\n    val str = expression.substring(expression.indexOf(\\'(\\') + 1, expression.lastIndexOf(\\')\\')).trim\\n    val strCont = str.replaceFirst(\"let\", \"\").trim\\n    val comp = Expression.parse(strCont, 0, \"\", Nil)\\n    val cont = (for (ind <- 0 until comp.length / 2) yield {\\n      comp(ind * 2) -> comp(ind * 2 + 1)\\n    }).toList\\n    var map = Map[Expression, Expression]()\\n    for (each <- cont) {\\n      map = map + (each._1 -> each._2)\\n    }\\n    Let(cont, comp.last)\\n  }\\n}\\nobject Util {\\n  def getMatching(expression: String, index: Int): Int = {\\n    val parenthesis = Array.fill(expression.length)(-1)\\n    var count = 0\\n    for (index <- 0 until expression.length) {\\n      expression.charAt(index) match {\\n        case \\'(\\' => count = count + 1; parenthesis(index) = count\\n        case \\')\\' => parenthesis(index) = count; count = count - 1\\n        case _ =>\\n      }\\n    }\\n    val some = for {\\n      indexNode <- parenthesis.zipWithIndex.find(a => a._2 == index)\\n    } yield parenthesis.zipWithIndex.filter(a => a._1 == indexNode._1 && a._2 >= index).map(_._2)\\n    some match {\\n      case Some(nums) => nums.sorted.apply(1)\\n      case None => -1\\n    }\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def evaluate(expression: String): Int = {\\n    Expression(expression).evaluate()\\n  }\\n}\\ntrait Expression {\\n  def evaluate(context: Map[Expression, Expression] = Map()): Int\\n}\\n\\nsealed case class Const(num: Int) extends Expression {\\n  override def evaluate(context: Map[Expression, Expression] = Map()): Int = num\\n}\\n\\nsealed case class Vari(name: String) extends Expression {\\n  override def evaluate(context: Map[Expression, Expression] = Map()): Int = context(Vari(name)).evaluate()\\n}\\n\\nsealed case class Mul(left: Expression, right: Expression) extends Expression {\\n  override def evaluate(context: Map[Expression, Expression] = Map()): Int = left.evaluate(context) * right.evaluate(context)\\n}\\n\\nsealed case class Add(left: Expression, right: Expression) extends Expression {\\n  override def evaluate(context: Map[Expression, Expression] = Map()): Int = left.evaluate(context) + right.evaluate(context)\\n}\\n\\nsealed case class Let(context: List[(Expression, Expression)], expr: Expression) extends Expression {\\n  override def evaluate(contextNew: Map[Expression, Expression] = Map()): Int = {\\n    def loop(con: List[(Expression, Expression)], acc: Map[Expression, Expression] = Map()): Map[Expression, Expression] = con match {\\n      case a :: tail => loop(tail, acc + (a._1 -> Const(a._2.evaluate(contextNew ++ acc))))\\n      case Nil => acc\\n    }\\n    expr.evaluate(contextNew ++ loop(context))\\n  }\\n}\\nobject Expression {\\n  def apply(expression: String): Expression = expression match {\\n    case _ if expression.startsWith(\"(let\") => Let(expression)\\n    case _ if expression.startsWith(\"(mul\") => Mul(expression)\\n    case _ if expression.startsWith(\"(add\") => Add(expression)\\n    case _ => scala.util.Try(Const.apply(expression).asInstanceOf[Expression]).orElse(scala.util.Try(Vari.apply(expression))).get\\n  }\\n\\n  def parse(chars: String, index: Int = 0, valu: String, acc: List[Expression]): List[Expression] = {\\n    if (index == chars.length) return (if (valu.trim.isEmpty) acc else Expression.apply(valu) :: acc).reverse\\n    chars(index) match {\\n      case \\'(\\' =>\\n        val endIndex = Util.getMatching(chars, index) + 1\\n        parse(chars, endIndex, \"\", Expression.apply(chars.substring(index, endIndex)) :: acc)\\n      case \\' \\' =>\\n        parse(chars, index + 1, \"\", if (valu.trim.nonEmpty) Expression.apply(valu) :: acc else acc)\\n      case a => parse(chars, index + 1, valu + a, acc)\\n    }\\n  }\\n}\\n\\nobject Const {\\n  def apply(expr: String): Const = {Const(expr.toInt)}\\n}\\n\\nobject Add {\\n  def apply(expression: String): Expression = {\\n    val str = expression.substring(expression.indexOf(\\'(\\') + 1, expression.lastIndexOf(\\')\\')).trim\\n    val strCont = str.replaceFirst(\"add\", \"\").trim\\n    val comp = Expression.parse(strCont, 0, \"\", Nil)\\n    Add(comp.head, comp(1))\\n  }\\n}\\n\\nobject Mul {\\n  def apply(expression: String): Expression = {\\n    val str = expression.substring(expression.indexOf(\\'(\\') + 1, expression.lastIndexOf(\\')\\')).trim\\n    val strCont = str.replaceFirst(\"mult\", \"\").trim\\n    val comp = Expression.parse(strCont, 0, \"\", Nil)\\n    Mul(comp.head, comp(1))\\n  }\\n}\\n\\nobject Let {\\n  def apply(expression: String): Expression = {\\n    val str = expression.substring(expression.indexOf(\\'(\\') + 1, expression.lastIndexOf(\\')\\')).trim\\n    val strCont = str.replaceFirst(\"let\", \"\").trim\\n    val comp = Expression.parse(strCont, 0, \"\", Nil)\\n    val cont = (for (ind <- 0 until comp.length / 2) yield {\\n      comp(ind * 2) -> comp(ind * 2 + 1)\\n    }).toList\\n    var map = Map[Expression, Expression]()\\n    for (each <- cont) {\\n      map = map + (each._1 -> each._2)\\n    }\\n    Let(cont, comp.last)\\n  }\\n}\\nobject Util {\\n  def getMatching(expression: String, index: Int): Int = {\\n    val parenthesis = Array.fill(expression.length)(-1)\\n    var count = 0\\n    for (index <- 0 until expression.length) {\\n      expression.charAt(index) match {\\n        case \\'(\\' => count = count + 1; parenthesis(index) = count\\n        case \\')\\' => parenthesis(index) = count; count = count - 1\\n        case _ =>\\n      }\\n    }\\n    val some = for {\\n      indexNode <- parenthesis.zipWithIndex.find(a => a._2 == index)\\n    } yield parenthesis.zipWithIndex.filter(a => a._1 == indexNode._1 && a._2 >= index).map(_._2)\\n    some match {\\n      case Some(nums) => nums.sorted.apply(1)\\n      case None => -1\\n    }\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1731712,
                "title": "clean-and-simple-java-solution-with-common-position-cursor",
                "content": "Idea is to recur on every paranthesis opening and end that when we have matching closing paranthesis, every expression in between would do this recursively.\\n\\n```\\nclass Solution {\\n    int pos = 0;\\n    public int evaluate(String expression) {\\n        // adding space for splitting\\n        expression = expression.replace(\")\",\" )\");\\n        expression = expression.replace(\"(\",\"( \");\\n        return evaluate(expression.split(\" \"), new HashMap<>());\\n    }\\n    \\n    public int evaluate(String[] expressionTokens, Map<String, Integer> varMap) {\\n        int val = 0;\\n        while(pos < expressionTokens.length) {\\n            String currToken = expressionTokens[pos++];\\n            switch(currToken){\\n                case \"let\" :\\n                    do {\\n                        String varName = expressionTokens[pos++];\\n                        varMap.put(varName, evaluate(expressionTokens, varMap));\\n                    } while(pos < expressionTokens.length - 2\\n                            && !expressionTokens[pos].equals(\"(\")\\n                            && !expressionTokens[pos+1].equals(\")\")\\n                    );\\n                    break;\\n                case \"(\" :\\n                    val += evaluate(expressionTokens, new HashMap<>(varMap));\\n                    break;\\n                case \")\" :\\n                    return val;\\n                case \"mult\" :\\n                    return evaluate(expressionTokens, new HashMap<>(varMap)) * evaluate(expressionTokens, new HashMap<>(varMap));\\n                case \"add\" :\\n                    return evaluate(expressionTokens, new HashMap<>(varMap)) + evaluate(expressionTokens, new HashMap<>(varMap));\\n                default :\\n                    try {\\n                        return Integer.parseInt(currToken);\\n                    } catch(Exception e) {\\n                        return varMap.get(currToken);\\n                }\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int pos = 0;\\n    public int evaluate(String expression) {\\n        // adding space for splitting\\n        expression = expression.replace(\")\",\" )\");\\n        expression = expression.replace(\"(\",\"( \");\\n        return evaluate(expression.split(\" \"), new HashMap<>());\\n    }\\n    \\n    public int evaluate(String[] expressionTokens, Map<String, Integer> varMap) {\\n        int val = 0;\\n        while(pos < expressionTokens.length) {\\n            String currToken = expressionTokens[pos++];\\n            switch(currToken){\\n                case \"let\" :\\n                    do {\\n                        String varName = expressionTokens[pos++];\\n                        varMap.put(varName, evaluate(expressionTokens, varMap));\\n                    } while(pos < expressionTokens.length - 2\\n                            && !expressionTokens[pos].equals(\"(\")\\n                            && !expressionTokens[pos+1].equals(\")\")\\n                    );\\n                    break;\\n                case \"(\" :\\n                    val += evaluate(expressionTokens, new HashMap<>(varMap));\\n                    break;\\n                case \")\" :\\n                    return val;\\n                case \"mult\" :\\n                    return evaluate(expressionTokens, new HashMap<>(varMap)) * evaluate(expressionTokens, new HashMap<>(varMap));\\n                case \"add\" :\\n                    return evaluate(expressionTokens, new HashMap<>(varMap)) + evaluate(expressionTokens, new HashMap<>(varMap));\\n                default :\\n                    try {\\n                        return Integer.parseInt(currToken);\\n                    } catch(Exception e) {\\n                        return varMap.get(currToken);\\n                }\\n            }\\n        }\\n        return val;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1492834,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    int evaluate(string expression){\\n        map<string, int> valMap;\\n        return evaluateHelper(expression, valMap);\\n    }\\n            \\n    int evaluateHelper(string expression, map<string, int> valMap) {\\n        if(expression.find(\\'(\\')==string::npos){\\n            if(isDigit(expression[0])){\\n                return stoi(expression);\\n            }\\n            return valMap[expression];\\n        }\\n        \\n        map<int, int> rightParent;\\n        stack<int> stk;\\n        for(int i=0; i<expression.size(); i++){\\n            if(expression[i]==\\'(\\'){\\n                stk.push(i);\\n            }\\n            else if(expression[i]==\\')\\'){\\n                int j = stk.top();\\n                stk.pop();\\n                rightParent[j] = i;\\n            }\\n        }\\n        \\n        string oper = expression.substr(1, 3);\\n        if(oper == \"let\"){\\n            int start = 5;\\n            \\n            while(true){\\n                string variable = findExpression(expression, start, rightParent);\\n                if(expression[start+variable.size()]==\\')\\')break;\\n                \\n                start += variable.size()+1;\\n                string exp = findExpression(expression, start, rightParent);\\n                int val = evaluateHelper(exp, valMap);\\n                valMap[variable] = val;\\n                cout << \"var: \"<<variable <<\",val: \"<<val<<endl;\\n            }\\n                       \\n            string expr = expression.substr(start, expression.size()-1-start);\\n            cout <<\"expr: \"<<expr<<endl;\\n            return evaluateHelper(expr, valMap);           \\n        }\\n        else if (oper == \"add\"){\\n            int start = 5;\\n            \\n            string e1 = findExpression(expression, start, rightParent);            \\n            start += e1.size()+1;            \\n            string e2 = findExpression(expression, start, rightParent);\\n            cout <<\"add expr1: \"<<e1<<\",expr2: \"<<e2<<endl;\\n            return evaluateHelper(e1, valMap)+evaluateHelper(e2, valMap);\\n        }\\n        else{\\n            int start = 6;\\n            string e1 = findExpression(expression, start, rightParent);          \\n            start += e1.size()+1;           \\n            string e2 = findExpression(expression, start, rightParent);\\n            cout <<\"mult expr1: \"<<e1<<\",expr2: \"<<e2<<endl;\\n            return evaluateHelper(e1, valMap)*evaluateHelper(e2, valMap);\\n        }\\n        \\n        return 0;\\n    }\\n    string findExpression(string expression, int start, map<int, int>& mp){\\n        int end1;\\n        if(expression[start]==\\'(\\'){\\n            end1 = mp[start]+1;\\n        }\\n        else{\\n            end1 = expression.find(\\' \\', start);\\n            int end2 = expression.find(\\')\\', start);\\n            if(end1 == string::npos||end1>end2){\\n                end1 = expression.find(\\')\\', start);\\n            }\\n        }\\n        return expression.substr(start, end1-start);\\n            \\n    }\\n    bool isDigit(char c){\\n        return (c>=\\'0\\' && c<=\\'9\\') || c==\\'-\\';\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int evaluate(string expression){\\n        map<string, int> valMap;\\n        return evaluateHelper(expression, valMap);\\n    }\\n            \\n    int evaluateHelper(string expression, map<string, int> valMap) {\\n        if(expression.find(\\'(\\')==string::npos){\\n            if(isDigit(expression[0])){\\n                return stoi(expression);\\n            }\\n            return valMap[expression];\\n        }\\n        \\n        map<int, int> rightParent;\\n        stack<int> stk;\\n        for(int i=0; i<expression.size(); i++){\\n            if(expression[i]==\\'(\\'){\\n                stk.push(i);\\n            }\\n            else if(expression[i]==\\')\\'){\\n                int j = stk.top();\\n                stk.pop();\\n                rightParent[j] = i;\\n            }\\n        }\\n        \\n        string oper = expression.substr(1, 3);\\n        if(oper == \"let\"){\\n            int start = 5;\\n            \\n            while(true){\\n                string variable = findExpression(expression, start, rightParent);\\n                if(expression[start+variable.size()]==\\')\\')break;\\n                \\n                start += variable.size()+1;\\n                string exp = findExpression(expression, start, rightParent);\\n                int val = evaluateHelper(exp, valMap);\\n                valMap[variable] = val;\\n                cout << \"var: \"<<variable <<\",val: \"<<val<<endl;\\n            }\\n                       \\n            string expr = expression.substr(start, expression.size()-1-start);\\n            cout <<\"expr: \"<<expr<<endl;\\n            return evaluateHelper(expr, valMap);           \\n        }\\n        else if (oper == \"add\"){\\n            int start = 5;\\n            \\n            string e1 = findExpression(expression, start, rightParent);            \\n            start += e1.size()+1;            \\n            string e2 = findExpression(expression, start, rightParent);\\n            cout <<\"add expr1: \"<<e1<<\",expr2: \"<<e2<<endl;\\n            return evaluateHelper(e1, valMap)+evaluateHelper(e2, valMap);\\n        }\\n        else{\\n            int start = 6;\\n            string e1 = findExpression(expression, start, rightParent);          \\n            start += e1.size()+1;           \\n            string e2 = findExpression(expression, start, rightParent);\\n            cout <<\"mult expr1: \"<<e1<<\",expr2: \"<<e2<<endl;\\n            return evaluateHelper(e1, valMap)*evaluateHelper(e2, valMap);\\n        }\\n        \\n        return 0;\\n    }\\n    string findExpression(string expression, int start, map<int, int>& mp){\\n        int end1;\\n        if(expression[start]==\\'(\\'){\\n            end1 = mp[start]+1;\\n        }\\n        else{\\n            end1 = expression.find(\\' \\', start);\\n            int end2 = expression.find(\\')\\', start);\\n            if(end1 == string::npos||end1>end2){\\n                end1 = expression.find(\\')\\', start);\\n            }\\n        }\\n        return expression.substr(start, end1-start);\\n            \\n    }\\n    bool isDigit(char c){\\n        return (c>=\\'0\\' && c<=\\'9\\') || c==\\'-\\';\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1319527,
                "title": "python3-recursive-parsing",
                "content": "I think the complex part is in the `expSplitter` function. You can try to use debugger or just print it out to see what\\'s happening there.\\n\\n```python\\n# https://leetcode.com/problems/parse-lisp-expression/\\n\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        self.variables = {}\\n\\n        # Parse Operator\\n        def expParser(expression) -> int:\\n            if expression[0] == \\'(\\':\\n                exp = expSplitter(expression)\\n            else:\\n                return self.variables[expression][-1] if expression in self.variables and len(self.variables[expression]) > 0 else int(expression)\\n\\n            if exp[1] == \\'let\\':\\n                return evalLetExp(exp)\\n            elif exp[1] == \\'add\\':\\n                return evalAddExp(exp)\\n            elif exp[1] == \\'mult\\':\\n                return evalMultExp(exp)\\n\\n        # Split Expression to Syntax List\\n        def expSplitter(expression) -> list:\\n            result = [\\'(\\']\\n            countParentheses = 0\\n            startIndex = 1\\n            for index in range(4, len(expression)):\\n                if expression[index] == \\'(\\':\\n                    countParentheses += 1\\n                elif expression[index] == \\' \\' and countParentheses == 0:\\n                    result.append(expression[startIndex:index])\\n                    startIndex = index + 1\\n                elif expression[index] == \\')\\':\\n                    countParentheses -= 1\\n            result.append(expression[startIndex:-1])\\n            result.append(\\')\\')\\n            return result\\n\\n        def evalLetExp(expression) -> int:\\n            # Push Variable Definition\\n            for index in range(2, len(expression) - 3, 2):\\n                if expression[index] not in self.variables:\\n                    self.variables[expression[index]] = []\\n                self.variables[expression[index]].append(expParser(expression[index + 1]))\\n\\n            result = expParser(expression[-2])\\n\\n            # Pop Variable Definition\\n            for index in range(2, len(expression) - 3, 2):\\n                self.variables[expression[index]].pop()\\n\\n            return result\\n\\n        def evalAddExp(expression) -> int:\\n            param1 = expParser(expression[2])\\n            param2 = expParser(expression[3])\\n            return param1 + param2\\n\\n        def evalMultExp(expression) -> str:\\n            param1 = expParser(expression[2])\\n            param2 = expParser(expression[3])\\n            return param1 * param2\\n\\n        return expParser(expression)\\n```",
                "solutionTags": [],
                "code": "```python\\n# https://leetcode.com/problems/parse-lisp-expression/\\n\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        self.variables = {}\\n\\n        # Parse Operator\\n        def expParser(expression) -> int:\\n            if expression[0] == \\'(\\':\\n                exp = expSplitter(expression)\\n            else:\\n                return self.variables[expression][-1] if expression in self.variables and len(self.variables[expression]) > 0 else int(expression)\\n\\n            if exp[1] == \\'let\\':\\n                return evalLetExp(exp)\\n            elif exp[1] == \\'add\\':\\n                return evalAddExp(exp)\\n            elif exp[1] == \\'mult\\':\\n                return evalMultExp(exp)\\n\\n        # Split Expression to Syntax List\\n        def expSplitter(expression) -> list:\\n            result = [\\'(\\']\\n            countParentheses = 0\\n            startIndex = 1\\n            for index in range(4, len(expression)):\\n                if expression[index] == \\'(\\':\\n                    countParentheses += 1\\n                elif expression[index] == \\' \\' and countParentheses == 0:\\n                    result.append(expression[startIndex:index])\\n                    startIndex = index + 1\\n                elif expression[index] == \\')\\':\\n                    countParentheses -= 1\\n            result.append(expression[startIndex:-1])\\n            result.append(\\')\\')\\n            return result\\n\\n        def evalLetExp(expression) -> int:\\n            # Push Variable Definition\\n            for index in range(2, len(expression) - 3, 2):\\n                if expression[index] not in self.variables:\\n                    self.variables[expression[index]] = []\\n                self.variables[expression[index]].append(expParser(expression[index + 1]))\\n\\n            result = expParser(expression[-2])\\n\\n            # Pop Variable Definition\\n            for index in range(2, len(expression) - 3, 2):\\n                self.variables[expression[index]].pop()\\n\\n            return result\\n\\n        def evalAddExp(expression) -> int:\\n            param1 = expParser(expression[2])\\n            param2 = expParser(expression[3])\\n            return param1 + param2\\n\\n        def evalMultExp(expression) -> str:\\n            param1 = expParser(expression[2])\\n            param2 = expParser(expression[3])\\n            return param1 * param2\\n\\n        return expParser(expression)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158947,
                "title": "javascript-solution",
                "content": "recursion method: \\n```\\nvar evaluate = function(expression) {\\n    let map = {};\\n    return helper(expression, map);\\n};\\n\\nvar helper = function(expression, map) {\\n    if(isNumber(expression)) {\\n        return parseInt(expression);\\n    }else if(isVariable(expression)) {\\n        return map[expression];\\n    }\\n    \\n    let res = 0;\\n    let list = parse(expression); // parse expression into array\\n   \\n    if(list[0] === \\'add\\') { // add expression\\n        res = helper(list[1], map) + helper(list[2], map);\\n    } \\n    else if(list[0] === \\'mult\\') { // mult expression\\n        res = helper(list[1], map) * helper(list[2], map);\\n    }\\n    else { // let expression\\n        let newMap = JSON.parse(JSON.stringify(map)); // deep copy map into newMap\\n        for(let i = 1; i < list.length-1; i += 2) { // save all variables into newMap\\n            newMap[list[i]] = helper(list[i+1], newMap); \\n        }\\n        \\n        res = helper(list[list.length-1], newMap);\\n    }\\n    \\n    return res;\\n}\\n\\nvar isNumber = function(expression) {\\n    let c = expression.charAt(0);\\n    return c >= \\'0\\' && c <= \\'9\\' || c === \\'-\\';\\n}\\n\\nvar isVariable = function(expression) {\\n    let c = expression.charAt(0);\\n    return c >= \\'a\\' && c <= \\'z\\';\\n}\\n\\nvar parse = function(expression) {\\n    const array = [];\\n    expression = expression.substring(1, expression.length-1);\\n    let startIdx = 0;\\n    while(startIdx < expression.length) {\\n        let endIdx = next(expression, startIdx);\\n        array.push(expression.substring(startIdx, endIdx));\\n        \\n        startIdx = endIdx + 1;\\n    }\\n    \\n    return array;\\n}\\n\\nvar next = function(expression, startIdx) {\\n     let index = startIdx;\\n     \\n    if(expression.charAt(index) === \\'(\\') {\\n        let count = 1;\\n        index++;\\n        while(index < expression.length && count > 0) {\\n            if(expression.charAt(index) === \\'(\\') {\\n                count++;\\n            }else if(expression.charAt(index) === \\')\\') {\\n                count--;\\n            }\\n            \\n            index++;\\n        }\\n    }else {\\n        while(index < expression.length && expression.charAt(index) !== \\' \\') {\\n            index++;\\n        }\\n    }\\n    return index;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar evaluate = function(expression) {\\n    let map = {};\\n    return helper(expression, map);\\n};\\n\\nvar helper = function(expression, map) {\\n    if(isNumber(expression)) {\\n        return parseInt(expression);\\n    }else if(isVariable(expression)) {\\n        return map[expression];\\n    }\\n    \\n    let res = 0;\\n    let list = parse(expression); // parse expression into array\\n   \\n    if(list[0] === \\'add\\') { // add expression\\n        res = helper(list[1], map) + helper(list[2], map);\\n    } \\n    else if(list[0] === \\'mult\\') { // mult expression\\n        res = helper(list[1], map) * helper(list[2], map);\\n    }\\n    else { // let expression\\n        let newMap = JSON.parse(JSON.stringify(map)); // deep copy map into newMap\\n        for(let i = 1; i < list.length-1; i += 2) { // save all variables into newMap\\n            newMap[list[i]] = helper(list[i+1], newMap); \\n        }\\n        \\n        res = helper(list[list.length-1], newMap);\\n    }\\n    \\n    return res;\\n}\\n\\nvar isNumber = function(expression) {\\n    let c = expression.charAt(0);\\n    return c >= \\'0\\' && c <= \\'9\\' || c === \\'-\\';\\n}\\n\\nvar isVariable = function(expression) {\\n    let c = expression.charAt(0);\\n    return c >= \\'a\\' && c <= \\'z\\';\\n}\\n\\nvar parse = function(expression) {\\n    const array = [];\\n    expression = expression.substring(1, expression.length-1);\\n    let startIdx = 0;\\n    while(startIdx < expression.length) {\\n        let endIdx = next(expression, startIdx);\\n        array.push(expression.substring(startIdx, endIdx));\\n        \\n        startIdx = endIdx + 1;\\n    }\\n    \\n    return array;\\n}\\n\\nvar next = function(expression, startIdx) {\\n     let index = startIdx;\\n     \\n    if(expression.charAt(index) === \\'(\\') {\\n        let count = 1;\\n        index++;\\n        while(index < expression.length && count > 0) {\\n            if(expression.charAt(index) === \\'(\\') {\\n                count++;\\n            }else if(expression.charAt(index) === \\')\\') {\\n                count--;\\n            }\\n            \\n            index++;\\n        }\\n    }else {\\n        while(index < expression.length && expression.charAt(index) !== \\' \\') {\\n            index++;\\n        }\\n    }\\n    return index;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1094415,
                "title": "java-solution-with-comment-explanation",
                "content": "```\\nclass Solution {\\n    public int evaluate(String expression) {\\n        return eval(expression, new HashMap<>());\\n    }\\n    \\n    public int eval(String expression, Map<String, Integer> map){\\n        //check for Number - positive or negative\\n        if (isNumber(expression)) return Integer.valueOf(expression);\\n        //check if this is a variable\\n        if (isVariable(expression)) return map.get(expression);\\n        \\n        //result\\n        int res = 0;\\n        //tokens list\\n        List<String> list = parse(expression);\\n        //if the operation is add, then add by recursive call to first operand and second operand\\n        if (list.get(0).equals(\"add\")) res = eval(list.get(1), map) + eval(list.get(2), map);\\n        //if the operation is mult, then add by recursive call to first operand and second operand\\n        else if(list.get(0).equals(\"mult\")) res = eval(list.get(1), map) * eval(list.get(2), map);\\n        //let operation\\n        else{\\n            //we need new set of map to store the variables in this scope\\n            //extend on top of existing map\\n            Map<String, Integer> newMap = new HashMap<>();\\n            newMap.putAll(map);\\n            //loop thorugh 1 and length-1 skipping paranthesis\\n            // step 2 skipping spaces\\n            for (int i = 1;i<list.size()-1;i+=2)\\n                //add the tokens and its value will be given by a recursive call\\n                newMap.put(list.get(i), eval(list.get(i+1), newMap));\\n            //the last expession recursive call\\n            res = eval(list.get(list.size()-1), newMap);\\n        }\\n        return res;\\n    }\\n    \\n    //check if first character is a digit or -\\n    public boolean isNumber(String expr){\\n        char c = expr.charAt(0);\\n        return Character.isDigit(c) || c == \\'-\\';\\n    }\\n    //if character is lower case\\n    public boolean isVariable(String expr){\\n        char c = expr.charAt(0);\\n        return Character.isLowerCase(c);\\n    }\\n    \\n    public List<String> parse(String expr){\\n        //list to hold all the tokens\\n        List<String> res = new ArrayList<>();\\n        //skip the first and last character for \\'(\\' and  \\')\\'\\'\\n        expr = expr.substring(1, expr.length() - 1);\\n        \\n        int i = 0;\\n        // strip off the tokens by iteration\\n        while (i < expr.length()){\\n            int j = find(expr, i);\\n            //add to the list\\n            res.add(expr.substring(i, j));\\n            i = j + 1;\\n        }\\n        return res;\\n    }\\n    \\n    public int find(String expr, int i){\\n        int index = i;\\n        //if the expression contains parantheses\\n        if (expr.charAt(index) == \\'(\\'){\\n            int count = 1;\\n            index++;\\n            // loop further and check if any more expressions\\n            while (index < expr.length() && count > 0){\\n                //increment and decrement based on the parantheses\\n\\t\\t\\t\\tif (expr.charAt(index) == \\'(\\') count++;\\n                else if (expr.charAt(index) == \\')\\') count--;\\n                index++;\\n            }\\n        }\\n        else \\n            // increment the index until space\\n\\t\\t\\twhile (index < expr.length() && expr.charAt(index) != \\' \\') index++;\\n        return index;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int evaluate(String expression) {\\n        return eval(expression, new HashMap<>());\\n    }\\n    \\n    public int eval(String expression, Map<String, Integer> map){\\n        //check for Number - positive or negative\\n        if (isNumber(expression)) return Integer.valueOf(expression);\\n        //check if this is a variable\\n        if (isVariable(expression)) return map.get(expression);\\n        \\n        //result\\n        int res = 0;\\n        //tokens list\\n        List<String> list = parse(expression);\\n        //if the operation is add, then add by recursive call to first operand and second operand\\n        if (list.get(0).equals(\"add\")) res = eval(list.get(1), map) + eval(list.get(2), map);\\n        //if the operation is mult, then add by recursive call to first operand and second operand\\n        else if(list.get(0).equals(\"mult\")) res = eval(list.get(1), map) * eval(list.get(2), map);\\n        //let operation\\n        else{\\n            //we need new set of map to store the variables in this scope\\n            //extend on top of existing map\\n            Map<String, Integer> newMap = new HashMap<>();\\n            newMap.putAll(map);\\n            //loop thorugh 1 and length-1 skipping paranthesis\\n            // step 2 skipping spaces\\n            for (int i = 1;i<list.size()-1;i+=2)\\n                //add the tokens and its value will be given by a recursive call\\n                newMap.put(list.get(i), eval(list.get(i+1), newMap));\\n            //the last expession recursive call\\n            res = eval(list.get(list.size()-1), newMap);\\n        }\\n        return res;\\n    }\\n    \\n    //check if first character is a digit or -\\n    public boolean isNumber(String expr){\\n        char c = expr.charAt(0);\\n        return Character.isDigit(c) || c == \\'-\\';\\n    }\\n    //if character is lower case\\n    public boolean isVariable(String expr){\\n        char c = expr.charAt(0);\\n        return Character.isLowerCase(c);\\n    }\\n    \\n    public List<String> parse(String expr){\\n        //list to hold all the tokens\\n        List<String> res = new ArrayList<>();\\n        //skip the first and last character for \\'(\\' and  \\')\\'\\'\\n        expr = expr.substring(1, expr.length() - 1);\\n        \\n        int i = 0;\\n        // strip off the tokens by iteration\\n        while (i < expr.length()){\\n            int j = find(expr, i);\\n            //add to the list\\n            res.add(expr.substring(i, j));\\n            i = j + 1;\\n        }\\n        return res;\\n    }\\n    \\n    public int find(String expr, int i){\\n        int index = i;\\n        //if the expression contains parantheses\\n        if (expr.charAt(index) == \\'(\\'){\\n            int count = 1;\\n            index++;\\n            // loop further and check if any more expressions\\n            while (index < expr.length() && count > 0){\\n                //increment and decrement based on the parantheses\\n\\t\\t\\t\\tif (expr.charAt(index) == \\'(\\') count++;\\n                else if (expr.charAt(index) == \\')\\') count--;\\n                index++;\\n            }\\n        }\\n        else \\n            // increment the index until space\\n\\t\\t\\twhile (index < expr.length() && expr.charAt(index) != \\' \\') index++;\\n        return index;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 983775,
                "title": "clean-java-solution-using-bnf",
                "content": "This solution is using the idea of BNF.\\nIt can also solve all kins of string decoding questions such as \\n[227. Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)\\n[394. Decode String](https://leetcode.com/problems/decode-string/)\\n[1597. Build Binary Expression Tree From Infix Expression](https://leetcode.com/problems/build-binary-expression-tree-from-infix-expression/)\\n[726. Number of Atoms](https://leetcode.com/problems/number-of-atoms)\\n\\nHere\\'s an explanation of the BNF expression:\\nhttps://www.youtube.com/watch?v=vdtAxiEXIBo\\n\\nHere\\'s the working code in java\\n```java\\nclass Solution {\\n\\n    //expression = integer | letExpress | addExpress | multExpress | variable\\n    //integer = [+/-] {1-9}\\n    //variable = {a-z}{1-9}{a-z}\\n    //letExpress = (let {variable expression} expr) --> hashmap.\\n    //addExpress = (add expression expression)\\n    //multExpress = (mult expression expression)\\n\\n    int i = 0;\\n    String s = null;;\\n    int n = 0;\\n    HashMap<String, Stack<Integer>> vars = new HashMap<>();\\n\\n    public int evaluate(String expression) {\\n        s = expression;\\n        n = s.length();\\n\\n        return expression();\\n    }\\n\\n    private int expression(){\\n        if (isInteger()) return integer();\\n\\n        if (s.charAt(i) == \\'(\\'){\\n            if (s.charAt(i+1) == \\'a\\')\\n                return addExpression();\\n            else if (s.charAt(i+1) == \\'m\\')\\n                return multExpression();\\n            else\\n                return letExpression();\\n        } else {\\n            return vars.get(variable()).peek();\\n        }\\n    }\\n\\n    private int letExpression(){\\n        i += 5; // consume \"(let \"\\n        List<String> assigned = new ArrayList<>(); //when out of scope remove the assignment\\n        Integer res = null;\\n        while (i<n && s.charAt(i) != \\'(\\' ){ // not last expression.\\n            if (isInteger()) { //we expect a var but it\\'s an integer, meaning it\\'s the last expr\\n                res = integer();\\n                break;\\n            }\\n\\n            String var = variable();\\n            if (s.charAt(i) == \\')\\') { //the next token is ) meaning this is the last expression.\\n                res = vars.get(var).peek();\\n                break;\\n            }\\n\\n            i++; // consume space\\n            int val = expression();\\n            assigned.add(var);\\n            vars.computeIfAbsent(var, (k)-> new Stack<>()).push(val);\\n            i++; // consume space\\n        }\\n\\n        //last expr is an expression.\\n        if (res == null)\\n            res = expression();\\n        i++; // consume \")\"\\n        for (String var:assigned){\\n            vars.get(var).pop();\\n        }\\n        return res;\\n    }\\n\\n    private int addExpression(){\\n        i += 5; // consume \"(add \"\\n        int res = expression();\\n        i++; // consume \" \"\\n        res += expression();\\n        i++; // consume \")\"\\n\\n        return res;\\n    }\\n\\n    private boolean isInteger(){\\n        return i < n && (s.charAt(i) == \\'+\\' || s.charAt(i) == \\'-\\' || Character.isDigit(s.charAt(i)));\\n    }\\n\\n    private int multExpression(){\\n        i+=6; // consume \"(mult \"\\n        int res = expression ();\\n        i++; // consume \" \"\\n        res *= expression();\\n        i++; // consume \")\"\\n\\n        return res;\\n    }\\n\\n    private int integer(){\\n        boolean isNeg = false;\\n        if (s.charAt(i) == \\'+\\') i++;\\n        if (s.charAt(i) == \\'-\\') {\\n            isNeg = true;\\n            i++;\\n        }\\n\\n        int num = 0;\\n        while (i<n && Character.isDigit(s.charAt(i))){\\n            num = num * 10 + s.charAt(i++) - \\'0\\';\\n        }\\n        return isNeg? -num : num;\\n    }\\n\\n    private String variable(){\\n        StringBuilder sb = new StringBuilder();\\n        while (i < n && Character.isAlphabetic(s.charAt(i)) ||\\n                Character.isDigit(s.charAt(i))){\\n            sb.append(s.charAt(i++));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n\\n    //expression = integer | letExpress | addExpress | multExpress | variable\\n    //integer = [+/-] {1-9}\\n    //variable = {a-z}{1-9}{a-z}\\n    //letExpress = (let {variable expression} expr) --> hashmap.\\n    //addExpress = (add expression expression)\\n    //multExpress = (mult expression expression)\\n\\n    int i = 0;\\n    String s = null;;\\n    int n = 0;\\n    HashMap<String, Stack<Integer>> vars = new HashMap<>();\\n\\n    public int evaluate(String expression) {\\n        s = expression;\\n        n = s.length();\\n\\n        return expression();\\n    }\\n\\n    private int expression(){\\n        if (isInteger()) return integer();\\n\\n        if (s.charAt(i) == \\'(\\'){\\n            if (s.charAt(i+1) == \\'a\\')\\n                return addExpression();\\n            else if (s.charAt(i+1) == \\'m\\')\\n                return multExpression();\\n            else\\n                return letExpression();\\n        } else {\\n            return vars.get(variable()).peek();\\n        }\\n    }\\n\\n    private int letExpression(){\\n        i += 5; // consume \"(let \"\\n        List<String> assigned = new ArrayList<>(); //when out of scope remove the assignment\\n        Integer res = null;\\n        while (i<n && s.charAt(i) != \\'(\\' ){ // not last expression.\\n            if (isInteger()) { //we expect a var but it\\'s an integer, meaning it\\'s the last expr\\n                res = integer();\\n                break;\\n            }\\n\\n            String var = variable();\\n            if (s.charAt(i) == \\')\\') { //the next token is ) meaning this is the last expression.\\n                res = vars.get(var).peek();\\n                break;\\n            }\\n\\n            i++; // consume space\\n            int val = expression();\\n            assigned.add(var);\\n            vars.computeIfAbsent(var, (k)-> new Stack<>()).push(val);\\n            i++; // consume space\\n        }\\n\\n        //last expr is an expression.\\n        if (res == null)\\n            res = expression();\\n        i++; // consume \")\"\\n        for (String var:assigned){\\n            vars.get(var).pop();\\n        }\\n        return res;\\n    }\\n\\n    private int addExpression(){\\n        i += 5; // consume \"(add \"\\n        int res = expression();\\n        i++; // consume \" \"\\n        res += expression();\\n        i++; // consume \")\"\\n\\n        return res;\\n    }\\n\\n    private boolean isInteger(){\\n        return i < n && (s.charAt(i) == \\'+\\' || s.charAt(i) == \\'-\\' || Character.isDigit(s.charAt(i)));\\n    }\\n\\n    private int multExpression(){\\n        i+=6; // consume \"(mult \"\\n        int res = expression ();\\n        i++; // consume \" \"\\n        res *= expression();\\n        i++; // consume \")\"\\n\\n        return res;\\n    }\\n\\n    private int integer(){\\n        boolean isNeg = false;\\n        if (s.charAt(i) == \\'+\\') i++;\\n        if (s.charAt(i) == \\'-\\') {\\n            isNeg = true;\\n            i++;\\n        }\\n\\n        int num = 0;\\n        while (i<n && Character.isDigit(s.charAt(i))){\\n            num = num * 10 + s.charAt(i++) - \\'0\\';\\n        }\\n        return isNeg? -num : num;\\n    }\\n\\n    private String variable(){\\n        StringBuilder sb = new StringBuilder();\\n        while (i < n && Character.isAlphabetic(s.charAt(i)) ||\\n                Character.isDigit(s.charAt(i))){\\n            sb.append(s.charAt(i++));\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 801614,
                "title": "c-o-n-with-stacks",
                "content": "Instead of vector<unordered_map<string,int>> scopes;\\nWe maintain unordered_map<string,stack<int>> values;\\n\\n```\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        unordered_map<string,stack<int>> values;\\n\\n        auto tokenize = [](string s) {\\n            vector<string> tokens;\\n            const int n = s.size();\\n            for (int i{0}; i < n; ++i) {\\n                if (s[i] == \\'(\\') {\\n                    tokens.push_back(\"(\");\\n                } else if (s[i] == \\')\\') {\\n                    tokens.push_back(\")\");\\n                } else if (s[i] == \\'-\\' || isdigit(s[i])) {\\n                    string t(1, s[i]);\\n                    while (i+1 < n && isdigit(s[i+1])) {\\n                        ++i;\\n                        t.push_back(s[i]);\\n                    }\\n                    tokens.push_back(t);\\n                } else if (isalpha(s[i])) { \\n                    string t(1, s[i]);\\n                    while (i+1 < n && isalnum(s[i+1])) {  \\n                        ++i;\\n                        t.push_back(s[i]);\\n                    }\\n                    tokens.push_back(t);\\n                }\\n            }\\n            return tokens;\\n        };\\n\\n        auto tokens = tokenize(expression);\\n\\n        int idx = 0;\\n        function<int()> parse = [&]() {\\n            string t = tokens[idx];\\n            if (t != \"(\") {\\n                ++idx;\\n                if (t[0] == \\'-\\' || isdigit(t[0])) {\\n                    return stoi(t);\\n                } else {\\n                    return values[t].top();\\n                }\\n            }\\n\\n            ++idx;\\n            string op = tokens[idx]; ++idx;\\n            if (op == \"add\" || op == \"mult\") {\\n                int v1 = parse(), v2 = parse();\\n                int v = op == \"add\" ? v1+v2 : v1*v2;\\n                ++idx; \\n                return v;\\n            } else {\\n                assert(op == \"let\");\\n                unordered_map<string,int> bindcnt;\\n                while (tokens[idx] != \"(\" && tokens[idx+1] != \")\") {\\n                    string name = tokens[idx++];\\n                    int val = parse();  \\n                    values[name].push(val);\\n                    bindcnt[name]++;\\n                }\\n                int val = parse();\\n                ++idx;                // consume )\\n                // rewind the stack\\n                for (auto [name, cnt] : bindcnt) {\\n                    while (cnt--) {\\n                        values[name].pop();\\n                    }\\n                    if (values[name].empty()) {\\n                        values.erase(name);\\n                    }\\n                }\\n                return val;\\n            }\\n        };\\n\\n        return parse();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        unordered_map<string,stack<int>> values;\\n\\n        auto tokenize = [](string s) {\\n            vector<string> tokens;\\n            const int n = s.size();\\n            for (int i{0}; i < n; ++i) {\\n                if (s[i] == \\'(\\') {\\n                    tokens.push_back(\"(\");\\n                } else if (s[i] == \\')\\') {\\n                    tokens.push_back(\")\");\\n                } else if (s[i] == \\'-\\' || isdigit(s[i])) {\\n                    string t(1, s[i]);\\n                    while (i+1 < n && isdigit(s[i+1])) {\\n                        ++i;\\n                        t.push_back(s[i]);\\n                    }\\n                    tokens.push_back(t);\\n                } else if (isalpha(s[i])) { \\n                    string t(1, s[i]);\\n                    while (i+1 < n && isalnum(s[i+1])) {  \\n                        ++i;\\n                        t.push_back(s[i]);\\n                    }\\n                    tokens.push_back(t);\\n                }\\n            }\\n            return tokens;\\n        };\\n\\n        auto tokens = tokenize(expression);\\n\\n        int idx = 0;\\n        function<int()> parse = [&]() {\\n            string t = tokens[idx];\\n            if (t != \"(\") {\\n                ++idx;\\n                if (t[0] == \\'-\\' || isdigit(t[0])) {\\n                    return stoi(t);\\n                } else {\\n                    return values[t].top();\\n                }\\n            }\\n\\n            ++idx;\\n            string op = tokens[idx]; ++idx;\\n            if (op == \"add\" || op == \"mult\") {\\n                int v1 = parse(), v2 = parse();\\n                int v = op == \"add\" ? v1+v2 : v1*v2;\\n                ++idx; \\n                return v;\\n            } else {\\n                assert(op == \"let\");\\n                unordered_map<string,int> bindcnt;\\n                while (tokens[idx] != \"(\" && tokens[idx+1] != \")\") {\\n                    string name = tokens[idx++];\\n                    int val = parse();  \\n                    values[name].push(val);\\n                    bindcnt[name]++;\\n                }\\n                int val = parse();\\n                ++idx;                // consume )\\n                // rewind the stack\\n                for (auto [name, cnt] : bindcnt) {\\n                    while (cnt--) {\\n                        values[name].pop();\\n                    }\\n                    if (values[name].empty()) {\\n                        values.erase(name);\\n                    }\\n                }\\n                return val;\\n            }\\n        };\\n\\n        return parse();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676037,
                "title": "java-recursion",
                "content": "ref: https://leetcode.com/problems/parse-lisp-expression/discuss/113902/A-Clean-Java-Solution\\n```\\nclass Solution {\\n    public int evaluate(String e){\\n        return evaluate(e, new HashMap<>());  // map for \"(let x 2 (add (let x 3 (let x 4 x)) x))\"\\n    }\\n    public int evaluate(String e, Map<String, Integer> map) {\\n        if (e.charAt(0) != \\'(\\') {\\n            if (Character.isDigit(e.charAt(0)) || e.charAt(0) == \\'-\\') return Integer.parseInt(e);\\n            return map.get(e);\\n        }\\n        List<String> list = parse(e);\\n        Map<String, Integer> newMap = new HashMap<>();\\n        newMap.putAll(map);\\n        if (e.charAt(1) == \\'m\\') {\\n            return evaluate(list.get(0), newMap) * evaluate(list.get(1), newMap);\\n        } else if (e.charAt(1) == \\'a\\') {\\n            return evaluate(list.get(0), newMap) + evaluate(list.get(1), newMap);\\n        } else {\\n            for (int i = 0; i < list.size() - 1; i += 2) {\\n                newMap.put(list.get(i), evaluate(list.get(i + 1), newMap));\\n            }\\n            return evaluate(list.get(list.size() - 1), newMap);\\n        }\\n    }\\n    \\n    private List<String> parse(String e) {\\n        List<String> res = new ArrayList<>();\\n        for (int i = e.indexOf(\\' \\') + 1, p = 0, last = i; i < e.length(); i++) {\\n            char c = e.charAt(i);\\n            if (c == \\')\\') p--;\\n            if (c == \\'(\\') p++;\\n            if (p == 0 && c == \\' \\' || i == e.length() - 1) {\\n                res.add(e.substring(last, i));\\n                last = i + 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int evaluate(String e){\\n        return evaluate(e, new HashMap<>());  // map for \"(let x 2 (add (let x 3 (let x 4 x)) x))\"\\n    }\\n    public int evaluate(String e, Map<String, Integer> map) {\\n        if (e.charAt(0) != \\'(\\') {\\n            if (Character.isDigit(e.charAt(0)) || e.charAt(0) == \\'-\\') return Integer.parseInt(e);\\n            return map.get(e);\\n        }\\n        List<String> list = parse(e);\\n        Map<String, Integer> newMap = new HashMap<>();\\n        newMap.putAll(map);\\n        if (e.charAt(1) == \\'m\\') {\\n            return evaluate(list.get(0), newMap) * evaluate(list.get(1), newMap);\\n        } else if (e.charAt(1) == \\'a\\') {\\n            return evaluate(list.get(0), newMap) + evaluate(list.get(1), newMap);\\n        } else {\\n            for (int i = 0; i < list.size() - 1; i += 2) {\\n                newMap.put(list.get(i), evaluate(list.get(i + 1), newMap));\\n            }\\n            return evaluate(list.get(list.size() - 1), newMap);\\n        }\\n    }\\n    \\n    private List<String> parse(String e) {\\n        List<String> res = new ArrayList<>();\\n        for (int i = e.indexOf(\\' \\') + 1, p = 0, last = i; i < e.length(); i++) {\\n            char c = e.charAt(i);\\n            if (c == \\')\\') p--;\\n            if (c == \\'(\\') p++;\\n            if (p == 0 && c == \\' \\' || i == e.length() - 1) {\\n                res.add(e.substring(last, i));\\n                last = i + 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 499966,
                "title": "go-recursive-solution",
                "content": "```\\nfunc evaluate(expression string) int {\\n\\treturn eval(expression, make(map[string]int))\\n}\\n\\nfunc eval(expr string, parent map[string]int) int {\\n\\tif expr[0] != \\'(\\' {\\n\\t\\tif expr[0] == \\'-\\' || (expr[0] >= \\'0\\' && expr[0] <= \\'9\\') {\\n\\t\\t\\tres, _ := strconv.Atoi(expr)\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\treturn parent[expr]\\n\\t}\\n\\tcache := make(map[string]int)\\n\\tfor k, v := range parent {\\n\\t\\tcache[k] = v\\n\\t}\\n\\n\\tvar tokens []string\\n\\tif expr[1] == \\'m\\' {\\n\\t\\ttokens = parse(expr[6 : len(expr)-1])\\n\\t} else {\\n\\t\\ttokens = parse(expr[5 : len(expr)-1])\\n\\t}\\n\\n\\tif strings.HasPrefix(expr, \"(a\") {\\n\\t\\treturn eval(tokens[0], cache) + eval(tokens[1], cache)\\n\\t} else if strings.HasPrefix(expr, \"(m\") {\\n\\t\\treturn eval(tokens[0], cache) * eval(tokens[1], cache)\\n\\t} else {\\n\\t\\tfor i := 0; i < len(tokens)-2; i += 2 {\\n\\t\\t\\tcache[tokens[i]] = eval(tokens[i+1], cache)\\n\\t\\t}\\n\\t\\treturn eval(tokens[len(tokens)-1], cache)\\n\\t}\\n}\\n\\nfunc parse(str string) []string {\\n\\tres := make([]string, 0)\\n\\tvar parent int\\n\\tsb := make([]byte, 0)\\n\\tfor i := range str {\\n\\t\\tif str[i] == \\'(\\' {\\n\\t\\t\\tparent++\\n\\t\\t}\\n\\t\\tif str[i] == \\')\\' {\\n\\t\\t\\tparent--\\n\\t\\t}\\n\\t\\tif parent == 0 && str[i] == \\' \\' {\\n\\t\\t\\tres = append(res, string(sb))\\n\\t\\t\\tsb = make([]byte, 0)\\n\\t\\t} else {\\n\\t\\t\\tsb = append(sb, str[i])\\n\\t\\t}\\n\\t}\\n\\tif len(sb) > 0 {\\n\\t\\tres = append(res, string(sb))\\n\\t}\\n\\treturn res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc evaluate(expression string) int {\\n\\treturn eval(expression, make(map[string]int))\\n}\\n\\nfunc eval(expr string, parent map[string]int) int {\\n\\tif expr[0] != \\'(\\' {\\n\\t\\tif expr[0] == \\'-\\' || (expr[0] >= \\'0\\' && expr[0] <= \\'9\\') {\\n\\t\\t\\tres, _ := strconv.Atoi(expr)\\n\\t\\t\\treturn res\\n\\t\\t}\\n\\t\\treturn parent[expr]\\n\\t}\\n\\tcache := make(map[string]int)\\n\\tfor k, v := range parent {\\n\\t\\tcache[k] = v\\n\\t}\\n\\n\\tvar tokens []string\\n\\tif expr[1] == \\'m\\' {\\n\\t\\ttokens = parse(expr[6 : len(expr)-1])\\n\\t} else {\\n\\t\\ttokens = parse(expr[5 : len(expr)-1])\\n\\t}\\n\\n\\tif strings.HasPrefix(expr, \"(a\") {\\n\\t\\treturn eval(tokens[0], cache) + eval(tokens[1], cache)\\n\\t} else if strings.HasPrefix(expr, \"(m\") {\\n\\t\\treturn eval(tokens[0], cache) * eval(tokens[1], cache)\\n\\t} else {\\n\\t\\tfor i := 0; i < len(tokens)-2; i += 2 {\\n\\t\\t\\tcache[tokens[i]] = eval(tokens[i+1], cache)\\n\\t\\t}\\n\\t\\treturn eval(tokens[len(tokens)-1], cache)\\n\\t}\\n}\\n\\nfunc parse(str string) []string {\\n\\tres := make([]string, 0)\\n\\tvar parent int\\n\\tsb := make([]byte, 0)\\n\\tfor i := range str {\\n\\t\\tif str[i] == \\'(\\' {\\n\\t\\t\\tparent++\\n\\t\\t}\\n\\t\\tif str[i] == \\')\\' {\\n\\t\\t\\tparent--\\n\\t\\t}\\n\\t\\tif parent == 0 && str[i] == \\' \\' {\\n\\t\\t\\tres = append(res, string(sb))\\n\\t\\t\\tsb = make([]byte, 0)\\n\\t\\t} else {\\n\\t\\t\\tsb = append(sb, str[i])\\n\\t\\t}\\n\\t}\\n\\tif len(sb) > 0 {\\n\\t\\tres = append(res, string(sb))\\n\\t}\\n\\treturn res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 491304,
                "title": "c-recursion-solution-with-string-view-to-avoid-memory-alloc-deallocs",
                "content": "Code is self explanatory and similar to what others have done. Posting it just to make people aware of string_view\\n```\\nclass Context {\\n  unordered_map<string_view, int> _map;\\n  const Context *_parent{};\\n  public:\\n  Context(const Context *parent) : _parent{parent}\\n  {\\n    ;\\n  }\\n  const Context* Parent() const { return _parent; }\\n  int GetValue(const string_view &key) const\\n  {\\n    auto it = _map.find(key);\\n    if (it != _map.end()) return it->second;\\n    if (_parent) return _parent->GetValue(key);\\n    assert(0);\\n    return numeric_limits<int>::min();\\n  }\\n  void AddValue(const string_view &key, int val) {\\n    auto [it, isInserted] = _map.emplace(key, val);\\n    if (!isInserted) it->second = val;\\n  }\\n};\\nclass Solution {\\n  string_view symbol(string_view &expr) {\\n    string_view ret;\\n    if (expr.empty() || !isalpha(expr[0])) {\\n      return ret;\\n    }\\n    auto pos = expr.find_first_of(\" )\");\\n    assert(pos != string_view::npos);\\n    ret = expr.substr(0, pos);\\n    expr.remove_prefix(pos);\\n    return ret;\\n  }\\n  int evaluate(string_view &expr, Context *context) {\\n    assert(!expr.empty());\\n    if (expr[0] == \\'(\\') {\\n      assert(expr.length() >= 4);\\n      if (expr.substr(0, 4) == \"(add\") {\\n        assert(expr.length() > 4);\\n        expr.remove_prefix(4);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int l = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int r = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\')\\');\\n        expr.remove_prefix(1);\\n        return l + r;\\n      }\\n      if (expr.substr(0, 4) == \"(mul\") {\\n        assert(expr.length() > 5);\\n        expr.remove_prefix(5);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int l = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int r = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\')\\');\\n        expr.remove_prefix(1);\\n        return l * r;\\n      }\\n      if (expr.substr(0, 4) == \"(let\") {\\n        assert(expr.length() > 4);\\n        expr.remove_prefix(4);\\n        Context nc(context);\\n        while (1) {\\n          assert(!expr.empty() && expr[0] == \\' \\');\\n          expr.remove_prefix(1);\\n          string_view sym = symbol(expr);\\n          assert(!expr.empty());\\n          if (sym.empty() || expr[0] == \\')\\') {\\n            int ret{};\\n            if (sym.empty()) {\\n              ret = evaluate(expr, &nc);\\n            } else {\\n              ret = nc.GetValue(sym);\\n            }\\n            assert(!expr.empty() && expr[0] == \\')\\');\\n            expr.remove_prefix(1);\\n            return ret;\\n          }\\n          assert(!expr.empty() && expr[0] == \\' \\');\\n          expr.remove_prefix(1);\\n          int value = evaluate(expr, &nc);\\n          nc.AddValue(sym, value);\\n        }\\n        assert(0);\\n      }\\n    } \\n    if (isdigit(expr[0]) || expr[0] == \\'-\\') {\\n      auto pos = expr.find_first_not_of(\"-0123456789\");\\n      auto len = min(expr.length(), pos);\\n      int num;\\n      if (auto [ptr, ec] = from_chars(expr.data(), expr.data()+len, num); ec == errc()) {\\n        expr.remove_prefix(len);\\n      } else {\\n        assert(0);\\n      }\\n      return num;\\n    }\\n    if (isalpha(expr[0])) {\\n      string_view sym = symbol(expr);\\n      assert(!expr.empty() && (expr[0] == \\' \\' || expr[0] == \\')\\'));\\n      return context->GetValue(sym);\\n    }\\n    assert(0);\\n    return numeric_limits<int>::min();\\n  }\\npublic:\\n    int evaluate(string expression) {\\n      string_view expr(expression);\\n      Context context(nullptr);\\n      return evaluate(expr, &context);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Context {\\n  unordered_map<string_view, int> _map;\\n  const Context *_parent{};\\n  public:\\n  Context(const Context *parent) : _parent{parent}\\n  {\\n    ;\\n  }\\n  const Context* Parent() const { return _parent; }\\n  int GetValue(const string_view &key) const\\n  {\\n    auto it = _map.find(key);\\n    if (it != _map.end()) return it->second;\\n    if (_parent) return _parent->GetValue(key);\\n    assert(0);\\n    return numeric_limits<int>::min();\\n  }\\n  void AddValue(const string_view &key, int val) {\\n    auto [it, isInserted] = _map.emplace(key, val);\\n    if (!isInserted) it->second = val;\\n  }\\n};\\nclass Solution {\\n  string_view symbol(string_view &expr) {\\n    string_view ret;\\n    if (expr.empty() || !isalpha(expr[0])) {\\n      return ret;\\n    }\\n    auto pos = expr.find_first_of(\" )\");\\n    assert(pos != string_view::npos);\\n    ret = expr.substr(0, pos);\\n    expr.remove_prefix(pos);\\n    return ret;\\n  }\\n  int evaluate(string_view &expr, Context *context) {\\n    assert(!expr.empty());\\n    if (expr[0] == \\'(\\') {\\n      assert(expr.length() >= 4);\\n      if (expr.substr(0, 4) == \"(add\") {\\n        assert(expr.length() > 4);\\n        expr.remove_prefix(4);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int l = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int r = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\')\\');\\n        expr.remove_prefix(1);\\n        return l + r;\\n      }\\n      if (expr.substr(0, 4) == \"(mul\") {\\n        assert(expr.length() > 5);\\n        expr.remove_prefix(5);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int l = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int r = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\')\\');\\n        expr.remove_prefix(1);\\n        return l * r;\\n      }\\n      if (expr.substr(0, 4) == \"(let\") {\\n        assert(expr.length() > 4);\\n        expr.remove_prefix(4);\\n        Context nc(context);\\n        while (1) {\\n          assert(!expr.empty() && expr[0] == \\' \\');\\n          expr.remove_prefix(1);\\n          string_view sym = symbol(expr);\\n          assert(!expr.empty());\\n          if (sym.empty() || expr[0] == \\')\\') {\\n            int ret{};\\n            if (sym.empty()) {\\n              ret = evaluate(expr, &nc);\\n            } else {\\n              ret = nc.GetValue(sym);\\n            }\\n            assert(!expr.empty() && expr[0] == \\')\\');\\n            expr.remove_prefix(1);\\n            return ret;\\n          }\\n          assert(!expr.empty() && expr[0] == \\' \\');\\n          expr.remove_prefix(1);\\n          int value = evaluate(expr, &nc);\\n          nc.AddValue(sym, value);\\n        }\\n        assert(0);\\n      }\\n    } \\n    if (isdigit(expr[0]) || expr[0] == \\'-\\') {\\n      auto pos = expr.find_first_not_of(\"-0123456789\");\\n      auto len = min(expr.length(), pos);\\n      int num;\\n      if (auto [ptr, ec] = from_chars(expr.data(), expr.data()+len, num); ec == errc()) {\\n        expr.remove_prefix(len);\\n      } else {\\n        assert(0);\\n      }\\n      return num;\\n    }\\n    if (isalpha(expr[0])) {\\n      string_view sym = symbol(expr);\\n      assert(!expr.empty() && (expr[0] == \\' \\' || expr[0] == \\')\\'));\\n      return context->GetValue(sym);\\n    }\\n    assert(0);\\n    return numeric_limits<int>::min();\\n  }\\npublic:\\n    int evaluate(string expression) {\\n      string_view expr(expression);\\n      Context context(nullptr);\\n      return evaluate(expr, &context);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447729,
                "title": "rust-recursive-0-ms-2-6-mb",
                "content": "Here is one simple solution in Rust.\\n\\nI think that the biggest difference to other solutions is that, I just pass existing variables to evaluate the scope below. In most cases, people do push/pop variables in some scope storage, but I think there is no need for it in this case.\\n\\nThere are few things that could be improved, like move add, mult, let into separate functions, use match for the main loop over operators. That would improve code readability.\\n\\n```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    fn expr<\\'a>(expr_stream: &mut Vec<&\\'a str>, mut variables: HashMap<&\\'a str, i32>) -> i32 {\\n        while let Some(action) = expr_stream.pop() {\\n            // Closing brackets are only important for let operator and it\\'s handled there.\\n            // For main operator loop, it can be ignored.\\n            if action == \")\" {\\n                continue;\\n            }\\n\\n            // Start of new scope\\n            if action == \"(\" {\\n                return Solution::expr(expr_stream, variables.clone());\\n            }\\n\\n            // (add 23 -20) = 3\\n            if action == \"add\" {\\n                let op1 = Solution::expr(expr_stream, variables.clone());\\n                let op2 = Solution::expr(expr_stream, variables.clone());\\n\\n                // Remove \")\"\\n                expr_stream.pop();\\n                \\n                return op1 + op2;\\n            }\\n            \\n            // (mult 3 4) = 12\\n            if action == \"mult\" {\\n                let op1 = Solution::expr(expr_stream, variables.clone());\\n                let op2 = Solution::expr(expr_stream, variables.clone());\\n                \\n                // Remove \")\"\\n                expr_stream.pop();\\n\\n                return op1 * op2;\\n            }\\n\\n            // (let x 2 x -3 x 4 (mult x 5)) = 20\\n            if action == \"let\" {\\n                while let Some(var_name) = expr_stream.pop() {\\n                    // we are facing evaluation, if variable name is \"(\"\\n                    if var_name == \"(\" {\\n                        return Solution::expr(expr_stream, variables.clone());\\n                    }\\n\\n                    // get value what should be assigned to variable\\n                    match expr_stream.pop() {\\n                        Some(\")\") => {\\n                            expr_stream.push(var_name);\\n\\n                            return Solution::expr(expr_stream, variables.clone());\\n                        },\\n                        Some(\"(\") => {\\n                            variables.insert(var_name, Solution::expr(expr_stream, variables.clone()));\\n                        },\\n                        Some(var_value) => {\\n                            expr_stream.push(var_value);\\n                            variables.insert(var_name, Solution::expr(expr_stream, variables.clone()));                            \\n                        },\\n                        _ => {\\n                            panic!(\"Let operator format is not valid!\");\\n                        }\\n                    };\\n                }\\n            }\\n\\n            // Handle integers\\n            if let Ok(value) = String::from(action).parse::<i32>() {\\n                return value;\\n            }\\n\\n            // Handle variables\\n            return variables.get(action).unwrap_or(&0i32).clone();\\n        }\\n\\n        panic!(\"Invalid list code!\");\\n    }\\n\\n    pub fn evaluate(expression: String) -> i32 {\\n        let mut expression = expression;\\n\\n        // Add spaces around brackets for better split by space\\n        expression = expression.replace(\"(\", \" ( \");\\n        expression = expression.replace(\")\", \" ) \");\\n\\n        // Reverse order is used because I have storing data in vector.\\n        // Reason for using of vector is easier handling of let operator.\\n        // And I am using pop for fetching next operator.\\n        // It\\'s also possible to use Iterator instead of Vec, but handling of let is a bit trickier.\\n        Solution::expr(&mut expression.split_whitespace().rev().collect::<Vec<&str>>(), HashMap::new())\\n    }\\n}\\n```\\n\\nI would like to improve the solution if someone has any suggestions.\\n",
                "solutionTags": [],
                "code": "```\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    fn expr<\\'a>(expr_stream: &mut Vec<&\\'a str>, mut variables: HashMap<&\\'a str, i32>) -> i32 {\\n        while let Some(action) = expr_stream.pop() {\\n            // Closing brackets are only important for let operator and it\\'s handled there.\\n            // For main operator loop, it can be ignored.\\n            if action == \")\" {\\n                continue;\\n            }\\n\\n            // Start of new scope\\n            if action == \"(\" {\\n                return Solution::expr(expr_stream, variables.clone());\\n            }\\n\\n            // (add 23 -20) = 3\\n            if action == \"add\" {\\n                let op1 = Solution::expr(expr_stream, variables.clone());\\n                let op2 = Solution::expr(expr_stream, variables.clone());\\n\\n                // Remove \")\"\\n                expr_stream.pop();\\n                \\n                return op1 + op2;\\n            }\\n            \\n            // (mult 3 4) = 12\\n            if action == \"mult\" {\\n                let op1 = Solution::expr(expr_stream, variables.clone());\\n                let op2 = Solution::expr(expr_stream, variables.clone());\\n                \\n                // Remove \")\"\\n                expr_stream.pop();\\n\\n                return op1 * op2;\\n            }\\n\\n            // (let x 2 x -3 x 4 (mult x 5)) = 20\\n            if action == \"let\" {\\n                while let Some(var_name) = expr_stream.pop() {\\n                    // we are facing evaluation, if variable name is \"(\"\\n                    if var_name == \"(\" {\\n                        return Solution::expr(expr_stream, variables.clone());\\n                    }\\n\\n                    // get value what should be assigned to variable\\n                    match expr_stream.pop() {\\n                        Some(\")\") => {\\n                            expr_stream.push(var_name);\\n\\n                            return Solution::expr(expr_stream, variables.clone());\\n                        },\\n                        Some(\"(\") => {\\n                            variables.insert(var_name, Solution::expr(expr_stream, variables.clone()));\\n                        },\\n                        Some(var_value) => {\\n                            expr_stream.push(var_value);\\n                            variables.insert(var_name, Solution::expr(expr_stream, variables.clone()));                            \\n                        },\\n                        _ => {\\n                            panic!(\"Let operator format is not valid!\");\\n                        }\\n                    };\\n                }\\n            }\\n\\n            // Handle integers\\n            if let Ok(value) = String::from(action).parse::<i32>() {\\n                return value;\\n            }\\n\\n            // Handle variables\\n            return variables.get(action).unwrap_or(&0i32).clone();\\n        }\\n\\n        panic!(\"Invalid list code!\");\\n    }\\n\\n    pub fn evaluate(expression: String) -> i32 {\\n        let mut expression = expression;\\n\\n        // Add spaces around brackets for better split by space\\n        expression = expression.replace(\"(\", \" ( \");\\n        expression = expression.replace(\")\", \" ) \");\\n\\n        // Reverse order is used because I have storing data in vector.\\n        // Reason for using of vector is easier handling of let operator.\\n        // And I am using pop for fetching next operator.\\n        // It\\'s also possible to use Iterator instead of Vec, but handling of let is a bit trickier.\\n        Solution::expr(&mut expression.split_whitespace().rev().collect::<Vec<&str>>(), HashMap::new())\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 434000,
                "title": "javascript-solution-using-a-tree-implementation-and-recursion-100-mem-100-speed",
                "content": "This problem reminded me a lot of my compilers class in Uni, here I made a tree from the expression as is typical in compilers. It\\'s a very simple tree that allows me to keep scope in each node (a node can be either a keyword like let, add, or mult, but it can also be a variable or a numerical value).\\n\\nWith this approach, I believe the code is quite readable but I still added some more comments for readability.\\n\\nFirstly, I created my Node class. It\\'s got the basics like a parent, a value and children. The scope is an object (used as a dictionary) to store the names and values of variables at that scope.\\n```\\nclass Node {\\n    constructor(parent, value) {\\n        this.parent = parent;\\n        this.value = value;\\n        this.children = [];\\n        this.scope = {};\\n    }\\n    \\n    addChild(node) {\\n        this.children.push(node);\\n    }\\n}\\n```\\n\\nThen I created the LispSolver class that at it\\'s core is just a special implementation of a typical tree class. It stores the root node (and such, all of the tree) and has methods to create and interpret the Lisp expression. When initializing this class, the expression is passed and the tree is built while the expression is parsed.\\n```\\nclass LispSolver {    \\n    constructor(expression) {\\n        this.root = null;\\n        this.parseExpression(expression);\\n    }\\n    // Separate by \"(\" allows for simpler parsing since the first word in each string will be a keyword (let, add, mult)\\n\\t// \\n    parseExpression(expression) {\\n        let expr = expression.split(\\'(\\');\\n        let exprSlice = \"\";\\n        let parent = null;\\n        \\n        for (var i = 0; i < expr.length; i++) {\\n            exprSlice = expr[i];\\n            if (exprSlice == \"\")\\n                continue;\\n            \\n            // new node for keyword. We split by space at this point to separate the keyword from the parameters in the expression\\n            exprSlice = exprSlice.split(\\' \\');\\n            let newNode = new Node(parent, exprSlice[0]);\\n            if (parent == null)\\n                this.root = newNode;\\n            else\\n                parent.addChild(newNode);\\n\\t\\t\\t\\n            for (var ei = 1; ei < exprSlice.length; ei++) {\\n\\t\\t\\t\\t// the way split works sometimes brings empty strings, so we ignore those\\n                if (exprSlice[ei] == \"\")\\n                    continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// add info as child of keyword (variables or numbers or other expressions)\\n                newNode.addChild(new Node(newNode, exprSlice[ei].replace(/\\\\)/g, \\'\\')));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// this bit checks the current word for \")\". The closing parenthesys denotes the end of an expression, \\n\\t\\t\\t\\t// so we want to move upwards to the parent to continue parsing and filling our tree correctly.\\n                if (exprSlice[ei].match(/\\\\)/g)) {\\n                    for (var idx = 0; idx < exprSlice[ei].length; idx++) {\\n                        if (exprSlice[ei][idx] == \\')\\') {\\n                            if (newNode != null)\\n                                newNode = newNode.parent;\\n                            if (newNode != null)\\n                                parent = newNode.parent;\\n                        }\\n                    }\\n                }\\n            }\\n\\t\\t\\t// at the end, we need to make sure we are moving down the tree to continue creating our nodes in the correct places\\n            parent = newNode;\\n        }\\n    }\\n\\n    // tries to find a variable name upward through scopes\\n    lookUpScope(node, variable) {\\n        let current = node;\\n        while (true) {\\n            if (current.scope[variable] != undefined && current.scope[variable] != null) {\\n                return current.scope[variable];\\n            }\\n            if (current.parent == null) // if we reach the root node and can\\'t find the variable then it doesn\\'t exist, return null. This could be omitted since the problem states that all the test cases have solutions\\n                return null;\\n            current = current.parent;\\n        }\\n    }\\n\\n    // recursive function that at it\\'s basic point returns a numeric value\\n    // also resolves expressions and variables\\n    resolve(node) {\\n        // expression\\n        if (node.value == \\'let\\') {\\n            for (var i = 0; i < node.children.length-1; i+=2) {\\n                node.scope[node.children[i].value] = this.resolve(node.children[i+1]);\\n            }\\n            return this.resolve(node.children[node.children.length-1]);\\n        }\\n        if (node.value == \\'add\\') {\\n            return this.resolve(node.children[0]) + this.resolve(node.children[1]);\\n        }\\n        if (node.value == \\'mult\\') {\\n            return this.resolve(node.children[0]) * this.resolve(node.children[1]);\\n        }\\n        // variable\\n        if (node.value[0].match(/[a-zA-Z]/g)) {\\n            return this.lookUpScope(node, node.value);\\n        }\\n        // value\\n        return Number(node.value)\\n    }\\n    \\n    calculate() {\\n        // resolve root value\\n        return this.resolve(this.root)\\n    }\\n}\\n```\\n\\nThe evaluate function can then be very simple as all the logic is in our LispSolver class. We can take the expression, convert it to a tree by making a new instance of LispSolver and easily compute the expression using the recursive approach above and that\\'s about it.\\n```\\nvar evaluate = function(expression) {\\n    // parse expression into tree\\n    let lispExpr = new LispSolver(expression);\\n    \\n    // solve for root expression\\n    return lispExpr.calculate();\\n};\\n```\\n\\nThis solution is apparently faster than 100% of submissions and uses 100% less memory. I would guess it\\'s because there aren\\'t many solving in JS, because I can see where it could be improved.",
                "solutionTags": [],
                "code": "```\\nclass Node {\\n    constructor(parent, value) {\\n        this.parent = parent;\\n        this.value = value;\\n        this.children = [];\\n        this.scope = {};\\n    }\\n    \\n    addChild(node) {\\n        this.children.push(node);\\n    }\\n}\\n```\n```\\nclass LispSolver {    \\n    constructor(expression) {\\n        this.root = null;\\n        this.parseExpression(expression);\\n    }\\n    // Separate by \"(\" allows for simpler parsing since the first word in each string will be a keyword (let, add, mult)\\n\\t// \\n    parseExpression(expression) {\\n        let expr = expression.split(\\'(\\');\\n        let exprSlice = \"\";\\n        let parent = null;\\n        \\n        for (var i = 0; i < expr.length; i++) {\\n            exprSlice = expr[i];\\n            if (exprSlice == \"\")\\n                continue;\\n            \\n            // new node for keyword. We split by space at this point to separate the keyword from the parameters in the expression\\n            exprSlice = exprSlice.split(\\' \\');\\n            let newNode = new Node(parent, exprSlice[0]);\\n            if (parent == null)\\n                this.root = newNode;\\n            else\\n                parent.addChild(newNode);\\n\\t\\t\\t\\n            for (var ei = 1; ei < exprSlice.length; ei++) {\\n\\t\\t\\t\\t// the way split works sometimes brings empty strings, so we ignore those\\n                if (exprSlice[ei] == \"\")\\n                    continue;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// add info as child of keyword (variables or numbers or other expressions)\\n                newNode.addChild(new Node(newNode, exprSlice[ei].replace(/\\\\)/g, \\'\\')));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// this bit checks the current word for \")\". The closing parenthesys denotes the end of an expression, \\n\\t\\t\\t\\t// so we want to move upwards to the parent to continue parsing and filling our tree correctly.\\n                if (exprSlice[ei].match(/\\\\)/g)) {\\n                    for (var idx = 0; idx < exprSlice[ei].length; idx++) {\\n                        if (exprSlice[ei][idx] == \\')\\') {\\n                            if (newNode != null)\\n                                newNode = newNode.parent;\\n                            if (newNode != null)\\n                                parent = newNode.parent;\\n                        }\\n                    }\\n                }\\n            }\\n\\t\\t\\t// at the end, we need to make sure we are moving down the tree to continue creating our nodes in the correct places\\n            parent = newNode;\\n        }\\n    }\\n\\n    // tries to find a variable name upward through scopes\\n    lookUpScope(node, variable) {\\n        let current = node;\\n        while (true) {\\n            if (current.scope[variable] != undefined && current.scope[variable] != null) {\\n                return current.scope[variable];\\n            }\\n            if (current.parent == null) // if we reach the root node and can\\'t find the variable then it doesn\\'t exist, return null. This could be omitted since the problem states that all the test cases have solutions\\n                return null;\\n            current = current.parent;\\n        }\\n    }\\n\\n    // recursive function that at it\\'s basic point returns a numeric value\\n    // also resolves expressions and variables\\n    resolve(node) {\\n        // expression\\n        if (node.value == \\'let\\') {\\n            for (var i = 0; i < node.children.length-1; i+=2) {\\n                node.scope[node.children[i].value] = this.resolve(node.children[i+1]);\\n            }\\n            return this.resolve(node.children[node.children.length-1]);\\n        }\\n        if (node.value == \\'add\\') {\\n            return this.resolve(node.children[0]) + this.resolve(node.children[1]);\\n        }\\n        if (node.value == \\'mult\\') {\\n            return this.resolve(node.children[0]) * this.resolve(node.children[1]);\\n        }\\n        // variable\\n        if (node.value[0].match(/[a-zA-Z]/g)) {\\n            return this.lookUpScope(node, node.value);\\n        }\\n        // value\\n        return Number(node.value)\\n    }\\n    \\n    calculate() {\\n        // resolve root value\\n        return this.resolve(this.root)\\n    }\\n}\\n```\n```\\nvar evaluate = function(expression) {\\n    // parse expression into tree\\n    let lispExpr = new LispSolver(expression);\\n    \\n    // solve for root expression\\n    return lispExpr.calculate();\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 394808,
                "title": "python-30-line-solution-using-try-except",
                "content": "```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        def get_num(exps, i, var_val):\\n            if exps[i] == \\'(\\':\\n                num, i = parse(exps, i+1, var_val)\\n            else:\\n                try:\\n                    num, i = int(exps[i]), i+1\\n                except:\\n                    num, i = var_val[exps[i]], i+1\\n            return num, i\\n        \\n        def parse(exps, i, var_val):\\n            var_val = var_val.copy()\\n            op, i = exps[i], i+1\\n            if op == \\'let\\':\\n                while True:\\n                    try:\\n                        var = exps[i]\\n                        val, i = get_num(exps, i+1, var_val)\\n                        var_val[var] = val\\n                    except:\\n                        expr, i = get_num(exps, i, var_val)\\n                        return expr, i+1\\n            else:\\n                num1, i = get_num(exps, i, var_val)\\n                num2, i = get_num(exps, i, var_val)\\n                val = num1 + num2 if op == \\'add\\' else num1 * num2\\n                return val, i+1\\n        \\n        expression = expression.replace(\\')\\', \\' )\\').replace(\\'(\\', \\'( \\')\\n        return parse(expression.split(), 1, {})[0]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        def get_num(exps, i, var_val):\\n            if exps[i] == \\'(\\':\\n                num, i = parse(exps, i+1, var_val)\\n            else:\\n                try:\\n                    num, i = int(exps[i]), i+1\\n                except:\\n                    num, i = var_val[exps[i]], i+1\\n            return num, i\\n        \\n        def parse(exps, i, var_val):\\n            var_val = var_val.copy()\\n            op, i = exps[i], i+1\\n            if op == \\'let\\':\\n                while True:\\n                    try:\\n                        var = exps[i]\\n                        val, i = get_num(exps, i+1, var_val)\\n                        var_val[var] = val\\n                    except:\\n                        expr, i = get_num(exps, i, var_val)\\n                        return expr, i+1\\n            else:\\n                num1, i = get_num(exps, i, var_val)\\n                num2, i = get_num(exps, i, var_val)\\n                val = num1 + num2 if op == \\'add\\' else num1 * num2\\n                return val, i+1\\n        \\n        expression = expression.replace(\\')\\', \\' )\\').replace(\\'(\\', \\'( \\')\\n        return parse(expression.split(), 1, {})[0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 393964,
                "title": "fastest-c-solution-greedy",
                "content": "```cs\\npublic class Solution \\n{\\n    // inner scopes are added at front\\n    LinkedList<Dictionary<string, int>> scopedVars = new LinkedList<Dictionary<string,int>>();\\n        \\n    string expression;\\n    public int Evaluate(string expression) \\n    {\\n        this.expression = expression;\\n        \\n        return Evaluate(0).val;\\n    }\\n    \\n    public (int val, int nextPos) Evaluate(int pos) \\n    {\\n        if (expression[pos] == \\'(\\')\\n        {\\n            int val1, val2;\\n            switch(expression[++pos])\\n            {\\n                case \\'a\\': //add\\n                    pos+=4;\\n                    (val1, pos) = Evaluate(pos);\\n                    (val2, pos) = Evaluate(pos+1);\\n                    return (val1+val2, pos+1); //eat the \\')\\'\\n                case \\'m\\':\\n                    pos+=5;\\n                    (val1, pos) = Evaluate(pos);\\n                    (val2, pos) = Evaluate(pos+1);\\n                    return (val1*val2, pos+1); \\n                case \\'l\\':\\n                    scopedVars.AddFirst(new Dictionary<string,int>());\\n                    pos+=4;\\n                    string varExpr=null;\\n                    do \\n                    {\\n                        if(!char.IsLetter(expression[pos])) //ending expression\\n                            break;\\n                        \\n                        //parse var name\\n                        var sb = new StringBuilder();\\n                        do \\n                        {\\n                            sb.Append(expression[pos++]);\\n                        }\\n                        while (char.IsLetter(expression[pos]) || char.IsDigit(expression[pos]));\\n                        \\n                        var varName = sb.ToString();\\n                        \\n                        if(expression[pos] == \\')\\')\\n                        {\\n                            varExpr=varName;\\n                            break;\\n                        }\\n                        \\n                        pos++;\\n                        \\n                        //Eval expression\\n                        int tmp;\\n                        (tmp, pos) = Evaluate(pos);\\n                        scopedVars.First.Value.Remove(varName);\\n                        scopedVars.First.Value.Add(varName, tmp);\\n                        pos++;\\n                    }\\n                    while(true);\\n                    \\n                    int val;\\n                    if(varExpr != null)\\n                    {\\n                        // eval expr\\n                        val = GetScopedVarValue(varExpr);\\n                    }\\n                    else\\n                    {\\n                        //eval var as expr\\n                        (val, pos) = Evaluate(pos);\\n                    }\\n\\n                    pos++;\\n                    \\n                    scopedVars.RemoveFirst();\\n                    \\n                    return (val, pos);\\n            }\\n        }\\n        else if(char.IsLetter(expression[pos]))\\n        {\\n            //var\\n            StringBuilder sb = new StringBuilder();\\n            do \\n            {\\n                sb.Append(expression[pos++]);\\n            }\\n            while (IsValid(pos) && (char.IsLetter(expression[pos]) || char.IsDigit(expression[pos])));\\n            \\n            return (GetScopedVarValue(sb.ToString()), pos);\\n        }\\n        else\\n        {\\n            //int\\n            bool isNeg = expression[pos] == \\'-\\';\\n            if (isNeg) pos++;\\n            \\n            int val=0;\\n            do\\n            {\\n                val = val*10 + (expression[pos++] - \\'0\\');\\n            }\\n            while (IsValid(pos) && char.IsDigit(expression[pos]));\\n            \\n            return (isNeg ? -val : val, pos);\\n        }\\n        \\n        //should never reach here\\n        throw new Exception(\"should not reach here\");\\n    }\\n    \\n    bool IsValid(int pos)\\n    {\\n        return pos < expression.Length;\\n    }\\n    \\n    int GetScopedVarValue(string var) \\n    {\\n        foreach(var scope in scopedVars) \\n        {\\n            if(scope.ContainsKey(var))\\n                return scope[var];\\n        }\\n        \\n        throw new Exception($\"var {var} value not found\");\\n    }\\n}\\n\\n\\n\\n```",
                "solutionTags": [],
                "code": "```cs\\npublic class Solution \\n{\\n    // inner scopes are added at front\\n    LinkedList<Dictionary<string, int>> scopedVars = new LinkedList<Dictionary<string,int>>();\\n        \\n    string expression;\\n    public int Evaluate(string expression) \\n    {\\n        this.expression = expression;\\n        \\n        return Evaluate(0).val;\\n    }\\n    \\n    public (int val, int nextPos) Evaluate(int pos) \\n    {\\n        if (expression[pos] == \\'(\\')\\n        {\\n            int val1, val2;\\n            switch(expression[++pos])\\n            {\\n                case \\'a\\': //add\\n                    pos+=4;\\n                    (val1, pos) = Evaluate(pos);\\n                    (val2, pos) = Evaluate(pos+1);\\n                    return (val1+val2, pos+1); //eat the \\')\\'\\n                case \\'m\\':\\n                    pos+=5;\\n                    (val1, pos) = Evaluate(pos);\\n                    (val2, pos) = Evaluate(pos+1);\\n                    return (val1*val2, pos+1); \\n                case \\'l\\':\\n                    scopedVars.AddFirst(new Dictionary<string,int>());\\n                    pos+=4;\\n                    string varExpr=null;\\n                    do \\n                    {\\n                        if(!char.IsLetter(expression[pos])) //ending expression\\n                            break;\\n                        \\n                        //parse var name\\n                        var sb = new StringBuilder();\\n                        do \\n                        {\\n                            sb.Append(expression[pos++]);\\n                        }\\n                        while (char.IsLetter(expression[pos]) || char.IsDigit(expression[pos]));\\n                        \\n                        var varName = sb.ToString();\\n                        \\n                        if(expression[pos] == \\')\\')\\n                        {\\n                            varExpr=varName;\\n                            break;\\n                        }\\n                        \\n                        pos++;\\n                        \\n                        //Eval expression\\n                        int tmp;\\n                        (tmp, pos) = Evaluate(pos);\\n                        scopedVars.First.Value.Remove(varName);\\n                        scopedVars.First.Value.Add(varName, tmp);\\n                        pos++;\\n                    }\\n                    while(true);\\n                    \\n                    int val;\\n                    if(varExpr != null)\\n                    {\\n                        // eval expr\\n                        val = GetScopedVarValue(varExpr);\\n                    }\\n                    else\\n                    {\\n                        //eval var as expr\\n                        (val, pos) = Evaluate(pos);\\n                    }\\n\\n                    pos++;\\n                    \\n                    scopedVars.RemoveFirst();\\n                    \\n                    return (val, pos);\\n            }\\n        }\\n        else if(char.IsLetter(expression[pos]))\\n        {\\n            //var\\n            StringBuilder sb = new StringBuilder();\\n            do \\n            {\\n                sb.Append(expression[pos++]);\\n            }\\n            while (IsValid(pos) && (char.IsLetter(expression[pos]) || char.IsDigit(expression[pos])));\\n            \\n            return (GetScopedVarValue(sb.ToString()), pos);\\n        }\\n        else\\n        {\\n            //int\\n            bool isNeg = expression[pos] == \\'-\\';\\n            if (isNeg) pos++;\\n            \\n            int val=0;\\n            do\\n            {\\n                val = val*10 + (expression[pos++] - \\'0\\');\\n            }\\n            while (IsValid(pos) && char.IsDigit(expression[pos]));\\n            \\n            return (isNeg ? -val : val, pos);\\n        }\\n        \\n        //should never reach here\\n        throw new Exception(\"should not reach here\");\\n    }\\n    \\n    bool IsValid(int pos)\\n    {\\n        return pos < expression.Length;\\n    }\\n    \\n    int GetScopedVarValue(string var) \\n    {\\n        foreach(var scope in scopedVars) \\n        {\\n            if(scope.ContainsKey(var))\\n                return scope[var];\\n        }\\n        \\n        throw new Exception($\"var {var} value not found\");\\n    }\\n}\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362741,
                "title": "c-stack-based-solution",
                "content": "```\\ntypedef pair<int, string> token;\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        stack<unordered_map<string, int>> dict_stack;\\n        vector<token> num_stack;\\n        stack<int> operator_stack;\\n        dict_stack.push(unordered_map<string, int>());\\n        for(int i=0; i<expression.size();){\\n            if(expression[i]==\\'(\\') {\\n                if(!operator_stack.empty()&&operator_stack.top()==2) {\\n                    int j = find_index(num_stack);\\n                    for(; j+1<num_stack.size();j+=2) {\\n                        dict_stack.top()[num_stack[j].second] = val_num(num_stack[j+1], dict_stack.top());\\n                    }\\n                }\\n                num_stack.push_back(make_pair(0, \"(\"));\\n                read_operator(operator_stack,expression, i);\\n                dict_stack.push(dict_stack.top());\\n            }\\n            else if(isdigit(expression[i])||expression[i]==\\'-\\') {\\n                read_number(num_stack,expression, i, 0);\\n            }\\n            else if(isalpha(expression[i])) {\\n                read_number(num_stack,expression, i, 1);\\n            }\\n            else if(expression[i]==\\')\\') {\\n                int index = find_index(num_stack);\\n                int res = 0;\\n                if (operator_stack.top()<2){\\n                    int l = val_num(num_stack[index], dict_stack.top());\\n                    int r = val_num(num_stack[index+1], dict_stack.top());\\n                    if(operator_stack.top()==1)\\n                        res = l*r;\\n                    if(operator_stack.top()==0)\\n                        res = l+r;\\n                } else{\\n                    int j = index;\\n                    for(; j+1<num_stack.size();j+=2) {\\n                        dict_stack.top()[num_stack[j].second] = val_num(num_stack[j+1], dict_stack.top());\\n                    }\\n                    res = val_num(num_stack[j],dict_stack.top());\\n                }\\n                num_stack.resize(index-1);\\n                num_stack.push_back(make_pair(res,\"\"));\\n                operator_stack.pop();\\n                dict_stack.pop();\\n                i++;\\n            }else {\\n                i++;\\n            }\\n        }\\n        return num_stack.back().first;\\n    }\\n    \\n    int find_index(vector<token> const & tokens) {\\n        for(int i=tokens.size()-1; i>=0; i--) {\\n            if(tokens[i].second==\"(\")\\n                return i+1;\\n        }\\n        return -1;\\n    }\\n    \\n    void read_operator(stack<int> & operator_stack, string const & expression, int & index) {\\n        index++;\\n        while(isspace(expression[index])) index++;\\n        if(expression[index]==\\'a\\') {\\n            operator_stack.push(0);index+=3;\\n        } else if(expression[index]==\\'m\\') {\\n            operator_stack.push(1);index+=4;\\n        }else  if(expression[index]==\\'l\\'){\\n            operator_stack.push(2);index+=3;\\n        }\\n    }\\n    \\n    void read_number(vector<token> & num_stack, string const & expression, int & index, int mode) {\\n        string cur_num;\\n        while(!isspace(expression[index])&&expression[index]!=\\')\\'){\\n            cur_num.push_back(expression[index]);index++;\\n        }\\n        if(mode)\\n            num_stack.push_back(make_pair(0, cur_num));\\n        else\\n            num_stack.push_back(make_pair(stoi(cur_num), \"\"));\\n    }\\n    \\n    int val_num(token & t, unordered_map<string, int> & dict) {\\n        if(t.second==\"\")\\n            return t.first;\\n        else\\n            return dict[t.second];\\n    }\\n    \\n};\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef pair<int, string> token;\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        stack<unordered_map<string, int>> dict_stack;\\n        vector<token> num_stack;\\n        stack<int> operator_stack;\\n        dict_stack.push(unordered_map<string, int>());\\n        for(int i=0; i<expression.size();){\\n            if(expression[i]==\\'(\\') {\\n                if(!operator_stack.empty()&&operator_stack.top()==2) {\\n                    int j = find_index(num_stack);\\n                    for(; j+1<num_stack.size();j+=2) {\\n                        dict_stack.top()[num_stack[j].second] = val_num(num_stack[j+1], dict_stack.top());\\n                    }\\n                }\\n                num_stack.push_back(make_pair(0, \"(\"));\\n                read_operator(operator_stack,expression, i);\\n                dict_stack.push(dict_stack.top());\\n            }\\n            else if(isdigit(expression[i])||expression[i]==\\'-\\') {\\n                read_number(num_stack,expression, i, 0);\\n            }\\n            else if(isalpha(expression[i])) {\\n                read_number(num_stack,expression, i, 1);\\n            }\\n            else if(expression[i]==\\')\\') {\\n                int index = find_index(num_stack);\\n                int res = 0;\\n                if (operator_stack.top()<2){\\n                    int l = val_num(num_stack[index], dict_stack.top());\\n                    int r = val_num(num_stack[index+1], dict_stack.top());\\n                    if(operator_stack.top()==1)\\n                        res = l*r;\\n                    if(operator_stack.top()==0)\\n                        res = l+r;\\n                } else{\\n                    int j = index;\\n                    for(; j+1<num_stack.size();j+=2) {\\n                        dict_stack.top()[num_stack[j].second] = val_num(num_stack[j+1], dict_stack.top());\\n                    }\\n                    res = val_num(num_stack[j],dict_stack.top());\\n                }\\n                num_stack.resize(index-1);\\n                num_stack.push_back(make_pair(res,\"\"));\\n                operator_stack.pop();\\n                dict_stack.pop();\\n                i++;\\n            }else {\\n                i++;\\n            }\\n        }\\n        return num_stack.back().first;\\n    }\\n    \\n    int find_index(vector<token> const & tokens) {\\n        for(int i=tokens.size()-1; i>=0; i--) {\\n            if(tokens[i].second==\"(\")\\n                return i+1;\\n        }\\n        return -1;\\n    }\\n    \\n    void read_operator(stack<int> & operator_stack, string const & expression, int & index) {\\n        index++;\\n        while(isspace(expression[index])) index++;\\n        if(expression[index]==\\'a\\') {\\n            operator_stack.push(0);index+=3;\\n        } else if(expression[index]==\\'m\\') {\\n            operator_stack.push(1);index+=4;\\n        }else  if(expression[index]==\\'l\\'){\\n            operator_stack.push(2);index+=3;\\n        }\\n    }\\n    \\n    void read_number(vector<token> & num_stack, string const & expression, int & index, int mode) {\\n        string cur_num;\\n        while(!isspace(expression[index])&&expression[index]!=\\')\\'){\\n            cur_num.push_back(expression[index]);index++;\\n        }\\n        if(mode)\\n            num_stack.push_back(make_pair(0, cur_num));\\n        else\\n            num_stack.push_back(make_pair(stoi(cur_num), \"\"));\\n    }\\n    \\n    int val_num(token & t, unordered_map<string, int> & dict) {\\n        if(t.second==\"\")\\n            return t.first;\\n        else\\n            return dict[t.second];\\n    }\\n    \\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 358515,
                "title": "python-generator-solution-beats-100",
                "content": "```\\nclass Solution:\\n    def get_token(self, expr: str, start: int):\\n        token_start = start\\n        while token_start < len(expr):\\n            if expr[token_start] != \\'(\\':\\n                token_end = expr.find(\\' \\', token_start)\\n                token = expr[token_start:token_end]\\n                if token_end != -1:\\n                    token_start = token_end + 1\\n                else:\\n                    token_start = len(expr)\\n                yield token\\n            else:\\n                left = 1\\n                for i in range(token_start + 1, len(expr)):\\n                    c = expr[i]\\n                    if c == \\'(\\':\\n                        left += 1\\n                    elif c == \\')\\':\\n                        left -= 1\\n                    if left == 0:\\n                        token = expr[token_start:i + 1]\\n                        token_start = i + 2\\n                        yield token\\n                        break\\n\\n    def convert_to_num(self, token: str, value_map) -> int:\\n        if token[0].isdigit() or token[0] == \\'-\\':\\n            return int(token)\\n        elif token[0] != \\'(\\':\\n            return value_map.get(token, 0)\\n        else:\\n            return self.evaluate_helper(token, value_map.copy())\\n\\n    def evaluate_helper(self, expr: str, value_map) -> int:\\n        if expr[0] == \\'(\\':\\n            tokens = [token for token in self.get_token(expr, 1)]\\n            if tokens[0] == \\'add\\':\\n                return self.convert_to_num(tokens[1], value_map) + self.convert_to_num(tokens[2], value_map)\\n            elif tokens[0] == \\'mult\\':\\n                return self.convert_to_num(tokens[1], value_map) * self.convert_to_num(tokens[2], value_map)\\n            else:\\n                final_expr = tokens[-1]\\n                mapping = value_map.copy()\\n                for i in range(1, len(tokens) - 1, 2):\\n                    key = tokens[i]\\n                    val = tokens[i + 1]\\n                    mapping[key] = self.convert_to_num(val, mapping)\\n                return self.evaluate_helper(final_expr, mapping)\\n        else:\\n            return self.convert_to_num(expr, value_map.copy())\\n\\n    def evaluate(self, expression: str) -> int:\\n        return self.evaluate_helper(expression, {})\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def get_token(self, expr: str, start: int):\\n        token_start = start\\n        while token_start < len(expr):\\n            if expr[token_start] != \\'(\\':\\n                token_end = expr.find(\\' \\', token_start)\\n                token = expr[token_start:token_end]\\n                if token_end != -1:\\n                    token_start = token_end + 1\\n                else:\\n                    token_start = len(expr)\\n                yield token\\n            else:\\n                left = 1\\n                for i in range(token_start + 1, len(expr)):\\n                    c = expr[i]\\n                    if c == \\'(\\':\\n                        left += 1\\n                    elif c == \\')\\':\\n                        left -= 1\\n                    if left == 0:\\n                        token = expr[token_start:i + 1]\\n                        token_start = i + 2\\n                        yield token\\n                        break\\n\\n    def convert_to_num(self, token: str, value_map) -> int:\\n        if token[0].isdigit() or token[0] == \\'-\\':\\n            return int(token)\\n        elif token[0] != \\'(\\':\\n            return value_map.get(token, 0)\\n        else:\\n            return self.evaluate_helper(token, value_map.copy())\\n\\n    def evaluate_helper(self, expr: str, value_map) -> int:\\n        if expr[0] == \\'(\\':\\n            tokens = [token for token in self.get_token(expr, 1)]\\n            if tokens[0] == \\'add\\':\\n                return self.convert_to_num(tokens[1], value_map) + self.convert_to_num(tokens[2], value_map)\\n            elif tokens[0] == \\'mult\\':\\n                return self.convert_to_num(tokens[1], value_map) * self.convert_to_num(tokens[2], value_map)\\n            else:\\n                final_expr = tokens[-1]\\n                mapping = value_map.copy()\\n                for i in range(1, len(tokens) - 1, 2):\\n                    key = tokens[i]\\n                    val = tokens[i + 1]\\n                    mapping[key] = self.convert_to_num(val, mapping)\\n                return self.evaluate_helper(final_expr, mapping)\\n        else:\\n            return self.convert_to_num(expr, value_map.copy())\\n\\n    def evaluate(self, expression: str) -> int:\\n        return self.evaluate_helper(expression, {})\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248476,
                "title": "35-lines-clear-python-solution-very-easy-to-understand-imply",
                "content": "Easy to understand & Impl, but not take care of performance.\\n\\n```\\nclass Solution:\\n    def split_(self, s):\\n        if s[0] != \\'(\\': return [s]\\n        s = s[1:-1]; res = []; curr = \"\"; depth = 0\\n        for c in s:\\n            if c == \\' \\' and depth == 0:\\n                if curr != \"\": res.append(curr)\\n                curr = \"\"\\n            else: curr += c\\n\\n            if c == \\'(\\': depth += 1\\n            if c == \\')\\': depth -= 1\\n\\n        if curr != \"\": res.append(curr)\\n        return res\\n    \\n    def evaluate(self, expression: str, var_dict=None) -> int:\\n        if not var_dict: var_dict = {}\\n        sp = self.split_(expression); res = None\\n        \\n        if len(sp) == 1:\\n            res = var_dict[sp[0]] if sp[0][0].isalpha() else int(sp[0])\\n        \\n        elif sp[0] != \\'let\\':\\n            x1 = self.evaluate(sp[1], var_dict)\\n            x2 = self.evaluate(sp[2], var_dict)\\n            res = x1 + x2 if sp[0] == \\'add\\' else x1 * x2\\n        \\n        else:  # sp[0] == \\'let\\'\\n            _var_dict = var_dict.copy()\\n            for i in range(len(sp) // 2 - 1):\\n                _var_dict[sp[i * 2 + 1]] = self.evaluate(sp[i * 2 + 2], _var_dict)\\n            res = self.evaluate(sp[-1], _var_dict)\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def split_(self, s):\\n        if s[0] != \\'(\\': return [s]\\n        s = s[1:-1]; res = []; curr = \"\"; depth = 0\\n        for c in s:\\n            if c == \\' \\' and depth == 0:\\n                if curr != \"\": res.append(curr)\\n                curr = \"\"\\n            else: curr += c\\n\\n            if c == \\'(\\': depth += 1\\n            if c == \\')\\': depth -= 1\\n\\n        if curr != \"\": res.append(curr)\\n        return res\\n    \\n    def evaluate(self, expression: str, var_dict=None) -> int:\\n        if not var_dict: var_dict = {}\\n        sp = self.split_(expression); res = None\\n        \\n        if len(sp) == 1:\\n            res = var_dict[sp[0]] if sp[0][0].isalpha() else int(sp[0])\\n        \\n        elif sp[0] != \\'let\\':\\n            x1 = self.evaluate(sp[1], var_dict)\\n            x2 = self.evaluate(sp[2], var_dict)\\n            res = x1 + x2 if sp[0] == \\'add\\' else x1 * x2\\n        \\n        else:  # sp[0] == \\'let\\'\\n            _var_dict = var_dict.copy()\\n            for i in range(len(sp) // 2 - 1):\\n                _var_dict[sp[i * 2 + 1]] = self.evaluate(sp[i * 2 + 2], _var_dict)\\n            res = self.evaluate(sp[-1], _var_dict)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 233641,
                "title": "clean-python-solution-beat-70",
                "content": "```\\nclass Solution:\\n    def __init__(self):\\n        self.stack = []\\n    \\n    def evaluate(self, expression: \\'str\\') -> \\'int\\':\\n        if expression[0] == \"(\":\\n            expr = expression[1:-1]\\n            eList = self.getExprs(expr)\\n            if eList[0] == \"add\":\\n                return self.add(eList[1], eList[2])\\n            if eList[0] == \"mult\":\\n                return self.mult(eList[1], eList[2])\\n            if eList[0] == \"let\":\\n                return self.let(eList[1:-1], eList[-1])\\n        else:\\n            try:\\n                return int(expression)\\n            except ValueError:                \\n                for i in reversed(range(len(self.stack))):\\n                    if expression in self.stack[i]:\\n                        return self.stack[i][expression]\\n                    \\n                    \\n    def add(self, e1, e2):\\n        return self.evaluate(e1) + self.evaluate(e2)\\n            \\n    def mult(self, e1, e2):\\n        return self.evaluate(e1) * self.evaluate(e2)\\n    \\n    def let(self, es, e):\\n        self.stack.append({})\\n        for i in range(0, len(es), 2):\\n            self.stack[-1][es[i]] = self.evaluate(es[i+1])\\n        r = self.evaluate(e)\\n        self.stack.pop()\\n        return r\\n\\n    def getExprs(self, expr):\\n        leftP = 0\\n        eList = []\\n        curr = \\'\\'\\n        for c in expr:\\n            if c == \" \" and leftP == 0:\\n                eList.append(curr)\\n                curr = \"\"\\n                continue\\n            if c == \"(\":\\n                leftP += 1\\n            if c == \")\":\\n                leftP -= 1\\n            curr = curr + c\\n        eList.append(curr)\\n        return eList\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.stack = []\\n    \\n    def evaluate(self, expression: \\'str\\') -> \\'int\\':\\n        if expression[0] == \"(\":\\n            expr = expression[1:-1]\\n            eList = self.getExprs(expr)\\n            if eList[0] == \"add\":\\n                return self.add(eList[1], eList[2])\\n            if eList[0] == \"mult\":\\n                return self.mult(eList[1], eList[2])\\n            if eList[0] == \"let\":\\n                return self.let(eList[1:-1], eList[-1])\\n        else:\\n            try:\\n                return int(expression)\\n            except ValueError:                \\n                for i in reversed(range(len(self.stack))):\\n                    if expression in self.stack[i]:\\n                        return self.stack[i][expression]\\n                    \\n                    \\n    def add(self, e1, e2):\\n        return self.evaluate(e1) + self.evaluate(e2)\\n            \\n    def mult(self, e1, e2):\\n        return self.evaluate(e1) * self.evaluate(e2)\\n    \\n    def let(self, es, e):\\n        self.stack.append({})\\n        for i in range(0, len(es), 2):\\n            self.stack[-1][es[i]] = self.evaluate(es[i+1])\\n        r = self.evaluate(e)\\n        self.stack.pop()\\n        return r\\n\\n    def getExprs(self, expr):\\n        leftP = 0\\n        eList = []\\n        curr = \\'\\'\\n        for c in expr:\\n            if c == \" \" and leftP == 0:\\n                eList.append(curr)\\n                curr = \"\"\\n                continue\\n            if c == \"(\":\\n                leftP += 1\\n            if c == \")\":\\n                leftP -= 1\\n            curr = curr + c\\n        eList.append(curr)\\n        return eList\\n```",
                "codeTag": "Java"
            },
            {
                "id": 165748,
                "title": "c-d-c-100-may-not-be-able-to-finish-in-a-45mins-interview-sad",
                "content": "```\\n#include <string>\\n#include <vector>\\n#include <unordered_map>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nclass Solution {\\n    vector<unordered_map<string, int>*> symbols;\\n\\n    string getVar(string& exp, int start) {\\n        int n = exp.length();\\n\\n        int i = start;\\n        while (i < n && exp[i] != \\' \\' && exp[i] != \\')\\') {\\n            ++i;\\n        }\\n        return exp.substr(start, i - start);\\n    }\\n\\n    string getExp(string& exp, int start) {\\n        int n = exp.length();\\n\\n        if (exp[start] == \\'-\\' || (exp[start] >= \\'0\\' && exp[start] <= \\'9\\')) {\\n            int i = start;\\n            while (i < n && exp[i] != \\' \\' && exp[i] != \\')\\') {\\n                ++i;\\n            }\\n            return exp.substr(start, i - start);\\n        }\\n\\n        int cnt = 0;\\n        int i = start;\\n        while (i < n) {\\n            if (exp[i] == \\'(\\') {\\n                ++cnt;\\n            } else if (exp[i] == \\')\\') {\\n                --cnt;\\n            }\\n\\n            if (cnt == 0) {\\n                break;\\n            }\\n            ++i;\\n        }\\n        return exp.substr(start, i - start + 1);\\n    }\\n\\n    int lookupVar(string& var) {\\n        int n = symbols.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            auto& tbl = *symbols[i];\\n            if (tbl.find(var) != tbl.end()) {\\n                return tbl[var];\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int eval(string& exp) {\\n        if (exp[0] == \\'-\\' || (exp[0] >= \\'0\\' && exp[0] <= \\'9\\')) {\\n            return stoi(exp);\\n        }\\n\\n        int n = exp.length();\\n\\n        int res = 0;\\n        if (exp[1] == \\'l\\') {\\n            unordered_map<string, int> sym;\\n            symbols.push_back(&sym);\\n            int i = 5;\\n            while (i < n) {\\n                if (exp[i] >= \\'a\\' && exp[i] <= \\'z\\') {\\n                    string var = getVar(exp, i);\\n                    i += (var.length() + 1);\\n                    if (i >= n) {\\n                        res = lookupVar(var);\\n                        break;\\n                    }\\n                    if (exp[i] >= \\'a\\' && exp[i] <= \\'z\\') {\\n                        string v = getVar(exp, i);\\n                        i += (v.length() + 1);\\n                        sym[var] = lookupVar(v);\\n                    } else {\\n                        string str = getExp(exp, i);\\n                        i += (str.length() + 1);\\n                        sym[var] = eval(str);\\n                    }\\n                } else {\\n                    string str = getExp(exp, i);\\n                    i += (str.length() + 1);\\n                    res = eval(str);\\n                }\\n            }\\n            symbols.pop_back();\\n        } else if (exp[1] == \\'a\\') {\\n            int i = 5;\\n            int e1 = 0;\\n            if (exp[i] >= \\'a\\' && exp[i] <= \\'z\\') {\\n                string var = getVar(exp, i);\\n                e1 = lookupVar(var);\\n                i += (var.length() + 1);\\n            } else {\\n                string str = getExp(exp, i);\\n                e1 = eval(str);\\n                i += (str.length() + 1);\\n            }\\n\\n            int e2 = 0;\\n            if (exp[i] >= \\'a\\' && exp[i] <= \\'z\\') {\\n                string var = getVar(exp, i);\\n                e2 = lookupVar(var);\\n            } else {\\n                string str = getExp(exp, i);\\n                e2 = eval(str);\\n            }\\n            res = e1 + e2;\\n        } else {\\n            int i = 6;\\n            int e1 = 0;\\n            if (exp[i] >= \\'a\\' && exp[i] <= \\'z\\') {\\n                string var = getVar(exp, i);\\n                e1 = lookupVar(var);\\n                i += (var.length() + 1);\\n            } else {\\n                string str = getExp(exp, i);\\n                e1 = eval(str);\\n                i += (str.length() + 1);\\n            }\\n\\n            int e2 = 0;\\n            if (exp[i] >= \\'a\\' && exp[i] <= \\'z\\') {\\n                string var = getVar(exp, i);\\n                e2 = lookupVar(var);\\n            } else {\\n                string str = getExp(exp, i);\\n                e2 = eval(str);\\n            }\\n            res = e1 * e2;\\n        }\\n\\n        return res;\\n    }\\npublic:\\n    int evaluate(string expression) {\\n        return eval(expression);\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "solutionTags": [],
                "code": "```\\n#include <string>\\n#include <vector>\\n#include <unordered_map>\\n#include <iostream>\\n\\nusing namespace std;\\n\\nclass Solution {\\n    vector<unordered_map<string, int>*> symbols;\\n\\n    string getVar(string& exp, int start) {\\n        int n = exp.length();\\n\\n        int i = start;\\n        while (i < n && exp[i] != \\' \\' && exp[i] != \\')\\') {\\n            ++i;\\n        }\\n        return exp.substr(start, i - start);\\n    }\\n\\n    string getExp(string& exp, int start) {\\n        int n = exp.length();\\n\\n        if (exp[start] == \\'-\\' || (exp[start] >= \\'0\\' && exp[start] <= \\'9\\')) {\\n            int i = start;\\n            while (i < n && exp[i] != \\' \\' && exp[i] != \\')\\') {\\n                ++i;\\n            }\\n            return exp.substr(start, i - start);\\n        }\\n\\n        int cnt = 0;\\n        int i = start;\\n        while (i < n) {\\n            if (exp[i] == \\'(\\') {\\n                ++cnt;\\n            } else if (exp[i] == \\')\\') {\\n                --cnt;\\n            }\\n\\n            if (cnt == 0) {\\n                break;\\n            }\\n            ++i;\\n        }\\n        return exp.substr(start, i - start + 1);\\n    }\\n\\n    int lookupVar(string& var) {\\n        int n = symbols.size();\\n        for (int i = n - 1; i >= 0; --i) {\\n            auto& tbl = *symbols[i];\\n            if (tbl.find(var) != tbl.end()) {\\n                return tbl[var];\\n            }\\n        }\\n        return -1;\\n    }\\n\\n    int eval(string& exp) {\\n        if (exp[0] == \\'-\\' || (exp[0] >= \\'0\\' && exp[0] <= \\'9\\')) {\\n            return stoi(exp);\\n        }\\n\\n        int n = exp.length();\\n\\n        int res = 0;\\n        if (exp[1] == \\'l\\') {\\n            unordered_map<string, int> sym;\\n            symbols.push_back(&sym);\\n            int i = 5;\\n            while (i < n) {\\n                if (exp[i] >= \\'a\\' && exp[i] <= \\'z\\') {\\n                    string var = getVar(exp, i);\\n                    i += (var.length() + 1);\\n                    if (i >= n) {\\n                        res = lookupVar(var);\\n                        break;\\n                    }\\n                    if (exp[i] >= \\'a\\' && exp[i] <= \\'z\\') {\\n                        string v = getVar(exp, i);\\n                        i += (v.length() + 1);\\n                        sym[var] = lookupVar(v);\\n                    } else {\\n                        string str = getExp(exp, i);\\n                        i += (str.length() + 1);\\n                        sym[var] = eval(str);\\n                    }\\n                } else {\\n                    string str = getExp(exp, i);\\n                    i += (str.length() + 1);\\n                    res = eval(str);\\n                }\\n            }\\n            symbols.pop_back();\\n        } else if (exp[1] == \\'a\\') {\\n            int i = 5;\\n            int e1 = 0;\\n            if (exp[i] >= \\'a\\' && exp[i] <= \\'z\\') {\\n                string var = getVar(exp, i);\\n                e1 = lookupVar(var);\\n                i += (var.length() + 1);\\n            } else {\\n                string str = getExp(exp, i);\\n                e1 = eval(str);\\n                i += (str.length() + 1);\\n            }\\n\\n            int e2 = 0;\\n            if (exp[i] >= \\'a\\' && exp[i] <= \\'z\\') {\\n                string var = getVar(exp, i);\\n                e2 = lookupVar(var);\\n            } else {\\n                string str = getExp(exp, i);\\n                e2 = eval(str);\\n            }\\n            res = e1 + e2;\\n        } else {\\n            int i = 6;\\n            int e1 = 0;\\n            if (exp[i] >= \\'a\\' && exp[i] <= \\'z\\') {\\n                string var = getVar(exp, i);\\n                e1 = lookupVar(var);\\n                i += (var.length() + 1);\\n            } else {\\n                string str = getExp(exp, i);\\n                e1 = eval(str);\\n                i += (str.length() + 1);\\n            }\\n\\n            int e2 = 0;\\n            if (exp[i] >= \\'a\\' && exp[i] <= \\'z\\') {\\n                string var = getVar(exp, i);\\n                e2 = lookupVar(var);\\n            } else {\\n                string str = getExp(exp, i);\\n                e2 = eval(str);\\n            }\\n            res = e1 * e2;\\n        }\\n\\n        return res;\\n    }\\npublic:\\n    int evaluate(string expression) {\\n        return eval(expression);\\n    }\\n};\\n\\n#if DEBUG\\nint main(int argc, char** argv) {\\n    return 0;\\n}\\n#endif\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 135130,
                "title": "c-solution",
                "content": "I have the comments within the code. The key things to consider are :\\n1. Scope of variables - Using a dictionary to maintain the scope of named variables, I create a new one and pass it to the next child scope.\\n2. Special case for Let statements (it has to return a value at the end)\\n\\n```\\npublic class Solution {\\n    public int Evaluate(string expression)\\n        {\\n            int i = 0;\\n            return EvaluateInternal(ref i, expression, new Dictionary<string, int>());\\n        }\\n\\n        public int EvaluateInternal(ref int i, string str, Dictionary<string, int> scopedvalues)\\n        {\\n            if (string.IsNullOrEmpty(str) || i >= str.Length) return 0;\\n            if (str[i] == \\'(\\') i++;\\n            string operation = \"\"; //Find out what operation it is, this remains constant for this frame of recursion.\\n            while (i < str.Length && str[i] != \\' \\')\\n            {\\n                operation += str[i];\\n                i++;\\n            }\\n            i++;\\n            var current_scopedvalues = new Dictionary<string, int>(scopedvalues);//using parents first\\n\\n            while (i < str.Length && str[i] != \\')\\') // Until you reeached the end of expression\\n            {\\n                var args = new object[2]; //There  are always 2 entites involved , only except for let statements when you have to return it\\n                for (int count = 0; count < 2; count++)\\n                {\\n                    if (str[i] == \\'(\\') //It is an expression evaluate it\\n                        args[count] = EvaluateInternal(ref i, str, current_scopedvalues);                    \\n                    else //Either it is a variable like x or a number\\n                    {\\n                        var temp = string.Empty;\\n                        while (i < str.Length && str[i] != \\' \\' && str[i] != \\')\\')\\n                        {\\n                            temp += str[i];\\n                            i++;\\n                        }\\n                        args[count] = temp;\\n                    }\\n\\n                    if (str[i] == \\')\\') break; // If you have reached end, only applicable for let\\n                    i++;\\n                }\\n                switch (operation)\\n                {\\n                    case \"let\":\\n                            if (str[i] == \\')\\')\\n                            {\\n                                i++;\\n                                return GetValue(args[0], current_scopedvalues);\\n                            }\\n                            var variable = args[0].ToString();//For let the first is always a variable\\n                            var value = GetValue(args[1], current_scopedvalues);\\n                            if (current_scopedvalues.ContainsKey(variable))\\n                                current_scopedvalues[variable] = value;\\n                            else\\n                                current_scopedvalues.Add(variable, value);\\n                        break;\\n                    case \"add\":\\n                    case \"mult\":\\n                        var first = GetValue(args[0], current_scopedvalues);\\n                        var second = GetValue(args[1], current_scopedvalues);\\n                        i++;\\n                        if (operation.Equals(\"add\")) return first + second;\\n                        return first * second;\\n                    default:\\n                        break;\\n                }\\n            }\\n            return 0;\\n        }\\n\\t\\t\\t\\t\\n    private int GetValue(object o, Dictionary<string, int> values)\\n        {\\n\\t    //object o must be a number or a variable present in values\\n            int res = 0;\\n            if (int.TryParse(o.ToString(), out res))\\n            {\\n                return res;\\n            }\\n\\n            return values[o.ToString()];\\n        }\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int Evaluate(string expression)\\n        {\\n            int i = 0;\\n            return EvaluateInternal(ref i, expression, new Dictionary<string, int>());\\n        }\\n\\n        public int EvaluateInternal(ref int i, string str, Dictionary<string, int> scopedvalues)\\n        {\\n            if (string.IsNullOrEmpty(str) || i >= str.Length) return 0;\\n            if (str[i] == \\'(\\') i++;\\n            string operation = \"\"; //Find out what operation it is, this remains constant for this frame of recursion.\\n            while (i < str.Length && str[i] != \\' \\')\\n            {\\n                operation += str[i];\\n                i++;\\n            }\\n            i++;\\n            var current_scopedvalues = new Dictionary<string, int>(scopedvalues);//using parents first\\n\\n            while (i < str.Length && str[i] != \\')\\') // Until you reeached the end of expression\\n            {\\n                var args = new object[2]; //There  are always 2 entites involved , only except for let statements when you have to return it\\n                for (int count = 0; count < 2; count++)\\n                {\\n                    if (str[i] == \\'(\\') //It is an expression evaluate it\\n                        args[count] = EvaluateInternal(ref i, str, current_scopedvalues);                    \\n                    else //Either it is a variable like x or a number\\n                    {\\n                        var temp = string.Empty;\\n                        while (i < str.Length && str[i] != \\' \\' && str[i] != \\')\\')\\n                        {\\n                            temp += str[i];\\n                            i++;\\n                        }\\n                        args[count] = temp;\\n                    }\\n\\n                    if (str[i] == \\')\\') break; // If you have reached end, only applicable for let\\n                    i++;\\n                }\\n                switch (operation)\\n                {\\n                    case \"let\":\\n                            if (str[i] == \\')\\')\\n                            {\\n                                i++;\\n                                return GetValue(args[0], current_scopedvalues);\\n                            }\\n                            var variable = args[0].ToString();//For let the first is always a variable\\n                            var value = GetValue(args[1], current_scopedvalues);\\n                            if (current_scopedvalues.ContainsKey(variable))\\n                                current_scopedvalues[variable] = value;\\n                            else\\n                                current_scopedvalues.Add(variable, value);\\n                        break;\\n                    case \"add\":\\n                    case \"mult\":\\n                        var first = GetValue(args[0], current_scopedvalues);\\n                        var second = GetValue(args[1], current_scopedvalues);\\n                        i++;\\n                        if (operation.Equals(\"add\")) return first + second;\\n                        return first * second;\\n                    default:\\n                        break;\\n                }\\n            }\\n            return 0;\\n        }\\n\\t\\t\\t\\t\\n    private int GetValue(object o, Dictionary<string, int> values)\\n        {\\n\\t    //object o must be a number or a variable present in values\\n            int res = 0;\\n            if (int.TryParse(o.ToString(), out res))\\n            {\\n                return res;\\n            }\\n\\n            return values[o.ToString()];\\n        }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109712,
                "title": "short-recursive-solution-with-explanation",
                "content": "As defined in Lisp expression, the expression can be categorized in 3 cases:\\n1. `(add s_1 s_2)` = `s1+s2` \\n1. `(mult s_1 s_2)` = `s1*s2`\\n1. `(let var_1 s_1 ... var_n s_n s)` = `s` with all `var`\\'s replaced by values.\\n\\nNote that each expression string `s` could be a nested Lisp expression, so recursion can be adopted to solve this problem.\\n\\n**Base Case:** when `s` is a single value or single variable, return its value directly.\\n\\n**Recursion:** Cases 1 and 2 are straightforward. For Case 3, by definition, we need to sequentially evaluate each expression `s_i` from left *while maintaining a variable->value dictionary* `dict` (because this is the only case where the value of a variable needs to be recorded for future use)\\n\\nTo split the given expression into tokens, we need to define a parser `next` to return next variable, value or expression from the original string.\\n\\n```cpp\\npublic:    \\n  int evaluate(string s, unordered_map<string,int> dict = unordered_map<string,int>()) \\n  {        \\n      // base case: single variable or single value\\n      if (s[0] != \\'(\\') return isalpha(s[0])? dict[s] : stoi(s);\\n\\n      int i = 1; s.pop_back(); // remove wrapping \"()\"\\n      string op = next(s, i); // operator of current string\\n\\n      if (op == \"let\") { // string: \"let a1 exp1 a2 exp2 finalExp\"\\n        string var;\\n        do {\\n          var = next(s, i);\\n          if (i <= s.size()) dict[var] = evaluate(next(s, i), dict);\\n        }\\n        while (i <= s.size());\\n        \\n        return evaluate(var, dict); // return last expression with dict fully built\\n      }                      \\n      else { // \"add\" or \"mult\" string: \"add exp1 exp2\"\\n          int x1 = evaluate(next(s, i), dict), x2 = evaluate(next(s, i), dict);\\n          return op == \"add\"? x1+x2 : x1*x2;\\n      }\\n  }\\n    \\nprivate:  \\n  // get next token (val, var or expression) starting at index i\\n  // i will be overwritten to new starting index of next token\\n  string next(const string& s,int& i) \\n  {\\n      size_t ii = i;\\n\\n      // token is an expression (need to find matching \\')\\')\\n      if (s[i++] == \\'(\\') {\\n        for (int dif=1; dif; ++i) // dif = count of \\'(\\' - count of \\')\\'\\n          if (s[i] == \\'(\\') dif++;\\n          else if (s[i] == \\')\\') dif--;\\n      }\\n      // token is a var or val (find next \\' \\')\\n      else i = min(s.find(\" \", ii), s.size()); \\n\\n      return s.substr(ii, i++ -ii);\\n  }\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Recursion"
                ],
                "code": "```cpp\\npublic:    \\n  int evaluate(string s, unordered_map<string,int> dict = unordered_map<string,int>()) \\n  {        \\n      // base case: single variable or single value\\n      if (s[0] != \\'(\\') return isalpha(s[0])? dict[s] : stoi(s);\\n\\n      int i = 1; s.pop_back(); // remove wrapping \"()\"\\n      string op = next(s, i); // operator of current string\\n\\n      if (op == \"let\") { // string: \"let a1 exp1 a2 exp2 finalExp\"\\n        string var;\\n        do {\\n          var = next(s, i);\\n          if (i <= s.size()) dict[var] = evaluate(next(s, i), dict);\\n        }\\n        while (i <= s.size());\\n        \\n        return evaluate(var, dict); // return last expression with dict fully built\\n      }                      \\n      else { // \"add\" or \"mult\" string: \"add exp1 exp2\"\\n          int x1 = evaluate(next(s, i), dict), x2 = evaluate(next(s, i), dict);\\n          return op == \"add\"? x1+x2 : x1*x2;\\n      }\\n  }\\n    \\nprivate:  \\n  // get next token (val, var or expression) starting at index i\\n  // i will be overwritten to new starting index of next token\\n  string next(const string& s,int& i) \\n  {\\n      size_t ii = i;\\n\\n      // token is an expression (need to find matching \\')\\')\\n      if (s[i++] == \\'(\\') {\\n        for (int dif=1; dif; ++i) // dif = count of \\'(\\' - count of \\')\\'\\n          if (s[i] == \\'(\\') dif++;\\n          else if (s[i] == \\')\\') dif--;\\n      }\\n      // token is a var or val (find next \\' \\')\\n      else i = min(s.find(\" \", ii), s.size()); \\n\\n      return s.substr(ii, i++ -ii);\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 109719,
                "title": "java-solution-with-explanation",
                "content": " First, we need to parse the string with parenthese and space. e.g. (add 1 2)->{\"(\",\"add\",\"1\",\"2\",\")\"};\\n Then we start processing the expression. In this process, we use one stack to store operators, and use another one to store all the other strings. Everytime when a String \")\" comes in, we know that one inner expression is closed here, then we can evaluate it. After we are done, we replace the inner expression with this result, or return it if no operator left.\\n```\\nclass Solution {\\n    public int evaluate(String expression) {\\n        String[] expr=parse(expression);  // parse\\n        Stack<String> st=new Stack<>();\\n        Stack<String> op=new Stack<>();\\n        st.push(expr[0]);\\n        for(int i=1;i<expr.length;i++){\\n            if(expr[i-1].equals(\"(\")){\\n                op.push(expr[i]);\\n            }\\n            \\n// when \")\" comes in, evaluate the inner expression. If the variable is not an integer, we search for its value in the stack from top to bottom.\\n            else if(expr[i].equals(\")\")){\\n                String operator=op.pop();\\n                int ans;\\n                if(operator.equals(\"let\")){\\n                    String tmp=st.pop();\\n                    if(!isInteger(tmp)) tmp=findValue(st,tmp);\\n                    ans=Integer.parseInt(tmp);\\n                    while(!st.peek().equals(\"(\")) st.pop();\\n                    st.pop();\\n                }\\n                else{\\n                    String s1=st.pop();\\n                    String s2=st.pop();\\n                    st.pop();\\n                    if(!isInteger(s1)) s1=findValue(st,s1);\\n                    if(!isInteger(s2)) s2=findValue(st,s2);\\n                    if(operator.equals(\"add\")){\\n                        ans=Integer.parseInt(s1)+Integer.parseInt(s2);\\n                    }else{\\n                        ans=Integer.parseInt(s1)*Integer.parseInt(s2);\\n                    }\\n                } \\n                if(op.isEmpty()) return ans;\\n                else st.push(String.valueOf(ans));\\n            }\\n            else st.push(expr[i]);   \\n        }\\n        return 0;\\n    }\\n    private String[] parse(String expression){\\n        List<String> result=new ArrayList<>();\\n        int start=0;\\n        for(int i=0;i<expression.length();i++){\\n            if(expression.charAt(i)=='('){\\n                result.add(expression.substring(i,i+1));\\n                start=i+1;\\n            }\\n            if(expression.charAt(i)==')'){\\n                if(expression.charAt(i-1)!=')') result.add(expression.substring(start,i));\\n                result.add(expression.substring(i,i+1));\\n                start=i+1;                \\n            }\\n            if(expression.charAt(i)==' '){\\n                if(expression.charAt(i-1)!=')') result.add(expression.substring(start,i));\\n                start=i+1;\\n            }\\n        }\\n        return result.toArray(new String[result.size()]);\\n    }\\n// check whether a String is an integer\\n    private boolean isInteger(String s){\\n        try{\\n            Integer.parseInt(s);\\n        }catch(NumberFormatException e){\\n            return false;\\n        }catch(NullPointerException e){\\n            return false;\\n        }\\n        return true;\\n    }\\n// search for the value of non-integer String from top to bottom\\n    private String findValue(Stack<String> st, String s){\\n        List<String> ls=new ArrayList<>(st);\\n        for(int j=ls.size()-2;j>=0;j--){\\n            if(ls.get(j).equals(s)){\\n                s=ls.get(j+1);\\n                if(isInteger(s)) return s;\\n            }\\n        } \\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int evaluate(String expression) {\\n        String[] expr=parse(expression);  // parse\\n        Stack<String> st=new Stack<>();\\n        Stack<String> op=new Stack<>();\\n        st.push(expr[0]);\\n        for(int i=1;i<expr.length;i++){\\n            if(expr[i-1].equals(\"(\")){\\n                op.push(expr[i]);\\n            }\\n            \\n// when \")\" comes in, evaluate the inner expression. If the variable is not an integer, we search for its value in the stack from top to bottom.\\n            else if(expr[i].equals(\")\")){\\n                String operator=op.pop();\\n                int ans;\\n                if(operator.equals(\"let\")){\\n                    String tmp=st.pop();\\n                    if(!isInteger(tmp)) tmp=findValue(st,tmp);\\n                    ans=Integer.parseInt(tmp);\\n                    while(!st.peek().equals(\"(\")) st.pop();\\n                    st.pop();\\n                }\\n                else{\\n                    String s1=st.pop();\\n                    String s2=st.pop();\\n                    st.pop();\\n                    if(!isInteger(s1)) s1=findValue(st,s1);\\n                    if(!isInteger(s2)) s2=findValue(st,s2);\\n                    if(operator.equals(\"add\")){\\n                        ans=Integer.parseInt(s1)+Integer.parseInt(s2);\\n                    }else{\\n                        ans=Integer.parseInt(s1)*Integer.parseInt(s2);\\n                    }\\n                } \\n                if(op.isEmpty()) return ans;\\n                else st.push(String.valueOf(ans));\\n            }\\n            else st.push(expr[i]);   \\n        }\\n        return 0;\\n    }\\n    private String[] parse(String expression){\\n        List<String> result=new ArrayList<>();\\n        int start=0;\\n        for(int i=0;i<expression.length();i++){\\n            if(expression.charAt(i)=='('){\\n                result.add(expression.substring(i,i+1));\\n                start=i+1;\\n            }\\n            if(expression.charAt(i)==')'){\\n                if(expression.charAt(i-1)!=')') result.add(expression.substring(start,i));\\n                result.add(expression.substring(i,i+1));\\n                start=i+1;                \\n            }\\n            if(expression.charAt(i)==' '){\\n                if(expression.charAt(i-1)!=')') result.add(expression.substring(start,i));\\n                start=i+1;\\n            }\\n        }\\n        return result.toArray(new String[result.size()]);\\n    }\\n// check whether a String is an integer\\n    private boolean isInteger(String s){\\n        try{\\n            Integer.parseInt(s);\\n        }catch(NumberFormatException e){\\n            return false;\\n        }catch(NullPointerException e){\\n            return false;\\n        }\\n        return true;\\n    }\\n// search for the value of non-integer String from top to bottom\\n    private String findValue(Stack<String> st, String s){\\n        List<String> ls=new ArrayList<>(st);\\n        for(int j=ls.size()-2;j>=0;j--){\\n            if(ls.get(j).equals(s)){\\n                s=ls.get(j+1);\\n                if(isInteger(s)) return s;\\n            }\\n        } \\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109723,
                "title": "python-recursion-no-stack-with-explanations",
                "content": "I defined five functions for structural clearness: `isnum`, `find`, `helper`, `compute`, `let`.\\n\\n`isnum` is to check if the given string is composed of numbers.\\n\\n`find` is to go along `expression` and find the next object and evaluate it\\n\\n`helper` is a task-assigner. It assigns tasks depends on whether the operator is `let` or not.\\n\\n`compute` is to do addition or multiplication.\\n\\n`let` is to execute 'let' operation. Note that there is a nonlocal dictionary `values` that is accessible everywhere in the program. To handle different layer of value assignment, a local dictionary `changed` is established. Before returning the result of `let` function, `changed` is used to recover the `values` before executing the current `let`.\\n\\nThe program keeps going forward, never turn back, and only passes indices when doing recursion, so it is O(n) and should be pretty fast.\\n\\n```\\n        def isnum(s):     # check if s is composed of numbers\\n            try:\\n                int(s)\\n                return True\\n            except:\\n                return False\\n\\n        def find(start, need_num = True): # find the next expression and evaluate it\\n            # need_num is to indicate whether numeric answer is preferred\\n            \\n            if expression[start] == '(':\\n                return helper(start+1)\\n            else:\\n                i = start\\n                while expression[i] not in ' )':\\n                    i += 1\\n                    \\n                ans = expression[start:i]\\n\\n                return (int(ans) if isnum(ans) \\\\\\n                                 else values[ans] if need_num \\\\\\n                                                  else ans, \\\\\\n                        i-1)\\n                    \\n        def helper(start):        # return the answer and the index of the ending ')'\\n            i = start\\n            while expression[i] != ' ':\\n                i += 1\\n            \\n            op = expression[start:i]\\n            if op == 'let':\\n                return let(i+1)\\n            else:                 # op is either 'add' or 'mult'\\n                return compute(i+1, op)\\n        \\n        def compute(start, op):   # return the answer and the index of the ending ')'\\n            x, i = find(start)\\n            y, j = find(i+2)\\n            \\n            return ( x+y if op=='add' else x*y, j+1 )\\n        \\n        def let(start):           # return the answer and the index of the ending ')'  \\n            changed = {}          # this is to record those values changed in the current 'let'\\n\\n            while True:\\n                x, i = find(start, False)\\n                \\n                if expression[i+1] == ')':      # the end of 'let' expression is reached \\n                    temp = (values[x] if x in values else x, i+1)\\n\\n                    for x in changed:           # this is to discard the changes we made to 'values' in the current 'let'\\n                        if changed[x] != None:\\n                            values[x] = changed[x]\\n                        else:\\n                            del values[x]\\n\\n                    return temp\\n                \\n                y, j = find(i+2)\\n\\n                changed[x] = values[x] if x in values else None\\n                values[x] = y\\n                \\n                start = j + 2\\n        \\n        values = {}\\n        return helper(1)[0] \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n        def isnum(s):     # check if s is composed of numbers\\n            try:\\n                int(s)\\n                return True\\n            except:\\n                return False\\n\\n        def find(start, need_num = True): # find the next expression and evaluate it\\n            # need_num is to indicate whether numeric answer is preferred\\n            \\n            if expression[start] == '(':\\n                return helper(start+1)\\n            else:\\n                i = start\\n                while expression[i] not in ' )':\\n                    i += 1\\n                    \\n                ans = expression[start:i]\\n\\n                return (int(ans) if isnum(ans) \\\\\\n                                 else values[ans] if need_num \\\\\\n                                                  else ans, \\\\\\n                        i-1)\\n                    \\n        def helper(start):        # return the answer and the index of the ending ')'\\n            i = start\\n            while expression[i] != ' ':\\n                i += 1\\n            \\n            op = expression[start:i]\\n            if op == 'let':\\n                return let(i+1)\\n            else:                 # op is either 'add' or 'mult'\\n                return compute(i+1, op)\\n        \\n        def compute(start, op):   # return the answer and the index of the ending ')'\\n            x, i = find(start)\\n            y, j = find(i+2)\\n            \\n            return ( x+y if op=='add' else x*y, j+1 )\\n        \\n        def let(start):           # return the answer and the index of the ending ')'  \\n            changed = {}          # this is to record those values changed in the current 'let'\\n\\n            while True:\\n                x, i = find(start, False)\\n                \\n                if expression[i+1] == ')':      # the end of 'let' expression is reached \\n                    temp = (values[x] if x in values else x, i+1)\\n\\n                    for x in changed:           # this is to discard the changes we made to 'values' in the current 'let'\\n                        if changed[x] != None:\\n                            values[x] = changed[x]\\n                        else:\\n                            del values[x]\\n\\n                    return temp\\n                \\n                y, j = find(i+2)\\n\\n                changed[x] = values[x] if x in values else None\\n                values[x] = y\\n                \\n                start = j + 2\\n        \\n        values = {}\\n        return helper(1)[0] \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 109733,
                "title": "python-easy-to-understand-recursive-solution",
                "content": "This is not the fastest way but very straight-forward to understand.\\n``` python\\nfrom typing import Dict\\n\\nclass Solution:\\n    def evaluate(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: int\\n        \"\"\"\\n        return self.eval_with_env(expression, {})\\n\\n    def match_parenthesis(self, expression : str) -> Dict[int, int]:\\n        parenthesis = {}\\n        stack = []\\n        for i in range(len(expression)):\\n            if expression[i] == '(':\\n                stack.append(i)\\n            elif expression[i] == ')':\\n                j = stack.pop()\\n                parenthesis[j] = i\\n        return parenthesis\\n\\n    def eval_with_env(self, expr : str, env : Dict[str, int]) -> int:\\n        if expr.startswith('('):\\n            parenthesis = self.match_parenthesis(expr)\\n            if expr.startswith(\"add\", 1): # (add operand1 operand2)\\n                if expr[5].isalpha() or expr[5].isnumeric() or expr[5] == '-':\\n                    sub_expr = expr[5:-1] # type: str\\n                    operand_1, operand_2 = sub_expr.split(\" \", 1)\\n                    return self.eval_with_env(operand_1, env.copy()) + self.eval_with_env(operand_2, env.copy())\\n                elif expr[5] == '(':\\n                    operand_1 = expr[5:parenthesis[5]+1]\\n                    operand_2 = expr[parenthesis[5]+2:-1]\\n                    return self.eval_with_env(operand_1, env.copy()) + self.eval_with_env(operand_2, env.copy())\\n            elif expr.startswith(\"mult\", 1): # (mult operand1 operand2)\\n                if expr[6].isalpha() or expr[6].isnumeric() or expr[6] == '-':\\n                    sub_expr = expr[6:-1] # type: str\\n                    operand_1, operand_2 = sub_expr.split(\" \", 1)\\n                    return self.eval_with_env(operand_1, env.copy()) * self.eval_with_env(operand_2, env.copy())\\n                elif expr[6] == '(':\\n                    operand_1 = expr[6:parenthesis[6]+1]\\n                    operand_2 = expr[parenthesis[6]+2:-1]\\n                    return self.eval_with_env(operand_1, env.copy()) * self.eval_with_env(operand_2, env.copy())\\n            elif expr.startswith(\"let\", 1): # (let identifier expr ... expr)\\n                rest = expr[5:-1]\\n                while True:\\n\\n                    identifier, rest = rest.split(\" \", 1) # type: str, str\\n\\n                    if rest[0].isnumeric() or rest[0] == '-':\\n                        value, rest = rest.split(\" \", 1)\\n                        env[identifier] = int(value)\\n                    elif rest[0].isalpha():\\n                        sub_expr, rest = rest.split(\" \", 1)\\n                        env[identifier] = self.eval_with_env(sub_expr, env.copy())\\n                    elif rest[0] == '(':\\n                        close_parenthesis_pos = self.match_parenthesis(rest)[0]\\n                        sub_expr = rest[:close_parenthesis_pos+1]\\n                        rest = rest[close_parenthesis_pos+2:]\\n                        env[identifier] = self.eval_with_env(sub_expr, env.copy())\\n\\n                    if rest[0] == '(' or rest[0].isnumeric() or  rest[0] == '-' or \\\\\\n                            (rest[0].isalpha() and rest.find(\" \") == -1):\\n                        return self.eval_with_env(rest, env.copy())\\n\\n        elif expr[0].isnumeric() or expr[0] == '-':\\n            return int(expr)\\n        elif expr[0].isalpha():\\n            expr = expr.strip()\\n            return env[expr]\\n```",
                "solutionTags": [],
                "code": "``` python\\nfrom typing import Dict\\n\\nclass Solution:\\n    def evaluate(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: int\\n        \"\"\"\\n        return self.eval_with_env(expression, {})\\n\\n    def match_parenthesis(self, expression : str) -> Dict[int, int]:\\n        parenthesis = {}\\n        stack = []\\n        for i in range(len(expression)):\\n            if expression[i] == '(':\\n                stack.append(i)\\n            elif expression[i] == ')':\\n                j = stack.pop()\\n                parenthesis[j] = i\\n        return parenthesis\\n\\n    def eval_with_env(self, expr : str, env : Dict[str, int]) -> int:\\n        if expr.startswith('('):\\n            parenthesis = self.match_parenthesis(expr)\\n            if expr.startswith(\"add\", 1): # (add operand1 operand2)\\n                if expr[5].isalpha() or expr[5].isnumeric() or expr[5] == '-':\\n                    sub_expr = expr[5:-1] # type: str\\n                    operand_1, operand_2 = sub_expr.split(\" \", 1)\\n                    return self.eval_with_env(operand_1, env.copy()) + self.eval_with_env(operand_2, env.copy())\\n                elif expr[5] == '(':\\n                    operand_1 = expr[5:parenthesis[5]+1]\\n                    operand_2 = expr[parenthesis[5]+2:-1]\\n                    return self.eval_with_env(operand_1, env.copy()) + self.eval_with_env(operand_2, env.copy())\\n            elif expr.startswith(\"mult\", 1): # (mult operand1 operand2)\\n                if expr[6].isalpha() or expr[6].isnumeric() or expr[6] == '-':\\n                    sub_expr = expr[6:-1] # type: str\\n                    operand_1, operand_2 = sub_expr.split(\" \", 1)\\n                    return self.eval_with_env(operand_1, env.copy()) * self.eval_with_env(operand_2, env.copy())\\n                elif expr[6] == '(':\\n                    operand_1 = expr[6:parenthesis[6]+1]\\n                    operand_2 = expr[parenthesis[6]+2:-1]\\n                    return self.eval_with_env(operand_1, env.copy()) * self.eval_with_env(operand_2, env.copy())\\n            elif expr.startswith(\"let\", 1): # (let identifier expr ... expr)\\n                rest = expr[5:-1]\\n                while True:\\n\\n                    identifier, rest = rest.split(\" \", 1) # type: str, str\\n\\n                    if rest[0].isnumeric() or rest[0] == '-':\\n                        value, rest = rest.split(\" \", 1)\\n                        env[identifier] = int(value)\\n                    elif rest[0].isalpha():\\n                        sub_expr, rest = rest.split(\" \", 1)\\n                        env[identifier] = self.eval_with_env(sub_expr, env.copy())\\n                    elif rest[0] == '(':\\n                        close_parenthesis_pos = self.match_parenthesis(rest)[0]\\n                        sub_expr = rest[:close_parenthesis_pos+1]\\n                        rest = rest[close_parenthesis_pos+2:]\\n                        env[identifier] = self.eval_with_env(sub_expr, env.copy())\\n\\n                    if rest[0] == '(' or rest[0].isnumeric() or  rest[0] == '-' or \\\\\\n                            (rest[0].isalpha() and rest.find(\" \") == -1):\\n                        return self.eval_with_env(rest, env.copy())\\n\\n        elif expr[0].isnumeric() or expr[0] == '-':\\n            return int(expr)\\n        elif expr[0].isalpha():\\n            expr = expr.strip()\\n            return env[expr]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109737,
                "title": "did-you-create-hash-in-every-call-you-lose-6ms",
                "content": "I use up-query linked list, got this idea from my compilers class....\\n\\n    struct Q {\\n        Q* up;\\n        unordered_map<string, int> m;\\n        bool get(string n, int* v = nullptr) {\\n            if (m.count(n)) {\\n                if (v) *v = m[n];\\n                return true;\\n            }\\n            if (up) return up->get(n, v);\\n            return false;\\n        }\\n    \\n        void set(string n, int v) {\\n            m[n] = v;\\n        }\\n    \\n        Q(Q* up = nullptr) : up(up) {};\\n    };\\n    \\n    class Solution {\\n    public:\\n        int evaluate(string expression) {\\n            string::iterator b = expression.begin();\\n            Q q;\\n            return evaluate(b, expression.end(), &q);\\n        }\\n    \\n        int evaluate(string::iterator& b, string::iterator e, Q* q) {\\n            string f = next(b, e);\\n            if (f != \"(\") {\\n                int v;\\n                if (q->get(f, &v)) return v;\\n                return stol(f);\\n            }\\n    \\n            string op = next(b, e);\\n            int result = 0;\\n            if (op == \"add\") {\\n                int x = evaluate(b, e, q);\\n                int y = evaluate(b, e, q);\\n                result = x + y;\\n    \\n            } else if (op == \"mult\") {\\n                int x = evaluate(b, e, q);\\n                int y = evaluate(b, e, q);\\n                result = x * y;\\n    \\n            } else if (op == \"let\") {\\n                Q local(q);\\n                while (true) {\\n                    string var = next(b, e);\\n                    if (var[0] == '(' || var[0] == '-' || isdigit(var[0])) {\\n                        b -= var.size();\\n                        result = evaluate(b, e, &local);\\n                        break;\\n                    }\\n                    if (local.m.count(var)) {\\n                        string vval = next(b, e);\\n                        b -= vval.size();\\n                        if (vval == \")\") {\\n                            local.get(var, &result);\\n                            break;\\n                        }\\n                    }\\n                    int val = evaluate(b, e, &local);\\n                    local.set(var, val);\\n                }\\n            } else {\\n                result = stol(op);\\n    \\n            }\\n            next(b, e); // )\\n            return result;\\n        }\\n    \\n        string next(string::iterator& b, string::iterator e) {\\n            if (b == e) return \"\";\\n            while (*b == ' ') ++b;\\n            if (*b == '(') {\\n                ++b;\\n                return \"(\";\\n            }\\n            if (*b == ')') {\\n                ++b ;\\n                return \")\";\\n            }\\n            while (*b == ' ') ++b;\\n            string ret;\\n            while (*b != ' ' && *b != ')') ret.push_back(*b++);\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int evaluate(string expression) {\\n            string::iterator b = expression.begin();\\n            Q q;\\n            return evaluate(b, expression.end(), &q);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 109739,
                "title": "java-recursion-solution",
                "content": "```\\nclass Solution {\\n    public int evaluate(String expression) {\\n        return evaluate(expression.replace(\"))\", \") )\").replace(\"))\", \") )\"), null);\\n    }\\n\\n    private int evaluate(String exp, LinkedMap<String, Integer> outer) {\\n        String[] tokens = split(exp);\\n        if (tokens.length == 1) {\\n            if (Character.isLetter(exp.charAt(0))) {\\n                return outer.get(tokens[0]);\\n            } else {\\n                return Integer.parseInt(tokens[0]);\\n            }\\n        } else if (tokens[0].equals(\"add\")) {\\n            return evaluate(tokens[1], outer) + evaluate(tokens[2], outer);\\n        } else if (tokens[0].equals(\"mult\")) {\\n            return evaluate(tokens[1], outer) * evaluate(tokens[2], outer);\\n        } else if (tokens[0].equals(\"let\")) {\\n            LinkedMap<String, Integer> lm = new LinkedMap<>(outer);\\n            for (int i = 1; i < tokens.length - 1; i += 2) {\\n                lm.put(tokens[i], evaluate(tokens[i + 1], lm));\\n            }\\n            return evaluate(tokens[tokens.length - 1], lm);\\n        } else {\\n            throw new RuntimeException();\\n        }\\n    }\\n    \\n    private String[] split(String exp) {\\n        if (exp.charAt(0) != '(') {\\n            return new String[] {exp};\\n        }\\n        String[] tokens = exp.substring(1, exp.length() - 1).split(\" \");\\n        List<String> output = new ArrayList<>();\\n        int p = 0;\\n        List<String> temp = new ArrayList<String>();\\n        for (String t : tokens) {\\n            if (t.startsWith(\"(\")) {\\n                p++;\\n            } else if (t.endsWith(\")\")) {\\n                p--;\\n            }\\n            temp.add(t);\\n            if (p == 0) {\\n                output.add(String.join(\" \", temp));\\n                temp = new ArrayList<>();\\n            }\\n        }\\n        return output.toArray(new String[0]);\\n    }\\n    \\n    private class LinkedMap<K, V> {\\n        HashMap<K, V> m = new HashMap<K, V>();\\n        LinkedMap<K, V> outer;\\n        public LinkedMap(LinkedMap<K, V> outer) {\\n            this.outer = outer;\\n        }\\n        public void put(K k, V v) {\\n            m.put(k, v);\\n        }\\n        public V get(K k) {\\n            LinkedMap<K, V> lm = this;\\n            while (!lm.m.containsKey(k)) {\\n                lm = lm.outer;\\n            }\\n            return lm.m.get(k);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int evaluate(String expression) {\\n        return evaluate(expression.replace(\"))\", \") )\").replace(\"))\", \") )\"), null);\\n    }\\n\\n    private int evaluate(String exp, LinkedMap<String, Integer> outer) {\\n        String[] tokens = split(exp);\\n        if (tokens.length == 1) {\\n            if (Character.isLetter(exp.charAt(0))) {\\n                return outer.get(tokens[0]);\\n            } else {\\n                return Integer.parseInt(tokens[0]);\\n            }\\n        } else if (tokens[0].equals(\"add\")) {\\n            return evaluate(tokens[1], outer) + evaluate(tokens[2], outer);\\n        } else if (tokens[0].equals(\"mult\")) {\\n            return evaluate(tokens[1], outer) * evaluate(tokens[2], outer);\\n        } else if (tokens[0].equals(\"let\")) {\\n            LinkedMap<String, Integer> lm = new LinkedMap<>(outer);\\n            for (int i = 1; i < tokens.length - 1; i += 2) {\\n                lm.put(tokens[i], evaluate(tokens[i + 1], lm));\\n            }\\n            return evaluate(tokens[tokens.length - 1], lm);\\n        } else {\\n            throw new RuntimeException();\\n        }\\n    }\\n    \\n    private String[] split(String exp) {\\n        if (exp.charAt(0) != '(') {\\n            return new String[] {exp};\\n        }\\n        String[] tokens = exp.substring(1, exp.length() - 1).split(\" \");\\n        List<String> output = new ArrayList<>();\\n        int p = 0;\\n        List<String> temp = new ArrayList<String>();\\n        for (String t : tokens) {\\n            if (t.startsWith(\"(\")) {\\n                p++;\\n            } else if (t.endsWith(\")\")) {\\n                p--;\\n            }\\n            temp.add(t);\\n            if (p == 0) {\\n                output.add(String.join(\" \", temp));\\n                temp = new ArrayList<>();\\n            }\\n        }\\n        return output.toArray(new String[0]);\\n    }\\n    \\n    private class LinkedMap<K, V> {\\n        HashMap<K, V> m = new HashMap<K, V>();\\n        LinkedMap<K, V> outer;\\n        public LinkedMap(LinkedMap<K, V> outer) {\\n            this.outer = outer;\\n        }\\n        public void put(K k, V v) {\\n            m.put(k, v);\\n        }\\n        public V get(K k) {\\n            LinkedMap<K, V> lm = this;\\n            while (!lm.m.containsKey(k)) {\\n                lm = lm.outer;\\n            }\\n            return lm.m.get(k);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 109740,
                "title": "javascript-solution-with-recursion-stacks-regular-expressions-and-hash-table-to-implement-the-scope",
                "content": "Managed to submit an accepted solution just 2 minutes after the contest ended!\\n\\n```\\nfunction isDigitsOnly(exp){\\n    return /^-?\\\\d+$/.test(exp);\\n}\\n\\nfunction isVar(exp){\\n    return /^[a-z]([a-z]|\\\\d)*$/.test(exp);\\n}\\n\\nfunction parseForward(exp){\\n    if (exp === ''){\\n        return null;\\n    }\\n\\n    if (exp.charAt(0) === '('){\\n        const S = ['('];\\n        let i = 1;\\n\\n        while (S.length){\\n            const c = exp.charAt(i);\\n\\n            if (c === '('){\\n                S.push('(');\\n            }\\n            \\n            if (c === ')'){\\n                S.pop();\\n            }\\n            \\n            i++;\\n        }\\n\\n        return exp.slice(0, i);\\n    }\\n    else {\\n        return exp.split(' ')[0];\\n    }\\n}\\n\\nfunction parseBackward(exp){\\n    if (exp.charAt(exp.length - 1) === ')'){\\n        const S = [')'];\\n        let i = exp.length - 2;\\n\\n        while (S.length){\\n            const c = exp.charAt(i);\\n\\n            if (c === ')'){\\n                S.push(')');\\n            }\\n            \\n            if (c === '('){\\n                S.pop();\\n            }\\n            \\n            i--;\\n        }\\n\\n        return exp.slice(i + 1);\\n    }\\n    else {\\n        const tmp = exp.split(' ');\\n        return tmp[tmp.length - 1];\\n    }\\n}\\n\\nfunction helper(exp, vars){\\n    ///console.log('eval', exp)\\n    \\n    if (isDigitsOnly(exp)){\\n        //console.log('num', exp);\\n        return Number(exp);\\n    }\\n\\n    if (isVar(exp)){\\n        return vars.get(exp);\\n    }\\n\\n    exp = exp.slice(1, exp.length - 1);\\n\\n    if (exp.startsWith('add')){\\n        exp = exp.slice(4);\\n\\n        let e1 = parseForward(exp);\\n        let e2 = parseBackward(exp);\\n\\n        console.log(e1, '+', e2);\\n\\n        return helper(e1, vars) + helper(e2, vars);\\n    }\\n    else if (exp.startsWith('mult')){\\n        exp = exp.slice(5);\\n\\n        let e1 = parseForward(exp);\\n        let e2 = parseBackward(exp);\\n\\n        // console.log(e1, '*', e2);\\n        \\n        return helper(e1, vars) * helper(e2, vars);\\n    }\\n    else {\\n        // let\\n        exp = exp.slice(4);\\n\\n        const scope = new Map(vars);\\n\\n        let v = parseForward(exp);\\n        exp = exp.slice(v.length + 1);\\n        \\n        let e = parseForward(exp);\\n        exp = exp.slice(e.length + 1);\\n        \\n        while (e){\\n            // console.log(v, e);\\n            scope.set(v, helper(e, scope));\\n            // console.log(v, scope.get(v));\\n\\n            v = parseForward(exp);\\n            exp = exp.slice(v.length + 1);\\n        \\n            e = parseForward(exp);\\n\\n            if (e){\\n                exp = exp.slice(e.length + 1);\\n            }\\n        }\\n\\n        return helper(v, scope);\\n    }\\n}\\n\\n/**\\n * @param {string} expression\\n * @return {number}\\n */\\nvar evaluate = function(expression) {\\n    return helper(expression, new Map());\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nfunction isDigitsOnly(exp){\\n    return /^-?\\\\d+$/.test(exp);\\n}\\n\\nfunction isVar(exp){\\n    return /^[a-z]([a-z]|\\\\d)*$/.test(exp);\\n}\\n\\nfunction parseForward(exp){\\n    if (exp === ''){\\n        return null;\\n    }\\n\\n    if (exp.charAt(0) === '('){\\n        const S = ['('];\\n        let i = 1;\\n\\n        while (S.length){\\n            const c = exp.charAt(i);\\n\\n            if (c === '('){\\n                S.push('(');\\n            }\\n            \\n            if (c === ')'){\\n                S.pop();\\n            }\\n            \\n            i++;\\n        }\\n\\n        return exp.slice(0, i);\\n    }\\n    else {\\n        return exp.split(' ')[0];\\n    }\\n}\\n\\nfunction parseBackward(exp){\\n    if (exp.charAt(exp.length - 1) === ')'){\\n        const S = [')'];\\n        let i = exp.length - 2;\\n\\n        while (S.length){\\n            const c = exp.charAt(i);\\n\\n            if (c === ')'){\\n                S.push(')');\\n            }\\n            \\n            if (c === '('){\\n                S.pop();\\n            }\\n            \\n            i--;\\n        }\\n\\n        return exp.slice(i + 1);\\n    }\\n    else {\\n        const tmp = exp.split(' ');\\n        return tmp[tmp.length - 1];\\n    }\\n}\\n\\nfunction helper(exp, vars){\\n    ///console.log('eval', exp)\\n    \\n    if (isDigitsOnly(exp)){\\n        //console.log('num', exp);\\n        return Number(exp);\\n    }\\n\\n    if (isVar(exp)){\\n        return vars.get(exp);\\n    }\\n\\n    exp = exp.slice(1, exp.length - 1);\\n\\n    if (exp.startsWith('add')){\\n        exp = exp.slice(4);\\n\\n        let e1 = parseForward(exp);\\n        let e2 = parseBackward(exp);\\n\\n        console.log(e1, '+', e2);\\n\\n        return helper(e1, vars) + helper(e2, vars);\\n    }\\n    else if (exp.startsWith('mult')){\\n        exp = exp.slice(5);\\n\\n        let e1 = parseForward(exp);\\n        let e2 = parseBackward(exp);\\n\\n        // console.log(e1, '*', e2);\\n        \\n        return helper(e1, vars) * helper(e2, vars);\\n    }\\n    else {\\n        // let\\n        exp = exp.slice(4);\\n\\n        const scope = new Map(vars);\\n\\n        let v = parseForward(exp);\\n        exp = exp.slice(v.length + 1);\\n        \\n        let e = parseForward(exp);\\n        exp = exp.slice(e.length + 1);\\n        \\n        while (e){\\n            // console.log(v, e);\\n            scope.set(v, helper(e, scope));\\n            // console.log(v, scope.get(v));\\n\\n            v = parseForward(exp);\\n            exp = exp.slice(v.length + 1);\\n        \\n            e = parseForward(exp);\\n\\n            if (e){\\n                exp = exp.slice(e.length + 1);\\n            }\\n        }\\n\\n        return helper(v, scope);\\n    }\\n}\\n\\n/**\\n * @param {string} expression\\n * @return {number}\\n */\\nvar evaluate = function(expression) {\\n    return helper(expression, new Map());\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056891,
                "title": "js-ts-solution-with-regexes-46ms-beats-100-as-of-now",
                "content": "# Intuition\\nAs I\\'ve already told in [previous solution](https://leetcode.com/problems/parse-lisp-expression/solutions/4056769/converting-to-json-with-string-manipulation-and-using-built-in-json-parse-beats-100-ts-and-js/), LISP is awful lot like JSON. But this time instead of splitting to real tokens and manipulating strings, we are using regexes.\\n\\n# Approach\\n1. Replace parentheses with brackets\\n2. Wrap words starting with lowercase letter in quotation marks\\n3. Replace sequences of whitespace characters with commas\\n4. It\\'s somehow proper JSON at this step, thanks to the fact that there are no spaces in test expressions where commas shouldn\\'t be in JSON (like after opening and before closing parentheses) \\n5. JSON.parse and then evaluate, that\\'s trivial\\n\\n# Complexity\\nTotally depends on how regexes and JSON.parse are implemented in v8/engine of your choice. Evaluating code itself is $$O(n)$$, I believe.\\n\\n# Code\\n```ts\\nfunction compute(expression: any, scope: Record<string, number>): number {\\n  if (typeof expression === \"number\") {\\n    return expression;\\n  }\\n\\n  if (typeof expression === \"string\") {\\n    return scope[expression];\\n  }\\n\\n  switch(expression[0]) {\\n    case \"let\": {\\n      const nextScope = { ...scope };\\n      for (let i = 1; i < expression.length - 1; i += 2) {\\n        let name = expression[i];\\n        let value = compute(expression[i + 1], nextScope);\\n        nextScope[name] = value;\\n      }\\n      return compute(expression[expression.length - 1], nextScope);\\n    }\\n    case \"add\": return compute(expression[1], scope) + compute(expression[2], scope);\\n    case \"mult\": return compute(expression[1], scope) * compute(expression[2], scope);\\n    default: throw new Error(`Wrong expression: ${JSON.stringify(expression)}`);\\n  }\\n}\\n\\nfunction evaluate(expression: string): number {\\n  const json = expression\\n    .replace(/\\\\(/g, \"[\")\\n    .replace(/\\\\)/g, \"]\")\\n    .replace(/\\\\b([a-z][a-z0-9]*)\\\\b/g, (_, $1) => `\"${$1}\"`)\\n    .replace(/\\\\s+/g, \",\");\\n  const parsed = JSON.parse(json);\\n  return compute(parsed, {});\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "String"
                ],
                "code": "```ts\\nfunction compute(expression: any, scope: Record<string, number>): number {\\n  if (typeof expression === \"number\") {\\n    return expression;\\n  }\\n\\n  if (typeof expression === \"string\") {\\n    return scope[expression];\\n  }\\n\\n  switch(expression[0]) {\\n    case \"let\": {\\n      const nextScope = { ...scope };\\n      for (let i = 1; i < expression.length - 1; i += 2) {\\n        let name = expression[i];\\n        let value = compute(expression[i + 1], nextScope);\\n        nextScope[name] = value;\\n      }\\n      return compute(expression[expression.length - 1], nextScope);\\n    }\\n    case \"add\": return compute(expression[1], scope) + compute(expression[2], scope);\\n    case \"mult\": return compute(expression[1], scope) * compute(expression[2], scope);\\n    default: throw new Error(`Wrong expression: ${JSON.stringify(expression)}`);\\n  }\\n}\\n\\nfunction evaluate(expression: string): number {\\n  const json = expression\\n    .replace(/\\\\(/g, \"[\")\\n    .replace(/\\\\)/g, \"]\")\\n    .replace(/\\\\b([a-z][a-z0-9]*)\\\\b/g, (_, $1) => `\"${$1}\"`)\\n    .replace(/\\\\s+/g, \",\");\\n  const parsed = JSON.parse(json);\\n  return compute(parsed, {});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4056769,
                "title": "converting-to-json-with-string-manipulation-and-using-built-in-json-parse-beats-100-ts-and-js",
                "content": "# Intuition\\n\\nLisp is awful lot like JSON, consider this:\\n```lisp\\n(let x 1 y 2 (add x y))\\n```\\nand\\n```json\\n[\"let\", \"x\", 1, \"y\", 2, [\"add\", \"x\", \"y\"]]\\n```\\n\\nWith that in mind, string manipulation without proper parsing to create JSON string representing \"AST\" of an expression seemed like a nice shortcut and here were are.\\n\\n# Approach\\n1. Split by `/\\\\s+/g`\\n2. Additionally slice any \"(\" and \")\" from tokens generated on step 1 and put them into their own tokens.\\n3. Convert to proper JSON:\\n    1. Numbers go in as is\\n    2. Strings are escaped with JSON.stringify\\n    3. If next symbol exists and isn\\'t \")\", add delimiter (\", \")\\n5. JSON.parse\\n6. Recursively evaluate AST\\n7. ???\\n8. PROFIT\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ + whatever complexity of JSON.parse is\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n\\n## Typescript\\n```ts\\nfunction countTrailingSymbols(str: string, sym: string) {\\n  for (let i = str.length - 1; i >= 0; --i) {\\n    if (str[i] !== sym) {\\n      return str.length - i - 1;\\n    }\\n  }\\n\\n  return str.length;\\n}\\n\\nfunction split(expression: string): string[] {\\n  let result: string[] = [];\\n  let intermediate = expression.split(/\\\\s+/g);\\n\\n  for (const pretoken of intermediate) {\\n    if (pretoken.startsWith(\"(\")) {\\n      result.push(\"(\");\\n      result.push(pretoken.slice(1));\\n      continue;\\n    }\\n    if (pretoken.endsWith(\")\")) {\\n      const count = countTrailingSymbols(pretoken, \")\");\\n      result.push(pretoken.slice(0, pretoken.length - count));\\n      for (let i = 0; i < count; ++i) {\\n        result.push(\")\");\\n      }\\n      continue;\\n    }\\n    result.push(pretoken);\\n  }\\n\\n  return result;\\n}\\n\\nfunction toJSON(tokens: string[]): string {\\n  let result = \"\";\\n  for (let i = 0; i < tokens.length; ++i) {\\n    const token = tokens[i];\\n    if (token === \"(\") {\\n      result += \"[\";\\n      continue;\\n    }\\n\\n    if (token === \")\") {\\n      result += \"]\";\\n      if (tokens[i + 1] && tokens[i + 1] !== \")\") {\\n        result += \", \";\\n      }\\n      continue;\\n    }\\n\\n    if (!Number.isNaN(Number(token))) {\\n      result += token;\\n      if (tokens[i + 1] && tokens[i + 1] !== \")\") {\\n        result += \", \";\\n      }\\n      continue;\\n    }\\n\\n    result += JSON.stringify(token);\\n    if (tokens[i + 1] && tokens[i + 1] !== \")\") {\\n      result += \", \";\\n    }\\n  }\\n\\n  return result;\\n}\\n\\nfunction compute(expression: any, scope: Record<string, number>): number {\\n  if (typeof expression === \"number\") {\\n    return expression;\\n  }\\n\\n  if (typeof expression === \"string\") {\\n    return scope[expression];\\n  }\\n\\n  switch(expression[0]) {\\n    case \"let\": {\\n      const nextScope = { ...scope };\\n      for (let i = 1; i < expression.length - 1; i += 2) {\\n        let name = expression[i];\\n        let value = compute(expression[i + 1], nextScope);\\n        nextScope[name] = value;\\n      }\\n      return compute(expression[expression.length - 1], nextScope);\\n    }\\n    case \"add\": return compute(expression[1], scope) + compute(expression[2], scope);\\n    case \"mult\": return compute(expression[1], scope) * compute(expression[2], scope);\\n    default: throw new Error(`Wrong expression: ${JSON.stringify(expression)}`);\\n  }\\n}\\n\\nfunction evaluate(expression: string): number {\\n  const tokens = split(expression);\\n  const json = toJSON(tokens);\\n  const parsed = JSON.parse(json);\\n  \\n  return compute(parsed, {});\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```lisp\\n(let x 1 y 2 (add x y))\\n```\n```json\\n[\"let\", \"x\", 1, \"y\", 2, [\"add\", \"x\", \"y\"]]\\n```\n```ts\\nfunction countTrailingSymbols(str: string, sym: string) {\\n  for (let i = str.length - 1; i >= 0; --i) {\\n    if (str[i] !== sym) {\\n      return str.length - i - 1;\\n    }\\n  }\\n\\n  return str.length;\\n}\\n\\nfunction split(expression: string): string[] {\\n  let result: string[] = [];\\n  let intermediate = expression.split(/\\\\s+/g);\\n\\n  for (const pretoken of intermediate) {\\n    if (pretoken.startsWith(\"(\")) {\\n      result.push(\"(\");\\n      result.push(pretoken.slice(1));\\n      continue;\\n    }\\n    if (pretoken.endsWith(\")\")) {\\n      const count = countTrailingSymbols(pretoken, \")\");\\n      result.push(pretoken.slice(0, pretoken.length - count));\\n      for (let i = 0; i < count; ++i) {\\n        result.push(\")\");\\n      }\\n      continue;\\n    }\\n    result.push(pretoken);\\n  }\\n\\n  return result;\\n}\\n\\nfunction toJSON(tokens: string[]): string {\\n  let result = \"\";\\n  for (let i = 0; i < tokens.length; ++i) {\\n    const token = tokens[i];\\n    if (token === \"(\") {\\n      result += \"[\";\\n      continue;\\n    }\\n\\n    if (token === \")\") {\\n      result += \"]\";\\n      if (tokens[i + 1] && tokens[i + 1] !== \")\") {\\n        result += \", \";\\n      }\\n      continue;\\n    }\\n\\n    if (!Number.isNaN(Number(token))) {\\n      result += token;\\n      if (tokens[i + 1] && tokens[i + 1] !== \")\") {\\n        result += \", \";\\n      }\\n      continue;\\n    }\\n\\n    result += JSON.stringify(token);\\n    if (tokens[i + 1] && tokens[i + 1] !== \")\") {\\n      result += \", \";\\n    }\\n  }\\n\\n  return result;\\n}\\n\\nfunction compute(expression: any, scope: Record<string, number>): number {\\n  if (typeof expression === \"number\") {\\n    return expression;\\n  }\\n\\n  if (typeof expression === \"string\") {\\n    return scope[expression];\\n  }\\n\\n  switch(expression[0]) {\\n    case \"let\": {\\n      const nextScope = { ...scope };\\n      for (let i = 1; i < expression.length - 1; i += 2) {\\n        let name = expression[i];\\n        let value = compute(expression[i + 1], nextScope);\\n        nextScope[name] = value;\\n      }\\n      return compute(expression[expression.length - 1], nextScope);\\n    }\\n    case \"add\": return compute(expression[1], scope) + compute(expression[2], scope);\\n    case \"mult\": return compute(expression[1], scope) * compute(expression[2], scope);\\n    default: throw new Error(`Wrong expression: ${JSON.stringify(expression)}`);\\n  }\\n}\\n\\nfunction evaluate(expression: string): number {\\n  const tokens = split(expression);\\n  const json = toJSON(tokens);\\n  const parsed = JSON.parse(json);\\n  \\n  return compute(parsed, {});\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4041436,
                "title": "js-solution",
                "content": "Not really efficient, but I like how challenging the implementation is \\uD83E\\uDEE0\\nShout out to Rich Hickey for completing an advanced version of this problem called Clojure. \\uD83E\\uDD72\\n\\n# Complexity\\n- Time complexity: $$O(expression.length)$$\\n- Space complexity: $$O(expression.length)$$\\n\\n# Code\\n```js\\n/** @type {Map<string, number[]>} */\\nconst vars = new Map();\\n/** @type {{ name: string, vars: string[] }[]} */\\nconst fns = [];\\nconst stack = [];\\n\\n/**\\n * @param {string} expression\\n * @return {number}\\n */\\nvar evaluate = function (expression) {\\n  vars.clear();\\n\\n  function saveVar(varName, value) {\\n    if (!vars.has(varName)) vars.set(varName, [value]);\\n    vars.get(varName).push(value);\\n  }\\n\\n  function getVar(varName) {\\n    const history = vars.get(varName);\\n    return history[history.length - 1];\\n  }\\n\\n  function popVar(varName) {\\n    vars.get(varName).pop();\\n  }\\n\\n  function isNumberChar(c) {\\n    if (!c) return false;\\n    const cc = c.charCodeAt();\\n    return 48 <= cc && cc <= 57;\\n  }\\n\\n  function isAlphaChar(c) {\\n    const cc = c.charCodeAt();\\n    return 97 <= cc && cc <= 122;\\n  }\\n\\n  function getCurFn() {\\n    return fns[fns.length - 1];\\n  }\\n\\n  function checkVarResolvable() {\\n    const fn = getCurFn();\\n    if (fn.name !== \"l\") return true;\\n    return stack[stack.length - 1] !== \"(\";\\n  }\\n\\n  for (let i = 0; i < expression.length; i++) {\\n    if (expression[i] === \"(\") {\\n      let newFn = {\\n        name: undefined,\\n      };\\n\\n      while (1) {\\n        i++;\\n        if (isAlphaChar(expression[i]) && !newFn.name)\\n          newFn.name = expression[i];\\n        if (expression[i] === \" \" && newFn.name) break;\\n      }\\n\\n      if (newFn.name == \"l\") newFn.vars = [];\\n      fns.push(newFn);\\n      stack.push(\"(\");\\n    }\\n\\n    if (expression[i] === \")\") {\\n      let fn = fns.pop();\\n      switch (fn.name) {\\n        case \"l\": {\\n          let r = stack.pop();\\n          if (typeof r !== \"number\") r = getVar(r);\\n          stack[stack.length - 1] = r;\\n          fn.vars.forEach((v) => popVar(v));\\n          break;\\n        }\\n        case \"m\": {\\n          let r = stack.pop() * stack.pop();\\n          stack[stack.length - 1] = r;\\n          break;\\n        }\\n        case \"a\": {\\n          let r = stack.pop() + stack.pop();\\n          stack[stack.length - 1] = r;\\n          break;\\n        }\\n      }\\n    }\\n\\n    if (i === 0 || expression[i - 1] === \" \") {\\n      if (isAlphaChar(expression[i])) {\\n        let varName = expression[i++];\\n        while (isAlphaChar(expression[i]) || isNumberChar(expression[i])) {\\n          varName += expression[i++];\\n        }\\n\\n        if (expression[i] === \")\") i--;\\n        if (checkVarResolvable()) stack.push(getVar(varName));\\n        else stack.push(varName);\\n      } else if (isNumberChar(expression[i]) || expression[i] === \"-\") {\\n        let str = expression[i++];\\n        while (isNumberChar(expression[i])) str += expression[i++];\\n\\n        if (expression[i] === \")\") i--;\\n        stack.push(parseInt(str));\\n      }\\n    }\\n\\n    if (getCurFn()?.name === \"l\") {\\n      let varName = stack[stack.length - 2];\\n      let varValue = stack[stack.length - 1];\\n\\n      if (varName !== \"(\" && varValue !== \"(\") {\\n        getCurFn().vars.push(varName) \\n        saveVar(varName, varValue);\\n        stack.pop();\\n        stack.pop();\\n      }\\n    }\\n  }\\n\\n  return stack.pop();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "String",
                    "Stack",
                    "Simulation"
                ],
                "code": "```js\\n/** @type {Map<string, number[]>} */\\nconst vars = new Map();\\n/** @type {{ name: string, vars: string[] }[]} */\\nconst fns = [];\\nconst stack = [];\\n\\n/**\\n * @param {string} expression\\n * @return {number}\\n */\\nvar evaluate = function (expression) {\\n  vars.clear();\\n\\n  function saveVar(varName, value) {\\n    if (!vars.has(varName)) vars.set(varName, [value]);\\n    vars.get(varName).push(value);\\n  }\\n\\n  function getVar(varName) {\\n    const history = vars.get(varName);\\n    return history[history.length - 1];\\n  }\\n\\n  function popVar(varName) {\\n    vars.get(varName).pop();\\n  }\\n\\n  function isNumberChar(c) {\\n    if (!c) return false;\\n    const cc = c.charCodeAt();\\n    return 48 <= cc && cc <= 57;\\n  }\\n\\n  function isAlphaChar(c) {\\n    const cc = c.charCodeAt();\\n    return 97 <= cc && cc <= 122;\\n  }\\n\\n  function getCurFn() {\\n    return fns[fns.length - 1];\\n  }\\n\\n  function checkVarResolvable() {\\n    const fn = getCurFn();\\n    if (fn.name !== \"l\") return true;\\n    return stack[stack.length - 1] !== \"(\";\\n  }\\n\\n  for (let i = 0; i < expression.length; i++) {\\n    if (expression[i] === \"(\") {\\n      let newFn = {\\n        name: undefined,\\n      };\\n\\n      while (1) {\\n        i++;\\n        if (isAlphaChar(expression[i]) && !newFn.name)\\n          newFn.name = expression[i];\\n        if (expression[i] === \" \" && newFn.name) break;\\n      }\\n\\n      if (newFn.name == \"l\") newFn.vars = [];\\n      fns.push(newFn);\\n      stack.push(\"(\");\\n    }\\n\\n    if (expression[i] === \")\") {\\n      let fn = fns.pop();\\n      switch (fn.name) {\\n        case \"l\": {\\n          let r = stack.pop();\\n          if (typeof r !== \"number\") r = getVar(r);\\n          stack[stack.length - 1] = r;\\n          fn.vars.forEach((v) => popVar(v));\\n          break;\\n        }\\n        case \"m\": {\\n          let r = stack.pop() * stack.pop();\\n          stack[stack.length - 1] = r;\\n          break;\\n        }\\n        case \"a\": {\\n          let r = stack.pop() + stack.pop();\\n          stack[stack.length - 1] = r;\\n          break;\\n        }\\n      }\\n    }\\n\\n    if (i === 0 || expression[i - 1] === \" \") {\\n      if (isAlphaChar(expression[i])) {\\n        let varName = expression[i++];\\n        while (isAlphaChar(expression[i]) || isNumberChar(expression[i])) {\\n          varName += expression[i++];\\n        }\\n\\n        if (expression[i] === \")\") i--;\\n        if (checkVarResolvable()) stack.push(getVar(varName));\\n        else stack.push(varName);\\n      } else if (isNumberChar(expression[i]) || expression[i] === \"-\") {\\n        let str = expression[i++];\\n        while (isNumberChar(expression[i])) str += expression[i++];\\n\\n        if (expression[i] === \")\") i--;\\n        stack.push(parseInt(str));\\n      }\\n    }\\n\\n    if (getCurFn()?.name === \"l\") {\\n      let varName = stack[stack.length - 2];\\n      let varValue = stack[stack.length - 1];\\n\\n      if (varName !== \"(\" && varValue !== \"(\") {\\n        getCurFn().vars.push(varName) \\n        saveVar(varName, varValue);\\n        stack.pop();\\n        stack.pop();\\n      }\\n    }\\n  }\\n\\n  return stack.pop();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3959633,
                "title": "easiest-solution",
                "content": "\\n\\n# Code\\n```java []\\nclass Solution {\\n    public int evaluate(String expression) {\\n        return eval(expression, new HashMap<String, Integer>());\\n    }    \\n    \\n    private int eval(String expression, Map<String, Integer> map) {\\n        // This function evaluates add, mult or let expression.\\n        List<String> strs = parse(expression.substring(1, expression.length() - 1));\\n        if(strs.get(0).equals(\"add\")) {\\n            return cal(strs.get(1), map) + cal(strs.get(2), map);\\n        } else if(strs.get(0).equals(\"mult\")) {\\n            return cal(strs.get(1), map) * cal(strs.get(2), map);\\n        } else {\\n            Map<String, Integer> next = new HashMap<>(map);\\n            for(int i = 1; i < strs.size() - 1; i += 2) {\\n                next.put(strs.get(i), cal(strs.get(i + 1), next));\\n            }\\n            return cal(strs.get(strs.size() - 1), next);\\n        }        \\n    }\\n    \\n    private int cal(String s, Map<String, Integer> map) {        \\n        if(s.charAt(0) == \\'(\\') {\\n            // Another let, add or mult expression.\\n            return eval(s, map);\\n        } else if(map.containsKey(s)) {\\n            // Assigned value.\\n            return map.get(s);\\n        } else {\\n            // Integer.\\n            return Integer.valueOf(s);\\n        }        \\n    }\\n    \\n    private List<String> parse(String s) {\\n        // Breaks down the expression in the current scope, leaving inner scopes untouched.\\n        // i.e. let x 2 (mult x 5) => [\"let\", \"x\", \"2\", \"(mult x 5)\"]        \\n        int par = 0, start = 0;\\n        List<String> list = new ArrayList<String>();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(c == \\' \\' && par == 0) {\\n                list.add(s.substring(start, i));\\n                start = i + 1;\\n            } else if(c == \\'(\\') {\\n                par++;\\n            } else if(c == \\')\\') {\\n                par--;\\n            }\\n        }\\n        list.add(s.substring(start));\\n        return list;\\n    }\\n}\\n```\\n```c++ []\\npublic:    \\n  int evaluate(string s, unordered_map<string,int> dict = unordered_map<string,int>()) \\n  {        \\n      // base case: single variable or single value\\n      if (s[0] != \\'(\\') return isalpha(s[0])? dict[s] : stoi(s);\\n\\n      int i = 1; s.pop_back(); // remove wrapping \"()\"\\n      string op = next(s, i); // operator of current string\\n\\n      if (op == \"let\") { // string: \"let a1 exp1 a2 exp2 finalExp\"\\n        string var;\\n        do {\\n          var = next(s, i);\\n          if (i <= s.size()) dict[var] = evaluate(next(s, i), dict);\\n        }\\n        while (i <= s.size());\\n        \\n        return evaluate(var, dict); // return last expression with dict fully built\\n      }                      \\n      else { // \"add\" or \"mult\" string: \"add exp1 exp2\"\\n          int x1 = evaluate(next(s, i), dict), x2 = evaluate(next(s, i), dict);\\n          return op == \"add\"? x1+x2 : x1*x2;\\n      }\\n  }\\n    \\nprivate:  \\n  // get next token (val, var or expression) starting at index i\\n  // i will be overwritten to new starting index of next token\\n  string next(const string& s,int& i) \\n  {\\n      size_t ii = i;\\n\\n      // token is an expression (need to find matching \\')\\')\\n      if (s[i++] == \\'(\\') {\\n        for (int dif=1; dif; ++i) // dif = count of \\'(\\' - count of \\')\\'\\n          if (s[i] == \\'(\\') dif++;\\n          else if (s[i] == \\')\\') dif--;\\n      }\\n      // token is a var or val (find next \\' \\')\\n      else i = min(s.find(\" \", ii), s.size()); \\n\\n      return s.substr(ii, i++ -ii);\\n  }\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int evaluate(String expression) {\\n        return eval(expression, new HashMap<String, Integer>());\\n    }    \\n    \\n    private int eval(String expression, Map<String, Integer> map) {\\n        // This function evaluates add, mult or let expression.\\n        List<String> strs = parse(expression.substring(1, expression.length() - 1));\\n        if(strs.get(0).equals(\"add\")) {\\n            return cal(strs.get(1), map) + cal(strs.get(2), map);\\n        } else if(strs.get(0).equals(\"mult\")) {\\n            return cal(strs.get(1), map) * cal(strs.get(2), map);\\n        } else {\\n            Map<String, Integer> next = new HashMap<>(map);\\n            for(int i = 1; i < strs.size() - 1; i += 2) {\\n                next.put(strs.get(i), cal(strs.get(i + 1), next));\\n            }\\n            return cal(strs.get(strs.size() - 1), next);\\n        }        \\n    }\\n    \\n    private int cal(String s, Map<String, Integer> map) {        \\n        if(s.charAt(0) == \\'(\\') {\\n            // Another let, add or mult expression.\\n            return eval(s, map);\\n        } else if(map.containsKey(s)) {\\n            // Assigned value.\\n            return map.get(s);\\n        } else {\\n            // Integer.\\n            return Integer.valueOf(s);\\n        }        \\n    }\\n    \\n    private List<String> parse(String s) {\\n        // Breaks down the expression in the current scope, leaving inner scopes untouched.\\n        // i.e. let x 2 (mult x 5) => [\"let\", \"x\", \"2\", \"(mult x 5)\"]        \\n        int par = 0, start = 0;\\n        List<String> list = new ArrayList<String>();\\n        for(int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(c == \\' \\' && par == 0) {\\n                list.add(s.substring(start, i));\\n                start = i + 1;\\n            } else if(c == \\'(\\') {\\n                par++;\\n            } else if(c == \\')\\') {\\n                par--;\\n            }\\n        }\\n        list.add(s.substring(start));\\n        return list;\\n    }\\n}\\n```\n```c++ []\\npublic:    \\n  int evaluate(string s, unordered_map<string,int> dict = unordered_map<string,int>()) \\n  {        \\n      // base case: single variable or single value\\n      if (s[0] != \\'(\\') return isalpha(s[0])? dict[s] : stoi(s);\\n\\n      int i = 1; s.pop_back(); // remove wrapping \"()\"\\n      string op = next(s, i); // operator of current string\\n\\n      if (op == \"let\") { // string: \"let a1 exp1 a2 exp2 finalExp\"\\n        string var;\\n        do {\\n          var = next(s, i);\\n          if (i <= s.size()) dict[var] = evaluate(next(s, i), dict);\\n        }\\n        while (i <= s.size());\\n        \\n        return evaluate(var, dict); // return last expression with dict fully built\\n      }                      \\n      else { // \"add\" or \"mult\" string: \"add exp1 exp2\"\\n          int x1 = evaluate(next(s, i), dict), x2 = evaluate(next(s, i), dict);\\n          return op == \"add\"? x1+x2 : x1*x2;\\n      }\\n  }\\n    \\nprivate:  \\n  // get next token (val, var or expression) starting at index i\\n  // i will be overwritten to new starting index of next token\\n  string next(const string& s,int& i) \\n  {\\n      size_t ii = i;\\n\\n      // token is an expression (need to find matching \\')\\')\\n      if (s[i++] == \\'(\\') {\\n        for (int dif=1; dif; ++i) // dif = count of \\'(\\' - count of \\')\\'\\n          if (s[i] == \\'(\\') dif++;\\n          else if (s[i] == \\')\\') dif--;\\n      }\\n      // token is a var or val (find next \\' \\')\\n      else i = min(s.find(\" \", ii), s.size()); \\n\\n      return s.substr(ii, i++ -ii);\\n  }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3799059,
                "title": "c-recursive-parser",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    // To hold scoped variables\\n    struct Context\\n    {\\n        Context* Parent = nullptr;\\n        unordered_map<string, int> Vars;\\n    };\\n\\n    void inc(string_view& buffer, int n = 1)\\n    {\\n        // Increment the current parsing read pointer\\n        assert(buffer.size() >= n);\\n        buffer = {buffer.data() + n, buffer.size() - n};\\n    }\\n\\n    void skipSpace(string_view& buffer)\\n    {\\n        if(isspace(buffer[0]))\\n            inc(buffer);\\n    }\\n\\n    int isNum(char c)\\n    {\\n        return isdigit(c) || c==\\'-\\';\\n    }\\n            \\n    int parseInt(string_view& buffer)\\n    {\\n        int result = atoi(buffer.data());\\n\\n        // Increment until we have read all the numbers\\n        while(isNum(buffer[0]))\\n            inc(buffer);\\n\\n        return result;\\n    }\\n\\n    bool parseWord(string_view& buffer, const string& word)\\n    {\\n        // Increment read pointer only if we match the word\\n        if((buffer.size() >= word.size()) && strncmp(buffer.data(), word.c_str(), word.size()) == 0)\\n        {\\n            inc(buffer, word.size());\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    optional<string_view> parseVar(string_view& buffer)\\n    {\\n        optional<string_view> result;\\n        skipSpace(buffer);\\n\\n        if(isalpha(buffer[0]))\\n        {\\n            string_view start = buffer;\\n            while(isalnum(buffer[0]))\\n                inc(buffer);\\n            result = string_view{start.data(), (size_t)(buffer.data()-start.data())};\\n        }\\n        return result;\\n    }\\n\\n    int parseExpression(string_view& buffer, Context* context)\\n    {\\n        static const string kLet {\"let\"};\\n        static const string kAdd {\"add\"};\\n        static const string kMult {\"mult\"};\\n\\n        skipSpace(buffer);\\n        if(buffer[0] == \\'(\\')\\n        {\\n            inc(buffer);\\n            int result = parseExpression(buffer, context);\\n            assert(buffer[0] == \\')\\');\\n            inc(buffer);\\n            return result;\\n        }\\n        else if(isNum(buffer[0]))\\n        {\\n            return parseInt(buffer);\\n        }\\n        else if(parseWord(buffer, kLet))\\n        {\\n            Context currContext;\\n            currContext.Parent = context;\\n\\n            // Unknown number of variable / expr for now\\n            while(true)\\n            {\\n                string_view backtrack = buffer;\\n                auto varName = parseVar(buffer);\\n\\n                // If we can\\'t parse a variable name or there is no value next to it,\\n                // we are don parsing pairs and we need to parse the ending expression\\n                if(!varName || buffer[0]==\\')\\')\\n                {\\n                    buffer = backtrack;\\n                    break;\\n                }\\n                \\n                int value = parseExpression(buffer, &currContext);\\n                currContext.Vars[string(varName.value())] = value;\\n            }\\n            return parseExpression(buffer, &currContext);\\n        }\\n        else if(parseWord(buffer, kAdd))\\n        {\\n            int a = parseExpression(buffer, context);\\n            int b = parseExpression(buffer, context);\\n            return a + b;\\n        }\\n        else if(parseWord(buffer, kMult))\\n        {\\n            int a = parseExpression(buffer, context);\\n            int b = parseExpression(buffer, context);\\n            return a * b;\\n        }\\n        else if(auto varName = parseVar(buffer))\\n        {\\n            string varNameStr = string(varName.value());\\n\\n            // Look for the value of this variable name in the stacked scopes\\n            Context* currContext = context;\\n            while(currContext)\\n            {\\n                auto it = currContext->Vars.find(varNameStr);\\n                if(it != currContext->Vars.end())\\n                    return it->second;\\n                currContext = currContext->Parent;\\n            }\\n            assert(!\"Failed to find variable\");\\n        }\\n\\n        assert(!\"Failed to parse expression\");\\n        return 0; \\n    }\\n\\n    int evaluate(string expression) {\\n        string_view buffer = expression;\\n        return parseExpression(buffer, nullptr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    // To hold scoped variables\\n    struct Context\\n    {\\n        Context* Parent = nullptr;\\n        unordered_map<string, int> Vars;\\n    };\\n\\n    void inc(string_view& buffer, int n = 1)\\n    {\\n        // Increment the current parsing read pointer\\n        assert(buffer.size() >= n);\\n        buffer = {buffer.data() + n, buffer.size() - n};\\n    }\\n\\n    void skipSpace(string_view& buffer)\\n    {\\n        if(isspace(buffer[0]))\\n            inc(buffer);\\n    }\\n\\n    int isNum(char c)\\n    {\\n        return isdigit(c) || c==\\'-\\';\\n    }\\n            \\n    int parseInt(string_view& buffer)\\n    {\\n        int result = atoi(buffer.data());\\n\\n        // Increment until we have read all the numbers\\n        while(isNum(buffer[0]))\\n            inc(buffer);\\n\\n        return result;\\n    }\\n\\n    bool parseWord(string_view& buffer, const string& word)\\n    {\\n        // Increment read pointer only if we match the word\\n        if((buffer.size() >= word.size()) && strncmp(buffer.data(), word.c_str(), word.size()) == 0)\\n        {\\n            inc(buffer, word.size());\\n            return true;\\n        }\\n        return false;\\n    }\\n\\n    optional<string_view> parseVar(string_view& buffer)\\n    {\\n        optional<string_view> result;\\n        skipSpace(buffer);\\n\\n        if(isalpha(buffer[0]))\\n        {\\n            string_view start = buffer;\\n            while(isalnum(buffer[0]))\\n                inc(buffer);\\n            result = string_view{start.data(), (size_t)(buffer.data()-start.data())};\\n        }\\n        return result;\\n    }\\n\\n    int parseExpression(string_view& buffer, Context* context)\\n    {\\n        static const string kLet {\"let\"};\\n        static const string kAdd {\"add\"};\\n        static const string kMult {\"mult\"};\\n\\n        skipSpace(buffer);\\n        if(buffer[0] == \\'(\\')\\n        {\\n            inc(buffer);\\n            int result = parseExpression(buffer, context);\\n            assert(buffer[0] == \\')\\');\\n            inc(buffer);\\n            return result;\\n        }\\n        else if(isNum(buffer[0]))\\n        {\\n            return parseInt(buffer);\\n        }\\n        else if(parseWord(buffer, kLet))\\n        {\\n            Context currContext;\\n            currContext.Parent = context;\\n\\n            // Unknown number of variable / expr for now\\n            while(true)\\n            {\\n                string_view backtrack = buffer;\\n                auto varName = parseVar(buffer);\\n\\n                // If we can\\'t parse a variable name or there is no value next to it,\\n                // we are don parsing pairs and we need to parse the ending expression\\n                if(!varName || buffer[0]==\\')\\')\\n                {\\n                    buffer = backtrack;\\n                    break;\\n                }\\n                \\n                int value = parseExpression(buffer, &currContext);\\n                currContext.Vars[string(varName.value())] = value;\\n            }\\n            return parseExpression(buffer, &currContext);\\n        }\\n        else if(parseWord(buffer, kAdd))\\n        {\\n            int a = parseExpression(buffer, context);\\n            int b = parseExpression(buffer, context);\\n            return a + b;\\n        }\\n        else if(parseWord(buffer, kMult))\\n        {\\n            int a = parseExpression(buffer, context);\\n            int b = parseExpression(buffer, context);\\n            return a * b;\\n        }\\n        else if(auto varName = parseVar(buffer))\\n        {\\n            string varNameStr = string(varName.value());\\n\\n            // Look for the value of this variable name in the stacked scopes\\n            Context* currContext = context;\\n            while(currContext)\\n            {\\n                auto it = currContext->Vars.find(varNameStr);\\n                if(it != currContext->Vars.end())\\n                    return it->second;\\n                currContext = currContext->Parent;\\n            }\\n            assert(!\"Failed to find variable\");\\n        }\\n\\n        assert(!\"Failed to parse expression\");\\n        return 0; \\n    }\\n\\n    int evaluate(string expression) {\\n        string_view buffer = expression;\\n        return parseExpression(buffer, nullptr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3697118,
                "title": "my-solution",
                "content": "**Solution I**\\n```\\nclass Solution {\\n private:\\n  enum class Op : char {\\n    let = \\'l\\',\\n    mult = \\'m\\',\\n    add = \\'a\\'\\n  };\\n  \\n public:\\n  int evaluate(const string &expression) {\\n    /**\\n     * {\\n     *   {\\n     *     the variable name,\\n     *     the variable value\\n     *   },\\n     *   ...\\n     * }\\n     */\\n    using context_t = unordered_map<string, int>;\\n    \\n    /**\\n     * {\\n     *   <0>, a flag indicating whether the operand is unset (0), or a variable (-1) or a value (1),\\n     *   <1>, the variable name\\n     *   <2>, the value is positive (true) or negative (false)\\n     *   <3>, the value\\n     * }\\n     */\\n    using operand_t = tuple<int, string, bool, int>;\\n    constexpr int operand_is_unset = 0;\\n    constexpr int operand_is_variable = -1;\\n    constexpr int operand_is_value = 1;\\n    constexpr int flag_i = 0;\\n    constexpr int variable_i = 1;\\n    constexpr int is_positive_i = 2;\\n    constexpr int value_i = 3;\\n    \\n    /**\\n     * the operands\\n     */\\n    using operands_t = queue<operand_t>;\\n    \\n    /**\\n     * {\\n     *   <0>, the context\\n     *   <1>, the operation\\n     *   <2>, the operands\\n     *   <3>, the return value}\\n     */\\n    using frame_t = tuple<context_t, Op, operands_t, int>;\\n    constexpr int context_i = 0;\\n    constexpr int operands_i = 2;\\n    constexpr int ret_value_i = 3;\\n    \\n    constexpr char open = \\'(\\';\\n    constexpr char close = \\')\\';\\n    constexpr char space = \\' \\';\\n    constexpr int base = 10;\\n    constexpr char zero = \\'0\\';\\n    constexpr char negative = \\'-\\';\\n    const int n = static_cast<int>(expression.size());\\n    stack<frame_t> st;\\n    operand_t operand = make_tuple(operand_is_unset, string{}, true, 0);\\n    \\n    auto push_operand = [&st, &operand, operand_is_unset]() -> void {\\n      if (st.empty() || get<flag_i>(operand) == operand_is_unset) {\\n        return;\\n      }\\n\\n      operands_t &operands = get<operands_i>(st.top());\\n      operands.emplace(move(operand));\\n      operand = make_tuple(operand_is_unset, string{}, true, 0);\\n    };\\n    \\n    auto get_value = [](const context_t &context, const operand_t &operand) -> int {\\n      const auto [flag, variable, is_positive, value] = operand;\\n      if (flag == operand_is_unset) {\\n        throw \"impossible path\";\\n      }\\n\\n      if (flag == operand_is_variable) {\\n        return context.at(variable);\\n      }\\n      return value * (is_positive ? 1 : -1);\\n    };\\n    \\n    auto evaluate = [&st, &get_value](const bool is_final) -> void {\\n      if (st.empty()) {\\n        return;\\n      }\\n\\n      auto &[context, op, operands, ret_value] = st.top();\\n      if (op == Op::let) {\\n        while (operands.size() > 1) {\\n          const string variable = move(get<variable_i>(operands.front()));\\n          operands.pop();\\n          const int value = get_value(context, operands.front());\\n          operands.pop();\\n          context[variable] = value;\\n        }\\n        if (is_final) {\\n          ret_value = get_value(context, operands.front());\\n        }\\n        return;\\n      }\\n      \\n      if (!is_final) {\\n        return;\\n      }\\n      \\n      const int lhs = get_value(context, operands.front());\\n      operands.pop();\\n      const int rhs = get_value(context, operands.front());\\n      \\n      ret_value = op == Op::mult ? (lhs * rhs) : (lhs + rhs);\\n    };\\n    \\n    for (int i = 0; i < n; ++i) {\\n      if (expression[i] == open) {\\n        push_operand();\\n        evaluate(false);\\n        context_t context(st.empty() ? context_t{} : get<context_i>(st.top()));\\n        Op op = static_cast<Op>(expression[i + 1]);\\n        st.emplace(move(context), op, operands_t{}, 0);\\n        for (; expression[i + 1] != space; ++i) {\\n        }\\n        continue;\\n      }\\n      \\n      if (expression[i] == close) {\\n        push_operand();\\n        evaluate(true);\\n        operand = make_tuple(operand_is_value, string{}, true, get<ret_value_i>(st.top()));\\n        st.pop();\\n        continue;\\n      }\\n      \\n      if (expression[i] == space) {\\n        push_operand();\\n        continue;\\n      }\\n      \\n      auto &[flag, variable, is_positive, value] = operand;\\n      if (flag == operand_is_unset) {\\n        flag = islower(expression[i]) ? operand_is_variable : operand_is_value;\\n      }\\n      if (flag == operand_is_variable) {\\n        variable.push_back(expression[i]);\\n      } else {\\n        if (expression[i] == negative) {\\n          is_positive = false;\\n        } else {\\n          value = base * value + (expression[i] - zero);\\n        }\\n      }\\n    }\\n    \\n    return get<value_i>(operand);\\n  }\\n};\\n```\\n**Solution II, the same idea with `I`, currently using `string` as `operand_t`**\\n```\\nclass Solution {\\n private:\\n  enum class Op : char {\\n    let = \\'l\\',\\n    mult = \\'m\\',\\n    add = \\'a\\'\\n  };\\n  \\n public:\\n  int evaluate(const string &expression) {\\n    using operand_t = string;\\n    using operands_t = queue<operand_t>;\\n    using context_t = unordered_map<string, int>;\\n    using frame_t = tuple<context_t, Op, operands_t, int>;\\n    \\n    constexpr int context_i = 0;\\n    constexpr int op_i = 1;\\n    constexpr int operands_i = 2;\\n    constexpr int result_i = 3;\\n    constexpr char open = \\'(\\';\\n    constexpr char close = \\')\\';\\n    constexpr char space = \\' \\';\\n    \\n    stack<frame_t> st;\\n    operand_t operand;\\n    \\n    auto push_operand = [&st, &operand]() -> void {\\n      if (st.empty() || operand.empty()) {\\n        return;\\n      }\\n      \\n      operands_t &operands = get<operands_i>(st.top());\\n      operands.emplace(move(operand));\\n    };\\n    \\n    auto get_value = [](const context_t &context, const operand_t &operand) -> int {\\n      if (islower(operand.front())) {\\n        return context.at(operand);\\n      }\\n      \\n      return stoi(operand);\\n    };\\n    \\n    auto evaluate = [&st, &get_value](const bool is_final) -> void {\\n      if (st.empty()) {\\n        return;\\n      }\\n      \\n      auto &[context, op, operands, result] = st.top();\\n      if (op == Op::let) {\\n        while (operands.size() > 1) {\\n          const string variable = move(operands.front());\\n          operands.pop();\\n          const string value = move(operands.front());\\n          operands.pop();\\n          context[variable] = get_value(context, value);\\n        }\\n        if (is_final) {\\n          result = get_value(context, operands.front());\\n        }\\n        return;\\n      }\\n      \\n      if (!is_final) {\\n        return;\\n      }\\n      \\n      const int lhs = get_value(context, operands.front());\\n      operands.pop();\\n      const int rhs = get_value(context, operands.front());\\n      result = op == Op::add ? lhs + rhs : lhs * rhs;\\n    };\\n    \\n    const int n = static_cast<int>(expression.size());\\n    for (int i = 0; i < n; ++i) {\\n      const char c = expression[i];\\n      if (c == open) {\\n        evaluate(false);\\n        const Op op = static_cast<Op>(expression[i + 1]);\\n        const context_t context = st.empty() ? context_t{} : get<context_i>(st.top());\\n        st.emplace(context, op, operands_t{}, 0);\\n        for (; i < n && expression[i] != space; ++i) {\\n        }\\n        continue;\\n      }\\n      \\n      if (c == close) {\\n        push_operand();\\n        evaluate(true);\\n        operand = to_string(get<result_i>(st.top()));\\n        st.pop();\\n        continue;\\n      }\\n      \\n      if (c == space) {\\n        push_operand();\\n        continue;\\n      }\\n      \\n      operand.push_back(c);\\n    }\\n    return stoi(operand);\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n private:\\n  enum class Op : char {\\n    let = \\'l\\',\\n    mult = \\'m\\',\\n    add = \\'a\\'\\n  };\\n  \\n public:\\n  int evaluate(const string &expression) {\\n    /**\\n     * {\\n     *   {\\n     *     the variable name,\\n     *     the variable value\\n     *   },\\n     *   ...\\n     * }\\n     */\\n    using context_t = unordered_map<string, int>;\\n    \\n    /**\\n     * {\\n     *   <0>, a flag indicating whether the operand is unset (0), or a variable (-1) or a value (1),\\n     *   <1>, the variable name\\n     *   <2>, the value is positive (true) or negative (false)\\n     *   <3>, the value\\n     * }\\n     */\\n    using operand_t = tuple<int, string, bool, int>;\\n    constexpr int operand_is_unset = 0;\\n    constexpr int operand_is_variable = -1;\\n    constexpr int operand_is_value = 1;\\n    constexpr int flag_i = 0;\\n    constexpr int variable_i = 1;\\n    constexpr int is_positive_i = 2;\\n    constexpr int value_i = 3;\\n    \\n    /**\\n     * the operands\\n     */\\n    using operands_t = queue<operand_t>;\\n    \\n    /**\\n     * {\\n     *   <0>, the context\\n     *   <1>, the operation\\n     *   <2>, the operands\\n     *   <3>, the return value}\\n     */\\n    using frame_t = tuple<context_t, Op, operands_t, int>;\\n    constexpr int context_i = 0;\\n    constexpr int operands_i = 2;\\n    constexpr int ret_value_i = 3;\\n    \\n    constexpr char open = \\'(\\';\\n    constexpr char close = \\')\\';\\n    constexpr char space = \\' \\';\\n    constexpr int base = 10;\\n    constexpr char zero = \\'0\\';\\n    constexpr char negative = \\'-\\';\\n    const int n = static_cast<int>(expression.size());\\n    stack<frame_t> st;\\n    operand_t operand = make_tuple(operand_is_unset, string{}, true, 0);\\n    \\n    auto push_operand = [&st, &operand, operand_is_unset]() -> void {\\n      if (st.empty() || get<flag_i>(operand) == operand_is_unset) {\\n        return;\\n      }\\n\\n      operands_t &operands = get<operands_i>(st.top());\\n      operands.emplace(move(operand));\\n      operand = make_tuple(operand_is_unset, string{}, true, 0);\\n    };\\n    \\n    auto get_value = [](const context_t &context, const operand_t &operand) -> int {\\n      const auto [flag, variable, is_positive, value] = operand;\\n      if (flag == operand_is_unset) {\\n        throw \"impossible path\";\\n      }\\n\\n      if (flag == operand_is_variable) {\\n        return context.at(variable);\\n      }\\n      return value * (is_positive ? 1 : -1);\\n    };\\n    \\n    auto evaluate = [&st, &get_value](const bool is_final) -> void {\\n      if (st.empty()) {\\n        return;\\n      }\\n\\n      auto &[context, op, operands, ret_value] = st.top();\\n      if (op == Op::let) {\\n        while (operands.size() > 1) {\\n          const string variable = move(get<variable_i>(operands.front()));\\n          operands.pop();\\n          const int value = get_value(context, operands.front());\\n          operands.pop();\\n          context[variable] = value;\\n        }\\n        if (is_final) {\\n          ret_value = get_value(context, operands.front());\\n        }\\n        return;\\n      }\\n      \\n      if (!is_final) {\\n        return;\\n      }\\n      \\n      const int lhs = get_value(context, operands.front());\\n      operands.pop();\\n      const int rhs = get_value(context, operands.front());\\n      \\n      ret_value = op == Op::mult ? (lhs * rhs) : (lhs + rhs);\\n    };\\n    \\n    for (int i = 0; i < n; ++i) {\\n      if (expression[i] == open) {\\n        push_operand();\\n        evaluate(false);\\n        context_t context(st.empty() ? context_t{} : get<context_i>(st.top()));\\n        Op op = static_cast<Op>(expression[i + 1]);\\n        st.emplace(move(context), op, operands_t{}, 0);\\n        for (; expression[i + 1] != space; ++i) {\\n        }\\n        continue;\\n      }\\n      \\n      if (expression[i] == close) {\\n        push_operand();\\n        evaluate(true);\\n        operand = make_tuple(operand_is_value, string{}, true, get<ret_value_i>(st.top()));\\n        st.pop();\\n        continue;\\n      }\\n      \\n      if (expression[i] == space) {\\n        push_operand();\\n        continue;\\n      }\\n      \\n      auto &[flag, variable, is_positive, value] = operand;\\n      if (flag == operand_is_unset) {\\n        flag = islower(expression[i]) ? operand_is_variable : operand_is_value;\\n      }\\n      if (flag == operand_is_variable) {\\n        variable.push_back(expression[i]);\\n      } else {\\n        if (expression[i] == negative) {\\n          is_positive = false;\\n        } else {\\n          value = base * value + (expression[i] - zero);\\n        }\\n      }\\n    }\\n    \\n    return get<value_i>(operand);\\n  }\\n};\\n```\n```\\nclass Solution {\\n private:\\n  enum class Op : char {\\n    let = \\'l\\',\\n    mult = \\'m\\',\\n    add = \\'a\\'\\n  };\\n  \\n public:\\n  int evaluate(const string &expression) {\\n    using operand_t = string;\\n    using operands_t = queue<operand_t>;\\n    using context_t = unordered_map<string, int>;\\n    using frame_t = tuple<context_t, Op, operands_t, int>;\\n    \\n    constexpr int context_i = 0;\\n    constexpr int op_i = 1;\\n    constexpr int operands_i = 2;\\n    constexpr int result_i = 3;\\n    constexpr char open = \\'(\\';\\n    constexpr char close = \\')\\';\\n    constexpr char space = \\' \\';\\n    \\n    stack<frame_t> st;\\n    operand_t operand;\\n    \\n    auto push_operand = [&st, &operand]() -> void {\\n      if (st.empty() || operand.empty()) {\\n        return;\\n      }\\n      \\n      operands_t &operands = get<operands_i>(st.top());\\n      operands.emplace(move(operand));\\n    };\\n    \\n    auto get_value = [](const context_t &context, const operand_t &operand) -> int {\\n      if (islower(operand.front())) {\\n        return context.at(operand);\\n      }\\n      \\n      return stoi(operand);\\n    };\\n    \\n    auto evaluate = [&st, &get_value](const bool is_final) -> void {\\n      if (st.empty()) {\\n        return;\\n      }\\n      \\n      auto &[context, op, operands, result] = st.top();\\n      if (op == Op::let) {\\n        while (operands.size() > 1) {\\n          const string variable = move(operands.front());\\n          operands.pop();\\n          const string value = move(operands.front());\\n          operands.pop();\\n          context[variable] = get_value(context, value);\\n        }\\n        if (is_final) {\\n          result = get_value(context, operands.front());\\n        }\\n        return;\\n      }\\n      \\n      if (!is_final) {\\n        return;\\n      }\\n      \\n      const int lhs = get_value(context, operands.front());\\n      operands.pop();\\n      const int rhs = get_value(context, operands.front());\\n      result = op == Op::add ? lhs + rhs : lhs * rhs;\\n    };\\n    \\n    const int n = static_cast<int>(expression.size());\\n    for (int i = 0; i < n; ++i) {\\n      const char c = expression[i];\\n      if (c == open) {\\n        evaluate(false);\\n        const Op op = static_cast<Op>(expression[i + 1]);\\n        const context_t context = st.empty() ? context_t{} : get<context_i>(st.top());\\n        st.emplace(context, op, operands_t{}, 0);\\n        for (; i < n && expression[i] != space; ++i) {\\n        }\\n        continue;\\n      }\\n      \\n      if (c == close) {\\n        push_operand();\\n        evaluate(true);\\n        operand = to_string(get<result_i>(st.top()));\\n        st.pop();\\n        continue;\\n      }\\n      \\n      if (c == space) {\\n        push_operand();\\n        continue;\\n      }\\n      \\n      operand.push_back(c);\\n    }\\n    return stoi(operand);\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3669481,
                "title": "python-simple-stack",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def evaluate(self, expression):\\n        tokens, stack, dict1 = [\"\"], [], defaultdict(int)\\n\\n        def evaluate(tokens):\\n            if tokens[0] in [\"add\",\"mult\"]:\\n                n1 = int(dict1[tokens[1]]) if tokens[1] in dict1 else int(tokens[1])\\n                n2 = int(dict1[tokens[2]]) if tokens[2] in dict1 else int(tokens[2])\\n                return str(n1+n2) if tokens[0] == \"add\" else str(n1*n2)\\n            else:\\n                for i in range(1,len(tokens)-2,2):\\n                    dict1[tokens[i]] = dict1.get(tokens[i+1],tokens[i+1])\\n                return dict1[tokens[-1]] if tokens[-1] in dict1 else tokens[-1]\\n\\n        for c in expression:\\n            if c == \"(\":\\n                if tokens[0] == \"let\": evaluate(tokens)\\n                stack.append((tokens,dict(dict1)))\\n                tokens = [\"\"]\\n            elif c == \")\":\\n                val = evaluate(tokens)\\n                tokens, dict1 = stack.pop()\\n                tokens[-1] += val\\n            elif c == \" \":\\n                tokens.append(\"\")\\n            else:\\n                tokens[-1] += c\\n\\n        return int(tokens[0])\\n\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, expression):\\n        tokens, stack, dict1 = [\"\"], [], defaultdict(int)\\n\\n        def evaluate(tokens):\\n            if tokens[0] in [\"add\",\"mult\"]:\\n                n1 = int(dict1[tokens[1]]) if tokens[1] in dict1 else int(tokens[1])\\n                n2 = int(dict1[tokens[2]]) if tokens[2] in dict1 else int(tokens[2])\\n                return str(n1+n2) if tokens[0] == \"add\" else str(n1*n2)\\n            else:\\n                for i in range(1,len(tokens)-2,2):\\n                    dict1[tokens[i]] = dict1.get(tokens[i+1],tokens[i+1])\\n                return dict1[tokens[-1]] if tokens[-1] in dict1 else tokens[-1]\\n\\n        for c in expression:\\n            if c == \"(\":\\n                if tokens[0] == \"let\": evaluate(tokens)\\n                stack.append((tokens,dict(dict1)))\\n                tokens = [\"\"]\\n            elif c == \")\":\\n                val = evaluate(tokens)\\n                tokens, dict1 = stack.pop()\\n                tokens[-1] += val\\n            elif c == \" \":\\n                tokens.append(\"\")\\n            else:\\n                tokens[-1] += c\\n\\n        return int(tokens[0])\\n\\n\\n\\n\\n            \\n\\n\\n\\n\\n\\n        \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3613733,
                "title": "solve-it-with-python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        def evaluate(e: str, prevScope: dict) -> int:\\n            # Base case: if the expression starts with a digit or a negative sign, it\\'s a number\\n            if e[0].isdigit() or e[0] == \\'-\\':\\n                return int(e)\\n            \\n            # Check if the expression has been evaluated previously and stored in the previous scope\\n            if e in prevScope:\\n                return prevScope[e]\\n\\n            # Create a new scope based on the previous scope\\n            scope = prevScope.copy()\\n            \\n            # Extract the next expression by removing the outermost parentheses\\n            nextExpression = e[e.index(\\' \\') + 1:-1]\\n            \\n            # Split the expression into tokens\\n            tokens = parse(nextExpression)\\n\\n            # Evaluate addition\\n            if e[1] == \\'a\\':\\n                return evaluate(tokens[0], scope) + evaluate(tokens[1], scope)\\n            \\n            # Evaluate multiplication\\n            if e[1] == \\'m\\':\\n                return evaluate(tokens[0], scope) * evaluate(tokens[1], scope)\\n\\n            # Process assignments\\n            for i in range(0, len(tokens) - 2, 2):\\n                scope[tokens[i]] = evaluate(tokens[i + 1], scope)\\n\\n            # Evaluate the last expression in the tokens using the updated scope\\n            return evaluate(tokens[-1], scope)\\n\\n        def parse(e: str):\\n            tokens = []\\n            s = \\'\\'\\n            parenthesis = 0\\n\\n            for c in e:\\n                if c == \\'(\\':\\n                    parenthesis += 1\\n                elif c == \\')\\':\\n                    parenthesis -= 1\\n                if parenthesis == 0 and c == \\' \\':\\n                    tokens.append(s)\\n                    s = \\'\\'\\n                else:\\n                    s += c\\n\\n            if len(s) > 0:\\n                tokens.append(s)\\n            return tokens\\n\\n        # Start evaluating the expression with an empty scope\\n        return evaluate(expression, {})\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        def evaluate(e: str, prevScope: dict) -> int:\\n            # Base case: if the expression starts with a digit or a negative sign, it\\'s a number\\n            if e[0].isdigit() or e[0] == \\'-\\':\\n                return int(e)\\n            \\n            # Check if the expression has been evaluated previously and stored in the previous scope\\n            if e in prevScope:\\n                return prevScope[e]\\n\\n            # Create a new scope based on the previous scope\\n            scope = prevScope.copy()\\n            \\n            # Extract the next expression by removing the outermost parentheses\\n            nextExpression = e[e.index(\\' \\') + 1:-1]\\n            \\n            # Split the expression into tokens\\n            tokens = parse(nextExpression)\\n\\n            # Evaluate addition\\n            if e[1] == \\'a\\':\\n                return evaluate(tokens[0], scope) + evaluate(tokens[1], scope)\\n            \\n            # Evaluate multiplication\\n            if e[1] == \\'m\\':\\n                return evaluate(tokens[0], scope) * evaluate(tokens[1], scope)\\n\\n            # Process assignments\\n            for i in range(0, len(tokens) - 2, 2):\\n                scope[tokens[i]] = evaluate(tokens[i + 1], scope)\\n\\n            # Evaluate the last expression in the tokens using the updated scope\\n            return evaluate(tokens[-1], scope)\\n\\n        def parse(e: str):\\n            tokens = []\\n            s = \\'\\'\\n            parenthesis = 0\\n\\n            for c in e:\\n                if c == \\'(\\':\\n                    parenthesis += 1\\n                elif c == \\')\\':\\n                    parenthesis -= 1\\n                if parenthesis == 0 and c == \\' \\':\\n                    tokens.append(s)\\n                    s = \\'\\'\\n                else:\\n                    s += c\\n\\n            if len(s) > 0:\\n                tokens.append(s)\\n            return tokens\\n\\n        # Start evaluating the expression with an empty scope\\n        return evaluate(expression, {})\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3609147,
                "title": "python-well-commented-stack-solution",
                "content": "PHEW! So many edge cases!\\n\\n\\n```\\ndef evaluate(self, expression: str) -> int: \\n        # Split expression at spaces\\n        # Since there are cases where \")\" and \"(\" do not have space around them\\n        # We will add spaces around them and then split the expression\\n        expression = expression.replace(\"(\", \" ( \").replace(\")\", \" ) \").split()\\n        \\n        # Variables and their values\\n        values = defaultdict(list)\\n        \\n        # Stack\\n        stack = []\\n        \\n        # Protected keywords\\n        protected = {\"add\", \"mult\", \"let\"}\\n        \\n        # To keep track of protected keywords\\n        keywords = []\\n        \\n        # REsult of expression\\n        expressionResult = 0\\n        \\n        # If previous value was a digit\\n        ifPreviousDigit = False\\n        \\n        # Loop over the expression\\n        for c in expression:\\n            # If it is an opening parenthesis\\n            if c  == \"(\" : stack.append(c)\\n                \\n            # If it is a word (or word with numbers e.g. \"a1\" and \"a5b\")\\n            elif (not c.isnumeric()) and (c.isalnum()):\\n                # If it is a variable\\n                if c not in protected: \\n                    \\n                    # If this variable is assigned to the variable on top of stack\\n                    # e.g. if we have something like (let b 3 a b)\\n                    # Where for variable \"a\" the value is the value of variable \"b\"\\n                    if (keywords and keywords[-1] == \"let\") and not ifPreviousDigit and type(stack[-1]) is list and not type(stack[-1][0]) is int:\\n                        values[stack[-1][0]].append(int(values[c][-1]))\\n                        stack[-1][1] = True\\n                        ifPreviousDigit = True\\n                    else:\\n                        # We will add an additional flag that indicates whether a value has been assigned to this variable \\n                        # In other words, whether there is a digit after this variable in the input expression\\n                        stack.append([c, False])\\n                else: \\n                    keywords.append(c)\\n                \\n                ifPreviousDigit = False\\n            \\n            # If it is a digit\\n            elif c.isnumeric() or c[0] == \"-\": \\n                if keywords and keywords[-1] == \"let\" and not stack[-1][1]:\\n                    values[stack[-1][0]].append(int(c))\\n                    # Recall what is mentioned in the comment above. Sine it is a digit, we set the flag for variable on top of stack as True\\n                    stack[-1][1] = True\\n                else:\\n                    stack.append([int(c), True])\\n                    \\n                ifPreviousDigit = True\\n            \\n            # If it is closing parenthesis\\n            else:\\n                # Variables\\n                localVars = []\\n                \\n                #  While we don\\'t come across a protected keyword\\n                while stack[-1] != \"(\": localVars.append(stack.pop())\\n\\t\\t\\t\\t\\n                # What type of expression it is \\n                expressionType = keywords.pop()\\n                \\n                # Pop the opening parenthesis\\n                stack.pop()\\n                \\n                # Let\\'s find the result of this expression\\n                result = None\\n                \\n                # If it is an \"add\" or \"mult\" expression\\n                if expressionType != \"let\":\\n                    var1, var2 = localVars[0][0], localVars[1][0]\\n                    \\n                    value1, value2 = 0,0 \\n                    \\n                    # Get the two operands\\n                    if var1 in values: value1 = values[var1][-1]\\n                    else: value1 = var1\\n                        \\n                    if var2 in values: value2 = values[var2][-1]\\n                    else: value2 = var2\\n                    \\n                    # Get the result\\n                    result = value1 + value2 if expressionType == \"add\" else value1 * value2\\n                        \\n                # If it is a \"let\" expression\\n                else:\\n                    # Loop over the local variables\\n                    for var in localVars:\\n                        # If among local variables, we have an integer value\\n                        # Then that is the result of this let expression\\n                        # So we can immediately exit\\n                        if type(var[0]) is int: \\n                            result = var[0]\\n                            break\\n                        # Otherwise, if result is \"None\", set it to the current value\\n                        else:\\n                            if not result: result = values[var[0]][-1]\\n                                \\n                    # Since it is a \"let\" expression, also pop the values from dictionary if there are multiple values assigned to this variable\\n                    # Because in current scope, the current value has been utilized so we won\\'t need it anymore\\n                    for var in localVars:\\n                        if type (var[0]) is not int and len(values[var[0]]) > 1: values[var[0]].pop()\\n                            \\n                # Common Task for all three operations\\n                \\n                # If stack has a variable that was not assigned a value\\n                # Then this result is a value for that variable\\n                if (keywords and keywords[-1] == \"let\") and stack and type(stack[-1]) is list and not stack[-1][1]:\\n                    values[stack[-1][0]].append(result)\\n                    stack[-1][1] = True \\n                    \\n                # Otherwise, push this result to the stack\\n                # And to avoid any errors, also put it in the dictionary with same value as itself\\n                else:\\n                    values[result].append(result)\\n                    stack.append([result, True])\\n                    expressionResult = result\\n\\t\\t\\t\\t\\t\\n        # And Finally, return the result of this expression\\n        return expressionResult \\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef evaluate(self, expression: str) -> int: \\n        # Split expression at spaces\\n        # Since there are cases where \")\" and \"(\" do not have space around them\\n        # We will add spaces around them and then split the expression\\n        expression = expression.replace(\"(\", \" ( \").replace(\")\", \" ) \").split()\\n        \\n        # Variables and their values\\n        values = defaultdict(list)\\n        \\n        # Stack\\n        stack = []\\n        \\n        # Protected keywords\\n        protected = {\"add\", \"mult\", \"let\"}\\n        \\n        # To keep track of protected keywords\\n        keywords = []\\n        \\n        # REsult of expression\\n        expressionResult = 0\\n        \\n        # If previous value was a digit\\n        ifPreviousDigit = False\\n        \\n        # Loop over the expression\\n        for c in expression:\\n            # If it is an opening parenthesis\\n            if c  == \"(\" : stack.append(c)\\n                \\n            # If it is a word (or word with numbers e.g. \"a1\" and \"a5b\")\\n            elif (not c.isnumeric()) and (c.isalnum()):\\n                # If it is a variable\\n                if c not in protected: \\n                    \\n                    # If this variable is assigned to the variable on top of stack\\n                    # e.g. if we have something like (let b 3 a b)\\n                    # Where for variable \"a\" the value is the value of variable \"b\"\\n                    if (keywords and keywords[-1] == \"let\") and not ifPreviousDigit and type(stack[-1]) is list and not type(stack[-1][0]) is int:\\n                        values[stack[-1][0]].append(int(values[c][-1]))\\n                        stack[-1][1] = True\\n                        ifPreviousDigit = True\\n                    else:\\n                        # We will add an additional flag that indicates whether a value has been assigned to this variable \\n                        # In other words, whether there is a digit after this variable in the input expression\\n                        stack.append([c, False])\\n                else: \\n                    keywords.append(c)\\n                \\n                ifPreviousDigit = False\\n            \\n            # If it is a digit\\n            elif c.isnumeric() or c[0] == \"-\": \\n                if keywords and keywords[-1] == \"let\" and not stack[-1][1]:\\n                    values[stack[-1][0]].append(int(c))\\n                    # Recall what is mentioned in the comment above. Sine it is a digit, we set the flag for variable on top of stack as True\\n                    stack[-1][1] = True\\n                else:\\n                    stack.append([int(c), True])\\n                    \\n                ifPreviousDigit = True\\n            \\n            # If it is closing parenthesis\\n            else:\\n                # Variables\\n                localVars = []\\n                \\n                #  While we don\\'t come across a protected keyword\\n                while stack[-1] != \"(\": localVars.append(stack.pop())\\n\\t\\t\\t\\t\\n                # What type of expression it is \\n                expressionType = keywords.pop()\\n                \\n                # Pop the opening parenthesis\\n                stack.pop()\\n                \\n                # Let\\'s find the result of this expression\\n                result = None\\n                \\n                # If it is an \"add\" or \"mult\" expression\\n                if expressionType != \"let\":\\n                    var1, var2 = localVars[0][0], localVars[1][0]\\n                    \\n                    value1, value2 = 0,0 \\n                    \\n                    # Get the two operands\\n                    if var1 in values: value1 = values[var1][-1]\\n                    else: value1 = var1\\n                        \\n                    if var2 in values: value2 = values[var2][-1]\\n                    else: value2 = var2\\n                    \\n                    # Get the result\\n                    result = value1 + value2 if expressionType == \"add\" else value1 * value2\\n                        \\n                # If it is a \"let\" expression\\n                else:\\n                    # Loop over the local variables\\n                    for var in localVars:\\n                        # If among local variables, we have an integer value\\n                        # Then that is the result of this let expression\\n                        # So we can immediately exit\\n                        if type(var[0]) is int: \\n                            result = var[0]\\n                            break\\n                        # Otherwise, if result is \"None\", set it to the current value\\n                        else:\\n                            if not result: result = values[var[0]][-1]\\n                                \\n                    # Since it is a \"let\" expression, also pop the values from dictionary if there are multiple values assigned to this variable\\n                    # Because in current scope, the current value has been utilized so we won\\'t need it anymore\\n                    for var in localVars:\\n                        if type (var[0]) is not int and len(values[var[0]]) > 1: values[var[0]].pop()\\n                            \\n                # Common Task for all three operations\\n                \\n                # If stack has a variable that was not assigned a value\\n                # Then this result is a value for that variable\\n                if (keywords and keywords[-1] == \"let\") and stack and type(stack[-1]) is list and not stack[-1][1]:\\n                    values[stack[-1][0]].append(result)\\n                    stack[-1][1] = True \\n                    \\n                # Otherwise, push this result to the stack\\n                # And to avoid any errors, also put it in the dictionary with same value as itself\\n                else:\\n                    values[result].append(result)\\n                    stack.append([result, True])\\n                    expressionResult = result\\n\\t\\t\\t\\t\\t\\n        # And Finally, return the result of this expression\\n        return expressionResult \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3168112,
                "title": "c-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    const string LET = \"(let\";\\n    const string ADD = \"(add\";\\n    const string MULT = \"(mult\";\\n    const int MIN = 9;\\n    private static Dictionary<string, Stack<int>> _values = new Dictionary<string, Stack<int>>();\\n    private static StringBuilder _sb = new StringBuilder();\\n    private string _text;\\n    private int _index;\\n    public int Evaluate(string expression) {\\n        if (expression.Length < MIN)\\n            return Convert.ToInt32(expression);\\n\\n        // _values.Clear();        \\n        _index = 0;\\n        _text = expression;\\n        return Parse();\\n    }\\n\\n    private int Parse() {\\n        if (StartsWith(_index, LET))\\n            return GoLet();\\n        else if (StartsWith(_index, ADD))\\n            return GoOp(ADD);\\n        else if (StartsWith(_index, MULT))\\n            return GoOp(MULT);\\n        \\n        if (IsSymbol(_text[_index])) {\\n            string name = GoName();\\n            return GetVar(name);\\n        } else {\\n            return GoInt();\\n        }\\n    }\\n\\n    private int GoOp(string template) {\\n        _index += template.Length + 1;\\n        int a = Parse();\\n        _index++;\\n        int b = Parse();\\n        _index++;\\n        return template == ADD ? a + b : a * b;\\n    }\\n\\n    private int GoInt() {\\n        int sign = +1;\\n        if (_index < _text.Length && _text[_index] == \\'-\\') {\\n            sign = -1;\\n            _index++;\\n        }\\n\\n        int res = 0;\\n        while (_index < _text.Length && IsDigit(_text[_index])) {\\n            res = res * 10 + ToInt(_text[_index]);\\n            _index++;\\n        }\\n        \\n        return res * sign;\\n    }\\n\\n    private string GoName() {\\n        _sb.Clear();\\n        while(_index < _text.Length && (IsSymbol(_text[_index]) || IsDigit(_text[_index]))) {\\n            _sb.Append(_text[_index]);\\n            _index++;\\n        }\\n\\n        return _sb.ToString();\\n    }\\n\\n    private int ToInt(char c) => (int)c - (int)\\'0\\';\\n\\n    private bool IsDigit(char c) => \\'0\\' <= c && c <= \\'9\\';\\n\\n    private bool IsSymbol(char c) => (int)\\'a\\' <= (int)c && (int)c <= (int)\\'z\\';\\n\\n    private int GoLet() {\\n        _index += LET.Length + 1;\\n        var context = new HashSet<string>();\\n        string name;\\n        while(true) {\\n            if (IsSymbol(_text[_index])) {\\n                name = GoName();\\n                if (_text[_index] == \\')\\') {\\n                    int retval = GetVar(name);\\n                    LoseContext(context);\\n                    _index++;\\n                    return retval;\\n                }\\n\\n                _index++;\\n                if (context.Contains(name)) {\\n                    SetVar(name, Parse());\\n                } else {\\n                    context.Add(name);\\n                    AddVar(name, Parse());\\n                }\\n                \\n                _index++;\\n            } else {\\n                int retval = Parse();\\n                LoseContext(context);\\n                _index++;\\n                return retval;\\n            }\\n        }\\n\\n        throw new Exception(\"Not expected\");\\n    }\\n\\n    private void AddVar(string name, int val) {\\n        if (!_values.ContainsKey(name))\\n            _values[name] = new Stack<int>();\\n\\n        _values[name].Push(val);\\n    }\\n\\n    private void SetVar(string name, int val) {\\n        _values[name].Pop();\\n        _values[name].Push(val);\\n    }\\n\\n    private int GetVar(string name) => _values[name].Peek();\\n\\n    private void LoseContext(IEnumerable<string> context) {\\n        foreach(string v in context) {\\n            _values[v].Pop();\\n        }\\n    }\\n\\n    private bool StartsWith(int shift, string pattern) {\\n        for(int i = 0; i < pattern.Length && shift + i < _text.Length; i++)\\n            if (_text[shift + i] != pattern[i])\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    const string LET = \"(let\";\\n    const string ADD = \"(add\";\\n    const string MULT = \"(mult\";\\n    const int MIN = 9;\\n    private static Dictionary<string, Stack<int>> _values = new Dictionary<string, Stack<int>>();\\n    private static StringBuilder _sb = new StringBuilder();\\n    private string _text;\\n    private int _index;\\n    public int Evaluate(string expression) {\\n        if (expression.Length < MIN)\\n            return Convert.ToInt32(expression);\\n\\n        // _values.Clear();        \\n        _index = 0;\\n        _text = expression;\\n        return Parse();\\n    }\\n\\n    private int Parse() {\\n        if (StartsWith(_index, LET))\\n            return GoLet();\\n        else if (StartsWith(_index, ADD))\\n            return GoOp(ADD);\\n        else if (StartsWith(_index, MULT))\\n            return GoOp(MULT);\\n        \\n        if (IsSymbol(_text[_index])) {\\n            string name = GoName();\\n            return GetVar(name);\\n        } else {\\n            return GoInt();\\n        }\\n    }\\n\\n    private int GoOp(string template) {\\n        _index += template.Length + 1;\\n        int a = Parse();\\n        _index++;\\n        int b = Parse();\\n        _index++;\\n        return template == ADD ? a + b : a * b;\\n    }\\n\\n    private int GoInt() {\\n        int sign = +1;\\n        if (_index < _text.Length && _text[_index] == \\'-\\') {\\n            sign = -1;\\n            _index++;\\n        }\\n\\n        int res = 0;\\n        while (_index < _text.Length && IsDigit(_text[_index])) {\\n            res = res * 10 + ToInt(_text[_index]);\\n            _index++;\\n        }\\n        \\n        return res * sign;\\n    }\\n\\n    private string GoName() {\\n        _sb.Clear();\\n        while(_index < _text.Length && (IsSymbol(_text[_index]) || IsDigit(_text[_index]))) {\\n            _sb.Append(_text[_index]);\\n            _index++;\\n        }\\n\\n        return _sb.ToString();\\n    }\\n\\n    private int ToInt(char c) => (int)c - (int)\\'0\\';\\n\\n    private bool IsDigit(char c) => \\'0\\' <= c && c <= \\'9\\';\\n\\n    private bool IsSymbol(char c) => (int)\\'a\\' <= (int)c && (int)c <= (int)\\'z\\';\\n\\n    private int GoLet() {\\n        _index += LET.Length + 1;\\n        var context = new HashSet<string>();\\n        string name;\\n        while(true) {\\n            if (IsSymbol(_text[_index])) {\\n                name = GoName();\\n                if (_text[_index] == \\')\\') {\\n                    int retval = GetVar(name);\\n                    LoseContext(context);\\n                    _index++;\\n                    return retval;\\n                }\\n\\n                _index++;\\n                if (context.Contains(name)) {\\n                    SetVar(name, Parse());\\n                } else {\\n                    context.Add(name);\\n                    AddVar(name, Parse());\\n                }\\n                \\n                _index++;\\n            } else {\\n                int retval = Parse();\\n                LoseContext(context);\\n                _index++;\\n                return retval;\\n            }\\n        }\\n\\n        throw new Exception(\"Not expected\");\\n    }\\n\\n    private void AddVar(string name, int val) {\\n        if (!_values.ContainsKey(name))\\n            _values[name] = new Stack<int>();\\n\\n        _values[name].Push(val);\\n    }\\n\\n    private void SetVar(string name, int val) {\\n        _values[name].Pop();\\n        _values[name].Push(val);\\n    }\\n\\n    private int GetVar(string name) => _values[name].Peek();\\n\\n    private void LoseContext(IEnumerable<string> context) {\\n        foreach(string v in context) {\\n            _values[v].Pop();\\n        }\\n    }\\n\\n    private bool StartsWith(int shift, string pattern) {\\n        for(int i = 0; i < pattern.Length && shift + i < _text.Length; i++)\\n            if (_text[shift + i] != pattern[i])\\n                return false;\\n        \\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2923178,
                "title": "c-recursion-with-explanation",
                "content": "# Intuition\\nRecursively resolve add/mult/let. Matain a global index to iterate through the input string. Use unordered_map to store mappings in let. Map is inherited(copied) from let opration from parent level.\\n\\nThe eval function assumes a ( at current index. Corresponding ) is skipped before eval returns.\\n\\nThe parse_and_eval function either parse and number or variable or call eval to evaluate an expression. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n), n = len of input string.\\n\\n- Space complexity:\\nO(m), m = numer of pair in all let operations.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        unordered_map<string, int> map;\\n        int idx = 0;\\n        return eval(expression, idx, map);\\n    }\\n\\n    int eval(const string& exp, int& idx, const unordered_map<string, int>& map){\\n        int result;\\n        // Skip leading (.\\n        idx++;\\n        int end = exp.find(\\' \\', idx);\\n        const string op = exp.substr(idx, end - idx);\\n        idx = end + 1;\\n        if(op == \"add\" || op == \"mult\"){\\n            const int v1 = parse_and_eval(exp, idx, map);\\n            const int v2 = parse_and_eval(exp, idx, map);\\n            result = op == \"add\" ? v1 + v2 : v1 * v2;\\n        }else{ // Let.\\n            // Copy current map and overwrite if necessary.\\n            unordered_map<string, int> new_map = map;\\n            while(exp[idx] != \\'(\\'){\\n                // Check and stop to evaluate let.\\n                end = idx;\\n                while(exp[end] != \\' \\' && exp[end] != \\')\\') ++end;\\n                if(exp[end] == \\')\\') break;\\n                // Get a (v, e) pair.\\n                const string var = exp.substr(idx, end - idx);\\n                idx = end + 1;\\n                const int val = parse_and_eval(exp, idx, new_map);\\n                new_map[var] = val;\\n            }\\n            result = parse_and_eval(exp, idx, new_map);\\n        }\\n        // Skip ending ).\\n        idx++;\\n        return result;\\n    }\\n\\n    int parse_and_eval(const string& exp, int& idx, const unordered_map<string, int>& map){\\n        int result;\\n        if(exp[idx] == \\'(\\'){\\n            // Expression start with a (.\\n            result = eval(exp, idx, map);\\n            // Skip ending space if exists.\\n            if(exp[idx] == \\' \\') ++idx;\\n        }else{ // Numbers or Variables.\\n            // It\\'s either a space or a ) at end index.\\n            int end = idx;\\n            while(exp[end] != \\' \\' && exp[end] != \\')\\') ++end;\\n            if(exp[idx] == \\'-\\' || (exp[idx] >= \\'0\\' && exp[idx] <= \\'9\\'))\\n                result = stoi(exp.substr(idx, end - idx));\\n            else // Variables.\\n                result = map.at(exp.substr(idx, end - idx));\\n            idx = exp[end] == \\' \\' ? end + 1 : end;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        unordered_map<string, int> map;\\n        int idx = 0;\\n        return eval(expression, idx, map);\\n    }\\n\\n    int eval(const string& exp, int& idx, const unordered_map<string, int>& map){\\n        int result;\\n        // Skip leading (.\\n        idx++;\\n        int end = exp.find(\\' \\', idx);\\n        const string op = exp.substr(idx, end - idx);\\n        idx = end + 1;\\n        if(op == \"add\" || op == \"mult\"){\\n            const int v1 = parse_and_eval(exp, idx, map);\\n            const int v2 = parse_and_eval(exp, idx, map);\\n            result = op == \"add\" ? v1 + v2 : v1 * v2;\\n        }else{ // Let.\\n            // Copy current map and overwrite if necessary.\\n            unordered_map<string, int> new_map = map;\\n            while(exp[idx] != \\'(\\'){\\n                // Check and stop to evaluate let.\\n                end = idx;\\n                while(exp[end] != \\' \\' && exp[end] != \\')\\') ++end;\\n                if(exp[end] == \\')\\') break;\\n                // Get a (v, e) pair.\\n                const string var = exp.substr(idx, end - idx);\\n                idx = end + 1;\\n                const int val = parse_and_eval(exp, idx, new_map);\\n                new_map[var] = val;\\n            }\\n            result = parse_and_eval(exp, idx, new_map);\\n        }\\n        // Skip ending ).\\n        idx++;\\n        return result;\\n    }\\n\\n    int parse_and_eval(const string& exp, int& idx, const unordered_map<string, int>& map){\\n        int result;\\n        if(exp[idx] == \\'(\\'){\\n            // Expression start with a (.\\n            result = eval(exp, idx, map);\\n            // Skip ending space if exists.\\n            if(exp[idx] == \\' \\') ++idx;\\n        }else{ // Numbers or Variables.\\n            // It\\'s either a space or a ) at end index.\\n            int end = idx;\\n            while(exp[end] != \\' \\' && exp[end] != \\')\\') ++end;\\n            if(exp[idx] == \\'-\\' || (exp[idx] >= \\'0\\' && exp[idx] <= \\'9\\'))\\n                result = stoi(exp.substr(idx, end - idx));\\n            else // Variables.\\n                result = map.at(exp.substr(idx, end - idx));\\n            idx = exp[end] == \\' \\' ? end + 1 : end;\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907850,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn evaluate(expression: String) -> i32 {\\n        let mut variables = HashMap::new();\\n        Self::get_val(expression.as_str(), &mut variables)\\n    }\\n\\n    fn get_val(expr: &str, variables: &mut HashMap<String, i32>) -> i32 {\\n        let type_ = Self::get_type(expr);\\n        if type_ == 1 {\\n            let tokens = Self::parse(expr);\\n            println!(\"{:?}\", tokens);\\n            Self::_evaluate_(&tokens, variables)\\n        } else if type_ == 2 {\\n            *variables.get(expr).unwrap()\\n        } else {\\n            let mut val = 0;\\n            let mut sign = 1;\\n            for c in expr.chars() {\\n                if c == \\'-\\' {\\n                    sign = -1;\\n                } else {\\n                    val = (val * 10) + (c as i32 - \\'0\\' as i32);\\n                }\\n            }\\n            val * sign\\n        }\\n    }\\n\\n    fn _evaluate_(tokens: &[String], variables: &HashMap<String, i32>) -> i32 {\\n        let mut variables = variables.clone();\\n        let return_val;\\n        if tokens[0] == \"mult\" {\\n            return_val = Self::get_val(&tokens[1], &mut variables) * Self::get_val(&tokens[2], &mut variables);\\n        } else if tokens[0] == \"add\" {\\n            return_val = Self::get_val(&tokens[1], &mut variables) + Self::get_val(&tokens[2], &mut variables);\\n        } else {\\n            for i in (1..tokens.len() - 1).step_by(2) {\\n                let v = Self::get_val(&tokens[i + 1], &mut variables);\\n                variables.insert(tokens[i].to_string(), v);\\n            }\\n            return_val = Self::get_val(tokens.last().unwrap(), &mut variables);\\n        }\\n        return_val\\n    }\\n\\n    fn parse(expr: &str) -> Vec<String> {\\n        let mut cursor = 1;\\n        let mut start = 1;\\n        let mut tokens = Vec::new();\\n        while cursor < expr.len() {\\n            let c = expr.chars().nth(cursor).unwrap();\\n            if c == \\' \\' || c == \\')\\' {\\n                tokens.push(expr[start..cursor].to_string());\\n                start = cursor + 1;\\n            } else if c == \\'(\\' {\\n                let mut open_parenthesis = 1;\\n                while open_parenthesis > 0 && cursor < expr.len() {\\n                    cursor += 1;\\n                    let c = expr.chars().nth(cursor).unwrap();\\n                    if c == \\'(\\' {\\n                        open_parenthesis += 1;\\n                    } else if c == \\')\\' {\\n                        open_parenthesis -= 1;\\n                    }\\n                }\\n            }\\n            cursor += 1;\\n        }\\n        tokens\\n    }\\n\\n    fn get_type(expr: &str) -> i32 {\\n        let begin = expr.chars().next().unwrap();\\n        if begin == \\'(\\' {\\n            1\\n        } else if (\\'a\\'..=\\'z\\').contains(&begin) {\\n            2\\n        } else {\\n            3\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nuse std::collections::HashMap;\\nimpl Solution {\\n    pub fn evaluate(expression: String) -> i32 {\\n        let mut variables = HashMap::new();\\n        Self::get_val(expression.as_str(), &mut variables)\\n    }\\n\\n    fn get_val(expr: &str, variables: &mut HashMap<String, i32>) -> i32 {\\n        let type_ = Self::get_type(expr);\\n        if type_ == 1 {\\n            let tokens = Self::parse(expr);\\n            println!(\"{:?}\", tokens);\\n            Self::_evaluate_(&tokens, variables)\\n        } else if type_ == 2 {\\n            *variables.get(expr).unwrap()\\n        } else {\\n            let mut val = 0;\\n            let mut sign = 1;\\n            for c in expr.chars() {\\n                if c == \\'-\\' {\\n                    sign = -1;\\n                } else {\\n                    val = (val * 10) + (c as i32 - \\'0\\' as i32);\\n                }\\n            }\\n            val * sign\\n        }\\n    }\\n\\n    fn _evaluate_(tokens: &[String], variables: &HashMap<String, i32>) -> i32 {\\n        let mut variables = variables.clone();\\n        let return_val;\\n        if tokens[0] == \"mult\" {\\n            return_val = Self::get_val(&tokens[1], &mut variables) * Self::get_val(&tokens[2], &mut variables);\\n        } else if tokens[0] == \"add\" {\\n            return_val = Self::get_val(&tokens[1], &mut variables) + Self::get_val(&tokens[2], &mut variables);\\n        } else {\\n            for i in (1..tokens.len() - 1).step_by(2) {\\n                let v = Self::get_val(&tokens[i + 1], &mut variables);\\n                variables.insert(tokens[i].to_string(), v);\\n            }\\n            return_val = Self::get_val(tokens.last().unwrap(), &mut variables);\\n        }\\n        return_val\\n    }\\n\\n    fn parse(expr: &str) -> Vec<String> {\\n        let mut cursor = 1;\\n        let mut start = 1;\\n        let mut tokens = Vec::new();\\n        while cursor < expr.len() {\\n            let c = expr.chars().nth(cursor).unwrap();\\n            if c == \\' \\' || c == \\')\\' {\\n                tokens.push(expr[start..cursor].to_string());\\n                start = cursor + 1;\\n            } else if c == \\'(\\' {\\n                let mut open_parenthesis = 1;\\n                while open_parenthesis > 0 && cursor < expr.len() {\\n                    cursor += 1;\\n                    let c = expr.chars().nth(cursor).unwrap();\\n                    if c == \\'(\\' {\\n                        open_parenthesis += 1;\\n                    } else if c == \\')\\' {\\n                        open_parenthesis -= 1;\\n                    }\\n                }\\n            }\\n            cursor += 1;\\n        }\\n        tokens\\n    }\\n\\n    fn get_type(expr: &str) -> i32 {\\n        let begin = expr.chars().next().unwrap();\\n        if begin == \\'(\\' {\\n            1\\n        } else if (\\'a\\'..=\\'z\\').contains(&begin) {\\n            2\\n        } else {\\n            3\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2902650,
                "title": "typescript-solution-with-generator",
                "content": "```\\nfunction evaluate(expr: string, vars: Record<string, number> = {}) {\\n    const evalWord = (word: string) => {\\n        return evaluate(word, { ...vars });\\n    };\\n\\n    if (expr[0] === \\'(\\') {\\n        expr = expr.slice(1, -1);\\n    }\\n\\n    const words = getWords(expr);\\n    const fn = words.next().value;\\n    let word1 = words.next();\\n    let word2 = words.next();\\n\\n    switch (fn) {\\n        case \\'let\\': {\\n            while (!word2.done) {\\n                vars[word1.value] = evalWord(word2.value);\\n                word1 = words.next();\\n                word2 = words.next();\\n            }\\n            return evalWord(word1.value);\\n        }\\n        case \\'mult\\': {\\n            return evalWord(word1.value) * evalWord(word2.value);\\n        }\\n        case \\'add\\': {\\n            return evalWord(word1.value) + evalWord(word2.value);\\n        }\\n    }\\n\\n    return fn in vars ? vars[fn] : Number(fn);\\n}\\n\\nfunction* getWords(expr: string) {\\n    let open = 0;\\n    let word = \\'\\';\\n    for (const c of expr) {\\n        word += c;\\n        switch (c) {\\n            case \\'(\\': {\\n                open++;\\n                break;\\n            }\\n            case \\')\\': {\\n                open--;\\n                break;\\n            }\\n            case \\' \\': {\\n                if (!open) {\\n                    yield word.slice(0, -1);\\n                    word = \\'\\';\\n                }\\n                break;\\n            }\\n        }\\n    }\\n    yield word;\\n    return \\'\\';\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction evaluate(expr: string, vars: Record<string, number> = {}) {\\n    const evalWord = (word: string) => {\\n        return evaluate(word, { ...vars });\\n    };\\n\\n    if (expr[0] === \\'(\\') {\\n        expr = expr.slice(1, -1);\\n    }\\n\\n    const words = getWords(expr);\\n    const fn = words.next().value;\\n    let word1 = words.next();\\n    let word2 = words.next();\\n\\n    switch (fn) {\\n        case \\'let\\': {\\n            while (!word2.done) {\\n                vars[word1.value] = evalWord(word2.value);\\n                word1 = words.next();\\n                word2 = words.next();\\n            }\\n            return evalWord(word1.value);\\n        }\\n        case \\'mult\\': {\\n            return evalWord(word1.value) * evalWord(word2.value);\\n        }\\n        case \\'add\\': {\\n            return evalWord(word1.value) + evalWord(word2.value);\\n        }\\n    }\\n\\n    return fn in vars ? vars[fn] : Number(fn);\\n}\\n\\nfunction* getWords(expr: string) {\\n    let open = 0;\\n    let word = \\'\\';\\n    for (const c of expr) {\\n        word += c;\\n        switch (c) {\\n            case \\'(\\': {\\n                open++;\\n                break;\\n            }\\n            case \\')\\': {\\n                open--;\\n                break;\\n            }\\n            case \\' \\': {\\n                if (!open) {\\n                    yield word.slice(0, -1);\\n                    word = \\'\\';\\n                }\\n                break;\\n            }\\n        }\\n    }\\n    yield word;\\n    return \\'\\';\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2878243,
                "title": "c-with-balanced-paranthesis",
                "content": "# Intuition\\nA recursive was of solving nested expression. The key is to find the end of the expression, which is obtained by another function matchingparanthesis -- an easy LC problem.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        unordered_map<string, int> hashmap;\\n        return parse(expression, hashmap);\\n    }\\n    int parse(string str, unordered_map<string, int> hashmap) {\\n        if(str.size() == 0) return 0;\\n        if(hashmap.count(str)) {\\n            auto res = hashmap[str];\\n            return res;\\n        }\\n        auto currop = str.substr(1,3);\\n        string last_var;\\n        if(currop == \"let\") {\\n            int l = 5, r = 5;\\n            bool var_or_val = 0; // 1 var, 0 val or expression\\n            while(true) {\\n                if(str[r] == \\' \\') {\\n                    auto curr = str.substr(l, r-l);\\n                    if(not var_or_val) {\\n                        last_var = curr;\\n                    }\\n                    else {\\n                        if(isdigit(curr[0]) or curr[0] == \\'-\\')\\n                            hashmap[last_var] = stoi(curr);\\n                        else\\n                            hashmap[last_var] = hashmap[curr];\\n                    }\\n                    r++;\\n                    l = r;\\n                    var_or_val = not var_or_val;\\n                    continue;\\n                }\\n                if(str[r] == \\')\\') {\\n                    auto curr = str.substr(l, r-l);\\n                    if(isdigit(str[l]) or str[l] == \\'-\\') {\\n                        return stoi(curr);\\n                    }\\n                    return hashmap[curr];\\n                }\\n                if(str[r] == \\'(\\') {\\n                    int nextidx = matchingparanthesis(str, r)+1;\\n                    int expval = parse(str.substr(r, nextidx-r), hashmap);\\n                    if(str[nextidx] == \\' \\') {\\n                        hashmap[last_var] = expval;\\n                        r = nextidx+1;\\n                        l = r;\\n                        var_or_val = 0;\\n                        continue;\\n                    }\\n                    return expval;\\n                }\\n                r++;\\n            }\\n        }\\n        else if(currop == \"mul\") {\\n            auto res = sum_mult(str, 6, 6, hashmap);\\n            return res.first * res.second;\\n        }\\n        else { // add\\n            auto res = sum_mult(str, 5, 5, hashmap);\\n            return res.first + res.second;\\n        }\\n        return 0;\\n    }\\n\\n    pair<int, int> sum_mult(string str, int l, int r, unordered_map<string, int> &hashmap) {\\n            int first, second = 0;\\n            if(str[l] == \\'(\\') {\\n                int nextidx = matchingparanthesis(str, l)+1;\\n                first = parse(str.substr(l, nextidx-l), hashmap);\\n                r = nextidx+1;\\n                l = r;\\n            }\\n            else {\\n                while(true) {\\n                    if(str[r] == \\' \\') {\\n                        auto curr = str.substr(l, r-l);\\n                        if(hashmap.count(curr)) {\\n                            first = hashmap[curr];\\n                        }\\n                        else {\\n                            first = stoi(curr);\\n                        }\\n                        break;\\n                    }\\n                    r++;\\n                }\\n                r++;\\n                l = r;\\n            }\\n\\n            if(str[l] == \\'(\\') {\\n                int nextidx = matchingparanthesis(str, l)+1;\\n                second = parse(str.substr(r, nextidx-l), hashmap);\\n            }\\n            else {\\n                while(true) {\\n                    if(str[r] == \\')\\') {\\n                        auto curr = str.substr(l, r-l);\\n                        if(hashmap.count(curr)) {\\n                            second = hashmap[curr];\\n                        }\\n                        else {\\n                            second = stoi(curr);\\n                        }\\n                        break;\\n                    }\\n                    r++;\\n                }\\n            }\\n            return {first, second};         \\n    }\\n\\n    int matchingparanthesis(string str, int curr) {\\n        int cnt = 1;\\n        curr++;\\n        while(cnt > 0) {\\n            if(str[curr] == \\')\\')\\n                cnt--;\\n            if(str[curr] == \\'(\\')\\n                cnt++;\\n            curr++;\\n        }\\n        return --curr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        unordered_map<string, int> hashmap;\\n        return parse(expression, hashmap);\\n    }\\n    int parse(string str, unordered_map<string, int> hashmap) {\\n        if(str.size() == 0) return 0;\\n        if(hashmap.count(str)) {\\n            auto res = hashmap[str];\\n            return res;\\n        }\\n        auto currop = str.substr(1,3);\\n        string last_var;\\n        if(currop == \"let\") {\\n            int l = 5, r = 5;\\n            bool var_or_val = 0; // 1 var, 0 val or expression\\n            while(true) {\\n                if(str[r] == \\' \\') {\\n                    auto curr = str.substr(l, r-l);\\n                    if(not var_or_val) {\\n                        last_var = curr;\\n                    }\\n                    else {\\n                        if(isdigit(curr[0]) or curr[0] == \\'-\\')\\n                            hashmap[last_var] = stoi(curr);\\n                        else\\n                            hashmap[last_var] = hashmap[curr];\\n                    }\\n                    r++;\\n                    l = r;\\n                    var_or_val = not var_or_val;\\n                    continue;\\n                }\\n                if(str[r] == \\')\\') {\\n                    auto curr = str.substr(l, r-l);\\n                    if(isdigit(str[l]) or str[l] == \\'-\\') {\\n                        return stoi(curr);\\n                    }\\n                    return hashmap[curr];\\n                }\\n                if(str[r] == \\'(\\') {\\n                    int nextidx = matchingparanthesis(str, r)+1;\\n                    int expval = parse(str.substr(r, nextidx-r), hashmap);\\n                    if(str[nextidx] == \\' \\') {\\n                        hashmap[last_var] = expval;\\n                        r = nextidx+1;\\n                        l = r;\\n                        var_or_val = 0;\\n                        continue;\\n                    }\\n                    return expval;\\n                }\\n                r++;\\n            }\\n        }\\n        else if(currop == \"mul\") {\\n            auto res = sum_mult(str, 6, 6, hashmap);\\n            return res.first * res.second;\\n        }\\n        else { // add\\n            auto res = sum_mult(str, 5, 5, hashmap);\\n            return res.first + res.second;\\n        }\\n        return 0;\\n    }\\n\\n    pair<int, int> sum_mult(string str, int l, int r, unordered_map<string, int> &hashmap) {\\n            int first, second = 0;\\n            if(str[l] == \\'(\\') {\\n                int nextidx = matchingparanthesis(str, l)+1;\\n                first = parse(str.substr(l, nextidx-l), hashmap);\\n                r = nextidx+1;\\n                l = r;\\n            }\\n            else {\\n                while(true) {\\n                    if(str[r] == \\' \\') {\\n                        auto curr = str.substr(l, r-l);\\n                        if(hashmap.count(curr)) {\\n                            first = hashmap[curr];\\n                        }\\n                        else {\\n                            first = stoi(curr);\\n                        }\\n                        break;\\n                    }\\n                    r++;\\n                }\\n                r++;\\n                l = r;\\n            }\\n\\n            if(str[l] == \\'(\\') {\\n                int nextidx = matchingparanthesis(str, l)+1;\\n                second = parse(str.substr(r, nextidx-l), hashmap);\\n            }\\n            else {\\n                while(true) {\\n                    if(str[r] == \\')\\') {\\n                        auto curr = str.substr(l, r-l);\\n                        if(hashmap.count(curr)) {\\n                            second = hashmap[curr];\\n                        }\\n                        else {\\n                            second = stoi(curr);\\n                        }\\n                        break;\\n                    }\\n                    r++;\\n                }\\n            }\\n            return {first, second};         \\n    }\\n\\n    int matchingparanthesis(string str, int curr) {\\n        int cnt = 1;\\n        curr++;\\n        while(cnt > 0) {\\n            if(str[curr] == \\')\\')\\n                cnt--;\\n            if(str[curr] == \\'(\\')\\n                cnt++;\\n            curr++;\\n        }\\n        return --curr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701091,
                "title": "c-simple-approach",
                "content": "Runtime: 7 ms, faster than 85.29% of C++ online submissions for Parse Lisp Expression.\\nMemory Usage: 16.1 MB, less than 54.41% of C++ online submissions for Parse Lisp Expression.\\n\\n```\\nclass Solution {\\n    vector<string_view> parse(string_view expr) {\\n        int cursor = 1, start = 1;\\n        vector<string_view> tokens;\\n        while (cursor < expr.length()) {\\n            if (expr[cursor] == \\' \\' || expr[cursor] == \\')\\') {\\n                tokens.emplace_back(expr.substr(start, (cursor - start)));\\n                start = cursor + 1;\\n            } else if (expr[cursor] == \\'(\\') {\\n                int open_parenthesis = 1;\\n                while (open_parenthesis) {\\n                    ++cursor;\\n                    if (expr[cursor] == \\'(\\') ++open_parenthesis;\\n                    else if (expr[cursor] == \\')\\') --open_parenthesis;\\n                }\\n            }\\n            ++cursor;\\n        }\\n\\n        return tokens;\\n    }\\n\\n    int evaluate(vector<string_view> &tokens, unordered_map<string_view, int> variables) {\\n        int return_val;\\n        if (tokens[0] == \"mult\")\\n            return_val = getVal(tokens[1], variables) * getVal(tokens[2], variables);\\n        else if (tokens[0] == \"add\")\\n            return_val = getVal(tokens[1], variables) + getVal(tokens[2], variables);\\n        else {\\n            for (int i = 1; i < tokens.size() - 1; i += 2)\\n                variables[tokens[i]] = getVal(tokens[i + 1], variables);\\n            return getVal(tokens.back(), variables);\\n        }\\n\\n        return return_val;\\n    }\\n\\n    int getVal(string_view expr, unordered_map<string_view, int> &variables) {\\n        int type = getType(expr);\\n        if (type == 1) {\\n            vector<string_view> tokens = parse(expr);\\n            return evaluate(tokens, variables);\\n        } else if (type == 2) return variables[expr];\\n        int val = 0, sign = 1;\\n        for (auto &c: expr)\\n            if (c == \\'-\\') sign = -1;\\n            else val = (val * 10) + (c - \\'0\\');\\n        return val * sign;\\n    }\\n\\n    int getType(string_view expr) {\\n        return (expr[0] == \\'(\\') ? 1 : (expr[0] >= \\'a\\' && expr[0] <= \\'z\\') ? 2 : 3;\\n    }\\n\\npublic:\\n    int evaluate(string expression) {\\n        unordered_map<string_view, int> variables;\\n        return getVal(string_view(expression), variables);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<string_view> parse(string_view expr) {\\n        int cursor = 1, start = 1;\\n        vector<string_view> tokens;\\n        while (cursor < expr.length()) {\\n            if (expr[cursor] == \\' \\' || expr[cursor] == \\')\\') {\\n                tokens.emplace_back(expr.substr(start, (cursor - start)));\\n                start = cursor + 1;\\n            } else if (expr[cursor] == \\'(\\') {\\n                int open_parenthesis = 1;\\n                while (open_parenthesis) {\\n                    ++cursor;\\n                    if (expr[cursor] == \\'(\\') ++open_parenthesis;\\n                    else if (expr[cursor] == \\')\\') --open_parenthesis;\\n                }\\n            }\\n            ++cursor;\\n        }\\n\\n        return tokens;\\n    }\\n\\n    int evaluate(vector<string_view> &tokens, unordered_map<string_view, int> variables) {\\n        int return_val;\\n        if (tokens[0] == \"mult\")\\n            return_val = getVal(tokens[1], variables) * getVal(tokens[2], variables);\\n        else if (tokens[0] == \"add\")\\n            return_val = getVal(tokens[1], variables) + getVal(tokens[2], variables);\\n        else {\\n            for (int i = 1; i < tokens.size() - 1; i += 2)\\n                variables[tokens[i]] = getVal(tokens[i + 1], variables);\\n            return getVal(tokens.back(), variables);\\n        }\\n\\n        return return_val;\\n    }\\n\\n    int getVal(string_view expr, unordered_map<string_view, int> &variables) {\\n        int type = getType(expr);\\n        if (type == 1) {\\n            vector<string_view> tokens = parse(expr);\\n            return evaluate(tokens, variables);\\n        } else if (type == 2) return variables[expr];\\n        int val = 0, sign = 1;\\n        for (auto &c: expr)\\n            if (c == \\'-\\') sign = -1;\\n            else val = (val * 10) + (c - \\'0\\');\\n        return val * sign;\\n    }\\n\\n    int getType(string_view expr) {\\n        return (expr[0] == \\'(\\') ? 1 : (expr[0] >= \\'a\\' && expr[0] <= \\'z\\') ? 2 : 3;\\n    }\\n\\npublic:\\n    int evaluate(string expression) {\\n        unordered_map<string_view, int> variables;\\n        return getVal(string_view(expression), variables);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2661134,
                "title": "python-rec-solution",
                "content": "```\\nclass Solution:\\n    def evaluate(self, s: str) -> int:\\n        rx = []\\n        i = 0\\n        while i < len(s):\\n            if s[i] == \" \":\\n                i += 1\\n                continue\\n            if s[i] == \"(\" or s[i] == \")\":\\n                rx.append(s[i])\\n                i += 1\\n                continue\\n\\n            x = []\\n            while i < len(s) and not (s[i] == \" \" or s[i] == \"(\" or s[i] == \")\"):\\n                x.append(s[i])\\n                i += 1\\n            rx.append(\"\".join(x))\\n            \\n        s = deque(rx)\\n        def p_expr(stmt):\\n            if s[0].lstrip(\"-\").isnumeric():return int(s.popleft())\\n            if s[0] in stmt:return int(stmt[s.popleft()])\\n            if s[0] == \"(\":\\n                s.popleft()\\n                nx = s.popleft()\\n                if nx == \"add\":\\n                    x1 = p_expr(stmt.copy())\\n                    x2 = p_expr(stmt.copy())\\n                    s.popleft()\\n                    return x1 + x2\\n                elif nx == \"mult\":\\n                    x1 = p_expr(stmt.copy())\\n                    x2 = p_expr(stmt.copy())\\n                    s.popleft()\\n                    return x1 * x2\\n                elif nx == \"let\":\\n                    last = 0\\n                    while True:\\n                        if s[0] == \"(\":\\n                            last = p_expr(stmt.copy())\\n                            stmt[var] = last\\n                            continue\\n                        elif s[0] == \")\":\\n                            s.popleft()\\n                            return last\\n                        else:\\n                            var = s.popleft()\\n                            if s[0] == \")\":\\n                                s.popleft()\\n                                return int(stmt[var]) if var in stmt else int(var)\\n                            last = p_expr(stmt.copy())\\n                            stmt[var] = last\\n                    return last\\n        return p_expr({})\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str) -> int:\\n        rx = []\\n        i = 0\\n        while i < len(s):\\n            if s[i] == \" \":\\n                i += 1\\n                continue\\n            if s[i] == \"(\" or s[i] == \")\":\\n                rx.append(s[i])\\n                i += 1\\n                continue\\n\\n            x = []\\n            while i < len(s) and not (s[i] == \" \" or s[i] == \"(\" or s[i] == \")\"):\\n                x.append(s[i])\\n                i += 1\\n            rx.append(\"\".join(x))\\n            \\n        s = deque(rx)\\n        def p_expr(stmt):\\n            if s[0].lstrip(\"-\").isnumeric():return int(s.popleft())\\n            if s[0] in stmt:return int(stmt[s.popleft()])\\n            if s[0] == \"(\":\\n                s.popleft()\\n                nx = s.popleft()\\n                if nx == \"add\":\\n                    x1 = p_expr(stmt.copy())\\n                    x2 = p_expr(stmt.copy())\\n                    s.popleft()\\n                    return x1 + x2\\n                elif nx == \"mult\":\\n                    x1 = p_expr(stmt.copy())\\n                    x2 = p_expr(stmt.copy())\\n                    s.popleft()\\n                    return x1 * x2\\n                elif nx == \"let\":\\n                    last = 0\\n                    while True:\\n                        if s[0] == \"(\":\\n                            last = p_expr(stmt.copy())\\n                            stmt[var] = last\\n                            continue\\n                        elif s[0] == \")\":\\n                            s.popleft()\\n                            return last\\n                        else:\\n                            var = s.popleft()\\n                            if s[0] == \")\":\\n                                s.popleft()\\n                                return int(stmt[var]) if var in stmt else int(var)\\n                            last = p_expr(stmt.copy())\\n                            stmt[var] = last\\n                    return last\\n        return p_expr({})\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618772,
                "title": "c-recursive-solution",
                "content": "helper functions:\\n> get_token: get next valid token string, move pos to next character\\n> peek: get next non space character, set pos to that chatacter\\n> get_val: get value of a variable\\n> \\n```\\nclass Solution {\\npublic:\\n    vector<unordered_map<string, int>> cts;\\n    int evaluate(string expression) {\\n      int pos = 0;\\n      return eval(expression, pos);\\n    }\\n    int eval(const string& expr, int& pos) {\\n      if (pos == expr.size()) { return -1; }\\n      cts.push_back({});\\n      string token;\\n      int ret;\\n      if (peek(expr, pos) != \\'(\\') {\\n        token = get_token(expr, pos);\\n        if (isalpha(token[0])) {\\n          ret = get_val(token);\\n        } else {\\n          ret = stoi(token);\\n        }\\n      } else {\\n        ++pos;\\n        token = get_token(expr, pos);\\n        if (token == \"let\") {\\n          while (true) {\\n            if (peek(expr, pos) == \\'(\\') {\\n              ret = eval(expr, pos);\\n              break;\\n            }\\n            string v = get_token(expr, pos);\\n            if (peek(expr, pos) == \\')\\') {\\n              ++pos;\\n              if (isalpha(v[0])) {\\n                ret = get_val(v);\\n              } else {\\n                ret = stoi(v);\\n              }\\n              break;\\n            }\\n            cts.back()[v] = eval(expr, pos);\\n          }\\n        } else if (token == \"add\") {\\n          int lhs = eval(expr, pos);\\n          int rhs = eval(expr, pos);\\n          ret = lhs + rhs;\\n        } else if (token == \"mult\") {\\n          int lhs = eval(expr, pos);\\n          int rhs = eval(expr, pos);\\n          ret = lhs * rhs;\\n        }\\n        if (peek(expr, pos) == \\')\\') { ++pos; }\\n      }\\n      cts.pop_back();\\n      return ret;\\n    }\\n    string get_token(const string& expr, int& pos) {\\n      string ret;\\n      while (expr[pos] == \\' \\') { ++pos; }\\n      while (expr[pos] != \\' \\') {\\n        if (expr[pos] == \\'(\\' || expr[pos] == \\')\\') {\\n          if (ret.empty()) {\\n            ret = expr[pos];\\n            ++pos;\\n          }\\n          break;\\n        } else {\\n          ret += expr[pos];\\n          ++pos;\\n        }\\n      }\\n      return ret;\\n    }\\n    char peek(const string& expr, int &pos) {\\n      while (expr[pos] == \\' \\') { ++pos; }\\n      return expr[pos];\\n    }\\n    int get_val(const string& vname) {\\n      for (auto it = cts.rbegin(); it != cts.rend(); ++it) {\\n        auto fit = it->find(vname);\\n        if (fit != it->end()) {\\n          return fit->second;\\n        }\\n      }\\n      return 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<unordered_map<string, int>> cts;\\n    int evaluate(string expression) {\\n      int pos = 0;\\n      return eval(expression, pos);\\n    }\\n    int eval(const string& expr, int& pos) {\\n      if (pos == expr.size()) { return -1; }\\n      cts.push_back({});\\n      string token;\\n      int ret;\\n      if (peek(expr, pos) != \\'(\\') {\\n        token = get_token(expr, pos);\\n        if (isalpha(token[0])) {\\n          ret = get_val(token);\\n        } else {\\n          ret = stoi(token);\\n        }\\n      } else {\\n        ++pos;\\n        token = get_token(expr, pos);\\n        if (token == \"let\") {\\n          while (true) {\\n            if (peek(expr, pos) == \\'(\\') {\\n              ret = eval(expr, pos);\\n              break;\\n            }\\n            string v = get_token(expr, pos);\\n            if (peek(expr, pos) == \\')\\') {\\n              ++pos;\\n              if (isalpha(v[0])) {\\n                ret = get_val(v);\\n              } else {\\n                ret = stoi(v);\\n              }\\n              break;\\n            }\\n            cts.back()[v] = eval(expr, pos);\\n          }\\n        } else if (token == \"add\") {\\n          int lhs = eval(expr, pos);\\n          int rhs = eval(expr, pos);\\n          ret = lhs + rhs;\\n        } else if (token == \"mult\") {\\n          int lhs = eval(expr, pos);\\n          int rhs = eval(expr, pos);\\n          ret = lhs * rhs;\\n        }\\n        if (peek(expr, pos) == \\')\\') { ++pos; }\\n      }\\n      cts.pop_back();\\n      return ret;\\n    }\\n    string get_token(const string& expr, int& pos) {\\n      string ret;\\n      while (expr[pos] == \\' \\') { ++pos; }\\n      while (expr[pos] != \\' \\') {\\n        if (expr[pos] == \\'(\\' || expr[pos] == \\')\\') {\\n          if (ret.empty()) {\\n            ret = expr[pos];\\n            ++pos;\\n          }\\n          break;\\n        } else {\\n          ret += expr[pos];\\n          ++pos;\\n        }\\n      }\\n      return ret;\\n    }\\n    char peek(const string& expr, int &pos) {\\n      while (expr[pos] == \\' \\') { ++pos; }\\n      return expr[pos];\\n    }\\n    int get_val(const string& vname) {\\n      for (auto it = cts.rbegin(); it != cts.rend(); ++it) {\\n        auto fit = it->find(vname);\\n        if (fit != it->end()) {\\n          return fit->second;\\n        }\\n      }\\n      return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2570187,
                "title": "c-faster-than-90",
                "content": "```\\nclass Context {\\n  unordered_map<string_view, int> _map;\\n  const Context *_parent{};\\n  public:\\n  Context(const Context *parent) : _parent{parent}\\n  {\\n    ;\\n  }\\n  const Context* Parent() const { return _parent; }\\n  int GetValue(const string_view &key) const\\n  {\\n    auto it = _map.find(key);\\n    if (it != _map.end()) return it->second;\\n    if (_parent) return _parent->GetValue(key);\\n    assert(0);\\n    return numeric_limits<int>::min();\\n  }\\n  void AddValue(const string_view &key, int val) {\\n    auto [it, isInserted] = _map.emplace(key, val);\\n    if (!isInserted) it->second = val;\\n  }\\n};\\nclass Solution {\\n  string_view symbol(string_view &expr) {\\n    string_view ret;\\n    if (expr.empty() || !isalpha(expr[0])) {\\n      return ret;\\n    }\\n    auto pos = expr.find_first_of(\" )\");\\n    assert(pos != string_view::npos);\\n    ret = expr.substr(0, pos);\\n    expr.remove_prefix(pos);\\n    return ret;\\n  }\\n  int evaluate(string_view &expr, Context *context) {\\n    assert(!expr.empty());\\n    if (expr[0] == \\'(\\') {\\n      assert(expr.length() >= 4);\\n      if (expr.substr(0, 4) == \"(add\") {\\n        assert(expr.length() > 4);\\n        expr.remove_prefix(4);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int l = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int r = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\')\\');\\n        expr.remove_prefix(1);\\n        return l + r;\\n      }\\n      if (expr.substr(0, 4) == \"(mul\") {\\n        assert(expr.length() > 5);\\n        expr.remove_prefix(5);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int l = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\' \\');\\n        expr.remove_prefix(1);\\n        int r = evaluate(expr, context);\\n        assert(!expr.empty() && expr[0] == \\')\\');\\n        expr.remove_prefix(1);\\n        return l * r;\\n      }\\n      if (expr.substr(0, 4) == \"(let\") {\\n        assert(expr.length() > 4);\\n        expr.remove_prefix(4);\\n        Context nc(context);\\n        while (1) {\\n          assert(!expr.empty() && expr[0] == \\' \\');\\n          expr.remove_prefix(1);\\n          string_view sym = symbol(expr);\\n          assert(!expr.empty());\\n          if (sym.empty() || expr[0] == \\')\\') {\\n            int ret{};\\n            if (sym.empty()) {\\n              ret = evaluate(expr, &nc);\\n            } else {\\n              ret = nc.GetValue(sym);\\n            }\\n            assert(!expr.empty() && expr[0] == \\')\\');\\n            expr.remove_prefix(1);\\n            return ret;\\n          }\\n          assert(!expr.empty() && expr[0] == \\' \\');\\n          expr.remove_prefix(1);\\n          int value = evaluate(expr, &nc);\\n          nc.AddValue(sym, value);\\n        }\\n        assert(0);\\n      }\\n    } \\n    if (isdigit(expr[0]) || expr[0] == \\'-\\') {\\n      auto pos = expr.find_first_not_of(\"-0123456789\");\\n      auto len = min(expr.length(), pos);\\n      int num;\\n      if (auto [ptr, ec] = from_chars(expr.data(), expr.data()+len, num); ec == errc()) {\\n        expr.remove_prefix(len);\\n      } else {\\n        assert(0);\\n      }\\n      return num;\\n    }\\n    if (isalpha(expr[0])) {\\n      string_view sym = symbol(expr);\\n      assert(!expr.empty() && (expr[0] == \\' \\' || expr[0] == \\')\\'));\\n      return context->GetValue(sym);\\n    }\\n    assert(0);\\n    return numeric_limits<int>::min();\\n  }\\npublic:\\n    int evaluate(string expression) {\\n      string_view expr(expression);\\n      Context context(nullptr);\\n      return evaluate(expr, &context);\\n    }\\n};",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "class Solution {\\n  string_view symbol(string_view &expr) {\\n    string_view ret;\\n    if (expr.empty() || !isalpha(expr[0])) {\\n      return ret;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2509874,
                "title": "c-a-handcrafted-parser-for-this-problem",
                "content": "There are many simpler and shorter ways to solve this problem.\\nDespites, It is a little bit cumbersome to write a parser, but being able to make a small own interpreter is fun and satisfied  : D\\n```\\n\\tusing System;\\n\\tusing System.Text.RegularExpressions;\\n\\tusing System.Linq;\\n    public class Token\\n    {\\n        public string TypeName { get; set; }\\n        public string Content { get; set; }\\n    }\\n\\n    public class Tokenizer\\n    {\\n        public IEnumerable<Token> GetTokens(string source)\\n        {\\n            Regex regex = new Regex(@\"(?<let>let)|(?<mult>mult)|(?<add>add)|(?<lp>\\\\()|(?<rp>\\\\))|(?<int>-?\\\\d+)|(?<var>[a-z]\\\\w*)\");\\n            List<Token> tmp = new List<Token>();\\n            foreach (Match m in regex.Matches(source))\\n            {\\n                for (int i = 1; i < m.Groups.Count; i++)\\n                {\\n                    if (m.Groups[i].Length > 0)\\n                    {\\n                        tmp.Add(new Token() { TypeName = m.Groups[i].Name, Content = m.Value });\\n                        break;\\n                    }\\n                }\\n            }\\n            return tmp;\\n        }\\n    }\\n\\n    public interface IExpression\\n    {\\n        public int Evaluate();\\n    }\\n\\n    public class VariableExpression : IExpression\\n    {\\n        string _name;\\n        int _value;\\n        public VariableExpression(string name, int value = 0)\\n        {\\n            _name = name;\\n            _value = value;\\n        }\\n\\n        public void SetValue(int value)\\n        {\\n            _value = value;\\n        }\\n\\n        public int Evaluate()\\n        {\\n            return _value;\\n        }\\n    }\\n\\n\\n    public class AddExpression : IExpression\\n    {\\n        IExpression _expr1;\\n        IExpression _expr2;\\n        public AddExpression(IExpression expr1, IExpression expr2)\\n        {\\n            _expr1 = expr1;\\n            _expr2 = expr2;\\n        }\\n        public int Evaluate()\\n        {\\n            return _expr1.Evaluate() + _expr2.Evaluate();\\n        }\\n    }\\n\\n    public class MulExpression : IExpression\\n    {\\n        IExpression _expr1;\\n        IExpression _expr2;\\n        public MulExpression(IExpression expr1, IExpression expr2)\\n        {\\n            _expr1 = expr1;\\n            _expr2 = expr2;\\n        }\\n        public int Evaluate()\\n        {\\n            return _expr1.Evaluate() * _expr2.Evaluate();\\n        }\\n    }\\n\\n    public class ConstNumberExpression : IExpression\\n    {\\n        int _value;\\n        public ConstNumberExpression(int value)\\n        {\\n            _value = value;\\n        }\\n        public int Evaluate()\\n        {\\n            return _value;\\n        }\\n    }\\n\\n    public class LetExpression : IExpression\\n    {\\n        IEnumerable<Tuple<VariableExpression, IExpression>> _subExpressions;\\n        IExpression _expr;\\n        public LetExpression(IEnumerable<Tuple<VariableExpression, IExpression>> subExpressions, IExpression expr)\\n        {\\n            _subExpressions = subExpressions;\\n            _expr = expr;\\n        }\\n        public int Evaluate()\\n        {\\n            foreach (Tuple<VariableExpression, IExpression> ve in _subExpressions)\\n            {\\n                VariableExpression v = ve.Item1 as VariableExpression;\\n                IExpression e = ve.Item2 as IExpression;\\n                v.SetValue(e.Evaluate());\\n            }\\n            return _expr.Evaluate();\\n        }\\n    }\\n\\n    public class TokenIndexer\\n    {\\n        Stack<int> _stack = new Stack<int>();\\n        int _position = 0;\\n        public int Position { get { return _position; } set { _position = value; } }\\n        List<Token> _tokens;\\n        string _currentTokenContent = null;\\n        public TokenIndexer(IEnumerable<Token> tokens)\\n        {\\n            _tokens = tokens.ToList();\\n        }\\n\\n        public void SavePosition()\\n        {\\n            _stack.Push(_position);\\n        }\\n\\n        public void RestorePosition()\\n        {\\n            _position = _stack.Pop();\\n        }\\n\\n        public string GetTokenContent\\n        {\\n            get { return _currentTokenContent; }\\n        }\\n\\n        public bool Check(string s)\\n        {\\n            bool result = false;\\n            _currentTokenContent = null;\\n            if (_tokens[_position].TypeName == s)\\n            {\\n                _currentTokenContent = _tokens[_position].Content;\\n                _position++;\\n                result = true;\\n            }\\n            return result;\\n        }\\n\\n    }\\n\\n    public class Parser\\n    {\\n        //# dont use left recursion Grammar\\n        //# Grammar:\\n        //# S -> LET | MUL | ADD\\n        //# LET -> ( let VE EXPR )\\n        //# VE -> declare EXPR VE | empty\\n        //# EXPR -> var | num | LET | MUL | ADD\\n        //# MUL -> ( mul EXPR EXPR )\\n        //# ADD -> ( add EXPR EXPR )\\n\\n        Stack<Dictionary<string, VariableExpression>> _symbolTables = new Stack<Dictionary<string, VariableExpression>>();\\n\\n        public IExpression Parse(string source)\\n        {\\n            Tokenizer tokenizer = new Tokenizer();\\n            var tokens = tokenizer.GetTokens(source);\\n            TokenIndexer tokenIndexer = new TokenIndexer(tokens);\\n            IExpression statements;\\n            bool result = START(tokenIndexer, out statements);\\n            return statements;\\n        }\\n        public bool START(TokenIndexer indexer, out IExpression statements)\\n        {\\n            statements = null;\\n            _symbolTables.Push(new Dictionary<string, VariableExpression>());\\n            indexer.SavePosition();\\n            if (LET(indexer, out statements))\\n            {\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n\\n            indexer.SavePosition();\\n            if (ADD(indexer, out statements))\\n            {\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n\\n            indexer.SavePosition();\\n            if (MULT(indexer, out statements))\\n            {\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n\\n            return false;\\n        }\\n\\n        public bool NUM(TokenIndexer indexer, out IExpression constNumberExpression)\\n        {\\n            bool result = indexer.Check(\"int\");\\n            constNumberExpression = null;\\n            if (true == result)\\n            {\\n                constNumberExpression = new ConstNumberExpression(int.Parse(indexer.GetTokenContent));\\n            }\\n            return result;\\n        }\\n\\n        public bool DECLARE(TokenIndexer indexer, out VariableExpression variableExpression)\\n        {\\n            bool result = indexer.Check(\"var\");\\n            variableExpression = null;\\n            if (true == result)\\n            {\\n                string varName = indexer.GetTokenContent;\\n                if (_symbolTables.Peek().ContainsKey(varName))\\n                {\\n                    variableExpression = (_symbolTables.Peek())[varName];\\n                }\\n                else\\n                {\\n                    variableExpression = new VariableExpression(indexer.GetTokenContent);\\n                    _symbolTables.Peek().Add(varName, variableExpression);\\n                }\\n            }\\n            return result;\\n        }\\n\\n        public bool VAR(TokenIndexer indexer, out VariableExpression variableExpression)\\n        {\\n            bool result = indexer.Check(\"var\");\\n            variableExpression = null;\\n            if (true == result)\\n            {\\n                string varName = indexer.GetTokenContent;\\n                foreach (var st in _symbolTables)\\n                {\\n                    if (st.ContainsKey(varName))\\n                    {\\n                        variableExpression = st[varName];\\n                        break;\\n                    }\\n                }\\n                //if (null == variableExpression)\\n                //{\\n                //    variableExpression = new VariableExpression(indexer.GetTokenContent);\\n                //    _symbolTables.Peek().Add(varName, variableExpression);\\n                //}\\n\\n            }\\n            return result;\\n        }\\n\\n        public bool EXPR(TokenIndexer indexer, out IExpression expr)\\n        {\\n            indexer.SavePosition();\\n            if (NUM(indexer, out expr))\\n            {\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n            VariableExpression variableExpression;\\n            indexer.SavePosition();\\n            if (VAR(indexer, out variableExpression))\\n            {\\n                expr = variableExpression;\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n\\n            indexer.SavePosition();\\n            if (LET(indexer, out expr))\\n            {\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n\\n            indexer.SavePosition();\\n            if (MULT(indexer, out expr))\\n            {\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n\\n            indexer.SavePosition();\\n            if (ADD(indexer, out expr))\\n            {\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n\\n            return false;\\n        }\\n\\n        public bool LET(TokenIndexer indexer, out IExpression letExpression)\\n        {\\n            letExpression = null;\\n            IExpression expr1;\\n            IEnumerable<Tuple<VariableExpression, IExpression>> veList;\\n            indexer.SavePosition();\\n            _symbolTables.Push(new Dictionary<string, VariableExpression>());\\n            if (indexer.Check(\"lp\") && indexer.Check(\"let\") && VE(indexer, out veList) && EXPR(indexer, out expr1) && indexer.Check(\"rp\"))\\n            {\\n\\n                letExpression = new LetExpression(veList, expr1);\\n                _symbolTables.Pop();\\n                return true;\\n            }\\n            _symbolTables.Pop();\\n            indexer.RestorePosition();\\n            return false;\\n        }\\n\\n        public bool VE(TokenIndexer indexer, out IEnumerable<Tuple<VariableExpression, IExpression>> veList)\\n        {\\n            veList = null;\\n            IEnumerable<Tuple<VariableExpression, IExpression>> veLatterPart;\\n            VariableExpression variableExpression;\\n            IExpression expr;\\n            indexer.SavePosition();\\n            if (DECLARE(indexer, out variableExpression) && EXPR(indexer, out expr) && VE(indexer, out veLatterPart))\\n            {\\n                List<Tuple<VariableExpression, IExpression>> tmp = new List<Tuple<VariableExpression, IExpression>>() {\\n                Tuple.Create(variableExpression, expr)};\\n                if (null != veLatterPart)\\n                {\\n                    tmp.AddRange(veLatterPart);\\n                }\\n                veList = tmp;\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n            return true;\\n        }\\n\\n        public bool ADD(TokenIndexer indexer, out IExpression addExpression)\\n        {\\n            addExpression = null;\\n            IExpression expr1;\\n            IExpression expr2;\\n            indexer.SavePosition();\\n            if (indexer.Check(\"lp\") && indexer.Check(\"add\") && EXPR(indexer, out expr1) && EXPR(indexer, out expr2) && indexer.Check(\"rp\"))\\n            {\\n                addExpression = new AddExpression(expr1, expr2);\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n            return false;\\n        }\\n\\n        public bool MULT(TokenIndexer indexer, out IExpression multExpression)\\n        {\\n            multExpression = null;\\n            IExpression expr1;\\n            IExpression expr2;\\n            indexer.SavePosition();\\n            if (indexer.Check(\"lp\") && indexer.Check(\"mult\") && EXPR(indexer, out expr1) && EXPR(indexer, out expr2) && indexer.Check(\"rp\"))\\n            {\\n                multExpression = new MulExpression(expr1, expr2);\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n            return false;\\n        }\\n\\n    }\\n\\n\\tpublic class Solution {\\n\\t\\tpublic int Evaluate(string expression) {\\n\\t\\t\\tParser parser = new Parser();\\n\\t\\t\\tvar prog=parser.Parse(expression);\\n\\t\\t\\treturn prog.Evaluate();\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n\\tusing System;\\n\\tusing System.Text.RegularExpressions;\\n\\tusing System.Linq;\\n    public class Token\\n    {\\n        public string TypeName { get; set; }\\n        public string Content { get; set; }\\n    }\\n\\n    public class Tokenizer\\n    {\\n        public IEnumerable<Token> GetTokens(string source)\\n        {\\n            Regex regex = new Regex(@\"(?<let>let)|(?<mult>mult)|(?<add>add)|(?<lp>\\\\()|(?<rp>\\\\))|(?<int>-?\\\\d+)|(?<var>[a-z]\\\\w*)\");\\n            List<Token> tmp = new List<Token>();\\n            foreach (Match m in regex.Matches(source))\\n            {\\n                for (int i = 1; i < m.Groups.Count; i++)\\n                {\\n                    if (m.Groups[i].Length > 0)\\n                    {\\n                        tmp.Add(new Token() { TypeName = m.Groups[i].Name, Content = m.Value });\\n                        break;\\n                    }\\n                }\\n            }\\n            return tmp;\\n        }\\n    }\\n\\n    public interface IExpression\\n    {\\n        public int Evaluate();\\n    }\\n\\n    public class VariableExpression : IExpression\\n    {\\n        string _name;\\n        int _value;\\n        public VariableExpression(string name, int value = 0)\\n        {\\n            _name = name;\\n            _value = value;\\n        }\\n\\n        public void SetValue(int value)\\n        {\\n            _value = value;\\n        }\\n\\n        public int Evaluate()\\n        {\\n            return _value;\\n        }\\n    }\\n\\n\\n    public class AddExpression : IExpression\\n    {\\n        IExpression _expr1;\\n        IExpression _expr2;\\n        public AddExpression(IExpression expr1, IExpression expr2)\\n        {\\n            _expr1 = expr1;\\n            _expr2 = expr2;\\n        }\\n        public int Evaluate()\\n        {\\n            return _expr1.Evaluate() + _expr2.Evaluate();\\n        }\\n    }\\n\\n    public class MulExpression : IExpression\\n    {\\n        IExpression _expr1;\\n        IExpression _expr2;\\n        public MulExpression(IExpression expr1, IExpression expr2)\\n        {\\n            _expr1 = expr1;\\n            _expr2 = expr2;\\n        }\\n        public int Evaluate()\\n        {\\n            return _expr1.Evaluate() * _expr2.Evaluate();\\n        }\\n    }\\n\\n    public class ConstNumberExpression : IExpression\\n    {\\n        int _value;\\n        public ConstNumberExpression(int value)\\n        {\\n            _value = value;\\n        }\\n        public int Evaluate()\\n        {\\n            return _value;\\n        }\\n    }\\n\\n    public class LetExpression : IExpression\\n    {\\n        IEnumerable<Tuple<VariableExpression, IExpression>> _subExpressions;\\n        IExpression _expr;\\n        public LetExpression(IEnumerable<Tuple<VariableExpression, IExpression>> subExpressions, IExpression expr)\\n        {\\n            _subExpressions = subExpressions;\\n            _expr = expr;\\n        }\\n        public int Evaluate()\\n        {\\n            foreach (Tuple<VariableExpression, IExpression> ve in _subExpressions)\\n            {\\n                VariableExpression v = ve.Item1 as VariableExpression;\\n                IExpression e = ve.Item2 as IExpression;\\n                v.SetValue(e.Evaluate());\\n            }\\n            return _expr.Evaluate();\\n        }\\n    }\\n\\n    public class TokenIndexer\\n    {\\n        Stack<int> _stack = new Stack<int>();\\n        int _position = 0;\\n        public int Position { get { return _position; } set { _position = value; } }\\n        List<Token> _tokens;\\n        string _currentTokenContent = null;\\n        public TokenIndexer(IEnumerable<Token> tokens)\\n        {\\n            _tokens = tokens.ToList();\\n        }\\n\\n        public void SavePosition()\\n        {\\n            _stack.Push(_position);\\n        }\\n\\n        public void RestorePosition()\\n        {\\n            _position = _stack.Pop();\\n        }\\n\\n        public string GetTokenContent\\n        {\\n            get { return _currentTokenContent; }\\n        }\\n\\n        public bool Check(string s)\\n        {\\n            bool result = false;\\n            _currentTokenContent = null;\\n            if (_tokens[_position].TypeName == s)\\n            {\\n                _currentTokenContent = _tokens[_position].Content;\\n                _position++;\\n                result = true;\\n            }\\n            return result;\\n        }\\n\\n    }\\n\\n    public class Parser\\n    {\\n        //# dont use left recursion Grammar\\n        //# Grammar:\\n        //# S -> LET | MUL | ADD\\n        //# LET -> ( let VE EXPR )\\n        //# VE -> declare EXPR VE | empty\\n        //# EXPR -> var | num | LET | MUL | ADD\\n        //# MUL -> ( mul EXPR EXPR )\\n        //# ADD -> ( add EXPR EXPR )\\n\\n        Stack<Dictionary<string, VariableExpression>> _symbolTables = new Stack<Dictionary<string, VariableExpression>>();\\n\\n        public IExpression Parse(string source)\\n        {\\n            Tokenizer tokenizer = new Tokenizer();\\n            var tokens = tokenizer.GetTokens(source);\\n            TokenIndexer tokenIndexer = new TokenIndexer(tokens);\\n            IExpression statements;\\n            bool result = START(tokenIndexer, out statements);\\n            return statements;\\n        }\\n        public bool START(TokenIndexer indexer, out IExpression statements)\\n        {\\n            statements = null;\\n            _symbolTables.Push(new Dictionary<string, VariableExpression>());\\n            indexer.SavePosition();\\n            if (LET(indexer, out statements))\\n            {\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n\\n            indexer.SavePosition();\\n            if (ADD(indexer, out statements))\\n            {\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n\\n            indexer.SavePosition();\\n            if (MULT(indexer, out statements))\\n            {\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n\\n            return false;\\n        }\\n\\n        public bool NUM(TokenIndexer indexer, out IExpression constNumberExpression)\\n        {\\n            bool result = indexer.Check(\"int\");\\n            constNumberExpression = null;\\n            if (true == result)\\n            {\\n                constNumberExpression = new ConstNumberExpression(int.Parse(indexer.GetTokenContent));\\n            }\\n            return result;\\n        }\\n\\n        public bool DECLARE(TokenIndexer indexer, out VariableExpression variableExpression)\\n        {\\n            bool result = indexer.Check(\"var\");\\n            variableExpression = null;\\n            if (true == result)\\n            {\\n                string varName = indexer.GetTokenContent;\\n                if (_symbolTables.Peek().ContainsKey(varName))\\n                {\\n                    variableExpression = (_symbolTables.Peek())[varName];\\n                }\\n                else\\n                {\\n                    variableExpression = new VariableExpression(indexer.GetTokenContent);\\n                    _symbolTables.Peek().Add(varName, variableExpression);\\n                }\\n            }\\n            return result;\\n        }\\n\\n        public bool VAR(TokenIndexer indexer, out VariableExpression variableExpression)\\n        {\\n            bool result = indexer.Check(\"var\");\\n            variableExpression = null;\\n            if (true == result)\\n            {\\n                string varName = indexer.GetTokenContent;\\n                foreach (var st in _symbolTables)\\n                {\\n                    if (st.ContainsKey(varName))\\n                    {\\n                        variableExpression = st[varName];\\n                        break;\\n                    }\\n                }\\n                //if (null == variableExpression)\\n                //{\\n                //    variableExpression = new VariableExpression(indexer.GetTokenContent);\\n                //    _symbolTables.Peek().Add(varName, variableExpression);\\n                //}\\n\\n            }\\n            return result;\\n        }\\n\\n        public bool EXPR(TokenIndexer indexer, out IExpression expr)\\n        {\\n            indexer.SavePosition();\\n            if (NUM(indexer, out expr))\\n            {\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n            VariableExpression variableExpression;\\n            indexer.SavePosition();\\n            if (VAR(indexer, out variableExpression))\\n            {\\n                expr = variableExpression;\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n\\n            indexer.SavePosition();\\n            if (LET(indexer, out expr))\\n            {\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n\\n            indexer.SavePosition();\\n            if (MULT(indexer, out expr))\\n            {\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n\\n            indexer.SavePosition();\\n            if (ADD(indexer, out expr))\\n            {\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n\\n            return false;\\n        }\\n\\n        public bool LET(TokenIndexer indexer, out IExpression letExpression)\\n        {\\n            letExpression = null;\\n            IExpression expr1;\\n            IEnumerable<Tuple<VariableExpression, IExpression>> veList;\\n            indexer.SavePosition();\\n            _symbolTables.Push(new Dictionary<string, VariableExpression>());\\n            if (indexer.Check(\"lp\") && indexer.Check(\"let\") && VE(indexer, out veList) && EXPR(indexer, out expr1) && indexer.Check(\"rp\"))\\n            {\\n\\n                letExpression = new LetExpression(veList, expr1);\\n                _symbolTables.Pop();\\n                return true;\\n            }\\n            _symbolTables.Pop();\\n            indexer.RestorePosition();\\n            return false;\\n        }\\n\\n        public bool VE(TokenIndexer indexer, out IEnumerable<Tuple<VariableExpression, IExpression>> veList)\\n        {\\n            veList = null;\\n            IEnumerable<Tuple<VariableExpression, IExpression>> veLatterPart;\\n            VariableExpression variableExpression;\\n            IExpression expr;\\n            indexer.SavePosition();\\n            if (DECLARE(indexer, out variableExpression) && EXPR(indexer, out expr) && VE(indexer, out veLatterPart))\\n            {\\n                List<Tuple<VariableExpression, IExpression>> tmp = new List<Tuple<VariableExpression, IExpression>>() {\\n                Tuple.Create(variableExpression, expr)};\\n                if (null != veLatterPart)\\n                {\\n                    tmp.AddRange(veLatterPart);\\n                }\\n                veList = tmp;\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n            return true;\\n        }\\n\\n        public bool ADD(TokenIndexer indexer, out IExpression addExpression)\\n        {\\n            addExpression = null;\\n            IExpression expr1;\\n            IExpression expr2;\\n            indexer.SavePosition();\\n            if (indexer.Check(\"lp\") && indexer.Check(\"add\") && EXPR(indexer, out expr1) && EXPR(indexer, out expr2) && indexer.Check(\"rp\"))\\n            {\\n                addExpression = new AddExpression(expr1, expr2);\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n            return false;\\n        }\\n\\n        public bool MULT(TokenIndexer indexer, out IExpression multExpression)\\n        {\\n            multExpression = null;\\n            IExpression expr1;\\n            IExpression expr2;\\n            indexer.SavePosition();\\n            if (indexer.Check(\"lp\") && indexer.Check(\"mult\") && EXPR(indexer, out expr1) && EXPR(indexer, out expr2) && indexer.Check(\"rp\"))\\n            {\\n                multExpression = new MulExpression(expr1, expr2);\\n                return true;\\n            }\\n            indexer.RestorePosition();\\n            return false;\\n        }\\n\\n    }\\n\\n\\tpublic class Solution {\\n\\t\\tpublic int Evaluate(string expression) {\\n\\t\\t\\tParser parser = new Parser();\\n\\t\\t\\tvar prog=parser.Parse(expression);\\n\\t\\t\\treturn prog.Evaluate();\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467707,
                "title": "python-solution",
                "content": "Have a look at this-\\n\\n```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        return int(self.eval(expression))        \\n        \\n    def split(self, exp):\\n        comps= [\"\"]\\n        bracks_count= 0\\n        for c in exp:\\n            if c==\" \" and bracks_count==0:\\n                comps.append(\"\")\\n                continue\\n            if c==\"(\":\\n                bracks_count+=1\\n            elif c==\")\":\\n                bracks_count-=1\\n            comps[-1]+=c\\n\\n        while len(comps)>1 and comps[-1]==\"\":\\n            comps= comps[:-1]\\n        return comps\\n\\n\\n\\n    def eval(self, exp, var_dict= {}):\\n\\n        exp= exp.lstrip(\" \").rstrip(\" \")\\n        while len(exp)>2 and exp[0]==\\'(\\' and exp[-1]==\")\":\\n            exp= exp[1:-1]\\n            exp= exp.lstrip(\" \").rstrip(\" \")\\n\\n        try:\\n            return float(exp)\\n        except:\\n            pass\\n\\n        try:\\n            return var_dict[exp]\\n        except:\\n            pass\\n\\n        comps= self.split(exp)\\n\\n\\n        if comps[0].lower()==\"let\":\\n            exp_to_eval= comps[-1]\\n            lets_to_eval= comps[1:-1]\\n            if len(lets_to_eval)%2!=0:\\n                raise Exception(\"!!! No of let assignments are bad... \"+ exp)\\n            for pair_id in range(0, len(lets_to_eval), 2):\\n                var_name, var_val= lets_to_eval[pair_id], lets_to_eval[pair_id+1]\\n                var_val= self.eval(var_val, var_dict= var_dict.copy())\\n                var_dict.update({var_name: var_val})\\n            return self.eval(exp_to_eval, var_dict=var_dict.copy())\\n\\n        elif comps[0].lower()==\"add\":\\n            if len(comps)!=3:\\n                raise Exception(\"!!! Too many values for mult... \", exp)\\n            v1= self.eval(comps[1], var_dict= var_dict.copy())\\n            v2= self.eval(comps[2], var_dict=var_dict.copy())\\n            return v1+v2\\n\\n        elif comps[0].lower()==\"mult\":\\n            if len(comps)!=3:\\n                raise Exception(\"!!! Too many values for mult... \", exp)\\n            v1= self.eval(comps[1], var_dict= var_dict.copy())\\n            v2= self.eval(comps[2], var_dict=var_dict.copy())\\n            return v1*v2\\n\\n        else:\\n            print(var_dict)\\n            raise Exception(exp)\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        return int(self.eval(expression))        \\n        \\n    def split(self, exp):\\n        comps= [\"\"]\\n        bracks_count= 0\\n        for c in exp:\\n            if c==\" \" and bracks_count==0:\\n                comps.append(\"\")\\n                continue\\n            if c==\"(\":\\n                bracks_count+=1\\n            elif c==\")\":\\n                bracks_count-=1\\n            comps[-1]+=c\\n\\n        while len(comps)>1 and comps[-1]==\"\":\\n            comps= comps[:-1]\\n        return comps\\n\\n\\n\\n    def eval(self, exp, var_dict= {}):\\n\\n        exp= exp.lstrip(\" \").rstrip(\" \")\\n        while len(exp)>2 and exp[0]==\\'(\\' and exp[-1]==\")\":\\n            exp= exp[1:-1]\\n            exp= exp.lstrip(\" \").rstrip(\" \")\\n\\n        try:\\n            return float(exp)\\n        except:\\n            pass\\n\\n        try:\\n            return var_dict[exp]\\n        except:\\n            pass\\n\\n        comps= self.split(exp)\\n\\n\\n        if comps[0].lower()==\"let\":\\n            exp_to_eval= comps[-1]\\n            lets_to_eval= comps[1:-1]\\n            if len(lets_to_eval)%2!=0:\\n                raise Exception(\"!!! No of let assignments are bad... \"+ exp)\\n            for pair_id in range(0, len(lets_to_eval), 2):\\n                var_name, var_val= lets_to_eval[pair_id], lets_to_eval[pair_id+1]\\n                var_val= self.eval(var_val, var_dict= var_dict.copy())\\n                var_dict.update({var_name: var_val})\\n            return self.eval(exp_to_eval, var_dict=var_dict.copy())\\n\\n        elif comps[0].lower()==\"add\":\\n            if len(comps)!=3:\\n                raise Exception(\"!!! Too many values for mult... \", exp)\\n            v1= self.eval(comps[1], var_dict= var_dict.copy())\\n            v2= self.eval(comps[2], var_dict=var_dict.copy())\\n            return v1+v2\\n\\n        elif comps[0].lower()==\"mult\":\\n            if len(comps)!=3:\\n                raise Exception(\"!!! Too many values for mult... \", exp)\\n            v1= self.eval(comps[1], var_dict= var_dict.copy())\\n            v2= self.eval(comps[2], var_dict=var_dict.copy())\\n            return v1*v2\\n\\n        else:\\n            print(var_dict)\\n            raise Exception(exp)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2401431,
                "title": "java-o-n-clean-solution-iterative",
                "content": "#### Foreword\\nStupid Problem. If I encounter this problem in a functional language like Typed Racket, I\\'d use recursion to solve it and it honestly wouldn\\'t be that bad. But here I am, using Java, and made up my mind that I\\'d do it **interatively**. I also decided that I will **not** stupidly copy the whole scope over when we enter a new `()`. I\\'d like to solve this effeciently. Thus, my suffering begins.\\n\\n#### This is the main function.\\nThis main function contains the logic of the code. Some 1-2 liners helper functions were extracted to make it more readable.\\nFirst we transform the stupid string into something reasonable.\\nFor example, `\"(let x 2 (mult x (let x 3 y 4 (add x y))))\"` becomes the following:\\n```\\n[let, x, 2, mult, x, let, x, 3, y, 4, add, x, y), ), ), )]\\n```\\nThe open `(` is redundant, so I removed them, we can tell the when it ends by `)`. \\n**Notice that I group `y)` together** in the example above - that way we can tell when `let` ends and that will have the return values.\\n\\n`Time O(N)`\\n`Space O(N)`\\n\\n```Java\\n    public int evaluate(String expression) {\\n        String[] A = expression.replaceAll(\"\\\\\\\\)\", \"\\\\\\\\) \").replaceAll(\"\\\\\\\\(\", \"\").replaceAll(\"\\\\\\\\s+\", \" \").split(\" \");\\n        op.push(\"\");\\n        for (String a : A){\\n            if (a.equals(LET) || a.equals(MULT) || a.equals(ADD)){\\n                op.push(a);\\n                wait.push(\"\");\\n            }else if (a.contains(\")\")){\\n                a = a.substring(0, a.length()-1);\\n                int val = a.isEmpty()? stack.pop() : isVariable(a)? env.get(a).peek() : Integer.parseInt(a);\\n                switch(op.peek()){\\n                    case LET -> {stack.push(val); cleanScope();}\\n                    case ADD -> {stack.push(stack.pop() + val);}\\n                    default  -> {stack.push(stack.pop() * val);}\\n                };\\n                op.pop();\\n                wait.pop();\\n                if (op.peek().equals(LET) && !wait.peek().isEmpty()){\\n                    addToEnv(stack.pop());\\n                }\\n            }else if (isVariable(a)){\\n                switch(op.peek()){\\n                    case LET -> {if (!wait.peek().isEmpty()) addToEnv(env.get(a).peek()); else extendScope(a);}\\n                    default  -> stack.push(env.get(a).peek());\\n                };\\n            }else if (isNum(a)){\\n                int val = Integer.parseInt(a);\\n                switch(op.peek()){\\n                    case LET -> addToEnv(val);\\n                    default  -> stack.push(val);\\n                };\\n            }\\n        }\\n        return stack.pop();\\n    }\\n```\\n\\n#### These are the helper functions for readability\\'s sake.\\nWe can totally include it all to make the whole program 10+ lines shorter but I think it is better for them to be separated out.\\nI totally did not expect to see a negative number in the test case, but there are some negative numbers, so we must check `\\'-\\'` as well.\\n```Java\\n    private void cleanScope(){\\n        for (String variable : scope.remove(op.size())){\\n            env.get(variable).pop();\\n        }\\n    }\\n\\n    private void extendScope(String a){\\n        scope.computeIfAbsent(op.size(), o -> new ArrayList<>()).add(a);\\n        wait.push(a);\\n    }\\n\\n    private void addToEnv(int val){\\n        env.computeIfAbsent(wait.pop(), o -> new ArrayDeque<>()).push(val);\\n    }\\n\\n    private boolean isNum(String a){\\n        return a.charAt(0) == \\'-\\' || a.chars().allMatch(Character::isDigit);\\n    }\\n\\n    private boolean isVariable(String a){\\n        return a.chars().anyMatch(Character::isLetter);\\n    }\\n```\\n#### Here are all the variables used.\\nI put them all in top levels for the helper functions above.\\nI don\\'t want to put them into the function parameters. It\\'d be too long.\\n\\n```Java\\n    Map<String, Deque<Integer>> env = new HashMap<>();\\n    Map<Integer, List<String>> scope = new HashMap<>();\\n    Deque<String> op = new ArrayDeque<>();\\n    Deque<Integer> stack = new ArrayDeque<>();\\n    Deque<String> wait = new ArrayDeque<>();\\n    final String MULT = \"mult\", LET = \"let\", ADD = \"add\";\\n```\\n\\n#### Why is it slow? \\nNow you may be wondering why it scores bottom 10% in terms of run time. \\n1. Weak Test cases and low constraint\\n2. In my code, I performed a lot of `replaceAll()` operations at the very beginning which can be slow, but it is `O(N)`.",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n[let, x, 2, mult, x, let, x, 3, y, 4, add, x, y), ), ), )]\\n```\n```Java\\n    public int evaluate(String expression) {\\n        String[] A = expression.replaceAll(\"\\\\\\\\)\", \"\\\\\\\\) \").replaceAll(\"\\\\\\\\(\", \"\").replaceAll(\"\\\\\\\\s+\", \" \").split(\" \");\\n        op.push(\"\");\\n        for (String a : A){\\n            if (a.equals(LET) || a.equals(MULT) || a.equals(ADD)){\\n                op.push(a);\\n                wait.push(\"\");\\n            }else if (a.contains(\")\")){\\n                a = a.substring(0, a.length()-1);\\n                int val = a.isEmpty()? stack.pop() : isVariable(a)? env.get(a).peek() : Integer.parseInt(a);\\n                switch(op.peek()){\\n                    case LET -> {stack.push(val); cleanScope();}\\n                    case ADD -> {stack.push(stack.pop() + val);}\\n                    default  -> {stack.push(stack.pop() * val);}\\n                };\\n                op.pop();\\n                wait.pop();\\n                if (op.peek().equals(LET) && !wait.peek().isEmpty()){\\n                    addToEnv(stack.pop());\\n                }\\n            }else if (isVariable(a)){\\n                switch(op.peek()){\\n                    case LET -> {if (!wait.peek().isEmpty()) addToEnv(env.get(a).peek()); else extendScope(a);}\\n                    default  -> stack.push(env.get(a).peek());\\n                };\\n            }else if (isNum(a)){\\n                int val = Integer.parseInt(a);\\n                switch(op.peek()){\\n                    case LET -> addToEnv(val);\\n                    default  -> stack.push(val);\\n                };\\n            }\\n        }\\n        return stack.pop();\\n    }\\n```\n```Java\\n    private void cleanScope(){\\n        for (String variable : scope.remove(op.size())){\\n            env.get(variable).pop();\\n        }\\n    }\\n\\n    private void extendScope(String a){\\n        scope.computeIfAbsent(op.size(), o -> new ArrayList<>()).add(a);\\n        wait.push(a);\\n    }\\n\\n    private void addToEnv(int val){\\n        env.computeIfAbsent(wait.pop(), o -> new ArrayDeque<>()).push(val);\\n    }\\n\\n    private boolean isNum(String a){\\n        return a.charAt(0) == \\'-\\' || a.chars().allMatch(Character::isDigit);\\n    }\\n\\n    private boolean isVariable(String a){\\n        return a.chars().anyMatch(Character::isLetter);\\n    }\\n```\n```Java\\n    Map<String, Deque<Integer>> env = new HashMap<>();\\n    Map<Integer, List<String>> scope = new HashMap<>();\\n    Deque<String> op = new ArrayDeque<>();\\n    Deque<Integer> stack = new ArrayDeque<>();\\n    Deque<String> wait = new ArrayDeque<>();\\n    final String MULT = \"mult\", LET = \"let\", ADD = \"add\";\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2247305,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {string} expression\\n * @return {number}\\n */\\nvar evaluate = function(expression) {\\n    return helper(expression);  \\n};\\n\\nconst helper = (expr, map = {}) => {\\n    if (expr[0] !== \\'(\\')\\n        return /[0-9]|-/.test(expr[0]) ? +expr : map[expr];\\n    \\n    map = Object.assign({}, map);\\n    const start = expr[1] === \\'m\\' ? 6 : 5;\\n    const tokens = parse(expr.slice(start, expr.length - 1));\\n    \\n    if (expr.startsWith(\\'(m\\')) return helper(tokens[0], map) * helper(tokens[1], map);\\n    if (expr.startsWith(\\'(a\\')) return helper(tokens[0], map) + helper(tokens[1], map);\\n    \\n    for (let i = 0; i < tokens.length - 2; i += 2)\\n        map[tokens[i]] = helper(tokens[i + 1], map);\\n    \\n    return helper(tokens.at(-1), map);\\n}\\n\\nconst parse = expr => {\\n    const tokens = [];\\n    let [builder, par] = [\\'\\', 0];\\n    \\n    for (let ch of expr) {\\n        if (ch === \\'(\\') par++;\\n        if (ch === \\')\\') par--;\\n        if (!par && ch === \\' \\') {\\n            tokens.push(builder);\\n            builder = \\'\\';\\n        }\\n        else builder += ch;\\n    }\\n    \\n    return builder ? [...tokens, builder] : tokens;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} expression\\n * @return {number}\\n */\\nvar evaluate = function(expression) {\\n    return helper(expression);  \\n};\\n\\nconst helper = (expr, map = {}) => {\\n    if (expr[0] !== \\'(\\')\\n        return /[0-9]|-/.test(expr[0]) ? +expr : map[expr];\\n    \\n    map = Object.assign({}, map);\\n    const start = expr[1] === \\'m\\' ? 6 : 5;\\n    const tokens = parse(expr.slice(start, expr.length - 1));\\n    \\n    if (expr.startsWith(\\'(m\\')) return helper(tokens[0], map) * helper(tokens[1], map);\\n    if (expr.startsWith(\\'(a\\')) return helper(tokens[0], map) + helper(tokens[1], map);\\n    \\n    for (let i = 0; i < tokens.length - 2; i += 2)\\n        map[tokens[i]] = helper(tokens[i + 1], map);\\n    \\n    return helper(tokens.at(-1), map);\\n}\\n\\nconst parse = expr => {\\n    const tokens = [];\\n    let [builder, par] = [\\'\\', 0];\\n    \\n    for (let ch of expr) {\\n        if (ch === \\'(\\') par++;\\n        if (ch === \\')\\') par--;\\n        if (!par && ch === \\' \\') {\\n            tokens.push(builder);\\n            builder = \\'\\';\\n        }\\n        else builder += ch;\\n    }\\n    \\n    return builder ? [...tokens, builder] : tokens;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2247124,
                "title": "java-stack-commented",
                "content": "\\nRead from left to right. If we read a \\'(\\' , it is a expression, other wise it is an integer or a variable. If it is a expression, it is a let, add or multi expression, try to read next variable or integer and calculate the expression.\\n\\nFor each variable, we use a stack to record the value. A variable may be assigned many times and the peek value of stack is current value. If we have finished a expression, we should pop all the values we assigned in this scope.\\n\\n```\\nclass Solution {\\n    \\n    String expression;\\n    int index;\\n    HashMap<String,Deque<Integer>> scope; \\n    //variable may be assigned many times, we use the peek value \\n    \\n    public int evaluate(String expression) {\\n        this.expression=expression;\\n        index=0;\\n        scope=new HashMap<>();\\n        return evaluate();\\n    }\\n    \\n    private int evaluate(){\\n        \\n        if(expression.charAt(index)==\\'(\\'){\\n            //this is an expression\\n            index++; //skip \\'(\\'\\n            char begin=expression.charAt(index);\\n            int ret;\\n            if(begin==\\'l\\'){\\n                //let\\n                index += 4; //skip let and a blank space\\n                ArrayList<String> vars=new ArrayList<>();\\n                while(true){\\n                    if(!Character.isLowerCase(expression.charAt(index))){\\n                        ret=evaluate();\\n                        break;\\n                    }\\n                    String var=parseVar();\\n                    if(expression.charAt(index)==\\')\\'){\\n                        ret=scope.get(var).peek();\\n                        break;\\n                    }\\n                    vars.add(var);\\n                    index++;\\n                    int e=evaluate();\\n                    scope.putIfAbsent(var, new LinkedList<>());\\n                    scope.get(var).push(e); //assign a new value\\n                    index++;\\n                }\\n                for (String var : vars) {\\n                    scope.get(var).pop(); // remove all values of this scope\\n                }\\n\\n            } else if(begin==\\'a\\') {\\n                //add\\n                index += 4;\\n                int v1 = evaluate();\\n                index++;\\n                int v2 = evaluate();\\n                ret = v1+v2;\\n            } else {\\n                //multi\\n                index += 5;\\n                int v1 = evaluate();\\n                index++;\\n                int v2 = evaluate();\\n                ret =  v1*v2;\\n            }\\n            index++; // skip \\')\\'\\n            return ret;\\n        } else {\\n            //this is not a expression, this is an integer or a variable\\n            if(Character.isLowerCase(expression.charAt(index))){\\n\\t\\t\\t\\t//this is a variable, the current value is peek value\\n                String var=parseVar();\\n                return scope.get(var).peek();\\n            } else {\\n\\t\\t\\t\\t//this is an integer\\n                return parseInt();\\n            }\\n        }\\n    }\\n    \\n    //read an integer\\n    private int parseInt(){\\n        boolean negative=false;\\n        if(expression.charAt(index)==\\'-\\'){\\n            negative=true;\\n            index++;\\n        }\\n        int ret=0;\\n        while(Character.isDigit(expression.charAt(index))){\\n            ret*=10;\\n            ret+=expression.charAt(index)-\\'0\\';\\n            index++;\\n        }\\n        if(negative) return -ret;\\n        return ret;\\n    }\\n    \\n    //read a variable\\n    private String parseVar(){\\n        StringBuilder sb=new StringBuilder();\\n        char c=expression.charAt(index);\\n        while(c!=\\' \\' && c!=\\')\\'){\\n            sb.append(c);\\n            c=expression.charAt(++index);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    \\n    String expression;\\n    int index;\\n    HashMap<String,Deque<Integer>> scope; \\n    //variable may be assigned many times, we use the peek value \\n    \\n    public int evaluate(String expression) {\\n        this.expression=expression;\\n        index=0;\\n        scope=new HashMap<>();\\n        return evaluate();\\n    }\\n    \\n    private int evaluate(){\\n        \\n        if(expression.charAt(index)==\\'(\\'){\\n            //this is an expression\\n            index++; //skip \\'(\\'\\n            char begin=expression.charAt(index);\\n            int ret;\\n            if(begin==\\'l\\'){\\n                //let\\n                index += 4; //skip let and a blank space\\n                ArrayList<String> vars=new ArrayList<>();\\n                while(true){\\n                    if(!Character.isLowerCase(expression.charAt(index))){\\n                        ret=evaluate();\\n                        break;\\n                    }\\n                    String var=parseVar();\\n                    if(expression.charAt(index)==\\')\\'){\\n                        ret=scope.get(var).peek();\\n                        break;\\n                    }\\n                    vars.add(var);\\n                    index++;\\n                    int e=evaluate();\\n                    scope.putIfAbsent(var, new LinkedList<>());\\n                    scope.get(var).push(e); //assign a new value\\n                    index++;\\n                }\\n                for (String var : vars) {\\n                    scope.get(var).pop(); // remove all values of this scope\\n                }\\n\\n            } else if(begin==\\'a\\') {\\n                //add\\n                index += 4;\\n                int v1 = evaluate();\\n                index++;\\n                int v2 = evaluate();\\n                ret = v1+v2;\\n            } else {\\n                //multi\\n                index += 5;\\n                int v1 = evaluate();\\n                index++;\\n                int v2 = evaluate();\\n                ret =  v1*v2;\\n            }\\n            index++; // skip \\')\\'\\n            return ret;\\n        } else {\\n            //this is not a expression, this is an integer or a variable\\n            if(Character.isLowerCase(expression.charAt(index))){\\n\\t\\t\\t\\t//this is a variable, the current value is peek value\\n                String var=parseVar();\\n                return scope.get(var).peek();\\n            } else {\\n\\t\\t\\t\\t//this is an integer\\n                return parseInt();\\n            }\\n        }\\n    }\\n    \\n    //read an integer\\n    private int parseInt(){\\n        boolean negative=false;\\n        if(expression.charAt(index)==\\'-\\'){\\n            negative=true;\\n            index++;\\n        }\\n        int ret=0;\\n        while(Character.isDigit(expression.charAt(index))){\\n            ret*=10;\\n            ret+=expression.charAt(index)-\\'0\\';\\n            index++;\\n        }\\n        if(negative) return -ret;\\n        return ret;\\n    }\\n    \\n    //read a variable\\n    private String parseVar(){\\n        StringBuilder sb=new StringBuilder();\\n        char c=expression.charAt(index);\\n        while(c!=\\' \\' && c!=\\')\\'){\\n            sb.append(c);\\n            c=expression.charAt(++index);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2240099,
                "title": "stacking-dictionaries-recursion",
                "content": "```\\nimport re\\nclass Solution(object):\\n    def evaluate(self, e):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: int\\n        \"\"\"\\n        def evl(start, resolve=True):\\n            \"\"\"eval a sexp. return the value, and the past-end index\"\"\"\\n            if e[start]==\" \":\\n                start+=1\\n\\n            m = re.match(\"[(](?:(let)|(add|mult))|(-?[0-9]+)|([^ )]+)\",e[start:])\\n            assert(m)\\n            s=m.group(0)\\n\\n            if m.group(1):\\n                return let(start)\\n            elif m.group(2):\\n                return addmult(start)\\n            elif m.group(3):\\n                val = int(s)\\n            else:\\n                var = s\\n                val = d[var][-1] if resolve else var\\n            return val, start+len(s)\\n            \\n        def let(start):\\n            \"\"\"eval a let. return the value, and the past-end index\"\"\"\\n            vrs=[]\\n            start+=5\\n            while True:\\n                var, start=evl(start, resolve=False)\\n                if e[start]==\")\":\\n                    val=var if isinstance(var, int) else d[var][-1]\\n                    for v in vrs:\\n                        d[v].pop()\\n                    assert(e[start]==\\')\\')\\n                    return val, start+1\\n                else:\\n                    vrs.append(var)\\n                    val, start=evl(start)\\n                    d.setdefault(var, []).append(val)\\n            \\n\\n        def addmult(start):\\n            \"\"\"eval an add or mult. return the value, and the past-end index\"\"\"\\n            add=e[start+1]==\\'a\\'\\n            start+=5 if add else 6\\n            a, start=evl(start)\\n            b, start=evl(start)\\n            assert(e[start]==\\')\\')\\n            return (a+b if add else a*b), start+1\\n\\n        d={}\\n        val, end = evl(0)\\n        assert(len(e)==end)\\n        return val\\n```",
                "solutionTags": [
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nimport re\\nclass Solution(object):\\n    def evaluate(self, e):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: int\\n        \"\"\"\\n        def evl(start, resolve=True):\\n            \"\"\"eval a sexp. return the value, and the past-end index\"\"\"\\n            if e[start]==\" \":\\n                start+=1\\n\\n            m = re.match(\"[(](?:(let)|(add|mult))|(-?[0-9]+)|([^ )]+)\",e[start:])\\n            assert(m)\\n            s=m.group(0)\\n\\n            if m.group(1):\\n                return let(start)\\n            elif m.group(2):\\n                return addmult(start)\\n            elif m.group(3):\\n                val = int(s)\\n            else:\\n                var = s\\n                val = d[var][-1] if resolve else var\\n            return val, start+len(s)\\n            \\n        def let(start):\\n            \"\"\"eval a let. return the value, and the past-end index\"\"\"\\n            vrs=[]\\n            start+=5\\n            while True:\\n                var, start=evl(start, resolve=False)\\n                if e[start]==\")\":\\n                    val=var if isinstance(var, int) else d[var][-1]\\n                    for v in vrs:\\n                        d[v].pop()\\n                    assert(e[start]==\\')\\')\\n                    return val, start+1\\n                else:\\n                    vrs.append(var)\\n                    val, start=evl(start)\\n                    d.setdefault(var, []).append(val)\\n            \\n\\n        def addmult(start):\\n            \"\"\"eval an add or mult. return the value, and the past-end index\"\"\"\\n            add=e[start+1]==\\'a\\'\\n            start+=5 if add else 6\\n            a, start=evl(start)\\n            b, start=evl(start)\\n            assert(e[start]==\\')\\')\\n            return (a+b if add else a*b), start+1\\n\\n        d={}\\n        val, end = evl(0)\\n        assert(len(e)==end)\\n        return val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1948680,
                "title": "c-just-a-shot-away",
                "content": "```\\nclass Solution {\\n    using dict_t = map<string, int>;\\n    string getVar(string& s, int& i) {\\n        if (i < s.size() && isspace(s[i]))\\n            i++;\\n        int start = i;\\n        while (i < s.size() && (isdigit(s[i]) || isalpha(s[i])))\\n            i++;\\n        auto res = s.substr(start, i - start);\\n        if (i < s.size() && isspace(s[i]))\\n            i++;\\n        return res;\\n    }\\n    string getKeyword(string& s, int& i) {\\n        return getVar(s, i);\\n    }\\n    int getInteger(string& s, int& i) {\\n        int res = 0;\\n        if (i < s.size() && isspace(s[i]))\\n            i++;\\n        bool sign = false;\\n        if (i < s.size() && s[i] == \\'-\\') {\\n            sign = true;\\n            i++;\\n        }\\n        while (i < s.size() && isdigit(s[i])) {\\n            res = res * 10 + s[i] - \\'0\\';\\n            i++;\\n        }\\n        if (i < s.size() && isspace(s[i]))\\n            i++;\\n        if (sign)\\n            res *= -1;\\n        return res;\\n    }\\n    int getValue(string& s, int& i, vector<dict_t*>& v) {\\n        if (s[i] == \\'(\\')\\n            return parseExpression(s, ++i, v);\\n        return getInteger(s, i);\\n    }\\n    int getValueOf(string& var, vector<dict_t*>& v) {\\n        for (int i = v.size() - 1; i >= 0; i--) {\\n            if (v[i]->find(var) != v[i]->end())\\n                return (*v[i])[var];\\n        }\\n        return INT_MIN;\\n    }\\n    int getToken(string& s, int& i, vector<dict_t*>& v) {\\n        if (i < s.size() && isspace(s[i]))\\n            i++;\\n        if (i == s.size())\\n            return INT_MIN;\\n        if (s[i] == \\'(\\')\\n            return parseExpression(s, ++i, v);\\n        if (isdigit(s[i]) || s[i] == \\'-\\')\\n            return getInteger(s, i);\\n        string var = getVar(s, i);\\n        return getValueOf(var, v);\\n    }\\n    bool haveDigit(char c) {\\n        return c == \\'-\\' || isdigit(c);\\n    }\\n    int parseExpression(string& s, int& i, vector<dict_t*>& v) {\\n        int res = 0;\\n        const int STATE_REGULAR = 0;\\n        const int STATE_LET = 1;\\n        int state = 0;\\n        dict_t d;\\n        v.push_back(&d);\\n        while (i < s.size()) {\\n            char c = s[i];\\n            if (isspace(c)) {\\n                i++;\\n                continue;\\n            } if (c == \\'(\\') {\\n                res = parseExpression(s, ++i, v);\\n            } else if (c == \\')\\') {\\n                i++;\\n                break;\\n            } else if (state == STATE_LET) {\\n                if (haveDigit(c)) {\\n                    res = getInteger(s, i);\\n                    continue;\\n                }\\n                string var = getVar(s, i);\\n                if (i == s.size() || s[i] == \\')\\') {\\n                    res = getValueOf(var, v);\\n                    continue;\\n                } else {\\n                    int v1 = getToken(s, i, v);\\n                    d[var] = v1;\\n                }\\n            } else {\\n                string k = getKeyword(s, i);\\n                if (k == \"let\") {\\n                    state = STATE_LET;\\n                } else if (k == \"add\") {\\n                    int v1 = getToken(s, i, v);\\n                    int v2 = getToken(s, i, v);\\n                    res = v1 + v2;\\n                } else if (k == \"mult\") {\\n                    int v1 = getToken(s, i, v);\\n                    int v2 = getToken(s, i, v);\\n                    res = v1 * v2;\\n                } else {\\n                    puts(\"Unknown keyword\");\\n                    abort();\\n                }\\n            }\\n        }\\n        v.pop_back();\\n        return res;\\n    }\\npublic:\\n    int evaluate(string expression) {\\n        int start = 0;\\n        vector<dict_t*> v;\\n        return parseExpression(expression, start, v);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    using dict_t = map<string, int>;\\n    string getVar(string& s, int& i) {\\n        if (i < s.size() && isspace(s[i]))\\n            i++;\\n        int start = i;\\n        while (i < s.size() && (isdigit(s[i]) || isalpha(s[i])))\\n            i++;\\n        auto res = s.substr(start, i - start);\\n        if (i < s.size() && isspace(s[i]))\\n            i++;\\n        return res;\\n    }\\n    string getKeyword(string& s, int& i) {\\n        return getVar(s, i);\\n    }\\n    int getInteger(string& s, int& i) {\\n        int res = 0;\\n        if (i < s.size() && isspace(s[i]))\\n            i++;\\n        bool sign = false;\\n        if (i < s.size() && s[i] == \\'-\\') {\\n            sign = true;\\n            i++;\\n        }\\n        while (i < s.size() && isdigit(s[i])) {\\n            res = res * 10 + s[i] - \\'0\\';\\n            i++;\\n        }\\n        if (i < s.size() && isspace(s[i]))\\n            i++;\\n        if (sign)\\n            res *= -1;\\n        return res;\\n    }\\n    int getValue(string& s, int& i, vector<dict_t*>& v) {\\n        if (s[i] == \\'(\\')\\n            return parseExpression(s, ++i, v);\\n        return getInteger(s, i);\\n    }\\n    int getValueOf(string& var, vector<dict_t*>& v) {\\n        for (int i = v.size() - 1; i >= 0; i--) {\\n            if (v[i]->find(var) != v[i]->end())\\n                return (*v[i])[var];\\n        }\\n        return INT_MIN;\\n    }\\n    int getToken(string& s, int& i, vector<dict_t*>& v) {\\n        if (i < s.size() && isspace(s[i]))\\n            i++;\\n        if (i == s.size())\\n            return INT_MIN;\\n        if (s[i] == \\'(\\')\\n            return parseExpression(s, ++i, v);\\n        if (isdigit(s[i]) || s[i] == \\'-\\')\\n            return getInteger(s, i);\\n        string var = getVar(s, i);\\n        return getValueOf(var, v);\\n    }\\n    bool haveDigit(char c) {\\n        return c == \\'-\\' || isdigit(c);\\n    }\\n    int parseExpression(string& s, int& i, vector<dict_t*>& v) {\\n        int res = 0;\\n        const int STATE_REGULAR = 0;\\n        const int STATE_LET = 1;\\n        int state = 0;\\n        dict_t d;\\n        v.push_back(&d);\\n        while (i < s.size()) {\\n            char c = s[i];\\n            if (isspace(c)) {\\n                i++;\\n                continue;\\n            } if (c == \\'(\\') {\\n                res = parseExpression(s, ++i, v);\\n            } else if (c == \\')\\') {\\n                i++;\\n                break;\\n            } else if (state == STATE_LET) {\\n                if (haveDigit(c)) {\\n                    res = getInteger(s, i);\\n                    continue;\\n                }\\n                string var = getVar(s, i);\\n                if (i == s.size() || s[i] == \\')\\') {\\n                    res = getValueOf(var, v);\\n                    continue;\\n                } else {\\n                    int v1 = getToken(s, i, v);\\n                    d[var] = v1;\\n                }\\n            } else {\\n                string k = getKeyword(s, i);\\n                if (k == \"let\") {\\n                    state = STATE_LET;\\n                } else if (k == \"add\") {\\n                    int v1 = getToken(s, i, v);\\n                    int v2 = getToken(s, i, v);\\n                    res = v1 + v2;\\n                } else if (k == \"mult\") {\\n                    int v1 = getToken(s, i, v);\\n                    int v2 = getToken(s, i, v);\\n                    res = v1 * v2;\\n                } else {\\n                    puts(\"Unknown keyword\");\\n                    abort();\\n                }\\n            }\\n        }\\n        v.pop_back();\\n        return res;\\n    }\\npublic:\\n    int evaluate(string expression) {\\n        int start = 0;\\n        vector<dict_t*> v;\\n        return parseExpression(expression, start, v);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1800203,
                "title": "faster-than-100-clean-code",
                "content": "```\\n\\nfunc evaluate(expression string) int {\\n    context := &Context{}\\n    return evaluateWithContext(expression, context)\\n}\\n\\nfunc evaluateWithContext(expression string, context *Context) int {\\n    if expression[0] == \\'-\\' || (expression[0] >=\\'0\\' && expression[0]<=\\'9\\') {\\n        n, _ := strconv.Atoi(expression)\\n        return n\\n    }\\n    if expression[0] != \\'(\\' {\\n        return context.get(expression)\\n    }\\n    context.startScobe()\\n    defer context.endScobe()\\n\\n    if strings.HasPrefix(expression, \"(let\") {\\n        t := &Toknizer{expr:expression[5:len(expression)-1]}\\n        part := t.next()\\n        for t.hasNext() {\\n            context.set(part, evaluateWithContext(t.next(), context))\\n            part = t.next()\\n        }\\n        return evaluateWithContext(part, context)\\n    }\\n    \\n    if strings.HasPrefix(expression, \"(add\") {\\n        t := &Toknizer{expr:expression[5:len(expression)-1]}\\n        return evaluateWithContext(t.next(), context) + evaluateWithContext(t.next(), context)\\n    }\\n    \\n    if strings.HasPrefix(expression, \"(mult\") {\\n        t := &Toknizer{expr:expression[6:len(expression)-1]}\\n        return evaluateWithContext(t.next(), context) * evaluateWithContext(t.next(), context)\\n    }\\n    return 0    \\n}\\n\\ntype Context struct {\\n    variables []map[string]int\\n}\\n\\nfunc (c *Context) startScobe() {\\n    c.variables = append(c.variables, map[string]int{})\\n}\\n\\nfunc (c *Context) endScobe() {\\n    c.variables = c.variables[0:len(c.variables)-1]\\n}\\n\\nfunc (c *Context) set(varName string, value int) {\\n    c.variables[len(c.variables)-1][varName] = value\\n}\\n\\nfunc (c *Context) get(varName string) int {\\n    for j := len(c.variables)-1;j>=0;j-- {\\n        value, ok := c.variables[j][varName]\\n        if ok {\\n            return value\\n        }\\n    }\\n    return 0\\n}\\n\\ntype Toknizer struct {\\n    expr string\\n    p int\\n}\\n\\nfunc (t *Toknizer) next() string {\\n    if t.expr[t.p] != \\'(\\' {\\n\\t\\tp2 := t.p+1\\n\\t\\tfor p2 < len(t.expr) && t.expr[p2] != \\' \\' {p2++}\\n\\t\\tret := t.expr[t.p:p2]\\n\\t\\tt.p = p2 + 1\\n\\t\\treturn ret\\n\\t}\\n\\tp2 := t.p+1\\n\\tnest := 0\\n\\tfor {\\n\\t\\tif t.expr[p2] == \\'(\\' {\\n\\t\\t\\tnest++\\n\\t\\t} else if t.expr[p2] == \\')\\' {\\n\\t\\t\\tif nest == 0 {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tnest--\\n\\t\\t}\\n\\t\\tp2++\\n\\t}\\n\\tret := t.expr[t.p:p2+1]\\n\\tt.p = p2 + 2\\n\\treturn ret\\n}\\n\\nfunc (t *Toknizer) hasNext() bool {\\n    return t.p<len(t.expr)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n\\nfunc evaluate(expression string) int {\\n    context := &Context{}\\n    return evaluateWithContext(expression, context)\\n}\\n\\nfunc evaluateWithContext(expression string, context *Context) int {\\n    if expression[0] == \\'-\\' || (expression[0] >=\\'0\\' && expression[0]<=\\'9\\') {\\n        n, _ := strconv.Atoi(expression)\\n        return n\\n    }\\n    if expression[0] != \\'(\\' {\\n        return context.get(expression)\\n    }\\n    context.startScobe()\\n    defer context.endScobe()\\n\\n    if strings.HasPrefix(expression, \"(let\") {\\n        t := &Toknizer{expr:expression[5:len(expression)-1]}\\n        part := t.next()\\n        for t.hasNext() {\\n            context.set(part, evaluateWithContext(t.next(), context))\\n            part = t.next()\\n        }\\n        return evaluateWithContext(part, context)\\n    }\\n    \\n    if strings.HasPrefix(expression, \"(add\") {\\n        t := &Toknizer{expr:expression[5:len(expression)-1]}\\n        return evaluateWithContext(t.next(), context) + evaluateWithContext(t.next(), context)\\n    }\\n    \\n    if strings.HasPrefix(expression, \"(mult\") {\\n        t := &Toknizer{expr:expression[6:len(expression)-1]}\\n        return evaluateWithContext(t.next(), context) * evaluateWithContext(t.next(), context)\\n    }\\n    return 0    \\n}\\n\\ntype Context struct {\\n    variables []map[string]int\\n}\\n\\nfunc (c *Context) startScobe() {\\n    c.variables = append(c.variables, map[string]int{})\\n}\\n\\nfunc (c *Context) endScobe() {\\n    c.variables = c.variables[0:len(c.variables)-1]\\n}\\n\\nfunc (c *Context) set(varName string, value int) {\\n    c.variables[len(c.variables)-1][varName] = value\\n}\\n\\nfunc (c *Context) get(varName string) int {\\n    for j := len(c.variables)-1;j>=0;j-- {\\n        value, ok := c.variables[j][varName]\\n        if ok {\\n            return value\\n        }\\n    }\\n    return 0\\n}\\n\\ntype Toknizer struct {\\n    expr string\\n    p int\\n}\\n\\nfunc (t *Toknizer) next() string {\\n    if t.expr[t.p] != \\'(\\' {\\n\\t\\tp2 := t.p+1\\n\\t\\tfor p2 < len(t.expr) && t.expr[p2] != \\' \\' {p2++}\\n\\t\\tret := t.expr[t.p:p2]\\n\\t\\tt.p = p2 + 1\\n\\t\\treturn ret\\n\\t}\\n\\tp2 := t.p+1\\n\\tnest := 0\\n\\tfor {\\n\\t\\tif t.expr[p2] == \\'(\\' {\\n\\t\\t\\tnest++\\n\\t\\t} else if t.expr[p2] == \\')\\' {\\n\\t\\t\\tif nest == 0 {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t\\tnest--\\n\\t\\t}\\n\\t\\tp2++\\n\\t}\\n\\tret := t.expr[t.p:p2+1]\\n\\tt.p = p2 + 2\\n\\treturn ret\\n}\\n\\nfunc (t *Toknizer) hasNext() bool {\\n    return t.p<len(t.expr)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1762724,
                "title": "c-static-scope-eval-with-expression-tree-visualization",
                "content": "We first construct the expression tree and call `eval` recursively. \\nHaving the symbolic expression allows us to debugging issues in the parser and/or evaluator. \\n\\n```\\n============\\n>> expr = (let x 2 (mult x (let x 3 y 4 (add x y))))\\n>> SYMBOL @ 0x607000000030\\nVAR [name = __root__]\\n LET - (INIT)\\n  >> SYMBOL @ 0x6070000000a0\\n  VAR [name = x]\\n   2\\n EXPR\\n  MULT - (INIT)\\n   >> SYMBOL @ 0x607000000110\\n   VAR [name = x]\\n    2\\n   LET - (INIT)\\n    >> SYMBOL @ 0x607000000180\\n    VAR [name = x]\\n     3\\n    >> SYMBOL @ 0x607000000180\\n    VAR [name = y]\\n     4\\n   EXPR\\n    ADD - (INIT)\\n     >> SYMBOL @ 0x6070000001f0\\n     VAR [name = x]\\n      3\\n     >> SYMBOL @ 0x6070000001f0\\n     VAR [name = y]\\n      4\\n    ADD - (DONE)\\n   LET - (DONE)\\n  MULT - (DONE)\\n LET - (DONE)\\n\\n```\\n\\nCode\\n```\\n\\nnamespace {\\nconstexpr bool kDebug = true;\\n}\\n\\nclass Expr {\\npublic:\\n    virtual int eval() = 0;\\n    virtual void update(std::shared_ptr<Expr> expr) = 0;\\n    virtual std::string repr() const {\\n        return {};\\n    }\\n    virtual bool composite() const {\\n        return false;\\n    }\\n    virtual void debug_print(int level = 0) const = 0;\\n};\\n\\nnamespace {\\nusing symbol_table_t = std::unordered_map<std::string, std::shared_ptr<Expr>>;\\n}\\n\\nclass IntExpr : public Expr {\\npublic:       \\n    IntExpr() : val_(0) {}\\n    IntExpr(int val) : val_(val) {}\\n    \\n    virtual int eval() override {\\n        return val_;\\n    }\\n    virtual void update(std::shared_ptr<Expr> expr) override {\\n        val_ = expr->eval();\\n    }\\n    virtual std::string repr() const override {\\n        return std::to_string(val_);\\n    }\\n    virtual void debug_print(int level) const override {\\n        if constexpr (kDebug) {\\n            const std::string prefix(level, \\' \\');\\n            std::cout << prefix << val_ << std::endl;\\n        }\\n    }\\nprivate:\\n    int val_;\\n};\\n\\nclass VarExpr : public Expr {\\npublic:\\n    VarExpr(\\n        const std::string &name,\\n        std::shared_ptr<symbol_table_t> vtbl_ptr\\n    ): var_name_(name), shared_vtbl_ptr_(vtbl_ptr) {}\\n    \\n    virtual int eval() override {\\n        if (binding_) {\\n            return binding_->eval();\\n        }\\n        return shared_vtbl_ptr_->find(var_name_)->second->eval();\\n    }    \\n    virtual void update(std::shared_ptr<Expr> expr) override {\\n        binding_ = (*shared_vtbl_ptr_)[var_name_] = \\n            expr->composite() ? expr : std::make_shared<IntExpr>(expr->eval());\\n    }    \\n    virtual std::string repr() const override {\\n        std::ostringstream sout;\\n        sout << \"VAR [name = \" << var_name_ << \"]\";\\n        return sout.str();\\n    }\\n    virtual void debug_print(int level = 0) const override {\\n        if constexpr (kDebug) {\\n            const std::string prefix(level, \\' \\');\\n            std::cout << prefix << \">> SYMBOL @ \" << shared_vtbl_ptr_ << std::endl;\\n            std::cout << prefix << repr() << std::endl;\\n            if (binding_) {\\n                binding_->debug_print(level + 1);\\n            } else {\\n                auto it = shared_vtbl_ptr_->find(var_name_);\\n                if (it != shared_vtbl_ptr_->end()) {\\n                    it->second->debug_print(level + 1);\\n                }\\n            }\\n        }\\n    }    \\nprivate:\\n    std::string var_name_;    \\n    std::shared_ptr<symbol_table_t> shared_vtbl_ptr_;\\n    std::shared_ptr<Expr> binding_ = nullptr;\\n};\\n\\nclass LetExpr : public Expr {\\npublic:\\n    virtual int eval() override {\\n        return ops_.back()->eval();\\n    }  \\n    virtual void update(std::shared_ptr<Expr> expr) override {        \\n        if ((ops_.size() % 2) == 1) {\\n            ops_.back()->update(expr);\\n        }\\n        ops_.push_back(expr);  \\n    }    \\n    virtual bool composite() const override {\\n        return true;\\n    }    \\n    virtual void debug_print(int level = 0) const override {\\n        if constexpr (kDebug) {\\n            const std::string prefix(level, \\' \\');\\n            std::cout << prefix << \"LET - (INIT)\" << std::endl;\\n            for (int i = 0; i + 1 < ops_.size(); i += 2) {\\n                ops_[i]->debug_print(level + 1);\\n            }\\n            std::cout << prefix << \"EXPR\" << std::endl;\\n            ops_.back()->debug_print(level + 1);\\n            std::cout << prefix << \"LET - (DONE)\" << std::endl;            \\n        }\\n    }        \\nprivate:\\n    std::vector<std::shared_ptr<Expr>> ops_;\\n};\\n\\nclass AddExpr : public Expr {\\npublic:\\n    virtual int eval() override {\\n        int val = 0;\\n        for (auto op : ops_) {\\n            val += op->eval();\\n        }\\n        return val;\\n    }        \\n    virtual void update(std::shared_ptr<Expr> expr) override {\\n        ops_.push_back(expr);\\n    }    \\n    virtual bool composite() const override {\\n        return true;\\n    }        \\n    virtual void debug_print(int level = 0) const override {\\n        if constexpr (kDebug) {\\n            const std::string prefix(level, \\' \\');\\n            std::cout << prefix << \"ADD - (INIT)\" << std::endl;\\n            for (auto op : ops_) {\\n                op->debug_print(level + 1);\\n            }\\n            std::cout << prefix << \"ADD - (DONE)\" << std::endl;\\n        }\\n    }            \\nprivate:\\n    std::vector<std::shared_ptr<Expr>> ops_;\\n};\\n\\nclass MultExpr : public Expr {\\npublic:\\n    virtual int eval() override {\\n        int val = 1;\\n        for (auto op : ops_) {\\n            val *= op->eval();\\n        }\\n        return val;\\n    }\\n    virtual void update(std::shared_ptr<Expr> expr) override {\\n        ops_.push_back(expr);\\n    }\\n    virtual bool composite() const override {\\n        return true;\\n    }    \\n    virtual void debug_print(int level = 0) const override {\\n        if constexpr (kDebug) {\\n            const std::string prefix(level, \\' \\');\\n            std::cout << prefix << \"MULT - (INIT)\" << std::endl;\\n            for (auto op : ops_) {\\n                op->debug_print(level + 1);\\n            }\\n            std::cout << prefix << \"MULT - (DONE)\" << std::endl;\\n        }\\n    }                \\nprivate:\\n    std::vector<std::shared_ptr<Expr>> ops_;    \\n};\\n\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        if constexpr (kDebug) {\\n            std::cout << \"============\" << std::endl;\\n            std::cout << \">> expr = \" << expression << std::endl;\\n        }\\n        \\n        std::stack<std::shared_ptr<Expr>> expr_stack;\\n        std::stack<std::shared_ptr<symbol_table_t>> vtbl_stack;\\n        vtbl_stack.push(std::make_shared<symbol_table_t>());\\n        expr_stack.push(\\n            std::make_shared<VarExpr>(\"__root__\", vtbl_stack.top())\\n        );\\n        \\n        const auto terminal_reached = [&expression](int i) -> bool {\\n            if (i == expression.size()) {\\n                return true;\\n            }\\n            switch (expression[i]) {\\n                case \\' \\':\\n                case \\')\\':\\n                    return true;\\n            }\\n            return false;\\n        };\\n        \\n        int idx = 0;                  \\n        while (idx < expression.size()) {\\n            const char ch = expression[idx]; \\n            if (ch == \\' \\') {\\n                ++idx;\\n                continue;\\n            }\\n            \\n            if (ch == \\')\\') {\\n                auto expr = expr_stack.top();\\n                expr_stack.pop();\\n                vtbl_stack.pop();                \\n                // panic if empty\\n                expr_stack.top()->update(expr);                                \\n                ++idx;\\n                continue;\\n            }\\n            \\n            if (ch == \\'(\\') {\\n                // Start a new node \\n                std::ostringstream sout;\\n                for (++idx; idx < expression.size(); ++idx) {\\n                    if (terminal_reached(idx)) {\\n                        break;\\n                    }\\n                    sout << expression[idx];\\n                }\\n                expr_stack.push(new_node_from_command(sout.str()));\\n                vtbl_stack.push(\\n                    std::make_shared<symbol_table_t>(*(vtbl_stack.top()))\\n                );\\n                continue;\\n            }            \\n            \\n            // Parse an integer.\\n            if ((ch == \\'-\\') || std::isdigit(ch)) {\\n                int sign = 1;\\n                if (ch == \\'-\\') {\\n                    sign = -1;\\n                    ++idx;\\n                }\\n                int val = 0;\\n                for (; idx < expression.size(); ++idx) {\\n                    if (terminal_reached(idx)) {\\n                        break;\\n                    }\\n                    val = val * 10 \\n                        + static_cast<int>(expression[idx] - \\'0\\');\\n                }\\n                expr_stack.top()->update(\\n                    std::make_shared<IntExpr>(sign * val)\\n                );                \\n                continue;\\n            }\\n            \\n            // Parse a variable or literal.\\n            std::ostringstream sout;\\n            for (; idx < expression.size(); ++idx) {\\n                if (terminal_reached(idx)) {\\n                    break;\\n                }\\n                sout << expression[idx];\\n            }\\n            expr_stack.top()->update(\\n                std::make_shared<VarExpr>(sout.str(), vtbl_stack.top())\\n            );\\n        }   \\n        \\n        expr_stack.top()->debug_print();\\n        return expr_stack.top()->eval();\\n    }\\nprivate:    \\n    std::shared_ptr<Expr> new_node_from_command(\\n        const std::string &cmd) const {\\n        if (cmd == \"add\") {\\n            return std::make_shared<AddExpr>();\\n        }        \\n        if (cmd == \"mult\") {\\n            return std::make_shared<MultExpr>();\\n        }\\n        if (cmd == \"let\") {\\n            return std::make_shared<LetExpr>();\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n============\\n>> expr = (let x 2 (mult x (let x 3 y 4 (add x y))))\\n>> SYMBOL @ 0x607000000030\\nVAR [name = __root__]\\n LET - (INIT)\\n  >> SYMBOL @ 0x6070000000a0\\n  VAR [name = x]\\n   2\\n EXPR\\n  MULT - (INIT)\\n   >> SYMBOL @ 0x607000000110\\n   VAR [name = x]\\n    2\\n   LET - (INIT)\\n    >> SYMBOL @ 0x607000000180\\n    VAR [name = x]\\n     3\\n    >> SYMBOL @ 0x607000000180\\n    VAR [name = y]\\n     4\\n   EXPR\\n    ADD - (INIT)\\n     >> SYMBOL @ 0x6070000001f0\\n     VAR [name = x]\\n      3\\n     >> SYMBOL @ 0x6070000001f0\\n     VAR [name = y]\\n      4\\n    ADD - (DONE)\\n   LET - (DONE)\\n  MULT - (DONE)\\n LET - (DONE)\\n\\n```\n```\\n\\nnamespace {\\nconstexpr bool kDebug = true;\\n}\\n\\nclass Expr {\\npublic:\\n    virtual int eval() = 0;\\n    virtual void update(std::shared_ptr<Expr> expr) = 0;\\n    virtual std::string repr() const {\\n        return {};\\n    }\\n    virtual bool composite() const {\\n        return false;\\n    }\\n    virtual void debug_print(int level = 0) const = 0;\\n};\\n\\nnamespace {\\nusing symbol_table_t = std::unordered_map<std::string, std::shared_ptr<Expr>>;\\n}\\n\\nclass IntExpr : public Expr {\\npublic:       \\n    IntExpr() : val_(0) {}\\n    IntExpr(int val) : val_(val) {}\\n    \\n    virtual int eval() override {\\n        return val_;\\n    }\\n    virtual void update(std::shared_ptr<Expr> expr) override {\\n        val_ = expr->eval();\\n    }\\n    virtual std::string repr() const override {\\n        return std::to_string(val_);\\n    }\\n    virtual void debug_print(int level) const override {\\n        if constexpr (kDebug) {\\n            const std::string prefix(level, \\' \\');\\n            std::cout << prefix << val_ << std::endl;\\n        }\\n    }\\nprivate:\\n    int val_;\\n};\\n\\nclass VarExpr : public Expr {\\npublic:\\n    VarExpr(\\n        const std::string &name,\\n        std::shared_ptr<symbol_table_t> vtbl_ptr\\n    ): var_name_(name), shared_vtbl_ptr_(vtbl_ptr) {}\\n    \\n    virtual int eval() override {\\n        if (binding_) {\\n            return binding_->eval();\\n        }\\n        return shared_vtbl_ptr_->find(var_name_)->second->eval();\\n    }    \\n    virtual void update(std::shared_ptr<Expr> expr) override {\\n        binding_ = (*shared_vtbl_ptr_)[var_name_] = \\n            expr->composite() ? expr : std::make_shared<IntExpr>(expr->eval());\\n    }    \\n    virtual std::string repr() const override {\\n        std::ostringstream sout;\\n        sout << \"VAR [name = \" << var_name_ << \"]\";\\n        return sout.str();\\n    }\\n    virtual void debug_print(int level = 0) const override {\\n        if constexpr (kDebug) {\\n            const std::string prefix(level, \\' \\');\\n            std::cout << prefix << \">> SYMBOL @ \" << shared_vtbl_ptr_ << std::endl;\\n            std::cout << prefix << repr() << std::endl;\\n            if (binding_) {\\n                binding_->debug_print(level + 1);\\n            } else {\\n                auto it = shared_vtbl_ptr_->find(var_name_);\\n                if (it != shared_vtbl_ptr_->end()) {\\n                    it->second->debug_print(level + 1);\\n                }\\n            }\\n        }\\n    }    \\nprivate:\\n    std::string var_name_;    \\n    std::shared_ptr<symbol_table_t> shared_vtbl_ptr_;\\n    std::shared_ptr<Expr> binding_ = nullptr;\\n};\\n\\nclass LetExpr : public Expr {\\npublic:\\n    virtual int eval() override {\\n        return ops_.back()->eval();\\n    }  \\n    virtual void update(std::shared_ptr<Expr> expr) override {        \\n        if ((ops_.size() % 2) == 1) {\\n            ops_.back()->update(expr);\\n        }\\n        ops_.push_back(expr);  \\n    }    \\n    virtual bool composite() const override {\\n        return true;\\n    }    \\n    virtual void debug_print(int level = 0) const override {\\n        if constexpr (kDebug) {\\n            const std::string prefix(level, \\' \\');\\n            std::cout << prefix << \"LET - (INIT)\" << std::endl;\\n            for (int i = 0; i + 1 < ops_.size(); i += 2) {\\n                ops_[i]->debug_print(level + 1);\\n            }\\n            std::cout << prefix << \"EXPR\" << std::endl;\\n            ops_.back()->debug_print(level + 1);\\n            std::cout << prefix << \"LET - (DONE)\" << std::endl;            \\n        }\\n    }        \\nprivate:\\n    std::vector<std::shared_ptr<Expr>> ops_;\\n};\\n\\nclass AddExpr : public Expr {\\npublic:\\n    virtual int eval() override {\\n        int val = 0;\\n        for (auto op : ops_) {\\n            val += op->eval();\\n        }\\n        return val;\\n    }        \\n    virtual void update(std::shared_ptr<Expr> expr) override {\\n        ops_.push_back(expr);\\n    }    \\n    virtual bool composite() const override {\\n        return true;\\n    }        \\n    virtual void debug_print(int level = 0) const override {\\n        if constexpr (kDebug) {\\n            const std::string prefix(level, \\' \\');\\n            std::cout << prefix << \"ADD - (INIT)\" << std::endl;\\n            for (auto op : ops_) {\\n                op->debug_print(level + 1);\\n            }\\n            std::cout << prefix << \"ADD - (DONE)\" << std::endl;\\n        }\\n    }            \\nprivate:\\n    std::vector<std::shared_ptr<Expr>> ops_;\\n};\\n\\nclass MultExpr : public Expr {\\npublic:\\n    virtual int eval() override {\\n        int val = 1;\\n        for (auto op : ops_) {\\n            val *= op->eval();\\n        }\\n        return val;\\n    }\\n    virtual void update(std::shared_ptr<Expr> expr) override {\\n        ops_.push_back(expr);\\n    }\\n    virtual bool composite() const override {\\n        return true;\\n    }    \\n    virtual void debug_print(int level = 0) const override {\\n        if constexpr (kDebug) {\\n            const std::string prefix(level, \\' \\');\\n            std::cout << prefix << \"MULT - (INIT)\" << std::endl;\\n            for (auto op : ops_) {\\n                op->debug_print(level + 1);\\n            }\\n            std::cout << prefix << \"MULT - (DONE)\" << std::endl;\\n        }\\n    }                \\nprivate:\\n    std::vector<std::shared_ptr<Expr>> ops_;    \\n};\\n\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        if constexpr (kDebug) {\\n            std::cout << \"============\" << std::endl;\\n            std::cout << \">> expr = \" << expression << std::endl;\\n        }\\n        \\n        std::stack<std::shared_ptr<Expr>> expr_stack;\\n        std::stack<std::shared_ptr<symbol_table_t>> vtbl_stack;\\n        vtbl_stack.push(std::make_shared<symbol_table_t>());\\n        expr_stack.push(\\n            std::make_shared<VarExpr>(\"__root__\", vtbl_stack.top())\\n        );\\n        \\n        const auto terminal_reached = [&expression](int i) -> bool {\\n            if (i == expression.size()) {\\n                return true;\\n            }\\n            switch (expression[i]) {\\n                case \\' \\':\\n                case \\')\\':\\n                    return true;\\n            }\\n            return false;\\n        };\\n        \\n        int idx = 0;                  \\n        while (idx < expression.size()) {\\n            const char ch = expression[idx]; \\n            if (ch == \\' \\') {\\n                ++idx;\\n                continue;\\n            }\\n            \\n            if (ch == \\')\\') {\\n                auto expr = expr_stack.top();\\n                expr_stack.pop();\\n                vtbl_stack.pop();                \\n                // panic if empty\\n                expr_stack.top()->update(expr);                                \\n                ++idx;\\n                continue;\\n            }\\n            \\n            if (ch == \\'(\\') {\\n                // Start a new node \\n                std::ostringstream sout;\\n                for (++idx; idx < expression.size(); ++idx) {\\n                    if (terminal_reached(idx)) {\\n                        break;\\n                    }\\n                    sout << expression[idx];\\n                }\\n                expr_stack.push(new_node_from_command(sout.str()));\\n                vtbl_stack.push(\\n                    std::make_shared<symbol_table_t>(*(vtbl_stack.top()))\\n                );\\n                continue;\\n            }            \\n            \\n            // Parse an integer.\\n            if ((ch == \\'-\\') || std::isdigit(ch)) {\\n                int sign = 1;\\n                if (ch == \\'-\\') {\\n                    sign = -1;\\n                    ++idx;\\n                }\\n                int val = 0;\\n                for (; idx < expression.size(); ++idx) {\\n                    if (terminal_reached(idx)) {\\n                        break;\\n                    }\\n                    val = val * 10 \\n                        + static_cast<int>(expression[idx] - \\'0\\');\\n                }\\n                expr_stack.top()->update(\\n                    std::make_shared<IntExpr>(sign * val)\\n                );                \\n                continue;\\n            }\\n            \\n            // Parse a variable or literal.\\n            std::ostringstream sout;\\n            for (; idx < expression.size(); ++idx) {\\n                if (terminal_reached(idx)) {\\n                    break;\\n                }\\n                sout << expression[idx];\\n            }\\n            expr_stack.top()->update(\\n                std::make_shared<VarExpr>(sout.str(), vtbl_stack.top())\\n            );\\n        }   \\n        \\n        expr_stack.top()->debug_print();\\n        return expr_stack.top()->eval();\\n    }\\nprivate:    \\n    std::shared_ptr<Expr> new_node_from_command(\\n        const std::string &cmd) const {\\n        if (cmd == \"add\") {\\n            return std::make_shared<AddExpr>();\\n        }        \\n        if (cmd == \"mult\") {\\n            return std::make_shared<MultExpr>();\\n        }\\n        if (cmd == \"let\") {\\n            return std::make_shared<LetExpr>();\\n        }\\n        return nullptr;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1632041,
                "title": "swift-solution-using-dictionary-for-quick-lookup-of-each-variable-s-value",
                "content": "```\\n\\tfunc evaluate(_ expression: String) -> Int {\\n\\t\\tvar varValues: [String: Int] = [:]\\n\\t\\treturn eval(expression, varValues)\\n    }\\n\\n    func eval(_ expression: String, _ values: [String: Int]) -> Int {\\n\\t\\tvar values = values\\n\\t\\tvar firstStr = String(expression.prefix(1))\\n\\t\\tif firstStr != \"(\" { \\n\\t\\t\\t\\tif let val = values[expression] {\\t\\n\\t\\t\\t\\t\\t\\treturn val\\n                } else {\\n\\t\\t\\t\\t\\t\\treturn Int(expression) ?? 0\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t    var parsed: (opt: String, items: [String]) = parse(expression) \\n\\t\\tvar items = parsed.items\\n\\t\\tswitch parsed.opt {\\n\\t\\t\\tcase \"add\":\\n\\t\\t\\t\\t\\treturn eval(items[0], values) + eval(items[1], values)\\n\\t\\t\\tcase \"mult\":\\n\\t\\t\\t\\t\\treturn eval(items[0], values) * eval(items[1], values)\\n\\t\\t\\tcase \"let\":\\n\\t\\t\\t\\t\\tfor i in stride(from: 0, to: items.count-2, by: 2) {\\n\\t\\t\\t\\t\\t\\t\\t//even items are variables and odd items are values\\n\\t\\t\\t\\t\\t\\t\\tvalues[items[i]] = eval(items[i+1], values)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn eval(items[items.count-1], values)\\n\\t\\t\\tdefault: // just a value/variable\\n\\t\\t\\t\\t\\treturn eval(parsed.opt, values)\\n\\t\\t}\\n    }\\n            \\n    func parse(_ exp: String) -> (String,[String]) {\\n\\t\\tlet firstSpace = exp.firstIndex(of: \" \") ?? exp.endIndex\\n\\t\\tlet opt = exp[exp.index(after: exp.startIndex)..<firstSpace] \\n        let offset = opt == \"mult\" ? 6 : 5\\n\\t\\tvar exp = Array(exp)\\n\\t\\tvar items: [String] = []\\n\\t\\tvar tempStr = \"\"\\n\\t\\tvar count = 0\\n\\t\\tfor i in offset..<exp.count-1 {\\n\\t\\t\\t\\tif exp[i] == \"(\" {\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t} else if exp[i] == \")\" {\\n\\t\\t\\t\\t\\t\\tcount -= 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif count == 0 && exp[i] == \" \" { // not in the outmost parentheses and on a whitespace\\n\\t\\t\\t\\t\\t\\titems.append(tempStr)  \\n\\t\\t\\t\\t\\t\\ttempStr = \"\"\\n\\t\\t\\t\\t} else { \\n\\t\\t\\t\\t\\t\\ttempStr.append(exp[i]) \\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif tempStr.count > 0 { items.append(tempStr) } // since the last item won\\'t be added because there is no space after it\\n\\t\\treturn (String(opt), items)\\n    }\\n//Time: O(m*n) Space: O(n*m) where n = String.count, m = expr numbers = max stack num.\\n```",
                "solutionTags": [],
                "code": "```\\n\\tfunc evaluate(_ expression: String) -> Int {\\n\\t\\tvar varValues: [String: Int] = [:]\\n\\t\\treturn eval(expression, varValues)\\n    }\\n\\n    func eval(_ expression: String, _ values: [String: Int]) -> Int {\\n\\t\\tvar values = values\\n\\t\\tvar firstStr = String(expression.prefix(1))\\n\\t\\tif firstStr != \"(\" { \\n\\t\\t\\t\\tif let val = values[expression] {\\t\\n\\t\\t\\t\\t\\t\\treturn val\\n                } else {\\n\\t\\t\\t\\t\\t\\treturn Int(expression) ?? 0\\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t    var parsed: (opt: String, items: [String]) = parse(expression) \\n\\t\\tvar items = parsed.items\\n\\t\\tswitch parsed.opt {\\n\\t\\t\\tcase \"add\":\\n\\t\\t\\t\\t\\treturn eval(items[0], values) + eval(items[1], values)\\n\\t\\t\\tcase \"mult\":\\n\\t\\t\\t\\t\\treturn eval(items[0], values) * eval(items[1], values)\\n\\t\\t\\tcase \"let\":\\n\\t\\t\\t\\t\\tfor i in stride(from: 0, to: items.count-2, by: 2) {\\n\\t\\t\\t\\t\\t\\t\\t//even items are variables and odd items are values\\n\\t\\t\\t\\t\\t\\t\\tvalues[items[i]] = eval(items[i+1], values)\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn eval(items[items.count-1], values)\\n\\t\\t\\tdefault: // just a value/variable\\n\\t\\t\\t\\t\\treturn eval(parsed.opt, values)\\n\\t\\t}\\n    }\\n            \\n    func parse(_ exp: String) -> (String,[String]) {\\n\\t\\tlet firstSpace = exp.firstIndex(of: \" \") ?? exp.endIndex\\n\\t\\tlet opt = exp[exp.index(after: exp.startIndex)..<firstSpace] \\n        let offset = opt == \"mult\" ? 6 : 5\\n\\t\\tvar exp = Array(exp)\\n\\t\\tvar items: [String] = []\\n\\t\\tvar tempStr = \"\"\\n\\t\\tvar count = 0\\n\\t\\tfor i in offset..<exp.count-1 {\\n\\t\\t\\t\\tif exp[i] == \"(\" {\\n\\t\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t} else if exp[i] == \")\" {\\n\\t\\t\\t\\t\\t\\tcount -= 1\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif count == 0 && exp[i] == \" \" { // not in the outmost parentheses and on a whitespace\\n\\t\\t\\t\\t\\t\\titems.append(tempStr)  \\n\\t\\t\\t\\t\\t\\ttempStr = \"\"\\n\\t\\t\\t\\t} else { \\n\\t\\t\\t\\t\\t\\ttempStr.append(exp[i]) \\n\\t\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif tempStr.count > 0 { items.append(tempStr) } // since the last item won\\'t be added because there is no space after it\\n\\t\\treturn (String(opt), items)\\n    }\\n//Time: O(m*n) Space: O(n*m) where n = String.count, m = expr numbers = max stack num.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1622201,
                "title": "c-solution-simple-parsing-recursion-and-singly-linked-lists-for-variables-and-scopes",
                "content": "```c\\n/*\\n *  C solution\\n */\\n\\n\\n/*\\n * Variable stores the start of name with its length and values.\\n * This saves memory because no need to allocate strings.\\n * Also, variable is a node in its scope.\\n */\\nstruct variable {\\n    int val;\\n    int nameLen;\\n    char *name;\\n    struct variable *next;\\n};\\n\\n\\n/*\\n * Scope is a node in the scope chain.\\n */\\nstruct scope {\\n    struct variable *varHead;\\n    struct scope *up;\\n};\\n\\n/*\\n * Space complexity is O(n*m),\\n * where n is the mean count of variables in the scopes,\\n * m is the count of scopes. \\n * Scopes and variables are in singly linked list.\\n */\\n\\n\\nstatic struct variable* scopeLookupLocally(struct scope *s, char *varName, int nameLen) {\\n    struct variable *n;\\n    int cmpLen;\\n    for (n = s->varHead; n != NULL; n = n->next) {\\n        cmpLen = n->nameLen;\\n        cmpLen = (cmpLen < nameLen ? nameLen : cmpLen);\\n        if (!strncmp(varName, n->name, cmpLen)) {\\n            return n;\\n        }\\n    }\\n    return NULL;\\n}\\n\\n/*\\n * Define or redefine a variable in the scope only.\\n * It\\'s O(n) worst case time complexity,\\n * where n is the count of variables in scope.\\n */\\nstatic struct variable* scopeDefineLocally(struct scope *s, char *varName, int nameLen) {\\n    struct variable **n;\\n    int cmpLen;\\n    for (n = &s->varHead; *n != NULL; n = &(*n)->next) {\\n        cmpLen = (*n)->nameLen;\\n        cmpLen = (cmpLen < nameLen ? nameLen : cmpLen);\\n        if (!strncmp(varName, (*n)->name, cmpLen)) {\\n            return *n;\\n        }\\n    }\\n    *n = malloc(sizeof(struct variable));\\n    if (*n == NULL) {\\n        return NULL;\\n    }\\n    (*n)->name = varName;\\n    (*n)->nameLen = nameLen;\\n    (*n)->next = NULL;\\n    return *n;\\n}\\n\\n/*\\n * Look up for the closest variable in all the scope chain.\\n * It\\'s O(n*m) worst case time complexity,\\n * where n is the mean count of variables in the scopes,\\n * m is the count of scopes.\\n */\\nstatic struct variable* scopeLookup(struct scope *s, char *varName, int nameLen) {\\n    struct scope *n;\\n    struct variable *var;\\n    for (n = s; n != NULL; n = n->up) {\\n        var = scopeLookupLocally(n, varName, nameLen);\\n        if (var) {\\n            return var;\\n        }\\n    }\\n    return NULL;\\n}\\n\\nstatic void scopeFreeVariables(struct scope *s) {\\n    struct variable *n, *t;\\n    for (n = s->varHead; n != NULL;) {\\n        t = n;\\n        n = n->next;\\n        free(t);\\n    }\\n    s->varHead = NULL;\\n}\\n\\nstatic void scopeFree(struct scope *s) {\\n    struct scope *n, *t;\\n    for (n = s; n != NULL;) {\\n        t = n;\\n        n = n->up;\\n        scopeFreeVariables(t);\\n        free(t);\\n    }\\n}\\n\\n\\n/*\\n * Append a new scope in the chain.\\n */\\nstatic struct scope* pushScope(struct scope **s) {\\n    struct scope *parent = *s;\\n    *s = malloc(sizeof(struct scope));\\n    if (*s == NULL) {\\n        *s = parent;\\n        return NULL;\\n    }\\n    (*s)->up = parent;\\n    (*s)->varHead = NULL;\\n    return *s;\\n}\\n\\n/*\\n * Remove the current scope in the chain and go up.\\n */\\nstatic struct scope* popScope(struct scope **s) {\\n    struct scope *parent = (*s)->up;\\n    scopeFreeVariables(*s);\\n    free(*s);\\n    return *s = parent;\\n}\\n\\n\\n/*\\n * Parsing with tokens that store their type, string and integer values.\\n * As in variables, the string value is a piece of the expression string.\\n */\\n#define TOKEN_END   0\\n#define TOKEN_INT   1\\n#define TOKEN_NAME  2\\n#define TOKEN_SEXP  3\\n#define TOKEN_CLOSE 4\\nstruct token {\\n    int type;\\n    int len;\\n    int val;\\n    char *str;\\n};\\n\\n\\n/*\\n * Parse the next token and move the string pointer (**s).\\n * Return 0 if a closing parenthesis encounted, otherwise 1 \\n */\\nstatic int tokenNext(char **s, struct token *dst) {\\n    int status = 1, sign;\\n    for (; isspace(**s); ++(*s)) {}\\n    if (**s == \\'\\\\0\\') {\\n        dst->len = 0;\\n        dst->type = TOKEN_END;\\n        return 1;\\n    }\\n    dst->str = *s;\\n    if (isdigit(**s) || **s == \\'-\\' || **s == \\'+\\') {\\n        sign = **s == \\'-\\';\\n        if (**s == \\'-\\' || **s == \\'+\\') {\\n            ++(*s);\\n        }\\n        dst->type = TOKEN_INT;\\n        dst->val = 0;\\n        for (; isdigit(**s); ++(*s)) {\\n            dst->val = dst->val*10 - (**s - \\'0\\');\\n        }\\n        dst->val = (sign ? dst->val : -dst->val);\\n    } else if (isalpha(**s)) {\\n        dst->type = TOKEN_NAME;\\n        for (; isalnum(**s); ++(*s)) {}\\n    } else if (**s == \\'(\\') {\\n        dst->type = TOKEN_SEXP;\\n        ++(*s);\\n    } else if (**s == \\')\\') {\\n        status = 0;\\n        dst->type = TOKEN_CLOSE;\\n        ++(*s);\\n    }\\n\\n    dst->len = *s - dst->str;\\n    return status;\\n}\\n\\n/*\\n * Evaluation part.\\n * This is recursive the \\'_evaluate\\' function calling its subroutines.\\n * The function saves the result in the pointer.\\n * In case of error, the function returns zero.\\n */\\n\\nstatic int _evaluate(char **s, int *result, struct token *tok, struct scope **curScope);\\n\\nstatic int evaluateCommandLet(char **s, int *result, struct token *tok, struct scope **curScope) {\\n    struct variable *var;\\n    char *oldPos, *varName;\\n    int varNameLen;\\n    int varVal;\\n    if (pushScope(curScope) == NULL) {\\n        return 0;\\n    }\\n    for (;;) { /* Defining variables while it\\'s possible. */\\n        oldPos = *s;\\n        if (!tokenNext(s, tok)) {\\n            return 0;\\n        }\\n        if (tok->type == TOKEN_NAME) {\\n            varName = tok->str;\\n            varNameLen = tok->len;\\n            if (!_evaluate(s, &varVal, tok, curScope)) {\\n                *s = oldPos;\\n                break;\\n            }\\n            var = scopeDefineLocally(*curScope, varName, varNameLen);\\n            if (var == NULL) {\\n                return 0;\\n            }\\n            var->val = varVal;\\n        } else {\\n            *s = oldPos;\\n            break;\\n        }\\n    }\\n    /* Evaluate the trailing part. */\\n    if (!_evaluate(s, result, tok, curScope)) {\\n        return 0;\\n    }\\n    if (tokenNext(s, tok)) { /* Skip a closing parenthesis */\\n        return 0;\\n    }\\n    popScope(curScope);\\n    return 1;\\n}\\n\\nstatic int evaluateCommandAdd(char **s, int *result, struct token *tok, struct scope **curScope) {\\n    int op1, op2;\\n    if (!_evaluate(s, &op1, tok, curScope)) {\\n        return 0;\\n    }\\n    if (!_evaluate(s, &op2, tok, curScope)) {\\n        return 0;\\n    }\\n    *result = op1 + op2;\\n    if (tokenNext(s, tok)) { /* Skip a closing parenthesis */\\n        return 0;\\n    }\\n    return 1;\\n}\\n\\nstatic int evaluateCommandMult(char **s, int *result, struct token *tok, struct scope **curScope) {\\n    int op1, op2;\\n    if (!_evaluate(s, &op1, tok, curScope)) {\\n        return 0;\\n    }\\n    if (!_evaluate(s, &op2, tok, curScope)) {\\n        return 0;\\n    }\\n    *result = op1*op2;\\n    if (tokenNext(s, tok)) {/* Skip a closing parenthesis */\\n        return 0;\\n    }\\n    return 1;\\n}\\n\\n/*\\n * Evaluate a command in the sexp.\\n * Simple searching for commands with strncmp.\\n */\\nstatic int evaluateCommand(char **s, int *result, struct token *tok, struct scope **curScope) {\\n    char *cmd = tok->str;\\n    int cmdLen = tok->len;\\n\\n    if (!strncmp(cmd, \"let\", cmdLen)) {\\n        return evaluateCommandLet(s, result, tok, curScope);\\n    }\\n    if (!strncmp(cmd, \"add\", cmdLen)) {\\n        return evaluateCommandAdd(s, result, tok, curScope);\\n    }\\n    if (!strncmp(cmd, \"mult\", cmdLen)) {\\n        return evaluateCommandMult(s, result, tok, curScope);\\n    }\\n    return 0;\\n}\\n\\nstatic int evaluateSexp(char **s, int *result, struct token *tok, struct scope **curScope) {\\n    if (!tokenNext(s, tok)) {\\n        return 0;\\n    }\\n    if (tok->type == TOKEN_NAME) {\\n        return evaluateCommand(s, result, tok, curScope);\\n    }\\n    return 0;\\n}\\n\\nstatic int _evaluate(char **s, int *result, struct token *tok, struct scope **curScope) {\\n    struct variable *var;\\n\\n    if (!tokenNext(s, tok)) {\\n        return 0;\\n    }\\n    if (tok->type == TOKEN_END) {\\n\\t\\t*result = 0;\\n        return 1;\\n    }\\n    if (tok->type == TOKEN_SEXP) {\\n        return evaluateSexp(s, result, tok, curScope);\\n    }\\n    if (tok->type == TOKEN_INT) {\\n        *result = tok->val;\\n        return 1;\\n    }\\n    if (tok->type == TOKEN_NAME) {\\n        var = scopeLookup(*curScope, tok->str, tok->len);\\n        if (var == NULL) {\\n            return 0;\\n        }\\n        *result = var->val;\\n        return 1;\\n    }\\n\\n    return 0;\\n}\\n\\n\\nint evaluate(char * expression) {\\n    /* Defining all the needed components. */\\n    struct scope *curScope = NULL;\\n    struct token token;\\n    char *s = expression;\\n    int result = 0;\\n\\n    if (!_evaluate(&s, &result, &token, &curScope)) {\\n        goto error;\\n    }\\n\\n    return result;\\n\\nerror: /* Error case. */\\n    scopeFree(curScope); /* Free the scope chain if not empty */\\n    return -1;\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Linked List",
                    "Recursion"
                ],
                "code": "```c\\n/*\\n *  C solution\\n */\\n\\n\\n/*\\n * Variable stores the start of name with its length and values.\\n * This saves memory because no need to allocate strings.\\n * Also, variable is a node in its scope.\\n */\\nstruct variable {\\n    int val;\\n    int nameLen;\\n    char *name;\\n    struct variable *next;\\n};\\n\\n\\n/*\\n * Scope is a node in the scope chain.\\n */\\nstruct scope {\\n    struct variable *varHead;\\n    struct scope *up;\\n};\\n\\n/*\\n * Space complexity is O(n*m),\\n * where n is the mean count of variables in the scopes,\\n * m is the count of scopes. \\n * Scopes and variables are in singly linked list.\\n */\\n\\n\\nstatic struct variable* scopeLookupLocally(struct scope *s, char *varName, int nameLen) {\\n    struct variable *n;\\n    int cmpLen;\\n    for (n = s->varHead; n != NULL; n = n->next) {\\n        cmpLen = n->nameLen;\\n        cmpLen = (cmpLen < nameLen ? nameLen : cmpLen);\\n        if (!strncmp(varName, n->name, cmpLen)) {\\n            return n;\\n        }\\n    }\\n    return NULL;\\n}\\n\\n/*\\n * Define or redefine a variable in the scope only.\\n * It\\'s O(n) worst case time complexity,\\n * where n is the count of variables in scope.\\n */\\nstatic struct variable* scopeDefineLocally(struct scope *s, char *varName, int nameLen) {\\n    struct variable **n;\\n    int cmpLen;\\n    for (n = &s->varHead; *n != NULL; n = &(*n)->next) {\\n        cmpLen = (*n)->nameLen;\\n        cmpLen = (cmpLen < nameLen ? nameLen : cmpLen);\\n        if (!strncmp(varName, (*n)->name, cmpLen)) {\\n            return *n;\\n        }\\n    }\\n    *n = malloc(sizeof(struct variable));\\n    if (*n == NULL) {\\n        return NULL;\\n    }\\n    (*n)->name = varName;\\n    (*n)->nameLen = nameLen;\\n    (*n)->next = NULL;\\n    return *n;\\n}\\n\\n/*\\n * Look up for the closest variable in all the scope chain.\\n * It\\'s O(n*m) worst case time complexity,\\n * where n is the mean count of variables in the scopes,\\n * m is the count of scopes.\\n */\\nstatic struct variable* scopeLookup(struct scope *s, char *varName, int nameLen) {\\n    struct scope *n;\\n    struct variable *var;\\n    for (n = s; n != NULL; n = n->up) {\\n        var = scopeLookupLocally(n, varName, nameLen);\\n        if (var) {\\n            return var;\\n        }\\n    }\\n    return NULL;\\n}\\n\\nstatic void scopeFreeVariables(struct scope *s) {\\n    struct variable *n, *t;\\n    for (n = s->varHead; n != NULL;) {\\n        t = n;\\n        n = n->next;\\n        free(t);\\n    }\\n    s->varHead = NULL;\\n}\\n\\nstatic void scopeFree(struct scope *s) {\\n    struct scope *n, *t;\\n    for (n = s; n != NULL;) {\\n        t = n;\\n        n = n->up;\\n        scopeFreeVariables(t);\\n        free(t);\\n    }\\n}\\n\\n\\n/*\\n * Append a new scope in the chain.\\n */\\nstatic struct scope* pushScope(struct scope **s) {\\n    struct scope *parent = *s;\\n    *s = malloc(sizeof(struct scope));\\n    if (*s == NULL) {\\n        *s = parent;\\n        return NULL;\\n    }\\n    (*s)->up = parent;\\n    (*s)->varHead = NULL;\\n    return *s;\\n}\\n\\n/*\\n * Remove the current scope in the chain and go up.\\n */\\nstatic struct scope* popScope(struct scope **s) {\\n    struct scope *parent = (*s)->up;\\n    scopeFreeVariables(*s);\\n    free(*s);\\n    return *s = parent;\\n}\\n\\n\\n/*\\n * Parsing with tokens that store their type, string and integer values.\\n * As in variables, the string value is a piece of the expression string.\\n */\\n#define TOKEN_END   0\\n#define TOKEN_INT   1\\n#define TOKEN_NAME  2\\n#define TOKEN_SEXP  3\\n#define TOKEN_CLOSE 4\\nstruct token {\\n    int type;\\n    int len;\\n    int val;\\n    char *str;\\n};\\n\\n\\n/*\\n * Parse the next token and move the string pointer (**s).\\n * Return 0 if a closing parenthesis encounted, otherwise 1 \\n */\\nstatic int tokenNext(char **s, struct token *dst) {\\n    int status = 1, sign;\\n    for (; isspace(**s); ++(*s)) {}\\n    if (**s == \\'\\\\0\\') {\\n        dst->len = 0;\\n        dst->type = TOKEN_END;\\n        return 1;\\n    }\\n    dst->str = *s;\\n    if (isdigit(**s) || **s == \\'-\\' || **s == \\'+\\') {\\n        sign = **s == \\'-\\';\\n        if (**s == \\'-\\' || **s == \\'+\\') {\\n            ++(*s);\\n        }\\n        dst->type = TOKEN_INT;\\n        dst->val = 0;\\n        for (; isdigit(**s); ++(*s)) {\\n            dst->val = dst->val*10 - (**s - \\'0\\');\\n        }\\n        dst->val = (sign ? dst->val : -dst->val);\\n    } else if (isalpha(**s)) {\\n        dst->type = TOKEN_NAME;\\n        for (; isalnum(**s); ++(*s)) {}\\n    } else if (**s == \\'(\\') {\\n        dst->type = TOKEN_SEXP;\\n        ++(*s);\\n    } else if (**s == \\')\\') {\\n        status = 0;\\n        dst->type = TOKEN_CLOSE;\\n        ++(*s);\\n    }\\n\\n    dst->len = *s - dst->str;\\n    return status;\\n}\\n\\n/*\\n * Evaluation part.\\n * This is recursive the \\'_evaluate\\' function calling its subroutines.\\n * The function saves the result in the pointer.\\n * In case of error, the function returns zero.\\n */\\n\\nstatic int _evaluate(char **s, int *result, struct token *tok, struct scope **curScope);\\n\\nstatic int evaluateCommandLet(char **s, int *result, struct token *tok, struct scope **curScope) {\\n    struct variable *var;\\n    char *oldPos, *varName;\\n    int varNameLen;\\n    int varVal;\\n    if (pushScope(curScope) == NULL) {\\n        return 0;\\n    }\\n    for (;;) { /* Defining variables while it\\'s possible. */\\n        oldPos = *s;\\n        if (!tokenNext(s, tok)) {\\n            return 0;\\n        }\\n        if (tok->type == TOKEN_NAME) {\\n            varName = tok->str;\\n            varNameLen = tok->len;\\n            if (!_evaluate(s, &varVal, tok, curScope)) {\\n                *s = oldPos;\\n                break;\\n            }\\n            var = scopeDefineLocally(*curScope, varName, varNameLen);\\n            if (var == NULL) {\\n                return 0;\\n            }\\n            var->val = varVal;\\n        } else {\\n            *s = oldPos;\\n            break;\\n        }\\n    }\\n    /* Evaluate the trailing part. */\\n    if (!_evaluate(s, result, tok, curScope)) {\\n        return 0;\\n    }\\n    if (tokenNext(s, tok)) { /* Skip a closing parenthesis */\\n        return 0;\\n    }\\n    popScope(curScope);\\n    return 1;\\n}\\n\\nstatic int evaluateCommandAdd(char **s, int *result, struct token *tok, struct scope **curScope) {\\n    int op1, op2;\\n    if (!_evaluate(s, &op1, tok, curScope)) {\\n        return 0;\\n    }\\n    if (!_evaluate(s, &op2, tok, curScope)) {\\n        return 0;\\n    }\\n    *result = op1 + op2;\\n    if (tokenNext(s, tok)) { /* Skip a closing parenthesis */\\n        return 0;\\n    }\\n    return 1;\\n}\\n\\nstatic int evaluateCommandMult(char **s, int *result, struct token *tok, struct scope **curScope) {\\n    int op1, op2;\\n    if (!_evaluate(s, &op1, tok, curScope)) {\\n        return 0;\\n    }\\n    if (!_evaluate(s, &op2, tok, curScope)) {\\n        return 0;\\n    }\\n    *result = op1*op2;\\n    if (tokenNext(s, tok)) {/* Skip a closing parenthesis */\\n        return 0;\\n    }\\n    return 1;\\n}\\n\\n/*\\n * Evaluate a command in the sexp.\\n * Simple searching for commands with strncmp.\\n */\\nstatic int evaluateCommand(char **s, int *result, struct token *tok, struct scope **curScope) {\\n    char *cmd = tok->str;\\n    int cmdLen = tok->len;\\n\\n    if (!strncmp(cmd, \"let\", cmdLen)) {\\n        return evaluateCommandLet(s, result, tok, curScope);\\n    }\\n    if (!strncmp(cmd, \"add\", cmdLen)) {\\n        return evaluateCommandAdd(s, result, tok, curScope);\\n    }\\n    if (!strncmp(cmd, \"mult\", cmdLen)) {\\n        return evaluateCommandMult(s, result, tok, curScope);\\n    }\\n    return 0;\\n}\\n\\nstatic int evaluateSexp(char **s, int *result, struct token *tok, struct scope **curScope) {\\n    if (!tokenNext(s, tok)) {\\n        return 0;\\n    }\\n    if (tok->type == TOKEN_NAME) {\\n        return evaluateCommand(s, result, tok, curScope);\\n    }\\n    return 0;\\n}\\n\\nstatic int _evaluate(char **s, int *result, struct token *tok, struct scope **curScope) {\\n    struct variable *var;\\n\\n    if (!tokenNext(s, tok)) {\\n        return 0;\\n    }\\n    if (tok->type == TOKEN_END) {\\n\\t\\t*result = 0;\\n        return 1;\\n    }\\n    if (tok->type == TOKEN_SEXP) {\\n        return evaluateSexp(s, result, tok, curScope);\\n    }\\n    if (tok->type == TOKEN_INT) {\\n        *result = tok->val;\\n        return 1;\\n    }\\n    if (tok->type == TOKEN_NAME) {\\n        var = scopeLookup(*curScope, tok->str, tok->len);\\n        if (var == NULL) {\\n            return 0;\\n        }\\n        *result = var->val;\\n        return 1;\\n    }\\n\\n    return 0;\\n}\\n\\n\\nint evaluate(char * expression) {\\n    /* Defining all the needed components. */\\n    struct scope *curScope = NULL;\\n    struct token token;\\n    char *s = expression;\\n    int result = 0;\\n\\n    if (!_evaluate(&s, &result, &token, &curScope)) {\\n        goto error;\\n    }\\n\\n    return result;\\n\\nerror: /* Error case. */\\n    scopeFree(curScope); /* Free the scope chain if not empty */\\n    return -1;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1607848,
                "title": "racket-solution",
                "content": "```scheme\\n(define (evaluate expression)\\n  (define expr (parse expression))\\n  ;; Store map of symbol -> value.\\n  ;; Recursion will naturally take care of scope.\\n  (define (eval-recur expr table)\\n    (match expr\\n      [(? integer? x) x]\\n      [(? symbol? s) (hash-ref table s)]\\n      [(list \\'add x y) (+ (eval-recur x table) (eval-recur y table))]\\n      [(list \\'mult x y) (* (eval-recur x table) (eval-recur y table))]\\n      [(list \\'let binds ... expr)\\n       (for/fold ([table table]\\n                  #:result (eval-recur expr table))\\n                 ([pair (in-slice 2 (in-list binds))])\\n         (hash-set table\\n                   (first pair)\\n                   (eval-recur (second pair) table)))]))\\n  (eval-recur expr #hasheq()))\\n  \\n;; Handrolled parser.\\n(define (parse str)\\n  (define tokens (regexp-match* #px\"\\\\\\\\(|\\\\\\\\)|-?\\\\\\\\d+|\\\\\\\\w[\\\\\\\\w\\\\\\\\d]*\" str))\\n  (define (parse-atom str) (or (string->number str) (string->symbol str)))\\n  (define (parse-seq tokens)\\n    (let loop ([seq \\'()]\\n               [tokens tokens])\\n      (cond [(string=? \")\" (car tokens)) (values (reverse seq) (cdr tokens))]\\n            [else (let-values ([(expr tokens) (parse-expr tokens)])\\n                    (loop (cons expr seq) tokens))])))\\n  (define (parse-expr tokens)\\n    (cond [(string=? \"(\" (car tokens)) (parse-seq (cdr tokens))]\\n          [else (values (parse-atom (car tokens)) (cdr tokens))]))\\n  (let-values ([(expr _tokens) (parse-expr tokens)]) expr))\\n```",
                "solutionTags": [],
                "code": "```scheme\\n(define (evaluate expression)\\n  (define expr (parse expression))\\n  ;; Store map of symbol -> value.\\n  ;; Recursion will naturally take care of scope.\\n  (define (eval-recur expr table)\\n    (match expr\\n      [(? integer? x) x]\\n      [(? symbol? s) (hash-ref table s)]\\n      [(list \\'add x y) (+ (eval-recur x table) (eval-recur y table))]\\n      [(list \\'mult x y) (* (eval-recur x table) (eval-recur y table))]\\n      [(list \\'let binds ... expr)\\n       (for/fold ([table table]\\n                  #:result (eval-recur expr table))\\n                 ([pair (in-slice 2 (in-list binds))])\\n         (hash-set table\\n                   (first pair)\\n                   (eval-recur (second pair) table)))]))\\n  (eval-recur expr #hasheq()))\\n  \\n;; Handrolled parser.\\n(define (parse str)\\n  (define tokens (regexp-match* #px\"\\\\\\\\(|\\\\\\\\)|-?\\\\\\\\d+|\\\\\\\\w[\\\\\\\\w\\\\\\\\d]*\" str))\\n  (define (parse-atom str) (or (string->number str) (string->symbol str)))\\n  (define (parse-seq tokens)\\n    (let loop ([seq \\'()]\\n               [tokens tokens])\\n      (cond [(string=? \")\" (car tokens)) (values (reverse seq) (cdr tokens))]\\n            [else (let-values ([(expr tokens) (parse-expr tokens)])\\n                    (loop (cons expr seq) tokens))])))\\n  (define (parse-expr tokens)\\n    (cond [(string=? \"(\" (car tokens)) (parse-seq (cdr tokens))]\\n          [else (values (parse-atom (car tokens)) (cdr tokens))]))\\n  (let-values ([(expr _tokens) (parse-expr tokens)]) expr))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1589296,
                "title": "java-simple-and-clean-solution-recursive-descent",
                "content": "# Grammar\\n\\n```text\\n+ := one or more\\n? := optional\\n| := alternative\\n\\nGRAMMAR\\n  \\n  expr        := group | integer | assignedVar\\n\\n  group       := \"(\" (let | add | mult) \")\"\\n\\n  let         := \"let \" (var \" \" expr \" \")+ expr\\n\\n  add         := \"add \" expr \" \" expr\\n\\n  mult        := \"mult \" expr \" \" expr\\n\\n  assignedVar := var\\n\\n  var         := lowercase (lowercase | digit)+\\n  \\n  integer     := \"-\"? digit+\\n\\n  digit       := \"0\" ... \"9\"\\n\\n  lowercase   := \"a\" ... \"z\"\\n```\\n\\n# Implementation\\n\\n```java\\nclass Solution {\\n  private String source;\\n  private int index;\\n  private List<Map<String, Integer>> scopes;\\n\\n  public int evaluate(String expression) {\\n    this.source = expression;\\n    this.index = 0;\\n    this.scopes = new ArrayList<>();\\n\\n    return expr();\\n  }\\n\\n  private int expr() {\\n    if (match(\\'(\\')) {\\n      return group();\\n    } else {\\n      if (isLowerCase(peek())) {\\n        return assignedVar();\\n      } else {\\n        return integer();\\n      }\\n    }\\n  }\\n\\n  private int group() {\\n    consume(\\'(\\', \"Expect \\'(\\'\");\\n    int res = 0;\\n\\n    if (match(\\'l\\')) {\\n      res = let();\\n    } else if (match(\\'a\\')) {\\n      res = add();\\n    } else {\\n      res = mult();\\n    }\\n\\n    consume(\\')\\', \"Expect \\')\\'\");\\n    return res;\\n  }\\n\\n  private int let() {\\n    consume(\"let \", \"Expect \\'let \\'\");\\n\\n    Map<String, Integer> scope = new HashMap<>();\\n    pushScope(scope);\\n\\n    while (isLowerCase(peek())) {\\n      String varname = var();\\n\\n      if (match(\\' \\')) {\\n        advance();\\n      } else {\\n        int res = assignedVar(varname);\\n        popScope();\\n        return res;\\n      }\\n\\n      scope.put(varname, expr());\\n      \\n      if (match(\\' \\')) advance();\\n    }\\n    \\n    int res = expr();\\n\\n    popScope();\\n\\n    return res;\\n  }\\n\\n  private int add() {\\n    consume(\"add \", \"Expect \\'add \\'\");\\n\\n    int expr1 = expr();\\n    consume(\\' \\', \"Expect \\' \\'\");\\n    int expr2 = expr();\\n\\n    return expr1 + expr2;\\n  }\\n\\n  private int mult() {\\n    consume(\"mult \", \"Expect \\'mult \\'\");\\n\\n    int expr1 = expr();\\n    consume(\\' \\', \"Expect \\' \\'\");\\n    int expr2 = expr();\\n\\n    return expr1 * expr2;\\n  }\\n\\n  private int assignedVar() {\\n    String varname = var();\\n    return assignedVar(varname);\\n  }\\n\\n  private int assignedVar(String varname) {\\n    for (int i = scopes.size() - 1; i >= 0; i--) {\\n      if (scopes.get(i).containsKey(varname)) {\\n        return scopes.get(i).get(varname);\\n      }\\n    }\\n\\n    // illegal state\\n    return Integer.MIN_VALUE;\\n  }\\n\\n  private String var() {\\n    StringBuilder builder = new StringBuilder();\\n    while (isLowerCase(peek()) || isDigit(peek())) {\\n      builder.append(peek());\\n      advance();\\n    }\\n\\n    return builder.toString();\\n  }\\n\\n  private int integer() {\\n    int sign = 1;\\n    if (match(\\'-\\')) {\\n      advance();\\n      sign = -1;\\n    }\\n\\n    int num = 0;\\n    while (isDigit(peek())) {\\n      num = num * 10 + (peek() - \\'0\\');\\n      advance();\\n    }\\n\\n    return sign * num;\\n  }\\n\\n  private void pushScope(Map<String, Integer> scope) {\\n    scopes.add(scope);\\n  }\\n\\n  private void popScope() {\\n    scopes.remove(scopes.size() - 1);\\n  }\\n\\n  private boolean isDigit(char ch) {\\n    return ch >= \\'0\\' && ch <= \\'9\\';\\n  }\\n\\n  private boolean isLowerCase(char ch) {\\n    return ch >= \\'a\\' && ch <= \\'z\\';\\n  }\\n\\n  private boolean isAtEnd() {\\n    return index >= source.length();\\n  }\\n\\n  private void advance() {\\n    if (isAtEnd()) return;\\n\\n    index++;\\n  }\\n\\n  private char peek() {\\n    return source.charAt(index);\\n  }\\n\\n  private boolean match(char ch) {\\n    if (isAtEnd()) return false;\\n\\n    return peek() == ch;\\n  }\\n\\n  private void consume(char ch, String message) {\\n    if (!match(ch)) {\\n      System.out.println(message);\\n    }\\n\\n    advance();\\n  }\\n\\n  private void consume(String s, String message) {\\n    for (int i = 0; i < s.length(); i++) {\\n      consume(s.charAt(i), message);\\n    }\\n  }\\n}\\n```\\n\\n# See also\\n- [1106. Parsing A Boolean Expression](https://leetcode.com/problems/parsing-a-boolean-expression/) --- *[my solution](https://leetcode.com/problems/parsing-a-boolean-expression/discuss/1588916/JAVA-Simple-and-Clean-Solution-(Recursive-Descent))*",
                "solutionTags": [],
                "code": "```text\\n+ := one or more\\n? := optional\\n| := alternative\\n\\nGRAMMAR\\n  \\n  expr        := group | integer | assignedVar\\n\\n  group       := \"(\" (let | add | mult) \")\"\\n\\n  let         := \"let \" (var \" \" expr \" \")+ expr\\n\\n  add         := \"add \" expr \" \" expr\\n\\n  mult        := \"mult \" expr \" \" expr\\n\\n  assignedVar := var\\n\\n  var         := lowercase (lowercase | digit)+\\n  \\n  integer     := \"-\"? digit+\\n\\n  digit       := \"0\" ... \"9\"\\n\\n  lowercase   := \"a\" ... \"z\"\\n```\n```java\\nclass Solution {\\n  private String source;\\n  private int index;\\n  private List<Map<String, Integer>> scopes;\\n\\n  public int evaluate(String expression) {\\n    this.source = expression;\\n    this.index = 0;\\n    this.scopes = new ArrayList<>();\\n\\n    return expr();\\n  }\\n\\n  private int expr() {\\n    if (match(\\'(\\')) {\\n      return group();\\n    } else {\\n      if (isLowerCase(peek())) {\\n        return assignedVar();\\n      } else {\\n        return integer();\\n      }\\n    }\\n  }\\n\\n  private int group() {\\n    consume(\\'(\\', \"Expect \\'(\\'\");\\n    int res = 0;\\n\\n    if (match(\\'l\\')) {\\n      res = let();\\n    } else if (match(\\'a\\')) {\\n      res = add();\\n    } else {\\n      res = mult();\\n    }\\n\\n    consume(\\')\\', \"Expect \\')\\'\");\\n    return res;\\n  }\\n\\n  private int let() {\\n    consume(\"let \", \"Expect \\'let \\'\");\\n\\n    Map<String, Integer> scope = new HashMap<>();\\n    pushScope(scope);\\n\\n    while (isLowerCase(peek())) {\\n      String varname = var();\\n\\n      if (match(\\' \\')) {\\n        advance();\\n      } else {\\n        int res = assignedVar(varname);\\n        popScope();\\n        return res;\\n      }\\n\\n      scope.put(varname, expr());\\n      \\n      if (match(\\' \\')) advance();\\n    }\\n    \\n    int res = expr();\\n\\n    popScope();\\n\\n    return res;\\n  }\\n\\n  private int add() {\\n    consume(\"add \", \"Expect \\'add \\'\");\\n\\n    int expr1 = expr();\\n    consume(\\' \\', \"Expect \\' \\'\");\\n    int expr2 = expr();\\n\\n    return expr1 + expr2;\\n  }\\n\\n  private int mult() {\\n    consume(\"mult \", \"Expect \\'mult \\'\");\\n\\n    int expr1 = expr();\\n    consume(\\' \\', \"Expect \\' \\'\");\\n    int expr2 = expr();\\n\\n    return expr1 * expr2;\\n  }\\n\\n  private int assignedVar() {\\n    String varname = var();\\n    return assignedVar(varname);\\n  }\\n\\n  private int assignedVar(String varname) {\\n    for (int i = scopes.size() - 1; i >= 0; i--) {\\n      if (scopes.get(i).containsKey(varname)) {\\n        return scopes.get(i).get(varname);\\n      }\\n    }\\n\\n    // illegal state\\n    return Integer.MIN_VALUE;\\n  }\\n\\n  private String var() {\\n    StringBuilder builder = new StringBuilder();\\n    while (isLowerCase(peek()) || isDigit(peek())) {\\n      builder.append(peek());\\n      advance();\\n    }\\n\\n    return builder.toString();\\n  }\\n\\n  private int integer() {\\n    int sign = 1;\\n    if (match(\\'-\\')) {\\n      advance();\\n      sign = -1;\\n    }\\n\\n    int num = 0;\\n    while (isDigit(peek())) {\\n      num = num * 10 + (peek() - \\'0\\');\\n      advance();\\n    }\\n\\n    return sign * num;\\n  }\\n\\n  private void pushScope(Map<String, Integer> scope) {\\n    scopes.add(scope);\\n  }\\n\\n  private void popScope() {\\n    scopes.remove(scopes.size() - 1);\\n  }\\n\\n  private boolean isDigit(char ch) {\\n    return ch >= \\'0\\' && ch <= \\'9\\';\\n  }\\n\\n  private boolean isLowerCase(char ch) {\\n    return ch >= \\'a\\' && ch <= \\'z\\';\\n  }\\n\\n  private boolean isAtEnd() {\\n    return index >= source.length();\\n  }\\n\\n  private void advance() {\\n    if (isAtEnd()) return;\\n\\n    index++;\\n  }\\n\\n  private char peek() {\\n    return source.charAt(index);\\n  }\\n\\n  private boolean match(char ch) {\\n    if (isAtEnd()) return false;\\n\\n    return peek() == ch;\\n  }\\n\\n  private void consume(char ch, String message) {\\n    if (!match(ch)) {\\n      System.out.println(message);\\n    }\\n\\n    advance();\\n  }\\n\\n  private void consume(String s, String message) {\\n    for (int i = 0; i < s.length(); i++) {\\n      consume(s.charAt(i), message);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1580582,
                "title": "clean-python-recursive-descent-parser",
                "content": "Workflow for similar problems:\\n1. write a tokenizer and implement peek, nxt (sometimes peekTwo)\\n2. helper function with required arguments\\n3. switch different literals based on the first X token(s)\\n4. implement each literal with heart and endeavour\\n\\n```\\nclass Tokenizer(object):\\n    def __init__(self, s:str):\\n        self.s = s\\n        self.i = 0\\n        self.patterns = [\\n            (\"bracket\", \"^[()]\"),\\n            (\"number\", \"^[-]?\\\\d+\"),\\n            (\"operator\", \"^let|^add|^mult\"),\\n            (\"var\", \"[a-z]+[0-9]*\"),\\n            (\"space\", \"^[ ]+\"),\\n        ]\\n    \\n    def _next(self):\\n        if self.i == len(self.s):\\n            return None\\n        for patternType, pattern in self.patterns:\\n            match = re.match(pattern, self.s[self.i:])\\n            if match:\\n                return (patternType, match.group(0))\\n        raise Exception(\"unknown token\", self.s[self.i:])\\n    \\n    def peek(self):\\n        token = self._next()\\n        while token and token[0] == \"space\":\\n            self.i += len(token[1])\\n            token = self._next()\\n        \\n        return token\\n\\n    def nxt(self):\\n        token = self.peek()\\n        self.i += len(token[1])\\n        return token\\n    \\n    def peekTwo(self):\\n        i = self.i\\n        one = self.nxt()\\n        if not one:\\n            raise Exception(\"cannot nxtTwo, first one missing\")\\n        \\n        two = self.nxt()\\n        if not two:\\n            raise Exception(\"cannot nxtTwo, second one missing\")\\n        \\n        self.i = i\\n        return one, two\\n        \\n        \\n    def expect(self, tokenType, tokenValue=None):\\n        token = self.nxt()\\n        if not token or token[0] != tokenType:\\n            raise Exception(\"expect token type\", tokenType, \"but get token\", token)\\n        if tokenValue and token[1] != tokenValue:\\n            raise Exception(\"expect token value\", tokenValue, \"but get token\", token)\\n        return token\\n\\nclass Solution:\\n    \\n    def evaluate(self, expression: str) -> int:\\n\\n        def numberLiteral(t, var):\\n            token = t.expect(\"number\")\\n            return int(token[1])\\n        \\n        def varLiteral(t, var):\\n            token = t.expect(\"var\")\\n            if token[1] not in var:\\n                raise Exception(\"unknown var\", token[1], var)\\n            return var[token[1]]\\n        \\n        def expressionLiteral(t, var):\\n            var = copy.copy(var) # new context\\n            t.expect(\"bracket\", \"(\")\\n            _, operator = t.expect(\"operator\")\\n            if operator in [\"add\", \"mult\"]:\\n                num1 = interpret(t, var)\\n                num2 = interpret(t, var)\\n                t.expect(\"bracket\", \")\")\\n                return num1+num2 if operator == \"add\" else num1*num2\\n            elif operator == \"let\":\\n                one, two = t.peekTwo()\\n                while one[0] == \"var\" and two != (\"bracket\", \")\"): # assign\\n                    # print(one, two)\\n                    t.nxt() # consume var\\n                    var[one[1]] = interpret(t, var)\\n                    one, two = t.peekTwo()\\n\\n                res = interpret(t, var)\\n                t.expect(\"bracket\", \")\")\\n\\n            else:\\n                raise Exception(\"unknown operator\", operator)\\n\\n            return res\\n        \\n        def interpret(t, var) -> int:\\n            # print(\"vars\", var)\\n            token = t.peek()\\n            if not token:\\n                raise Exception(\"interpret empty\")\\n                \\n            if token[0] == \"number\":\\n                return numberLiteral(t, var)\\n            \\n            if token[0] == \"var\":\\n                return varLiteral(t, var)\\n            \\n            if token == (\"bracket\", \"(\"): # expression\\n                return expressionLiteral(t, var)\\n            \\n            raise Exception(\"don\\'t know how to interpret\", t, \"starting with token\", token)\\n        \\n        t = Tokenizer(expression)\\n        return interpret(t, {})\\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Tokenizer(object):\\n    def __init__(self, s:str):\\n        self.s = s\\n        self.i = 0\\n        self.patterns = [\\n            (\"bracket\", \"^[()]\"),\\n            (\"number\", \"^[-]?\\\\d+\"),\\n            (\"operator\", \"^let|^add|^mult\"),\\n            (\"var\", \"[a-z]+[0-9]*\"),\\n            (\"space\", \"^[ ]+\"),\\n        ]\\n    \\n    def _next(self):\\n        if self.i == len(self.s):\\n            return None\\n        for patternType, pattern in self.patterns:\\n            match = re.match(pattern, self.s[self.i:])\\n            if match:\\n                return (patternType, match.group(0))\\n        raise Exception(\"unknown token\", self.s[self.i:])\\n    \\n    def peek(self):\\n        token = self._next()\\n        while token and token[0] == \"space\":\\n            self.i += len(token[1])\\n            token = self._next()\\n        \\n        return token\\n\\n    def nxt(self):\\n        token = self.peek()\\n        self.i += len(token[1])\\n        return token\\n    \\n    def peekTwo(self):\\n        i = self.i\\n        one = self.nxt()\\n        if not one:\\n            raise Exception(\"cannot nxtTwo, first one missing\")\\n        \\n        two = self.nxt()\\n        if not two:\\n            raise Exception(\"cannot nxtTwo, second one missing\")\\n        \\n        self.i = i\\n        return one, two\\n        \\n        \\n    def expect(self, tokenType, tokenValue=None):\\n        token = self.nxt()\\n        if not token or token[0] != tokenType:\\n            raise Exception(\"expect token type\", tokenType, \"but get token\", token)\\n        if tokenValue and token[1] != tokenValue:\\n            raise Exception(\"expect token value\", tokenValue, \"but get token\", token)\\n        return token\\n\\nclass Solution:\\n    \\n    def evaluate(self, expression: str) -> int:\\n\\n        def numberLiteral(t, var):\\n            token = t.expect(\"number\")\\n            return int(token[1])\\n        \\n        def varLiteral(t, var):\\n            token = t.expect(\"var\")\\n            if token[1] not in var:\\n                raise Exception(\"unknown var\", token[1], var)\\n            return var[token[1]]\\n        \\n        def expressionLiteral(t, var):\\n            var = copy.copy(var) # new context\\n            t.expect(\"bracket\", \"(\")\\n            _, operator = t.expect(\"operator\")\\n            if operator in [\"add\", \"mult\"]:\\n                num1 = interpret(t, var)\\n                num2 = interpret(t, var)\\n                t.expect(\"bracket\", \")\")\\n                return num1+num2 if operator == \"add\" else num1*num2\\n            elif operator == \"let\":\\n                one, two = t.peekTwo()\\n                while one[0] == \"var\" and two != (\"bracket\", \")\"): # assign\\n                    # print(one, two)\\n                    t.nxt() # consume var\\n                    var[one[1]] = interpret(t, var)\\n                    one, two = t.peekTwo()\\n\\n                res = interpret(t, var)\\n                t.expect(\"bracket\", \")\")\\n\\n            else:\\n                raise Exception(\"unknown operator\", operator)\\n\\n            return res\\n        \\n        def interpret(t, var) -> int:\\n            # print(\"vars\", var)\\n            token = t.peek()\\n            if not token:\\n                raise Exception(\"interpret empty\")\\n                \\n            if token[0] == \"number\":\\n                return numberLiteral(t, var)\\n            \\n            if token[0] == \"var\":\\n                return varLiteral(t, var)\\n            \\n            if token == (\"bracket\", \"(\"): # expression\\n                return expressionLiteral(t, var)\\n            \\n            raise Exception(\"don\\'t know how to interpret\", t, \"starting with token\", token)\\n        \\n        t = Tokenizer(expression)\\n        return interpret(t, {})\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1578119,
                "title": "simple-and-fun-ruby-solution-beats-100",
                "content": "```\\ndef evaluate(expr)\\n  f = -> a,h=({}){op,*args=a\\n    reduce = ->op{args.map{|x|f[x, h]}.reduce op}\\n    op[ \\'add\\'] ? reduce[:+] :\\n    op[\\'mult\\'] ? reduce[:*] :\\n    op[ \\'let\\'] ? h.clone.tap{|h|args.each_slice(2){|t|h[t[-2]] = f[t[-1], h]}}[nil] :\\n    a[/^-?\\\\d+$/] ? a.to_i : h[a]}\\n  f[eval expr.gsub(?(,?[).gsub(?),\\'],\\').gsub(/-?\\\\w+/){\"\\'#$&\\',\"}[0..-2]]\\nend\\n```",
                "solutionTags": [],
                "code": "```\\ndef evaluate(expr)\\n  f = -> a,h=({}){op,*args=a\\n    reduce = ->op{args.map{|x|f[x, h]}.reduce op}\\n    op[ \\'add\\'] ? reduce[:+] :\\n    op[\\'mult\\'] ? reduce[:*] :\\n    op[ \\'let\\'] ? h.clone.tap{|h|args.each_slice(2){|t|h[t[-2]] = f[t[-1], h]}}[nil] :\\n    a[/^-?\\\\d+$/] ? a.to_i : h[a]}\\n  f[eval expr.gsub(?(,?[).gsub(?),\\'],\\').gsub(/-?\\\\w+/){\"\\'#$&\\',\"}[0..-2]]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1488213,
                "title": "python-using-recursion",
                "content": "```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        if not expression:\\n            return -1\\n\\n        value, _ = self.recursive(expression, 0, 0, {})\\n        return value\\n\\n    def recursive(self, expression, start=0, end=0, dictionary={}):\\n        temp_str = \\'\\'\\n        while end < len(expression):\\n            if expression[end] == \\'(\\' and start != end:\\n                dict_ = self.parse_previous(temp_str, dictionary)\\n                value, end = self.recursive(expression, end, end, dict_)\\n                temp_str += str(value)\\n            elif expression[end] == \\')\\':\\n                temp_str += expression[end]\\n                return self.evaluate_expression(temp_str, end, dictionary)\\n            else:\\n                temp_str += expression[end]\\n\\n            end += 1\\n\\n    def parse_previous(self, str_, dictionary):\\n        split_expression = str_[1:-1].split(\\' \\')\\n        if split_expression[0] == \\'let\\':\\n            cnt = 1\\n            temp_dict = dictionary.copy()\\n            prev_var = None\\n            while cnt < len(split_expression):\\n                if split_expression[cnt][0].isalpha():\\n                    temp_dict[split_expression[cnt]] = temp_dict.get(split_expression[cnt], 0)\\n                    prev_var = split_expression[cnt]\\n                else:\\n                    temp_dict[prev_var] = split_expression[cnt]\\n                    prev_var = None\\n                cnt += 1\\n            return temp_dict\\n        else:\\n            return dictionary\\n\\n    def evaluate_expression(self, str_, end, dictionary):\\n        split_expression = str_[1:-1].split(\\' \\')\\n        if split_expression[0] == \\'let\\':\\n            cnt = 1\\n            temp_dict = {}\\n            prev_var = None\\n            last_seen = None\\n            while cnt < len(split_expression):\\n                if split_expression[cnt][0].isalpha():\\n                    temp_dict[split_expression[cnt]] = temp_dict.get(split_expression[cnt], 0)\\n                    prev_var = split_expression[cnt]\\n                else:\\n                    temp_dict[prev_var] = split_expression[cnt]\\n                    last_seen = prev_var\\n                    prev_var = None\\n                cnt += 1\\n\\n            if split_expression[cnt-1][0].isalpha():\\n                return temp_dict[last_seen], end\\n            else:\\n                return int(split_expression[cnt-1]), end\\n        else:\\n\\n            if split_expression[1][0].isalpha():\\n                var1 = int(dictionary.get(split_expression[1], 0))\\n            else:\\n                var1 = int(split_expression[1])\\n\\n            if split_expression[2][0].isalpha():\\n                var2 = int(dictionary.get(split_expression[2], 0))\\n            else:\\n                var2 = int(split_expression[2])\\n\\n            if split_expression[0] == \\'mult\\':\\n                return (var1 * var2), end\\n            else:\\n                return (var1 + var2), end\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        if not expression:\\n            return -1\\n\\n        value, _ = self.recursive(expression, 0, 0, {})\\n        return value\\n\\n    def recursive(self, expression, start=0, end=0, dictionary={}):\\n        temp_str = \\'\\'\\n        while end < len(expression):\\n            if expression[end] == \\'(\\' and start != end:\\n                dict_ = self.parse_previous(temp_str, dictionary)\\n                value, end = self.recursive(expression, end, end, dict_)\\n                temp_str += str(value)\\n            elif expression[end] == \\')\\':\\n                temp_str += expression[end]\\n                return self.evaluate_expression(temp_str, end, dictionary)\\n            else:\\n                temp_str += expression[end]\\n\\n            end += 1\\n\\n    def parse_previous(self, str_, dictionary):\\n        split_expression = str_[1:-1].split(\\' \\')\\n        if split_expression[0] == \\'let\\':\\n            cnt = 1\\n            temp_dict = dictionary.copy()\\n            prev_var = None\\n            while cnt < len(split_expression):\\n                if split_expression[cnt][0].isalpha():\\n                    temp_dict[split_expression[cnt]] = temp_dict.get(split_expression[cnt], 0)\\n                    prev_var = split_expression[cnt]\\n                else:\\n                    temp_dict[prev_var] = split_expression[cnt]\\n                    prev_var = None\\n                cnt += 1\\n            return temp_dict\\n        else:\\n            return dictionary\\n\\n    def evaluate_expression(self, str_, end, dictionary):\\n        split_expression = str_[1:-1].split(\\' \\')\\n        if split_expression[0] == \\'let\\':\\n            cnt = 1\\n            temp_dict = {}\\n            prev_var = None\\n            last_seen = None\\n            while cnt < len(split_expression):\\n                if split_expression[cnt][0].isalpha():\\n                    temp_dict[split_expression[cnt]] = temp_dict.get(split_expression[cnt], 0)\\n                    prev_var = split_expression[cnt]\\n                else:\\n                    temp_dict[prev_var] = split_expression[cnt]\\n                    last_seen = prev_var\\n                    prev_var = None\\n                cnt += 1\\n\\n            if split_expression[cnt-1][0].isalpha():\\n                return temp_dict[last_seen], end\\n            else:\\n                return int(split_expression[cnt-1]), end\\n        else:\\n\\n            if split_expression[1][0].isalpha():\\n                var1 = int(dictionary.get(split_expression[1], 0))\\n            else:\\n                var1 = int(split_expression[1])\\n\\n            if split_expression[2][0].isalpha():\\n                var2 = int(dictionary.get(split_expression[2], 0))\\n            else:\\n                var2 = int(split_expression[2])\\n\\n            if split_expression[0] == \\'mult\\':\\n                return (var1 * var2), end\\n            else:\\n                return (var1 + var2), end\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1441915,
                "title": "c-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    class Operation {\\n    public:\\n        Operation(\\n            unordered_map<string, int> const& vars)\\n            : _vars(vars) {\\n            }\\n        \\n        virtual int Evaluate() const = 0;\\n        \\n    protected:\\n        unordered_map<string, int> _vars;\\n    };\\n    \\n    class AddOperation : public Operation {\\n    public:\\n        AddOperation(\\n            unordered_map<string, int> const& vars,\\n            unique_ptr<Operation> oper1,\\n            unique_ptr<Operation> oper2)\\n            : Operation(vars)\\n            , _oper1(move(oper1))\\n            , _oper2(move(oper2)) {\\n            }\\n        \\n        virtual int Evaluate() const {\\n            return _oper1->Evaluate() + _oper2->Evaluate();\\n        }\\n        \\n    private:\\n        unique_ptr<Operation> _oper1;\\n        unique_ptr<Operation> _oper2;\\n    };\\n    \\n    class MultOperation : public Operation {\\n    public:\\n        MultOperation(\\n            unordered_map<string, int> const& vars,\\n            unique_ptr<Operation> oper1,\\n            unique_ptr<Operation> oper2)\\n            : Operation(vars)\\n            , _oper1(move(oper1))\\n            , _oper2(move(oper2)) {\\n            }\\n        \\n        virtual int Evaluate() const {\\n            return _oper1->Evaluate() * _oper2->Evaluate();\\n        }\\n        \\n    private:\\n        unique_ptr<Operation> _oper1;\\n        unique_ptr<Operation> _oper2;\\n    };\\n    \\n    class LetOperation : public Operation {\\n    public:\\n        LetOperation(\\n            unordered_map<string, int> const& vars,\\n            unique_ptr<Operation> oper)\\n            : Operation(vars)\\n            , _oper(move(oper)){\\n            }\\n        \\n        virtual int Evaluate() const {\\n            return _oper->Evaluate();\\n        }\\n                   \\n    private:\\n        unique_ptr<Operation> _oper;\\n    };\\n    \\n    class VarOperation : public Operation {\\n    public:\\n        VarOperation(\\n            unordered_map<string, int> const& vars,\\n            string const& varName)\\n            : Operation(vars)\\n            , _varName(varName) {\\n            }\\n        \\n        virtual int Evaluate() const {\\n            return _vars.at(_varName);\\n        }\\n        \\n    private:\\n        string _varName;\\n    };\\n    \\n    class NoOperation : public Operation {\\n    public:\\n        NoOperation(\\n            unordered_map<string, int> const& vars,\\n            int val)\\n            : Operation(vars)\\n            , _val(val) {\\n            }\\n        \\n        virtual int Evaluate() const {\\n            return _val;\\n        }\\n        \\n    private:\\n        int _val;\\n    };\\n    \\n    int evaluate(string expression) {\\n        if (expression.empty()) {\\n            return 0;\\n        }\\n        \\n        unordered_map<string, int> emptVars;\\n        auto op = ReadOperation(expression, emptVars);\\n        return op->Evaluate();\\n    }\\n    \\n    unique_ptr<Operation> ReadOperation(\\n        string const& expr, \\n        unordered_map<string, int> const& vars) {\\n        if (expr.rfind(\"(let\", 0) == 0) {\\n            unordered_map<string, int> allVars(vars);\\n            auto splits = splitstr(expr.substr(5, expr.size()-6));\\n            for (int i=0; i<splits.size()-1; i+=2) {\\n                allVars[splits[i]] =\\n                    ReadOperation(\\n                        splits[i+1], \\n                        allVars)->Evaluate();\\n            }\\n            return make_unique<LetOperation>(\\n                allVars, \\n                ReadOperation(splits[splits.size()-1], allVars));\\n            \\n        } else if (expr.rfind(\"(add\", 0) == 0) {\\n            auto splits = splitstr(expr.substr(5, expr.size()-6));\\n            return make_unique<AddOperation>(\\n                vars,\\n                ReadOperation(splits[0], vars),\\n                ReadOperation(splits[1], vars));\\n        } else if (expr.rfind(\"(mult\", 0) == 0) {\\n            auto splits = splitstr(expr.substr(6, expr.size()-7));\\n            return make_unique<MultOperation>(\\n                vars,\\n                ReadOperation(splits[0], vars),\\n                ReadOperation(splits[1], vars));\\n        } else if (!IsNumber(expr[0])) {\\n            return make_unique<VarOperation>(vars, expr);\\n        } else {\\n            return make_unique<NoOperation>(vars, stoi(expr));\\n        }\\n    }\\n    \\n    vector<string> splitstr(string const& s) {\\n        vector<string> res;\\n        int curr = 0;\\n        while (curr < s.size()) {\\n            int nextSpace = -1;\\n            if (s[curr] != \\'(\\') {\\n                nextSpace = s.find(\\' \\', curr);\\n            } else {\\n                int open = 1;\\n                nextSpace = curr+1;\\n                while (nextSpace < s.size()) {\\n                    if (s[nextSpace] == \\'(\\') {\\n                        open++;\\n                    } else if (s[nextSpace] == \\')\\') {\\n                        open--;\\n                    }\\n                    nextSpace++;\\n                    if (open == 0) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (nextSpace < 0) {\\n                nextSpace = s.size();\\n            }\\n            res.push_back(s.substr(curr, nextSpace-curr));\\n            curr = nextSpace+1;\\n        }\\n        return res;\\n    }\\n    \\n    bool IsNumber(char c) {\\n        return c == \\'-\\' || (c >= \\'0\\' && c <= \\'9\\');\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class Operation {\\n    public:\\n        Operation(\\n            unordered_map<string, int> const& vars)\\n            : _vars(vars) {\\n            }\\n        \\n        virtual int Evaluate() const = 0;\\n        \\n    protected:\\n        unordered_map<string, int> _vars;\\n    };\\n    \\n    class AddOperation : public Operation {\\n    public:\\n        AddOperation(\\n            unordered_map<string, int> const& vars,\\n            unique_ptr<Operation> oper1,\\n            unique_ptr<Operation> oper2)\\n            : Operation(vars)\\n            , _oper1(move(oper1))\\n            , _oper2(move(oper2)) {\\n            }\\n        \\n        virtual int Evaluate() const {\\n            return _oper1->Evaluate() + _oper2->Evaluate();\\n        }\\n        \\n    private:\\n        unique_ptr<Operation> _oper1;\\n        unique_ptr<Operation> _oper2;\\n    };\\n    \\n    class MultOperation : public Operation {\\n    public:\\n        MultOperation(\\n            unordered_map<string, int> const& vars,\\n            unique_ptr<Operation> oper1,\\n            unique_ptr<Operation> oper2)\\n            : Operation(vars)\\n            , _oper1(move(oper1))\\n            , _oper2(move(oper2)) {\\n            }\\n        \\n        virtual int Evaluate() const {\\n            return _oper1->Evaluate() * _oper2->Evaluate();\\n        }\\n        \\n    private:\\n        unique_ptr<Operation> _oper1;\\n        unique_ptr<Operation> _oper2;\\n    };\\n    \\n    class LetOperation : public Operation {\\n    public:\\n        LetOperation(\\n            unordered_map<string, int> const& vars,\\n            unique_ptr<Operation> oper)\\n            : Operation(vars)\\n            , _oper(move(oper)){\\n            }\\n        \\n        virtual int Evaluate() const {\\n            return _oper->Evaluate();\\n        }\\n                   \\n    private:\\n        unique_ptr<Operation> _oper;\\n    };\\n    \\n    class VarOperation : public Operation {\\n    public:\\n        VarOperation(\\n            unordered_map<string, int> const& vars,\\n            string const& varName)\\n            : Operation(vars)\\n            , _varName(varName) {\\n            }\\n        \\n        virtual int Evaluate() const {\\n            return _vars.at(_varName);\\n        }\\n        \\n    private:\\n        string _varName;\\n    };\\n    \\n    class NoOperation : public Operation {\\n    public:\\n        NoOperation(\\n            unordered_map<string, int> const& vars,\\n            int val)\\n            : Operation(vars)\\n            , _val(val) {\\n            }\\n        \\n        virtual int Evaluate() const {\\n            return _val;\\n        }\\n        \\n    private:\\n        int _val;\\n    };\\n    \\n    int evaluate(string expression) {\\n        if (expression.empty()) {\\n            return 0;\\n        }\\n        \\n        unordered_map<string, int> emptVars;\\n        auto op = ReadOperation(expression, emptVars);\\n        return op->Evaluate();\\n    }\\n    \\n    unique_ptr<Operation> ReadOperation(\\n        string const& expr, \\n        unordered_map<string, int> const& vars) {\\n        if (expr.rfind(\"(let\", 0) == 0) {\\n            unordered_map<string, int> allVars(vars);\\n            auto splits = splitstr(expr.substr(5, expr.size()-6));\\n            for (int i=0; i<splits.size()-1; i+=2) {\\n                allVars[splits[i]] =\\n                    ReadOperation(\\n                        splits[i+1], \\n                        allVars)->Evaluate();\\n            }\\n            return make_unique<LetOperation>(\\n                allVars, \\n                ReadOperation(splits[splits.size()-1], allVars));\\n            \\n        } else if (expr.rfind(\"(add\", 0) == 0) {\\n            auto splits = splitstr(expr.substr(5, expr.size()-6));\\n            return make_unique<AddOperation>(\\n                vars,\\n                ReadOperation(splits[0], vars),\\n                ReadOperation(splits[1], vars));\\n        } else if (expr.rfind(\"(mult\", 0) == 0) {\\n            auto splits = splitstr(expr.substr(6, expr.size()-7));\\n            return make_unique<MultOperation>(\\n                vars,\\n                ReadOperation(splits[0], vars),\\n                ReadOperation(splits[1], vars));\\n        } else if (!IsNumber(expr[0])) {\\n            return make_unique<VarOperation>(vars, expr);\\n        } else {\\n            return make_unique<NoOperation>(vars, stoi(expr));\\n        }\\n    }\\n    \\n    vector<string> splitstr(string const& s) {\\n        vector<string> res;\\n        int curr = 0;\\n        while (curr < s.size()) {\\n            int nextSpace = -1;\\n            if (s[curr] != \\'(\\') {\\n                nextSpace = s.find(\\' \\', curr);\\n            } else {\\n                int open = 1;\\n                nextSpace = curr+1;\\n                while (nextSpace < s.size()) {\\n                    if (s[nextSpace] == \\'(\\') {\\n                        open++;\\n                    } else if (s[nextSpace] == \\')\\') {\\n                        open--;\\n                    }\\n                    nextSpace++;\\n                    if (open == 0) {\\n                        break;\\n                    }\\n                }\\n            }\\n            if (nextSpace < 0) {\\n                nextSpace = s.size();\\n            }\\n            res.push_back(s.substr(curr, nextSpace-curr));\\n            curr = nextSpace+1;\\n        }\\n        return res;\\n    }\\n    \\n    bool IsNumber(char c) {\\n        return c == \\'-\\' || (c >= \\'0\\' && c <= \\'9\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1410182,
                "title": "easy-c-recursive-solutoon",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isNumber(string s) {\\n        if (s == \"\" || s == \" \") return false;\\n        if ((s[0] < \\'0\\' || s[0] > \\'9\\') && s[0] != \\'-\\') return false;\\n        int cur = 0, n = s.length();\\n        if (s[0] == \\'-\\') cur++;\\n        while (cur < n) {\\n            if (s[cur] < \\'0\\' || s[0] > \\'9\\') return false;\\n            cur++;\\n        }\\n        return true;\\n    }\\n    \\n    // collect everything within a () as 1 token\\n    vector<string> tokenize(string exp) {\\n        if (exp == \"\" || exp == \" \") return vector<string> (); // empty string\\n        \\n        if (exp[0] == \\'(\\' && exp[exp.length() - 1] == \\')\\') exp = exp.substr(1, exp.length()-2);\\n        \\n        if (isNumber(exp)) return vector<string> {exp}; // digits\\n        else {\\n            int unfinishedParen = 0;\\n            string builder;\\n            vector<string> tokens;\\n            for (auto c: exp) {\\n                if (c == \\'(\\') unfinishedParen++;\\n                else if (c == \\')\\') unfinishedParen--;\\n                \\n                if (unfinishedParen == 0 && c == \\' \\') {\\n                    tokens.push_back(builder);\\n                    builder = \"\";\\n                } else builder += c;\\n            }\\n            if (builder.length() > 0) tokens.push_back(builder);\\n            return tokens;\\n        }\\n    }\\n    \\n    int eval(string exp, unordered_map<string, int>& parentScope) {\\n        if (exp == \"\" || exp == \" \") return 0;\\n        vector<string> tokens = tokenize(exp);\\n        \\n        int n = tokens.size();\\n\\n        if (n == 0) return 0;\\n        \\n        else if (n == 1) { // this is a digit or var name\\n            if (isNumber(tokens[0])) return stoi(tokens[0]);\\n            else return parentScope[tokens[0]];\\n        \\n        } else {\\n        \\n            if (tokens[0] == \"add\") {\\n                return eval(tokens[1], parentScope) + eval(tokens[2], parentScope);\\n            \\n            } else if (tokens[0] == \"mult\") {\\n                return eval(tokens[1], parentScope) * eval(tokens[2], parentScope);\\n            \\n            } else if (tokens[0] == \"let\") {\\n                unordered_map<string, int> childScope(parentScope);\\n                for (int i = 1; i < n-2; i+=2) {\\n                    string var = tokens[i];\\n                    int varExp = eval(tokens[i+1], childScope);\\n                    childScope[var] = varExp;\\n                }\\n                return eval(tokens[n-1], childScope);\\n            \\n            } else {\\n                throw \"unknown operation\\\\n\";\\n            }\\n        }\\n    }\\n    \\n    int evaluate(string expression) {\\n        unordered_map<string, int> scope;\\n        return eval(expression, scope);\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isNumber(string s) {\\n        if (s == \"\" || s == \" \") return false;\\n        if ((s[0] < \\'0\\' || s[0] > \\'9\\') && s[0] != \\'-\\') return false;\\n        int cur = 0, n = s.length();\\n        if (s[0] == \\'-\\') cur++;\\n        while (cur < n) {\\n            if (s[cur] < \\'0\\' || s[0] > \\'9\\') return false;\\n            cur++;\\n        }\\n        return true;\\n    }\\n    \\n    // collect everything within a () as 1 token\\n    vector<string> tokenize(string exp) {\\n        if (exp == \"\" || exp == \" \") return vector<string> (); // empty string\\n        \\n        if (exp[0] == \\'(\\' && exp[exp.length() - 1] == \\')\\') exp = exp.substr(1, exp.length()-2);\\n        \\n        if (isNumber(exp)) return vector<string> {exp}; // digits\\n        else {\\n            int unfinishedParen = 0;\\n            string builder;\\n            vector<string> tokens;\\n            for (auto c: exp) {\\n                if (c == \\'(\\') unfinishedParen++;\\n                else if (c == \\')\\') unfinishedParen--;\\n                \\n                if (unfinishedParen == 0 && c == \\' \\') {\\n                    tokens.push_back(builder);\\n                    builder = \"\";\\n                } else builder += c;\\n            }\\n            if (builder.length() > 0) tokens.push_back(builder);\\n            return tokens;\\n        }\\n    }\\n    \\n    int eval(string exp, unordered_map<string, int>& parentScope) {\\n        if (exp == \"\" || exp == \" \") return 0;\\n        vector<string> tokens = tokenize(exp);\\n        \\n        int n = tokens.size();\\n\\n        if (n == 0) return 0;\\n        \\n        else if (n == 1) { // this is a digit or var name\\n            if (isNumber(tokens[0])) return stoi(tokens[0]);\\n            else return parentScope[tokens[0]];\\n        \\n        } else {\\n        \\n            if (tokens[0] == \"add\") {\\n                return eval(tokens[1], parentScope) + eval(tokens[2], parentScope);\\n            \\n            } else if (tokens[0] == \"mult\") {\\n                return eval(tokens[1], parentScope) * eval(tokens[2], parentScope);\\n            \\n            } else if (tokens[0] == \"let\") {\\n                unordered_map<string, int> childScope(parentScope);\\n                for (int i = 1; i < n-2; i+=2) {\\n                    string var = tokens[i];\\n                    int varExp = eval(tokens[i+1], childScope);\\n                    childScope[var] = varExp;\\n                }\\n                return eval(tokens[n-1], childScope);\\n            \\n            } else {\\n                throw \"unknown operation\\\\n\";\\n            }\\n        }\\n    }\\n    \\n    int evaluate(string expression) {\\n        unordered_map<string, int> scope;\\n        return eval(expression, scope);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1371046,
                "title": "scala-pure-fp-solution-beats-100",
                "content": "```scala\\n  def evaluate(expression: String): Int = {\\n    val letPattern = \"\\\\\\\\(let (.+)\\\\\\\\)\".r\\n    val addPattern = \"\\\\\\\\(add (.+)\\\\\\\\)\".r\\n    val multPattern = \"\\\\\\\\(mult (.+)\\\\\\\\)\".r\\n    val numberPattern = \"([+|-]?\\\\\\\\d+)\".r\\n    val variablePattern = \"(\\\\\\\\w[\\\\\\\\w|\\\\\\\\d]*)\".r\\n\\n    def eval(expression: String, globalVariables: Map[String, Int]): Int = {\\n      val localVariables = mutable.HashMap.empty[String, Int]\\n\\n      expression match {\\n        case letPattern(str) =>\\n          val (vars, expr) = parseVariables(str)\\n          vars.foreach { case (x, expr) =>\\n            localVariables += x -> eval(expr, globalVariables ++ localVariables.toMap)\\n          }\\n          eval(expr, globalVariables ++ localVariables.toMap)\\n        case addPattern(str) =>\\n          val (leftExpr, rightExpr) = parseOperands(str)\\n          operator(_ + _)(leftExpr, rightExpr, globalVariables)\\n        case multPattern(str) =>\\n          val (leftExpr, rightExpr) = parseOperands(str)\\n          operator(_ * _)(leftExpr, rightExpr, globalVariables)\\n        case numberPattern(str) =>\\n          str.toInt\\n        case variablePattern(str) if globalVariables.contains(str) =>\\n          globalVariables(str)\\n        case str => throw new IllegalArgumentException(s\"Can`t parse $str\")\\n      }\\n    }\\n\\n    @tailrec\\n    def parseVariables(str: String,\\n                       res: (Array[(String, String)], String) = (Array.empty[(String, String)], \"\")\\n                      ): (Array[(String, String)], String) = {\\n      if (str == \"\") res\\n      else {\\n        val (first, i) = parseExpression(str)\\n        if (i == str.length) (res._1, res._2 + first)\\n        else {\\n          val (second, j) = parseExpression(str.drop(i + 1))\\n          parseVariables(str.drop(i + 1 + j + 1), (res._1 :+ (first, second), res._2))\\n        }\\n      }\\n    }\\n\\n    def parseOperands(str: String): (String, String) = {\\n      val (left, i) = parseExpression(str)\\n      (left, str.drop(i + 1))\\n    }\\n\\n    def parseExpression(str: String): (String, Int) = {\\n      var i = 0\\n      var brackets = 0\\n      if (str.head == \\'(\\') {\\n        brackets += 1\\n        i = 1\\n        while(i < str.length && brackets != 0) {\\n          if (str(i) == \\'(\\') brackets += 1\\n          if (str(i) == \\')\\') brackets -= 1\\n          i += 1\\n        }\\n      } else {\\n        i = 0\\n        while(i < str.length && str(i) != \\' \\') i += 1\\n      }\\n      (str.take(i), i)\\n    }\\n\\n    def operator(f: (Int, Int) => Int)\\n                (leftExpression: String,\\n                 rightExpression: String,\\n                 variables: Map[String, Int]): Int = {\\n      f(eval(leftExpression, variables), eval(rightExpression, variables))\\n    }\\n\\n    eval(expression, Map.empty[String, Int])\\n  }\\n```",
                "solutionTags": [],
                "code": "```scala\\n  def evaluate(expression: String): Int = {\\n    val letPattern = \"\\\\\\\\(let (.+)\\\\\\\\)\".r\\n    val addPattern = \"\\\\\\\\(add (.+)\\\\\\\\)\".r\\n    val multPattern = \"\\\\\\\\(mult (.+)\\\\\\\\)\".r\\n    val numberPattern = \"([+|-]?\\\\\\\\d+)\".r\\n    val variablePattern = \"(\\\\\\\\w[\\\\\\\\w|\\\\\\\\d]*)\".r\\n\\n    def eval(expression: String, globalVariables: Map[String, Int]): Int = {\\n      val localVariables = mutable.HashMap.empty[String, Int]\\n\\n      expression match {\\n        case letPattern(str) =>\\n          val (vars, expr) = parseVariables(str)\\n          vars.foreach { case (x, expr) =>\\n            localVariables += x -> eval(expr, globalVariables ++ localVariables.toMap)\\n          }\\n          eval(expr, globalVariables ++ localVariables.toMap)\\n        case addPattern(str) =>\\n          val (leftExpr, rightExpr) = parseOperands(str)\\n          operator(_ + _)(leftExpr, rightExpr, globalVariables)\\n        case multPattern(str) =>\\n          val (leftExpr, rightExpr) = parseOperands(str)\\n          operator(_ * _)(leftExpr, rightExpr, globalVariables)\\n        case numberPattern(str) =>\\n          str.toInt\\n        case variablePattern(str) if globalVariables.contains(str) =>\\n          globalVariables(str)\\n        case str => throw new IllegalArgumentException(s\"Can`t parse $str\")\\n      }\\n    }\\n\\n    @tailrec\\n    def parseVariables(str: String,\\n                       res: (Array[(String, String)], String) = (Array.empty[(String, String)], \"\")\\n                      ): (Array[(String, String)], String) = {\\n      if (str == \"\") res\\n      else {\\n        val (first, i) = parseExpression(str)\\n        if (i == str.length) (res._1, res._2 + first)\\n        else {\\n          val (second, j) = parseExpression(str.drop(i + 1))\\n          parseVariables(str.drop(i + 1 + j + 1), (res._1 :+ (first, second), res._2))\\n        }\\n      }\\n    }\\n\\n    def parseOperands(str: String): (String, String) = {\\n      val (left, i) = parseExpression(str)\\n      (left, str.drop(i + 1))\\n    }\\n\\n    def parseExpression(str: String): (String, Int) = {\\n      var i = 0\\n      var brackets = 0\\n      if (str.head == \\'(\\') {\\n        brackets += 1\\n        i = 1\\n        while(i < str.length && brackets != 0) {\\n          if (str(i) == \\'(\\') brackets += 1\\n          if (str(i) == \\')\\') brackets -= 1\\n          i += 1\\n        }\\n      } else {\\n        i = 0\\n        while(i < str.length && str(i) != \\' \\') i += 1\\n      }\\n      (str.take(i), i)\\n    }\\n\\n    def operator(f: (Int, Int) => Int)\\n                (leftExpression: String,\\n                 rightExpression: String,\\n                 variables: Map[String, Int]): Int = {\\n      f(eval(leftExpression, variables), eval(rightExpression, variables))\\n    }\\n\\n    eval(expression, Map.empty[String, Int])\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1368434,
                "title": "standard-interpreter-structure",
                "content": "```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        return self.evaluate_env(expression, {})\\n    \\n    def split_expr(self, expr):\\n\\t\\t\\'\\'\\'\\n\\t\\tSplit the expression using stack\\n\\t\\t\\'\\'\\'\\n        stack = 0\\n        res = []\\n        cur = \"\"\\n        for i in range(1, len(expr)-1):\\n            if expr[i] != \\' \\' or stack > 0:\\n                cur+=expr[i]\\n            elif expr[i]==\\' \\' and stack == 0:\\n                if cur != \\'\\':\\n                    res.append(cur)\\n                cur = \"\"\\n            if \\'(\\' == expr[i]:\\n                stack += 1\\n            elif \\')\\' == expr[i]:\\n                stack -= 1\\n        res.append(cur)\\n        # print(res)\\n        return res\\n    \\n    def evaluate_env(self, expression: str, env):\\n        if expression.isdigit() or (expression[0]==\\'-\\' and expression[1:].isdigit()):\\n            return int(expression)\\n        elif expression in env:\\n            return env[expression]\\n        stack = []\\n        cur_exprs = self.split_expr(expression)\\n        if cur_exprs[0] == \\'let\\':\\n            pair_num = (len(cur_exprs) - 2) // 2\\n            for i in range(pair_num):\\n                env[cur_exprs[i*2+1]] = self.evaluate_env(cur_exprs[i*2+2], env.copy())\\n            if cur_exprs[-1] in env:\\n                return env[cur_exprs[-1]]\\n            else:\\n                return self.evaluate_env(cur_exprs[-1], env.copy())\\n        elif cur_exprs[0] == \\'add\\':\\n            return self.evaluate_env(cur_exprs[1], env.copy()) + self.evaluate_env(cur_exprs[2], env.copy())\\n        elif cur_exprs[0] == \"mult\":\\n            return self.evaluate_env(cur_exprs[1], env.copy()) * self.evaluate_env(cur_exprs[2], env.copy())\\n```\\nJust like the interpreter learned in school, to interpret the inner local code, bring a copy of environment outside. The environment should contain the mapping from variable to its value. The addon is we need to split the expression by ourselves. I used a stack to check whether the current pointer is on a inner code.",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        return self.evaluate_env(expression, {})\\n    \\n    def split_expr(self, expr):\\n\\t\\t\\'\\'\\'\\n\\t\\tSplit the expression using stack\\n\\t\\t\\'\\'\\'\\n        stack = 0\\n        res = []\\n        cur = \"\"\\n        for i in range(1, len(expr)-1):\\n            if expr[i] != \\' \\' or stack > 0:\\n                cur+=expr[i]\\n            elif expr[i]==\\' \\' and stack == 0:\\n                if cur != \\'\\':\\n                    res.append(cur)\\n                cur = \"\"\\n            if \\'(\\' == expr[i]:\\n                stack += 1\\n            elif \\')\\' == expr[i]:\\n                stack -= 1\\n        res.append(cur)\\n        # print(res)\\n        return res\\n    \\n    def evaluate_env(self, expression: str, env):\\n        if expression.isdigit() or (expression[0]==\\'-\\' and expression[1:].isdigit()):\\n            return int(expression)\\n        elif expression in env:\\n            return env[expression]\\n        stack = []\\n        cur_exprs = self.split_expr(expression)\\n        if cur_exprs[0] == \\'let\\':\\n            pair_num = (len(cur_exprs) - 2) // 2\\n            for i in range(pair_num):\\n                env[cur_exprs[i*2+1]] = self.evaluate_env(cur_exprs[i*2+2], env.copy())\\n            if cur_exprs[-1] in env:\\n                return env[cur_exprs[-1]]\\n            else:\\n                return self.evaluate_env(cur_exprs[-1], env.copy())\\n        elif cur_exprs[0] == \\'add\\':\\n            return self.evaluate_env(cur_exprs[1], env.copy()) + self.evaluate_env(cur_exprs[2], env.copy())\\n        elif cur_exprs[0] == \"mult\":\\n            return self.evaluate_env(cur_exprs[1], env.copy()) * self.evaluate_env(cur_exprs[2], env.copy())\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1289132,
                "title": "c-simple-solution-no-parse-tree-or-grammar-needed",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n  // The context is a singly linked list of scopes\\n  struct Context {\\n    Context *outer = nullptr;\\n    unordered_map<string, int> scope;\\n    \\n    Context(Context *outer) : outer(outer) {}\\n    Context() : outer(nullptr) {}\\n    \\n    int getVal(const string& varName) {\\n      if (scope.find(varName) == scope.end()) {\\n        return outer->getVal(varName);\\n      }\\n      return scope[varName];\\n    }\\n  };\\n  \\n  // The \"main\" function\\n  int evaluate(string expression) {\\n    int idx = 0;\\n    Context *ctx = nullptr;\\n    return evaluate(expression, idx, ctx);\\n  }\\n  \\n  // Evaluates the expression at index idx given the context ctx\\n  int evaluate(string& exp, int& idx, Context *ctx) {\\n    int value = -1;\\n    eat(exp, idx, \\'(\\');\\n    if (eat(exp, idx, \"let\")) {\\n      value = evaluateLet(exp, idx, ctx);\\n    } else if (eat(exp, idx, \"mult\")) {\\n      value = evaluateMult(exp, idx, ctx);\\n    } else if (eat(exp, idx, \"add\")) {\\n      value = evaluateAdd(exp, idx, ctx);\\n    } else {\\n      string token = getToken(exp, idx);\\n      if (isNumber(token)) {\\n        value = stoi(token);\\n      } else {\\n        value = ctx->getVal(token);\\n      }\\n      eat(exp, idx, \\' \\');\\n    }\\n    eat(exp, idx, \\')\\');\\n    return value;\\n  }\\n  \\n  int evaluateLet(string& exp, int& idx, Context *outer) {\\n    // Create new context for the declarations under the let\\n    Context *ctx = new Context(outer);\\n    \\n    int value = -1;\\n    while (true) {\\n      // Indicates an expression, which means that it is the result of the let\\n      if (peek(exp, idx) == \\'(\\') {\\n        value = evaluate(exp, idx, ctx);\\n        break;\\n      }\\n      \\n      string token = getToken(exp, idx);\\n      // Closed paren indicates end of expression and the current token is the result\\n      if (peek(exp, idx) == \\')\\') {\\n        // Check if the token is a number\\n        if (isNumber(token)) return stoi(token);\\n        // If not, it must be a variable, return its value\\n        value = ctx->getVal(token);\\n        break;\\n      }\\n      eat(exp, idx, \\' \\');\\n      int val = evaluate(exp, idx, ctx);\\n      ctx->scope[token] = val;\\n      eat(exp, idx, \\' \\');\\n    }\\n    delete ctx;\\n    return value;\\n  }\\n  \\n  int evaluateAdd(string& exp, int& idx, Context *ctx) {\\n    int e1 = evaluate(exp, idx, ctx);\\n    // Eat the space between operands\\n    eat(exp, idx, \\' \\');\\n    int e2 = evaluate(exp, idx, ctx);\\n    return e1 + e2;\\n  }\\n  \\n  int evaluateMult(string& exp, int& idx, Context *ctx) {\\n    int e1 = evaluate(exp, idx, ctx);\\n    // Eat the space between operands\\n    eat(exp, idx, \\' \\');\\n    int e2 = evaluate(exp, idx, ctx);\\n    return e1 * e2;\\n  }\\n  \\n  //--------------------------HELPER FUNCTIONS FOR PARSING----------------------------\\n  \\n  // Returns the next token (token is any string surrounded by whitespace)\\n  string getToken(string& exp, int& idx) {\\n    if (idx >= exp.size()) return \"\";\\n    int initIdx = idx;\\n    while (idx < exp.size() && exp[idx] != \\' \\' && exp[idx] != \\')\\') idx++;\\n    return exp.substr(initIdx, idx - initIdx);\\n  }\\n  \\n  // Checks if char c is at the current index and progresses the index if it is\\n  bool eat(string& exp, int& idx, char c) {\\n    if (exp[idx] == c) {\\n      idx++;\\n      return true;\\n    }\\n    return false;\\n  }\\n  \\n  // Checks if string s is at the current index and progresses the index if it is\\n  bool eat(string exp, int& idx, const string& s) {\\n    if (idx + s.size() > exp.size()) {\\n      return false;\\n    }\\n    for (int i = 0; i < s.size(); ++i) {\\n      if (s[i] != exp[idx + i]) return false;\\n    }\\n    if (idx + s.size() == exp.size()) {\\n      idx += s.size();\\n      return true;\\n    } else if (exp[idx + s.size()] == \\' \\') {\\n      idx += (s.size() + 1);\\n      return true;\\n    }\\n    return false;\\n  }\\n  \\n  // Checks the current character without changing the index\\n  char peek(string& exp, int idx) {\\n    return exp[idx];\\n  }\\n  \\n  // Checks if given string is a number\\n  bool isNumber(const string& s) {\\n    if (s.size() == 0) return false;\\n    int i = 0;\\n    if (s[i] == \\'-\\') {\\n      i++;\\n    }\\n    for (; i < s.size(); ++i) {\\n      char c = s[i];\\n      if (c < \\'0\\' || c > \\'9\\') return false;\\n    }\\n    return true;\\n  }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n  // The context is a singly linked list of scopes\\n  struct Context {\\n    Context *outer = nullptr;\\n    unordered_map<string, int> scope;\\n    \\n    Context(Context *outer) : outer(outer) {}\\n    Context() : outer(nullptr) {}\\n    \\n    int getVal(const string& varName) {\\n      if (scope.find(varName) == scope.end()) {\\n        return outer->getVal(varName);\\n      }\\n      return scope[varName];\\n    }\\n  };\\n  \\n  // The \"main\" function\\n  int evaluate(string expression) {\\n    int idx = 0;\\n    Context *ctx = nullptr;\\n    return evaluate(expression, idx, ctx);\\n  }\\n  \\n  // Evaluates the expression at index idx given the context ctx\\n  int evaluate(string& exp, int& idx, Context *ctx) {\\n    int value = -1;\\n    eat(exp, idx, \\'(\\');\\n    if (eat(exp, idx, \"let\")) {\\n      value = evaluateLet(exp, idx, ctx);\\n    } else if (eat(exp, idx, \"mult\")) {\\n      value = evaluateMult(exp, idx, ctx);\\n    } else if (eat(exp, idx, \"add\")) {\\n      value = evaluateAdd(exp, idx, ctx);\\n    } else {\\n      string token = getToken(exp, idx);\\n      if (isNumber(token)) {\\n        value = stoi(token);\\n      } else {\\n        value = ctx->getVal(token);\\n      }\\n      eat(exp, idx, \\' \\');\\n    }\\n    eat(exp, idx, \\')\\');\\n    return value;\\n  }\\n  \\n  int evaluateLet(string& exp, int& idx, Context *outer) {\\n    // Create new context for the declarations under the let\\n    Context *ctx = new Context(outer);\\n    \\n    int value = -1;\\n    while (true) {\\n      // Indicates an expression, which means that it is the result of the let\\n      if (peek(exp, idx) == \\'(\\') {\\n        value = evaluate(exp, idx, ctx);\\n        break;\\n      }\\n      \\n      string token = getToken(exp, idx);\\n      // Closed paren indicates end of expression and the current token is the result\\n      if (peek(exp, idx) == \\')\\') {\\n        // Check if the token is a number\\n        if (isNumber(token)) return stoi(token);\\n        // If not, it must be a variable, return its value\\n        value = ctx->getVal(token);\\n        break;\\n      }\\n      eat(exp, idx, \\' \\');\\n      int val = evaluate(exp, idx, ctx);\\n      ctx->scope[token] = val;\\n      eat(exp, idx, \\' \\');\\n    }\\n    delete ctx;\\n    return value;\\n  }\\n  \\n  int evaluateAdd(string& exp, int& idx, Context *ctx) {\\n    int e1 = evaluate(exp, idx, ctx);\\n    // Eat the space between operands\\n    eat(exp, idx, \\' \\');\\n    int e2 = evaluate(exp, idx, ctx);\\n    return e1 + e2;\\n  }\\n  \\n  int evaluateMult(string& exp, int& idx, Context *ctx) {\\n    int e1 = evaluate(exp, idx, ctx);\\n    // Eat the space between operands\\n    eat(exp, idx, \\' \\');\\n    int e2 = evaluate(exp, idx, ctx);\\n    return e1 * e2;\\n  }\\n  \\n  //--------------------------HELPER FUNCTIONS FOR PARSING----------------------------\\n  \\n  // Returns the next token (token is any string surrounded by whitespace)\\n  string getToken(string& exp, int& idx) {\\n    if (idx >= exp.size()) return \"\";\\n    int initIdx = idx;\\n    while (idx < exp.size() && exp[idx] != \\' \\' && exp[idx] != \\')\\') idx++;\\n    return exp.substr(initIdx, idx - initIdx);\\n  }\\n  \\n  // Checks if char c is at the current index and progresses the index if it is\\n  bool eat(string& exp, int& idx, char c) {\\n    if (exp[idx] == c) {\\n      idx++;\\n      return true;\\n    }\\n    return false;\\n  }\\n  \\n  // Checks if string s is at the current index and progresses the index if it is\\n  bool eat(string exp, int& idx, const string& s) {\\n    if (idx + s.size() > exp.size()) {\\n      return false;\\n    }\\n    for (int i = 0; i < s.size(); ++i) {\\n      if (s[i] != exp[idx + i]) return false;\\n    }\\n    if (idx + s.size() == exp.size()) {\\n      idx += s.size();\\n      return true;\\n    } else if (exp[idx + s.size()] == \\' \\') {\\n      idx += (s.size() + 1);\\n      return true;\\n    }\\n    return false;\\n  }\\n  \\n  // Checks the current character without changing the index\\n  char peek(string& exp, int idx) {\\n    return exp[idx];\\n  }\\n  \\n  // Checks if given string is a number\\n  bool isNumber(const string& s) {\\n    if (s.size() == 0) return false;\\n    int i = 0;\\n    if (s[i] == \\'-\\') {\\n      i++;\\n    }\\n    for (; i < s.size(); ++i) {\\n      char c = s[i];\\n      if (c < \\'0\\' || c > \\'9\\') return false;\\n    }\\n    return true;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253735,
                "title": "java-o-n-build-parse-tree-and-dfs-o-m-do-evaluate",
                "content": "Instead of reading exp from left to right, we could read the exp from right to left in this case.\\nWe also need a data structure to build a parse tree, which can store the operation, variable, or value as well as the child and parent nodes. \\nSince `add`, `mult`, and `let`, are reseved words, we could use a String field to hold operation, variable, or value, named `op` in this implementaion.\\nThe following are the logic on how to build the tree:\\n1. `)` -> Start a new child node and we don\\'t know what operation will be for this node yet.\\n2. Go through all the var, operation, or value and add them into the stack of current node.\\n3.  `(` -> we can know the operation now, which is stored at the top of the stack of current node. Thus, we pop the operation and the assign it to current node\\'s `op`. Go back to the parent node.\\n4.  We don\\'t need to evalute the `let` assignment yet. Just build the tree.\\n\\nAs for the evaluation, just start from the root and do DFS to collect the result.\\n\\n```\\nclass Solution {\\n    class Exp {\\n        Stack<Exp> exps;\\n        String op;\\n        Exp parent;\\n\\n        Exp(Exp from) {\\n            this.exps = new Stack<>();\\n            this.parent = from;\\n        }\\n\\n        int evaluate(Map<String, Integer> vars) {\\n            if (op.equalsIgnoreCase(\"add\")) {\\n                return exps.pop().evaluate(vars) + exps.pop().evaluate(vars);\\n            } else if (op.equalsIgnoreCase(\"mult\")) {\\n                return exps.pop().evaluate(vars) * exps.pop().evaluate(vars);\\n            } else if (op.equalsIgnoreCase(\"let\")) {\\n                Map<String, Integer> nextVars = new HashMap<>(vars);\\n                while (exps.size()>1) {\\n                    String varName = exps.pop().op;\\n                    int val = exps.pop().evaluate(nextVars);\\n                    nextVars.put(varName, val);\\n                }\\n                return exps.pop().evaluate(nextVars);\\n            } else {\\n                if (Character.isLetter(op.charAt(0))) {\\n                    return vars.get(op);\\n                } else {\\n                    return Integer.parseInt(op);\\n                }\\n            }\\n        }\\n    }\\n    \\n    Exp buildTree(String exp) {\\n        Exp root = new Exp(null), cur = root;\\n        int n = exp.length()-1;\\n        while (n >=0) {\\n            char c = exp.charAt(n);\\n            if (c==\\')\\') {\\n                Exp next = new Exp(cur);\\n                cur.exps.push(next);\\n                cur = next;\\n            } else if (c==\\'(\\') {\\n                cur.op = cur.exps.pop().op;\\n                cur = cur.parent;\\n            } else if (c != \\' \\'){\\n                int pre = n;\\n                while (pre>=0 && exp.charAt(pre)!=\\'(\\' && exp.charAt(pre)!=\\' \\')\\n                    pre--;\\n                Exp next = new Exp(cur);\\n                next.op = exp.substring(pre+1, n+1);\\n                cur.exps.push(next);\\n                n=pre+1;\\n            }\\n            n--;\\n        }\\n        return root.exps.pop();\\n    }\\n    \\n    public int evaluate(String exp) {\\n        return buildTree(exp).evaluate(new HashMap<>());\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    class Exp {\\n        Stack<Exp> exps;\\n        String op;\\n        Exp parent;\\n\\n        Exp(Exp from) {\\n            this.exps = new Stack<>();\\n            this.parent = from;\\n        }\\n\\n        int evaluate(Map<String, Integer> vars) {\\n            if (op.equalsIgnoreCase(\"add\")) {\\n                return exps.pop().evaluate(vars) + exps.pop().evaluate(vars);\\n            } else if (op.equalsIgnoreCase(\"mult\")) {\\n                return exps.pop().evaluate(vars) * exps.pop().evaluate(vars);\\n            } else if (op.equalsIgnoreCase(\"let\")) {\\n                Map<String, Integer> nextVars = new HashMap<>(vars);\\n                while (exps.size()>1) {\\n                    String varName = exps.pop().op;\\n                    int val = exps.pop().evaluate(nextVars);\\n                    nextVars.put(varName, val);\\n                }\\n                return exps.pop().evaluate(nextVars);\\n            } else {\\n                if (Character.isLetter(op.charAt(0))) {\\n                    return vars.get(op);\\n                } else {\\n                    return Integer.parseInt(op);\\n                }\\n            }\\n        }\\n    }\\n    \\n    Exp buildTree(String exp) {\\n        Exp root = new Exp(null), cur = root;\\n        int n = exp.length()-1;\\n        while (n >=0) {\\n            char c = exp.charAt(n);\\n            if (c==\\')\\') {\\n                Exp next = new Exp(cur);\\n                cur.exps.push(next);\\n                cur = next;\\n            } else if (c==\\'(\\') {\\n                cur.op = cur.exps.pop().op;\\n                cur = cur.parent;\\n            } else if (c != \\' \\'){\\n                int pre = n;\\n                while (pre>=0 && exp.charAt(pre)!=\\'(\\' && exp.charAt(pre)!=\\' \\')\\n                    pre--;\\n                Exp next = new Exp(cur);\\n                next.op = exp.substring(pre+1, n+1);\\n                cur.exps.push(next);\\n                n=pre+1;\\n            }\\n            n--;\\n        }\\n        return root.exps.pop();\\n    }\\n    \\n    public int evaluate(String exp) {\\n        return buildTree(exp).evaluate(new HashMap<>());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1251955,
                "title": "c-stacks-recursion",
                "content": "```\\nclass Solution {\\n    unordered_map<string, stack<int>> m;\\n    \\n    string getVar(const string& expr, int& i) {\\n        string var;\\n        while (isalnum(expr[i])) \\n            var += expr[i++];\\n        return var;\\n    }\\n    \\n    int getNum(const string& expr, int& i) {\\n        int sig = expr[i] == \\'-\\' ? -1 : 1;\\n        if (expr[i] == \\'-\\') ++i;\\n        int val = 0;\\n        while (isdigit(expr[i])) \\n            val = expr[i++] - \\'0\\' + val * 10;\\n        val *= sig;\\n        return val;\\n    }\\n    \\n    // add / mult\\n    int getVal(const string& expr, int& i) {\\n        if (expr[i] == \\'(\\')\\n            return eval(expr, i);\\n        else if (expr[i] == \\'-\\' || isdigit(expr[i]))\\n            return getNum(expr, i);\\n        else \\n            return m[getVar(expr, i)].top();\\n    }\\n    \\n    int eval(const string& expr, int& i) {        \\n        int s = i;\\n        while (expr[i] != \\' \\') ++i;\\n        string opt(expr.substr(s, i - s));\\n        ++i; // skip space\\n        \\n        if (opt == \"(let\") {\\n            int ans = 0;\\n            vector<string> vars;\\n            while (true) {\\n                // (let x 5 ... (...))\\n                if (expr[i] == \\'(\\') {\\n                    ans = eval(expr, i);\\n                    break;\\n                }\\n                \\n                // (let x 5 ... 99)\\n                if (expr[i] == \\'-\\' || isdigit(expr[i])) {\\n                    ans = getNum(expr, i);\\n                    break;\\n                }\\n                    \\n                string var(getVar(expr, i));\\n                \\n                // (let x 5 ... x)\\n                if (expr[i] == \\')\\') {\\n                    ans = m[var].top();\\n                    break;\\n                }\\n                \\n                ++i; // skip space\\n                \\n                int val = 0;\\n                if (expr[i] == \\'(\\') {\\n                    val = eval(expr, i);\\n                } else if (expr[i] == \\'-\\' || isdigit(expr[i])) {\\n                    val = getNum(expr, i);\\n                } else {\\n                    val = m[getVar(expr, i)].top();\\n                }\\n                \\n                vars.push_back(var);\\n                m[var].push(val);\\n                \\n                ++i; // skip space\\n            }\\n            ++i; // skip )\\n            for (const auto& var : vars)\\n                m[var].pop();\\n            return ans;\\n        } else if (opt == \"(add\") {\\n            int l = getVal(expr, i);\\n            ++i; // skip space\\n            int r = getVal(expr, i);\\n            ++i; // skip )\\n            return l + r;\\n        } else /*if (opt == \"(mult\")*/ {\\n            int l = getVal(expr, i);\\n            ++i; // skip space\\n            int r = getVal(expr, i);\\n            ++i; // skip )\\n            return l * r;\\n        }\\n    }\\n    \\npublic:\\n    int evaluate(string expression) {\\n        int i = 0;\\n        if (expression[i] != \\'(\\') \\n            return stoi(expression);\\n        return eval(expression, i);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    unordered_map<string, stack<int>> m;\\n    \\n    string getVar(const string& expr, int& i) {\\n        string var;\\n        while (isalnum(expr[i])) \\n            var += expr[i++];\\n        return var;\\n    }\\n    \\n    int getNum(const string& expr, int& i) {\\n        int sig = expr[i] == \\'-\\' ? -1 : 1;\\n        if (expr[i] == \\'-\\') ++i;\\n        int val = 0;\\n        while (isdigit(expr[i])) \\n            val = expr[i++] - \\'0\\' + val * 10;\\n        val *= sig;\\n        return val;\\n    }\\n    \\n    // add / mult\\n    int getVal(const string& expr, int& i) {\\n        if (expr[i] == \\'(\\')\\n            return eval(expr, i);\\n        else if (expr[i] == \\'-\\' || isdigit(expr[i]))\\n            return getNum(expr, i);\\n        else \\n            return m[getVar(expr, i)].top();\\n    }\\n    \\n    int eval(const string& expr, int& i) {        \\n        int s = i;\\n        while (expr[i] != \\' \\') ++i;\\n        string opt(expr.substr(s, i - s));\\n        ++i; // skip space\\n        \\n        if (opt == \"(let\") {\\n            int ans = 0;\\n            vector<string> vars;\\n            while (true) {\\n                // (let x 5 ... (...))\\n                if (expr[i] == \\'(\\') {\\n                    ans = eval(expr, i);\\n                    break;\\n                }\\n                \\n                // (let x 5 ... 99)\\n                if (expr[i] == \\'-\\' || isdigit(expr[i])) {\\n                    ans = getNum(expr, i);\\n                    break;\\n                }\\n                    \\n                string var(getVar(expr, i));\\n                \\n                // (let x 5 ... x)\\n                if (expr[i] == \\')\\') {\\n                    ans = m[var].top();\\n                    break;\\n                }\\n                \\n                ++i; // skip space\\n                \\n                int val = 0;\\n                if (expr[i] == \\'(\\') {\\n                    val = eval(expr, i);\\n                } else if (expr[i] == \\'-\\' || isdigit(expr[i])) {\\n                    val = getNum(expr, i);\\n                } else {\\n                    val = m[getVar(expr, i)].top();\\n                }\\n                \\n                vars.push_back(var);\\n                m[var].push(val);\\n                \\n                ++i; // skip space\\n            }\\n            ++i; // skip )\\n            for (const auto& var : vars)\\n                m[var].pop();\\n            return ans;\\n        } else if (opt == \"(add\") {\\n            int l = getVal(expr, i);\\n            ++i; // skip space\\n            int r = getVal(expr, i);\\n            ++i; // skip )\\n            return l + r;\\n        } else /*if (opt == \"(mult\")*/ {\\n            int l = getVal(expr, i);\\n            ++i; // skip space\\n            int r = getVal(expr, i);\\n            ++i; // skip )\\n            return l * r;\\n        }\\n    }\\n    \\npublic:\\n    int evaluate(string expression) {\\n        int i = 0;\\n        if (expression[i] != \\'(\\') \\n            return stoi(expression);\\n        return eval(expression, i);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1235630,
                "title": "single-pass-with-istringstream-c",
                "content": "```\\nclass Solution {\\n    using TokenValue = std::map<std::string, int>;\\n    \\npublic:\\n    int evaluate(const std::string& expression) {\\n        TokenValue token_value;\\n        std::istringstream iss(expression);\\n        return evaluate(iss, token_value);\\n    }\\n\\nprivate:\\n    bool skipSpaces(std::istringstream& iss) const {\\n        while (iss.good() && std::isblank(iss.peek())) {\\n            iss.get();\\n        }\\n        return true;\\n    }\\n\\n    bool isNumber(std::istringstream& iss) {\\n        return skipSpaces(iss) && (std::isdigit(iss.peek()) || iss.peek() == \\'-\\');\\n    }\\n\\n    bool isExpression(std::istringstream& iss) {\\n        return skipSpaces(iss) && iss.peek() == \\'(\\';\\n    }\\n    \\n    bool isValue(std::istringstream& iss) {\\n        return isNumber(iss) || isExpression(iss);\\n    }\\n    \\n    bool isToken(std::istringstream& iss) {\\n        return !isValue(iss);\\n    }\\n    \\n    std::string getToken(std::istringstream& iss) {\\n        skipSpaces(iss);\\n        std::ostringstream oss; // don\\'t mess with \\'))\\'\\n        while (iss.good() && std::isalnum(iss.peek())) {\\n            oss << (char)iss.get();\\n        }\\n        return oss.str();\\n    }\\n    \\n    int getValue(std::istringstream& iss, TokenValue token_value) {\\n        if (isNumber(iss)) {\\n            int result;\\n            iss >> result;\\n            return result;\\n        }\\n        if (isExpression(iss)) {\\n            return evaluate(iss, token_value);\\n        }\\n        return token_value[getToken(iss)];\\n    }\\n\\n    int evaluate(std::istringstream& iss, TokenValue token_value) {\\n        iss.get(); // \\'(\\'\\n        std::string expression;\\n        iss >> expression;\\n        int result = 0;\\n        if (expression == \"add\") {\\n            result = getValue(iss, token_value) + getValue(iss, token_value);\\n        }\\n        if (expression == \"mult\") {\\n            result = getValue(iss, token_value) * getValue(iss, token_value);\\n        }\\n        if (expression == \"let\") {\\n            while (isToken(iss)) {\\n                std::string token = getToken(iss);\\n                if (iss.peek() == \\')\\') {\\n                    result = token_value[token];\\n                    break;\\n                }\\n                token_value[token] = getValue(iss, token_value);\\n            }\\n            if (isValue(iss)) {\\n                result = getValue(iss, token_value);\\n            }\\n        }\\n        iss.get(); // \\')\\'\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    using TokenValue = std::map<std::string, int>;\\n    \\npublic:\\n    int evaluate(const std::string& expression) {\\n        TokenValue token_value;\\n        std::istringstream iss(expression);\\n        return evaluate(iss, token_value);\\n    }\\n\\nprivate:\\n    bool skipSpaces(std::istringstream& iss) const {\\n        while (iss.good() && std::isblank(iss.peek())) {\\n            iss.get();\\n        }\\n        return true;\\n    }\\n\\n    bool isNumber(std::istringstream& iss) {\\n        return skipSpaces(iss) && (std::isdigit(iss.peek()) || iss.peek() == \\'-\\');\\n    }\\n\\n    bool isExpression(std::istringstream& iss) {\\n        return skipSpaces(iss) && iss.peek() == \\'(\\';\\n    }\\n    \\n    bool isValue(std::istringstream& iss) {\\n        return isNumber(iss) || isExpression(iss);\\n    }\\n    \\n    bool isToken(std::istringstream& iss) {\\n        return !isValue(iss);\\n    }\\n    \\n    std::string getToken(std::istringstream& iss) {\\n        skipSpaces(iss);\\n        std::ostringstream oss; // don\\'t mess with \\'))\\'\\n        while (iss.good() && std::isalnum(iss.peek())) {\\n            oss << (char)iss.get();\\n        }\\n        return oss.str();\\n    }\\n    \\n    int getValue(std::istringstream& iss, TokenValue token_value) {\\n        if (isNumber(iss)) {\\n            int result;\\n            iss >> result;\\n            return result;\\n        }\\n        if (isExpression(iss)) {\\n            return evaluate(iss, token_value);\\n        }\\n        return token_value[getToken(iss)];\\n    }\\n\\n    int evaluate(std::istringstream& iss, TokenValue token_value) {\\n        iss.get(); // \\'(\\'\\n        std::string expression;\\n        iss >> expression;\\n        int result = 0;\\n        if (expression == \"add\") {\\n            result = getValue(iss, token_value) + getValue(iss, token_value);\\n        }\\n        if (expression == \"mult\") {\\n            result = getValue(iss, token_value) * getValue(iss, token_value);\\n        }\\n        if (expression == \"let\") {\\n            while (isToken(iss)) {\\n                std::string token = getToken(iss);\\n                if (iss.peek() == \\')\\') {\\n                    result = token_value[token];\\n                    break;\\n                }\\n                token_value[token] = getValue(iss, token_value);\\n            }\\n            if (isValue(iss)) {\\n                result = getValue(iss, token_value);\\n            }\\n        }\\n        iss.get(); // \\')\\'\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1174757,
                "title": "i-love-to-see-those-shitty-solutions-everywhere-give-them-a-try-not-this-one",
                "content": "```\\nfrom enum import Enum\\nfrom copy import deepcopy\\nclass Token(Enum):\\n    INT = 1\\n    VAR = 2\\n    LEFT_PAR = 3\\n    RIGHT_PAR = 4\\n    ADD = 5\\n    MUL = 6\\n    LET = 7\\n\\nclass Tokenizer:\\n    def __init__(self, exp):\\n        self.exp = exp\\n        self.idx = 0\\n        self.size = len(exp)\\n        \\n    def has_next_token(self):\\n        while self.idx < self.size and self.exp[self.idx] == \\' \\':\\n            self.idx += 1\\n        return self.idx < self.size\\n    \\n    def get_next_token(self):\\n        assert (self.has_next_token())\\n        is_negative = False\\n        if self.exp[self.idx] == \\'-\\':\\n            is_negative = True\\n            self.idx += 1\\n        if self.exp[self.idx].isdigit():\\n            next_idx = self.idx\\n            while next_idx < self.size and self.exp[next_idx].isdigit():\\n                next_idx += 1\\n            number = int(self.exp[self.idx:next_idx])\\n            if is_negative:\\n                number = -number\\n            self.idx = next_idx\\n            return (Token.INT, int(number))\\n        else:\\n            if self.exp[self.idx] == \\'(\\':\\n                self.idx += 1\\n                return (Token.LEFT_PAR, None)\\n            elif self.exp[self.idx] == \\')\\':\\n                self.idx += 1\\n                return (Token.RIGHT_PAR, None)\\n            else:\\n                assert (self.exp[self.idx].isalpha())\\n                next_idx = self.idx\\n                while next_idx < self.size and self.exp[next_idx].isalnum():\\n                    next_idx += 1\\n                token_string = self.exp[self.idx:next_idx]\\n                self.idx = next_idx\\n                if token_string == \\'add\\':\\n                    return (Token.ADD, None)\\n                elif token_string == \\'mult\\':\\n                    return (Token.MUL, None)\\n                elif token_string == \\'let\\':\\n                    return (Token.LET, None)\\n                else:\\n                    #print(\"new variable: {}\".format(token_string))\\n                    return (Token.VAR, token_string)\\n\\n# E -> INT | VAR | LEFT_PARA W\\n# W -> ADD E E RIGHT_PARA | MUL E E RIGHT_PARA | LET VAR E M\\n# M -> E ) | VAR E M\\n\\nclass Solution(object):\\n    def evaluate(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: int\\n        \"\"\"\\n        expression = expression.lower()\\n        tokenizer = Tokenizer(expression)\\n        tokens = []\\n        while tokenizer.has_next_token():\\n            tokens.append(tokenizer.get_next_token())\\n        #print(tokens)\\n        self.tokens = tokens\\n        self.idx = 0\\n        self.size = len(self.tokens)\\n        environment = dict()\\n        return self.parse_e(environment)\\n\\n    def look_ahead(self):\\n        assert self.idx < self.size\\n        res = self.tokens[self.idx]\\n        self.idx += 1\\n        return res\\n    \\n    def put_back(self):\\n        self.idx -= 1\\n        return\\n        \\n    def parse_e(self, env):\\n        next_token = self.look_ahead()\\n        if next_token[0] == Token.INT:\\n            return int(next_token[1])\\n        elif next_token[0] == Token.VAR:\\n            assert(next_token[1] in env.keys())\\n            return env[next_token[1]]\\n        else:\\n            assert(next_token[0] == Token.LEFT_PAR)\\n            next_env = deepcopy(env)\\n            return self.parse_w(next_env)\\n    \\n    \\n    def parse_w(self, env):\\n        next_env = deepcopy(env)\\n        next_token = self.look_ahead()\\n        if next_token[0] == Token.ADD:\\n            a = self.parse_e(next_env)\\n            b = self.parse_e(next_env)\\n            res = a + b\\n            next_token = self.look_ahead()\\n            assert(next_token[0] == Token.RIGHT_PAR)\\n            return res\\n        elif next_token[0] == Token.MUL:\\n            a = self.parse_e(next_env)\\n            b = self.parse_e(next_env)\\n            res = a * b\\n            next_token = self.look_ahead()\\n            assert(next_token[0] == Token.RIGHT_PAR)\\n            return res\\n        elif next_token[0] == Token.LET:\\n            var_token = self.look_ahead()\\n            assert(var_token[0] == Token.VAR)\\n            var_value = self.parse_e(next_env)\\n            next_env[var_token[1]] = var_value\\n            return self.parse_m(next_env)\\n        \\n    def parse_m(self, env):\\n        next_env = deepcopy(env)\\n        next_token = self.look_ahead()\\n        if next_token[0] == Token.INT or next_token[0] == Token.LEFT_PAR:\\n            self.put_back()\\n            res = self.parse_e(next_env)\\n            next_token = self.look_ahead()\\n            assert(next_token[0] == Token.RIGHT_PAR)\\n            return res\\n        else:\\n            assert(next_token[0] == Token.VAR)\\n            var_token = next_token\\n            next_token = self.look_ahead()\\n            if next_token[0] == Token.RIGHT_PAR:\\n                self.put_back()\\n                self.put_back()\\n                res = self.parse_e(next_env)\\n                next_token = self.look_ahead()\\n                assert(next_token[0] == Token.RIGHT_PAR)\\n                return res\\n            else:\\n                self.put_back()\\n                var_value = self.parse_e(next_env)\\n                next_env[var_token[1]] = var_value\\n                return self.parse_m(next_env)\\n```\\nIf you major in CS you should understand it.\\nDon\\'t try at home, but in compiler class.",
                "solutionTags": [],
                "code": "```\\nfrom enum import Enum\\nfrom copy import deepcopy\\nclass Token(Enum):\\n    INT = 1\\n    VAR = 2\\n    LEFT_PAR = 3\\n    RIGHT_PAR = 4\\n    ADD = 5\\n    MUL = 6\\n    LET = 7\\n\\nclass Tokenizer:\\n    def __init__(self, exp):\\n        self.exp = exp\\n        self.idx = 0\\n        self.size = len(exp)\\n        \\n    def has_next_token(self):\\n        while self.idx < self.size and self.exp[self.idx] == \\' \\':\\n            self.idx += 1\\n        return self.idx < self.size\\n    \\n    def get_next_token(self):\\n        assert (self.has_next_token())\\n        is_negative = False\\n        if self.exp[self.idx] == \\'-\\':\\n            is_negative = True\\n            self.idx += 1\\n        if self.exp[self.idx].isdigit():\\n            next_idx = self.idx\\n            while next_idx < self.size and self.exp[next_idx].isdigit():\\n                next_idx += 1\\n            number = int(self.exp[self.idx:next_idx])\\n            if is_negative:\\n                number = -number\\n            self.idx = next_idx\\n            return (Token.INT, int(number))\\n        else:\\n            if self.exp[self.idx] == \\'(\\':\\n                self.idx += 1\\n                return (Token.LEFT_PAR, None)\\n            elif self.exp[self.idx] == \\')\\':\\n                self.idx += 1\\n                return (Token.RIGHT_PAR, None)\\n            else:\\n                assert (self.exp[self.idx].isalpha())\\n                next_idx = self.idx\\n                while next_idx < self.size and self.exp[next_idx].isalnum():\\n                    next_idx += 1\\n                token_string = self.exp[self.idx:next_idx]\\n                self.idx = next_idx\\n                if token_string == \\'add\\':\\n                    return (Token.ADD, None)\\n                elif token_string == \\'mult\\':\\n                    return (Token.MUL, None)\\n                elif token_string == \\'let\\':\\n                    return (Token.LET, None)\\n                else:\\n                    #print(\"new variable: {}\".format(token_string))\\n                    return (Token.VAR, token_string)\\n\\n# E -> INT | VAR | LEFT_PARA W\\n# W -> ADD E E RIGHT_PARA | MUL E E RIGHT_PARA | LET VAR E M\\n# M -> E ) | VAR E M\\n\\nclass Solution(object):\\n    def evaluate(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: int\\n        \"\"\"\\n        expression = expression.lower()\\n        tokenizer = Tokenizer(expression)\\n        tokens = []\\n        while tokenizer.has_next_token():\\n            tokens.append(tokenizer.get_next_token())\\n        #print(tokens)\\n        self.tokens = tokens\\n        self.idx = 0\\n        self.size = len(self.tokens)\\n        environment = dict()\\n        return self.parse_e(environment)\\n\\n    def look_ahead(self):\\n        assert self.idx < self.size\\n        res = self.tokens[self.idx]\\n        self.idx += 1\\n        return res\\n    \\n    def put_back(self):\\n        self.idx -= 1\\n        return\\n        \\n    def parse_e(self, env):\\n        next_token = self.look_ahead()\\n        if next_token[0] == Token.INT:\\n            return int(next_token[1])\\n        elif next_token[0] == Token.VAR:\\n            assert(next_token[1] in env.keys())\\n            return env[next_token[1]]\\n        else:\\n            assert(next_token[0] == Token.LEFT_PAR)\\n            next_env = deepcopy(env)\\n            return self.parse_w(next_env)\\n    \\n    \\n    def parse_w(self, env):\\n        next_env = deepcopy(env)\\n        next_token = self.look_ahead()\\n        if next_token[0] == Token.ADD:\\n            a = self.parse_e(next_env)\\n            b = self.parse_e(next_env)\\n            res = a + b\\n            next_token = self.look_ahead()\\n            assert(next_token[0] == Token.RIGHT_PAR)\\n            return res\\n        elif next_token[0] == Token.MUL:\\n            a = self.parse_e(next_env)\\n            b = self.parse_e(next_env)\\n            res = a * b\\n            next_token = self.look_ahead()\\n            assert(next_token[0] == Token.RIGHT_PAR)\\n            return res\\n        elif next_token[0] == Token.LET:\\n            var_token = self.look_ahead()\\n            assert(var_token[0] == Token.VAR)\\n            var_value = self.parse_e(next_env)\\n            next_env[var_token[1]] = var_value\\n            return self.parse_m(next_env)\\n        \\n    def parse_m(self, env):\\n        next_env = deepcopy(env)\\n        next_token = self.look_ahead()\\n        if next_token[0] == Token.INT or next_token[0] == Token.LEFT_PAR:\\n            self.put_back()\\n            res = self.parse_e(next_env)\\n            next_token = self.look_ahead()\\n            assert(next_token[0] == Token.RIGHT_PAR)\\n            return res\\n        else:\\n            assert(next_token[0] == Token.VAR)\\n            var_token = next_token\\n            next_token = self.look_ahead()\\n            if next_token[0] == Token.RIGHT_PAR:\\n                self.put_back()\\n                self.put_back()\\n                res = self.parse_e(next_env)\\n                next_token = self.look_ahead()\\n                assert(next_token[0] == Token.RIGHT_PAR)\\n                return res\\n            else:\\n                self.put_back()\\n                var_value = self.parse_e(next_env)\\n                next_env[var_token[1]] = var_value\\n                return self.parse_m(next_env)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1119004,
                "title": "testcases-needed",
                "content": "I have made 3 accepted submissions to this problem. But after further testing, my first solution crashed on my own case\\n\\n\"(let y 2 x (let q 2 z y 2) x)\"\\n\\nand the second crashed on the case\\n\\n\"(let foo 2 foo foo foo (let bar (let bar 4 foo 7 (add bar bar)) (mult foo bar)) foo foo foo)\"\\n\\nThe built-in \"Run Code\" judge has no problem with either one of these, but it looks like the submission judge is reporting some false positives.\\n\\nThank you!",
                "solutionTags": [],
                "code": "I have made 3 accepted submissions to this problem. But after further testing, my first solution crashed on my own case\\n\\n\"(let y 2 x (let q 2 z y 2) x)\"\\n\\nand the second crashed on the case\\n\\n\"(let foo 2 foo foo foo (let bar (let bar 4 foo 7 (add bar bar)) (mult foo bar)) foo foo foo)\"\\n\\nThe built-in \"Run Code\" judge has no problem with either one of these, but it looks like the submission judge is reporting some false positives.\\n\\nThank you!",
                "codeTag": "Unknown"
            },
            {
                "id": 989989,
                "title": "javascript-rescursion-100-100",
                "content": "```\\n/**\\n * @param {string} expression\\n * @return {number}\\n */\\nvar evaluate = function (expression) {\\n  class Scope {\\n    /**\\n     * \\n     * @param {Scope} parent \\n     */\\n    constructor(parent) {\\n      this.vars = {}\\n      this.parent = parent\\n    }\\n\\n    getVar(name) {\\n      let t = this\\n      while (t) {\\n        if (t.vars.hasOwnProperty(name)) return t.vars[name]\\n        t = t.parent\\n      }\\n      throw `var ${name} not found in any scope`\\n    }\\n    setVar(name, value) {\\n      this.vars[name] = value\\n    }\\n  }\\n\\n  const words = expression\\n    .split(\\'(\\').join(\\'( \\')\\n    .split(\\')\\').join(\\' )\\')\\n    .split(\\' \\'),\\n    KEYWORDS = {\\n      let: 1,\\n      mult: 2,\\n      add: 3,\\n    },\\n    STATES = {\\n      init: 0,\\n      ...KEYWORDS,\\n      letOrVal: 4,\\n    }\\n  let i = 0\\n\\n  return parse()\\n\\n  /**\\n   * \\n   * @param {Scope} parentScope \\n   */\\n  function parse(parentScope) {\\n    let curScope = new Scope(parentScope), state = STATES.init\\n    if (words[i] != \\'(\\') {\\n      let val = /^-?\\\\d+$/.test(words[i])\\n        ? Number.parseInt(words[i])\\n        : curScope.getVar(words[i])\\n      i++\\n      return val\\n    }\\n    i++\\n    outer:\\n    while (i < words.length) {\\n      let word = words[i]\\n      switch (state) {\\n        case STATES.init:\\n          state = STATES[word]\\n          break\\n        case STATES.add:\\n          {\\n            let v1 = parse(curScope), v2 = parse(curScope)\\n            i++ // skip \\')\\'\\n            return v1 + v2\\n          }\\n        case STATES.mult:\\n          {\\n            let v1 = parse(curScope), v2 = parse(curScope)\\n            i++ // skip \\')\\'\\n            return v1 * v2\\n          }\\n        case STATES.letOrVal:\\n          if (!/^[a-z]/.test(word) || words[i + 1] == \\')\\') {\\n            let rtn = parse(curScope)\\n            i++\\n            return rtn\\n          }\\n        // not breaking, go to let\\n        case STATES.let:\\n          let name = word\\n          i++\\n          let value = parse(curScope)\\n          curScope.setVar(name, value)\\n          state = STATES.letOrVal\\n          continue outer\\n      }\\n      i++\\n    }\\n  }\\n};\\n\\n// console.log(evaluate(`(let x 2 (add (let x 3 (let x 4 x)) x))`))\\n// console.log(evaluate(\"(let x 7 -12)\"))\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} expression\\n * @return {number}\\n */\\nvar evaluate = function (expression) {\\n  class Scope {\\n    /**\\n     * \\n     * @param {Scope} parent \\n     */\\n    constructor(parent) {\\n      this.vars = {}\\n      this.parent = parent\\n    }\\n\\n    getVar(name) {\\n      let t = this\\n      while (t) {\\n        if (t.vars.hasOwnProperty(name)) return t.vars[name]\\n        t = t.parent\\n      }\\n      throw `var ${name} not found in any scope`\\n    }\\n    setVar(name, value) {\\n      this.vars[name] = value\\n    }\\n  }\\n\\n  const words = expression\\n    .split(\\'(\\').join(\\'( \\')\\n    .split(\\')\\').join(\\' )\\')\\n    .split(\\' \\'),\\n    KEYWORDS = {\\n      let: 1,\\n      mult: 2,\\n      add: 3,\\n    },\\n    STATES = {\\n      init: 0,\\n      ...KEYWORDS,\\n      letOrVal: 4,\\n    }\\n  let i = 0\\n\\n  return parse()\\n\\n  /**\\n   * \\n   * @param {Scope} parentScope \\n   */\\n  function parse(parentScope) {\\n    let curScope = new Scope(parentScope), state = STATES.init\\n    if (words[i] != \\'(\\') {\\n      let val = /^-?\\\\d+$/.test(words[i])\\n        ? Number.parseInt(words[i])\\n        : curScope.getVar(words[i])\\n      i++\\n      return val\\n    }\\n    i++\\n    outer:\\n    while (i < words.length) {\\n      let word = words[i]\\n      switch (state) {\\n        case STATES.init:\\n          state = STATES[word]\\n          break\\n        case STATES.add:\\n          {\\n            let v1 = parse(curScope), v2 = parse(curScope)\\n            i++ // skip \\')\\'\\n            return v1 + v2\\n          }\\n        case STATES.mult:\\n          {\\n            let v1 = parse(curScope), v2 = parse(curScope)\\n            i++ // skip \\')\\'\\n            return v1 * v2\\n          }\\n        case STATES.letOrVal:\\n          if (!/^[a-z]/.test(word) || words[i + 1] == \\')\\') {\\n            let rtn = parse(curScope)\\n            i++\\n            return rtn\\n          }\\n        // not breaking, go to let\\n        case STATES.let:\\n          let name = word\\n          i++\\n          let value = parse(curScope)\\n          curScope.setVar(name, value)\\n          state = STATES.letOrVal\\n          continue outer\\n      }\\n      i++\\n    }\\n  }\\n};\\n\\n// console.log(evaluate(`(let x 2 (add (let x 3 (let x 4 x)) x))`))\\n// console.log(evaluate(\"(let x 7 -12)\"))\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 987099,
                "title": "python-3-bnf-grammar",
                "content": "```\\nclass Solution:\\n    def evaluate(self, s: str) -> int:\\n        \\n        s += \"$\"\\n        \\n        i = 0\\n        d = defaultdict(list)\\n        \\n        def EXPR():\\n            nonlocal i\\n            \\n            if s[i] == \"(\":\\n                if s.startswith(\"add \", i+1):\\n                    return ADD()\\n                elif s.startswith(\"mult \", i+1):\\n                    return MULT()\\n                else:\\n                    return LET()\\n            else:\\n                if s[i].isalpha():\\n                    return VARIABLE()\\n                else:\\n                    return INTEGER()\\n        \\n        def INTEGER():\\n            nonlocal i\\n            \\n            j = i\\n            while s[j] in \"-0123456789\":\\n                j += 1\\n                \\n            ret = int(s[i:j])\\n            i = j\\n            \\n            return ret\\n        \\n        \\n        def name():\\n            nonlocal i\\n            \\n            ret = \"\"\\n            \\n            while s[i].isalpha() or s[i].isdigit():\\n                ret += s[i]\\n                i += 1\\n                \\n            return ret\\n        \\n        def VARIABLE():\\n            nonlocal i\\n            return d[name()][-1]\\n            \\n        def ADD():\\n            nonlocal i\\n            \\n            i += 5\\n            left = EXPR()\\n            i += 1\\n            right = EXPR()\\n            i += 1\\n            return left + right\\n            \\n        \\n        def MULT():\\n            nonlocal i\\n            \\n            i += 6\\n            left = EXPR()\\n            i += 1\\n            right = EXPR()\\n            i += 1\\n            return left * right\\n            \\n        \\n        def LET():\\n            nonlocal i\\n            \\n            i += 5\\n            \\n            shadow_times = Counter()\\n            \\n            var_expr = False\\n            \\n            while s[i].isalpha():\\n                \\n                var = name()\\n                \\n                # disambiguating between vn and expr\\n                if s[i] == \")\":\\n                    var_expr = True\\n                    break\\n                \\n                i += 1\\n                value = EXPR()\\n                i += 1\\n                \\n                shadow_times[var] += 1\\n                d[var].append(value)\\n            \\n            \\n            if var_expr:\\n                ret = d[var][-1]\\n            else:\\n                ret = EXPR()\\n                \\n            for k,times in shadow_times.items():\\n                for _ in range(times):\\n                    d[k].pop()\\n            \\n            i += 1\\n            \\n            return ret\\n            \\n        return EXPR()\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def evaluate(self, s: str) -> int:\\n        \\n        s += \"$\"\\n        \\n        i = 0\\n        d = defaultdict(list)\\n        \\n        def EXPR():\\n            nonlocal i\\n            \\n            if s[i] == \"(\":\\n                if s.startswith(\"add \", i+1):\\n                    return ADD()\\n                elif s.startswith(\"mult \", i+1):\\n                    return MULT()\\n                else:\\n                    return LET()\\n            else:\\n                if s[i].isalpha():\\n                    return VARIABLE()\\n                else:\\n                    return INTEGER()\\n        \\n        def INTEGER():\\n            nonlocal i\\n            \\n            j = i\\n            while s[j] in \"-0123456789\":\\n                j += 1\\n                \\n            ret = int(s[i:j])\\n            i = j\\n            \\n            return ret\\n        \\n        \\n        def name():\\n            nonlocal i\\n            \\n            ret = \"\"\\n            \\n            while s[i].isalpha() or s[i].isdigit():\\n                ret += s[i]\\n                i += 1\\n                \\n            return ret\\n        \\n        def VARIABLE():\\n            nonlocal i\\n            return d[name()][-1]\\n            \\n        def ADD():\\n            nonlocal i\\n            \\n            i += 5\\n            left = EXPR()\\n            i += 1\\n            right = EXPR()\\n            i += 1\\n            return left + right\\n            \\n        \\n        def MULT():\\n            nonlocal i\\n            \\n            i += 6\\n            left = EXPR()\\n            i += 1\\n            right = EXPR()\\n            i += 1\\n            return left * right\\n            \\n        \\n        def LET():\\n            nonlocal i\\n            \\n            i += 5\\n            \\n            shadow_times = Counter()\\n            \\n            var_expr = False\\n            \\n            while s[i].isalpha():\\n                \\n                var = name()\\n                \\n                # disambiguating between vn and expr\\n                if s[i] == \")\":\\n                    var_expr = True\\n                    break\\n                \\n                i += 1\\n                value = EXPR()\\n                i += 1\\n                \\n                shadow_times[var] += 1\\n                d[var].append(value)\\n            \\n            \\n            if var_expr:\\n                ret = d[var][-1]\\n            else:\\n                ret = EXPR()\\n                \\n            for k,times in shadow_times.items():\\n                for _ in range(times):\\n                    d[k].pop()\\n            \\n            i += 1\\n            \\n            return ret\\n            \\n        return EXPR()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 978321,
                "title": "o-n-python-solution",
                "content": "```python\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        \\n        def get_next_token(i):\\n            while i < len(expression) and expression[i] == \\' \\':\\n                i += 1\\n            if i >= len(expression):\\n                return None, i + 1\\n            if expression[i] in {\\'(\\', \\')\\'}:\\n                return expression[i], i + 1\\n            else:\\n                j = i + 1\\n                while j < len(expression) and expression[j] not in {\\' \\', \\')\\'}:\\n                    j += 1\\n                res = expression[i:j]\\n                try:\\n                    res = int(res)\\n                except Exception:\\n                    pass\\n                return res, j\\n            raise ValueError\\n        \\n        def eval_exp(i, **kwargs):\\n            var_dict = kwargs.copy()\\n            exp_type = None\\n            operants = []\\n            eval_val = None\\n            has_let = False\\n            seen_var = False\\n            while i < len(expression):\\n                token, i = get_next_token(i)\\n                if token is None:\\n                    return eval_val, i\\n                elif token == \\')\\':\\n                    return eval_val, i\\n                if token == \\'(\\':\\n                    token, i = eval_exp(i, **var_dict)\\n                if token in {\\'mult\\', \\'add\\'}:\\n                    exp_type = token\\n                elif token == \\'let\\':\\n                    has_let = True\\n                else:  # normal variable or numbers\\n                    if has_let:\\n                        if isinstance(token, (float, int)):\\n                            if seen_var:\\n                                var_dict[var_name] = token\\n                                seen_var = False\\n                            eval_val = token\\n                        else:\\n                            var_name = token\\n                            seen_var = True\\n                            if var_name in var_dict:\\n                                eval_val = var_dict[token]\\n                    elif exp_type is not None:\\n                        if isinstance(token, (float, int)):\\n                            operants.append(token)\\n                        else:\\n                            operants.append(var_dict[token])\\n                        if len(operants) == 2:\\n                            if exp_type == \\'add\\':\\n                                eval_val = operants[0] + operants[1]\\n                            elif exp_type == \\'mult\\':\\n                                eval_val = operants[0] * operants[1]\\n                            else:\\n                                raise ValueError\\n                            operants = []\\n                    else:\\n                        eval_val = token\\n            return eval_val, i\\n                \\n        res, _ = eval_exp(0)\\n        return res\\n\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        \\n        def get_next_token(i):\\n            while i < len(expression) and expression[i] == \\' \\':\\n                i += 1\\n            if i >= len(expression):\\n                return None, i + 1\\n            if expression[i] in {\\'(\\', \\')\\'}:\\n                return expression[i], i + 1\\n            else:\\n                j = i + 1\\n                while j < len(expression) and expression[j] not in {\\' \\', \\')\\'}:\\n                    j += 1\\n                res = expression[i:j]\\n                try:\\n                    res = int(res)\\n                except Exception:\\n                    pass\\n                return res, j\\n            raise ValueError\\n        \\n        def eval_exp(i, **kwargs):\\n            var_dict = kwargs.copy()\\n            exp_type = None\\n            operants = []\\n            eval_val = None\\n            has_let = False\\n            seen_var = False\\n            while i < len(expression):\\n                token, i = get_next_token(i)\\n                if token is None:\\n                    return eval_val, i\\n                elif token == \\')\\':\\n                    return eval_val, i\\n                if token == \\'(\\':\\n                    token, i = eval_exp(i, **var_dict)\\n                if token in {\\'mult\\', \\'add\\'}:\\n                    exp_type = token\\n                elif token == \\'let\\':\\n                    has_let = True\\n                else:  # normal variable or numbers\\n                    if has_let:\\n                        if isinstance(token, (float, int)):\\n                            if seen_var:\\n                                var_dict[var_name] = token\\n                                seen_var = False\\n                            eval_val = token\\n                        else:\\n                            var_name = token\\n                            seen_var = True\\n                            if var_name in var_dict:\\n                                eval_val = var_dict[token]\\n                    elif exp_type is not None:\\n                        if isinstance(token, (float, int)):\\n                            operants.append(token)\\n                        else:\\n                            operants.append(var_dict[token])\\n                        if len(operants) == 2:\\n                            if exp_type == \\'add\\':\\n                                eval_val = operants[0] + operants[1]\\n                            elif exp_type == \\'mult\\':\\n                                eval_val = operants[0] * operants[1]\\n                            else:\\n                                raise ValueError\\n                            operants = []\\n                    else:\\n                        eval_val = token\\n            return eval_val, i\\n                \\n        res, _ = eval_exp(0)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 972666,
                "title": "python3-single-pass-eager-evaluator",
                "content": "```\\nfrom operator import add, mul as mult\\n\\nclass Solution:\\n    def __init__(self):\\n        self.let = lambda x: x\\n        self.opers = {\\'add\\': add, \\'mult\\': mul, \\'let\\': self.let}\\n        \\n    def parseAlphaNum(self, expr, i):\\n        name = expr[i]\\n        i += 1\\n        while i < len(expr) and expr[i].isalnum():\\n            name += expr[i]\\n            i += 1\\n        return name, i - 1\\n    \\n    def parseSign(self, expr, i):\\n        if expr[i] == \\'-\\':\\n            sign = -1\\n            i += 1\\n        else:\\n            sign = +1\\n        return sign, i\\n    \\n    def resolve(self, varname, scopes):        \\n        for sco in reversed(scopes):\\n            value = sco.get(varname, None)\\n            if value is not None:\\n                return value\\n        raise ValueError(\\'Could not resolve variable %s\\' % varname)\\n        \\n    def setVar(self, ops, args, scopes):\\n        if ops and ops[-1] == self.let and len(args[-1]) > 1 and type(args[-1][-2]) == str:\\n            value, varname = args[-1].pop(), args[-1].pop()\\n            scopes[-1][varname] = value\\n            \\n    def handleVarname(self, expr, i, ops, args, scopes, spc):\\n        varname, i = self.parseAlphaNum(expr, i)\\n        isBinding = ops[-1] == self.let and spc[-1] % 2 == 1 and \\\\\\n            not (i < len(expr) - 1 and expr[i+1] == \\')\\')\\n        if isBinding:            \\n            args[-1].append(varname)            \\n        else:            \\n            value = self.resolve(varname, scopes)\\n            args[-1].append(value)\\n        return not isBinding, i\\n                    \\n    def evaluate(self, expr: str) -> int:   \\n        ops, args, scopes, spc = [None], [[]], [{}], [0]\\n        i = 0\\n        while i < len(expr):\\n            c = expr[i]\\n            justEval = False\\n            if c == \\'(\\':\\n                opname, i = self.parseAlphaNum(expr, i+1)\\n                ops.append(self.opers[opname])        \\n                args.append([])                \\n                scopes.append({})            \\n                spc.append(0)\\n            elif c == \\')\\':\\n                f, xs = ops.pop(), args.pop()\\n                value = f(*xs)\\n                args[-1].append(value)\\n                scopes.pop()\\n                spc.pop()\\n                justEval = True\\n            elif c.isalpha():                \\n                justEval, i = self.handleVarname(expr, i, ops, args, scopes, spc)\\n            elif c == \\'-\\' or c.isdigit():\\n                sign, i = self.parseSign(expr, i)\\n                valueStr, i = self.parseAlphaNum(expr, i)\\n                args[-1].append(sign * int(valueStr))\\n                justEval = True\\n            elif c == \\' \\':\\n                spc[-1] += 1\\n            if justEval:\\n                self.setVar(ops, args, scopes)\\n            i += 1\\n        return args[-1][0]        \\n```",
                "solutionTags": [],
                "code": "```\\nfrom operator import add, mul as mult\\n\\nclass Solution:\\n    def __init__(self):\\n        self.let = lambda x: x\\n        self.opers = {\\'add\\': add, \\'mult\\': mul, \\'let\\': self.let}\\n        \\n    def parseAlphaNum(self, expr, i):\\n        name = expr[i]\\n        i += 1\\n        while i < len(expr) and expr[i].isalnum():\\n            name += expr[i]\\n            i += 1\\n        return name, i - 1\\n    \\n    def parseSign(self, expr, i):\\n        if expr[i] == \\'-\\':\\n            sign = -1\\n            i += 1\\n        else:\\n            sign = +1\\n        return sign, i\\n    \\n    def resolve(self, varname, scopes):        \\n        for sco in reversed(scopes):\\n            value = sco.get(varname, None)\\n            if value is not None:\\n                return value\\n        raise ValueError(\\'Could not resolve variable %s\\' % varname)\\n        \\n    def setVar(self, ops, args, scopes):\\n        if ops and ops[-1] == self.let and len(args[-1]) > 1 and type(args[-1][-2]) == str:\\n            value, varname = args[-1].pop(), args[-1].pop()\\n            scopes[-1][varname] = value\\n            \\n    def handleVarname(self, expr, i, ops, args, scopes, spc):\\n        varname, i = self.parseAlphaNum(expr, i)\\n        isBinding = ops[-1] == self.let and spc[-1] % 2 == 1 and \\\\\\n            not (i < len(expr) - 1 and expr[i+1] == \\')\\')\\n        if isBinding:            \\n            args[-1].append(varname)            \\n        else:            \\n            value = self.resolve(varname, scopes)\\n            args[-1].append(value)\\n        return not isBinding, i\\n                    \\n    def evaluate(self, expr: str) -> int:   \\n        ops, args, scopes, spc = [None], [[]], [{}], [0]\\n        i = 0\\n        while i < len(expr):\\n            c = expr[i]\\n            justEval = False\\n            if c == \\'(\\':\\n                opname, i = self.parseAlphaNum(expr, i+1)\\n                ops.append(self.opers[opname])        \\n                args.append([])                \\n                scopes.append({})            \\n                spc.append(0)\\n            elif c == \\')\\':\\n                f, xs = ops.pop(), args.pop()\\n                value = f(*xs)\\n                args[-1].append(value)\\n                scopes.pop()\\n                spc.pop()\\n                justEval = True\\n            elif c.isalpha():                \\n                justEval, i = self.handleVarname(expr, i, ops, args, scopes, spc)\\n            elif c == \\'-\\' or c.isdigit():\\n                sign, i = self.parseSign(expr, i)\\n                valueStr, i = self.parseAlphaNum(expr, i)\\n                args[-1].append(sign * int(valueStr))\\n                justEval = True\\n            elif c == \\' \\':\\n                spc[-1] += 1\\n            if justEval:\\n                self.setVar(ops, args, scopes)\\n            i += 1\\n        return args[-1][0]        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 963892,
                "title": "java-o-n-modulize-recursion-with-hashmap",
                "content": "paren():  to handle \\'(\\' - determine \"mult\" or \"add\" or \"let\", also make copy of map.\\nlet(): handle \"let\" operation\\nadd(): handle \"mult\" and \"add\" operation\\n\\n```\\nclass Solution {\\n    int ptr = 0;\\n    String exp;\\n    public int evaluate(String expression) {\\n        exp = expression;\\n        return paren(new HashMap<>());\\n    }\\n    \\n    int paren(HashMap<String, Integer> map){\\n        ptr++; //\"(\"\\n        \\n        HashMap<String, Integer> copy = new HashMap<>(map);\\n        int res = 0;\\n        String op = \"\";\\n        while(exp.charAt(ptr) != \\' \\'){\\n            op += exp.charAt(ptr++);\\n        }\\n        \\n        ptr++; //\"(space)\"\\n        if(op.equals(\"let\")){\\n            res = let(copy);\\n        } else if(op.equals(\"add\")){\\n            res = add(copy, true);\\n        } else if(op.equals(\"mult\")){\\n            res = add(copy, false);\\n        }\\n        \\n        return res;\\n    }\\n    \\n    int let(HashMap<String, Integer> map){\\n        String key = \"\";\\n        String val = \"\";\\n        boolean KV = false;\\n        \\n        while(exp.charAt(ptr) != \\')\\'){\\n            char c = exp.charAt(ptr);\\n            if(c == \\'(\\'){\\n                val = String.valueOf(paren(map));\\n            } else if(c == \\' \\'){\\n                if(KV){\\n                    Integer v = map.get(val) != null ? \\n                        map.get(val) : Integer.valueOf(val);\\n                    \\n                    map.put(key, v);\\n                    key = \"\";\\n                    val = \"\";\\n                }\\n                KV = !KV;\\n            } else if(!KV){\\n                key += c;    \\n            } else {\\n                val += c;\\n            }\\n            ptr++;\\n        }\\n        \\n        if(key.length() > 0)\\n            return map.get(key) != null ? map.get(key) : Integer.valueOf(key);\\n        \\n        return Integer.valueOf(val);\\n    }\\n    \\n    int add(HashMap<String, Integer> map, boolean AM){\\n        String a = \"\";\\n        String b = \"\";\\n        boolean AB = false;\\n        \\n        while(exp.charAt(ptr) != \\')\\'){\\n            char c = exp.charAt(ptr);\\n            if(c == \\'(\\'){\\n                if(!AB)\\n                    a = String.valueOf(paren(map));\\n                else\\n                    b = String.valueOf(paren(map));\\n            } else if(c == \\' \\'){\\n                AB = !AB;\\n            } else if(!AB){\\n                a += c;    \\n            } else {\\n                b += c;\\n            }\\n            ptr++;\\n        }\\n        \\n        int va = map.get(a) != null ? map.get(a) : Integer.valueOf(a);\\n        int vb = map.get(b) != null ? map.get(b) : Integer.valueOf(b);\\n        return AM ? \\n            va + vb : va * vb;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n    int ptr = 0;\\n    String exp;\\n    public int evaluate(String expression) {\\n        exp = expression;\\n        return paren(new HashMap<>());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 956405,
                "title": "a-clean-java-solution",
                "content": "```\\nclass Solution {\\n    public int evaluate(String expression) {\\n        return eval(expression, new HashMap<>());   \\n    }\\n    \\n    public int eval(String s, Map<String, Integer> outsiderMap) {\\n        char c = s.charAt(0);\\n        if(c == \\'(\\') {\\n            Map<String, Integer> map = new HashMap<>(outsiderMap);\\n            List<String> list = parse(s.substring(1, s.length() - 1));\\n            String op = list.get(0);\\n            if(op.equals(\"let\")) {\\n                int k = 1;\\n                while(k < list.size() - 1) {\\n                    map.put(list.get(k), eval(list.get(k + 1), map));\\n                    k += 2;\\n                }\\n                return eval(list.get(k), map);\\n            } else if(op.equals(\"mult\")) {\\n                return eval(list.get(1), map) * eval(list.get(2), map);\\n            } else if(op.equals(\"add\")) {\\n                return eval(list.get(1), map) + eval(list.get(2), map);\\n            }\\n        } else if(Character.isLowerCase(c)) {\\n            return outsiderMap.get(s);\\n        }\\n        \\n        return Integer.parseInt(s);\\n    }\\n    \\n    public List<String> parse(String s) {\\n        int i = 0;\\n        List<String> list = new ArrayList<>();\\n        while(i < s.length()) {\\n            int j = i + 1;\\n            if(s.charAt(i) == \\'(\\') {\\n                int count = 1;\\n                while(count > 0) {\\n                    if(s.charAt(j) == \\'(\\') count++;\\n                    else if(s.charAt(j) == \\')\\') count--;\\n                    j++;\\n                }\\n            } else {\\n                while(j < s.length() && s.charAt(j) != \\' \\') j++;\\n            }\\n            list.add(s.substring(i, j));\\n            i = j + 1;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int evaluate(String expression) {\\n        return eval(expression, new HashMap<>());   \\n    }\\n    \\n    public int eval(String s, Map<String, Integer> outsiderMap) {\\n        char c = s.charAt(0);\\n        if(c == \\'(\\') {\\n            Map<String, Integer> map = new HashMap<>(outsiderMap);\\n            List<String> list = parse(s.substring(1, s.length() - 1));\\n            String op = list.get(0);\\n            if(op.equals(\"let\")) {\\n                int k = 1;\\n                while(k < list.size() - 1) {\\n                    map.put(list.get(k), eval(list.get(k + 1), map));\\n                    k += 2;\\n                }\\n                return eval(list.get(k), map);\\n            } else if(op.equals(\"mult\")) {\\n                return eval(list.get(1), map) * eval(list.get(2), map);\\n            } else if(op.equals(\"add\")) {\\n                return eval(list.get(1), map) + eval(list.get(2), map);\\n            }\\n        } else if(Character.isLowerCase(c)) {\\n            return outsiderMap.get(s);\\n        }\\n        \\n        return Integer.parseInt(s);\\n    }\\n    \\n    public List<String> parse(String s) {\\n        int i = 0;\\n        List<String> list = new ArrayList<>();\\n        while(i < s.length()) {\\n            int j = i + 1;\\n            if(s.charAt(i) == \\'(\\') {\\n                int count = 1;\\n                while(count > 0) {\\n                    if(s.charAt(j) == \\'(\\') count++;\\n                    else if(s.charAt(j) == \\')\\') count--;\\n                    j++;\\n                }\\n            } else {\\n                while(j < s.length() && s.charAt(j) != \\' \\') j++;\\n            }\\n            list.add(s.substring(i, j));\\n            i = j + 1;\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 952544,
                "title": "simple-dfs-beats-98",
                "content": "```\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        \\n        expression = expression.strip().lower().replace(\\'(\\', \\'( \\').replace(\\')\\', \\' )\\').split(\\' \\')                \\n        \\n        def recurse (i, curr_map): \\n            if expression[i] != \\'(\\': \\n                if expression[i].isdigit(): \\n                    return int (expression[i]), i+1\\n                elif expression[i][0]==\\'-\\' and expression[i][1:].isdigit():\\n                    return -1*int(expression[i][1:]), i+1\\n                return int(curr_map[expression[i]]), i+1\\n            \\n            i+=1\\n            if expression[i] == \\'add\\':\\n                \\n                prev_map = curr_map.copy()\\n                val1, i  = recurse(i+1, curr_map) \\n                curr_map = prev_map\\n                  \\n                prev_map = curr_map.copy()\\n                val2, i  =   recurse (i, curr_map)\\n                curr_map = prev_map\\n                \\n                assert (expression[i] == \\')\\')\\n                return val1+val2, i+1 \\n            if expression[i] == \\'mult\\':\\n                \\n                prev_map = curr_map.copy()\\n                val1, i  = recurse(i+1, curr_map)\\n                curr_map = prev_map\\n                \\n                prev_map = curr_map.copy()\\n                val2, i  =   recurse (i, curr_map)\\n                curr_map = prev_map\\n                \\n                assert (expression[i] == \\')\\')\\n                return val1*val2, i+1\\n            if expression[i] == \\'let\\':\\n                let_end = False \\n                i+=1 \\n                prev_map = curr_map.copy()\\n                while let_end == False: \\n                    if ord(\\'a\\') <= ord(expression[i][0]) <= ord(\\'z\\') and expression[i+1] != \\')\\':\\n                        key = expression[i]\\n                        \\n                        prev_map = curr_map.copy()\\n                        val, i = recurse(i+1, curr_map)\\n                        curr_map = prev_map \\n                        \\n                        curr_map[key] = val \\n                        \\n                    else: \\n                        let_end = True \\n                \\n                prev_map = curr_map.copy()\\n                val, i= recurse(i, curr_map)\\n                curr_map = prev_map \\n                \\n                return val, i+1 \\n                \\n            \\n        ans =  recurse (0, {})\\n        return ans[0]\\n            \\n            \\n        \\n                \\n                \\n                \\n                \\n        \\n                \\n                \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def evaluate(self, expression: str) -> int:\\n        \\n        expression = expression.strip().lower().replace(\\'(\\', \\'( \\').replace(\\')\\', \\' )\\').split(\\' \\')                \\n        \\n        def recurse (i, curr_map): \\n            if expression[i] != \\'(\\': \\n                if expression[i].isdigit(): \\n                    return int (expression[i]), i+1\\n                elif expression[i][0]==\\'-\\' and expression[i][1:].isdigit():\\n                    return -1*int(expression[i][1:]), i+1\\n                return int(curr_map[expression[i]]), i+1\\n            \\n            i+=1\\n            if expression[i] == \\'add\\':\\n                \\n                prev_map = curr_map.copy()\\n                val1, i  = recurse(i+1, curr_map) \\n                curr_map = prev_map\\n                  \\n                prev_map = curr_map.copy()\\n                val2, i  =   recurse (i, curr_map)\\n                curr_map = prev_map\\n                \\n                assert (expression[i] == \\')\\')\\n                return val1+val2, i+1 \\n            if expression[i] == \\'mult\\':\\n                \\n                prev_map = curr_map.copy()\\n                val1, i  = recurse(i+1, curr_map)\\n                curr_map = prev_map\\n                \\n                prev_map = curr_map.copy()\\n                val2, i  =   recurse (i, curr_map)\\n                curr_map = prev_map\\n                \\n                assert (expression[i] == \\')\\')\\n                return val1*val2, i+1\\n            if expression[i] == \\'let\\':\\n                let_end = False \\n                i+=1 \\n                prev_map = curr_map.copy()\\n                while let_end == False: \\n                    if ord(\\'a\\') <= ord(expression[i][0]) <= ord(\\'z\\') and expression[i+1] != \\')\\':\\n                        key = expression[i]\\n                        \\n                        prev_map = curr_map.copy()\\n                        val, i = recurse(i+1, curr_map)\\n                        curr_map = prev_map \\n                        \\n                        curr_map[key] = val \\n                        \\n                    else: \\n                        let_end = True \\n                \\n                prev_map = curr_map.copy()\\n                val, i= recurse(i, curr_map)\\n                curr_map = prev_map \\n                \\n                return val, i+1 \\n                \\n            \\n        ans =  recurse (0, {}",
                "codeTag": "Java"
            },
            {
                "id": 949672,
                "title": "go",
                "content": "```\\nfunc evaluate(expression string) int {\\n    return eval(expression, make(map[string]int))\\n}\\n\\nfunc eval(e string, env map[string]int) int {\\n    if len(e) == 0 {\\n        panic(e)\\n    }\\n    \\n    if e[0] != \\'(\\' {\\n        if (e[0] >= \\'0\\' && e[0] <= \\'9\\') || e[0] == \\'-\\' {\\n            res, err := strconv.Atoi(e)\\n            if err != nil {\\n                panic(err)\\n            }\\n           return res\\n       } else {\\n           if res, ok := env[e]; !ok {\\n               panic(e)\\n           } else {\\n               return res\\n           }\\n       }\\n    }  \\n    \\n    list := parse(e)\\n    \\n    newenv := make(map[string]int)\\n    for k, v := range env {\\n        newenv[k] = v\\n    }\\n    \\n    if list[0] == \"add\" {\\n        if len(list) != 3 {\\n            panic(\"add\")\\n        }\\n        return eval(list[1], newenv) + eval(list[2], newenv)\\n    }\\n    \\n    if list[0] == \"mult\" {\\n        if len(list) != 3 {\\n            panic(\"mult\")\\n        }\\n        return eval(list[1], newenv) * eval(list[2], newenv)\\n    }\\n    \\n    if list[0] == \"let\" {\\n        for i := 1; i < len(list) - 1; i += 2 {\\n            val := eval(list[i + 1], newenv)\\n            newenv[list[i]] = val\\n        }\\n        return eval(list[len(list) - 1], newenv)\\n    }\\n    \\n    panic(\"unsupported method\")\\n    return 0\\n}\\n\\nfunc parse(e string) []string {\\n    var res []string\\n    var b bytes.Buffer\\n    e = e[1:len(e) - 1] + \" \"\\n    i := 0\\n    for i < len(e) {\\n        if e[i] == \\' \\' {\\n            res = append(res, b.String())\\n            b.Reset()\\n            i++\\n        } else if e[i] == \\'(\\' {\\n            flag := 0\\n            j := i + 1\\n            for !(flag == 0 && e[j] == \\')\\') {\\n                if e[j] == \\'(\\' {\\n                    flag++\\n                } else if e[j] == \\')\\' {\\n                    flag--\\n                }\\n                j++\\n            }\\n            b.WriteString(e[i:j + 1])\\n            i = j + 1\\n        } else {\\n            b.WriteByte(e[i])\\n            i++\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc evaluate(expression string) int {\\n    return eval(expression, make(map[string]int))\\n}\\n\\nfunc eval(e string, env map[string]int) int {\\n    if len(e) == 0 {\\n        panic(e)\\n    }\\n    \\n    if e[0] != \\'(\\' {\\n        if (e[0] >= \\'0\\' && e[0] <= \\'9\\') || e[0] == \\'-\\' {\\n            res, err := strconv.Atoi(e)\\n            if err != nil {\\n                panic(err)\\n            }\\n           return res\\n       } else {\\n           if res, ok := env[e]; !ok {\\n               panic(e)\\n           } else {\\n               return res\\n           }\\n       }\\n    }  \\n    \\n    list := parse(e)\\n    \\n    newenv := make(map[string]int)\\n    for k, v := range env {\\n        newenv[k] = v\\n    }\\n    \\n    if list[0] == \"add\" {\\n        if len(list) != 3 {\\n            panic(\"add\")\\n        }\\n        return eval(list[1], newenv) + eval(list[2], newenv)\\n    }\\n    \\n    if list[0] == \"mult\" {\\n        if len(list) != 3 {\\n            panic(\"mult\")\\n        }\\n        return eval(list[1], newenv) * eval(list[2], newenv)\\n    }\\n    \\n    if list[0] == \"let\" {\\n        for i := 1; i < len(list) - 1; i += 2 {\\n            val := eval(list[i + 1], newenv)\\n            newenv[list[i]] = val\\n        }\\n        return eval(list[len(list) - 1], newenv)\\n    }\\n    \\n    panic(\"unsupported method\")\\n    return 0\\n}\\n\\nfunc parse(e string) []string {\\n    var res []string\\n    var b bytes.Buffer\\n    e = e[1:len(e) - 1] + \" \"\\n    i := 0\\n    for i < len(e) {\\n        if e[i] == \\' \\' {\\n            res = append(res, b.String())\\n            b.Reset()\\n            i++\\n        } else if e[i] == \\'(\\' {\\n            flag := 0\\n            j := i + 1\\n            for !(flag == 0 && e[j] == \\')\\') {\\n                if e[j] == \\'(\\' {\\n                    flag++\\n                } else if e[j] == \\')\\' {\\n                    flag--\\n                }\\n                j++\\n            }\\n            b.WriteString(e[i:j + 1])\\n            i = j + 1\\n        } else {\\n            b.WriteByte(e[i])\\n            i++\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 892054,
                "title": "a-full-blown-parser-solution",
                "content": "I wrote a small look ahead lexer and parser for this. The good part is that the time complexity is O(n) (in fact, it is single pass) but the constant part is big, so it doesn\\'t matter for us since n is always less than 2000.\\n\\nDon\\'t do this in an interview, it took me around 2 hours, because debugging this is a pain.\\n\\nHere\\'s the code, hopefully it is self explanatory:\\n\\n\\n\\tclass Solution {\\n\\t\\tpublic int evaluate(String expression) {\\n\\t\\t\\tParser p = new Parser(new Lexer(expression));\\n\\t\\t\\treturn p.parse();\\n\\t\\t}\\n\\n\\t\\tenum TokenType {\\n\\t\\t\\tIDENTIFIER,\\n\\t\\t\\tNUMBER,\\n\\t\\t\\tOPENBR,\\n\\t\\t\\tCLOSEBR,\\n\\t\\t\\tLET,\\n\\t\\t\\tMULT,\\n\\t\\t\\tADD\\n\\t\\t}\\n\\t\\tclass Token {\\n\\n\\t\\t\\tTokenType type;\\n\\t\\t\\tString value;\\n\\n\\t\\t\\tToken() {\\n\\t\\t\\t\\tthis.type = null;\\n\\t\\t\\t\\tthis.value = \"\";\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic String toString() {\\n\\t\\t\\t\\treturn \"{Type:\" + type + \", value:\" + value + \"}\";\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\n\\n\\t\\tclass Lexer {\\n\\t\\t\\tToken token = new Token();\\n\\t\\t\\tString expression;\\n\\t\\t\\tchar ch;\\n\\t\\t\\tint index;\\n\\n\\t\\t\\tLexer(String s) {\\n\\t\\t\\t\\texpression = s;\\n\\t\\t\\t\\tindex = 0;\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic String toString() {\\n\\t\\t\\t\\treturn \"{Token:\" + token +\", expr: \" + expression + \"index: \" + index +\"}\";\\n\\t\\t\\t}\\n\\t\\t\\tpublic void next() {\\n\\t\\t\\t\\tif (index == expression.length()) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tch = expression.charAt(index);\\n\\t\\t\\t\\twhile (ch == \\' \\') {\\n\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t\\tch = expression.charAt(index);\\n\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif (ch == \\'(\\') {\\n\\t\\t\\t\\t\\ttoken.type = TokenType.OPENBR;\\n\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t} else if (ch == \\')\\') {\\n\\t\\t\\t\\t\\ttoken.type = TokenType.CLOSEBR;\\n\\t\\t\\t\\t\\tindex++;\\n\\t\\t\\t\\t} else if ((ch >= \\'0\\' && ch <= \\'9\\') || ch == \\'+\\' || ch == \\'-\\') {\\n\\t\\t\\t\\t\\ttoken.type = TokenType.NUMBER;\\n\\t\\t\\t\\t\\tint temp = index+1;\\n\\t\\t\\t\\t\\tchar c = this.expression.charAt(temp);\\n\\t\\t\\t\\t\\twhile (c >= \\'0\\' && c <= \\'9\\') {\\n\\t\\t\\t\\t\\t\\ttemp++;\\n\\t\\t\\t\\t\\t\\tc = expression.charAt(temp);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttoken.value = expression.substring(index, temp);\\n\\t\\t\\t\\t\\tindex = temp;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tint temp = index;\\n\\t\\t\\t\\t\\tchar c = this.expression.charAt(temp);\\n\\t\\t\\t\\t\\twhile ((c >= \\'a\\' && c <= \\'z\\') || (c >= \\'0\\' && c <= \\'9\\')) {\\n\\t\\t\\t\\t\\t\\ttemp++;\\n\\t\\t\\t\\t\\t\\tc = expression.charAt(temp);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tString id = expression.substring(index, temp);\\n\\t\\t\\t\\t\\tif (id.equals(\"let\")) {\\n\\t\\t\\t\\t\\t\\ttoken.type = TokenType.LET;\\n\\t\\t\\t\\t\\t} else if (id.equals(\"mult\")) {\\n\\t\\t\\t\\t\\t\\ttoken.type = TokenType.MULT;\\n\\t\\t\\t\\t\\t} else if (id.equals(\"add\")) {\\n\\t\\t\\t\\t\\t\\ttoken.type = TokenType.ADD;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\ttoken.type = TokenType.IDENTIFIER;\\n\\t\\t\\t\\t\\t\\ttoken.value = id;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tindex=temp;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tpublic TokenType getSymbol() {\\n\\t\\t\\t\\treturn token.type;\\n\\t\\t\\t} \\n\\n\\t\\t\\tpublic String value() {\\n\\t\\t\\t\\treturn token.value;\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tclass Parser {\\n\\t\\t\\tLexer lexer;\\n\\n\\n\\t\\t\\tclass Frame {\\n\\t\\t\\t\\tMap<String, Integer> variables;\\n\\n\\t\\t\\t\\tFrame() {\\n\\t\\t\\t\\t\\tvariables = new HashMap<>();\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tFrame(Frame other) {\\n\\t\\t\\t\\t\\tthis();\\n\\t\\t\\t\\t\\tif (other != null) {\\n\\t\\t\\t\\t\\t\\tother.variables.forEach((k,v) -> {\\n\\t\\t\\t\\t\\t\\t\\tthis.variables.put(k,v);\\n\\t\\t\\t\\t\\t\\t});\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tvoid addVariable(String key, Integer val) {\\n\\t\\t\\t\\t\\tthis.variables.put(key, val);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tInteger getVar(String key) {\\n\\t\\t\\t\\t\\treturn this.variables.get(key);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tpublic String toString() {\\n\\t\\t\\t\\t\\treturn variables.toString();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tDeque<Frame> frames = new ArrayDeque<>();\\n\\n\\t\\t\\tParser(Lexer l) {\\n\\t\\t\\t\\tthis.lexer = l;\\n\\t\\t\\t}\\n\\t\\t\\tint parse() {\\n\\t\\t\\t\\tlexer.next();\\n\\t\\t\\t\\treturn parseStatements();            \\n\\t\\t\\t}\\n\\n\\t\\t\\tint parseStatements() {\\n\\n\\t\\t\\t\\tif (lexer.getSymbol().equals(TokenType.ADD)) {\\n\\t\\t\\t\\t\\tmustParse(TokenType.ADD);\\n\\t\\t\\t\\t\\tint a = parseStatements();\\n\\t\\t\\t\\t\\tint b = parseStatements();\\n\\t\\t\\t\\t\\treturn a+b;\\n\\t\\t\\t\\t} else if (lexer.getSymbol().equals(TokenType.MULT)) {\\n\\t\\t\\t\\t\\tmustParse(TokenType.MULT);\\n\\t\\t\\t\\t\\tint a = parseStatements();\\n\\t\\t\\t\\t\\tint b = parseStatements();\\n\\t\\t\\t\\t\\treturn a*b;\\n\\t\\t\\t\\t} else if (lexer.getSymbol().equals(TokenType.NUMBER)) {\\n\\t\\t\\t\\t\\tint number = Integer.parseInt(lexer.value());\\n\\t\\t\\t\\t\\tmustParse(TokenType.NUMBER);\\n\\t\\t\\t\\t\\treturn number;\\n\\t\\t\\t\\t} else if (lexer.getSymbol().equals(TokenType.IDENTIFIER)) {\\n\\t\\t\\t\\t\\tFrame top = frames.peekFirst();\\n\\t\\t\\t\\t\\tint value = top.getVar(lexer.value());\\n\\t\\t\\t\\t\\tmustParse(TokenType.IDENTIFIER);\\n\\t\\t\\t\\t\\treturn value;\\n\\t\\t\\t\\t} else if (lexer.getSymbol().equals(TokenType.OPENBR)) {\\n\\t\\t\\t\\t\\tmustParse(TokenType.OPENBR);\\n\\n\\t\\t\\t\\t\\tFrame f = new Frame(frames.peekFirst());\\n\\t\\t\\t\\t\\t// System.out.println(f);\\n\\t\\t\\t\\t\\tframes.addFirst(f);\\n\\t\\t\\t\\t\\tint a = parseStatements();\\n\\t\\t\\t\\t\\tmustParse(TokenType.CLOSEBR);\\n\\t\\t\\t\\t\\tframes.pop();\\n\\t\\t\\t\\t\\treturn a;\\n\\t\\t\\t\\t} else if (lexer.getSymbol().equals(TokenType.LET)) {\\n\\t\\t\\t\\t\\tmustParse(TokenType.LET);\\n\\t\\t\\t\\t\\treturn parseLet();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn -1;\\n\\t\\t\\t}\\n\\n\\t\\t\\tint parseLet() {\\n\\t\\t\\t\\tString variable = lexer.value();\\n\\t\\t\\t\\tlexer.next();\\n\\t\\t\\t\\tInteger value = parseStatements();\\n\\n\\t\\t\\t\\tFrame topFrame = frames.peekFirst();\\n\\t\\t\\t\\ttopFrame.addVariable(variable, value);\\n\\t\\t\\t\\twhile (true) {\\n\\t\\t\\t\\t\\tif (lexer.getSymbol().equals(TokenType.OPENBR) || lexer.getSymbol().equals(TokenType.NUMBER)) {\\n\\t\\t\\t\\t\\t\\treturn parseStatements();\\n\\t\\t\\t\\t\\t} else if (lexer.getSymbol().equals(TokenType.IDENTIFIER)) {\\n\\n\\t\\t\\t\\t\\t\\tvariable = lexer.value();\\n\\t\\t\\t\\t\\t\\tmustParse(TokenType.IDENTIFIER);\\n\\n\\t\\t\\t\\t\\t\\t// now check\\n\\t\\t\\t\\t\\t\\t// 2 cases: one is that this is the last one, so return it\\n\\t\\t\\t\\t\\t\\t// other is that more to come\\n\\t\\t\\t\\t\\t\\tif (lexer.getSymbol().equals(TokenType.CLOSEBR)) {\\n\\t\\t\\t\\t\\t\\t\\treturn topFrame.getVar(variable);\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tvalue = parseStatements();\\n\\t\\t\\t\\t\\t\\t\\ttopFrame.addVariable(variable, value);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\t// mustParse can be replaced by lexer.next() for our example\\n\\t\\t\\t// Leaving it here because it improves readability, and we can also \\n\\t\\t\\t// add error handling if needed.\\n\\t\\t\\tvoid mustParse(TokenType type) {\\n\\t\\t\\t\\tif (lexer.getSymbol().equals(type)) lexer.next();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t} \\n\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int evaluate(String expression) {\\n\\t\\t\\tParser p = new Parser(new Lexer(expression));\\n\\t\\t\\treturn p.parse();\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 833557,
                "title": "iteration-java-solution-with-explanation",
                "content": "First we observe the characteristics of the input expression string:\\n\\n1. It is an expression that satisfies the conditions of the question.\\n2. A single space separates each element.\\n3. The inner expression is surrounded by parentheses, and the outermost expression is also surrounded by parentheses.\\n4. The beginning of the expression must be `(let`, `(add`, `(muti`.\\n5. The end of the expression is `elm)`, `elm)))...`\\n6. The `let` operation is sequentially assignment.\\n7. The expression is calculated from the inner layer to the outer layer.\\n8. Every expression has a return value.\\n9. The elements in the expression are paired except that the `let` expression contains return value elements.\\n10. Only `let` can have multiple pairs of parameters\\n\\nFor these characteristics, we can easily think of dividing the string into character arrays with spaces (or the idea of character operation and word caching), and then traverse the array, analyze each element and perform corresponding processing, according to sequentially assignment and nested calculation, we can think of using two data structures, queues and stacks, to store relevant information.\\n\\nWe can use the `stack` and `hashmap` here to store the return value of an expression and the assignment of each element of it. The assignment information can be recorded by Map. When the next level of operation is performed, the previous map will be pushed to the stack and generate a copy for next level, the assignment operation will not affect the previous level map, when returning to the previous level, the stack will be popped.\\n\\n``` java\\nclass Solution {\\n    public int evaluate(String expression) {\\n        String [] elements = expression.split(\" \");\\n        Stack<Map<String, String>> stack = new Stack<>();\\n        Stack<String> keys = new Stack<>();\\n        Stack<String> optkeys = new Stack<>();\\n        Map<String, String> curMap = new HashMap<>();\\n        int res = 0;\\n        for (int i = 0; i < elements.length; ++i) {\\n            String element = elements[i];\\n            if (element.startsWith(\"(\")) {\\n                if (element.equals(\"(let\")) {\\n                    stack.push(curMap);\\n                    curMap = new HashMap<String, String>(curMap);\\n                }\\n                optkeys.push(element);\\n                keys.push(element);\\n            } else if (element.endsWith(\")\")) {\\n                StringBuilder valuebuf = new StringBuilder();\\n                int j;\\n                for (j = 0; element.charAt(j) != \\')\\'; ++j) valuebuf.append(element.charAt(j));\\n                String value = curMap.getOrDefault(valuebuf.toString(), valuebuf.toString());\\n                for (j = j; j < element.length(); ++j) {\\n                    String opt = optkeys.pop();\\n                    String subres = keys.pop();\\n                    subres = curMap.getOrDefault(subres, subres);\\n                    if (opt.equals(\"(add\")){\\n                        subres = Integer.valueOf(subres) + Integer.valueOf(value) + \"\";\\n                        keys.pop();\\n                    }\\n                    else if (opt.equals(\"(mult\")){\\n                        subres = Integer.valueOf(subres) * Integer.valueOf(value) + \"\";\\n                        keys.pop();\\n                    }\\n                    else {\\n                        subres = value.toString();\\n                        curMap = stack.pop();\\n                    }\\n                    value = subres;\\n                }\\n                if(keys.isEmpty()) {\\n                    keys.push(value);\\n                    break;\\n                }\\n                String key = keys.peek();\\n                if (key.equals(optkeys.peek())) keys.push(value);\\n                else {\\n                    key = keys.pop();\\n                    curMap.put(key, curMap.getOrDefault(value, value));\\n                }\\n            } else {\\n                String key = keys.peek();\\n                if (key.equals(optkeys.peek())) keys.push(element);\\n                else {\\n                    key = keys.pop();\\n                    curMap.put(key, curMap.getOrDefault(element, element));\\n                }\\n            }\\n        }\\n        return Integer.valueOf(keys.pop());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "``` java\\nclass Solution {\\n    public int evaluate(String expression) {\\n        String [] elements = expression.split(\" \");\\n        Stack<Map<String, String>> stack = new Stack<>();\\n        Stack<String> keys = new Stack<>();\\n        Stack<String> optkeys = new Stack<>();\\n        Map<String, String> curMap = new HashMap<>();\\n        int res = 0;\\n        for (int i = 0; i < elements.length; ++i) {\\n            String element = elements[i];\\n            if (element.startsWith(\"(\")) {\\n                if (element.equals(\"(let\")) {\\n                    stack.push(curMap);\\n                    curMap = new HashMap<String, String>(curMap);\\n                }\\n                optkeys.push(element);\\n                keys.push(element);\\n            } else if (element.endsWith(\")\")) {\\n                StringBuilder valuebuf = new StringBuilder();\\n                int j;\\n                for (j = 0; element.charAt(j) != \\')\\'; ++j) valuebuf.append(element.charAt(j));\\n                String value = curMap.getOrDefault(valuebuf.toString(), valuebuf.toString());\\n                for (j = j; j < element.length(); ++j) {\\n                    String opt = optkeys.pop();\\n                    String subres = keys.pop();\\n                    subres = curMap.getOrDefault(subres, subres);\\n                    if (opt.equals(\"(add\")){\\n                        subres = Integer.valueOf(subres) + Integer.valueOf(value) + \"\";\\n                        keys.pop();\\n                    }\\n                    else if (opt.equals(\"(mult\")){\\n                        subres = Integer.valueOf(subres) * Integer.valueOf(value) + \"\";\\n                        keys.pop();\\n                    }\\n                    else {\\n                        subres = value.toString();\\n                        curMap = stack.pop();\\n                    }\\n                    value = subres;\\n                }\\n                if(keys.isEmpty()) {\\n                    keys.push(value);\\n                    break;\\n                }\\n                String key = keys.peek();\\n                if (key.equals(optkeys.peek())) keys.push(value);\\n                else {\\n                    key = keys.pop();\\n                    curMap.put(key, curMap.getOrDefault(value, value));\\n                }\\n            } else {\\n                String key = keys.peek();\\n                if (key.equals(optkeys.peek())) keys.push(element);\\n                else {\\n                    key = keys.pop();\\n                    curMap.put(key, curMap.getOrDefault(element, element));\\n                }\\n            }\\n        }\\n        return Integer.valueOf(keys.pop());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 817846,
                "title": "java-with-debug-out-put-inline",
                "content": "``` \\nclass Solution {\\n    int i = 0;\\n    \\n    public int evaluate(String expression) {\\n        Map<String, Integer> map = new HashMap<>();\\n        return evaluate(expression.toCharArray(), map);\\n    }\\n    \\n    int evaluate(char[] exp, Map<String, Integer> pre) {\\n        Map<String, Integer> map = new HashMap<>(pre);\\n        Queue<Integer> values = new LinkedList<>();\\n        Queue<String> keys = new LinkedList<>();\\n        String op = null;\\n        StringBuilder sb = new StringBuilder();\\n        while (i < exp.length) {\\n            // System.out.print(exp[i]);\\n            if (exp[i] == \\'(\\') {\\n                i++;\\n                //System.out.println();\\n                //System.out.println(\"To next level\");\\n                int val = evaluate(exp, map);\\n                values.add(val);\\n                //System.out.println();\\n                //System.out.println(\"Get result \" + val + \" back push to values, now values size is \" + values.size());\\n                \\n            } else if(exp[i] == \\' \\') {\\n                if (sb.length() != 0) {\\n                    if (op == null) {\\n                        op = sb.toString();\\n                    } else {\\n                        try {\\n                            int num = Integer.parseInt(sb.toString());\\n                            //System.out.println(\"Putting \" + num + \" to values\");\\n                            values.add(num);\\n                        } catch (Exception e) {\\n                            \\n                            \\n                            if (\"let\".equals(op)) {\\n                                if (keys.size() > values.size()) {\\n                                    //System.out.println(\"Putting \" + map.get(sb.toString()) + \" to values\");\\n                                    values.add(map.get(sb.toString()));\\n                                } else {\\n                                    //System.out.println(\"Putting \" + sb.toString() + \" to keys\");\\n                                    keys.add(sb.toString());\\n                                }\\n                            } else {\\n                                    //System.out.println(\"Putting \" + map.get(sb.toString()) + \" to values\");\\n                                values.add(map.get(sb.toString()));\\n                            }\\n                        }\\n\\n                    }\\n                    \\n\\n                }\\n                \\n                i++;              \\n                sb = new StringBuilder();\\n            } else if (exp[i] == \\')\\') {\\n                if (sb.length() != 0) {\\n                    try {\\n                        int num = Integer.parseInt(sb.toString());\\n                        values.add(num);\\n                    } catch (Exception e) {\\n                        if (\"let\".equals(op)) {\\n                            keys.add(sb.toString());\\n                        } else {\\n                            values.add(map.get(sb.toString()));\\n                        }\\n                    }\\n                }\\n                \\n                //System.out.println();\\n                //System.out.println(\"op is \" + op);\\n                if (op == null) {\\n                    i++;\\n                    return values.isEmpty() ? map.get(keys.poll()) : values.poll();\\n                } else if (\"let\".equals(op)) {\\n                    //System.out.println();\\n                    //System.out.println(\"Will put \"+ keys.peek()+ \" with \" + values.peek() + \" , now key size is \" + keys.size() + \" and values size is \" + values.size());\\n                    while (\"let\".equals(op) && !keys.isEmpty() && !values.isEmpty()) {\\n                        map.put(keys.poll(), values.poll());\\n                    }\\n                    //System.out.println();\\n                    //System.out.println(\"go back to upper level with result \" + ( values.isEmpty() ? map.get(keys.peek()) : values.peek()));\\n                    i++;\\n                    return values.isEmpty() ? map.get(keys.poll()) : values.poll();\\n                } else {\\n                    \\n                    // System.out.println();\\n                    // System.out.println(\" Getting values keys size is \" + keys.size());\\n                    // System.out.println(\" Getting values values size is \" + values.size() + \" \" + values);\\n                    \\n                    int x = keys.isEmpty() ? values.poll() : map.get(keys.poll());\\n                    int y = keys.isEmpty() ? values.poll() : map.get(keys.poll());\\n                    i++;\\n                    \\n                //     // System.out.println();\\n                //     if (\"add\".equals(op)) {\\n                //         // System.out.println(\"Adding \" + x + \" and \" + y);\\n                //     } else {\\n                //         // System.out.println(\"mult \" + x + \" and \" + y);\\n                //     }\\n                    return \"add\".equals(op) ? x + y : x * y;\\n                }\\n            }else {\\n                sb.append(exp[i++]);\\n            }\\n            while (\"let\".equals(op) && !keys.isEmpty() && !values.isEmpty()) {\\n                    map.put(keys.poll(), values.poll());\\n            }\\n        }\\n        return values.isEmpty() ? map.get(keys.poll()) : values.poll();\\n    }\\n    \\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    int i = 0;\\n    \\n    public int evaluate(String expression) {\\n        Map<String, Integer> map = new HashMap<>();\\n        return evaluate(expression.toCharArray(), map);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 776183,
                "title": "java-solution-without-regex",
                "content": "```\\nclass Solution {\\n    \\n\\t// evaluate with context ( variable to evaluated value map )\\n    private int evContext(String expression, Map<String, String> context) {\\n\\t\\n\\t\\t// if this is an expression\\n        if (expression.startsWith(\"(\")) {\\n            String[] splitted = expression.substring(1, expression.length()-1).split(\" \");\\n            \\n\\t\\t\\t// all the expression/values in sequential order\\n            List<String> terms = new ArrayList<>();\\n\\t\\t\\t\\n\\t\\t\\t// add first element (since it will always be an operator or a value)\\n            terms.add(splitted[0]);\\n            \\n            StringBuilder sb = new StringBuilder();\\n            int indent = 0;\\n            for (int i=1; i<splitted.length; i++) {\\n                sb.append(\" \");\\n                sb.append(splitted[i]);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if the space splitted string element is like: \"(let\", \"(23\", \"*(add\" -> increment the indent\\n                if (splitted[i].startsWith(\"(\")) {\\n                    indent++;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if current space-splitted string element contains a closing parenthesis (will be in the end only!)\\n                if (splitted[i].contains(\")\")) {\\n\\t\\t\\t\\t  \\n\\t\\t\\t\\t  // decreasing indent for all closing parenthesis\\n                  indent -= (splitted[i].length() - splitted[i].indexOf(\")\"));\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if there is no parenthesis involved or all parenthesis have been closed, add the current append string in terms\\n                if (indent == 0) {\\n                    terms.add(sb.toString().substring(1));\\n                    sb = new StringBuilder();\\n                }\\n            }\\n            int l = terms.size();\\n            \\n            if (terms.get(0).equals(\"add\")) {\\n\\t\\t\\t\\t// evaluate the following expressions with passed context and add the values\\n                return evContext(terms.get(1), context) + evContext(terms.get(2), context);\\n            }\\n            if (terms.get(0).equals(\"mult\")) {\\n\\t\\t\\t\\t// evaluate the following expressions with passed context and multiply the values\\n                return evContext(terms.get(1), context) * evContext(terms.get(2), context);\\n            }\\n            if (terms.get(0).equals(\"let\")) {\\n\\t\\t\\t\\t// create a new context by adding all the entries of the passed context\\n                Map<String, String> map = new HashMap<>(context);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// increment the terms\\' index by 2 as key value will always be in the pair of 2\\n                for (int i=1; i<l-1; i+= 2) {\\n\\t\\t\\t\\t\\t// put/override existing context with current evaluated one\\n                    map.put(terms.get(i), String.valueOf(evContext(terms.get(i+1), map)));\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// last term will be an expression, evaluate that using current context\\n                return evContext(terms.get(l-1), map);\\n            }\\n        }\\n        \\n        return Integer.parseInt(\\n\\t\\t\\n\\t\\t\\t// if the key is in the context get the value else parse the value ( either it will be \"x\" or some value \"42\")\\n            context.getOrDefault(expression, expression)\\n        );\\n    }\\n    \\n    public int evaluate(String expression) {\\n\\t\\t// evaluate the expression passing an empty context\\n        return evContext(expression, new HashMap<>());\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n\\t// evaluate with context ( variable to evaluated value map )\\n    private int evContext(String expression, Map<String, String> context) {\\n\\t\\n\\t\\t// if this is an expression\\n        if (expression.startsWith(\"(\")) {\\n            String[] splitted = expression.substring(1, expression.length()-1).split(\" \");\\n            \\n\\t\\t\\t// all the expression/values in sequential order\\n            List<String> terms = new ArrayList<>();\\n\\t\\t\\t\\n\\t\\t\\t// add first element (since it will always be an operator or a value)\\n            terms.add(splitted[0]);\\n            \\n            StringBuilder sb = new StringBuilder();\\n            int indent = 0;\\n            for (int i=1; i<splitted.length; i++) {\\n                sb.append(\" \");\\n                sb.append(splitted[i]);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if the space splitted string element is like: \"(let\", \"(23\", \"*(add\" -> increment the indent\\n                if (splitted[i].startsWith(\"(\")) {\\n                    indent++;\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if current space-splitted string element contains a closing parenthesis (will be in the end only!)\\n                if (splitted[i].contains(\")\")) {\\n\\t\\t\\t\\t  \\n\\t\\t\\t\\t  // decreasing indent for all closing parenthesis\\n                  indent -= (splitted[i].length() - splitted[i].indexOf(\")\"));\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if there is no parenthesis involved or all parenthesis have been closed, add the current append string in terms\\n                if (indent == 0) {\\n                    terms.add(sb.toString().substring(1));\\n                    sb = new StringBuilder();\\n                }\\n            }\\n            int l = terms.size();\\n            \\n            if (terms.get(0).equals(\"add\")) {\\n\\t\\t\\t\\t// evaluate the following expressions with passed context and add the values\\n                return evContext(terms.get(1), context) + evContext(terms.get(2), context);\\n            }\\n            if (terms.get(0).equals(\"mult\")) {\\n\\t\\t\\t\\t// evaluate the following expressions with passed context and multiply the values\\n                return evContext(terms.get(1), context) * evContext(terms.get(2), context);\\n            }\\n            if (terms.get(0).equals(\"let\")) {\\n\\t\\t\\t\\t// create a new context by adding all the entries of the passed context\\n                Map<String, String> map = new HashMap<>(context);\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// increment the terms\\' index by 2 as key value will always be in the pair of 2\\n                for (int i=1; i<l-1; i+= 2) {\\n\\t\\t\\t\\t\\t// put/override existing context with current evaluated one\\n                    map.put(terms.get(i), String.valueOf(evContext(terms.get(i+1), map)));\\n                }\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// last term will be an expression, evaluate that using current context\\n                return evContext(terms.get(l-1), map);\\n            }\\n        }\\n        \\n        return Integer.parseInt(\\n\\t\\t\\n\\t\\t\\t// if the key is in the context get the value else parse the value ( either it will be \"x\" or some value \"42\")\\n            context.getOrDefault(expression, expression)\\n        );\\n    }\\n    \\n    public int evaluate(String expression) {\\n\\t\\t// evaluate the expression passing an empty context\\n        return evContext(expression, new HashMap<>());\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 771802,
                "title": "java-one-pass",
                "content": "class Solution {\\n\\n    public int evaluate(String expression) {\\n        return new Engine(expression).compute(new HashMap<>());\\n    }\\n\\n    class Engine {\\n        String expression;\\n        int offset;\\n        \\n        public Engine(String expr) {\\n            expression = expr;\\n        }\\n        \\n        public int compute(Map<String,Integer> context) {\\n            String v = isVar() ? readVar() : null;\\n            return v != null ?  context.get(v) // throws exception if variable not found\\n                 : isNumber() ? readNumber()\\n                 : match(\"(let \", true) ? let(context)\\n                 : match(\"(add \", true) ? add(context)\\n                 : match(\"(mult \", true) ? mult(context)\\n                 : 0; // or throw exception?\\n        }\\n        \\n        private boolean isVar() {\\n            skipWhitespace(); //isVar is checked first in compute() and let().\\n            return Character.isLetter(peek());\\n        }\\n\\n        private String readVar() {\\n            int i = offset;\\n            while(Character.isLetterOrDigit(peek())) {\\n                offset++;\\n            }\\n            return expression.substring(i, offset);\\n        }\\n        \\n        private boolean isNumber() {\\n            return peek() == \\'-\\' || Character.isDigit(peek());\\n        }\\n        \\n        private int readNumber() {\\n            boolean negative = match(\"-\", true);\\n            int result = 0;\\n            while (Character.isDigit(peek())) {\\n                result = result * 10 + (int)(peek() - \\'0\\');\\n                offset++;\\n            }\\n            return negative ? -result : result;\\n        }\\n\\n        private int add(Map<String,Integer> context) {\\n            return call(compute(context) + compute(context));\\n        }\\n\\n        private int mult(Map<String,Integer> context) {\\n            return call(compute(context) * compute(context));\\n        }\\n        \\n        private int let(Map<String,Integer> context) {\\n            Map<String,Integer> next = new HashMap<>(context);\\n            while (isVar()) {\\n                String v = readVar();\\n                if (match(\")\", false)) { //it was expression as var!\\n                    return call(next.get(v)); //throws exception if variable not found\\n                }\\n                next.put(v, compute(next));\\n            }\\n            return call(compute(next));\\n        }\\n\\n        private int call(int res) {\\n            if (match(\")\", true)) return res; else throw new RuntimeException();\\n        }\\n\\n        private boolean match(String s, boolean consume) {\\n            skipWhitespace();\\n            boolean ok = expression.regionMatches(offset, s, 0, s.length());\\n            offset += ok && consume ? s.length() : 0; \\n            return ok;\\n        }\\n        \\n        private void skipWhitespace() {\\n            while (Character.isWhitespace(peek())) offset++;\\n        }\\n\\n        private char peek() {\\n            return offset >= expression.length() ? \\'\\\\0\\' : expression.charAt(offset);\\n        }        \\n    }\\n}\\n",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    public int evaluate(String expression) {\\n        return new Engine(expression).compute(new HashMap<>());\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 701162,
                "title": "c-o-n-recursive-descent-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    struct Env{\\n        unordered_map<string,int> m; \\n        int get(const string& name){\\n            return m[name];\\n        }\\n        void put(const string& name, int v){\\n            m[name] = v;\\n        }\\n        bool exist(const string& name){\\n            return m.find(name) != m.end();\\n        }\\n        void remove(const string& name){\\n            m.erase(name);\\n        }\\n    };\\n    struct Node{\\n        virtual int eval(Env env) = 0;\\n    };\\n    struct IntNode : Node{\\n        int v; \\n        int eval(Env env) override {\\n            return v;\\n        }\\n        IntNode(int v_) : v(v_){}\\n    };\\n    struct MulNode : Node{\\n        Node* l;\\n        Node* r; \\n        int eval(Env env) override {\\n            return l->eval(env) * r->eval(env);\\n        }\\n        MulNode(Node* l_, Node* r_) : l(l_), r(r_) {}\\n    };\\n    struct AddNode : Node{\\n        Node* l; \\n        Node* r; \\n        int eval(Env env)  override {\\n            return l->eval(env) + r->eval(env);\\n        }\\n        AddNode(Node* l_, Node* r_) : l(l_),r(r_){}\\n    };\\n    struct VariableNode : Node{\\n        string name; \\n        int eval(Env env) override {\\n            return env.get(name);\\n        }\\n        VariableNode(string name_) : name(name_){}\\n    };\\n    struct LetNode : Node {\\n        vector<pair<string,Node*>> variables; \\n        Node* expr; \\n        int eval(Env env){\\n            set<string> needRemove; \\n            vector<pair<string,int>> needRestore; \\n            for(auto& p : variables){\\n                string name = p.first; \\n                Node* n = p.second; \\n                if(env.exist(name)){\\n                    needRestore.push_back({name,env.get(name)});\\n                } else {\\n                    needRemove.insert(name);\\n                }\\n                env.put(name,n->eval(env));\\n            }\\n            int ret = expr->eval(env);\\n            for(auto& str : needRemove){\\n                env.remove(str);\\n            }\\n            for(auto& p : needRestore){\\n                env.put(p.first,p.second);\\n            }\\n            return ret; \\n        }\\n        LetNode(vector<pair<string,Node*>> vs, Node* expr_) : variables(vs),expr(expr_){}\\n    };\\n    Node* integer(const string& str, int& i){\\n        int ret = 0;\\n        if(str[i] == \\'-\\'){\\n            i++;\\n            Node* val = integer(str,i);\\n            return new IntNode(-((IntNode*)val)->v);\\n        }\\n        while(str[i]>=\\'0\\'&&str[i]<=\\'9\\'){\\n            ret = ret * 10 + str[i] - \\'0\\';\\n            i++;\\n        }\\n        return new IntNode(ret);\\n    }\\n    Node* variable(const string& str, int& i){\\n        string name;\\n        while(str[i]!=\\' \\'&&str[i]!=\\')\\'){\\n            name += str[i];\\n            i++;\\n        }\\n        return new VariableNode(name);\\n    }\\n    Node* parse(const string& str, int& i){\\n        if(str[i] == \\'-\\' || (str[i]>=\\'0\\'&&str[i]<=\\'9\\')){\\n            return  integer(str,i);\\n        }\\n        else if(str[i]>=\\'a\\'&&str[i]<=\\'z\\'){\\n            return  variable(str,i);\\n        }\\n        i++;\\n        Node* ret; \\n        if(str[i] == \\'l\\'){\\n            //let\\n            i+=4; \\n            ret = let(str,i);\\n        } \\n        else if(str[i] == \\'a\\'){\\n            //add\\n            i+=4;\\n            ret = add(str,i);\\n        } else {\\n            //mult \\n            i+=5;\\n            ret = mult(str,i);\\n        }\\n        i++;\\n        return ret; \\n    }\\n    \\n    Node* add(const string& str, int& i){\\n        Node* l = parse(str,i);\\n        i++;\\n        Node* r = parse(str,i);\\n        return new  AddNode(l,r);\\n    }\\n    \\n    Node* mult(const string& str, int& i){\\n        Node* l = parse(str,i);\\n        i++;\\n        Node* r = parse(str,i);\\n        return new MulNode(l,r);\\n    }\\n    \\n    Node* let(const string& str, int& i){\\n        vector<pair<string,Node*>> vs; \\n        Node* _variable = nullptr;\\n        while(str[i]>=\\'a\\'&&str[i]<=\\'z\\'){\\n            Node* name = variable(str,i);\\n            if(str[i] == \\')\\'){\\n                _variable = name;\\n                break;\\n            }\\n            i++;\\n            Node* v = parse(str,i);\\n            i++;\\n            vs.push_back({((VariableNode*)name)->name,v});\\n        }\\n        if(_variable!=nullptr){\\n            return new LetNode(vs,_variable);\\n        }\\n        Node* expr = parse(str,i);\\n        return new LetNode(vs,expr);\\n    }\\n    \\n    int evaluate(string expression) {\\n        int i = 0;\\n        Node* node = parse(expression,i);\\n        Env env; \\n        return node->eval(env);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    struct Env{\\n        unordered_map<string,int> m; \\n        int get(const string& name){\\n            return m[name];\\n        }\\n        void put(const string& name, int v){\\n            m[name] = v;\\n        }\\n        bool exist(const string& name){\\n            return m.find(name) != m.end();\\n        }\\n        void remove(const string& name){\\n            m.erase(name);\\n        }\\n    };\\n    struct Node{\\n        virtual int eval(Env env) = 0;\\n    };\\n    struct IntNode : Node{\\n        int v; \\n        int eval(Env env) override {\\n            return v;\\n        }\\n        IntNode(int v_) : v(v_){}\\n    };\\n    struct MulNode : Node{\\n        Node* l;\\n        Node* r; \\n        int eval(Env env) override {\\n            return l->eval(env) * r->eval(env);\\n        }\\n        MulNode(Node* l_, Node* r_) : l(l_), r(r_) {}\\n    };\\n    struct AddNode : Node{\\n        Node* l; \\n        Node* r; \\n        int eval(Env env)  override {\\n            return l->eval(env) + r->eval(env);\\n        }\\n        AddNode(Node* l_, Node* r_) : l(l_),r(r_){}\\n    };\\n    struct VariableNode : Node{\\n        string name; \\n        int eval(Env env) override {\\n            return env.get(name);\\n        }\\n        VariableNode(string name_) : name(name_){}\\n    };\\n    struct LetNode : Node {\\n        vector<pair<string,Node*>> variables; \\n        Node* expr; \\n        int eval(Env env){\\n            set<string> needRemove; \\n            vector<pair<string,int>> needRestore; \\n            for(auto& p : variables){\\n                string name = p.first; \\n                Node* n = p.second; \\n                if(env.exist(name)){\\n                    needRestore.push_back({name,env.get(name)});\\n                } else {\\n                    needRemove.insert(name);\\n                }\\n                env.put(name,n->eval(env));\\n            }\\n            int ret = expr->eval(env);\\n            for(auto& str : needRemove){\\n                env.remove(str);\\n            }\\n            for(auto& p : needRestore){\\n                env.put(p.first,p.second);\\n            }\\n            return ret; \\n        }\\n        LetNode(vector<pair<string,Node*>> vs, Node* expr_) : variables(vs),expr(expr_){}\\n    };\\n    Node* integer(const string& str, int& i){\\n        int ret = 0;\\n        if(str[i] == \\'-\\'){\\n            i++;\\n            Node* val = integer(str,i);\\n            return new IntNode(-((IntNode*)val)->v);\\n        }\\n        while(str[i]>=\\'0\\'&&str[i]<=\\'9\\'){\\n            ret = ret * 10 + str[i] - \\'0\\';\\n            i++;\\n        }\\n        return new IntNode(ret);\\n    }\\n    Node* variable(const string& str, int& i){\\n        string name;\\n        while(str[i]!=\\' \\'&&str[i]!=\\')\\'){\\n            name += str[i];\\n            i++;\\n        }\\n        return new VariableNode(name);\\n    }\\n    Node* parse(const string& str, int& i){\\n        if(str[i] == \\'-\\' || (str[i]>=\\'0\\'&&str[i]<=\\'9\\')){\\n            return  integer(str,i);\\n        }\\n        else if(str[i]>=\\'a\\'&&str[i]<=\\'z\\'){\\n            return  variable(str,i);\\n        }\\n        i++;\\n        Node* ret; \\n        if(str[i] == \\'l\\'){\\n            //let\\n            i+=4; \\n            ret = let(str,i);\\n        } \\n        else if(str[i] == \\'a\\'){\\n            //add\\n            i+=4;\\n            ret = add(str,i);\\n        } else {\\n            //mult \\n            i+=5;\\n            ret = mult(str,i);\\n        }\\n        i++;\\n        return ret; \\n    }\\n    \\n    Node* add(const string& str, int& i){\\n        Node* l = parse(str,i);\\n        i++;\\n        Node* r = parse(str,i);\\n        return new  AddNode(l,r);\\n    }\\n    \\n    Node* mult(const string& str, int& i){\\n        Node* l = parse(str,i);\\n        i++;\\n        Node* r = parse(str,i);\\n        return new MulNode(l,r);\\n    }\\n    \\n    Node* let(const string& str, int& i){\\n        vector<pair<string,Node*>> vs; \\n        Node* _variable = nullptr;\\n        while(str[i]>=\\'a\\'&&str[i]<=\\'z\\'){\\n            Node* name = variable(str,i);\\n            if(str[i] == \\')\\'){\\n                _variable = name;\\n                break;\\n            }\\n            i++;\\n            Node* v = parse(str,i);\\n            i++;\\n            vs.push_back({((VariableNode*)name)->name,v});\\n        }\\n        if(_variable!=nullptr){\\n            return new LetNode(vs,_variable);\\n        }\\n        Node* expr = parse(str,i);\\n        return new LetNode(vs,expr);\\n    }\\n    \\n    int evaluate(string expression) {\\n        int i = 0;\\n        Node* node = parse(expression,i);\\n        Env env; \\n        return node->eval(env);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 673787,
                "title": "java-clean-interpreter-solution",
                "content": "```\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\npublic class Solution {\\n\\tprivate int index;\\n\\tprivate List<String> tokens;\\n\\t\\n\\tpublic int evaluate(String expression) {\\n\\t\\tthis.tokens = tokenize(expression);\\n\\t\\tthis.index = 0;\\n\\t\\t\\n\\t\\tSyntaxTree tree = buildExpression();\\n\\t\\treturn tree.evaluate(new HashMap<>());\\n\\t}\\n\\n\\tprivate List<String> tokenize(String expression) {\\n\\t\\tPattern pattern = Pattern.compile(\"(add|let|mult|(?:\\\\\\\\-|\\\\\\\\+)?\\\\\\\\d+|\\\\\\\\(|\\\\\\\\)|[a-z][a-z0-9]*)\");\\n\\t\\tMatcher matcher = pattern.matcher(expression);\\n\\n\\t\\tList<String> tokens = new ArrayList<>();\\n\\t\\twhile (matcher.find()) {\\n\\t\\t\\tString group = matcher.group();\\n\\t\\t\\ttokens.add(group);\\n\\t\\t}\\n\\n\\t\\treturn tokens;\\n\\t}\\n\\t\\n\\tprivate String eat() {\\n\\t\\treturn tokens.get(index);\\n\\t}\\n\\t\\n\\tprivate void readNext(String value) {\\n\\t\\tString actualToken = eat(); \\n\\t\\tif (!actualToken.equals(value)) {\\n\\t\\t\\tthrow new IllegalArgumentException(\"Unexpected token: \" + actualToken);\\n\\t\\t} \\n\\t\\t\\n\\t\\tindex++;\\n\\t}\\n\\t\\n\\tprivate boolean isVariable(String token) {\\n\\t\\treturn token.charAt(0) >= \\'a\\' && token.charAt(0) <= \\'z\\';\\n\\t}\\n\\t\\n\\tprivate SyntaxTree buildExpression() {\\n\\t\\tString token = eat();\\n\\t\\t\\n\\t\\tif (token.equals(\"(\")) {\\n\\t\\t\\treadNext(\"(\");\\n\\t\\t\\tSyntaxTree tree = buildExpression();\\n\\t\\t\\treadNext(\")\");\\n\\t\\t\\t\\n\\t\\t\\treturn tree;\\n\\t\\t} else if (token.equals(\"let\")) {\\n\\t\\t\\treturn buildLet();\\n\\t\\t} else if (token.equals(\"add\")) {\\n\\t\\t\\treturn buildAdd();\\n\\t\\t} else if (token.equals(\"mult\")) {\\n\\t\\t\\treturn buildMult();\\n\\t\\t} else if (isVariable(token)) {\\n\\t\\t\\treadNext(token);\\n\\t\\t\\treturn new VariableExpression(token);\\n\\t\\t} else {\\n\\t\\t\\tInteger value = Integer.parseInt(token);\\n\\t\\t\\treadNext(token);\\n\\t\\t\\treturn new NumberExpression(value);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tprivate SyntaxTree buildAdd() {\\n\\t\\treadNext(\"add\");\\n\\t\\tSyntaxTree left = buildExpression();\\n\\t\\tSyntaxTree right = buildExpression();\\n\\t\\t\\n\\t\\treturn new AddExpression(left, right);\\n\\t}\\n\\t\\n\\tprivate SyntaxTree buildMult() {\\n\\t\\treadNext(\"mult\");\\n\\t\\tSyntaxTree left = buildExpression();\\n\\t\\tSyntaxTree right = buildExpression();\\n\\t\\t\\n\\t\\treturn new MultiplyExpression(left, right);\\n\\t}\\n\\t\\n\\tprivate SyntaxTree buildLet() {\\n\\t\\treadNext(\"let\");\\n\\t\\tList<Pair<String, SyntaxTree>> assignments = new ArrayList<>();\\n\\t\\t\\n\\t\\twhile (isVariable(eat())) {\\n\\t\\t\\tString name = eat();\\n\\t\\t\\treadNext(name);\\n\\t\\t\\t\\n\\t\\t\\tif (eat().equals(\")\")) {\\n\\t\\t\\t\\tSyntaxTree expression = new VariableExpression(name);\\n\\t\\t\\t\\treturn new LetExpression(assignments, expression);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tSyntaxTree value = buildExpression();\\n\\t\\t\\tassignments.add(new Pair(name, value));\\n\\t\\t}\\n\\t\\t\\n\\t\\tSyntaxTree expression = buildExpression();\\n\\t\\treturn new LetExpression(assignments, expression);\\n\\t}\\n\\n\\tprivate static interface SyntaxTree {\\n\\t\\tpublic int evaluate(Map<String, Integer> context);\\n\\t}\\n\\n\\tprivate static class AddExpression implements SyntaxTree {\\n\\t\\tprivate SyntaxTree left;\\n\\t\\tprivate SyntaxTree right;\\n\\t\\t\\n\\t\\tpublic AddExpression(SyntaxTree left, SyntaxTree right) {\\n\\t\\t\\tthis.left = left;\\n\\t\\t\\tthis.right = right;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int evaluate(Map<String, Integer> context) {\\n\\t\\t\\treturn left.evaluate(context) + right.evaluate(context);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static class MultiplyExpression implements SyntaxTree {\\n\\t\\tprivate SyntaxTree left;\\n\\t\\tprivate SyntaxTree right;\\n\\t\\t\\n\\t\\tpublic MultiplyExpression(SyntaxTree left, SyntaxTree right) {\\n\\t\\t\\tthis.left = left;\\n\\t\\t\\tthis.right = right;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int evaluate(Map<String, Integer> context) {\\n\\t\\t\\treturn left.evaluate(context) * right.evaluate(context);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static class LetExpression implements SyntaxTree {\\n\\t\\tprivate List<Pair<String, SyntaxTree>> assignments;\\n\\t\\tprivate SyntaxTree expression;\\n\\t\\t\\n\\t\\tpublic LetExpression(List<Pair<String, SyntaxTree>> assignments, SyntaxTree expression) {\\n\\t\\t\\tthis.assignments = assignments;\\n\\t\\t\\tthis.expression = expression;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int evaluate(Map<String, Integer> context) {\\n\\t\\t\\tMap<String, Integer> newContext = new HashMap<>(context);\\n\\t\\t\\tfor (var assignment : assignments) {\\n\\t\\t\\t\\tString name = assignment.getKey();\\n\\t\\t\\t\\tint value = assignment.getValue().evaluate(newContext);\\n\\t\\t\\t\\tnewContext.put(name, value);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn expression.evaluate(newContext);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static class NumberExpression implements SyntaxTree {\\n\\t\\tprivate int number;\\n\\t\\t\\n\\t\\tpublic NumberExpression(int number) {\\n\\t\\t\\tthis.number = number;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int evaluate(Map<String, Integer> context) {\\n\\t\\t\\treturn number;\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static class VariableExpression implements SyntaxTree {\\n\\t\\tprivate String variable;\\n\\t\\t\\n\\t\\tpublic VariableExpression(String variable) {\\n\\t\\t\\tthis.variable = variable;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int evaluate(Map<String, Integer> context) {\\n\\t\\t\\treturn context.get(variable);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\n\\npublic class Solution {\\n\\tprivate int index;\\n\\tprivate List<String> tokens;\\n\\t\\n\\tpublic int evaluate(String expression) {\\n\\t\\tthis.tokens = tokenize(expression);\\n\\t\\tthis.index = 0;\\n\\t\\t\\n\\t\\tSyntaxTree tree = buildExpression();\\n\\t\\treturn tree.evaluate(new HashMap<>());\\n\\t}\\n\\n\\tprivate List<String> tokenize(String expression) {\\n\\t\\tPattern pattern = Pattern.compile(\"(add|let|mult|(?:\\\\\\\\-|\\\\\\\\+)?\\\\\\\\d+|\\\\\\\\(|\\\\\\\\)|[a-z][a-z0-9]*)\");\\n\\t\\tMatcher matcher = pattern.matcher(expression);\\n\\n\\t\\tList<String> tokens = new ArrayList<>();\\n\\t\\twhile (matcher.find()) {\\n\\t\\t\\tString group = matcher.group();\\n\\t\\t\\ttokens.add(group);\\n\\t\\t}\\n\\n\\t\\treturn tokens;\\n\\t}\\n\\t\\n\\tprivate String eat() {\\n\\t\\treturn tokens.get(index);\\n\\t}\\n\\t\\n\\tprivate void readNext(String value) {\\n\\t\\tString actualToken = eat(); \\n\\t\\tif (!actualToken.equals(value)) {\\n\\t\\t\\tthrow new IllegalArgumentException(\"Unexpected token: \" + actualToken);\\n\\t\\t} \\n\\t\\t\\n\\t\\tindex++;\\n\\t}\\n\\t\\n\\tprivate boolean isVariable(String token) {\\n\\t\\treturn token.charAt(0) >= \\'a\\' && token.charAt(0) <= \\'z\\';\\n\\t}\\n\\t\\n\\tprivate SyntaxTree buildExpression() {\\n\\t\\tString token = eat();\\n\\t\\t\\n\\t\\tif (token.equals(\"(\")) {\\n\\t\\t\\treadNext(\"(\");\\n\\t\\t\\tSyntaxTree tree = buildExpression();\\n\\t\\t\\treadNext(\")\");\\n\\t\\t\\t\\n\\t\\t\\treturn tree;\\n\\t\\t} else if (token.equals(\"let\")) {\\n\\t\\t\\treturn buildLet();\\n\\t\\t} else if (token.equals(\"add\")) {\\n\\t\\t\\treturn buildAdd();\\n\\t\\t} else if (token.equals(\"mult\")) {\\n\\t\\t\\treturn buildMult();\\n\\t\\t} else if (isVariable(token)) {\\n\\t\\t\\treadNext(token);\\n\\t\\t\\treturn new VariableExpression(token);\\n\\t\\t} else {\\n\\t\\t\\tInteger value = Integer.parseInt(token);\\n\\t\\t\\treadNext(token);\\n\\t\\t\\treturn new NumberExpression(value);\\n\\t\\t}\\n\\t}\\n\\t\\n\\tprivate SyntaxTree buildAdd() {\\n\\t\\treadNext(\"add\");\\n\\t\\tSyntaxTree left = buildExpression();\\n\\t\\tSyntaxTree right = buildExpression();\\n\\t\\t\\n\\t\\treturn new AddExpression(left, right);\\n\\t}\\n\\t\\n\\tprivate SyntaxTree buildMult() {\\n\\t\\treadNext(\"mult\");\\n\\t\\tSyntaxTree left = buildExpression();\\n\\t\\tSyntaxTree right = buildExpression();\\n\\t\\t\\n\\t\\treturn new MultiplyExpression(left, right);\\n\\t}\\n\\t\\n\\tprivate SyntaxTree buildLet() {\\n\\t\\treadNext(\"let\");\\n\\t\\tList<Pair<String, SyntaxTree>> assignments = new ArrayList<>();\\n\\t\\t\\n\\t\\twhile (isVariable(eat())) {\\n\\t\\t\\tString name = eat();\\n\\t\\t\\treadNext(name);\\n\\t\\t\\t\\n\\t\\t\\tif (eat().equals(\")\")) {\\n\\t\\t\\t\\tSyntaxTree expression = new VariableExpression(name);\\n\\t\\t\\t\\treturn new LetExpression(assignments, expression);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tSyntaxTree value = buildExpression();\\n\\t\\t\\tassignments.add(new Pair(name, value));\\n\\t\\t}\\n\\t\\t\\n\\t\\tSyntaxTree expression = buildExpression();\\n\\t\\treturn new LetExpression(assignments, expression);\\n\\t}\\n\\n\\tprivate static interface SyntaxTree {\\n\\t\\tpublic int evaluate(Map<String, Integer> context);\\n\\t}\\n\\n\\tprivate static class AddExpression implements SyntaxTree {\\n\\t\\tprivate SyntaxTree left;\\n\\t\\tprivate SyntaxTree right;\\n\\t\\t\\n\\t\\tpublic AddExpression(SyntaxTree left, SyntaxTree right) {\\n\\t\\t\\tthis.left = left;\\n\\t\\t\\tthis.right = right;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int evaluate(Map<String, Integer> context) {\\n\\t\\t\\treturn left.evaluate(context) + right.evaluate(context);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static class MultiplyExpression implements SyntaxTree {\\n\\t\\tprivate SyntaxTree left;\\n\\t\\tprivate SyntaxTree right;\\n\\t\\t\\n\\t\\tpublic MultiplyExpression(SyntaxTree left, SyntaxTree right) {\\n\\t\\t\\tthis.left = left;\\n\\t\\t\\tthis.right = right;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int evaluate(Map<String, Integer> context) {\\n\\t\\t\\treturn left.evaluate(context) * right.evaluate(context);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static class LetExpression implements SyntaxTree {\\n\\t\\tprivate List<Pair<String, SyntaxTree>> assignments;\\n\\t\\tprivate SyntaxTree expression;\\n\\t\\t\\n\\t\\tpublic LetExpression(List<Pair<String, SyntaxTree>> assignments, SyntaxTree expression) {\\n\\t\\t\\tthis.assignments = assignments;\\n\\t\\t\\tthis.expression = expression;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int evaluate(Map<String, Integer> context) {\\n\\t\\t\\tMap<String, Integer> newContext = new HashMap<>(context);\\n\\t\\t\\tfor (var assignment : assignments) {\\n\\t\\t\\t\\tString name = assignment.getKey();\\n\\t\\t\\t\\tint value = assignment.getValue().evaluate(newContext);\\n\\t\\t\\t\\tnewContext.put(name, value);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\treturn expression.evaluate(newContext);\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static class NumberExpression implements SyntaxTree {\\n\\t\\tprivate int number;\\n\\t\\t\\n\\t\\tpublic NumberExpression(int number) {\\n\\t\\t\\tthis.number = number;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int evaluate(Map<String, Integer> context) {\\n\\t\\t\\treturn number;\\n\\t\\t}\\n\\t}\\n\\n\\tprivate static class VariableExpression implements SyntaxTree {\\n\\t\\tprivate String variable;\\n\\t\\t\\n\\t\\tpublic VariableExpression(String variable) {\\n\\t\\t\\tthis.variable = variable;\\n\\t\\t}\\n\\t\\t\\n\\t\\tpublic int evaluate(Map<String, Integer> context) {\\n\\t\\t\\treturn context.get(variable);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668423,
                "title": "use-java-util-scanner",
                "content": "The same idea as other solutions but let the `Scanner` do the dirty work. Dirty work is actually much faster compared to using regex in Java, though.\\n\\n```java\\nclass Solution {\\n    public int evaluate(String expression) {\\n        Deque<Map<String, Integer>> contexts = new ArrayDeque<>();\\n        Scanner sc = new Scanner(expression);\\n        sc.useDelimiter(\"\\\\\\\\s|\\\\\\\\b(?=\\\\\\\\))|\\\\\\\\B(?=\\\\\\\\))\");\\n        return parse(sc, contexts);\\n    }\\n    private static java.util.regex.Pattern leftValPat = java.util.regex.Pattern.compile(\"\\\\\\\\p{Ll}[\\\\\\\\p{Ll}\\\\\\\\d]*?(?!\\\\\\\\))\");\\n    private static int parse(Scanner sc, Deque<Map<String, Integer>> contexts) {\\n        String token = sc.next();\\n        int ans;\\n        switch (token) {\\n            case \"(add\":\\n                ans = parse(sc, contexts) + parse(sc, contexts);\\n                sc.next(); // assert sc.next() == \")\";\\n                break;\\n            case \"(mult\":\\n                ans = parse(sc, contexts) * parse(sc, contexts);\\n                sc.next();\\n                break;\\n            case \"(let\":\\n                Map<String, Integer> ctx = new HashMap<>();\\n                contexts.offerFirst(ctx);\\n                while (sc.hasNext(leftValPat)) {\\n                    String varName = sc.next();\\n                    ctx.put(varName, parse(sc, contexts));\\n                }\\n                ans = parse(sc, contexts);\\n                contexts.pollFirst();\\n                sc.next();\\n                break;\\n            default:\\n                ans = Character.isLowerCase(token.charAt(0)) ? getVar(contexts, token) : Integer.parseInt(token);\\n        }\\n        return ans;\\n    }\\n    private static int getVar(Deque<Map<String, Integer>> contexts, String token) {\\n        for (Map<String, Integer> ctx : contexts) {\\n            if (ctx.containsKey(token)) return ctx.get(token);\\n        }\\n        throw new IllegalArgumentException();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int evaluate(String expression) {\\n        Deque<Map<String, Integer>> contexts = new ArrayDeque<>();\\n        Scanner sc = new Scanner(expression);\\n        sc.useDelimiter(\"\\\\\\\\s|\\\\\\\\b(?=\\\\\\\\))|\\\\\\\\B(?=\\\\\\\\))\");\\n        return parse(sc, contexts);\\n    }\\n    private static java.util.regex.Pattern leftValPat = java.util.regex.Pattern.compile(\"\\\\\\\\p{Ll}[\\\\\\\\p{Ll}\\\\\\\\d]*?(?!\\\\\\\\))\");\\n    private static int parse(Scanner sc, Deque<Map<String, Integer>> contexts) {\\n        String token = sc.next();\\n        int ans;\\n        switch (token) {\\n            case \"(add\":\\n                ans = parse(sc, contexts) + parse(sc, contexts);\\n                sc.next(); // assert sc.next() == \")\";\\n                break;\\n            case \"(mult\":\\n                ans = parse(sc, contexts) * parse(sc, contexts);\\n                sc.next();\\n                break;\\n            case \"(let\":\\n                Map<String, Integer> ctx = new HashMap<>();\\n                contexts.offerFirst(ctx);\\n                while (sc.hasNext(leftValPat)) {\\n                    String varName = sc.next();\\n                    ctx.put(varName, parse(sc, contexts));\\n                }\\n                ans = parse(sc, contexts);\\n                contexts.pollFirst();\\n                sc.next();\\n                break;\\n            default:\\n                ans = Character.isLowerCase(token.charAt(0)) ? getVar(contexts, token) : Integer.parseInt(token);\\n        }\\n        return ans;\\n    }\\n    private static int getVar(Deque<Map<String, Integer>> contexts, String token) {\\n        for (Map<String, Integer> ctx : contexts) {\\n            if (ctx.containsKey(token)) return ctx.get(token);\\n        }\\n        throw new IllegalArgumentException();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 667319,
                "title": "golang-easy-to-follow-solution",
                "content": "Follow the defition of an expression, it can be a number or a variable or an operation, recursively parse the string from left to right. Using a global hashset, key is the variable name, value is a stack. When entering the \"let\", push local variable to the stack, when leaving \"let\", pop them out.\\n```\\nvar variables map[string][]int\\n\\nfunc isDigit(b byte) bool {\\n    return b == \\'-\\' || (0 <= b - \\'0\\' && b - \\'0\\' < 10)\\n}\\n\\nfunc isLower(b byte) bool {\\n    return 0 <= b - \\'a\\' && b - \\'a\\' < 26\\n}\\n\\nfunc evalNumber(s string) (int, int) {\\n    n, i := 0, 0\\n    negative := false\\n    if s[i] == \\'-\\' {\\n        negative = true\\n        i++\\n    }\\n    for ; i < len(s) && isDigit(s[i]); i++ {\\n        n = n * 10 + int(s[i]-\\'0\\')\\n    }\\n    if negative {\\n        n = -n\\n    }\\n    return n, i\\n}\\n\\nfunc evalVariable(s string) (string, int, int) {\\n    i := 0\\n    for ; i < len(s) && (isDigit(s[i]) ||isLower(s[i])); i++ {}\\n    var n int\\n    v := s[:i]\\n    if _, exist := variables[v]; exist {\\n        n = variables[v][len(variables[v])-1]\\n    }\\n    \\n    return v, n, i\\n}\\n\\nfunc evalLet(s string) (int, int) {\\n    local := make(map[string]bool)\\n    for i := 0; i < len(s); i++ {\\n        v, n, j := evalExpr(s[i:])\\n        i += j\\n        if s[i] == \\')\\' {\\n            for v, _ := range local {\\n                variables[v] = variables[v][:len(variables[v])-1]\\n            }\\n            return n, i\\n        }\\n        i++\\n        _, n, j = evalExpr(s[i:])\\n        i += j\\n        if local[v] {\\n            variables[v][len(variables[v])-1] = n\\n        } else {\\n            local[v] = true\\n            variables[v] = append(variables[v], n)\\n        }\\n    }\\n    \\n    return 0, 0\\n}\\n\\nfunc evalOp(s string) (int, int) {\\n    var n, i int\\n    if s[0] == \\'l\\' {\\n        n, i = evalLet(s[4:])\\n        i += 4\\n    } else {\\n        i = 4\\n        if s[0] == \\'m\\' {\\n            i = 5\\n        }\\n        _, first, j := evalExpr(s[i:])\\n        i += j + 1\\n        _, second, j := evalExpr(s[i:])\\n        i += j\\n        if s[0] == \\'a\\' {\\n            n = first + second\\n        } else {\\n            n = first * second\\n        }\\n    }\\n    return n, i\\n}\\n\\nfunc evalExpr(s string) (string, int, int) {\\n    if isDigit(s[0]) {\\n        n, i := evalNumber(s)\\n        return \"\", n, i\\n    } else if s[0] == \\'(\\' {\\n        n, i := evalOp(s[1:])\\n        return \"\", n, i + 2\\n    } else {\\n        return evalVariable(s)\\n    }\\n}\\n\\nfunc evaluate(s string) int {\\n    variables = make(map[string][]int)\\n    _, n, _ := evalExpr(s)\\n    return n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvar variables map[string][]int\\n\\nfunc isDigit(b byte) bool {\\n    return b == \\'-\\' || (0 <= b - \\'0\\' && b - \\'0\\' < 10)\\n}\\n\\nfunc isLower(b byte) bool {\\n    return 0 <= b - \\'a\\' && b - \\'a\\' < 26\\n}\\n\\nfunc evalNumber(s string) (int, int) {\\n    n, i := 0, 0\\n    negative := false\\n    if s[i] == \\'-\\' {\\n        negative = true\\n        i++\\n    }\\n    for ; i < len(s) && isDigit(s[i]); i++ {\\n        n = n * 10 + int(s[i]-\\'0\\')\\n    }\\n    if negative {\\n        n = -n\\n    }\\n    return n, i\\n}\\n\\nfunc evalVariable(s string) (string, int, int) {\\n    i := 0\\n    for ; i < len(s) && (isDigit(s[i]) ||isLower(s[i])); i++ {}\\n    var n int\\n    v := s[:i]\\n    if _, exist := variables[v]; exist {\\n        n = variables[v][len(variables[v])-1]\\n    }\\n    \\n    return v, n, i\\n}\\n\\nfunc evalLet(s string) (int, int) {\\n    local := make(map[string]bool)\\n    for i := 0; i < len(s); i++ {\\n        v, n, j := evalExpr(s[i:])\\n        i += j\\n        if s[i] == \\')\\' {\\n            for v, _ := range local {\\n                variables[v] = variables[v][:len(variables[v])-1]\\n            }\\n            return n, i\\n        }\\n        i++\\n        _, n, j = evalExpr(s[i:])\\n        i += j\\n        if local[v] {\\n            variables[v][len(variables[v])-1] = n\\n        } else {\\n            local[v] = true\\n            variables[v] = append(variables[v], n)\\n        }\\n    }\\n    \\n    return 0, 0\\n}\\n\\nfunc evalOp(s string) (int, int) {\\n    var n, i int\\n    if s[0] == \\'l\\' {\\n        n, i = evalLet(s[4:])\\n        i += 4\\n    } else {\\n        i = 4\\n        if s[0] == \\'m\\' {\\n            i = 5\\n        }\\n        _, first, j := evalExpr(s[i:])\\n        i += j + 1\\n        _, second, j := evalExpr(s[i:])\\n        i += j\\n        if s[0] == \\'a\\' {\\n            n = first + second\\n        } else {\\n            n = first * second\\n        }\\n    }\\n    return n, i\\n}\\n\\nfunc evalExpr(s string) (string, int, int) {\\n    if isDigit(s[0]) {\\n        n, i := evalNumber(s)\\n        return \"\", n, i\\n    } else if s[0] == \\'(\\' {\\n        n, i := evalOp(s[1:])\\n        return \"\", n, i + 2\\n    } else {\\n        return evalVariable(s)\\n    }\\n}\\n\\nfunc evaluate(s string) int {\\n    variables = make(map[string][]int)\\n    _, n, _ := evalExpr(s)\\n    return n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 658251,
                "title": "straightforward-java-solution-with-explanation",
                "content": "Ideas\\n\\n1. Parse the input string and store the results into a Queue to handle them in recursion easily\\n2. Handle strings instead of characters so that we can think the algorithm bit higher level without consideration of each character handling\\n3. Do recursion when we meet \\'(\\', and then return the calculated value at \\')\\'. \\'(\\' and \\')\\' are used only for that.\\n4. Map to store the variable and value pairs should be nested and the outer map should be copied to inner map before processing. Then we don\\'t have to worry about the scope of variables\\n5. Focus on the reserved keywords - let, add, mult\\n   . add/multi - we should get the first operand and second operand. Then add/multiply them and return.\\n   . let - We should get the variable and value continuously in loop. In last loop, value part is missing. Then, we need to return a value which comes from recusive call(eg.  \"(let x 7 (add x 1))\"), map (eg.  \"(let x 7 x)\"), or itself - it can be number (eg.  \"(let x 7 -12)\"). Also if the variable part starts with (, it\\'s the last loop.\\n\\n\\nN: length of input string\\ntime complexity: O(N) since it doesn\\'t visit the string again in recursion\\nspace comlexity: O(N^2) since map is nested\\n\\n```\\nclass Solution {\\n    public int evaluate(String expression) {\\n      Queue<String> queue = new LinkedList<>();      \\n      StringBuilder sb = new StringBuilder();\\n      int index = 0;\\n      while(index < expression.length()) {\\n        char c = expression.charAt(index);\\n        if (c == \\'(\\') { \\n          queue.offer(Character.toString(c));\\n          sb = new StringBuilder();\\n        } else if (c == \\')\\') { \\n          if (sb.length() > 0) {\\n            queue.offer(sb.toString());\\n          }\\n          queue.offer(Character.toString(c));\\n          sb = new StringBuilder();\\n        } else if (c == \\' \\') {\\n          if (sb.length() > 0) {\\n            queue.offer(sb.toString());\\n          }\\n          sb = new StringBuilder();\\n        } else { \\n          sb.append(c); \\n        }\\n        index++;\\n      }\\n      if (sb.length() > 0) {\\n        queue.offer(sb.toString());\\n      }\\n      return process(queue, new HashMap<>());\\n    }\\n  \\n    int process(Queue<String> queue, Map<String, Integer> map) {\\n      queue.poll(); // for (\\n      Map<String, Integer> innerMap = new HashMap<>();\\n      for(String s: map.keySet()) {\\n        innerMap.put(s, map.get(s));\\n      }\\n      int result = 0;\\n      String keyword = queue.poll();\\n      if (keyword.equals(\"add\")) {\\n        result = getValue(queue, innerMap) + getValue(queue, innerMap);\\n      } else if (keyword.equals(\"mult\")) {\\n        result = getValue(queue, innerMap) * getValue(queue, innerMap);\\n      } else if (keyword.equals(\"let\")) {\\n        while(true) { \\n          if (queue.peek().equals(\"(\")) {\\n            result = process(queue, innerMap); \\n            break;\\n          } else {\\n            String var = queue.poll(); \\n            if (queue.peek().equals(\")\")) {\\n              result = innerMap.containsKey(var) ? innerMap.get(var) : Integer.parseInt(var);\\n              break;\\n            }\\n            innerMap.put(var, getValue(queue, innerMap));\\n          }\\n        }\\n      }\\n      queue.poll(); // for )\\n      return result; \\n    }\\n  \\n    int getValue(Queue<String> queue, Map<String, Integer> map) {\\n        if (queue.peek().equals(\"(\")) { \\n          return process(queue, map);  \\n        } \\n        String var = queue.poll();\\n        if (isInteger(var)) {\\n          return Integer.parseInt(var);\\n        } \\n        return map.get(var);\\n    }\\n  \\n    boolean isInteger(String s)  {\\n      try {\\n        Integer.parseInt(s);\\n      } catch(Exception e) {\\n        return false; \\n      }\\n      return true; \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int evaluate(String expression) {\\n      Queue<String> queue = new LinkedList<>();      \\n      StringBuilder sb = new StringBuilder();\\n      int index = 0;\\n      while(index < expression.length()) {\\n        char c = expression.charAt(index);\\n        if (c == \\'(\\') { \\n          queue.offer(Character.toString(c));\\n          sb = new StringBuilder();\\n        } else if (c == \\')\\') { \\n          if (sb.length() > 0) {\\n            queue.offer(sb.toString());\\n          }\\n          queue.offer(Character.toString(c));\\n          sb = new StringBuilder();\\n        } else if (c == \\' \\') {\\n          if (sb.length() > 0) {\\n            queue.offer(sb.toString());\\n          }\\n          sb = new StringBuilder();\\n        } else { \\n          sb.append(c); \\n        }\\n        index++;\\n      }\\n      if (sb.length() > 0) {\\n        queue.offer(sb.toString());\\n      }\\n      return process(queue, new HashMap<>());\\n    }\\n  \\n    int process(Queue<String> queue, Map<String, Integer> map) {\\n      queue.poll(); // for (\\n      Map<String, Integer> innerMap = new HashMap<>();\\n      for(String s: map.keySet()) {\\n        innerMap.put(s, map.get(s));\\n      }\\n      int result = 0;\\n      String keyword = queue.poll();\\n      if (keyword.equals(\"add\")) {\\n        result = getValue(queue, innerMap) + getValue(queue, innerMap);\\n      } else if (keyword.equals(\"mult\")) {\\n        result = getValue(queue, innerMap) * getValue(queue, innerMap);\\n      } else if (keyword.equals(\"let\")) {\\n        while(true) { \\n          if (queue.peek().equals(\"(\")) {\\n            result = process(queue, innerMap); \\n            break;\\n          } else {\\n            String var = queue.poll(); \\n            if (queue.peek().equals(\")\")) {\\n              result = innerMap.containsKey(var) ? innerMap.get(var) : Integer.parseInt(var);\\n              break;\\n            }\\n            innerMap.put(var, getValue(queue, innerMap));\\n          }\\n        }\\n      }\\n      queue.poll(); // for )\\n      return result; \\n    }\\n  \\n    int getValue(Queue<String> queue, Map<String, Integer> map) {\\n        if (queue.peek().equals(\"(\")) { \\n          return process(queue, map);  \\n        } \\n        String var = queue.poll();\\n        if (isInteger(var)) {\\n          return Integer.parseInt(var);\\n        } \\n        return map.get(var);\\n    }\\n  \\n    boolean isInteger(String s)  {\\n      try {\\n        Integer.parseInt(s);\\n      } catch(Exception e) {\\n        return false; \\n      }\\n      return true; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 631970,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int evaluate(string e) {\\n        unordered_map<string, int> v_map;\\n        return dfs(v_map, e.substr(1, e.length()-2));\\n    }\\n    \\n    int dfs(unordered_map<string, int> v_map, string e) {\\n        if(e[0] == \\'a\\' || e[0] == \\'m\\') {\\n            int idx = 0, left = 0, right = 0;\\n            \\n            while(e[idx++] != \\' \\');\\n            int p1 = getExpr(v_map, e, idx);\\n            while(e[idx++] != \\' \\');\\n            int p2 = getExpr(v_map, e, idx);\\n            return e[0] == \\'a\\' ? (p1 + p2) : (p1 * p2);\\n        } \\n        \\n        int idx = 3;\\n        while(idx < e.length()) {\\n            while(e[idx] == \\' \\') idx++;\\n            if(!isalpha(e[idx])) break;\\n            \\n            int s = idx;\\n            while(idx < e.length() && e[idx] != \\' \\') idx++;\\n            \\n            string key = e.substr(s, idx - s);\\n            idx++;\\n            if(idx >= e.length()-1) return v_map[key];\\n            \\n            int v = getExpr(v_map, e, idx);\\n            v_map[key] = v;\\n        }\\n        \\n        int start = 0;\\n        return getExpr(v_map, e.substr(idx), start);\\n    }\\n    \\n    int getExpr(unordered_map<string, int> v_map, string e, int& idx) {\\n        int v = 0, sign = 1;\\n        if(e[idx] == \\'(\\') {\\n            int s = idx, sum = 0;\\n            while(idx < e.length()) {\\n                if(e[idx] == \\'(\\') sum--;\\n                else if(e[idx] == \\')\\') sum++;\\n                idx++;\\n                if(sum == 0) break;\\n            }\\n            v = dfs(v_map, e.substr(s+1, idx - s - 2));\\n        } else if(isalpha(e[idx])) {\\n            int s = idx;\\n            while(idx < e.length() && e[idx] != \\' \\') idx++;\\n            v = v_map[e.substr(s, idx - s)];\\n        } else {\\n            if(e[idx] == \\'-\\' || e[idx] == \\'+\\') {sign = e[idx] == \\'-\\' ? -1 : 1; idx++;}\\n            while(idx < e.length() && isdigit(e[idx])) v = v*10 + (e[idx++] - \\'0\\');\\n        }\\n        return v*sign;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int evaluate(string e) {\\n        unordered_map<string, int> v_map;\\n        return dfs(v_map, e.substr(1, e.length()-2));\\n    }\\n    \\n    int dfs(unordered_map<string, int> v_map, string e) {\\n        if(e[0] == \\'a\\' || e[0] == \\'m\\') {\\n            int idx = 0, left = 0, right = 0;\\n            \\n            while(e[idx++] != \\' \\');\\n            int p1 = getExpr(v_map, e, idx);\\n            while(e[idx++] != \\' \\');\\n            int p2 = getExpr(v_map, e, idx);\\n            return e[0] == \\'a\\' ? (p1 + p2) : (p1 * p2);\\n        } \\n        \\n        int idx = 3;\\n        while(idx < e.length()) {\\n            while(e[idx] == \\' \\') idx++;\\n            if(!isalpha(e[idx])) break;\\n            \\n            int s = idx;\\n            while(idx < e.length() && e[idx] != \\' \\') idx++;\\n            \\n            string key = e.substr(s, idx - s);\\n            idx++;\\n            if(idx >= e.length()-1) return v_map[key];\\n            \\n            int v = getExpr(v_map, e, idx);\\n            v_map[key] = v;\\n        }\\n        \\n        int start = 0;\\n        return getExpr(v_map, e.substr(idx), start);\\n    }\\n    \\n    int getExpr(unordered_map<string, int> v_map, string e, int& idx) {\\n        int v = 0, sign = 1;\\n        if(e[idx] == \\'(\\') {\\n            int s = idx, sum = 0;\\n            while(idx < e.length()) {\\n                if(e[idx] == \\'(\\') sum--;\\n                else if(e[idx] == \\')\\') sum++;\\n                idx++;\\n                if(sum == 0) break;\\n            }\\n            v = dfs(v_map, e.substr(s+1, idx - s - 2));\\n        } else if(isalpha(e[idx])) {\\n            int s = idx;\\n            while(idx < e.length() && e[idx] != \\' \\') idx++;\\n            v = v_map[e.substr(s, idx - s)];\\n        } else {\\n            if(e[idx] == \\'-\\' || e[idx] == \\'+\\') {sign = e[idx] == \\'-\\' ? -1 : 1; idx++;}\\n            while(idx < e.length() && isdigit(e[idx])) v = v*10 + (e[idx++] - \\'0\\');\\n        }\\n        return v*sign;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 624342,
                "title": "java-clean-code",
                "content": "```java\\npublic int evaluate(String expression) {\\n\\treturn evaluateHelper(expression, new HashMap<>());\\n}\\n\\nprivate int evaluateHelper(String expr, Map<String, Integer> map) { // map stores expr and evaluated value\\n\\tif (isNumber(expr))\\n\\t\\treturn Integer.valueOf(expr);\\n\\n\\tif (isVariable(expr))\\n\\t\\treturn map.get(expr);\\n\\n\\tint result = 0;\\n\\tList<String> list = parse(expr);\\n\\n\\tString operator = list.get(0);\\n\\n\\tif (operator.equals(\"add\"))\\n\\t\\tresult = evaluateHelper(list.get(1), map) + evaluateHelper(list.get(2), map);\\n\\n\\telse if (operator.equals(\"mult\"))\\n\\t\\tresult = evaluateHelper(list.get(1), map) * evaluateHelper(list.get(2), map);\\n\\n\\telse {\\n\\t\\tMap<String, Integer> another = new HashMap<>(map); // Same variable can have a different value at lower level\\n\\t\\tfor (int i = 1; i < list.size() - 1; i +=2) {\\n\\t\\t\\tanother.put(list.get(i), evaluateHelper(list.get(i + 1), another));\\n\\t\\t}\\n\\t\\tresult = evaluateHelper(list.get(list.size() - 1), another); // Last element is the expression, so evaluate and store in result\\n\\t}\\n\\treturn result;\\n}\\n\\nprivate boolean isNumber(String expr) {\\n\\tchar c = expr.charAt(0);\\n\\treturn c >= \\'0\\' && c <= \\'9\\' || c == \\'-\\';\\n}\\n\\nprivate boolean isVariable(String expr) {\\n\\tchar c = expr.charAt(0);\\n\\treturn c >= \\'a\\' && c <= \\'z\\';\\n}\\n\\nprivate List<String> parse(String expr) {\\n\\tList<String> result = new ArrayList<>();\\n\\texpr = expr.substring(1, expr.length() - 1); // remove parentheses\\n\\n\\tint startIdx = 0;\\n\\twhile (startIdx < expr.length()) {\\n\\t\\tint endIdx = next(expr, startIdx);\\n\\t\\tresult.add(expr.substring(startIdx, endIdx));\\n\\t\\tstartIdx = endIdx + 1;\\n\\t}\\n\\treturn result;\\n}\\n\\nprivate int next(String expr, int startIndex) {\\n\\tint index = startIndex;\\n\\tif (expr.charAt(index) == \\'(\\') {\\n\\t\\tint count = 1;\\n\\t\\tindex++;\\n\\t\\twhile (index < expr.length() && count > 0) {\\n\\t\\t\\tif (expr.charAt(index) == \\'(\\')\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\telse if (expr.charAt(index) == \\')\\')\\n\\t\\t\\t\\tcount--;\\n\\n\\t\\t\\tindex++;\\n\\t\\t}\\n\\t} else {\\n\\t\\twhile (index < expr.length() && expr.charAt(index) != \\' \\') // variable or number\\n\\t\\t\\tindex++;\\n\\t}\\n\\treturn index;\\n}",
                "solutionTags": [],
                "code": "```java\\npublic int evaluate(String expression) {\\n\\treturn evaluateHelper(expression, new HashMap<>());\\n}\\n\\nprivate int evaluateHelper(String expr, Map<String, Integer> map) { // map stores expr and evaluated value\\n\\tif (isNumber(expr))\\n\\t\\treturn Integer.valueOf(expr);\\n\\n\\tif (isVariable(expr))\\n\\t\\treturn map.get(expr);\\n\\n\\tint result = 0;\\n\\tList<String> list = parse(expr);\\n\\n\\tString operator = list.get(0);\\n\\n\\tif (operator.equals(\"add\"))\\n\\t\\tresult = evaluateHelper(list.get(1), map) + evaluateHelper(list.get(2), map);\\n\\n\\telse if (operator.equals(\"mult\"))\\n\\t\\tresult = evaluateHelper(list.get(1), map) * evaluateHelper(list.get(2), map);\\n\\n\\telse {\\n\\t\\tMap<String, Integer> another = new HashMap<>(map); // Same variable can have a different value at lower level\\n\\t\\tfor (int i = 1; i < list.size() - 1; i +=2) {\\n\\t\\t\\tanother.put(list.get(i), evaluateHelper(list.get(i + 1), another));\\n\\t\\t}\\n\\t\\tresult = evaluateHelper(list.get(list.size() - 1), another); // Last element is the expression, so evaluate and store in result\\n\\t}\\n\\treturn result;\\n}\\n\\nprivate boolean isNumber(String expr) {\\n\\tchar c = expr.charAt(0);\\n\\treturn c >= \\'0\\' && c <= \\'9\\' || c == \\'-\\';\\n}\\n\\nprivate boolean isVariable(String expr) {\\n\\tchar c = expr.charAt(0);\\n\\treturn c >= \\'a\\' && c <= \\'z\\';\\n}\\n\\nprivate List<String> parse(String expr) {\\n\\tList<String> result = new ArrayList<>();\\n\\texpr = expr.substring(1, expr.length() - 1); // remove parentheses\\n\\n\\tint startIdx = 0;\\n\\twhile (startIdx < expr.length()) {\\n\\t\\tint endIdx = next(expr, startIdx);\\n\\t\\tresult.add(expr.substring(startIdx, endIdx));\\n\\t\\tstartIdx = endIdx + 1;\\n\\t}\\n\\treturn result;\\n}\\n\\nprivate int next(String expr, int startIndex) {\\n\\tint index = startIndex;\\n\\tif (expr.charAt(index) == \\'(\\') {\\n\\t\\tint count = 1;\\n\\t\\tindex++;\\n\\t\\twhile (index < expr.length() && count > 0) {\\n\\t\\t\\tif (expr.charAt(index) == \\'(\\')\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\telse if (expr.charAt(index) == \\')\\')\\n\\t\\t\\t\\tcount--;\\n\\n\\t\\t\\tindex++;\\n\\t\\t}\\n\\t} else {\\n\\t\\twhile (index < expr.length() && expr.charAt(index) != \\' \\') // variable or number\\n\\t\\t\\tindex++;\\n\\t}\\n\\treturn index;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 588417,
                "title": "java-one-pass-but-not-exactly-o-n",
                "content": "Most solution seen in the discuss is `O(n^2)` when processing the `(`, `)`. My solution is avoiding revising all the character twice. The only reason I say is not `O(n)` is the varaible to value mapping requires a copy every time `i` runs into `(\\'\\n\\n```java\\nprivate static final String ADD = \"add\", MULT = \"mult\", LET = \"let\";\\n  private static final int ADD_VAL = 1, MULT_VAL = 2, LET_VAL = 3;\\n\\n  public int evaluate(String expression) {\\n    int o1 = ADD_VAL, l1 = 0;\\n    /* true iff <c>i</c> pointing to an term that is a variable or the expression in operation Let*/\\n    boolean isVarOrFinalExpression = false;\\n    final Deque<int[]> stack = new ArrayDeque<>();\\n    final Deque<String> varNameStack = new ArrayDeque<>();\\n    final Deque<Map<String, Integer>> varStack = new ArrayDeque<>() {{\\n      push(new HashMap<>());\\n    }};\\n    for (int i = 0; i < expression.length(); ++i) {\\n      final char chr = expression.charAt(i);\\n      if (chr == \\'(\\') { // start\\n        stack.push(new int[]{o1, l1});\\n        assert varStack.peek() != null;\\n        varStack.push(new HashMap<>(varStack.peek()));\\n      } else if (expression.startsWith(ADD, i)) {\\n        o1 = ADD_VAL;\\n        l1 = 0;\\n        i += ADD.length() - 1;\\n        isVarOrFinalExpression = false;\\n      } else if (expression.startsWith(MULT, i)) {\\n        o1 = MULT_VAL;\\n        l1 = 1;\\n        i += MULT.length() - 1;\\n        isVarOrFinalExpression = false;\\n      } else if (expression.startsWith(LET, i)) {\\n        o1 = LET_VAL;\\n        i += LET.length() - 1;\\n        isVarOrFinalExpression = false;\\n      } else if (chr == \\'-\\' || Character.isDigit(chr)) { // is digit\\n        int sign = chr == \\'-\\' ? -1 : 1, num = chr == \\'-\\' ? 0 : chr - \\'0\\';\\n        while (i + 1 < expression.length() && Character.isDigit(expression.charAt(i + 1))) {\\n          num = num * 10 + expression.charAt(i + 1) - \\'0\\';\\n          i++;\\n        }\\n        if (o1 == ADD_VAL) {\\n          l1 += sign * num;\\n        } else if (o1 == MULT_VAL) {\\n          l1 *= sign * num;\\n        } else {\\n          assert o1 == LET_VAL;\\n          assert varStack.peek() != null;\\n          if (isVarOrFinalExpression) {\\n            l1 = sign * num;\\n          } else {\\n            varStack.peek().put(varNameStack.pop(), sign * num);\\n          }\\n        }\\n      } else if (Character.isLetter(chr)) { // variable\\n        final int start = i;\\n        while (i + 1 < expression.length() && Character.isLetterOrDigit(expression.charAt(i + 1))) {\\n          i++;\\n        }\\n        final String varName = expression.substring(start, i + 1);\\n        if (o1 == LET_VAL) {\\n          final var curVarToVal = varStack.peek();\\n          assert curVarToVal != null;\\n          if (isVarOrFinalExpression) {\\n            varNameStack.push(varName);\\n            l1 = curVarToVal.getOrDefault(varName, 0);\\n          } else {\\n            curVarToVal.put(varNameStack.pop(), curVarToVal.get(varName));\\n          }\\n        } else if (o1 == ADD_VAL) {\\n          assert varStack.peek() != null;\\n          l1 += varStack.peek().get(varName);\\n        } else {\\n          assert varStack.peek() != null;\\n          l1 *= varStack.peek().get(varName);\\n        }\\n      } else if (chr == \\')\\') {\\n        final int[] prev = stack.pop();\\n        final int prevOp = prev[0], prevL1 = prev[1];\\n        o1 = prevOp;\\n        varStack.pop();\\n        if (prevOp == ADD_VAL) {\\n          l1 = prevL1 + l1;\\n        } else if (prevOp == MULT_VAL) {\\n          l1 = prevL1 * l1;\\n        } else {\\n          assert prevOp == LET_VAL;\\n          if (varNameStack.isEmpty()) { // is the final expression\\n            // l1 = l1;\\n          } else {\\n            varStack.peek().put(varNameStack.pop(), l1);\\n          }\\n        }\\n      } else if (chr == \\' \\') {\\n        isVarOrFinalExpression = !isVarOrFinalExpression;\\n      }\\n    }\\n    return l1;\\n  }\\n```",
                "solutionTags": [],
                "code": "```java\\nprivate static final String ADD = \"add\", MULT = \"mult\", LET = \"let\";\\n  private static final int ADD_VAL = 1, MULT_VAL = 2, LET_VAL = 3;\\n\\n  public int evaluate(String expression) {\\n    int o1 = ADD_VAL, l1 = 0;\\n    /* true iff <c>i</c> pointing to an term that is a variable or the expression in operation Let*/\\n    boolean isVarOrFinalExpression = false;\\n    final Deque<int[]> stack = new ArrayDeque<>();\\n    final Deque<String> varNameStack = new ArrayDeque<>();\\n    final Deque<Map<String, Integer>> varStack = new ArrayDeque<>() {{\\n      push(new HashMap<>());\\n    }};\\n    for (int i = 0; i < expression.length(); ++i) {\\n      final char chr = expression.charAt(i);\\n      if (chr == \\'(\\') { // start\\n        stack.push(new int[]{o1, l1});\\n        assert varStack.peek() != null;\\n        varStack.push(new HashMap<>(varStack.peek()));\\n      } else if (expression.startsWith(ADD, i)) {\\n        o1 = ADD_VAL;\\n        l1 = 0;\\n        i += ADD.length() - 1;\\n        isVarOrFinalExpression = false;\\n      } else if (expression.startsWith(MULT, i)) {\\n        o1 = MULT_VAL;\\n        l1 = 1;\\n        i += MULT.length() - 1;\\n        isVarOrFinalExpression = false;\\n      } else if (expression.startsWith(LET, i)) {\\n        o1 = LET_VAL;\\n        i += LET.length() - 1;\\n        isVarOrFinalExpression = false;\\n      } else if (chr == \\'-\\' || Character.isDigit(chr)) { // is digit\\n        int sign = chr == \\'-\\' ? -1 : 1, num = chr == \\'-\\' ? 0 : chr - \\'0\\';\\n        while (i + 1 < expression.length() && Character.isDigit(expression.charAt(i + 1))) {\\n          num = num * 10 + expression.charAt(i + 1) - \\'0\\';\\n          i++;\\n        }\\n        if (o1 == ADD_VAL) {\\n          l1 += sign * num;\\n        } else if (o1 == MULT_VAL) {\\n          l1 *= sign * num;\\n        } else {\\n          assert o1 == LET_VAL;\\n          assert varStack.peek() != null;\\n          if (isVarOrFinalExpression) {\\n            l1 = sign * num;\\n          } else {\\n            varStack.peek().put(varNameStack.pop(), sign * num);\\n          }\\n        }\\n      } else if (Character.isLetter(chr)) { // variable\\n        final int start = i;\\n        while (i + 1 < expression.length() && Character.isLetterOrDigit(expression.charAt(i + 1))) {\\n          i++;\\n        }\\n        final String varName = expression.substring(start, i + 1);\\n        if (o1 == LET_VAL) {\\n          final var curVarToVal = varStack.peek();\\n          assert curVarToVal != null;\\n          if (isVarOrFinalExpression) {\\n            varNameStack.push(varName);\\n            l1 = curVarToVal.getOrDefault(varName, 0);\\n          } else {\\n            curVarToVal.put(varNameStack.pop(), curVarToVal.get(varName));\\n          }\\n        } else if (o1 == ADD_VAL) {\\n          assert varStack.peek() != null;\\n          l1 += varStack.peek().get(varName);\\n        } else {\\n          assert varStack.peek() != null;\\n          l1 *= varStack.peek().get(varName);\\n        }\\n      } else if (chr == \\')\\') {\\n        final int[] prev = stack.pop();\\n        final int prevOp = prev[0], prevL1 = prev[1];\\n        o1 = prevOp;\\n        varStack.pop();\\n        if (prevOp == ADD_VAL) {\\n          l1 = prevL1 + l1;\\n        } else if (prevOp == MULT_VAL) {\\n          l1 = prevL1 * l1;\\n        } else {\\n          assert prevOp == LET_VAL;\\n          if (varNameStack.isEmpty()) { // is the final expression\\n            // l1 = l1;\\n          } else {\\n            varStack.peek().put(varNameStack.pop(), l1);\\n          }\\n        }\\n      } else if (chr == \\' \\') {\\n        isVarOrFinalExpression = !isVarOrFinalExpression;\\n      }\\n    }\\n    return l1;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 577778,
                "title": "stack-solution",
                "content": "```\\nclass Solution {\\n    public int evaluate(String ex) {\\n        ex = ex.replaceAll(\"\\\\\\\\(\", \"( \");\\n        ex = ex.replaceAll(\"\\\\\\\\)\", \" )\");\\n        String[] exlist = ex.split(\" \");\\n        Stack<String> op = new Stack<>();//stack peek maintains cur level operation\\n        Stack<Map<String, Integer>> varCache = new Stack<>();//stack peek maintains cur level variable cache\\n        Stack<Stack<Integer>> numSt = new Stack<>();//stack peek maintains cur level numbers\\n        Stack<Stack<String>> varSt = new Stack<>();//stack peek maintains cur level variable to be allocated\\n        Set<String> opSet = new HashSet<>(Arrays.asList(\"mult\", \"add\", \"let\"));\\n        numSt.push(new Stack<>()); varSt.push(new Stack<>()); varCache.push(new HashMap<>());\\n        for (int i = 0; i < exlist.length; i++) {\\n            String cur = exlist[i];\\n            if (opSet.contains(cur)) {\\n                op.push(cur);\\n            } else if (cur.equals(\"(\")) {\\n                varCache.push(new HashMap<>(varCache.peek()));\\n                numSt.push(new Stack<>());\\n                varSt.push(new Stack<>());\\n            } else if (cur.equals(\")\")) {\\n                String curOp = op.pop();\\n                Stack<Integer> curLv = numSt.pop();\\n                if (curOp.equals(\"add\")) curLv.push(curLv.pop() + curLv.pop());\\n                else if (curOp.equals(\"mult\")) curLv.push(curLv.pop() * curLv.pop());\\n                numSt.peek().push(curLv.peek());\\n                varCache.pop(); varSt.pop();\\n                if (!op.isEmpty()) {\\n                    String preOp = op.peek();\\n                    if (preOp.equals(\"let\")) {\\n                        Stack<String> vst = varSt.peek();\\n                        if (!vst.isEmpty()) {\\n                            varCache.peek().put(vst.pop(), numSt.peek().peek());\\n                        }\\n                    }\\n                }\\n            } else if (isNum(cur)) {\\n                int curNum = Integer.valueOf(cur);\\n                if (op.peek().equals(\"let\") && !varSt.peek().isEmpty()) {\\n                    varCache.peek().put(varSt.peek().pop(), curNum);\\n                } else {\\n                    numSt.peek().push(curNum);\\n                }\\n                \\n            } else if (isSpace(cur)) {\\n                continue;\\n            } else {\\n                String curOp = op.peek();\\n                if (curOp.equals(\"let\")) {\\n                    if (!varSt.peek().isEmpty()) {\\n                        String curVar = varSt.peek().pop();\\n                        varCache.peek().put(curVar, varCache.peek().get(cur));\\n                    } else if (!exlist[i + 1].equals(\")\")){\\n                        varSt.peek().push(cur);\\n                    } else {\\n                        numSt.peek().push(varCache.peek().get(cur));\\n                    }\\n                } else {\\n                    numSt.peek().push(varCache.peek().get(cur));\\n                }\\n            }\\n        }\\n        return numSt.peek().peek();\\n    }\\n    \\n    private boolean isNum(String s) {\\n        for (char c : s.toCharArray()) {\\n            if (!Character.isDigit(c) && c != \\'-\\') return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isSpace(String s) {\\n        for (char c : s.toCharArray()) {\\n            if (c != \\' \\') return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int evaluate(String ex) {\\n        ex = ex.replaceAll(\"\\\\\\\\(\", \"( \");\\n        ex = ex.replaceAll(\"\\\\\\\\)\", \" )\");\\n        String[] exlist = ex.split(\" \");\\n        Stack<String> op = new Stack<>();//stack peek maintains cur level operation\\n        Stack<Map<String, Integer>> varCache = new Stack<>();//stack peek maintains cur level variable cache\\n        Stack<Stack<Integer>> numSt = new Stack<>();//stack peek maintains cur level numbers\\n        Stack<Stack<String>> varSt = new Stack<>();//stack peek maintains cur level variable to be allocated\\n        Set<String> opSet = new HashSet<>(Arrays.asList(\"mult\", \"add\", \"let\"));\\n        numSt.push(new Stack<>()); varSt.push(new Stack<>()); varCache.push(new HashMap<>());\\n        for (int i = 0; i < exlist.length; i++) {\\n            String cur = exlist[i];\\n            if (opSet.contains(cur)) {\\n                op.push(cur);\\n            } else if (cur.equals(\"(\")) {\\n                varCache.push(new HashMap<>(varCache.peek()));\\n                numSt.push(new Stack<>());\\n                varSt.push(new Stack<>());\\n            } else if (cur.equals(\")\")) {\\n                String curOp = op.pop();\\n                Stack<Integer> curLv = numSt.pop();\\n                if (curOp.equals(\"add\")) curLv.push(curLv.pop() + curLv.pop());\\n                else if (curOp.equals(\"mult\")) curLv.push(curLv.pop() * curLv.pop());\\n                numSt.peek().push(curLv.peek());\\n                varCache.pop(); varSt.pop();\\n                if (!op.isEmpty()) {\\n                    String preOp = op.peek();\\n                    if (preOp.equals(\"let\")) {\\n                        Stack<String> vst = varSt.peek();\\n                        if (!vst.isEmpty()) {\\n                            varCache.peek().put(vst.pop(), numSt.peek().peek());\\n                        }\\n                    }\\n                }\\n            } else if (isNum(cur)) {\\n                int curNum = Integer.valueOf(cur);\\n                if (op.peek().equals(\"let\") && !varSt.peek().isEmpty()) {\\n                    varCache.peek().put(varSt.peek().pop(), curNum);\\n                } else {\\n                    numSt.peek().push(curNum);\\n                }\\n                \\n            } else if (isSpace(cur)) {\\n                continue;\\n            } else {\\n                String curOp = op.peek();\\n                if (curOp.equals(\"let\")) {\\n                    if (!varSt.peek().isEmpty()) {\\n                        String curVar = varSt.peek().pop();\\n                        varCache.peek().put(curVar, varCache.peek().get(cur));\\n                    } else if (!exlist[i + 1].equals(\")\")){\\n                        varSt.peek().push(cur);\\n                    } else {\\n                        numSt.peek().push(varCache.peek().get(cur));\\n                    }\\n                } else {\\n                    numSt.peek().push(varCache.peek().get(cur));\\n                }\\n            }\\n        }\\n        return numSt.peek().peek();\\n    }\\n    \\n    private boolean isNum(String s) {\\n        for (char c : s.toCharArray()) {\\n            if (!Character.isDigit(c) && c != \\'-\\') return false;\\n        }\\n        return true;\\n    }\\n    \\n    private boolean isSpace(String s) {\\n        for (char c : s.toCharArray()) {\\n            if (c != \\' \\') return false;\\n        }\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 573310,
                "title": "java-one-pass-stack-solution-o-n",
                "content": "Just [call stack](https://en.wikipedia.org/wiki/Call_stack) idea. e.g.\\n\\n```\\nfunc foo:\\n    var x, y ...\\n    bar(x, y)\\n\\nfunc bar (a, b)\\n    return a + b\\n```\\n\\nWhen ```bar```  is invoked inside ``` foo```, the local variables(```x,y```) in ```foo``` are pushed into stack so that when ```bar``` returns ```foo```can continue. Inputs to ```bar``` are passed (by value or reference) from ```foo```.\\n\\n\\n```\\n\\n    static class Node{\\n        String verb;\\n        String lastVar;                     // needed by LET\\n        Map<String, Integer> valueMap;      // needed by LET\\n        List<String> ops;                   // needed by ADD/MUL\\n        \\n        Node(String s) {\\n            verb = s;\\n            ops = new ArrayList<>();\\n        }\\n    }\\n    \\n    public int evaluate(String expression) {\\n        \\n        char[] exp = expression.toCharArray();        \\n        Deque<Node> stack = new LinkedList<>();\\n        \\n        int res = 0;  // result returned from a func call (bar) to its parent (foo)\\n\\n        for (int i = 0; i < exp.length; i++) {\\n            \\n            // new func call (bar)\\n            if (exp[i] == \\'(\\') {\\n                String verb = expression.substring(i + 1, i + 4);\\n                Node node = new Node(verb);\\n                node.valueMap = stack.isEmpty() ? new HashMap<>() : new HashMap<>(stack.peek().valueMap);\\n                stack.push(node);\\n                i = i + 4;  // skip let/add/mul\\n            }\\n            \\n            // variable name\\n            else if (Character.isLetter(exp[i])) {\\n                StringBuilder sb = new StringBuilder();\\n                for (; i < exp.length && exp[i] != \\' \\' && exp[i] != \\')\\'; i++) {\\n                    sb.append(exp[i]);\\n                }\\n                \\n                String varName = sb.toString();\\n                Node peek = stack.peek();\\n                if (peek.lastVar != null && !peek.valueMap.containsKey(peek.lastVar)) {\\n                    peek.valueMap.put(peek.lastVar, peek.valueMap.get(varName));\\n                } else {\\n                    peek.lastVar = varName;\\n                }\\n                \\n                if (!peek.verb.equals(\"let\")) {\\n                    peek.ops.add(varName);\\n                }\\n            }\\n            \\n            // number\\n            else if (exp[i] == \\'+\\' || exp[i] == \\'-\\' || Character.isDigit(exp[i])) {\\n                int start = i;\\n                i++;\\n                while (i < exp.length && Character.isDigit(exp[i])) i++;\\n                int val = Integer.parseInt(expression.substring(start, i));\\n\\n                Node peek = stack.peek();\\n                if (peek.verb.equals(\"let\")) {\\n                    peek.valueMap.put(peek.lastVar, val);\\n                } else {\\n                    peek.ops.add(String.valueOf(val));\\n                }\\n            }\\n            \\n            // pop the top node\\n            else if (exp[i] == \\')\\') {    \\n                Node pop = stack.pop();\\n                if (pop.verb.equals(\"let\")) {\\n                    res = pop.valueMap.get(pop.lastVar);\\n                } else { \\n                    String op1Str = pop.ops.get(0), op2Str = pop.ops.get(1);\\n                    int op1 = pop.valueMap.containsKey(op1Str) ? pop.valueMap.get(op1Str) : Integer.parseInt(op1Str);\\n                    int op2 = pop.valueMap.containsKey(op2Str) ? pop.valueMap.get(op2Str) : Integer.parseInt(op2Str);\\n                    res = pop.verb.equals(\"add\") ? op1 + op2 : op1 * op2;\\n                }\\n                \\n                // return the result to the parent func (foo)\\n                if (!stack.isEmpty()) {\\n                    if (stack.peek().verb.equals(\"let\")) \\n                        stack.peek().valueMap.put(stack.peek().lastVar, res);\\n                    else \\n                        stack.peek().ops.add(String.valueOf(res));\\n                } \\n            }\\n            \\n            // else: move on\\n        }\\n        \\n        return res;\\n    }\\n    \\n\\n```",
                "solutionTags": [],
                "code": "```\\nfunc foo:\\n    var x, y ...\\n    bar(x, y)\\n\\nfunc bar (a, b)\\n    return a + b\\n```\n```bar```\n``` foo```\n```x,y```\n```foo```\n```bar```\n```foo```\n```bar```\n```foo```\n```\\n\\n    static class Node{\\n        String verb;\\n        String lastVar;                     // needed by LET\\n        Map<String, Integer> valueMap;      // needed by LET\\n        List<String> ops;                   // needed by ADD/MUL\\n        \\n        Node(String s) {\\n            verb = s;\\n            ops = new ArrayList<>();\\n        }\\n    }\\n    \\n    public int evaluate(String expression) {\\n        \\n        char[] exp = expression.toCharArray();        \\n        Deque<Node> stack = new LinkedList<>();\\n        \\n        int res = 0;  // result returned from a func call (bar) to its parent (foo)\\n\\n        for (int i = 0; i < exp.length; i++) {\\n            \\n            // new func call (bar)\\n            if (exp[i] == \\'(\\') {\\n                String verb = expression.substring(i + 1, i + 4);\\n                Node node = new Node(verb);\\n                node.valueMap = stack.isEmpty() ? new HashMap<>() : new HashMap<>(stack.peek().valueMap);\\n                stack.push(node);\\n                i = i + 4;  // skip let/add/mul\\n            }\\n            \\n            // variable name\\n            else if (Character.isLetter(exp[i])) {\\n                StringBuilder sb = new StringBuilder();\\n                for (; i < exp.length && exp[i] != \\' \\' && exp[i] != \\')\\'; i++) {\\n                    sb.append(exp[i]);\\n                }\\n                \\n                String varName = sb.toString();\\n                Node peek = stack.peek();\\n                if (peek.lastVar != null && !peek.valueMap.containsKey(peek.lastVar)) {\\n                    peek.valueMap.put(peek.lastVar, peek.valueMap.get(varName));\\n                } else {\\n                    peek.lastVar = varName;\\n                }\\n                \\n                if (!peek.verb.equals(\"let\")) {\\n                    peek.ops.add(varName);\\n                }\\n            }\\n            \\n            // number\\n            else if (exp[i] == \\'+\\' || exp[i] == \\'-\\' || Character.isDigit(exp[i])) {\\n                int start = i;\\n                i++;\\n                while (i < exp.length && Character.isDigit(exp[i])) i++;\\n                int val = Integer.parseInt(expression.substring(start, i));\\n\\n                Node peek = stack.peek();\\n                if (peek.verb.equals(\"let\")) {\\n                    peek.valueMap.put(peek.lastVar, val);\\n                } else {\\n                    peek.ops.add(String.valueOf(val));\\n                }\\n            }\\n            \\n            // pop the top node\\n            else if (exp[i] == \\')\\') {    \\n                Node pop = stack.pop();\\n                if (pop.verb.equals(\"let\")) {\\n                    res = pop.valueMap.get(pop.lastVar);\\n                } else { \\n                    String op1Str = pop.ops.get(0), op2Str = pop.ops.get(1);\\n                    int op1 = pop.valueMap.containsKey(op1Str) ? pop.valueMap.get(op1Str) : Integer.parseInt(op1Str);\\n                    int op2 = pop.valueMap.containsKey(op2Str) ? pop.valueMap.get(op2Str) : Integer.parseInt(op2Str);\\n                    res = pop.verb.equals(\"add\") ? op1 + op2 : op1 * op2;\\n                }\\n                \\n                // return the result to the parent func (foo)\\n                if (!stack.isEmpty()) {\\n                    if (stack.peek().verb.equals(\"let\")) \\n                        stack.peek().valueMap.put(stack.peek().lastVar, res);\\n                    else \\n                        stack.peek().ops.add(String.valueOf(res));\\n                } \\n            }\\n            \\n            // else: move on\\n        }\\n        \\n        return res;\\n    }\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 520244,
                "title": "c-solution",
                "content": "```\\n    int evaluate(string e) {\\n        unordered_map<string, int> v_map;\\n        return dfs(v_map, e.substr(1, e.length()-2));\\n    }\\n    \\n    int dfs(unordered_map<string, int> v_map, string e) {\\n        if(e[0] == \\'a\\' || e[0] == \\'m\\') {\\n            int idx = 0, left = 0, right = 0;\\n            \\n            while(e[idx++] != \\' \\');\\n            int p1 = getExpr(v_map, e, idx);\\n            while(e[idx++] != \\' \\');\\n            int p2 = getExpr(v_map, e, idx);\\n            return e[0] == \\'a\\' ? p1 + p2 : p1 * p2;\\n        } \\n        \\n        int idx = 3;\\n        while(idx < e.length()) {\\n            while(e[idx] == \\' \\') idx++;\\n            if(!isalpha(e[idx])) break;\\n            \\n            int s = idx;\\n            while(idx < e.length() && e[idx] != \\' \\') idx++;\\n            \\n            string key = e.substr(s, idx - s);\\n            idx++;\\n            if(idx >= e.length()-1) return v_map[key];\\n            \\n            int v = getExpr(v_map, e, idx);\\n            v_map[key] = v;\\n        }\\n        \\n        int start = 0;\\n        return getExpr(v_map, e.substr(idx), start);\\n    }\\n    \\n    int getExpr(unordered_map<string, int> v_map, string e, int& idx) {\\n        int v = 0, sign = 1;\\n        if(e[idx] == \\'(\\') {\\n            int s = idx, sum = 0;\\n            while(idx < e.length()) {\\n                if(e[idx] == \\'(\\') sum--;\\n                else if(e[idx] == \\')\\') sum++;\\n                idx++;\\n                if(sum == 0) break;\\n            }\\n            v = dfs(v_map, e.substr(s+1, idx - s - 2));\\n        } else if(isalpha(e[idx])) {\\n            int s = idx;\\n            while(idx < e.length() && e[idx] != \\' \\') idx++;\\n            v = v_map[e.substr(s, idx - s)];\\n        } else {\\n            if(e[idx] == \\'-\\' || e[idx] == \\'+\\') {sign = e[idx] == \\'-\\' ? -1 : 1; idx++;}\\n            while(idx < e.length() && isdigit(e[idx])) v = v*10 + (e[idx++] - \\'0\\');\\n        }\\n        return v*sign;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    int evaluate(string e) {\\n        unordered_map<string, int> v_map;\\n        return dfs(v_map, e.substr(1, e.length()-2));\\n    }\\n    \\n    int dfs(unordered_map<string, int> v_map, string e) {\\n        if(e[0] == \\'a\\' || e[0] == \\'m\\') {\\n            int idx = 0, left = 0, right = 0;\\n            \\n            while(e[idx++] != \\' \\');\\n            int p1 = getExpr(v_map, e, idx);\\n            while(e[idx++] != \\' \\');\\n            int p2 = getExpr(v_map, e, idx);\\n            return e[0] == \\'a\\' ? p1 + p2 : p1 * p2;\\n        } \\n        \\n        int idx = 3;\\n        while(idx < e.length()) {\\n            while(e[idx] == \\' \\') idx++;\\n            if(!isalpha(e[idx])) break;\\n            \\n            int s = idx;\\n            while(idx < e.length() && e[idx] != \\' \\') idx++;\\n            \\n            string key = e.substr(s, idx - s);\\n            idx++;\\n            if(idx >= e.length()-1) return v_map[key];\\n            \\n            int v = getExpr(v_map, e, idx);\\n            v_map[key] = v;\\n        }\\n        \\n        int start = 0;\\n        return getExpr(v_map, e.substr(idx), start);\\n    }\\n    \\n    int getExpr(unordered_map<string, int> v_map, string e, int& idx) {\\n        int v = 0, sign = 1;\\n        if(e[idx] == \\'(\\') {\\n            int s = idx, sum = 0;\\n            while(idx < e.length()) {\\n                if(e[idx] == \\'(\\') sum--;\\n                else if(e[idx] == \\')\\') sum++;\\n                idx++;\\n                if(sum == 0) break;\\n            }\\n            v = dfs(v_map, e.substr(s+1, idx - s - 2));\\n        } else if(isalpha(e[idx])) {\\n            int s = idx;\\n            while(idx < e.length() && e[idx] != \\' \\') idx++;\\n            v = v_map[e.substr(s, idx - s)];\\n        } else {\\n            if(e[idx] == \\'-\\' || e[idx] == \\'+\\') {sign = e[idx] == \\'-\\' ? -1 : 1; idx++;}\\n            while(idx < e.length() && isdigit(e[idx])) v = v*10 + (e[idx++] - \\'0\\');\\n        }\\n        return v*sign;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 513679,
                "title": "clean-logic-python-recursion-solution",
                "content": "three cases in first level: digit, variable, another expression \\'()\\'\\nanother three cases when meeting new expression in the first level: add, mult, let\\nwhen meeting let, use a stack to store variables in the same level, remove their value when current let finish\\n\\ninspired by https://leetcode.com/problems/parse-lisp-expression/discuss/191901/The-most-concise-Python-implementation-to-achieve-TRUE-O(N)-time-complexity.\\n\\n```\\n        token = expression.replace(\"(\", \" ( \").replace(\")\", \" ) \").split()\\n        variables = collections.defaultdict(list)\\n        \\n        def evalue(token):\\n            cur = token.pop(0)\\n            if cur.isdigit() or cur.replace(\"-\", \"\").isdigit():\\n                return int(cur)\\n            if cur in variables:\\n                return variables[cur][-1]\\n            if cur == \"(\":\\n                cur = token.pop(0)\\n                if cur == \"add\":\\n                    val = evalue(token) + evalue(token)\\n                    token.pop(0) # remove \\')\\'\\n                    return val\\n                if cur == \"mult\":\\n                    val = evalue(token) * evalue(token)\\n                    token.pop(0) # remove \\')\\'\\n                    return val\\n                if cur == \"let\":\\n                    temp_var = []\\n                    while token:\\n                        if token[0] == \"(\" or token[1] == \")\":\\n                            val = evalue(token)\\n                            while temp_var:\\n                                variables[temp_var.pop()].pop() # clean up same level variables\\' values\\n                            token.pop(0) # remove \\')\\'\\n                            return val\\n                        var = token.pop(0)\\n                        temp_var.append(var)\\n                        value = evalue(token)\\n                        variables[var].append(value)\\n        \\n        return evalue(token)\\n```",
                "solutionTags": [],
                "code": "```\\n        token = expression.replace(\"(\", \" ( \").replace(\")\", \" ) \").split()\\n        variables = collections.defaultdict(list)\\n        \\n        def evalue(token):\\n            cur = token.pop(0)\\n            if cur.isdigit() or cur.replace(\"-\", \"\").isdigit():\\n                return int(cur)\\n            if cur in variables:\\n                return variables[cur][-1]\\n            if cur == \"(\":\\n                cur = token.pop(0)\\n                if cur == \"add\":\\n                    val = evalue(token) + evalue(token)\\n                    token.pop(0) # remove \\')\\'\\n                    return val\\n                if cur == \"mult\":\\n                    val = evalue(token) * evalue(token)\\n                    token.pop(0) # remove \\')\\'\\n                    return val\\n                if cur == \"let\":\\n                    temp_var = []\\n                    while token:\\n                        if token[0] == \"(\" or token[1] == \")\":\\n                            val = evalue(token)\\n                            while temp_var:\\n                                variables[temp_var.pop()].pop() # clean up same level variables\\' values\\n                            token.pop(0) # remove \\')\\'\\n                            return val\\n                        var = token.pop(0)\\n                        temp_var.append(var)\\n                        value = evalue(token)\\n                        variables[var].append(value)\\n        \\n        return evalue(token)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 501965,
                "title": "python-4-cases",
                "content": "the expression is\\n1. either a **let** \\n1. either a **add** \\n1. either a **mult** \\n1. either a variable meant to be evaluated or a constant number (an int) \\n\\nI passed along a hashmap h where \\n```\\nh ={ \\'a\\':1, \\'b\\': 2}\\nmeans a = 1 and b = 2\\n```\\nmaking a copy of of everytime because its mutable, (python passes a pointer of it to modify it), we want the opposite, the changes to be flushed only one way from the \"larger\" scope to the \"smaller\" one\\n\\naka\\n\\nif I evaluated so far x,y,z,b,c \\nI am passing along to an expression e\\nwithin that scope it does whatever it wants as long as it does not modigy my hashmap \\n\\n\\n\\n```\\nclass Solution(object):\\n    def evaluate(self, expression, h = {}):\\n        if expression[:4] == \\'(let\\':\\n            local_h = {k:h[k] for k in h} \\n            temp = self.f(expression[5:-1])\\n            for e,v in [(temp[2*i],temp[2*i +1]) for i in range(len(temp)/2)]:  \\n                local_h[e] = self.evaluate(v, local_h)\\n            return self.evaluate(temp[-1], local_h)\\n        elif expression[:5] == \\'(mult\\':\\n            a,b = self.f(expression[6:-1])\\n            return self.evaluate(a,h) * self.evaluate(b,h)\\n        elif expression[:4] == \\'(add\\':\\n            a,b = self.f(expression[5:-1])\\n            return self.evaluate(a,h) + self.evaluate(b,h)\\n        return h[expression] if expression in h else int(expression)\\n    \\n\\t\\n    #get the sequence of \"balance stable\" terms , \\'(())\\' is balanced , \\'(()\\' has a +1 balance, etc...\\n    def f(self,s):\\n        res,i,j, bal = [],0,0,0\\n        while(i<len(s)):\\n            j = i\\n            while(j < len(s) and (bal or s[j] != \\' \\')):\\n                bal += 1 if s[j] == \\'(\\' else (-1 if s[j] == \\')\\' else 0)\\n                j += 1\\n            res.append(s[i:j])\\n            i = j+1\\n        return res\\n```\\n\\nget the balanced terms in a recursive way\\n```\\n    def f_recursive(self,s):\\n        if s == \\'\\': return []\\n        j, bal = 0, 0\\n        while(j < len(s) and (bal or s[j] != \\' \\')):\\n            bal += 1 if s[j] == \\'(\\' else (-1 if s[j] == \\')\\' else 0)\\n            j += 1\\n        return [s[:j]] + self.f_recursive(s[j + 1:])\\n```",
                "solutionTags": [],
                "code": "```\\nh ={ \\'a\\':1, \\'b\\': 2}\\nmeans a = 1 and b = 2\\n```\n```\\nclass Solution(object):\\n    def evaluate(self, expression, h = {}):\\n        if expression[:4] == \\'(let\\':\\n            local_h = {k:h[k] for k in h} \\n            temp = self.f(expression[5:-1])\\n            for e,v in [(temp[2*i],temp[2*i +1]) for i in range(len(temp)/2)]:  \\n                local_h[e] = self.evaluate(v, local_h)\\n            return self.evaluate(temp[-1], local_h)\\n        elif expression[:5] == \\'(mult\\':\\n            a,b = self.f(expression[6:-1])\\n            return self.evaluate(a,h) * self.evaluate(b,h)\\n        elif expression[:4] == \\'(add\\':\\n            a,b = self.f(expression[5:-1])\\n            return self.evaluate(a,h) + self.evaluate(b,h)\\n        return h[expression] if expression in h else int(expression)\\n    \\n\\t\\n    #get the sequence of \"balance stable\" terms , \\'(())\\' is balanced , \\'(()\\' has a +1 balance, etc...\\n    def f(self,s):\\n        res,i,j, bal = [],0,0,0\\n        while(i<len(s)):\\n            j = i\\n            while(j < len(s) and (bal or s[j] != \\' \\')):\\n                bal += 1 if s[j] == \\'(\\' else (-1 if s[j] == \\')\\' else 0)\\n                j += 1\\n            res.append(s[i:j])\\n            i = j+1\\n        return res\\n```\n```\\n    def f_recursive(self,s):\\n        if s == \\'\\': return []\\n        j, bal = 0, 0\\n        while(j < len(s) and (bal or s[j] != \\' \\')):\\n            bal += 1 if s[j] == \\'(\\' else (-1 if s[j] == \\')\\' else 0)\\n            j += 1\\n        return [s[:j]] + self.f_recursive(s[j + 1:])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 478959,
                "title": "tokenization-and-top-down-parsing-clean-javascript-solution-beats-100",
                "content": "```\\n/**\\n * @param {string} expression\\n * @return {number}\\n */\\nvar evaluate = function(expression) {\\n    const tokens = tokenizer(expression);\\n    let i = 0;\\n    \\n    function exec(scope) {\\n        let value = null;\\n        \\n        const next = tokens[i++];\\n        if (next === \\'(\\') {\\n            scope = enter(scope);\\n            \\n            switch (tokens[i++]) {\\n                case \\'add\\':\\n                    const a = exec(scope); \\n                    const b = exec(scope); \\n                    value = a + b;\\n                    break;\\n                    \\n                case \\'mult\\':\\n                    const x = exec(scope);\\n                    const y = exec(scope);\\n                    value = x * y;\\n                    break;\\n                    \\n                case \\'let\\':\\n                    while (tokens[i] !== \\'(\\' && tokens[i + 1] !== \\')\\') {\\n                        scope.variables[tokens[i++]] = exec(scope);\\n                    }\\n                    value = exec(scope);\\n                    break;\\n            }\\n            \\n            scope = exit(scope); \\n            // consume the closing \")\"\\n            i++;\\n            \\n        } else if (isNumber(next)) {\\n            value = Number(next);\\n            \\n        } else {\\n            // Find variable in current scope otherwise go to parent\\n            let t = scope;\\n            while (t) {\\n                if (next in t.variables) {\\n                    value = t.variables[next];\\n                    break;\\n                }\\n                \\n                t = t.parent;\\n            }\\n        }\\n        \\n        return value;\\n    }\\n    \\n    return exec(newScope());\\n};\\n\\nfunction tokenizer(expression) {\\n    const tokens = [];\\n    let token = \\'\\';\\n    for (const c of expression) {\\n        if (c === \\'(\\' || c === \\')\\') {\\n            if (token) tokens.push(token);\\n            tokens.push(c);\\n            token = \\'\\';\\n        } else if (c === \\' \\') {\\n            if (token) tokens.push(token);\\n            token = \\'\\';\\n        } else {\\n            token += c;\\n        }\\n    }\\n    \\n    if (token) {\\n        tokens.push(token);\\n    }\\n    \\n    return tokens;\\n}\\n\\nfunction isNumber(n) {\\n    return !isNaN(n);\\n}\\n\\nfunction newScope() {\\n    return { parent: null, variables: {} };\\n}\\n\\nfunction enter(scope) {\\n    const next = newScope();\\n    next.parent = scope;\\n    return next;\\n}\\n\\nfunction exit(scope) {\\n    return scope.parent;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} expression\\n * @return {number}\\n */\\nvar evaluate = function(expression) {\\n    const tokens = tokenizer(expression);\\n    let i = 0;\\n    \\n    function exec(scope) {\\n        let value = null;\\n        \\n        const next = tokens[i++];\\n        if (next === \\'(\\') {\\n            scope = enter(scope);\\n            \\n            switch (tokens[i++]) {\\n                case \\'add\\':\\n                    const a = exec(scope); \\n                    const b = exec(scope); \\n                    value = a + b;\\n                    break;\\n                    \\n                case \\'mult\\':\\n                    const x = exec(scope);\\n                    const y = exec(scope);\\n                    value = x * y;\\n                    break;\\n                    \\n                case \\'let\\':\\n                    while (tokens[i] !== \\'(\\' && tokens[i + 1] !== \\')\\') {\\n                        scope.variables[tokens[i++]] = exec(scope);\\n                    }\\n                    value = exec(scope);\\n                    break;\\n            }\\n            \\n            scope = exit(scope); \\n            // consume the closing \")\"\\n            i++;\\n            \\n        } else if (isNumber(next)) {\\n            value = Number(next);\\n            \\n        } else {\\n            // Find variable in current scope otherwise go to parent\\n            let t = scope;\\n            while (t) {\\n                if (next in t.variables) {\\n                    value = t.variables[next];\\n                    break;\\n                }\\n                \\n                t = t.parent;\\n            }\\n        }\\n        \\n        return value;\\n    }\\n    \\n    return exec(newScope());\\n};\\n\\nfunction tokenizer(expression) {\\n    const tokens = [];\\n    let token = \\'\\';\\n    for (const c of expression) {\\n        if (c === \\'(\\' || c === \\')\\') {\\n            if (token) tokens.push(token);\\n            tokens.push(c);\\n            token = \\'\\';\\n        } else if (c === \\' \\') {\\n            if (token) tokens.push(token);\\n            token = \\'\\';\\n        } else {\\n            token += c;\\n        }\\n    }\\n    \\n    if (token) {\\n        tokens.push(token);\\n    }\\n    \\n    return tokens;\\n}\\n\\nfunction isNumber(n) {\\n    return !isNaN(n);\\n}\\n\\nfunction newScope() {\\n    return { parent: null, variables: {} };\\n}\\n\\nfunction enter(scope) {\\n    const next = newScope();\\n    next.parent = scope;\\n    return next;\\n}\\n\\nfunction exit(scope) {\\n    return scope.parent;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 466353,
                "title": "c-o-n-recursive-top-down-parsing",
                "content": "```\\nclass Solution {\\n    int parseInt(const string &str, int &idx) {\\n        int result = 0;\\n        bool negative = false;\\n        if (str[idx] == \\'-\\') {\\n            negative = true;\\n            idx++;\\n        }\\n        for (; idx < str.length() && isdigit(str[idx]); idx++) {\\n            result = result * 10 + (str[idx] - \\'0\\');\\n        }\\n        if (negative) {\\n            result = -result;\\n        }\\n        return result;\\n    }\\n    string parseName(const string &str, int &idx) {\\n        string result;\\n        for (; idx < str.length() && isalnum(str[idx]); idx++) {\\n            result.push_back(str[idx]);\\n        }\\n        return result;\\n    }\\n    int parseLet(const string &str, int &idx, vector<unordered_map<string, int>> &scopes) {\\n        int result;\\n        for (idx += 4; idx < str.length() && str[idx] == \\' \\';) {\\n            idx++;\\n            if (str[idx] == \\'(\\' || str[idx] == \\'-\\' || isdigit(str[idx])) {\\n                result = parseExpr(str, idx, scopes);\\n            } else {\\n                string name = parseName(str, idx);\\n                if (str[idx] == \\')\\') {\\n                    result = find(scopes, name)->second;\\n                } else {\\n                    //str[idx] == \\' \\'\\n                    idx++;\\n                    int val = parseExpr(str, idx, scopes);\\n                    scopes.back()[name] = val;\\n                }\\n            }\\n        }\\n        idx++;\\n        return result;\\n    }\\n    int parseAdd(const string &str, int &idx, vector<unordered_map<string, int>> &scopes) {\\n        idx += 5;\\n        int val1 = parseExpr(str, idx, scopes);\\n        idx++;\\n        int val2 = parseExpr(str, idx, scopes);\\n        idx++;\\n        return val1 + val2;\\n    }\\n    int parseMult(const string &str, int &idx, vector<unordered_map<string, int>> &scopes) {\\n        idx += 6;\\n        int val1 = parseExpr(str, idx, scopes);\\n        idx++;\\n        int val2 = parseExpr(str, idx, scopes);\\n        idx++;\\n        return val1 * val2;\\n    }\\n    unordered_map<string, int>::iterator find(vector<unordered_map<string, int>> &scopes, const string &name) {\\n        for (int i = scopes.size() - 1; i >= 0; i--) {\\n            auto it = scopes[i].find(name);\\n            if (it != scopes[i].end()) {\\n                return it;\\n            }\\n        }\\n        return scopes.back().end();\\n    }\\n    int parseExpr(const string &str, int &idx, vector<unordered_map<string, int>> &scopes) {\\n        scopes.emplace_back();\\n        int result;\\n        if (str[idx] == \\'-\\' || isdigit(str[idx])) {\\n            result = parseInt(str, idx);\\n        } else if (str[idx] == \\'(\\') {\\n            if (str[idx + 1] == \\'l\\') {\\n                result = parseLet(str, idx, scopes);\\n            } else if (str[idx + 1] == \\'a\\') {\\n                result = parseAdd(str, idx, scopes);\\n            } else if (str[idx + 1] == \\'m\\') {\\n                result = parseMult(str, idx, scopes);\\n            }\\n        } else {\\n            string name = parseName(str, idx);\\n            auto it = find(scopes, name);\\n            result = it->second;\\n        }\\n        scopes.pop_back();\\n        return result;\\n    }\\npublic:\\n    int evaluate(string expression) {\\n        int idx = 0;\\n        vector<unordered_map<string, int>> scopes;\\n        return parseExpr(expression, idx, scopes);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int parseInt(const string &str, int &idx) {\\n        int result = 0;\\n        bool negative = false;\\n        if (str[idx] == \\'-\\') {\\n            negative = true;\\n            idx++;\\n        }\\n        for (; idx < str.length() && isdigit(str[idx]); idx++) {\\n            result = result * 10 + (str[idx] - \\'0\\');\\n        }\\n        if (negative) {\\n            result = -result;\\n        }\\n        return result;\\n    }\\n    string parseName(const string &str, int &idx) {\\n        string result;\\n        for (; idx < str.length() && isalnum(str[idx]); idx++) {\\n            result.push_back(str[idx]);\\n        }\\n        return result;\\n    }\\n    int parseLet(const string &str, int &idx, vector<unordered_map<string, int>> &scopes) {\\n        int result;\\n        for (idx += 4; idx < str.length() && str[idx] == \\' \\';) {\\n            idx++;\\n            if (str[idx] == \\'(\\' || str[idx] == \\'-\\' || isdigit(str[idx])) {\\n                result = parseExpr(str, idx, scopes);\\n            } else {\\n                string name = parseName(str, idx);\\n                if (str[idx] == \\')\\') {\\n                    result = find(scopes, name)->second;\\n                } else {\\n                    //str[idx] == \\' \\'\\n                    idx++;\\n                    int val = parseExpr(str, idx, scopes);\\n                    scopes.back()[name] = val;\\n                }\\n            }\\n        }\\n        idx++;\\n        return result;\\n    }\\n    int parseAdd(const string &str, int &idx, vector<unordered_map<string, int>> &scopes) {\\n        idx += 5;\\n        int val1 = parseExpr(str, idx, scopes);\\n        idx++;\\n        int val2 = parseExpr(str, idx, scopes);\\n        idx++;\\n        return val1 + val2;\\n    }\\n    int parseMult(const string &str, int &idx, vector<unordered_map<string, int>> &scopes) {\\n        idx += 6;\\n        int val1 = parseExpr(str, idx, scopes);\\n        idx++;\\n        int val2 = parseExpr(str, idx, scopes);\\n        idx++;\\n        return val1 * val2;\\n    }\\n    unordered_map<string, int>::iterator find(vector<unordered_map<string, int>> &scopes, const string &name) {\\n        for (int i = scopes.size() - 1; i >= 0; i--) {\\n            auto it = scopes[i].find(name);\\n            if (it != scopes[i].end()) {\\n                return it;\\n            }\\n        }\\n        return scopes.back().end();\\n    }\\n    int parseExpr(const string &str, int &idx, vector<unordered_map<string, int>> &scopes) {\\n        scopes.emplace_back();\\n        int result;\\n        if (str[idx] == \\'-\\' || isdigit(str[idx])) {\\n            result = parseInt(str, idx);\\n        } else if (str[idx] == \\'(\\') {\\n            if (str[idx + 1] == \\'l\\') {\\n                result = parseLet(str, idx, scopes);\\n            } else if (str[idx + 1] == \\'a\\') {\\n                result = parseAdd(str, idx, scopes);\\n            } else if (str[idx + 1] == \\'m\\') {\\n                result = parseMult(str, idx, scopes);\\n            }\\n        } else {\\n            string name = parseName(str, idx);\\n            auto it = find(scopes, name);\\n            result = it->second;\\n        }\\n        scopes.pop_back();\\n        return result;\\n    }\\npublic:\\n    int evaluate(string expression) {\\n        int idx = 0;\\n        vector<unordered_map<string, int>> scopes;\\n        return parseExpr(expression, idx, scopes);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 455381,
                "title": "c-solution-using-recursion-with-comments",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    unordered_map<string,vector<int>> total;\\n    \\n    int dfs(string& expression,int& c)\\n    {\\n        //parentheses\\n        if(expression[c]==\\'(\\')\\n        {\\n            c++;//left parenthesis\\n            int r=dfs(expression,c);//valid expression\\n            c++;//right parenthesis\\n            return r;\\n        }\\n        //parse the first element\\n        string current=\"\";\\n        while(true)\\n        {\\n            if(c<expression.length()&&expression[c]!=\\' \\'&&expression[c]!=\\')\\')\\n            {\\n                current+=expression[c];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n            c++;\\n        }\\n        //end condition\\n        if(current!=\"add\"&&current!=\"mult\"&&current!=\"let\")\\n        {\\n            if(isdigit(current[0])||current[0]==\\'-\\')\\n            {\\n                return stoi(current);\\n            }\\n            else\\n            {\\n                return total[current].back();\\n            }\\n        }\\n        //add,mult,let\\n        c++;//jump over the space\\n        if(current==\"add\")\\n        {\\n            int first=dfs(expression,c);\\n            c++;\\n            int second=dfs(expression,c);\\n            return first+second;\\n        }\\n        else if(current==\"mult\")\\n        {\\n            int first=dfs(expression,c);\\n            c++;\\n            int second=dfs(expression,c);\\n            return first*second;\\n        }\\n        else if(current==\"let\")\\n        {\\n            unordered_map<string,int> overall; //used to record the variables to be popped\\n            while(true)\\n            {\\n                string variable_name=\"\";\\n                int k=c;\\n                int t=0; //check if the parentheses are closed\\n                while(true)\\n                {\\n                    if(c<expression.length()&&(expression[c]!=\\' \\'||t>0))\\n                    {\\n                        variable_name+=expression[c];\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                    if(expression[c]==\\'(\\')\\n                    {\\n                        t++;\\n                    }\\n                    else if(expression[c]==\\')\\')\\n                    {\\n                        t--;\\n                        if(t<=0)\\n                        {\\n                            break;\\n                        }\\n                    }\\n                    c++;\\n                }\\n                if(c<expression.length()&&expression[c]==\\')\\')\\n                {\\n                    c=k;\\n                    int r=dfs(expression,c);\\n                    for(unordered_map<string,int>::iterator it=overall.begin();it!=overall.end();it++)\\n                    {\\n                        for(int i=0;i<it->second;i++)\\n                        {\\n                            total[it->first].pop_back();\\n                        }\\n                    }\\n                    return r;\\n                }\\n                c++;\\n                int r=dfs(expression,c);\\n                total[variable_name].push_back(r);\\n                overall[variable_name]++;\\n                c++;\\n            }\\n        }\\n        return -1;\\n    }\\n    int evaluate(string expression) \\n    {\\n        int c=0;\\n        return dfs(expression,c);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    unordered_map<string,vector<int>> total;\\n    \\n    int dfs(string& expression,int& c)\\n    {\\n        //parentheses\\n        if(expression[c]==\\'(\\')\\n        {\\n            c++;//left parenthesis\\n            int r=dfs(expression,c);//valid expression\\n            c++;//right parenthesis\\n            return r;\\n        }\\n        //parse the first element\\n        string current=\"\";\\n        while(true)\\n        {\\n            if(c<expression.length()&&expression[c]!=\\' \\'&&expression[c]!=\\')\\')\\n            {\\n                current+=expression[c];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n            c++;\\n        }\\n        //end condition\\n        if(current!=\"add\"&&current!=\"mult\"&&current!=\"let\")\\n        {\\n            if(isdigit(current[0])||current[0]==\\'-\\')\\n            {\\n                return stoi(current);\\n            }\\n            else\\n            {\\n                return total[current].back();\\n            }\\n        }\\n        //add,mult,let\\n        c++;//jump over the space\\n        if(current==\"add\")\\n        {\\n            int first=dfs(expression,c);\\n            c++;\\n            int second=dfs(expression,c);\\n            return first+second;\\n        }\\n        else if(current==\"mult\")\\n        {\\n            int first=dfs(expression,c);\\n            c++;\\n            int second=dfs(expression,c);\\n            return first*second;\\n        }\\n        else if(current==\"let\")\\n        {\\n            unordered_map<string,int> overall; //used to record the variables to be popped\\n            while(true)\\n            {\\n                string variable_name=\"\";\\n                int k=c;\\n                int t=0; //check if the parentheses are closed\\n                while(true)\\n                {\\n                    if(c<expression.length()&&(expression[c]!=\\' \\'||t>0))\\n                    {\\n                        variable_name+=expression[c];\\n                    }\\n                    else\\n                    {\\n                        break;\\n                    }\\n                    if(expression[c]==\\'(\\')\\n                    {\\n                        t++;\\n                    }\\n                    else if(expression[c]==\\')\\')\\n                    {\\n                        t--;\\n                        if(t<=0)\\n                        {\\n                            break;\\n                        }\\n                    }\\n                    c++;\\n                }\\n                if(c<expression.length()&&expression[c]==\\')\\')\\n                {\\n                    c=k;\\n                    int r=dfs(expression,c);\\n                    for(unordered_map<string,int>::iterator it=overall.begin();it!=overall.end();it++)\\n                    {\\n                        for(int i=0;i<it->second;i++)\\n                        {\\n                            total[it->first].pop_back();\\n                        }\\n                    }\\n                    return r;\\n                }\\n                c++;\\n                int r=dfs(expression,c);\\n                total[variable_name].push_back(r);\\n                overall[variable_name]++;\\n                c++;\\n            }\\n        }\\n        return -1;\\n    }\\n    int evaluate(string expression) \\n    {\\n        int c=0;\\n        return dfs(expression,c);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 440958,
                "title": "go-recursive-0-ms-2-3-mb",
                "content": "```go\\ntype op int\\ntype scope map[string]int\\n\\nconst (\\n\\tlet op = iota\\n\\tadd\\n\\tmult\\n)\\n\\nvar vars = []scope{}\\n\\nfunc getVal(s string) int {\\n\\tif s[0] >= \\'0\\' && s[0] <= \\'9\\' || s[0] == \\'-\\' {\\n\\t\\tnum, _ := strconv.Atoi(s)\\n\\t\\treturn num\\n\\t}\\n\\n\\tfor i := len(vars) - 1; i >= 0; i-- {\\n\\t\\tif v, ok := vars[i][s]; ok {\\n\\t\\t\\treturn v\\n\\t\\t}\\n\\t}\\n\\n\\treturn 0\\n}\\n\\nfunc getOperand(s string) (int, string) {\\n\\tvar pos int\\n\\tif s[0] != \\'(\\' {\\n\\t\\tpos = strings.IndexByte(s, \\' \\')\\n\\t\\tif pos == -1 {\\n\\t\\t\\treturn getVal(s), \"\"\\n\\t\\t}\\n\\t\\treturn getVal(s[:pos]), s[pos+1:]\\n\\t}\\n\\n\\tvar pars int\\n\\tfor pos = range s {\\n\\t\\tswitch s[pos] {\\n\\t\\tcase \\'(\\':\\n\\t\\t\\tpars++\\n\\t\\tcase \\')\\':\\n\\t\\t\\tpars--\\n\\t\\t}\\n\\t\\tif pars == 0 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tif pos == len(s)-1 {\\n\\t\\treturn evaluate(s), \"\"\\n\\t}\\n\\n\\tnum := evaluate(s[:pos+1])\\n\\treturn num, s[pos+2:]\\n}\\n\\nfunc parseLet(s string) int {\\n\\tvar pos int\\n\\tvar name string\\n\\tvar vals string\\n\\tvar first bool\\n\\n\\tlocal := scope{}\\n\\tvars = append(vars, local)\\n\\n\\tfor {\\n\\t\\tif first {\\n\\t\\t\\tif s[0] == \\'(\\' {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpos = strings.IndexByte(s, \\' \\')\\n\\t\\tif pos == -1 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tname = s[:pos]\\n\\t\\ts = s[pos+1:]\\n\\n\\t\\tif s[0] == \\'(\\' {\\n\\t\\t\\tnum, s2 := getOperand(s)\\n\\t\\t\\ts = s2\\n\\t\\t\\tlocal[name] = num\\n\\t\\t} else {\\n\\t\\t\\tpos = strings.IndexByte(s, \\' \\')\\n\\t\\t\\tvals = s[:pos]\\n\\t\\t\\tlocal[name] = getVal(vals)\\n\\t\\t\\ts = s[pos+1:]\\n\\t\\t}\\n\\t\\tfirst = true\\n\\t}\\n\\n\\tnum, _ := getOperand(s)\\n\\tvars = vars[:len(vars)-1]\\n\\treturn num\\n}\\n\\nfunc calc(o op, op1, op2 int) int {\\n\\tswitch o {\\n\\tcase add:\\n\\t\\treturn op1 + op2\\n\\tcase mult:\\n\\t\\treturn op1 * op2\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc evaluate(exp string) int {\\n\\texp = exp[1 : len(exp)-1]\\n\\tvar op op\\n\\n\\tswitch {\\n\\tcase strings.HasPrefix(exp, \"let\"):\\n\\t\\top = let\\n\\t\\treturn parseLet(exp[4:])\\n\\tcase strings.HasPrefix(exp, \"add\"):\\n\\t\\top = add\\n\\t\\texp = exp[4:]\\n\\tcase strings.HasPrefix(exp, \"mult\"):\\n\\t\\top = mult\\n\\t\\texp = exp[5:]\\n\\t}\\n\\n\\top1, exp := getOperand(exp)\\n\\top2, _ := getOperand(exp)\\n\\n\\treturn calc(op, op1, op2)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\ntype op int\\ntype scope map[string]int\\n\\nconst (\\n\\tlet op = iota\\n\\tadd\\n\\tmult\\n)\\n\\nvar vars = []scope{}\\n\\nfunc getVal(s string) int {\\n\\tif s[0] >= \\'0\\' && s[0] <= \\'9\\' || s[0] == \\'-\\' {\\n\\t\\tnum, _ := strconv.Atoi(s)\\n\\t\\treturn num\\n\\t}\\n\\n\\tfor i := len(vars) - 1; i >= 0; i-- {\\n\\t\\tif v, ok := vars[i][s]; ok {\\n\\t\\t\\treturn v\\n\\t\\t}\\n\\t}\\n\\n\\treturn 0\\n}\\n\\nfunc getOperand(s string) (int, string) {\\n\\tvar pos int\\n\\tif s[0] != \\'(\\' {\\n\\t\\tpos = strings.IndexByte(s, \\' \\')\\n\\t\\tif pos == -1 {\\n\\t\\t\\treturn getVal(s), \"\"\\n\\t\\t}\\n\\t\\treturn getVal(s[:pos]), s[pos+1:]\\n\\t}\\n\\n\\tvar pars int\\n\\tfor pos = range s {\\n\\t\\tswitch s[pos] {\\n\\t\\tcase \\'(\\':\\n\\t\\t\\tpars++\\n\\t\\tcase \\')\\':\\n\\t\\t\\tpars--\\n\\t\\t}\\n\\t\\tif pars == 0 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t}\\n\\n\\tif pos == len(s)-1 {\\n\\t\\treturn evaluate(s), \"\"\\n\\t}\\n\\n\\tnum := evaluate(s[:pos+1])\\n\\treturn num, s[pos+2:]\\n}\\n\\nfunc parseLet(s string) int {\\n\\tvar pos int\\n\\tvar name string\\n\\tvar vals string\\n\\tvar first bool\\n\\n\\tlocal := scope{}\\n\\tvars = append(vars, local)\\n\\n\\tfor {\\n\\t\\tif first {\\n\\t\\t\\tif s[0] == \\'(\\' {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tpos = strings.IndexByte(s, \\' \\')\\n\\t\\tif pos == -1 {\\n\\t\\t\\tbreak\\n\\t\\t}\\n\\t\\tname = s[:pos]\\n\\t\\ts = s[pos+1:]\\n\\n\\t\\tif s[0] == \\'(\\' {\\n\\t\\t\\tnum, s2 := getOperand(s)\\n\\t\\t\\ts = s2\\n\\t\\t\\tlocal[name] = num\\n\\t\\t} else {\\n\\t\\t\\tpos = strings.IndexByte(s, \\' \\')\\n\\t\\t\\tvals = s[:pos]\\n\\t\\t\\tlocal[name] = getVal(vals)\\n\\t\\t\\ts = s[pos+1:]\\n\\t\\t}\\n\\t\\tfirst = true\\n\\t}\\n\\n\\tnum, _ := getOperand(s)\\n\\tvars = vars[:len(vars)-1]\\n\\treturn num\\n}\\n\\nfunc calc(o op, op1, op2 int) int {\\n\\tswitch o {\\n\\tcase add:\\n\\t\\treturn op1 + op2\\n\\tcase mult:\\n\\t\\treturn op1 * op2\\n\\t}\\n\\treturn 0\\n}\\n\\nfunc evaluate(exp string) int {\\n\\texp = exp[1 : len(exp)-1]\\n\\tvar op op\\n\\n\\tswitch {\\n\\tcase strings.HasPrefix(exp, \"let\"):\\n\\t\\top = let\\n\\t\\treturn parseLet(exp[4:])\\n\\tcase strings.HasPrefix(exp, \"add\"):\\n\\t\\top = add\\n\\t\\texp = exp[4:]\\n\\tcase strings.HasPrefix(exp, \"mult\"):\\n\\t\\top = mult\\n\\t\\texp = exp[5:]\\n\\t}\\n\\n\\top1, exp := getOperand(exp)\\n\\top2, _ := getOperand(exp)\\n\\n\\treturn calc(op, op1, op2)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 437177,
                "title": "clean-c-answer-4ms",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<unordered_map<string,int>> v;\\n    \\n    int evaluate(string e) {\\n        int idx = 0;\\n        return expr(e, idx);\\n    }\\n    \\n    bool isInt(string &e, int idx) {\\n        if (e[idx] != \\'-\\' && !isdigit(e[idx])) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isLet(string &e, int idx) {\\n        if ((idx + 3) >= e.size()) return false;\\n        return e.substr(idx, 4) == \"(let\";\\n    }\\n    \\n    bool isAdd(string &e, int idx) {\\n        if ((idx + 3) >= e.size()) return false;\\n        return e.substr(idx, 4) == \"(add\";\\n    }\\n    \\n    bool isMult(string &e, int idx) {\\n        if ((idx + 4) >= e.size()) return false;\\n        return e.substr(idx, 5) == \"(mult\";\\n    }\\n    \\n    bool isVar(string &e, int &idx) {\\n        if ((\\'a\\' <= e[idx] && e[idx] <= \\'z\\') || (\\'A\\' <= e[idx] && e[idx] <= \\'Z\\')) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int expr(string e, int &idx) {\\n        if (isInt(e, idx)) {\\n            return parseInt(e, idx);\\n        } else if (isLet(e, idx)) {\\n            return parseLet(e, idx);\\n        } else if (isAdd(e, idx)) {\\n            return parseAdd(e, idx);\\n        } else if (isMult(e, idx)) {\\n            return parseMult(e, idx);\\n        } else if (isVar(e, idx)) {\\n            return parseVar(e, idx);\\n        }\\n        return -1;\\n    }\\n    \\n    int lookup(string& name) {\\n        int len = v.size();\\n        for(int i = len-1; i >= 0; i--) {\\n            if (v[i].count(name)) {\\n                return v[i][name];\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    int parseInt(string &e, int &idx) {\\n        int s = idx;\\n        if (e[idx] == \\'-\\') idx++;\\n        while(idx < e.size() && isdigit(e[idx])) idx++;\\n        string res = e.substr(s, idx-s);\\n        return stoi(res);\\n    }\\n    \\n    int parseVar(string &e, int &idx) {\\n        int s = idx;\\n        while(idx < e.size() && isalnum(e[idx])) idx++;\\n        string name = e.substr(s, idx-s);\\n        int res = lookup(name);\\n        return res;\\n    }\\n    \\n    int parseLet(string &e, int &idx) {\\n        idx += 4;\\n        unordered_map<string,int> env;\\n        v.push_back(env);\\n        while(e[idx] == \\' \\') idx++;\\n        while(idx < e.size()) {\\n            int s = idx;\\n\\t\\t\\t// if the next expression is the last expression \\n\\t\\t\\t// in the current Let expression\\n            if (e[idx] == \\'(\\') {\\n                int res = expr(e, idx);\\n                idx++;\\n                v.pop_back();\\n                return res;\\n            }\\n            while(isalnum(e[idx])) idx++;\\n            string name = e.substr(s, idx-s);\\n\\t\\t\\t// if the name is the last expression \\n\\t\\t\\t// in the Let expression\\n            if (e[idx] == \\')\\') {\\n                idx++;\\n                int res = lookup(name);\\n                v.pop_back();\\n                return res;\\n            }\\n            while(e[idx] == \\' \\') idx++;\\n            int num = expr(e, idx);\\n            v.back()[name] = num;\\n            while(idx < e.size() && e[idx] == \\' \\') idx++;\\n        }\\n        return -1;\\n    }\\n    \\n    int parseAdd(string &e, int &idx) {\\n        idx += 4;\\n        while(e[idx] == \\' \\') idx++;\\n        int num1 = expr(e, idx);\\n        while(e[idx] == \\' \\') idx++;\\n        int num2 = expr(e, idx);\\n        idx++;\\n        return num1 + num2;\\n    }\\n    \\n    int parseMult(string &e, int &idx) {\\n        idx += 5;\\n        while(e[idx] == \\' \\') idx++;\\n        int num1 = expr(e, idx);\\n        while(e[idx] == \\' \\') idx++;\\n        int num2 = expr(e, idx);\\n        idx++;\\n        return num1 * num2;\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<unordered_map<string,int>> v;\\n    \\n    int evaluate(string e) {\\n        int idx = 0;\\n        return expr(e, idx);\\n    }\\n    \\n    bool isInt(string &e, int idx) {\\n        if (e[idx] != \\'-\\' && !isdigit(e[idx])) {\\n            return false;\\n        }\\n        return true;\\n    }\\n    \\n    bool isLet(string &e, int idx) {\\n        if ((idx + 3) >= e.size()) return false;\\n        return e.substr(idx, 4) == \"(let\";\\n    }\\n    \\n    bool isAdd(string &e, int idx) {\\n        if ((idx + 3) >= e.size()) return false;\\n        return e.substr(idx, 4) == \"(add\";\\n    }\\n    \\n    bool isMult(string &e, int idx) {\\n        if ((idx + 4) >= e.size()) return false;\\n        return e.substr(idx, 5) == \"(mult\";\\n    }\\n    \\n    bool isVar(string &e, int &idx) {\\n        if ((\\'a\\' <= e[idx] && e[idx] <= \\'z\\') || (\\'A\\' <= e[idx] && e[idx] <= \\'Z\\')) {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    int expr(string e, int &idx) {\\n        if (isInt(e, idx)) {\\n            return parseInt(e, idx);\\n        } else if (isLet(e, idx)) {\\n            return parseLet(e, idx);\\n        } else if (isAdd(e, idx)) {\\n            return parseAdd(e, idx);\\n        } else if (isMult(e, idx)) {\\n            return parseMult(e, idx);\\n        } else if (isVar(e, idx)) {\\n            return parseVar(e, idx);\\n        }\\n        return -1;\\n    }\\n    \\n    int lookup(string& name) {\\n        int len = v.size();\\n        for(int i = len-1; i >= 0; i--) {\\n            if (v[i].count(name)) {\\n                return v[i][name];\\n            }\\n        }\\n        return 0;\\n    }\\n    \\n    int parseInt(string &e, int &idx) {\\n        int s = idx;\\n        if (e[idx] == \\'-\\') idx++;\\n        while(idx < e.size() && isdigit(e[idx])) idx++;\\n        string res = e.substr(s, idx-s);\\n        return stoi(res);\\n    }\\n    \\n    int parseVar(string &e, int &idx) {\\n        int s = idx;\\n        while(idx < e.size() && isalnum(e[idx])) idx++;\\n        string name = e.substr(s, idx-s);\\n        int res = lookup(name);\\n        return res;\\n    }\\n    \\n    int parseLet(string &e, int &idx) {\\n        idx += 4;\\n        unordered_map<string,int> env;\\n        v.push_back(env);\\n        while(e[idx] == \\' \\') idx++;\\n        while(idx < e.size()) {\\n            int s = idx;\\n\\t\\t\\t// if the next expression is the last expression \\n\\t\\t\\t// in the current Let expression\\n            if (e[idx] == \\'(\\') {\\n                int res = expr(e, idx);\\n                idx++;\\n                v.pop_back();\\n                return res;\\n            }\\n            while(isalnum(e[idx])) idx++;\\n            string name = e.substr(s, idx-s);\\n\\t\\t\\t// if the name is the last expression \\n\\t\\t\\t// in the Let expression\\n            if (e[idx] == \\')\\') {\\n                idx++;\\n                int res = lookup(name);\\n                v.pop_back();\\n                return res;\\n            }\\n            while(e[idx] == \\' \\') idx++;\\n            int num = expr(e, idx);\\n            v.back()[name] = num;\\n            while(idx < e.size() && e[idx] == \\' \\') idx++;\\n        }\\n        return -1;\\n    }\\n    \\n    int parseAdd(string &e, int &idx) {\\n        idx += 4;\\n        while(e[idx] == \\' \\') idx++;\\n        int num1 = expr(e, idx);\\n        while(e[idx] == \\' \\') idx++;\\n        int num2 = expr(e, idx);\\n        idx++;\\n        return num1 + num2;\\n    }\\n    \\n    int parseMult(string &e, int &idx) {\\n        idx += 5;\\n        while(e[idx] == \\' \\') idx++;\\n        int num1 = expr(e, idx);\\n        while(e[idx] == \\' \\') idx++;\\n        int num2 = expr(e, idx);\\n        idx++;\\n        return num1 * num2;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 436435,
                "title": "c-solution-with-recursion-and-stack-of-variables",
                "content": "```\\nusing VarsT = unordered_map<string, stack<int>>;\\n\\nbool isNumber(char c) {\\n    return (c >= \\'0\\' && c <= \\'9\\') || c == \\'-\\';\\n}\\n\\nvector<string> parseSubExprs(const string& expr) {\\n    int openCnt = 0;\\n    size_t start = 0;\\n    vector<string> subExprs;\\n    for (size_t i = 1; i < expr.size(); ++i) {\\n        if (expr[i] == \\' \\' && openCnt == 0) {\\n            subExprs.push_back(expr.substr(start, i - start));\\n            start = i + 1;\\n        } else if (expr[i] == \\'(\\') {\\n            ++openCnt;\\n        } else if (expr[i] == \\')\\') {\\n            --openCnt;\\n        }\\n    }\\n    subExprs.push_back(expr.substr(start));\\n    return subExprs;\\n}\\n\\nint evalImpl(const string& expr, VarsT& vars) {\\n    if (isNumber(expr[0]))\\n        return stoi(expr);\\n    if (expr[0] == \\'(\\')\\n        return evalImpl(expr.substr(1, expr.size() - 2), vars);\\n    auto subExprs = parseSubExprs(expr);\\n    if (subExprs.front() == \"add\") {\\n        return evalImpl(subExprs[1], vars) + evalImpl(subExprs[2], vars);\\n    } else if (subExprs.front() == \"mult\") {\\n        return evalImpl(subExprs[1], vars) * evalImpl(subExprs[2], vars);\\n    } else if (subExprs.front() == \"let\") {\\n        vector<string> pushedVars;\\n        for (size_t i = 1; i < subExprs.size() - 1; i += 2) {\\n            pushedVars.push_back(subExprs[i]);\\n            vars[subExprs[i]].push(evalImpl(subExprs[i + 1], vars));\\n        }\\n        auto res = evalImpl(subExprs.back(), vars);\\n        for (const auto& var : pushedVars)\\n            vars[var].pop();\\n        return res;\\n    }\\n    return vars[expr].top();\\n}\\n\\nint evaluate(const string& exp) {\\n    VarsT vars;\\n    return evalImpl(exp, vars);\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\nusing VarsT = unordered_map<string, stack<int>>;\\n\\nbool isNumber(char c) {\\n    return (c >= \\'0\\' && c <= \\'9\\') || c == \\'-\\';\\n}\\n\\nvector<string> parseSubExprs(const string& expr) {\\n    int openCnt = 0;\\n    size_t start = 0;\\n    vector<string> subExprs;\\n    for (size_t i = 1; i < expr.size(); ++i) {\\n        if (expr[i] == \\' \\' && openCnt == 0) {\\n            subExprs.push_back(expr.substr(start, i - start));\\n            start = i + 1;\\n        } else if (expr[i] == \\'(\\') {\\n            ++openCnt;\\n        } else if (expr[i] == \\')\\') {\\n            --openCnt;\\n        }\\n    }\\n    subExprs.push_back(expr.substr(start));\\n    return subExprs;\\n}\\n\\nint evalImpl(const string& expr, VarsT& vars) {\\n    if (isNumber(expr[0]))\\n        return stoi(expr);\\n    if (expr[0] == \\'(\\')\\n        return evalImpl(expr.substr(1, expr.size() - 2), vars);\\n    auto subExprs = parseSubExprs(expr);\\n    if (subExprs.front() == \"add\") {\\n        return evalImpl(subExprs[1], vars) + evalImpl(subExprs[2], vars);\\n    } else if (subExprs.front() == \"mult\") {\\n        return evalImpl(subExprs[1], vars) * evalImpl(subExprs[2], vars);\\n    } else if (subExprs.front() == \"let\") {\\n        vector<string> pushedVars;\\n        for (size_t i = 1; i < subExprs.size() - 1; i += 2) {\\n            pushedVars.push_back(subExprs[i]);\\n            vars[subExprs[i]].push(evalImpl(subExprs[i + 1], vars));\\n        }\\n        auto res = evalImpl(subExprs.back(), vars);\\n        for (const auto& var : pushedVars)\\n            vars[var].pop();\\n        return res;\\n    }\\n    return vars[expr].top();\\n}\\n\\nint evaluate(const string& exp) {\\n    VarsT vars;\\n    return evalImpl(exp, vars);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 435307,
                "title": "this-is-a-very-challenge-but-effective-question-in-interview",
                "content": "Although the discription is very long, the question itself is quite straight forward. That means you have to handle the pressure and be concise on thinking through.\\n\\nSince the previous value could get into the following expression, I used a Map to record the value and pass it on recursion. \\n\\nFor each recursion layer, if the value was changed, the current map will change and will not effect layers on top of it.\\n```\\nclass Solution {\\n    public int evaluate(String expression) {\\n        Map<String,Integer> map = new HashMap();\\n        return evaluate(expression, map);\\n    }\\n    private int evaluate(String expression, Map<String,Integer> map){\\n        if(expression.charAt(0) <=\\'9\\'&&expression.charAt(0)>=\\'0\\'||expression.charAt(0)==\\'-\\') return Integer.parseInt(expression);\\n        if(expression.charAt(0)!=\\'(\\') return map.get(expression);\\n        Map<String,Integer> curMap = new HashMap();\\n        curMap.putAll(map);\\n        int index = expression.indexOf(\" \");\\n        String operator = expression.substring(1,index);\\n        if(operator.equals(\"let\")){\\n            boolean isVar = true;\\n            String var =\" \"; int value=-1, endIndex = findExpressionEnd(expression,index+1);\\n            while(endIndex<expression.length()-1){\\n                endIndex = findExpressionEnd(expression,index+1);\\n                if(isVar){\\n                    var = expression.substring(index+1,endIndex);\\n                    isVar = false;\\n                }else{\\n                    value = evaluate(expression.substring(index+1,endIndex),curMap);\\n                    curMap.put(var,value);\\n                    isVar = true;\\n                }\\n                index = endIndex;\\n            }\\n            return evaluate(var,curMap); \\n            \\n        }\\n        else if(operator.equals(\"add\")){\\n            int endIndex = findExpressionEnd(expression,index+1);\\n            int add1 = evaluate(expression.substring(index+1,endIndex),curMap);\\n            index = endIndex;\\n            endIndex = findExpressionEnd(expression,index+1);\\n            int add2 = evaluate(expression.substring(index+1,endIndex),curMap);\\n            return add1 + add2;\\n        }\\n        else if(operator.equals(\"mult\")){\\n            int endIndex = findExpressionEnd(expression,index+1);\\n            int add1 = evaluate(expression.substring(index+1,endIndex),curMap);\\n            index = endIndex;\\n            endIndex = findExpressionEnd(expression,index+1);\\n            int add2 = evaluate(expression.substring(index+1,endIndex),curMap);\\n            return add1 * add2;\\n        }else \\n            return -1;\\n    }\\n    private int findExpressionEnd(String s, int startIndex){\\n        if(s.charAt(startIndex)!=\\'(\\') return s.indexOf(\" \",startIndex)>0?s.indexOf(\" \",startIndex):s.indexOf(\")\",startIndex);\\n        int stack = 1;\\n        for(int i=startIndex+1;i<s.length();i++){\\n            if(s.charAt(i)==\\'(\\') stack++;\\n            else if(s.charAt(i)==\\')\\') if(--stack == 0) return i+1;\\n        }\\n        return -1;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int evaluate(String expression) {\\n        Map<String,Integer> map = new HashMap();\\n        return evaluate(expression, map);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 400354,
                "title": "cpp-no-recursion-0-8ms-9-9m-o-n-2",
                "content": "2 passes O(nlogn) algorithm:\\n\\n1. first pass to parse brackets:   \\n2. parse and execute program.\\n\\n\\n```\\n\\n\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n         \\n        string delim = \"()\";\\n        std::size_t curr(0);\\n        uint next;\\n        \\n        curr = expression.find_first_of(delim,curr);\\n        uint start = curr;\\n        \\n        std::stack<int> return_stack;\\n        std::map<uint,uint> hm;\\n        \\n        // parsing of brackets only.\\n        while (curr != std::string::npos) {\\n            \\n            switch(expression[curr]){\\n                case \\'(\\':\\n                    return_stack.push(curr);\\n                    break;\\n                case \\')\\':\\n                    hm[return_stack.top()] = (uint)curr;\\n                    return_stack.pop();\\n                break;\\n            }\\n            curr = expression.find_first_of(delim,curr+1);\\n            \\n        }\\n        \\n        \\n        std::stack<std::tuple<uint,uint,Instruction,string>> exec_point; //stack of expressions to evaluate.\\n        std::vector<std::unordered_map<string,int>> u; // vector of contexts for each calling depth.\\n        auto it1 = hm.begin();\\n        exec_point.push({it1->first +1,it1++->second,undef,\"\"}); // are we guaranteed expression in initializer list are executed sequentially ?\\n        u.push_back(std::unordered_map<string,int>());\\n\\n        while(!exec_point.empty()){\\n            \\n            auto& [ indx, end, instruction, left_val ] = exec_point.top();\\n            curr = indx;\\n            next = end;\\n            if(it1!=hm.end()){\\n                next = std::min(it1->first,next);\\n            }\\n            \\n            if(left_val != \"\"){\\n                u.back()[left_val] = return_stack.top();\\n                left_val = \"\";\\n                return_stack.pop();\\n            }\\n            \\n            std::istringstream iss(expression.substr(curr,next-curr));\\n\\n            int i(0);\\n            string s;\\n            if(instruction==undef){\\n                \\n                iss >> s;\\n                if(s==\"let\"){\\n                   instruction = let;\\n                }\\n                else if(s==\"add\"){\\n                    instruction = add;\\n                }\\n                else if(s==\"mult\"){\\n                    instruction = mult; \\n                }\\n            }\\n\\n            while(iss >> s){\\n                \\n                ++i;\\n                \\n                if(islower(s[0])){ \\n                    if(instruction!= let || \\n                       (i%2)==0 ||\\n                       iss.peek() == std::char_traits<char>::eof() ){ // variable to look up (right value). look up is O(n).\\n\\t\\t\\t\\t\\t\\tint j(u.size());\\n                        int val;\\n                        while(--j>=0){\\n                            auto it = u[j].find(s);\\n                            if(it!=u[j].end()){\\n                                val = it->second;\\n                                break;\\n                            }\\n                        }\\n                        if(left_val!=\"\"){\\n                            u.back()[left_val] = val;\\n                            left_val = \"\";\\n                        }\\n                        else{\\n                            return_stack.push(val);\\n                        }\\n                    }\\n                    else{                              // variable definition (left value).\\n                        left_val = s;\\n                    }\\n                }\\n                else{                                 // integer value.\\n                    if(left_val!=\"\"){\\n                        u.back()[left_val] = std::stoi(s);\\n                        left_val = \"\";\\n                    }\\n                    else{\\n                        return_stack.push(std::stoi(s));\\n                    }\\n                }\\n            }\\n                   \\n            switch(expression[next]){\\n                case \\'(\\':                           // new expression to evaluate.\\n                    exec_point.push({next+1,it1->second,undef,\"\"});\\n                    u.push_back(std::unordered_map<string,int>()); // new context;\\n                    indx = it1++->second + 1;         // resume there after control returns.\\n                    break;\\n                case \\')\\':                           // return value to caller.\\n                    switch(instruction){\\n                        case let:\\n                            break;\\n                        case add:{\\n                            int a=return_stack.top();\\n                            return_stack.pop();\\n                            return_stack.top()+=a;\\n                        }\\n                            break;\\n                       case mult:{\\n                            int a=return_stack.top();\\n                            return_stack.pop();\\n                            return_stack.top()*=a;\\n                       }\\n                            break;\\n                    }\\n                    u.pop_back();                  // throw context.\\n                    exec_point.pop();            // instruction removed from the evaluation stack.\\n                    break;\\n            }\\n        }\\n        return return_stack.top();\\n    }\\n        \\nprivate:\\n        \\n    enum Instruction: uint8_t {\\n        let,\\n        add,\\n        mult,\\n        undef\\n    };\\n};\\n```\\nI made a one pass version as well:\\n```\\n\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        std::size_t n = expression.length();\\n        string delim = \" ()\";\\n        std::size_t next;\\n        std::size_t curr = expression.find_first_of(\\'(\\',curr)+1;\\n        while(expression[curr]==\\' \\'){\\n            ++curr;\\n        }\\n        std::stack<int> return_stack;\\n\\n        std::vector<Instruction> instr;\\n        std::vector<string> left_val;\\n        left_val.push_back(\"\");\\n        instr.push_back(undef);\\n        std::vector<std::unordered_map<string,int>> u; // vector of contexts for each calling depth.\\n        u.push_back(std::unordered_map<string,int>());\\n\\n        while(curr < n){\\n\\n            if(left_val.back() != \"\"){\\n                u.back()[left_val.back()] = return_stack.top();\\n                left_val.back() = \"\";\\n                return_stack.pop();\\n            }\\n            \\n            if(instr.back()==undef){\\n                next = expression.find_first_of(delim,curr);\\n                std::string s = expression.substr(curr,next-curr);\\n                \\n                if(s==\"let\"){\\n                   instr.back() = let;\\n                }\\n                else if(s==\"add\"){\\n                    instr.back() = add;\\n                }\\n                else if(s==\"mult\"){\\n                    instr.back() = mult; \\n                }\\n                while(expression[next]==\\' \\'){\\n                    ++next;\\n                }   \\n                curr=next;\\n            }\\n            \\n\\n            int i(0);\\n            while(expression[curr]!= \\')\\' && expression[curr]!= \\'(\\' ){\\n                next = expression.find_first_of(delim,curr);\\n                ++i;\\n                std::string s = expression.substr(curr,next-curr);\\n                \\n                if(islower(s[0])){ \\n                    if(instr.back()!= let || \\n                       (i%2)==0 ||\\n                        expression[next] == \\')\\' ){ // variable to look up (right value).(last test will fail if unnecessry space)\\n                        int j(u.size());\\n                        int val;\\n                        while(--j>=0){\\n                            auto it = u[j].find(s);\\n                            if(it!=u[j].end()){\\n                                val = it->second;\\n                                break;\\n                            }\\n                        }\\n                        if(left_val.back()!=\"\"){\\n                            u.back()[left_val.back()] = val;\\n                            left_val.back() = \"\";\\n                        }\\n                        else{\\n                            return_stack.push(val);\\n                        }\\n                    }\\n                    else{                              // variable definition (left value).\\n                        left_val.back() = s;\\n                    }\\n                }\\n                else{                                 // integer value.\\n                    if(left_val.back()!=\"\"){\\n                        u.back()[left_val.back()] = std::stoi(s);\\n                        left_val.back() = \"\";\\n                    }\\n                    else{\\n                        return_stack.push(std::stoi(s));\\n                    }\\n                }\\n                \\n                while(expression[next]==\\' \\'){\\n                    ++next;\\n                }   \\n                curr=next;\\n            }\\n            \\n                  \\n            switch(expression[curr]){\\n                case \\'(\\':                           // new expression to evaluate.\\n                    left_val.push_back(\"\");\\n                    instr.push_back(undef);\\n                    u.push_back(std::unordered_map<string,int>()); // new context;\\n                    break;\\n                case \\')\\':                           // return value to caller.\\n                    switch(instr.back()){\\n                        case let:\\n                            break;\\n                        case add:{\\n                            int a=return_stack.top();\\n                            return_stack.pop();\\n                            return_stack.top()+=a;\\n                        }\\n                            break;\\n                       case mult:{\\n                            int a=return_stack.top();\\n                            return_stack.pop();\\n                            return_stack.top()*=a;\\n                       }\\n                            break;\\n                    }\\n                    u.pop_back();                  // throw context.\\n                    instr.pop_back();\\n                    left_val.pop_back();         // instruction removed from the evaluation stack.\\n                    break;\\n            }\\n            \\n            ++curr;\\n            while(curr<n && expression[curr]==\\' \\'){\\n                    ++curr;\\n            }   \\n        }\\n        return return_stack.top();\\n    }\\n        \\nprivate:\\n        \\n    enum Instruction: uint8_t {\\n        let,\\n        add,\\n        mult,\\n        undef\\n    };\\n};",
                "solutionTags": [],
                "code": "```\\n\\n\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n         \\n        string delim = \"()\";\\n        std::size_t curr(0);\\n        uint next;\\n        \\n        curr = expression.find_first_of(delim,curr);\\n        uint start = curr;\\n        \\n        std::stack<int> return_stack;\\n        std::map<uint,uint> hm;\\n        \\n        // parsing of brackets only.\\n        while (curr != std::string::npos) {\\n            \\n            switch(expression[curr]){\\n                case \\'(\\':\\n                    return_stack.push(curr);\\n                    break;\\n                case \\')\\':\\n                    hm[return_stack.top()] = (uint)curr;\\n                    return_stack.pop();\\n                break;\\n            }\\n            curr = expression.find_first_of(delim,curr+1);\\n            \\n        }\\n        \\n        \\n        std::stack<std::tuple<uint,uint,Instruction,string>> exec_point; //stack of expressions to evaluate.\\n        std::vector<std::unordered_map<string,int>> u; // vector of contexts for each calling depth.\\n        auto it1 = hm.begin();\\n        exec_point.push({it1->first +1,it1++->second,undef,\"\"}); // are we guaranteed expression in initializer list are executed sequentially ?\\n        u.push_back(std::unordered_map<string,int>());\\n\\n        while(!exec_point.empty()){\\n            \\n            auto& [ indx, end, instruction, left_val ] = exec_point.top();\\n            curr = indx;\\n            next = end;\\n            if(it1!=hm.end()){\\n                next = std::min(it1->first,next);\\n            }\\n            \\n            if(left_val != \"\"){\\n                u.back()[left_val] = return_stack.top();\\n                left_val = \"\";\\n                return_stack.pop();\\n            }\\n            \\n            std::istringstream iss(expression.substr(curr,next-curr));\\n\\n            int i(0);\\n            string s;\\n            if(instruction==undef){\\n                \\n                iss >> s;\\n                if(s==\"let\"){\\n                   instruction = let;\\n                }\\n                else if(s==\"add\"){\\n                    instruction = add;\\n                }\\n                else if(s==\"mult\"){\\n                    instruction = mult; \\n                }\\n            }\\n\\n            while(iss >> s){\\n                \\n                ++i;\\n                \\n                if(islower(s[0])){ \\n                    if(instruction!= let || \\n                       (i%2)==0 ||\\n                       iss.peek() == std::char_traits<char>::eof() ){ // variable to look up (right value). look up is O(n).\\n\\t\\t\\t\\t\\t\\tint j(u.size());\\n                        int val;\\n                        while(--j>=0){\\n                            auto it = u[j].find(s);\\n                            if(it!=u[j].end()){\\n                                val = it->second;\\n                                break;\\n                            }\\n                        }\\n                        if(left_val!=\"\"){\\n                            u.back()[left_val] = val;\\n                            left_val = \"\";\\n                        }\\n                        else{\\n                            return_stack.push(val);\\n                        }\\n                    }\\n                    else{                              // variable definition (left value).\\n                        left_val = s;\\n                    }\\n                }\\n                else{                                 // integer value.\\n                    if(left_val!=\"\"){\\n                        u.back()[left_val] = std::stoi(s);\\n                        left_val = \"\";\\n                    }\\n                    else{\\n                        return_stack.push(std::stoi(s));\\n                    }\\n                }\\n            }\\n                   \\n            switch(expression[next]){\\n                case \\'(\\':                           // new expression to evaluate.\\n                    exec_point.push({next+1,it1->second,undef,\"\"});\\n                    u.push_back(std::unordered_map<string,int>()); // new context;\\n                    indx = it1++->second + 1;         // resume there after control returns.\\n                    break;\\n                case \\')\\':                           // return value to caller.\\n                    switch(instruction){\\n                        case let:\\n                            break;\\n                        case add:{\\n                            int a=return_stack.top();\\n                            return_stack.pop();\\n                            return_stack.top()+=a;\\n                        }\\n                            break;\\n                       case mult:{\\n                            int a=return_stack.top();\\n                            return_stack.pop();\\n                            return_stack.top()*=a;\\n                       }\\n                            break;\\n                    }\\n                    u.pop_back();                  // throw context.\\n                    exec_point.pop();            // instruction removed from the evaluation stack.\\n                    break;\\n            }\\n        }\\n        return return_stack.top();\\n    }\\n        \\nprivate:\\n        \\n    enum Instruction: uint8_t {\\n        let,\\n        add,\\n        mult,\\n        undef\\n    };\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 395013,
                "title": "it-s-not-bad-lexical-parser-solution-using-recursive-descent-4-12ms",
                "content": "```\\nnamespace {\\nbool is_digit(char ch) { return (ch >= \\'0\\' and ch <= \\'9\\') or (ch == \\'-\\'); }\\nbool is_alphabet(char ch) { return (ch  >= \\'A\\' and ch <= \\'Z\\') or (ch  >= \\'a\\' and ch <= \\'z\\'); }\\n}\\n\\nclass tokenizer {\\n public:\\n  string str;\\n  int pos;\\n  int n;\\n  static constexpr char eof = \\'\\\\n\\';\\n\\n  tokenizer(const string &s) : str(s.begin(), s.end()), pos(0), n(s.size()) {}\\n  \\n  void trim_whitespace() {\\n    while (str[pos] == \\' \\') pos++;\\n  }\\n\\n  char peek_next_char(bool include_spaces = false) {\\n    if (include_spaces) return pos+1 < n ? str[pos + 1] : eof;\\n    for (int i = pos; i < n; ++i) {\\n      if (str[i] != \\' \\') return str[i];\\n    }\\n    return eof;\\n  }\\n\\n  vector<string> peek_next_n_string(int n) {\\n    int cur_pos = pos;\\n    auto peek_next_string_helper = [&]() -> string {\\n      string result = \"\";\\n      while (str[cur_pos] == \\' \\') cur_pos++;\\n      while (cur_pos < this->n and str[cur_pos] != \\' \\') result += str[cur_pos++];\\n      return result;\\n    };\\n    vector<string> result;\\n    for (int i = 0; i < n; ++i) result.push_back(peek_next_string_helper());\\n    return result;\\n  }\\n\\n \\n  bool has_next() {\\n    return ! peek_next_char() == eof;\\n  }\\n\\n  vector<string> next_n_strings (int n){\\n    int& cur_pos = pos;\\n    auto next_string_helper = [&]() -> string {\\n      string result = \"\";\\n      while (str[cur_pos] == \\' \\') cur_pos++;\\n      while (cur_pos < this->n and str[cur_pos] != \\' \\') result += str[cur_pos++];\\n      return result;\\n    };\\n    vector<string> result;\\n    for (int i = 0; i < n; ++i) result.push_back(next_string_helper());\\n    return result;\\n  }\\n\\n  string peek_next_string() {\\n    return peek_next_n_string(1)[0];\\n  }\\n\\n  optional<string> next_variable() {\\n    trim_whitespace();\\n    if (!is_alphabet(str[pos])) return {};\\n    string res = \"\";\\n    while (is_alphabet(str[pos]) or is_digit(str[pos])) {\\n      res += str[pos++];\\n    }\\n    return res;\\n  }\\n  \\n  string next_string() {\\n    return next_n_strings(1)[0];\\n  }\\n\\n  char next_char() {\\n    trim_whitespace();\\n    return pos < n ? str[pos++] : eof;\\n  } \\n  \\n  int next_int() {\\n    trim_whitespace();\\n    int sign = peek_next_char() == \\'-\\' ? -1 : 1;\\n    if (peek_next_char() == \\'-\\') next_char();\\n    int acc = 0;\\n    while (is_digit(str[pos])) {\\n      acc  = acc * 10 + (str[pos++] - \\'0\\');\\n    }\\n    return acc * sign;\\n  }\\n};\\n\\n\\nclass Solution {\\n public:\\n  int evaluate(string expression) {\\n    tokenizer in(expression);\\n    // could be faster if using gp_hash_table..but it doesn\\'t make a difference given the current test strength..\\n    \\n    unordered_map<string, deque<int>> variable_stack;\\n    \\n    auto is_valid_variable_name = [](const string & name) {\\n      return is_alphabet(name[0]);\\n    };\\n\\n    /* 90% correct when assume the input the proper.. but overall it\\'s a handwaivy implementation..*/\\n    auto is_valid_expression = [&](const string & s) {\\n      if (s[0] == \\'(\\')           return true; \\n      else if (s.back() == \\')\\' ) return false;\\n      else if (is_digit(s[0]))   return true;\\n      else                       return is_valid_variable_name(s);\\n    };\\n    \\n    auto is_valid_var_list = [&](const vector<string> & x) {\\n      bool has_two_values           = is_valid_variable_name(x[0]) and x[1] != \"\";\\n      bool second_is_number_or_expr = is_valid_expression(x[1]);\\n      return has_two_values and second_is_number_or_expr;\\n    };\\n\\n    /* set up for mutual recursion. this could be done in a more traditional way.. but it\\'s a bit weird when we have the\\n       full capability to solve the problem inside one function... this does reduce the performance a bit due to type \\n       erasures induced by std::function. But this is more or less inevitable for mutual recursion cases..\\n     */\\n    std::function <int(void)>  expr;\\n    std::function <int(void)>  let;\\n    std::function <int(void)>  add;\\n    std::function <int(void)>  mul;\\n    std::function <int(void)>  var;\\n    std::function <vector<pair<string, int>>(void)> var_list;\\n\\n    expr = [&]() -> int {\\n      if (in.peek_next_char() == \\'(\\') {\\n        in.next_char(); // get rid of \"(\"\\n        if      (in.peek_next_string() == \"let\")   return let();\\n        else if (in.peek_next_string() == \"add\")   return add();\\n        else if (in.peek_next_string() == \"mult\")  return mul();\\n        in.next_char(); // get rid of \")\"\\n      }\\n      else {\\n        if (is_digit(in.peek_next_char()))\\n          return in.next_int();\\n        else {\\n          // could choose not to use optional.. but it is less defensive..\\n          optional<string> var = in.next_variable();\\n          if (var.has_value()) return variable_stack[var.value()].front();\\n        }\\n      }\\n      // should throw exception if code has gone here... but whatever..\\n      return INT_MIN;\\n    };\\n\\n    let = [&]() -> int {\\n      in.next_string();  // delete \"let\"\\n      vector<pair<string, int>> local_variables = var_list();\\n      int ret = expr();\\n      in.next_char();    // delete \")\"\\n      // clear local variable in the global variable stack\\n      for (const auto & [var, val] : local_variables) {\\n        variable_stack[var].pop_front();\\n      }\\n      return ret;\\n    };\\n\\n    add = [&]() -> int {\\n      in.next_string();  // delete \"add\"\\n      int sum = expr() + expr();\\n      in.next_char();\\n      return sum;        // delete \")\"\\n    };\\n\\n    mul = [&]() -> int {\\n      in.next_string(); // delete \"mult\"\\n      int product = expr() * expr();\\n      in.next_char();\\n      return product;   // delete \")\"\\n    };\\n\\n    var_list = [&]() -> vector<pair<string, int>> {\\n      vector<pair<string, int >> new_local_vars;\\n      while (is_valid_var_list(in.peek_next_n_string(2))) {\\n        string new_var_name = in.next_string();\\n        int    new_val      = expr();\\n        variable_stack[new_var_name].emplace_front(new_val);\\n        new_local_vars.emplace_back(new_var_name, new_val);\\n      }\\n      return new_local_vars;\\n    };\\n    return expr();\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nnamespace {\\nbool is_digit(char ch) { return (ch >= \\'0\\' and ch <= \\'9\\') or (ch == \\'-\\'); }\\nbool is_alphabet(char ch) { return (ch  >= \\'A\\' and ch <= \\'Z\\') or (ch  >= \\'a\\' and ch <= \\'z\\'); }\\n}\\n\\nclass tokenizer {\\n public:\\n  string str;\\n  int pos;\\n  int n;\\n  static constexpr char eof = \\'\\\\n\\';\\n\\n  tokenizer(const string &s) : str(s.begin(), s.end()), pos(0), n(s.size()) {}\\n  \\n  void trim_whitespace() {\\n    while (str[pos] == \\' \\') pos++;\\n  }\\n\\n  char peek_next_char(bool include_spaces = false) {\\n    if (include_spaces) return pos+1 < n ? str[pos + 1] : eof;\\n    for (int i = pos; i < n; ++i) {\\n      if (str[i] != \\' \\') return str[i];\\n    }\\n    return eof;\\n  }\\n\\n  vector<string> peek_next_n_string(int n) {\\n    int cur_pos = pos;\\n    auto peek_next_string_helper = [&]() -> string {\\n      string result = \"\";\\n      while (str[cur_pos] == \\' \\') cur_pos++;\\n      while (cur_pos < this->n and str[cur_pos] != \\' \\') result += str[cur_pos++];\\n      return result;\\n    };\\n    vector<string> result;\\n    for (int i = 0; i < n; ++i) result.push_back(peek_next_string_helper());\\n    return result;\\n  }\\n\\n \\n  bool has_next() {\\n    return ! peek_next_char() == eof;\\n  }\\n\\n  vector<string> next_n_strings (int n){\\n    int& cur_pos = pos;\\n    auto next_string_helper = [&]() -> string {\\n      string result = \"\";\\n      while (str[cur_pos] == \\' \\') cur_pos++;\\n      while (cur_pos < this->n and str[cur_pos] != \\' \\') result += str[cur_pos++];\\n      return result;\\n    };\\n    vector<string> result;\\n    for (int i = 0; i < n; ++i) result.push_back(next_string_helper());\\n    return result;\\n  }\\n\\n  string peek_next_string() {\\n    return peek_next_n_string(1)[0];\\n  }\\n\\n  optional<string> next_variable() {\\n    trim_whitespace();\\n    if (!is_alphabet(str[pos])) return {};\\n    string res = \"\";\\n    while (is_alphabet(str[pos]) or is_digit(str[pos])) {\\n      res += str[pos++];\\n    }\\n    return res;\\n  }\\n  \\n  string next_string() {\\n    return next_n_strings(1)[0];\\n  }\\n\\n  char next_char() {\\n    trim_whitespace();\\n    return pos < n ? str[pos++] : eof;\\n  } \\n  \\n  int next_int() {\\n    trim_whitespace();\\n    int sign = peek_next_char() == \\'-\\' ? -1 : 1;\\n    if (peek_next_char() == \\'-\\') next_char();\\n    int acc = 0;\\n    while (is_digit(str[pos])) {\\n      acc  = acc * 10 + (str[pos++] - \\'0\\');\\n    }\\n    return acc * sign;\\n  }\\n};\\n\\n\\nclass Solution {\\n public:\\n  int evaluate(string expression) {\\n    tokenizer in(expression);\\n    // could be faster if using gp_hash_table..but it doesn\\'t make a difference given the current test strength..\\n    \\n    unordered_map<string, deque<int>> variable_stack;\\n    \\n    auto is_valid_variable_name = [](const string & name) {\\n      return is_alphabet(name[0]);\\n    };\\n\\n    /* 90% correct when assume the input the proper.. but overall it\\'s a handwaivy implementation..*/\\n    auto is_valid_expression = [&](const string & s) {\\n      if (s[0] == \\'(\\')           return true; \\n      else if (s.back() == \\')\\' ) return false;\\n      else if (is_digit(s[0]))   return true;\\n      else                       return is_valid_variable_name(s);\\n    };\\n    \\n    auto is_valid_var_list = [&](const vector<string> & x) {\\n      bool has_two_values           = is_valid_variable_name(x[0]) and x[1] != \"\";\\n      bool second_is_number_or_expr = is_valid_expression(x[1]);\\n      return has_two_values and second_is_number_or_expr;\\n    };\\n\\n    /* set up for mutual recursion. this could be done in a more traditional way.. but it\\'s a bit weird when we have the\\n       full capability to solve the problem inside one function... this does reduce the performance a bit due to type \\n       erasures induced by std::function. But this is more or less inevitable for mutual recursion cases..\\n     */\\n    std::function <int(void)>  expr;\\n    std::function <int(void)>  let;\\n    std::function <int(void)>  add;\\n    std::function <int(void)>  mul;\\n    std::function <int(void)>  var;\\n    std::function <vector<pair<string, int>>(void)> var_list;\\n\\n    expr = [&]() -> int {\\n      if (in.peek_next_char() == \\'(\\') {\\n        in.next_char(); // get rid of \"(\"\\n        if      (in.peek_next_string() == \"let\")   return let();\\n        else if (in.peek_next_string() == \"add\")   return add();\\n        else if (in.peek_next_string() == \"mult\")  return mul();\\n        in.next_char(); // get rid of \")\"\\n      }\\n      else {\\n        if (is_digit(in.peek_next_char()))\\n          return in.next_int();\\n        else {\\n          // could choose not to use optional.. but it is less defensive..\\n          optional<string> var = in.next_variable();\\n          if (var.has_value()) return variable_stack[var.value()].front();\\n        }\\n      }\\n      // should throw exception if code has gone here... but whatever..\\n      return INT_MIN;\\n    };\\n\\n    let = [&]() -> int {\\n      in.next_string();  // delete \"let\"\\n      vector<pair<string, int>> local_variables = var_list();\\n      int ret = expr();\\n      in.next_char();    // delete \")\"\\n      // clear local variable in the global variable stack\\n      for (const auto & [var, val] : local_variables) {\\n        variable_stack[var].pop_front();\\n      }\\n      return ret;\\n    };\\n\\n    add = [&]() -> int {\\n      in.next_string();  // delete \"add\"\\n      int sum = expr() + expr();\\n      in.next_char();\\n      return sum;        // delete \")\"\\n    };\\n\\n    mul = [&]() -> int {\\n      in.next_string(); // delete \"mult\"\\n      int product = expr() * expr();\\n      in.next_char();\\n      return product;   // delete \")\"\\n    };\\n\\n    var_list = [&]() -> vector<pair<string, int>> {\\n      vector<pair<string, int >> new_local_vars;\\n      while (is_valid_var_list(in.peek_next_n_string(2))) {\\n        string new_var_name = in.next_string();\\n        int    new_val      = expr();\\n        variable_stack[new_var_name].emplace_front(new_val);\\n        new_local_vars.emplace_back(new_var_name, new_val);\\n      }\\n      return new_local_vars;\\n    };\\n    return expr();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 392783,
                "title": "simple-java-o-n-beats-100-on-speed-as-well-as-memory",
                "content": "Runtime: 2 ms, faster than 100.00% of Java online submissions for Parse Lisp Expression.\\nMemory Usage: 36 MB, less than 100.00% of Java online submissions for Parse Lisp Expression.\\n\\n```\\nclass Solution {\\n    \\n    private class EvalData {\\n        int idx = 0;\\n        List<Map<String, Integer>> scopes = new ArrayList<Map<String, Integer>>();\\n    }\\n    \\n    public int evaluate(String expression) {\\n        return eval(expression, new EvalData());\\n    }\\n    \\n    private int eval(String expr, EvalData d) {\\n        if(expr.charAt(d.idx) == \\'(\\') {\\n            ++d.idx;\\n            if(expr.charAt(d.idx) == \\'a\\') {\\n                // add\\n                d.idx += \"add\".length();\\n                d.idx = skipSpace(expr, d.idx);\\n                int a = eval(expr, d);\\n                d.idx = skipSpace(expr, d.idx);\\n                int b = eval(expr, d);\\n                ++d.idx; // )\\n                return a + b;\\n            } else if(expr.charAt(d.idx) == \\'m\\') {\\n                // mult\\n                d.idx += \"mult\".length();\\n                d.idx = skipSpace(expr, d.idx);\\n                int a = eval(expr, d);\\n                d.idx = skipSpace(expr, d.idx);\\n                int b = eval(expr, d);\\n                ++d.idx; // )\\n                return a * b;\\n            } else {\\n                // let\\n                d.scopes.add(new HashMap<String, Integer>());\\n                d.idx += \"let\".length();\\n                d.idx = skipSpace(expr, d.idx);\\n                String varOrVal = \"\";\\n                int val = 0;\\n                while(expr.charAt(d.idx) != \\')\\') {\\n                    if(isChar(expr.charAt(d.idx))) {\\n                        varOrVal = getToken(expr, d.idx);\\n                        d.idx += varOrVal.length();\\n                        d.idx = skipSpace(expr, d.idx);\\n                    }\\n                    if(expr.charAt(d.idx) == \\')\\') {\\n                        // \\')\\'\\n                        // the last token (varOrVal) is the expression for the let statement\\n                        // and was a variable that should be in scope\\n                        val = getVal(varOrVal, d.scopes);\\n                    } else {\\n                        val = eval(expr, d);\\n                        d.scopes.get(d.scopes.size() - 1).put(varOrVal, val);\\n                        d.idx = skipSpace(expr, d.idx);\\n                    }\\n                }\\n                d.scopes.remove(d.scopes.size() - 1);\\n                ++d.idx; //)\\n                return val;\\n            }\\n        }\\n        \\n        // num or var\\n        if(isChar(expr.charAt(d.idx))) {\\n            String var = getToken(expr, d.idx);\\n            d.idx += var.length();\\n            d.idx = skipSpace(expr, d.idx);\\n            return getVal(var, d.scopes);\\n        }\\n        \\n        // num\\n        int sign = 1;\\n        if(expr.charAt(d.idx) == \\'-\\') {\\n            sign = -1;\\n            ++d.idx;\\n        }\\n        String numStr = getToken(expr, d.idx);\\n        d.idx += numStr.length();\\n        d.idx = skipSpace(expr, d.idx);\\n        return sign * Integer.parseInt(numStr);\\n    }\\n    \\n    private boolean isChar(char c) {\\n        return c >= \\'a\\' && c <= \\'z\\';\\n    }\\n    \\n    private int skipSpace(String expr, int idx) {\\n        while(expr.charAt(idx) == \\' \\') {\\n            ++idx;\\n        }\\n        return idx;\\n    }\\n    \\n    private String getToken(String expr, int idx) {\\n        StringBuilder sb = new StringBuilder();\\n        char c = expr.charAt(idx);\\n        while(c != \\' \\' && c != \\')\\') {\\n            ++idx;\\n            sb.append(c);\\n            c = expr.charAt(idx);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int getVal(String key, List<Map<String, Integer>> scopes) {\\n        for(int i = scopes.size() - 1; i >= 0; i--) {\\n            Map<String, Integer> currMap = scopes.get(i);\\n            if(currMap.containsKey(key)) {\\n                return currMap.get(key);\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private class EvalData {\\n        int idx = 0;\\n        List<Map<String, Integer>> scopes = new ArrayList<Map<String, Integer>>();\\n    }\\n    \\n    public int evaluate(String expression) {\\n        return eval(expression, new EvalData());\\n    }\\n    \\n    private int eval(String expr, EvalData d) {\\n        if(expr.charAt(d.idx) == \\'(\\') {\\n            ++d.idx;\\n            if(expr.charAt(d.idx) == \\'a\\') {\\n                // add\\n                d.idx += \"add\".length();\\n                d.idx = skipSpace(expr, d.idx);\\n                int a = eval(expr, d);\\n                d.idx = skipSpace(expr, d.idx);\\n                int b = eval(expr, d);\\n                ++d.idx; // )\\n                return a + b;\\n            } else if(expr.charAt(d.idx) == \\'m\\') {\\n                // mult\\n                d.idx += \"mult\".length();\\n                d.idx = skipSpace(expr, d.idx);\\n                int a = eval(expr, d);\\n                d.idx = skipSpace(expr, d.idx);\\n                int b = eval(expr, d);\\n                ++d.idx; // )\\n                return a * b;\\n            } else {\\n                // let\\n                d.scopes.add(new HashMap<String, Integer>());\\n                d.idx += \"let\".length();\\n                d.idx = skipSpace(expr, d.idx);\\n                String varOrVal = \"\";\\n                int val = 0;\\n                while(expr.charAt(d.idx) != \\')\\') {\\n                    if(isChar(expr.charAt(d.idx))) {\\n                        varOrVal = getToken(expr, d.idx);\\n                        d.idx += varOrVal.length();\\n                        d.idx = skipSpace(expr, d.idx);\\n                    }\\n                    if(expr.charAt(d.idx) == \\')\\') {\\n                        // \\')\\'\\n                        // the last token (varOrVal) is the expression for the let statement\\n                        // and was a variable that should be in scope\\n                        val = getVal(varOrVal, d.scopes);\\n                    } else {\\n                        val = eval(expr, d);\\n                        d.scopes.get(d.scopes.size() - 1).put(varOrVal, val);\\n                        d.idx = skipSpace(expr, d.idx);\\n                    }\\n                }\\n                d.scopes.remove(d.scopes.size() - 1);\\n                ++d.idx; //)\\n                return val;\\n            }\\n        }\\n        \\n        // num or var\\n        if(isChar(expr.charAt(d.idx))) {\\n            String var = getToken(expr, d.idx);\\n            d.idx += var.length();\\n            d.idx = skipSpace(expr, d.idx);\\n            return getVal(var, d.scopes);\\n        }\\n        \\n        // num\\n        int sign = 1;\\n        if(expr.charAt(d.idx) == \\'-\\') {\\n            sign = -1;\\n            ++d.idx;\\n        }\\n        String numStr = getToken(expr, d.idx);\\n        d.idx += numStr.length();\\n        d.idx = skipSpace(expr, d.idx);\\n        return sign * Integer.parseInt(numStr);\\n    }\\n    \\n    private boolean isChar(char c) {\\n        return c >= \\'a\\' && c <= \\'z\\';\\n    }\\n    \\n    private int skipSpace(String expr, int idx) {\\n        while(expr.charAt(idx) == \\' \\') {\\n            ++idx;\\n        }\\n        return idx;\\n    }\\n    \\n    private String getToken(String expr, int idx) {\\n        StringBuilder sb = new StringBuilder();\\n        char c = expr.charAt(idx);\\n        while(c != \\' \\' && c != \\')\\') {\\n            ++idx;\\n            sb.append(c);\\n            c = expr.charAt(idx);\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private int getVal(String key, List<Map<String, Integer>> scopes) {\\n        for(int i = scopes.size() - 1; i >= 0; i--) {\\n            Map<String, Integer> currMap = scopes.get(i);\\n            if(currMap.containsKey(key)) {\\n                return currMap.get(key);\\n            }\\n        }\\n        return 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 391838,
                "title": "concise-maybe-c-solution-stack-and-recursion-only-1-page-lol",
                "content": "```\\nclass Solution {\\npublic:\\n    int idx = 0;\\n    unordered_map<string, int> var;\\n    \\n    int cal(vector<string> &stk, string &str) {\\n        if(str.size() > 0) {\\n            stk.push_back(str);\\n            str = \"\";\\n        }\\n        if(stk.size() <= 1) return 0;\\n        string op = stk[0];\\n        if(op == \"add\" || op == \"mult\") {\\n            if(stk.size() != 3) return -1;\\n            int a = var.count(stk[1]) ? var[stk[1]] : stoi(stk[1]);\\n            int b = var.count(stk[2]) ? var[stk[2]] : stoi(stk[2]);\\n            return op == \"add\" ? a + b : a * b;\\n        }\\n        if(stk.size() > 2) {\\n            var[stk[1]] = var.count(stk[2]) ? var[stk[2]] : stoi(stk[2]);\\n            stk.pop_back();stk.pop_back();\\n            return -1;\\n        }\\n        if(stk.back()[0] >= \\'a\\' && stk.back()[0] <= \\'z\\') return var[stk.back()];\\n        return stoi(stk.back());\\n    }\\n    int evaluate(string &exp) {\\n        \\n        if(exp[idx] == \\'(\\'){\\n            ++idx;\\n            return evaluate(exp);\\n        }\\n        vector<string> stk;\\n        string str;\\n        while(idx < exp.size()) {\\n            if(exp[idx] == \\' \\') {\\n                cal(stk, str);\\n            }else if(exp[idx] == \\')\\'){\\n                return cal(stk, str);\\n            }\\n            else if(exp[idx] == \\'(\\'){\\n                ++idx;\\n                auto srcVar = var;\\n                stk.push_back(to_string(evaluate(exp)));\\n                var = srcVar;\\n                cal(stk, str);\\n            }else\\n                str += exp[idx];\\n            ++idx;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int idx = 0;\\n    unordered_map<string, int> var;\\n    \\n    int cal(vector<string> &stk, string &str) {\\n        if(str.size() > 0) {\\n            stk.push_back(str);\\n            str = \"\";\\n        }\\n        if(stk.size() <= 1) return 0;\\n        string op = stk[0];\\n        if(op == \"add\" || op == \"mult\") {\\n            if(stk.size() != 3) return -1;\\n            int a = var.count(stk[1]) ? var[stk[1]] : stoi(stk[1]);\\n            int b = var.count(stk[2]) ? var[stk[2]] : stoi(stk[2]);\\n            return op == \"add\" ? a + b : a * b;\\n        }\\n        if(stk.size() > 2) {\\n            var[stk[1]] = var.count(stk[2]) ? var[stk[2]] : stoi(stk[2]);\\n            stk.pop_back();stk.pop_back();\\n            return -1;\\n        }\\n        if(stk.back()[0] >= \\'a\\' && stk.back()[0] <= \\'z\\') return var[stk.back()];\\n        return stoi(stk.back());\\n    }\\n    int evaluate(string &exp) {\\n        \\n        if(exp[idx] == \\'(\\'){\\n            ++idx;\\n            return evaluate(exp);\\n        }\\n        vector<string> stk;\\n        string str;\\n        while(idx < exp.size()) {\\n            if(exp[idx] == \\' \\') {\\n                cal(stk, str);\\n            }else if(exp[idx] == \\')\\'){\\n                return cal(stk, str);\\n            }\\n            else if(exp[idx] == \\'(\\'){\\n                ++idx;\\n                auto srcVar = var;\\n                stk.push_back(to_string(evaluate(exp)));\\n                var = srcVar;\\n                cal(stk, str);\\n            }else\\n                str += exp[idx];\\n            ++idx;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 387821,
                "title": "js-solution-beats-90-91-for-speed-100-for-memory",
                "content": "```JavaScript\\n/**\\n * @param {string} expression\\n * @return {number}\\n */\\nvar evaluate = function(expression) {\\n    function get(val, stack) {\\n        // Find value\\n        let frame = stack.length-1;\\n        while (!stack[frame].has(val) && frame > 0)\\n            frame --;\\n        return stack[frame].get(val);\\n    }\\n    function assign(a, b, stack) {\\n        // Assign variable a the value of expression b, given stack\\n        stack[stack.length-1].set(a, typeof b === \"number\" ? b : get(b, stack));\\n    }\\n    \\n    function getParts(expr) {\\n        // console.log(expr);\\n        const parts = [];\\n        let open = 0;\\n        for (let s = 0, i = 0; i < expr.length; i ++) {\\n            if (expr[i] === \"(\") {\\n                open ++;\\n            } else if (expr[i] === \")\") {\\n                open --;\\n            }\\n            if ((expr[i] === \" \" || i === expr.length-1) && open === 0) {\\n                // new part\\n                parts.push(expr.slice(s, i === expr.length-1 ? i+1 : i));\\n                s = i+1;\\n            }\\n        }\\n        // console.log(parts);\\n        return parts;\\n    }\\n    \\n    return (function parse(expr, stack) {\\n        // console.log(expr);\\n        stack.push(new Map());\\n        let res;\\n        \\n        if (expr[0] === \"(\") {\\n            switch (expr.slice(1, 4)) {\\n                case \"let\": {\\n                    const parts = getParts(expr.slice(5, expr.length-1));\\n                    for (let i = 1; i < parts.length; i += 2) {\\n                        // Assign variable to expression\\n                        assign(parse(parts[i-1], stack), parse(parts[i], stack), stack);\\n                    }\\n                    res = parse(parts.pop(), stack);\\n                    if (typeof res !== \"number\")\\n                        res = get(res, stack);\\n                    break;\\n                }\\n                case \"add\": {\\n                    res = 0;\\n                    const parts = getParts(expr.slice(5, expr.length-1));\\n                    for (let i = 0; i < parts.length; i ++) {\\n                        parts[i] = parse(parts[i], stack);\\n                        if (typeof parts[i] !== \"number\")\\n                            parts[i] = get(parts[i], stack);\\n                        res += parts[i];\\n                    }\\n                    break;\\n                }\\n                case \"mul\": {\\n                    res = 1;\\n                    const parts = getParts(expr.slice(6, expr.length-1));\\n                    for (let i = 0; i < parts.length; i ++) {\\n                        parts[i] = parse(parts[i], stack);\\n                        if (typeof parts[i] !== \"number\")\\n                            parts[i] = get(parts[i], stack);\\n                        res *= parts[i];\\n                    }\\n                    break;\\n                }\\n            }\\n        } else {\\n            // Return var name or number\\n            res = isNaN(+expr) ? expr : + expr;\\n        }\\n\\n        stack.pop();\\n        return res;\\n    })(expression, []);\\n};\\n```",
                "solutionTags": [],
                "code": "```JavaScript\\n/**\\n * @param {string} expression\\n * @return {number}\\n */\\nvar evaluate = function(expression) {\\n    function get(val, stack) {\\n        // Find value\\n        let frame = stack.length-1;\\n        while (!stack[frame].has(val) && frame > 0)\\n            frame --;\\n        return stack[frame].get(val);\\n    }\\n    function assign(a, b, stack) {\\n        // Assign variable a the value of expression b, given stack\\n        stack[stack.length-1].set(a, typeof b === \"number\" ? b : get(b, stack));\\n    }\\n    \\n    function getParts(expr) {\\n        // console.log(expr);\\n        const parts = [];\\n        let open = 0;\\n        for (let s = 0, i = 0; i < expr.length; i ++) {\\n            if (expr[i] === \"(\") {\\n                open ++;\\n            } else if (expr[i] === \")\") {\\n                open --;\\n            }\\n            if ((expr[i] === \" \" || i === expr.length-1) && open === 0) {\\n                // new part\\n                parts.push(expr.slice(s, i === expr.length-1 ? i+1 : i));\\n                s = i+1;\\n            }\\n        }\\n        // console.log(parts);\\n        return parts;\\n    }\\n    \\n    return (function parse(expr, stack) {\\n        // console.log(expr);\\n        stack.push(new Map());\\n        let res;\\n        \\n        if (expr[0] === \"(\") {\\n            switch (expr.slice(1, 4)) {\\n                case \"let\": {\\n                    const parts = getParts(expr.slice(5, expr.length-1));\\n                    for (let i = 1; i < parts.length; i += 2) {\\n                        // Assign variable to expression\\n                        assign(parse(parts[i-1], stack), parse(parts[i], stack), stack);\\n                    }\\n                    res = parse(parts.pop(), stack);\\n                    if (typeof res !== \"number\")\\n                        res = get(res, stack);\\n                    break;\\n                }\\n                case \"add\": {\\n                    res = 0;\\n                    const parts = getParts(expr.slice(5, expr.length-1));\\n                    for (let i = 0; i < parts.length; i ++) {\\n                        parts[i] = parse(parts[i], stack);\\n                        if (typeof parts[i] !== \"number\")\\n                            parts[i] = get(parts[i], stack);\\n                        res += parts[i];\\n                    }\\n                    break;\\n                }\\n                case \"mul\": {\\n                    res = 1;\\n                    const parts = getParts(expr.slice(6, expr.length-1));\\n                    for (let i = 0; i < parts.length; i ++) {\\n                        parts[i] = parse(parts[i], stack);\\n                        if (typeof parts[i] !== \"number\")\\n                            parts[i] = get(parts[i], stack);\\n                        res *= parts[i];\\n                    }\\n                    break;\\n                }\\n            }\\n        } else {\\n            // Return var name or number\\n            res = isNaN(+expr) ? expr : + expr;\\n        }\\n\\n        stack.pop();\\n        return res;\\n    })(expression, []);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386962,
                "title": "java-easy-understanding-structured-recursion-solution",
                "content": "```\\n    public int evaluate(String expression) {\\n        return eval(expression, new HashMap<String,Integer>());\\n    }\\n    \\n    public int eval(String expr, Map<String,Integer> vars){\\n        if(isNum(expr)){\\n            return Integer.parseInt(expr);\\n        }\\n        \\n        if(isVar(expr)){\\n            return vars.get(expr);\\n        }\\n        \\n        List<String> exprs = exprSplit(expr);\\n        String op = exprs.get(0);\\n        if(op.equals(\"add\") || op.equals(\"mult\")){\\n            int var1 = eval(exprs.get(1),vars);\\n            int var2 = eval(exprs.get(2),vars);\\n            return op.equals(\"add\") ? var1+var2 : var1*var2;\\n        }\\n        else{\\n            Map<String,Integer> newVars = new HashMap<>(vars);\\n            for(int i=1; i<exprs.size()-1; i+=2){\\n                newVars.put(exprs.get(i), eval(exprs.get(i+1), newVars));\\n            }\\n            return eval(exprs.get(exprs.size()-1), newVars);\\n        }\\n    }\\n    \\n    public List<String> exprSplit(String expr){\\n        expr = expr.charAt(0)==\\'(\\' ? expr.substring(1,expr.length()-1) : expr;\\n        List<String> res = new ArrayList();\\n        int left = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : expr.toCharArray()){\\n            if(c==\\'(\\'){\\n                left++;\\n            }\\n            else if(c==\\')\\'){\\n                left--;\\n            }\\n            \\n            if(c==\\' \\'){\\n                if(left==0){\\n                    res.add(sb.toString());\\n                    sb.setLength(0);\\n                }\\n                else{\\n                    sb.append(c);\\n                }\\n            }\\n            else{\\n                sb.append(c);\\n            }\\n        }\\n        if(sb.length()>0){\\n            res.add(sb.toString());\\n        }\\n        return res;\\n    }\\n    \\n    public boolean isExpr(String s){\\n        return s.contains(\"(\");\\n    }\\n    \\n    public boolean isVar(String s){\\n        return s.matches(\"[a-z]+\\\\\\\\d*\");\\n    }\\n    \\n    public boolean isNum(String s){\\n        return s.matches(\"-?\\\\\\\\d+\");\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int evaluate(String expression) {\\n        return eval(expression, new HashMap<String,Integer>());\\n    }\\n    \\n    public int eval(String expr, Map<String,Integer> vars){\\n        if(isNum(expr)){\\n            return Integer.parseInt(expr);\\n        }\\n        \\n        if(isVar(expr)){\\n            return vars.get(expr);\\n        }\\n        \\n        List<String> exprs = exprSplit(expr);\\n        String op = exprs.get(0);\\n        if(op.equals(\"add\") || op.equals(\"mult\")){\\n            int var1 = eval(exprs.get(1),vars);\\n            int var2 = eval(exprs.get(2),vars);\\n            return op.equals(\"add\") ? var1+var2 : var1*var2;\\n        }\\n        else{\\n            Map<String,Integer> newVars = new HashMap<>(vars);\\n            for(int i=1; i<exprs.size()-1; i+=2){\\n                newVars.put(exprs.get(i), eval(exprs.get(i+1), newVars));\\n            }\\n            return eval(exprs.get(exprs.size()-1), newVars);\\n        }\\n    }\\n    \\n    public List<String> exprSplit(String expr){\\n        expr = expr.charAt(0)==\\'(\\' ? expr.substring(1,expr.length()-1) : expr;\\n        List<String> res = new ArrayList();\\n        int left = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(char c : expr.toCharArray()){\\n            if(c==\\'(\\'){\\n                left++;\\n            }\\n            else if(c==\\')\\'){\\n                left--;\\n            }\\n            \\n            if(c==\\' \\'){\\n                if(left==0){\\n                    res.add(sb.toString());\\n                    sb.setLength(0);\\n                }\\n                else{\\n                    sb.append(c);\\n                }\\n            }\\n            else{\\n                sb.append(c);\\n            }\\n        }\\n        if(sb.length()>0){\\n            res.add(sb.toString());\\n        }\\n        return res;\\n    }\\n    \\n    public boolean isExpr(String s){\\n        return s.contains(\"(\");\\n    }\\n    \\n    public boolean isVar(String s){\\n        return s.matches(\"[a-z]+\\\\\\\\d*\");\\n    }\\n    \\n    public boolean isNum(String s){\\n        return s.matches(\"-?\\\\\\\\d+\");\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 386791,
                "title": "python-solution-with-three-main-ideas",
                "content": "Three main things need to remember:\\n\\n1. Use recursion function to handle the nested calculation\\n2. \"let\" is tricky, because there can be multiple variable assignment, so need to have a for/while loop in \"let\" branch\\n3. scope is a pitfall. Have to use a stack contains scope dictionary\\n\\n```\\nclass Solution:\\n    def __init__(self):\\n        self.i = 0\\n        self.list = []\\n    \\n    def evaluate(self, expression):\\n        return self.eval(expression)\\n        \\n    def eval(self,expression):\\n        self.list.append(dict())\\n        ans = 0\\n        if expression[self.i] == \\'(\\':\\n            self.i += 1\\n        \\n        token = self.getToken(expression)\\n        \\n        if token == \\'add\\':\\n            self.i += 1\\n            v1 = self.eval(expression) \\n            self.i += 1\\n            v2 = self.eval(expression)\\n            \\n            ans = v1 + v2\\n        elif token == \\'mult\\':\\n            self.i += 1\\n            v1 = self.eval(expression)\\n            self.i += 1\\n            v2 = self.eval(expression)\\n            ans = v1 * v2\\n        elif token == \\'let\\':\\n            while self.i < len(expression) and expression[self.i] != \\')\\':\\n                self.i += 1\\n                if expression[self.i] == \\'(\\':\\n                    ans = self.eval(expression)\\n                    break\\n                var = self.getToken(expression)\\n                if expression[self.i] == \\')\\':\\n                    if var[0].isalpha():\\n                        ans = self.getValue(var)\\n                    else:\\n                        ans = int(var)\\n                    break\\n                self.i+=1\\n                \\n                self.list[-1][var] = self.eval(expression)\\n                #self.dic[var] = self.eval(expression)\\n\\n                #ans = self.dic[var]\\n                ans = self.list[-1][var]\\n                 \\n        elif token[0].isalpha():\\n            ans = self.getValue(token) #variable\\n        else:\\n            ans = int(token) #number\\n                \\n        \\n        print ans,self.i,len(expression)\\n        if self.i < len(expression) and expression[self.i] == \\')\\':\\n            self.i += 1\\n        del self.list[-1]\\n        return ans\\n   \\n    \\n    def getToken(self, expression):\\n        token = \"\"\\n        while self.i < len(expression):\\n            if expression[self.i] == \\' \\' or expression[self.i] == \\')\\':\\n                return token\\n            token += expression[self.i]\\n            self.i += 1\\n        return token\\n            \\n            \\n    def getValue(self, key):\\n        for i in range(len(self.list)-1,-1,-1):\\n            if key in self.list[i]:\\n                return self.list[i][key]\\n            \\n                \\n                \\n    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def __init__(self):\\n        self.i = 0\\n        self.list = []\\n    \\n    def evaluate(self, expression):\\n        return self.eval(expression)\\n        \\n    def eval(self,expression):\\n        self.list.append(dict())\\n        ans = 0\\n        if expression[self.i] == \\'(\\':\\n            self.i += 1\\n        \\n        token = self.getToken(expression)\\n        \\n        if token == \\'add\\':\\n            self.i += 1\\n            v1 = self.eval(expression) \\n            self.i += 1\\n            v2 = self.eval(expression)\\n            \\n            ans = v1 + v2\\n        elif token == \\'mult\\':\\n            self.i += 1\\n            v1 = self.eval(expression)\\n            self.i += 1\\n            v2 = self.eval(expression)\\n            ans = v1 * v2\\n        elif token == \\'let\\':\\n            while self.i < len(expression) and expression[self.i] != \\')\\':\\n                self.i += 1\\n                if expression[self.i] == \\'(\\':\\n                    ans = self.eval(expression)\\n                    break\\n                var = self.getToken(expression)\\n                if expression[self.i] == \\')\\':\\n                    if var[0].isalpha():\\n                        ans = self.getValue(var)\\n                    else:\\n                        ans = int(var)\\n                    break\\n                self.i+=1\\n                \\n                self.list[-1][var] = self.eval(expression)\\n                #self.dic[var] = self.eval(expression)\\n\\n                #ans = self.dic[var]\\n                ans = self.list[-1][var]\\n                 \\n        elif token[0].isalpha():\\n            ans = self.getValue(token) #variable\\n        else:\\n            ans = int(token) #number\\n                \\n        \\n        print ans,self.i,len(expression)\\n        if self.i < len(expression) and expression[self.i] == \\')\\':\\n            self.i += 1\\n        del self.list[-1]\\n        return ans\\n   \\n    \\n    def getToken(self, expression):\\n        token = \"\"\\n        while self.i < len(expression):\\n            if expression[self.i] == \\' \\' or expression[self.i] == \\')\\':\\n                return token\\n            token += expression[self.i]\\n            self.i += 1\\n        return token\\n            \\n            \\n    def getValue(self, key):\\n        for i in range(len(self.list)-1,-1,-1):\\n            if key in self.list[i]:\\n                return self.list[i][key]\\n            \\n                \\n                \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 385493,
                "title": "java-o-n",
                "content": "```\\nclass Solution \\n{\\n    public int evaluate(String expression) \\n    {\\n        return eval(expression, new HashMap());\\n    }\\n    \\n    int i_ = 0;\\n    int eval(String s, Map<String, Integer> map)\\n    {\\n        if (s.charAt(i_) == \\'(\\')\\n        {\\n            ++i_;\\n            if (s.charAt(i_) == \\'a\\')\\n            {\\n                // add\\n                i_ += 3;\\n                space(s);\\n                int a = eval(s, map);\\n                space(s);\\n                int b = eval(s, map);\\n                ++i_; // for \\')\\'\\n                return a + b;\\n            }\\n            else if (s.charAt(i_) == \\'m\\')\\n            {\\n                // mult\\n                i_ += 4;\\n                space(s);\\n                int a = eval(s, map);\\n                space(s);\\n                int b = eval(s, map);\\n                ++i_; // for \\')\\'\\n                return a * b;\\n            }\\n            else\\n            {\\n                // let\\n                i_ += 3;\\n                int r = 0;\\n                Map<String, Integer> next = new HashMap(map);\\n                while (true)\\n                {\\n                    space(s);\\n                    if (s.charAt(i_) == \\'(\\')\\n                    {\\n                        r = eval(s, next);\\n                        ++i_; // for \\')\\'\\n                        break;\\n                    }\\n                    else if (is_digit(s.charAt(i_)))\\n                    {\\n                        r = get_num(s);\\n                        ++i_; // for \\')\\'\\n                        break;\\n                    }\\n                    String v = get_var(s);\\n                    if (s.charAt(i_) == \\')\\')\\n                    {\\n                        ++i_;\\n                        r = next.get(v);\\n                        break;\\n                    }\\n                    space(s);\\n                    int n = eval(s, next);\\n                    next.put(v, n);\\n                }\\n                \\n                return r;\\n            }\\n        }\\n        else\\n        {\\n            // could be either a number or a variable\\n            if (is_letter(s.charAt(i_)))\\n            {\\n                String v = get_var(s);\\n                return map.get(v);\\n            }\\n            else \\n            {\\n                // number\\n                return get_num(s);\\n            }\\n        }\\n    }\\n    \\n    void space(String s)\\n    {\\n        while (i_ < s.length() && s.charAt(i_) == \\' \\')\\n        {\\n            ++i_;\\n        }\\n    }\\n    \\n    int get_num(String s)\\n    {\\n        int sign = 1;\\n        if (s.charAt(i_) == \\'-\\')\\n        {\\n            sign = -1;\\n            ++i_;\\n        }\\n        int r = 0;\\n        while (i_ < s.length() && is_digit(s.charAt(i_)))\\n        {\\n            r = 10 * r + (s.charAt(i_++) - \\'0\\');\\n        }\\n        \\n        return r * sign;\\n    }\\n    \\n    String get_var(String s)\\n    {\\n        int start = i_;\\n        while (i_ < s.length() && (is_letter(s.charAt(i_)) || is_digit(s.charAt(i_))))\\n        {\\n            ++i_;\\n        }\\n        \\n        return s.substring(start, i_);\\n    }\\n    \\n    boolean is_digit(char c)\\n    {\\n        return (c >= \\'0\\' && c <= \\'9\\') || (c == \\'-\\');\\n    }\\n    \\n    boolean is_letter(char c)\\n    {\\n        return c >= \\'a\\' && c <= \\'z\\';\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public int evaluate(String expression) \\n    {\\n        return eval(expression, new HashMap());\\n    }\\n    \\n    int i_ = 0;\\n    int eval(String s, Map<String, Integer> map)\\n    {\\n        if (s.charAt(i_) == \\'(\\')\\n        {\\n            ++i_;\\n            if (s.charAt(i_) == \\'a\\')\\n            {\\n                // add\\n                i_ += 3;\\n                space(s);\\n                int a = eval(s, map);\\n                space(s);\\n                int b = eval(s, map);\\n                ++i_; // for \\')\\'\\n                return a + b;\\n            }\\n            else if (s.charAt(i_) == \\'m\\')\\n            {\\n                // mult\\n                i_ += 4;\\n                space(s);\\n                int a = eval(s, map);\\n                space(s);\\n                int b = eval(s, map);\\n                ++i_; // for \\')\\'\\n                return a * b;\\n            }\\n            else\\n            {\\n                // let\\n                i_ += 3;\\n                int r = 0;\\n                Map<String, Integer> next = new HashMap(map);\\n                while (true)\\n                {\\n                    space(s);\\n                    if (s.charAt(i_) == \\'(\\')\\n                    {\\n                        r = eval(s, next);\\n                        ++i_; // for \\')\\'\\n                        break;\\n                    }\\n                    else if (is_digit(s.charAt(i_)))\\n                    {\\n                        r = get_num(s);\\n                        ++i_; // for \\')\\'\\n                        break;\\n                    }\\n                    String v = get_var(s);\\n                    if (s.charAt(i_) == \\')\\')\\n                    {\\n                        ++i_;\\n                        r = next.get(v);\\n                        break;\\n                    }\\n                    space(s);\\n                    int n = eval(s, next);\\n                    next.put(v, n);\\n                }\\n                \\n                return r;\\n            }\\n        }\\n        else\\n        {\\n            // could be either a number or a variable\\n            if (is_letter(s.charAt(i_)))\\n            {\\n                String v = get_var(s);\\n                return map.get(v);\\n            }\\n            else \\n            {\\n                // number\\n                return get_num(s);\\n            }\\n        }\\n    }\\n    \\n    void space(String s)\\n    {\\n        while (i_ < s.length() && s.charAt(i_) == \\' \\')\\n        {\\n            ++i_;\\n        }\\n    }\\n    \\n    int get_num(String s)\\n    {\\n        int sign = 1;\\n        if (s.charAt(i_) == \\'-\\')\\n        {\\n            sign = -1;\\n            ++i_;\\n        }\\n        int r = 0;\\n        while (i_ < s.length() && is_digit(s.charAt(i_)))\\n        {\\n            r = 10 * r + (s.charAt(i_++) - \\'0\\');\\n        }\\n        \\n        return r * sign;\\n    }\\n    \\n    String get_var(String s)\\n    {\\n        int start = i_;\\n        while (i_ < s.length() && (is_letter(s.charAt(i_)) || is_digit(s.charAt(i_))))\\n        {\\n            ++i_;\\n        }\\n        \\n        return s.substring(start, i_);\\n    }\\n    \\n    boolean is_digit(char c)\\n    {\\n        return (c >= \\'0\\' && c <= \\'9\\') || (c == \\'-\\');\\n    }\\n    \\n    boolean is_letter(char c)\\n    {\\n        return c >= \\'a\\' && c <= \\'z\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 362057,
                "title": "python-80-ms-solution-using-stack-explanation",
                "content": "variables:\\n\\t`opr`: string, the name of operation\\n\\t`params`: list, parameters\\n\\t`dic`: dictionary, key(str)->variable name, value(int)\\n\\t`stack`:list, a list of tuples. tuple->(`opr`,`params`,`dic`)\\n\\t\\nfunctions:\\n\\t`parse()`: given a string, return its value.\\n\\t\\tIf the given string cannot be converted to an interger, look up its value in `dic` or the `dic`s in `stack`.\\n\\t`calculate`: use `opr,params,dic` to calculate the value of an expression with in `(*)`. stack is also given in case a lookup in previous `dic`s is needed.\\n\\nI think this solution is pretty straightforward even though it is a bit verbose.\\n```\\nclass Solution(object):\\n    def evaluate(self, expression):\\n                \\n        def parse(s,dic,stack):\\n            try:\\n                return int(s)\\n            except ValueError:\\n                if s in dic:\\n                    return dic[s]\\n                for _,_,dic in stack[::-1]:\\n                    if s in dic:\\n                        return dic[s]\\n                print \"wrong in parse\"\\n                return\\n            \\n        def calculate(opr,params,dic,stack):\\n            if opr==\\'add\\':\\n                v1=parse(params[0],dic,stack)\\n                v2=parse(params[1],dic,stack)\\n                return v1+v2\\n            if opr==\\'mult\\':\\n                v1=parse(params[0],dic,stack)\\n                v2=parse(params[1],dic,stack)\\n                return v1*v2\\n            if opr==\\'let\\':\\n                try:\\n                    return int(params[-1])\\n                except ValueError:\\n                    i=0\\n                    while i+1<len(params):\\n                        dic[params[i]]=parse(params[i+1],dic,stack)\\n                        i+=2\\n                    return dic[params[-1]]\\n            print \"wrong in calculate\"\\n            return\\n            \\n        opr=None\\n        params=[]\\n        dic={}\\n        num=\\'\\'\\n        string=\\'\\'\\n        stack=[]\\n        for s in expression:\\n            if s==\\' \\':\\n                if opr:\\n                    if string:\\n                        params.append(string)\\n                        string=\\'\\'\\n                    if num:\\n                        params.append(int(num))\\n                        num=\\'\\'\\n                    if opr==\\'let\\':\\n                        i=0\\n                        while i+1<len(params):\\n                            dic[params[i]]=parse(params[i+1],dic,stack)\\n                            i+=2\\n                else:\\n                    opr=string\\n                    string=\\'\\'\\n                    if num:\\n                        print \"wrong while seeing space\"\\n            elif s==\\'(\\':\\n                if opr:\\n                    stack.append((opr,params,dic))\\n                    opr=None\\n                    params=[]\\n                    dic={}\\n                    num=\\'\\'\\n                    string=\\'\\'\\n            elif s==\\')\\':\\n                if string:\\n                    params.append(string)\\n                    string=\\'\\'\\n                if num:\\n                    params.append(int(num))\\n                    num=\\'\\'\\n                v=calculate(opr,params,dic,stack)\\n                if stack:\\n                    opr,params,dic=stack.pop()\\n                    params.append(v)\\n                else:\\n                    return v\\n            else:\\n                if not string and s in \\'0123456789\\':\\n                    num+=s\\n                else:\\n                    string+=s\\n        return None\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def evaluate(self, expression):\\n                \\n        def parse(s,dic,stack):\\n            try:\\n                return int(s)\\n            except ValueError:\\n                if s in dic:\\n                    return dic[s]\\n                for _,_,dic in stack[::-1]:\\n                    if s in dic:\\n                        return dic[s]\\n                print \"wrong in parse\"\\n                return\\n            \\n        def calculate(opr,params,dic,stack):\\n            if opr==\\'add\\':\\n                v1=parse(params[0],dic,stack)\\n                v2=parse(params[1],dic,stack)\\n                return v1+v2\\n            if opr==\\'mult\\':\\n                v1=parse(params[0],dic,stack)\\n                v2=parse(params[1],dic,stack)\\n                return v1*v2\\n            if opr==\\'let\\':\\n                try:\\n                    return int(params[-1])\\n                except ValueError:\\n                    i=0\\n                    while i+1<len(params):\\n                        dic[params[i]]=parse(params[i+1],dic,stack)\\n                        i+=2\\n                    return dic[params[-1]]\\n            print \"wrong in calculate\"\\n            return\\n            \\n        opr=None\\n        params=[]\\n        dic={}\\n        num=\\'\\'\\n        string=\\'\\'\\n        stack=[]\\n        for s in expression:\\n            if s==\\' \\':\\n                if opr:\\n                    if string:\\n                        params.append(string)\\n                        string=\\'\\'\\n                    if num:\\n                        params.append(int(num))\\n                        num=\\'\\'\\n                    if opr==\\'let\\':\\n                        i=0\\n                        while i+1<len(params):\\n                            dic[params[i]]=parse(params[i+1],dic,stack)\\n                            i+=2\\n                else:\\n                    opr=string\\n                    string=\\'\\'\\n                    if num:\\n                        print \"wrong while seeing space\"\\n            elif s==\\'(\\':\\n                if opr:\\n                    stack.append((opr,params,dic))\\n                    opr=None\\n                    params=[]\\n                    dic={}\\n                    num=\\'\\'\\n                    string=\\'\\'\\n            elif s==\\')\\':\\n                if string:\\n                    params.append(string)\\n                    string=\\'\\'\\n                if num:\\n                    params.append(int(num))\\n                    num=\\'\\'\\n                v=calculate(opr,params,dic,stack)\\n                if stack:\\n                    opr,params,dic=stack.pop()\\n                    params.append(v)\\n                else:\\n                    return v\\n            else:\\n                if not string and s in \\'0123456789\\':\\n                    num+=s\\n                else:\\n                    string+=s\\n        return None\\n```",
                "codeTag": "Java"
            },
            {
                "id": 361532,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    Map<String, Integer> vars = new HashMap<>();\\n\\n    public int evaluate(String expression) {\\n        String[] strs = split(expression);\\n\\n        switch (strs[0]) {\\n            case \"let\":\\n                Map<String, Integer> localVars = new HashMap<>(vars);\\n                Map temp = vars;\\n                for (int i = 1; i < strs.length - 1; i++) {\\n                    String name = strs[i];\\n                    int val = evaluate(strs[i + 1]);\\n                    if (localVars.containsKey(name)) localVars.replace(name, val);\\n                    else localVars.put(name, val);\\n                    i++;\\n                    vars = localVars;\\n                }\\n                int res = evaluate(strs[strs.length - 1]);\\n                vars = temp;\\n                return res;\\n\\n            case \"add\":\\n                return evaluate(strs[1]) + evaluate(strs[2]);\\n\\n            case \"mult\":\\n                return evaluate(strs[1]) * evaluate(strs[2]);\\n\\n            default:\\n                try {\\n                    return Integer.parseInt(strs[0]);\\n                } catch (Exception e) {\\n                    return vars.get(strs[0]);\\n                }\\n        }\\n    }\\n\\n    private String[] split(String exp) {\\n        List<String> tokens = new ArrayList<>();\\n\\n        if (exp.charAt(0) != \\'(\\') {\\n            tokens.add(exp);\\n        }\\n        else {\\n            tokens.add(exp.substring(1, exp.indexOf(\\' \\')));\\n\\n            for (int i = exp.indexOf(\\' \\') + 1; i < exp.length(); i++) {\\n                if (exp.charAt(i) == \\')\\') break;\\n                else if (exp.charAt(i) == \\' \\') continue;\\n\\n                if (tokens.get(0).equals(\"let\") && tokens.size() % 2 == 1 && exp.charAt(i) != \\'(\\' && exp.indexOf(\\' \\', i) > 0) {\\n                    tokens.add(exp.substring(i, exp.indexOf(\\' \\', i + 1)));\\n                    i = exp.indexOf(\\' \\', i + 1) + 1;\\n                }\\n\\n                if (exp.charAt(i) != \\'(\\') {\\n                    int index = exp.indexOf(\\' \\', i + 1);\\n                    if (index < 0) index = exp.indexOf(\\')\\', i + 1);\\n                    tokens.add(exp.substring(i, index).trim());\\n                    i = index;\\n                } else {\\n                    int stack = 1;\\n                    int j = i + 1;\\n                    while (stack > 0) {\\n                        if (exp.charAt(j) == \\'(\\') stack++;\\n                        else if (exp.charAt(j) == \\')\\') stack--;\\n                        j++;\\n                    }\\n                    tokens.add(exp.substring(i, j));\\n                    i = j;\\n                }\\n            }\\n        }\\n\\n        return tokens.toArray(new String[0]);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<String, Integer> vars = new HashMap<>();\\n\\n    public int evaluate(String expression) {\\n        String[] strs = split(expression);\\n\\n        switch (strs[0]) {\\n            case \"let\":\\n                Map<String, Integer> localVars = new HashMap<>(vars);\\n                Map temp = vars;\\n                for (int i = 1; i < strs.length - 1; i++) {\\n                    String name = strs[i];\\n                    int val = evaluate(strs[i + 1]);\\n                    if (localVars.containsKey(name)) localVars.replace(name, val);\\n                    else localVars.put(name, val);\\n                    i++;\\n                    vars = localVars;\\n                }\\n                int res = evaluate(strs[strs.length - 1]);\\n                vars = temp;\\n                return res;\\n\\n            case \"add\":\\n                return evaluate(strs[1]) + evaluate(strs[2]);\\n\\n            case \"mult\":\\n                return evaluate(strs[1]) * evaluate(strs[2]);\\n\\n            default:\\n                try {\\n                    return Integer.parseInt(strs[0]);\\n                } catch (Exception e) {\\n                    return vars.get(strs[0]);\\n                }\\n        }\\n    }\\n\\n    private String[] split(String exp) {\\n        List<String> tokens = new ArrayList<>();\\n\\n        if (exp.charAt(0) != \\'(\\') {\\n            tokens.add(exp);\\n        }\\n        else {\\n            tokens.add(exp.substring(1, exp.indexOf(\\' \\')));\\n\\n            for (int i = exp.indexOf(\\' \\') + 1; i < exp.length(); i++) {\\n                if (exp.charAt(i) == \\')\\') break;\\n                else if (exp.charAt(i) == \\' \\') continue;\\n\\n                if (tokens.get(0).equals(\"let\") && tokens.size() % 2 == 1 && exp.charAt(i) != \\'(\\' && exp.indexOf(\\' \\', i) > 0) {\\n                    tokens.add(exp.substring(i, exp.indexOf(\\' \\', i + 1)));\\n                    i = exp.indexOf(\\' \\', i + 1) + 1;\\n                }\\n\\n                if (exp.charAt(i) != \\'(\\') {\\n                    int index = exp.indexOf(\\' \\', i + 1);\\n                    if (index < 0) index = exp.indexOf(\\')\\', i + 1);\\n                    tokens.add(exp.substring(i, index).trim());\\n                    i = index;\\n                } else {\\n                    int stack = 1;\\n                    int j = i + 1;\\n                    while (stack > 0) {\\n                        if (exp.charAt(j) == \\'(\\') stack++;\\n                        else if (exp.charAt(j) == \\')\\') stack--;\\n                        j++;\\n                    }\\n                    tokens.add(exp.substring(i, j));\\n                    i = j;\\n                }\\n            }\\n        }\\n\\n        return tokens.toArray(new String[0]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 343638,
                "title": "python-faster-than-100",
                "content": "```Python\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        return self.calc(expression)\\n    \\n    def split_args(self, expression):\\n        stack = []\\n        result = []\\n        start = 0\\n        for i, c in enumerate(list(expression)):\\n            if c == \" \" and not stack:\\n                result.append(expression[start:i])\\n                start = i + 1\\n            if c == \"(\": stack.append(\"(\")\\n            if c == \")\": stack.pop()\\n        result.append(expression[start:])\\n        return result\\n    \\n    def calc(self, expression:str, m={}):\\n        # print(\"calc\", expression, m)\\n        if expression[0] != \\'(\\':\\n            # variable or number\\n            if expression[0].isdigit() or expression[0] == \\'-\\':\\n                return expression\\n            else:\\n                # print(m, expression)\\n                return m[expression]\\n            \\n        expression = expression[1:-1] # remove outer braces and evaluate the expr\\n        cmd, expression = expression.split(\" \", 1)\\n        args = self.split_args(expression)\\n        if cmd == \\'add\\':\\n            return str(int(self.calc(args[0], m)) + int(self.calc(args[1], m)))\\n        if cmd == \\'mult\\':\\n            return str(int(self.calc(args[0], m)) * int(self.calc(args[1], m)))\\n        if cmd == \\'let\\':\\n            n = dict(m)\\n            for i in range((len(args) - 1) // 2):\\n                n[args[2*i]] = self.calc(args[2*i + 1], n)\\n            return self.calc(args[-1], n)\\n        \\n    \\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution:\\n    def evaluate(self, expression: str) -> int:\\n        return self.calc(expression)\\n    \\n    def split_args(self, expression):\\n        stack = []\\n        result = []\\n        start = 0\\n        for i, c in enumerate(list(expression)):\\n            if c == \" \" and not stack:\\n                result.append(expression[start:i])\\n                start = i + 1\\n            if c == \"(\": stack.append(\"(\")\\n            if c == \")\": stack.pop()\\n        result.append(expression[start:])\\n        return result\\n    \\n    def calc(self, expression:str, m={}):\\n        # print(\"calc\", expression, m)\\n        if expression[0] != \\'(\\':\\n            # variable or number\\n            if expression[0].isdigit() or expression[0] == \\'-\\':\\n                return expression\\n            else:\\n                # print(m, expression)\\n                return m[expression]\\n            \\n        expression = expression[1:-1] # remove outer braces and evaluate the expr\\n        cmd, expression = expression.split(\" \", 1)\\n        args = self.split_args(expression)\\n        if cmd == \\'add\\':\\n            return str(int(self.calc(args[0], m)) + int(self.calc(args[1], m)))\\n        if cmd == \\'mult\\':\\n            return str(int(self.calc(args[0], m)) * int(self.calc(args[1], m)))\\n        if cmd == \\'let\\':\\n            n = dict(m)\\n            for i in range((len(args) - 1) // 2):\\n                n[args[2*i]] = self.calc(args[2*i + 1], n)\\n            return self.calc(args[-1], n)\\n        \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 311726,
                "title": "c-8-ms-faster-than-93-77-create-tree",
                "content": "In this solution initially I create a TREE in order to store in every node the expression and its children. Every time I have a parenthesis in a parenthesis (e.x. (add 1 (add 2 3))) I store in the outer parent Node an \"A\" in order to show that I have a value that I still do not know and I should parse to find out. \\n\\nWith this way I initially get rid of all the parenthesis and I then parse every node using an unordered_map to store within the recurtion process the variables.\\n\\n``` \\nstruct Node {\\n    std::string expression;\\n    std::queue<Node*> children;\\n    Node* parent;\\n    Node(string exp, Node* p) : expression(exp), parent(p) {};\\n};\\n\\nclass Solution {\\npublic:\\n    int evaluate(string expression) {\\n        Node* root = new Node(\"\", NULL);\\n        \\n        for (int i = 1; i < expression.size()-1; i++) {\\n            if (expression[i] == \\'(\\') {\\n                root->expression += \"A\";\\n                Node* child = new Node(\"\", root);\\n                root->children.push(child);\\n                root = child;\\n            } else if (expression[i] == \\')\\') { \\n                root = root->parent;\\n            } else {\\n                root->expression.push_back(expression[i]);\\n            }\\n        }\\n        \\n        std::unordered_map<string, int> vars;\\n        return parser(root, vars);\\n    }\\n    int parser(Node* root, std::unordered_map<string, int>& vars) {\\n        std::stringstream s(root->expression);\\n        std::string exp;\\n        getline(s, exp, \\' \\');\\n        \\n        if (exp == \"add\" || exp == \"mult\") {\\n            string v;\\n            getline(s, v, \\' \\');\\n            \\n            int var1, var2;\\n            if (v == \"A\") {\\n                std::unordered_map<string, int> m = vars;\\n                var1 = parser(root->children.front(), m);\\n                root->children.pop();\\n            } else if (v[0] == \\'-\\' || isdigit(v[0])) {\\n                var1 = stoi(v);\\n            } else {\\n                var1 = vars[v];\\n            }\\n            getline(s, v, \\' \\');\\n            if (v == \"A\") {\\n                std::unordered_map<string, int> m = vars;\\n                var2 = parser(root->children.front(), m);\\n                root->children.pop();\\n            } else if (v[0] == \\'-\\' || isdigit(v[0])) {\\n                var2 = stoi(v);\\n            } else {\\n                var2 = vars[v];\\n            }\\n            if (exp == \"add\") {\\n                return var1+var2;\\n            } else {\\n                return var1*var2;\\n            }\\n        } else {\\n            std::string tmp, v;\\n            int last = 0, i = 1;\\n            while (getline(s, v, \\' \\')) {\\n                if (v == \"A\") {\\n                    last = parser(root->children.front(), vars);\\n                    root->children.pop();\\n                    vars[tmp] = last;\\n                } else if (v[0] == \\'-\\' || isdigit(v[0])) {\\n                    last = stoi(v);\\n                    vars[tmp] = last;\\n                } else {\\n                    if (i%2 == 0) {\\n                        last = vars[v];\\n                        vars[tmp] = last;\\n                    } else {\\n                        tmp = v;\\n                    }\\n                }\\n                i++;\\n            }            \\n            return vars[tmp];\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int evaluate(string expression) {\\n        Node* root = new Node(\"\", NULL);\\n        \\n        for (int i = 1; i < expression.size()-1; i++) {\\n            if (expression[i] == \\'(\\') {\\n                root->expression += \"A\";\\n                Node* child = new Node(\"\", root);\\n                root->children.push(child);\\n                root = child;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 311337,
                "title": "c-beats-99-time-92-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    int evaluate(string expr) {\\n        int pos = 0;\\n        vector<unordered_map<string, int>> envs;\\n        try {\\n            return evaluate_helper(expr, pos, envs);\\n        } catch (char* str) {\\n            cerr << str << endl;\\n            return -1;\\n        }\\n    }\\n    private:\\n    // Evaluate expr at pos, and also move pos to next character\\n    int evaluate_helper(string const& expr, \\n                       int& pos, \\n                       vector<unordered_map<string, int>>& envs) {\\n        string token = readToken(expr, pos);\\n        if (token == \"(\") {\\n            int ret = evaluate_helper(expr, pos, envs);\\n            if (readToken(expr, pos) != \")\") {\\n                throw \"Expect parenthesis\";\\n            }\\n            return ret;\\n        } else if (token == \"let\") {\\n            envs.push_back(unordered_map<string, int>{});\\n            while (isVar(peekToken(expr, pos))) {  // \"early discovery\", just end loop\\n                int tmp_pos = pos; // Note the last clause of let is not context-free.\\n                                   // We store the pos here for potential restoring.\\n                string var = readToken(expr, pos);\\n                if (peekToken(expr, pos) == \")\") { // \"late discovery\", need to restore\\n                    pos = tmp_pos;\\n                    break;\\n                } else {\\n                    int val = evaluate_helper(expr, pos, envs);\\n                    envs.back()[var] = val;\\n                }\\n            }\\n            int ret = evaluate_helper(expr, pos, envs);\\n            envs.pop_back();\\n            return ret;\\n        } else if (token == \"add\") {\\n            return evaluate_helper(expr, pos, envs) \\n                   + evaluate_helper(expr, pos, envs);\\n        } else if (token == \"mult\") {\\n            return evaluate_helper(expr, pos, envs)\\n                   * evaluate_helper(expr, pos, envs);\\n        } else if (isVar(token)) {\\n                return lookupVal(token, envs);\\n        } else {\\n            try {\\n                return stoi(token);\\n            } catch (...) {\\n                throw \"Malformed\";\\n            }\\n            \\n        }\\n    }\\n                   \\n    int lookupVal(string const& token, vector<unordered_map<string, int>> const& envs) {\\n        for (auto it = envs.rbegin(); it != envs.rend(); ++it) {\\n            if (it->count(token)) {\\n                return it->at(token);\\n            }\\n        }\\n        throw \"Undefined variable\";\\n    }\\n    \\n    // Read token at pos, and also move pos to next character.\\n    // Note \"(\" and \")\" are treated as independent tokens.\\n    string readToken(string const& expr, int& pos) {\\n        for (; pos < expr.length() \\n               && expr[pos] == \\' \\'; ++pos);\\n        if (pos >= expr.length()) return \"\";\\n        if (expr[pos] == \\'(\\') {\\n            ++pos;\\n            return \"(\";\\n        }\\n        if (expr[pos] == \\')\\') {\\n            ++pos;\\n            return \")\";\\n        }\\n        string ret;\\n        for (; expr[pos] != \\' \\' \\n               && expr[pos] != \\'(\\'\\n               && expr[pos] != \\')\\'; ++pos) {\\n            ret += expr[pos];\\n        }\\n        return ret;\\n    }\\n    \\n    string peekToken(string const& expr, int pos) {\\n        // Just re-use readToken with a copied pos\\n        return readToken(expr, pos);\\n    }\\n    \\n    bool isVar(string const& token) {\\n        if (token.empty()) return false;\\n        if (! std::isalpha(token[0])) return false;\\n        int n = token.length();\\n        for (int i = 1; i < n; ++i) {\\n            if (! std::isalnum(token[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int evaluate(string expr) {\\n        int pos = 0;\\n        vector<unordered_map<string, int>> envs;\\n        try {\\n            return evaluate_helper(expr, pos, envs);\\n        } catch (char* str) {\\n            cerr << str << endl;\\n            return -1;\\n        }\\n    }\\n    private:\\n    // Evaluate expr at pos, and also move pos to next character\\n    int evaluate_helper(string const& expr, \\n                       int& pos, \\n                       vector<unordered_map<string, int>>& envs) {\\n        string token = readToken(expr, pos);\\n        if (token == \"(\") {\\n            int ret = evaluate_helper(expr, pos, envs);\\n            if (readToken(expr, pos) != \")\") {\\n                throw \"Expect parenthesis\";\\n            }\\n            return ret;\\n        } else if (token == \"let\") {\\n            envs.push_back(unordered_map<string, int>{});\\n            while (isVar(peekToken(expr, pos))) {  // \"early discovery\", just end loop\\n                int tmp_pos = pos; // Note the last clause of let is not context-free.\\n                                   // We store the pos here for potential restoring.\\n                string var = readToken(expr, pos);\\n                if (peekToken(expr, pos) == \")\") { // \"late discovery\", need to restore\\n                    pos = tmp_pos;\\n                    break;\\n                } else {\\n                    int val = evaluate_helper(expr, pos, envs);\\n                    envs.back()[var] = val;\\n                }\\n            }\\n            int ret = evaluate_helper(expr, pos, envs);\\n            envs.pop_back();\\n            return ret;\\n        } else if (token == \"add\") {\\n            return evaluate_helper(expr, pos, envs) \\n                   + evaluate_helper(expr, pos, envs);\\n        } else if (token == \"mult\") {\\n            return evaluate_helper(expr, pos, envs)\\n                   * evaluate_helper(expr, pos, envs);\\n        } else if (isVar(token)) {\\n                return lookupVal(token, envs);\\n        } else {\\n            try {\\n                return stoi(token);\\n            } catch (...) {\\n                throw \"Malformed\";\\n            }\\n            \\n        }\\n    }\\n                   \\n    int lookupVal(string const& token, vector<unordered_map<string, int>> const& envs) {\\n        for (auto it = envs.rbegin(); it != envs.rend(); ++it) {\\n            if (it->count(token)) {\\n                return it->at(token);\\n            }\\n        }\\n        throw \"Undefined variable\";\\n    }\\n    \\n    // Read token at pos, and also move pos to next character.\\n    // Note \"(\" and \")\" are treated as independent tokens.\\n    string readToken(string const& expr, int& pos) {\\n        for (; pos < expr.length() \\n               && expr[pos] == \\' \\'; ++pos);\\n        if (pos >= expr.length()) return \"\";\\n        if (expr[pos] == \\'(\\') {\\n            ++pos;\\n            return \"(\";\\n        }\\n        if (expr[pos] == \\')\\') {\\n            ++pos;\\n            return \")\";\\n        }\\n        string ret;\\n        for (; expr[pos] != \\' \\' \\n               && expr[pos] != \\'(\\'\\n               && expr[pos] != \\')\\'; ++pos) {\\n            ret += expr[pos];\\n        }\\n        return ret;\\n    }\\n    \\n    string peekToken(string const& expr, int pos) {\\n        // Just re-use readToken with a copied pos\\n        return readToken(expr, pos);\\n    }\\n    \\n    bool isVar(string const& token) {\\n        if (token.empty()) return false;\\n        if (! std::isalpha(token[0])) return false;\\n        int n = token.length();\\n        for (int i = 1; i < n; ++i) {\\n            if (! std::isalnum(token[i])) {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307150,
                "title": "java-4ms-95-19",
                "content": "from yinwang\\u2018s  http://www.yinwang.org/blog-cn/2012/08/01/interpreter\\n\\nJava does not have a S-express and pattern match\\uFF0C so if you don\\'t hava enough time\\uFF0Cyou dont need to creare the ast\\uFF0Cjust interperter in string\\n\\n```java\\nclass Solution {\\n    \\n    //cost me 13:05~16:33\\n    public int evaluate(String expression) {\\n        return eval(expression, null); \\n    }\\n    \\n    //bind tokenizer and eval together\\n    public int eval(String s, Map<String,Object> env){\\n        //System.out.println(\"eval [\" + s + \"], env=\" + env);\\n        char c0 = s.charAt(0);\\n        // (? number? x) x\\n        if(Character.isDigit(c0) || c0 == \\'-\\' ){\\n            return Integer.valueOf(s);\\n        }\\n        // A variable starts with a lowercase letter, then zero or more lowercase letters or digits\\n        // (? symbol? x) (lookup x env)\\n        if(Character.isLetter(c0)){\\n            return lookup(s, env);\\n        }\\n        // always start with \\'(\\', it won\\'t covert to ASTs, but strings for better performance.\\n\\t\\t// if for better performance, you can record the index rather create a new string\\n        List<String> exprs = tokenize(s);\\n        switch(exprs.get(0)){\\n            case \"add\":\\n                return eval(exprs.get(1), env) + eval(exprs.get(2), env);\\n            case \"mult\":\\n                return eval(exprs.get(1), env) * eval(exprs.get(2), env);\\n            case \"let\":\\n                env = extEnv(env);\\n                for(int j=1;j+1<exprs.size();j += 2){\\n                    int val = eval(exprs.get(j+1), env);\\n                    env.put(exprs.get(j), val);\\n                    //System.out.println(\"put \" + exprs.get(j) + \": \" + val);\\n                }\\n                return eval(exprs.get(exprs.size()-1), env);\\n            default:\\n                return -1;\\n        }\\n    }\\n    \\n    // remove duo par(`(`,`)`), split with space, no depth\\n    public List<String> tokenize(String s){\\n        List<String> exprs = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        int lpad = 0; //as a stack\\n        for(int i =0;i<s.length();i++){\\n            char c  = s.charAt(i);\\n            switch(c){\\n                case \\'(\\':\\n                    if(lpad>0){\\n                        sb.append(c);\\n                    } else{\\n                        //\\n                    }\\n                    lpad++;\\n                    break;\\n                case \\')\\':\\n                    // ( let x 2 (mult x (let x 3 y 4 (add x y)  )  )  )\\n                    //0  1         2       3            4       3  2  1  0\\n                    if(lpad > 1){\\n                       sb.append(c);\\n                    } else{\\n                        exprs.add(sb.toString());\\n                        sb.setLength(0);\\n                    }\\n                    lpad--;\\n                    break;\\n                case \\' \\':\\n                    if(lpad > 1){\\n                        sb.append(c);\\n                    } else{\\n                        exprs.add(sb.toString());\\n                        sb.setLength(0);                   \\n                    }\\n                    break;\\n                default:\\n                    sb.append(c);\\n                    break;\\n            }\\n        }\\n        if(sb.length() > 0){\\n            exprs.add(sb.toString());\\n        }\\n        return exprs;\\n    }\\n    \\n    // lexical scoping, I won\\'t override the parent map\\n    public Map<String,Object> extEnv( Map<String,Object> parent){\\n        Map<String,Object> env = new HashMap<>();\\n        if(parent != null){\\n            // a trick, the better way is to create an Env class with a parent and a map\\n\\t\\t\\t//  like OGNL Context(ognl.OgnlContext),\\n            env.put(\"_parent_\", parent);\\n        }\\n        return env;\\n    }\\n    \\n    public Integer lookup( String key, Map<String,Object> env){\\n        //System.out.println(\"lookup [\" + key + \"], env=\" + env);\\n        if(env == null){\\n            throw new RuntimeException(key + \" is undefined\");\\n        }\\n        Object v = env.get(key);\\n        if(v != null){\\n            return (Integer)v;\\n        }\\n        return lookup(key, (Map<String,Object>)env.get(\"_parent_\"));\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    \\n    //cost me 13:05~16:33\\n    public int evaluate(String expression) {\\n        return eval(expression, null); \\n    }\\n    \\n    //bind tokenizer and eval together\\n    public int eval(String s, Map<String,Object> env){\\n        //System.out.println(\"eval [\" + s + \"], env=\" + env);\\n        char c0 = s.charAt(0);\\n        // (? number? x) x\\n        if(Character.isDigit(c0) || c0 == \\'-\\' ){\\n            return Integer.valueOf(s);\\n        }\\n        // A variable starts with a lowercase letter, then zero or more lowercase letters or digits\\n        // (? symbol? x) (lookup x env)\\n        if(Character.isLetter(c0)){\\n            return lookup(s, env);\\n        }\\n        // always start with \\'(\\', it won\\'t covert to ASTs, but strings for better performance.\\n\\t\\t// if for better performance, you can record the index rather create a new string\\n        List<String> exprs = tokenize(s);\\n        switch(exprs.get(0)){\\n            case \"add\":\\n                return eval(exprs.get(1), env) + eval(exprs.get(2), env);\\n            case \"mult\":\\n                return eval(exprs.get(1), env) * eval(exprs.get(2), env);\\n            case \"let\":\\n                env = extEnv(env);\\n                for(int j=1;j+1<exprs.size();j += 2){\\n                    int val = eval(exprs.get(j+1), env);\\n                    env.put(exprs.get(j), val);\\n                    //System.out.println(\"put \" + exprs.get(j) + \": \" + val);\\n                }\\n                return eval(exprs.get(exprs.size()-1), env);\\n            default:\\n                return -1;\\n        }\\n    }\\n    \\n    // remove duo par(`(`,`)`), split with space, no depth\\n    public List<String> tokenize(String s){\\n        List<String> exprs = new ArrayList<>();\\n        StringBuilder sb = new StringBuilder();\\n        int lpad = 0; //as a stack\\n        for(int i =0;i<s.length();i++){\\n            char c  = s.charAt(i);\\n            switch(c){\\n                case \\'(\\':\\n                    if(lpad>0){\\n                        sb.append(c);\\n                    } else{\\n                        //\\n                    }\\n                    lpad++;\\n                    break;\\n                case \\')\\':\\n                    // ( let x 2 (mult x (let x 3 y 4 (add x y)  )  )  )\\n                    //0  1         2       3            4       3  2  1  0\\n                    if(lpad > 1){\\n                       sb.append(c);\\n                    } else{\\n                        exprs.add(sb.toString());\\n                        sb.setLength(0);\\n                    }\\n                    lpad--;\\n                    break;\\n                case \\' \\':\\n                    if(lpad > 1){\\n                        sb.append(c);\\n                    } else{\\n                        exprs.add(sb.toString());\\n                        sb.setLength(0);                   \\n                    }\\n                    break;\\n                default:\\n                    sb.append(c);\\n                    break;\\n            }\\n        }\\n        if(sb.length() > 0){\\n            exprs.add(sb.toString());\\n        }\\n        return exprs;\\n    }\\n    \\n    // lexical scoping, I won\\'t override the parent map\\n    public Map<String,Object> extEnv( Map<String,Object> parent){\\n        Map<String,Object> env = new HashMap<>();\\n        if(parent != null){\\n            // a trick, the better way is to create an Env class with a parent and a map\\n\\t\\t\\t//  like OGNL Context(ognl.OgnlContext),\\n            env.put(\"_parent_\", parent);\\n        }\\n        return env;\\n    }\\n    \\n    public Integer lookup( String key, Map<String,Object> env){\\n        //System.out.println(\"lookup [\" + key + \"], env=\" + env);\\n        if(env == null){\\n            throw new RuntimeException(key + \" is undefined\");\\n        }\\n        Object v = env.get(key);\\n        if(v != null){\\n            return (Integer)v;\\n        }\\n        return lookup(key, (Map<String,Object>)env.get(\"_parent_\"));\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 306617,
                "title": "ultral-short-python-recurssive-solution",
                "content": "ULTRAL SHORT Python recurssive solution.\\n\\nfirst tokenize the expression. \\n\\nthere are several tokens.\\n1. variable name, \\\\[a-z][a-z|0-9]*\\n2. \"let\",\"add\",\"mult\"\\n3. number, -* [0-9]+\\n4. \"(\", \")\"\\n\\ndefine a function which will return the first complete expression.\\n\\nfor any expression, there are several cases,\\n\\n 1. a number (can be negative), use try, except ValueError\\n 2. a variablm, just return the value found in scope\\n 3. add or mul. get next two expressions, evaluate them, and return the computed sum or product\\n 4. let, this is the most tricy one. first, get all the following expressions, loop over the varialbe name , expression pairs, evaluate the expression, put the value into local scope. finally, return the value of the last expression.\\n\\n```Python\\nclass Solution(object):\\n    def evaluate(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: int\\n        \"\"\"\\n        #tokenize the expression\\n        tokens = re.findall(\"[a-z][a-z|0-9]*|let|add|mult|\\\\-*[0-9]+|\\\\(|\\\\)\", expression)\\n        \\n        ## find the first complete expression in a substring\\n        def find_next_expr(tokens):\\n            #print \"findnext\", tokens\\n            #if(tokens[0].isdigit()): return tokens[0]\\n            try:\\n                int(tokens[0])\\n                return [tokens[0]]\\n            except ValueError:\\n                pass\\n            \\n            if(tokens[0]==\\'(\\'):\\n                s = []\\n                for i in range(len(tokens)):\\n                    if(tokens[i]==\\'(\\'): s.append(\"(\")\\n                    if(tokens[i]==\\')\\' and s[-1] == \"(\"): \\n                        s.pop()\\n                        if(len(s)==0): return tokens[:i+1]\\n            return [tokens[0]]\\n        \\n        \\n        def eval_expr(tokens, values):\\n            local_values = dict(values) # copy the parent values\\n            \\n            ## if the expression starts with let, add, mult\\n            if(tokens[0]==\"(\"):\\n                if(tokens[1]==\"add\" or tokens[1]==\"mult\"):\\n                    expr1 = find_next_expr(tokens[2:])\\n                    expr2 = find_next_expr(tokens[2+len(expr1):])\\n                    res1 = eval_expr(expr1, local_values)\\n                    res2 = eval_expr(expr2, local_values)\\n                    #print \"next\", expr1, \"and\", expr2\\n                    if(tokens[1]==\"add\"): return res1+res2\\n                    else: return res1*res2\\n                \\n                ## deal with let expression\\n                exprs = []\\n                remain_tokens = tokens[2:-1]\\n                #print \"remain_tokens\", remain_tokens\\n                while(remain_tokens):\\n                    expr = find_next_expr(remain_tokens)\\n                    exprs.append(expr)\\n                    remain_tokens = remain_tokens[len(expr):]\\n                    #print expr, remain_tokens, len(expr)\\n                for i in range(len(exprs)//2):\\n                    var_i = exprs[2*i][0]\\n                    expr_i = exprs[2*i+1]\\n                    res_i = eval_expr(expr_i, local_values)\\n                    local_values[var_i] = res_i #assign var in local scope\\n\\n                return eval_expr(exprs[-1], local_values)\\n                    \\n            ## if the expression is a number\\n            try: \\n                x = int(tokens[0])\\n                return x\\n            except ValueError:\\n                pass\\n            \\n            ## if the expression is a variable name\\n            return values[tokens[0]]\\n            \\n        res = eval_expr(tokens, {})\\n        return res\\n```",
                "solutionTags": [],
                "code": "```Python\\nclass Solution(object):\\n    def evaluate(self, expression):\\n        \"\"\"\\n        :type expression: str\\n        :rtype: int\\n        \"\"\"\\n        #tokenize the expression\\n        tokens = re.findall(\"[a-z][a-z|0-9]*|let|add|mult|\\\\-*[0-9]+|\\\\(|\\\\)\", expression)\\n        \\n        ## find the first complete expression in a substring\\n        def find_next_expr(tokens):\\n            #print \"findnext\", tokens\\n            #if(tokens[0].isdigit()): return tokens[0]\\n            try:\\n                int(tokens[0])\\n                return [tokens[0]]\\n            except ValueError:\\n                pass\\n            \\n            if(tokens[0]==\\'(\\'):\\n                s = []\\n                for i in range(len(tokens)):\\n                    if(tokens[i]==\\'(\\'): s.append(\"(\")\\n                    if(tokens[i]==\\')\\' and s[-1] == \"(\"): \\n                        s.pop()\\n                        if(len(s)==0): return tokens[:i+1]\\n            return [tokens[0]]\\n        \\n        \\n        def eval_expr(tokens, values):\\n            local_values = dict(values) # copy the parent values\\n            \\n            ## if the expression starts with let, add, mult\\n            if(tokens[0]==\"(\"):\\n                if(tokens[1]==\"add\" or tokens[1]==\"mult\"):\\n                    expr1 = find_next_expr(tokens[2:])\\n                    expr2 = find_next_expr(tokens[2+len(expr1):])\\n                    res1 = eval_expr(expr1, local_values)\\n                    res2 = eval_expr(expr2, local_values)\\n                    #print \"next\", expr1, \"and\", expr2\\n                    if(tokens[1]==\"add\"): return res1+res2\\n                    else: return res1*res2\\n                \\n                ## deal with let expression\\n                exprs = []\\n                remain_tokens = tokens[2:-1]\\n                #print \"remain_tokens\", remain_tokens\\n                while(remain_tokens):\\n                    expr = find_next_expr(remain_tokens)\\n                    exprs.append(expr)\\n                    remain_tokens = remain_tokens[len(expr):]\\n                    #print expr, remain_tokens, len(expr)\\n                for i in range(len(exprs)//2):\\n                    var_i = exprs[2*i][0]\\n                    expr_i = exprs[2*i+1]\\n                    res_i = eval_expr(expr_i, local_values)\\n                    local_values[var_i] = res_i #assign var in local scope\\n\\n                return eval_expr(exprs[-1], local_values)\\n                    \\n            ## if the expression is a number\\n            try: \\n                x = int(tokens[0])\\n                return x\\n            except ValueError:\\n                pass\\n            \\n            ## if the expression is a variable name\\n            return values[tokens[0]]\\n            \\n        res = eval_expr(tokens, {})\\n        return res\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564809,
                "content": [
                    {
                        "username": "evanl1208",
                        "content": "Such problem might be good for ACM contest, but definitely not good for interview. With such a long explanation of the problem itself, I don't think it is a good one for interview. Better to select some practical interview problem as contest problem. Just my two cents. Don't want Leetcode to be congested with lot of non-interview coding problem."
                    },
                    {
                        "username": "supredee",
                        "content": "I personally dislike long explanation to a problem but if you ever have to take coding assessment on HackerRank that place design to confuse you with words!"
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem, in contrast to most of other problems, is close to what I do at work sometimes \\uD83D\\uDC4D"
                    },
                    {
                        "username": "username100500",
                        "content": "I got lot of fun solving the problem. I wish you the same - enjoy the process!"
                    }
                ]
            },
            {
                "id": 1791914,
                "content": [
                    {
                        "username": "evanl1208",
                        "content": "Such problem might be good for ACM contest, but definitely not good for interview. With such a long explanation of the problem itself, I don't think it is a good one for interview. Better to select some practical interview problem as contest problem. Just my two cents. Don't want Leetcode to be congested with lot of non-interview coding problem."
                    },
                    {
                        "username": "supredee",
                        "content": "I personally dislike long explanation to a problem but if you ever have to take coding assessment on HackerRank that place design to confuse you with words!"
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem, in contrast to most of other problems, is close to what I do at work sometimes \\uD83D\\uDC4D"
                    },
                    {
                        "username": "username100500",
                        "content": "I got lot of fun solving the problem. I wish you the same - enjoy the process!"
                    }
                ]
            },
            {
                "id": 1795583,
                "content": [
                    {
                        "username": "evanl1208",
                        "content": "Such problem might be good for ACM contest, but definitely not good for interview. With such a long explanation of the problem itself, I don't think it is a good one for interview. Better to select some practical interview problem as contest problem. Just my two cents. Don't want Leetcode to be congested with lot of non-interview coding problem."
                    },
                    {
                        "username": "supredee",
                        "content": "I personally dislike long explanation to a problem but if you ever have to take coding assessment on HackerRank that place design to confuse you with words!"
                    },
                    {
                        "username": "Finesse",
                        "content": "This problem, in contrast to most of other problems, is close to what I do at work sometimes \\uD83D\\uDC4D"
                    },
                    {
                        "username": "username100500",
                        "content": "I got lot of fun solving the problem. I wish you the same - enjoy the process!"
                    }
                ]
            }
        ]
    }
]